//
// Generated by Bluespec Compiler, version 2021.12.1-27-g9a7d5e05 (build 9a7d5e05)
//
//
// Ports:
// Name                         I/O  size props
// fabric_HRDATA                  O    32 reg
// fabric_HREADYOUT               O     1 reg
// fabric_HRESP                   O     1 reg
// timer_interrupt_pending        O     1 reg
// sw_interrupt_pending           O     1 reg
// CLK                            I     1 clock
// RST_N                          I     1 reset
// fabric_HSEL                    I     1
// fabric_HREADY                  I     1
// fabric_HADDR                   I    32
// fabric_HBURST                  I     3 unused
// fabric_HMASTLOCK               I     1 unused
// fabric_HPROT                   I     4 unused
// fabric_HSIZE                   I     3
// fabric_HTRANS                  I     2
// fabric_HWDATA                  I    32
// fabric_HWRITE                  I     1 reg
//
// No combinational paths from inputs to outputs
//
//
// This module does not conduct address range checks.
// It is assumed that address range checks are the
// responsibility of the system AHB-L decoder.
//
//

`ifdef BSV_ASSIGNMENT_DELAY
`else
  `define BSV_ASSIGNMENT_DELAY
`endif

`ifdef BSV_POSITIVE_RESET
  `define BSV_RESET_VALUE 1'b1
  `define BSV_RESET_EDGE posedge
`else
  `define BSV_RESET_VALUE 1'b0
  `define BSV_RESET_EDGE negedge
`endif

module mkCLINT_AHBL(CLK,
		    RST_N,

		    fabric_HSEL,

		    fabric_HREADY,

		    fabric_HADDR,

		    fabric_HBURST,

		    fabric_HMASTLOCK,

		    fabric_HPROT,

		    fabric_HSIZE,

		    fabric_HTRANS,

		    fabric_HWDATA,

		    fabric_HWRITE,

		    fabric_HRDATA,

		    fabric_HREADYOUT,

		    fabric_HRESP,

		    timer_interrupt_pending,

		    sw_interrupt_pending);
  input  CLK;
  input  RST_N;

  // action method fabric_hsel
  input  fabric_HSEL;

  // action method fabric_hready
  input  fabric_HREADY;

  // action method fabric_haddr
  input  [31 : 0] fabric_HADDR;

  // action method fabric_hburst
  input  [2 : 0] fabric_HBURST;

  // action method fabric_hmastlock
  input  fabric_HMASTLOCK;

  // action method fabric_hprot
  input  [3 : 0] fabric_HPROT;

  // action method fabric_hsize
  input  [2 : 0] fabric_HSIZE;

  // action method fabric_htrans
  input  [1 : 0] fabric_HTRANS;

  // action method fabric_hwdata
  input  [31 : 0] fabric_HWDATA;

  // action method fabric_hwrite
  input  fabric_HWRITE;

  // value method fabric_hrdata
  output [31 : 0] fabric_HRDATA;

  // value method fabric_hreadyout
  output fabric_HREADYOUT;

  // value method fabric_hresp
  output fabric_HRESP;

  // value method timer_interrupt_pending
  output timer_interrupt_pending;

  // value method sw_interrupt_pending
  output sw_interrupt_pending;

  // signals for module outputs
  wire [31 : 0] fabric_HRDATA;
  wire fabric_HREADYOUT,
       fabric_HRESP,
       sw_interrupt_pending,
       timer_interrupt_pending;

  // inlined wires
  wire [63 : 0] crg_time$port0__write_1,
		crg_time$port1__read,
		crg_time$port1__write_1,
		crg_time$port2__read,
		crg_timecmp$port1__write_1,
		crg_timecmp$port2__read;
  wire crg_time$EN_port1__write, crg_timecmp$EN_port1__write;

  // register crg_time
  reg [63 : 0] crg_time;
  wire [63 : 0] crg_time$D_IN;
  wire crg_time$EN;

  // register crg_timecmp
  reg [63 : 0] crg_timecmp;
  wire [63 : 0] crg_timecmp$D_IN;
  wire crg_timecmp$EN;

  // register rg_haddr
  reg [31 : 0] rg_haddr;
  wire [31 : 0] rg_haddr$D_IN;
  wire rg_haddr$EN;

  // register rg_hrdata
  reg [31 : 0] rg_hrdata;
  reg [31 : 0] rg_hrdata$D_IN;
  wire rg_hrdata$EN;

  // register rg_hready
  reg rg_hready;
  reg rg_hready$D_IN;
  wire rg_hready$EN;

  // register rg_hresp
  reg rg_hresp;
  reg rg_hresp$D_IN;
  wire rg_hresp$EN;

  // register rg_hsize
  reg [2 : 0] rg_hsize;
  wire [2 : 0] rg_hsize$D_IN;
  wire rg_hsize$EN;

  // register rg_htrans
  reg [1 : 0] rg_htrans;
  wire [1 : 0] rg_htrans$D_IN;
  wire rg_htrans$EN;

  // register rg_hwrite
  reg rg_hwrite;
  wire rg_hwrite$D_IN, rg_hwrite$EN;

  // register rg_msip
  reg rg_msip;
  wire rg_msip$D_IN, rg_msip$EN;

  // register rg_mtip
  reg rg_mtip;
  wire rg_mtip$D_IN, rg_mtip$EN;

  // register rg_state
  reg [2 : 0] rg_state;
  reg [2 : 0] rg_state$D_IN;
  wire rg_state$EN;

  // ports of submodule f_sw_interrupt_req
  wire f_sw_interrupt_req$CLR,
       f_sw_interrupt_req$DEQ,
       f_sw_interrupt_req$D_IN,
       f_sw_interrupt_req$ENQ;

  // rule scheduling signals
  wire CAN_FIRE_RL_rl_compare,
       CAN_FIRE_RL_rl_error1,
       CAN_FIRE_RL_rl_error2,
       CAN_FIRE_RL_rl_idle,
       CAN_FIRE_RL_rl_new_req,
       CAN_FIRE_RL_rl_rd_req,
       CAN_FIRE_RL_rl_reset,
       CAN_FIRE_RL_rl_tick_timer,
       CAN_FIRE_RL_rl_wr_req,
       CAN_FIRE_fabric_haddr,
       CAN_FIRE_fabric_hburst,
       CAN_FIRE_fabric_hmastlock,
       CAN_FIRE_fabric_hprot,
       CAN_FIRE_fabric_hready,
       CAN_FIRE_fabric_hsel,
       CAN_FIRE_fabric_hsize,
       CAN_FIRE_fabric_htrans,
       CAN_FIRE_fabric_hwdata,
       CAN_FIRE_fabric_hwrite,
       WILL_FIRE_RL_rl_compare,
       WILL_FIRE_RL_rl_error1,
       WILL_FIRE_RL_rl_error2,
       WILL_FIRE_RL_rl_idle,
       WILL_FIRE_RL_rl_new_req,
       WILL_FIRE_RL_rl_rd_req,
       WILL_FIRE_RL_rl_reset,
       WILL_FIRE_RL_rl_tick_timer,
       WILL_FIRE_RL_rl_wr_req,
       WILL_FIRE_fabric_haddr,
       WILL_FIRE_fabric_hburst,
       WILL_FIRE_fabric_hmastlock,
       WILL_FIRE_fabric_hprot,
       WILL_FIRE_fabric_hready,
       WILL_FIRE_fabric_hsel,
       WILL_FIRE_fabric_hsize,
       WILL_FIRE_fabric_htrans,
       WILL_FIRE_fabric_hwdata,
       WILL_FIRE_fabric_hwrite;

  // inputs to muxes for submodule ports
  wire [63 : 0] MUX_crg_time$port1__write_1__VAL_1,
		MUX_crg_timecmp$port1__write_1__VAL_1;
  wire [2 : 0] MUX_rg_state$write_1__VAL_1,
	       MUX_rg_state$write_1__VAL_2,
	       MUX_rg_state$write_1__VAL_3;
  wire MUX_crg_time$port1__write_1__SEL_1,
       MUX_crg_timecmp$port1__write_1__SEL_1,
       MUX_rg_hready$write_1__SEL_4,
       MUX_rg_hready$write_1__VAL_1,
       MUX_rg_hready$write_1__VAL_2,
       MUX_rg_hresp$write_1__SEL_1,
       MUX_rg_hresp$write_1__SEL_2,
       MUX_rg_hresp$write_1__SEL_4,
       MUX_rg_hresp$write_1__VAL_3,
       MUX_rg_msip$write_1__SEL_1;

  // declarations used by system tasks
  // synopsys translate_off
  reg [31 : 0] v__h5128;
  reg [31 : 0] v__h5455;
  reg [31 : 0] v__h5122;
  reg [31 : 0] v__h5449;
  // synopsys translate_on

  // remaining internal signals
  reg [31 : 0] CASE_rg_haddr_BITS_1_TO_0_0b0_new_word298_0b10_ETC__q3,
	       CASE_rg_haddr_BITS_1_TO_0_0b0_new_word580_0b10_ETC__q1,
	       CASE_rg_haddr_BITS_1_TO_0_0b0_new_word923_0b10_ETC__q2,
	       CASE_rg_haddr_BITS_1_TO_0_0b0_new_word955_0b10_ETC__q4,
	       IF_rg_haddr_8_BITS_1_TO_0_9_EQ_0b0_0_THEN_crg__ETC___d119,
	       IF_rg_haddr_8_BITS_1_TO_0_9_EQ_0b0_0_THEN_crg__ETC___d155,
	       IF_rg_haddr_8_BITS_1_TO_0_9_EQ_0b0_0_THEN_crg__ETC___d178,
	       IF_rg_haddr_8_BITS_1_TO_0_9_EQ_0b0_0_THEN_crg__ETC___d92,
	       new_time_H__h4438,
	       new_time_L__h3750,
	       new_timecmp_H__h3063,
	       new_timecmp_L__h2372;
  wire [63 : 0] x1__h2389, x1__h3080, x1__h3767, x1__h4455;
  wire [31 : 0] byte_addr__h2115,
		new_word__h2532,
		new_word__h2649,
		new_word__h2736,
		new_word__h2823,
		new_word__h2923,
		new_word__h2968,
		new_word__h3121,
		new_word__h3306,
		new_word__h3393,
		new_word__h3480,
		new_word__h3580,
		new_word__h3625,
		new_word__h3907,
		new_word__h4024,
		new_word__h4111,
		new_word__h4198,
		new_word__h4298,
		new_word__h4343,
		new_word__h4496,
		new_word__h4681,
		new_word__h4768,
		new_word__h4855,
		new_word__h4955,
		new_word__h5000,
		rdata___1__h5358;
  wire NOT_crg_time_port0__read_ULT_crg_timecmp_port0_ETC___d12;

  // action method fabric_hsel
  assign CAN_FIRE_fabric_hsel = 1'd1 ;
  assign WILL_FIRE_fabric_hsel = 1'd1 ;

  // action method fabric_hready
  assign CAN_FIRE_fabric_hready = 1'd1 ;
  assign WILL_FIRE_fabric_hready = 1'd1 ;

  // action method fabric_haddr
  assign CAN_FIRE_fabric_haddr = 1'd1 ;
  assign WILL_FIRE_fabric_haddr = 1'd1 ;

  // action method fabric_hburst
  assign CAN_FIRE_fabric_hburst = 1'd1 ;
  assign WILL_FIRE_fabric_hburst = 1'd1 ;

  // action method fabric_hmastlock
  assign CAN_FIRE_fabric_hmastlock = 1'd1 ;
  assign WILL_FIRE_fabric_hmastlock = 1'd1 ;

  // action method fabric_hprot
  assign CAN_FIRE_fabric_hprot = 1'd1 ;
  assign WILL_FIRE_fabric_hprot = 1'd1 ;

  // action method fabric_hsize
  assign CAN_FIRE_fabric_hsize = 1'd1 ;
  assign WILL_FIRE_fabric_hsize = 1'd1 ;

  // action method fabric_htrans
  assign CAN_FIRE_fabric_htrans = 1'd1 ;
  assign WILL_FIRE_fabric_htrans = 1'd1 ;

  // action method fabric_hwdata
  assign CAN_FIRE_fabric_hwdata = 1'd1 ;
  assign WILL_FIRE_fabric_hwdata = 1'd1 ;

  // action method fabric_hwrite
  assign CAN_FIRE_fabric_hwrite = 1'd1 ;
  assign WILL_FIRE_fabric_hwrite = 1'd1 ;

  // value method fabric_hrdata
  assign fabric_HRDATA = rg_hrdata ;

  // value method fabric_hreadyout
  assign fabric_HREADYOUT = rg_hready ;

  // value method fabric_hresp
  assign fabric_HRESP = rg_hresp ;

  // value method timer_interrupt_pending
  assign timer_interrupt_pending = rg_mtip ;

  // value method sw_interrupt_pending
  assign sw_interrupt_pending = rg_msip ;

  // submodule f_sw_interrupt_req
  FIFO2 #(.width(32'd1), .guarded(1'd1)) f_sw_interrupt_req(.RST(RST_N),
							    .CLK(CLK),
							    .D_IN(f_sw_interrupt_req$D_IN),
							    .ENQ(f_sw_interrupt_req$ENQ),
							    .DEQ(f_sw_interrupt_req$DEQ),
							    .CLR(f_sw_interrupt_req$CLR),
							    .D_OUT(),
							    .FULL_N(),
							    .EMPTY_N());

  // rule RL_rl_reset
  assign CAN_FIRE_RL_rl_reset = rg_state == 3'd0 ;
  assign WILL_FIRE_RL_rl_reset = CAN_FIRE_RL_rl_reset ;

  // rule RL_rl_compare
  assign CAN_FIRE_RL_rl_compare =
	     rg_state == 3'd1 &&
	     rg_mtip !=
	     NOT_crg_time_port0__read_ULT_crg_timecmp_port0_ETC___d12 ;
  assign WILL_FIRE_RL_rl_compare = CAN_FIRE_RL_rl_compare ;

  // rule RL_rl_tick_timer
  assign CAN_FIRE_RL_rl_tick_timer =
	     rg_state == 3'd1 && crg_time != 64'hFFFFFFFFFFFFFFFF ;
  assign WILL_FIRE_RL_rl_tick_timer = CAN_FIRE_RL_rl_tick_timer ;

  // rule RL_rl_new_req
  assign CAN_FIRE_RL_rl_new_req =
	     rg_state == 3'd1 && fabric_HSEL && fabric_HREADY &&
	     fabric_HTRANS == 2'd2 ;
  assign WILL_FIRE_RL_rl_new_req = CAN_FIRE_RL_rl_new_req ;

  // rule RL_rl_wr_req
  assign CAN_FIRE_RL_rl_wr_req = rg_state == 3'd2 && rg_hwrite ;
  assign WILL_FIRE_RL_rl_wr_req = CAN_FIRE_RL_rl_wr_req ;

  // rule RL_rl_rd_req
  assign CAN_FIRE_RL_rl_rd_req = rg_state == 3'd2 && !rg_hwrite ;
  assign WILL_FIRE_RL_rl_rd_req = CAN_FIRE_RL_rl_rd_req ;

  // rule RL_rl_idle
  assign CAN_FIRE_RL_rl_idle =
	     rg_state == 3'd1 && fabric_HSEL && fabric_HTRANS == 2'd0 ;
  assign WILL_FIRE_RL_rl_idle = CAN_FIRE_RL_rl_idle ;

  // rule RL_rl_error1
  assign CAN_FIRE_RL_rl_error1 = rg_state == 3'd3 ;
  assign WILL_FIRE_RL_rl_error1 = CAN_FIRE_RL_rl_error1 ;

  // rule RL_rl_error2
  assign CAN_FIRE_RL_rl_error2 = rg_state == 3'd4 ;
  assign WILL_FIRE_RL_rl_error2 = CAN_FIRE_RL_rl_error2 ;

  // inputs to muxes for submodule ports
  assign MUX_crg_time$port1__write_1__SEL_1 =
	     WILL_FIRE_RL_rl_wr_req &&
	     (rg_haddr[15:0] == 16'd49144 || rg_haddr[15:0] == 16'd49148) ;
  assign MUX_crg_timecmp$port1__write_1__SEL_1 =
	     WILL_FIRE_RL_rl_wr_req &&
	     (rg_haddr[15:0] == 16'd16384 || rg_haddr[15:0] == 16'd16388) ;
  assign MUX_rg_hready$write_1__SEL_4 =
	     WILL_FIRE_RL_rl_error2 || WILL_FIRE_RL_rl_error1 ||
	     WILL_FIRE_RL_rl_idle ||
	     WILL_FIRE_RL_rl_reset ;
  assign MUX_rg_hresp$write_1__SEL_1 =
	     WILL_FIRE_RL_rl_wr_req && rg_haddr[15:0] != 16'd0 &&
	     rg_haddr[15:0] != 16'd4 &&
	     rg_haddr[15:0] != 16'd16384 &&
	     rg_haddr[15:0] != 16'd16388 &&
	     rg_haddr[15:0] != 16'd49144 &&
	     rg_haddr[15:0] != 16'd49148 ;
  assign MUX_rg_hresp$write_1__SEL_2 =
	     WILL_FIRE_RL_rl_rd_req && rg_haddr[15:0] != 16'd0 &&
	     rg_haddr[15:0] != 16'd16384 &&
	     rg_haddr[15:0] != 16'd49144 &&
	     rg_haddr[15:0] != 16'd4 &&
	     rg_haddr[15:0] != 16'd16388 &&
	     rg_haddr[15:0] != 16'd49148 ;
  assign MUX_rg_hresp$write_1__SEL_4 =
	     WILL_FIRE_RL_rl_error2 || WILL_FIRE_RL_rl_reset ;
  assign MUX_rg_msip$write_1__SEL_1 =
	     WILL_FIRE_RL_rl_wr_req && rg_haddr[15:0] == 16'd0 &&
	     rg_msip != fabric_HWDATA[0] ;
  assign MUX_crg_time$port1__write_1__VAL_1 =
	     (rg_haddr[15:0] == 16'd49144) ? x1__h3767 : x1__h4455 ;
  assign MUX_crg_timecmp$port1__write_1__VAL_1 =
	     (rg_haddr[15:0] == 16'd16384) ? x1__h2389 : x1__h3080 ;
  assign MUX_rg_hready$write_1__VAL_1 =
	     rg_haddr[15:0] == 16'd0 || rg_haddr[15:0] == 16'd4 ||
	     rg_haddr[15:0] == 16'd16384 ||
	     rg_haddr[15:0] == 16'd16388 ||
	     rg_haddr[15:0] == 16'd49144 ||
	     rg_haddr[15:0] == 16'd49148 ;
  assign MUX_rg_hready$write_1__VAL_2 =
	     rg_haddr[15:0] == 16'd0 || rg_haddr[15:0] == 16'd16384 ||
	     rg_haddr[15:0] == 16'd49144 ||
	     rg_haddr[15:0] == 16'd4 ||
	     rg_haddr[15:0] == 16'd16388 ||
	     rg_haddr[15:0] == 16'd49148 ;
  assign MUX_rg_hresp$write_1__VAL_3 =
	     fabric_HSIZE != 3'd0 &&
	     ((fabric_HSIZE == 3'd1) ?
		fabric_HADDR[1:0] != 2'b0 && fabric_HADDR[1:0] != 2'b10 :
		fabric_HSIZE != 3'd2 || fabric_HADDR[1:0] != 2'b0) ;
  assign MUX_rg_state$write_1__VAL_1 =
	     (fabric_HSIZE == 3'd0 ||
	      ((fabric_HSIZE == 3'd1) ?
		 fabric_HADDR[1:0] == 2'b0 || fabric_HADDR[1:0] == 2'b10 :
		 fabric_HSIZE == 3'd2 && fabric_HADDR[1:0] == 2'b0)) ?
	       3'd2 :
	       3'd3 ;
  assign MUX_rg_state$write_1__VAL_2 =
	     (rg_haddr[15:0] != 16'd0 && rg_haddr[15:0] != 16'd4 &&
	      rg_haddr[15:0] != 16'd16384 &&
	      rg_haddr[15:0] != 16'd16388 &&
	      rg_haddr[15:0] != 16'd49144 &&
	      rg_haddr[15:0] != 16'd49148) ?
	       3'd3 :
	       3'd1 ;
  assign MUX_rg_state$write_1__VAL_3 =
	     (rg_haddr[15:0] != 16'd0 && rg_haddr[15:0] != 16'd16384 &&
	      rg_haddr[15:0] != 16'd49144 &&
	      rg_haddr[15:0] != 16'd4 &&
	      rg_haddr[15:0] != 16'd16388 &&
	      rg_haddr[15:0] != 16'd49148) ?
	       3'd3 :
	       3'd1 ;

  // inlined wires
  assign crg_time$port0__write_1 = crg_time + 64'd1 ;
  assign crg_time$port1__read =
	     CAN_FIRE_RL_rl_tick_timer ? crg_time$port0__write_1 : crg_time ;
  assign crg_time$EN_port1__write =
	     WILL_FIRE_RL_rl_wr_req &&
	     (rg_haddr[15:0] == 16'd49144 || rg_haddr[15:0] == 16'd49148) ||
	     WILL_FIRE_RL_rl_reset ;
  assign crg_time$port1__write_1 =
	     MUX_crg_time$port1__write_1__SEL_1 ?
	       MUX_crg_time$port1__write_1__VAL_1 :
	       64'd1 ;
  assign crg_time$port2__read =
	     crg_time$EN_port1__write ?
	       crg_time$port1__write_1 :
	       crg_time$port1__read ;
  assign crg_timecmp$EN_port1__write =
	     WILL_FIRE_RL_rl_wr_req &&
	     (rg_haddr[15:0] == 16'd16384 || rg_haddr[15:0] == 16'd16388) ||
	     WILL_FIRE_RL_rl_reset ;
  assign crg_timecmp$port1__write_1 =
	     MUX_crg_timecmp$port1__write_1__SEL_1 ?
	       MUX_crg_timecmp$port1__write_1__VAL_1 :
	       64'd0 ;
  assign crg_timecmp$port2__read =
	     crg_timecmp$EN_port1__write ?
	       crg_timecmp$port1__write_1 :
	       crg_timecmp ;

  // register crg_time
  assign crg_time$D_IN = crg_time$port2__read ;
  assign crg_time$EN = 1'b1 ;

  // register crg_timecmp
  assign crg_timecmp$D_IN = crg_timecmp$port2__read ;
  assign crg_timecmp$EN = 1'b1 ;

  // register rg_haddr
  assign rg_haddr$D_IN = fabric_HADDR ;
  assign rg_haddr$EN = CAN_FIRE_RL_rl_new_req ;

  // register rg_hrdata
  always@(rg_haddr or crg_time or rdata___1__h5358 or crg_timecmp)
  begin
    case (rg_haddr[15:0])
      16'd0: rg_hrdata$D_IN = rdata___1__h5358;
      16'd4: rg_hrdata$D_IN = 32'd0;
      16'd16384: rg_hrdata$D_IN = crg_timecmp[31:0];
      16'd16388: rg_hrdata$D_IN = crg_timecmp[63:32];
      16'd49144: rg_hrdata$D_IN = crg_time[31:0];
      default: rg_hrdata$D_IN = crg_time[63:32];
    endcase
  end
  assign rg_hrdata$EN =
	     WILL_FIRE_RL_rl_rd_req &&
	     (rg_haddr[15:0] == 16'd0 || rg_haddr[15:0] == 16'd16384 ||
	      rg_haddr[15:0] == 16'd49144 ||
	      rg_haddr[15:0] == 16'd4 ||
	      rg_haddr[15:0] == 16'd16388 ||
	      rg_haddr[15:0] == 16'd49148) ;

  // register rg_hready
  always@(WILL_FIRE_RL_rl_wr_req or
	  MUX_rg_hready$write_1__VAL_1 or
	  WILL_FIRE_RL_rl_rd_req or
	  MUX_rg_hready$write_1__VAL_2 or
	  WILL_FIRE_RL_rl_new_req or MUX_rg_hready$write_1__SEL_4)
  begin
    case (1'b1) // synopsys parallel_case
      WILL_FIRE_RL_rl_wr_req: rg_hready$D_IN = MUX_rg_hready$write_1__VAL_1;
      WILL_FIRE_RL_rl_rd_req: rg_hready$D_IN = MUX_rg_hready$write_1__VAL_2;
      WILL_FIRE_RL_rl_new_req: rg_hready$D_IN = 1'd0;
      MUX_rg_hready$write_1__SEL_4: rg_hready$D_IN = 1'd1;
      default: rg_hready$D_IN = 1'b0 /* unspecified value */ ;
    endcase
  end
  assign rg_hready$EN =
	     WILL_FIRE_RL_rl_wr_req || WILL_FIRE_RL_rl_rd_req ||
	     WILL_FIRE_RL_rl_new_req ||
	     WILL_FIRE_RL_rl_error2 ||
	     WILL_FIRE_RL_rl_error1 ||
	     WILL_FIRE_RL_rl_idle ||
	     WILL_FIRE_RL_rl_reset ;

  // register rg_hresp
  always@(WILL_FIRE_RL_rl_new_req or
	  MUX_rg_hresp$write_1__VAL_3 or
	  MUX_rg_hresp$write_1__SEL_4 or
	  MUX_rg_hresp$write_1__SEL_1 or MUX_rg_hresp$write_1__SEL_2)
  begin
    case (1'b1) // synopsys parallel_case
      WILL_FIRE_RL_rl_new_req: rg_hresp$D_IN = MUX_rg_hresp$write_1__VAL_3;
      MUX_rg_hresp$write_1__SEL_4: rg_hresp$D_IN = 1'd0;
      MUX_rg_hresp$write_1__SEL_1 || MUX_rg_hresp$write_1__SEL_2:
	  rg_hresp$D_IN = 1'd1;
      default: rg_hresp$D_IN = 1'b0 /* unspecified value */ ;
    endcase
  end
  assign rg_hresp$EN =
	     WILL_FIRE_RL_rl_wr_req && rg_haddr[15:0] != 16'd0 &&
	     rg_haddr[15:0] != 16'd4 &&
	     rg_haddr[15:0] != 16'd16384 &&
	     rg_haddr[15:0] != 16'd16388 &&
	     rg_haddr[15:0] != 16'd49144 &&
	     rg_haddr[15:0] != 16'd49148 ||
	     WILL_FIRE_RL_rl_rd_req && rg_haddr[15:0] != 16'd0 &&
	     rg_haddr[15:0] != 16'd16384 &&
	     rg_haddr[15:0] != 16'd49144 &&
	     rg_haddr[15:0] != 16'd4 &&
	     rg_haddr[15:0] != 16'd16388 &&
	     rg_haddr[15:0] != 16'd49148 ||
	     WILL_FIRE_RL_rl_new_req ||
	     WILL_FIRE_RL_rl_error2 ||
	     WILL_FIRE_RL_rl_reset ;

  // register rg_hsize
  assign rg_hsize$D_IN = fabric_HSIZE ;
  assign rg_hsize$EN = CAN_FIRE_RL_rl_new_req ;

  // register rg_htrans
  assign rg_htrans$D_IN = fabric_HTRANS ;
  assign rg_htrans$EN = CAN_FIRE_RL_rl_new_req ;

  // register rg_hwrite
  assign rg_hwrite$D_IN = fabric_HWRITE ;
  assign rg_hwrite$EN = CAN_FIRE_RL_rl_new_req ;

  // register rg_msip
  assign rg_msip$D_IN = MUX_rg_msip$write_1__SEL_1 && fabric_HWDATA[0] ;
  assign rg_msip$EN =
	     WILL_FIRE_RL_rl_wr_req && rg_haddr[15:0] == 16'd0 &&
	     rg_msip != fabric_HWDATA[0] ||
	     WILL_FIRE_RL_rl_reset ;

  // register rg_mtip
  assign rg_mtip$D_IN =
	     !WILL_FIRE_RL_rl_compare ||
	     NOT_crg_time_port0__read_ULT_crg_timecmp_port0_ETC___d12 ;
  assign rg_mtip$EN = WILL_FIRE_RL_rl_compare || WILL_FIRE_RL_rl_reset ;

  // register rg_state
  always@(WILL_FIRE_RL_rl_new_req or
	  MUX_rg_state$write_1__VAL_1 or
	  WILL_FIRE_RL_rl_wr_req or
	  MUX_rg_state$write_1__VAL_2 or
	  WILL_FIRE_RL_rl_rd_req or
	  MUX_rg_state$write_1__VAL_3 or
	  MUX_rg_hresp$write_1__SEL_4 or WILL_FIRE_RL_rl_error1)
  begin
    case (1'b1) // synopsys parallel_case
      WILL_FIRE_RL_rl_new_req: rg_state$D_IN = MUX_rg_state$write_1__VAL_1;
      WILL_FIRE_RL_rl_wr_req: rg_state$D_IN = MUX_rg_state$write_1__VAL_2;
      WILL_FIRE_RL_rl_rd_req: rg_state$D_IN = MUX_rg_state$write_1__VAL_3;
      MUX_rg_hresp$write_1__SEL_4: rg_state$D_IN = 3'd1;
      WILL_FIRE_RL_rl_error1: rg_state$D_IN = 3'd4;
      default: rg_state$D_IN = 3'b010 /* unspecified value */ ;
    endcase
  end
  assign rg_state$EN =
	     WILL_FIRE_RL_rl_new_req || WILL_FIRE_RL_rl_wr_req ||
	     WILL_FIRE_RL_rl_rd_req ||
	     WILL_FIRE_RL_rl_error2 ||
	     WILL_FIRE_RL_rl_reset ||
	     WILL_FIRE_RL_rl_error1 ;

  // submodule f_sw_interrupt_req
  assign f_sw_interrupt_req$D_IN = 1'b0 ;
  assign f_sw_interrupt_req$ENQ = 1'b0 ;
  assign f_sw_interrupt_req$DEQ = 1'b0 ;
  assign f_sw_interrupt_req$CLR = 1'b0 ;

  // remaining internal signals
  assign NOT_crg_time_port0__read_ULT_crg_timecmp_port0_ETC___d12 =
	     crg_time >= crg_timecmp ;
  assign byte_addr__h2115 = { 16'd0, rg_haddr[15:0] } ;
  assign new_word__h2532 = { crg_timecmp[31:8], fabric_HWDATA[7:0] } ;
  assign new_word__h2649 =
	     { crg_timecmp[31:16], fabric_HWDATA[15:8], crg_timecmp[7:0] } ;
  assign new_word__h2736 =
	     { crg_timecmp[31:24], fabric_HWDATA[23:16], crg_timecmp[15:0] } ;
  assign new_word__h2823 = { fabric_HWDATA[31:24], crg_timecmp[23:0] } ;
  assign new_word__h2923 = { crg_timecmp[31:16], fabric_HWDATA[15:0] } ;
  assign new_word__h2968 = { fabric_HWDATA[31:16], crg_timecmp[15:0] } ;
  assign new_word__h3121 = { crg_timecmp[63:40], fabric_HWDATA[7:0] } ;
  assign new_word__h3306 =
	     { crg_timecmp[63:48], fabric_HWDATA[15:8], crg_timecmp[39:32] } ;
  assign new_word__h3393 =
	     { crg_timecmp[63:56],
	       fabric_HWDATA[23:16],
	       crg_timecmp[47:32] } ;
  assign new_word__h3480 = { fabric_HWDATA[31:24], crg_timecmp[55:32] } ;
  assign new_word__h3580 = { crg_timecmp[63:48], fabric_HWDATA[15:0] } ;
  assign new_word__h3625 = { fabric_HWDATA[31:16], crg_timecmp[47:32] } ;
  assign new_word__h3907 =
	     { crg_time$port1__read[31:8], fabric_HWDATA[7:0] } ;
  assign new_word__h4024 =
	     { crg_time$port1__read[31:16],
	       fabric_HWDATA[15:8],
	       crg_time$port1__read[7:0] } ;
  assign new_word__h4111 =
	     { crg_time$port1__read[31:24],
	       fabric_HWDATA[23:16],
	       crg_time$port1__read[15:0] } ;
  assign new_word__h4198 =
	     { fabric_HWDATA[31:24], crg_time$port1__read[23:0] } ;
  assign new_word__h4298 =
	     { crg_time$port1__read[31:16], fabric_HWDATA[15:0] } ;
  assign new_word__h4343 =
	     { fabric_HWDATA[31:16], crg_time$port1__read[15:0] } ;
  assign new_word__h4496 =
	     { crg_time$port1__read[63:40], fabric_HWDATA[7:0] } ;
  assign new_word__h4681 =
	     { crg_time$port1__read[63:48],
	       fabric_HWDATA[15:8],
	       crg_time$port1__read[39:32] } ;
  assign new_word__h4768 =
	     { crg_time$port1__read[63:56],
	       fabric_HWDATA[23:16],
	       crg_time$port1__read[47:32] } ;
  assign new_word__h4855 =
	     { fabric_HWDATA[31:24], crg_time$port1__read[55:32] } ;
  assign new_word__h4955 =
	     { crg_time$port1__read[63:48], fabric_HWDATA[15:0] } ;
  assign new_word__h5000 =
	     { fabric_HWDATA[31:16], crg_time$port1__read[47:32] } ;
  assign rdata___1__h5358 = { 31'd0, rg_msip } ;
  assign x1__h2389 = { crg_timecmp[63:32], new_timecmp_L__h2372 } ;
  assign x1__h3080 = { new_timecmp_H__h3063, crg_timecmp[31:0] } ;
  assign x1__h3767 = { crg_time$port1__read[63:32], new_time_L__h3750 } ;
  assign x1__h4455 = { new_time_H__h4438, crg_time$port1__read[31:0] } ;
  always@(rg_haddr or
	  crg_timecmp or
	  new_word__h3121 or
	  new_word__h3306 or new_word__h3393 or new_word__h3480)
  begin
    case (rg_haddr[1:0])
      2'b0:
	  IF_rg_haddr_8_BITS_1_TO_0_9_EQ_0b0_0_THEN_crg__ETC___d119 =
	      new_word__h3121;
      2'b01:
	  IF_rg_haddr_8_BITS_1_TO_0_9_EQ_0b0_0_THEN_crg__ETC___d119 =
	      new_word__h3306;
      2'b10:
	  IF_rg_haddr_8_BITS_1_TO_0_9_EQ_0b0_0_THEN_crg__ETC___d119 =
	      new_word__h3393;
      2'b11:
	  IF_rg_haddr_8_BITS_1_TO_0_9_EQ_0b0_0_THEN_crg__ETC___d119 =
	      new_word__h3480;
    endcase
  end
  always@(rg_haddr or crg_timecmp or new_word__h3580 or new_word__h3625)
  begin
    case (rg_haddr[1:0])
      2'b0:
	  CASE_rg_haddr_BITS_1_TO_0_0b0_new_word580_0b10_ETC__q1 =
	      new_word__h3580;
      2'b10:
	  CASE_rg_haddr_BITS_1_TO_0_0b0_new_word580_0b10_ETC__q1 =
	      new_word__h3625;
      default: CASE_rg_haddr_BITS_1_TO_0_0b0_new_word580_0b10_ETC__q1 =
		   crg_timecmp[63:32];
    endcase
  end
  always@(rg_hsize or
	  crg_timecmp or
	  IF_rg_haddr_8_BITS_1_TO_0_9_EQ_0b0_0_THEN_crg__ETC___d119 or
	  CASE_rg_haddr_BITS_1_TO_0_0b0_new_word580_0b10_ETC__q1 or
	  rg_haddr or fabric_HWDATA)
  begin
    case (rg_hsize)
      3'd0:
	  new_timecmp_H__h3063 =
	      IF_rg_haddr_8_BITS_1_TO_0_9_EQ_0b0_0_THEN_crg__ETC___d119;
      3'd1:
	  new_timecmp_H__h3063 =
	      CASE_rg_haddr_BITS_1_TO_0_0b0_new_word580_0b10_ETC__q1;
      3'd2:
	  new_timecmp_H__h3063 =
	      (rg_haddr[1:0] == 2'b0) ? fabric_HWDATA : crg_timecmp[63:32];
      default: new_timecmp_H__h3063 = crg_timecmp[63:32];
    endcase
  end
  always@(rg_haddr or
	  crg_timecmp or
	  new_word__h2532 or
	  new_word__h2649 or new_word__h2736 or new_word__h2823)
  begin
    case (rg_haddr[1:0])
      2'b0:
	  IF_rg_haddr_8_BITS_1_TO_0_9_EQ_0b0_0_THEN_crg__ETC___d92 =
	      new_word__h2532;
      2'b01:
	  IF_rg_haddr_8_BITS_1_TO_0_9_EQ_0b0_0_THEN_crg__ETC___d92 =
	      new_word__h2649;
      2'b10:
	  IF_rg_haddr_8_BITS_1_TO_0_9_EQ_0b0_0_THEN_crg__ETC___d92 =
	      new_word__h2736;
      2'b11:
	  IF_rg_haddr_8_BITS_1_TO_0_9_EQ_0b0_0_THEN_crg__ETC___d92 =
	      new_word__h2823;
    endcase
  end
  always@(rg_haddr or crg_timecmp or new_word__h2923 or new_word__h2968)
  begin
    case (rg_haddr[1:0])
      2'b0:
	  CASE_rg_haddr_BITS_1_TO_0_0b0_new_word923_0b10_ETC__q2 =
	      new_word__h2923;
      2'b10:
	  CASE_rg_haddr_BITS_1_TO_0_0b0_new_word923_0b10_ETC__q2 =
	      new_word__h2968;
      default: CASE_rg_haddr_BITS_1_TO_0_0b0_new_word923_0b10_ETC__q2 =
		   crg_timecmp[31:0];
    endcase
  end
  always@(rg_hsize or
	  crg_timecmp or
	  IF_rg_haddr_8_BITS_1_TO_0_9_EQ_0b0_0_THEN_crg__ETC___d92 or
	  CASE_rg_haddr_BITS_1_TO_0_0b0_new_word923_0b10_ETC__q2 or
	  rg_haddr or fabric_HWDATA)
  begin
    case (rg_hsize)
      3'd0:
	  new_timecmp_L__h2372 =
	      IF_rg_haddr_8_BITS_1_TO_0_9_EQ_0b0_0_THEN_crg__ETC___d92;
      3'd1:
	  new_timecmp_L__h2372 =
	      CASE_rg_haddr_BITS_1_TO_0_0b0_new_word923_0b10_ETC__q2;
      3'd2:
	  new_timecmp_L__h2372 =
	      (rg_haddr[1:0] == 2'b0) ? fabric_HWDATA : crg_timecmp[31:0];
      default: new_timecmp_L__h2372 = crg_timecmp[31:0];
    endcase
  end
  always@(rg_haddr or
	  crg_time$port1__read or
	  new_word__h3907 or
	  new_word__h4024 or new_word__h4111 or new_word__h4198)
  begin
    case (rg_haddr[1:0])
      2'b0:
	  IF_rg_haddr_8_BITS_1_TO_0_9_EQ_0b0_0_THEN_crg__ETC___d155 =
	      new_word__h3907;
      2'b01:
	  IF_rg_haddr_8_BITS_1_TO_0_9_EQ_0b0_0_THEN_crg__ETC___d155 =
	      new_word__h4024;
      2'b10:
	  IF_rg_haddr_8_BITS_1_TO_0_9_EQ_0b0_0_THEN_crg__ETC___d155 =
	      new_word__h4111;
      2'b11:
	  IF_rg_haddr_8_BITS_1_TO_0_9_EQ_0b0_0_THEN_crg__ETC___d155 =
	      new_word__h4198;
    endcase
  end
  always@(rg_haddr or
	  crg_time$port1__read or new_word__h4298 or new_word__h4343)
  begin
    case (rg_haddr[1:0])
      2'b0:
	  CASE_rg_haddr_BITS_1_TO_0_0b0_new_word298_0b10_ETC__q3 =
	      new_word__h4298;
      2'b10:
	  CASE_rg_haddr_BITS_1_TO_0_0b0_new_word298_0b10_ETC__q3 =
	      new_word__h4343;
      default: CASE_rg_haddr_BITS_1_TO_0_0b0_new_word298_0b10_ETC__q3 =
		   crg_time$port1__read[31:0];
    endcase
  end
  always@(rg_hsize or
	  crg_time$port1__read or
	  IF_rg_haddr_8_BITS_1_TO_0_9_EQ_0b0_0_THEN_crg__ETC___d155 or
	  CASE_rg_haddr_BITS_1_TO_0_0b0_new_word298_0b10_ETC__q3 or
	  rg_haddr or fabric_HWDATA)
  begin
    case (rg_hsize)
      3'd0:
	  new_time_L__h3750 =
	      IF_rg_haddr_8_BITS_1_TO_0_9_EQ_0b0_0_THEN_crg__ETC___d155;
      3'd1:
	  new_time_L__h3750 =
	      CASE_rg_haddr_BITS_1_TO_0_0b0_new_word298_0b10_ETC__q3;
      3'd2:
	  new_time_L__h3750 =
	      (rg_haddr[1:0] == 2'b0) ?
		fabric_HWDATA :
		crg_time$port1__read[31:0];
      default: new_time_L__h3750 = crg_time$port1__read[31:0];
    endcase
  end
  always@(rg_haddr or
	  crg_time$port1__read or
	  new_word__h4496 or
	  new_word__h4681 or new_word__h4768 or new_word__h4855)
  begin
    case (rg_haddr[1:0])
      2'b0:
	  IF_rg_haddr_8_BITS_1_TO_0_9_EQ_0b0_0_THEN_crg__ETC___d178 =
	      new_word__h4496;
      2'b01:
	  IF_rg_haddr_8_BITS_1_TO_0_9_EQ_0b0_0_THEN_crg__ETC___d178 =
	      new_word__h4681;
      2'b10:
	  IF_rg_haddr_8_BITS_1_TO_0_9_EQ_0b0_0_THEN_crg__ETC___d178 =
	      new_word__h4768;
      2'b11:
	  IF_rg_haddr_8_BITS_1_TO_0_9_EQ_0b0_0_THEN_crg__ETC___d178 =
	      new_word__h4855;
    endcase
  end
  always@(rg_haddr or
	  crg_time$port1__read or new_word__h4955 or new_word__h5000)
  begin
    case (rg_haddr[1:0])
      2'b0:
	  CASE_rg_haddr_BITS_1_TO_0_0b0_new_word955_0b10_ETC__q4 =
	      new_word__h4955;
      2'b10:
	  CASE_rg_haddr_BITS_1_TO_0_0b0_new_word955_0b10_ETC__q4 =
	      new_word__h5000;
      default: CASE_rg_haddr_BITS_1_TO_0_0b0_new_word955_0b10_ETC__q4 =
		   crg_time$port1__read[63:32];
    endcase
  end
  always@(rg_hsize or
	  crg_time$port1__read or
	  IF_rg_haddr_8_BITS_1_TO_0_9_EQ_0b0_0_THEN_crg__ETC___d178 or
	  CASE_rg_haddr_BITS_1_TO_0_0b0_new_word955_0b10_ETC__q4 or
	  rg_haddr or fabric_HWDATA)
  begin
    case (rg_hsize)
      3'd0:
	  new_time_H__h4438 =
	      IF_rg_haddr_8_BITS_1_TO_0_9_EQ_0b0_0_THEN_crg__ETC___d178;
      3'd1:
	  new_time_H__h4438 =
	      CASE_rg_haddr_BITS_1_TO_0_0b0_new_word955_0b10_ETC__q4;
      3'd2:
	  new_time_H__h4438 =
	      (rg_haddr[1:0] == 2'b0) ?
		fabric_HWDATA :
		crg_time$port1__read[63:32];
      default: new_time_H__h4438 = crg_time$port1__read[63:32];
    endcase
  end

  // handling of inlined registers

  always@(posedge CLK)
  begin
    if (RST_N == `BSV_RESET_VALUE)
      begin
        crg_time <= `BSV_ASSIGNMENT_DELAY 64'd1;
	crg_timecmp <= `BSV_ASSIGNMENT_DELAY 64'd0;
	rg_hready <= `BSV_ASSIGNMENT_DELAY 1'd1;
	rg_hresp <= `BSV_ASSIGNMENT_DELAY 1'd0;
	rg_mtip <= `BSV_ASSIGNMENT_DELAY 1'd1;
	rg_state <= `BSV_ASSIGNMENT_DELAY 3'd0;
      end
    else
      begin
        if (crg_time$EN) crg_time <= `BSV_ASSIGNMENT_DELAY crg_time$D_IN;
	if (crg_timecmp$EN)
	  crg_timecmp <= `BSV_ASSIGNMENT_DELAY crg_timecmp$D_IN;
	if (rg_hready$EN) rg_hready <= `BSV_ASSIGNMENT_DELAY rg_hready$D_IN;
	if (rg_hresp$EN) rg_hresp <= `BSV_ASSIGNMENT_DELAY rg_hresp$D_IN;
	if (rg_mtip$EN) rg_mtip <= `BSV_ASSIGNMENT_DELAY rg_mtip$D_IN;
	if (rg_state$EN) rg_state <= `BSV_ASSIGNMENT_DELAY rg_state$D_IN;
      end
    if (rg_haddr$EN) rg_haddr <= `BSV_ASSIGNMENT_DELAY rg_haddr$D_IN;
    if (rg_hrdata$EN) rg_hrdata <= `BSV_ASSIGNMENT_DELAY rg_hrdata$D_IN;
    if (rg_hsize$EN) rg_hsize <= `BSV_ASSIGNMENT_DELAY rg_hsize$D_IN;
    if (rg_htrans$EN) rg_htrans <= `BSV_ASSIGNMENT_DELAY rg_htrans$D_IN;
    if (rg_hwrite$EN) rg_hwrite <= `BSV_ASSIGNMENT_DELAY rg_hwrite$D_IN;
    if (rg_msip$EN) rg_msip <= `BSV_ASSIGNMENT_DELAY rg_msip$D_IN;
  end

  // synopsys translate_off
  `ifdef BSV_NO_INITIAL_BLOCKS
  `else // not BSV_NO_INITIAL_BLOCKS
  initial
  begin
    crg_time = 64'hAAAAAAAAAAAAAAAA;
    crg_timecmp = 64'hAAAAAAAAAAAAAAAA;
    rg_haddr = 32'hAAAAAAAA;
    rg_hrdata = 32'hAAAAAAAA;
    rg_hready = 1'h0;
    rg_hresp = 1'h0;
    rg_hsize = 3'h2;
    rg_htrans = 2'h2;
    rg_hwrite = 1'h0;
    rg_msip = 1'h0;
    rg_mtip = 1'h0;
    rg_state = 3'h2;
  end
  `endif // BSV_NO_INITIAL_BLOCKS
  // synopsys translate_on

  // handling of system tasks

  // synopsys translate_off
  always@(negedge CLK)
  begin
    #0;
    if (RST_N != `BSV_RESET_VALUE)
      if (WILL_FIRE_RL_rl_wr_req && rg_haddr[15:0] != 16'd0 &&
	  rg_haddr[15:0] != 16'd4 &&
	  rg_haddr[15:0] != 16'd16384 &&
	  rg_haddr[15:0] != 16'd16388 &&
	  rg_haddr[15:0] != 16'd49144 &&
	  rg_haddr[15:0] != 16'd49148)
	begin
	  v__h5128 = $stime;
	  #0;
	end
    v__h5122 = v__h5128 / 32'd10;
    if (RST_N != `BSV_RESET_VALUE)
      if (WILL_FIRE_RL_rl_wr_req && rg_haddr[15:0] != 16'd0 &&
	  rg_haddr[15:0] != 16'd4 &&
	  rg_haddr[15:0] != 16'd16384 &&
	  rg_haddr[15:0] != 16'd16388 &&
	  rg_haddr[15:0] != 16'd49144 &&
	  rg_haddr[15:0] != 16'd49148)
	$display("%06d:[E]:%m.rl_wr_req: unrecognized addr: 0x%08h",
		 v__h5122,
		 byte_addr__h2115);
    if (RST_N != `BSV_RESET_VALUE)
      if (WILL_FIRE_RL_rl_rd_req && rg_haddr[15:0] != 16'd0 &&
	  rg_haddr[15:0] != 16'd16384 &&
	  rg_haddr[15:0] != 16'd49144 &&
	  rg_haddr[15:0] != 16'd4 &&
	  rg_haddr[15:0] != 16'd16388 &&
	  rg_haddr[15:0] != 16'd49148)
	begin
	  v__h5455 = $stime;
	  #0;
	end
    v__h5449 = v__h5455 / 32'd10;
    if (RST_N != `BSV_RESET_VALUE)
      if (WILL_FIRE_RL_rl_rd_req && rg_haddr[15:0] != 16'd0 &&
	  rg_haddr[15:0] != 16'd16384 &&
	  rg_haddr[15:0] != 16'd49144 &&
	  rg_haddr[15:0] != 16'd4 &&
	  rg_haddr[15:0] != 16'd16388 &&
	  rg_haddr[15:0] != 16'd49148)
	$display("%06d:[E]:%m.rl_rd_req: unrecognized addr: 0x%08h",
		 v__h5449,
		 byte_addr__h2115);
  end
  // synopsys translate_on
endmodule  // mkCLINT_AHBL

