//
// Generated by Bluespec Compiler, version 2021.12.1-27-g9a7d5e05 (build 9a7d5e05)
//
//
// Ports:
// Name                         I/O  size props
// target_HRDATA                  O    32
// target_HREADYOUT               O     1 reg
// target_HRESP                   O     1 reg
// out                            O    16 reg
// CLK                            I     1 clock
// RST_N                          I     1 reset
// target_HSEL                    I     1
// target_HREADY                  I     1
// target_HADDR                   I    32
// target_HBURST                  I     3 unused
// target_HMASTLOCK               I     1 unused
// target_HPROT                   I     4 unused
// target_HSIZE                   I     3
// target_HTRANS                  I     2
// target_HWDATA                  I    32
// target_HWRITE                  I     1 reg
//
// No combinational paths from inputs to outputs
//
//
// 16-bit GPIO behind 32-bit AHB-L interface
// Word-addressed
// Single 16-bit register at offset 0x0
// Word writes at offset 0x0 will ignore upper 16 bits
// Byte/Half-Word/Word reads at offset 0x0 are okay
// All R/W accesses at non-0x0 offset will trigger error response
//
//

`ifdef BSV_ASSIGNMENT_DELAY
`else
  `define BSV_ASSIGNMENT_DELAY
`endif

`ifdef BSV_POSITIVE_RESET
  `define BSV_RESET_VALUE 1'b1
  `define BSV_RESET_EDGE posedge
`else
  `define BSV_RESET_VALUE 1'b0
  `define BSV_RESET_EDGE negedge
`endif

module mkGPIO(CLK,
	      RST_N,

	      target_HSEL,

	      target_HREADY,

	      target_HADDR,

	      target_HBURST,

	      target_HMASTLOCK,

	      target_HPROT,

	      target_HSIZE,

	      target_HTRANS,

	      target_HWDATA,

	      target_HWRITE,

	      target_HRDATA,

	      target_HREADYOUT,

	      target_HRESP,

	      out);
  input  CLK;
  input  RST_N;

  // action method target_hsel
  input  target_HSEL;

  // action method target_hready
  input  target_HREADY;

  // action method target_haddr
  input  [31 : 0] target_HADDR;

  // action method target_hburst
  input  [2 : 0] target_HBURST;

  // action method target_hmastlock
  input  target_HMASTLOCK;

  // action method target_hprot
  input  [3 : 0] target_HPROT;

  // action method target_hsize
  input  [2 : 0] target_HSIZE;

  // action method target_htrans
  input  [1 : 0] target_HTRANS;

  // action method target_hwdata
  input  [31 : 0] target_HWDATA;

  // action method target_hwrite
  input  target_HWRITE;

  // value method target_hrdata
  output [31 : 0] target_HRDATA;

  // value method target_hreadyout
  output target_HREADYOUT;

  // value method target_hresp
  output target_HRESP;

  // value method out
  output [15 : 0] out;

  // signals for module outputs
  wire [31 : 0] target_HRDATA;
  wire [15 : 0] out;
  wire target_HREADYOUT, target_HRESP;

  // register rg_gpio_out
  reg [15 : 0] rg_gpio_out;
  wire [15 : 0] rg_gpio_out$D_IN;
  wire rg_gpio_out$EN;

  // register rg_haddr
  reg [31 : 0] rg_haddr;
  wire [31 : 0] rg_haddr$D_IN;
  wire rg_haddr$EN;

  // register rg_hready
  reg rg_hready;
  wire rg_hready$D_IN, rg_hready$EN;

  // register rg_hresp
  reg rg_hresp;
  wire rg_hresp$D_IN, rg_hresp$EN;

  // register rg_hsize
  reg [2 : 0] rg_hsize;
  wire [2 : 0] rg_hsize$D_IN;
  wire rg_hsize$EN;

  // register rg_htrans
  reg [1 : 0] rg_htrans;
  wire [1 : 0] rg_htrans$D_IN;
  wire rg_htrans$EN;

  // register rg_hwrite
  reg rg_hwrite;
  wire rg_hwrite$D_IN, rg_hwrite$EN;

  // register rg_state
  reg [1 : 0] rg_state;
  wire [1 : 0] rg_state$D_IN;
  wire rg_state$EN;

  // rule scheduling signals
  wire CAN_FIRE_RL_rl_data,
       CAN_FIRE_RL_rl_error,
       CAN_FIRE_RL_rl_idle,
       CAN_FIRE_RL_rl_new_req,
       CAN_FIRE_target_haddr,
       CAN_FIRE_target_hburst,
       CAN_FIRE_target_hmastlock,
       CAN_FIRE_target_hprot,
       CAN_FIRE_target_hready,
       CAN_FIRE_target_hsel,
       CAN_FIRE_target_hsize,
       CAN_FIRE_target_htrans,
       CAN_FIRE_target_hwdata,
       CAN_FIRE_target_hwrite,
       WILL_FIRE_RL_rl_data,
       WILL_FIRE_RL_rl_error,
       WILL_FIRE_RL_rl_idle,
       WILL_FIRE_RL_rl_new_req,
       WILL_FIRE_target_haddr,
       WILL_FIRE_target_hburst,
       WILL_FIRE_target_hmastlock,
       WILL_FIRE_target_hprot,
       WILL_FIRE_target_hready,
       WILL_FIRE_target_hsel,
       WILL_FIRE_target_hsize,
       WILL_FIRE_target_htrans,
       WILL_FIRE_target_hwdata,
       WILL_FIRE_target_hwrite;

  // inputs to muxes for submodule ports
  wire [1 : 0] MUX_rg_state$write_1__VAL_1;
  wire MUX_rg_hready$write_1__VAL_1, MUX_rg_hresp$write_1__VAL_1;

  // remaining internal signals
  reg [31 : 0] IF_rg_haddr_6_BITS_1_TO_0_7_EQ_0b0_8_THEN_0_CO_ETC___d58,
	       new_word__h792;
  wire [31 : 0] IF_rg_haddr_6_BITS_1_TO_0_7_EQ_0b0_8_THEN_0_CO_ETC___d65,
		new_word__h1407,
		new_word__h1497,
		new_word__h1582,
		new_word__h1667,
		old_word__h1368;

  // action method target_hsel
  assign CAN_FIRE_target_hsel = 1'd1 ;
  assign WILL_FIRE_target_hsel = 1'd1 ;

  // action method target_hready
  assign CAN_FIRE_target_hready = 1'd1 ;
  assign WILL_FIRE_target_hready = 1'd1 ;

  // action method target_haddr
  assign CAN_FIRE_target_haddr = 1'd1 ;
  assign WILL_FIRE_target_haddr = 1'd1 ;

  // action method target_hburst
  assign CAN_FIRE_target_hburst = 1'd1 ;
  assign WILL_FIRE_target_hburst = 1'd1 ;

  // action method target_hmastlock
  assign CAN_FIRE_target_hmastlock = 1'd1 ;
  assign WILL_FIRE_target_hmastlock = 1'd1 ;

  // action method target_hprot
  assign CAN_FIRE_target_hprot = 1'd1 ;
  assign WILL_FIRE_target_hprot = 1'd1 ;

  // action method target_hsize
  assign CAN_FIRE_target_hsize = 1'd1 ;
  assign WILL_FIRE_target_hsize = 1'd1 ;

  // action method target_htrans
  assign CAN_FIRE_target_htrans = 1'd1 ;
  assign WILL_FIRE_target_htrans = 1'd1 ;

  // action method target_hwdata
  assign CAN_FIRE_target_hwdata = 1'd1 ;
  assign WILL_FIRE_target_hwdata = 1'd1 ;

  // action method target_hwrite
  assign CAN_FIRE_target_hwrite = 1'd1 ;
  assign WILL_FIRE_target_hwrite = 1'd1 ;

  // value method target_hrdata
  assign target_HRDATA = old_word__h1368 ;

  // value method target_hreadyout
  assign target_HREADYOUT = rg_hready ;

  // value method target_hresp
  assign target_HRESP = rg_hresp ;

  // value method out
  assign out = rg_gpio_out ;

  // rule RL_rl_new_req
  assign CAN_FIRE_RL_rl_new_req =
	     rg_state == 2'd0 && target_HSEL && target_HREADY &&
	     target_HTRANS == 2'd2 ;
  assign WILL_FIRE_RL_rl_new_req = CAN_FIRE_RL_rl_new_req ;

  // rule RL_rl_data
  assign CAN_FIRE_RL_rl_data = rg_state == 2'd1 ;
  assign WILL_FIRE_RL_rl_data = CAN_FIRE_RL_rl_data ;

  // rule RL_rl_idle
  assign CAN_FIRE_RL_rl_idle =
	     rg_state == 2'd0 && target_HSEL && target_HTRANS == 2'd0 ;
  assign WILL_FIRE_RL_rl_idle = CAN_FIRE_RL_rl_idle ;

  // rule RL_rl_error
  assign CAN_FIRE_RL_rl_error = rg_state == 2'd2 ;
  assign WILL_FIRE_RL_rl_error = CAN_FIRE_RL_rl_error ;

  // inputs to muxes for submodule ports
  assign MUX_rg_hready$write_1__VAL_1 =
	     target_HSIZE == 3'd0 ||
	     ((target_HSIZE == 3'd1) ?
		target_HADDR[1:0] == 2'b0 || target_HADDR[1:0] == 2'b10 :
		target_HSIZE == 3'd2 && target_HADDR[1:0] == 2'b0) ;
  assign MUX_rg_hresp$write_1__VAL_1 =
	     target_HSIZE != 3'd0 &&
	     ((target_HSIZE == 3'd1) ?
		target_HADDR[1:0] != 2'b0 && target_HADDR[1:0] != 2'b10 :
		target_HSIZE != 3'd2 || target_HADDR[1:0] != 2'b0) ;
  assign MUX_rg_state$write_1__VAL_1 =
	     (target_HSIZE == 3'd0 ||
	      ((target_HSIZE == 3'd1) ?
		 target_HADDR[1:0] == 2'b0 || target_HADDR[1:0] == 2'b10 :
		 target_HSIZE == 3'd2 && target_HADDR[1:0] == 2'b0)) ?
	       2'd1 :
	       2'd2 ;

  // register rg_gpio_out
  assign rg_gpio_out$D_IN = new_word__h792[15:0] ;
  assign rg_gpio_out$EN = WILL_FIRE_RL_rl_data && rg_hwrite ;

  // register rg_haddr
  assign rg_haddr$D_IN = target_HADDR ;
  assign rg_haddr$EN = CAN_FIRE_RL_rl_new_req ;

  // register rg_hready
  assign rg_hready$D_IN =
	     !WILL_FIRE_RL_rl_new_req || MUX_rg_hready$write_1__VAL_1 ;
  assign rg_hready$EN =
	     WILL_FIRE_RL_rl_new_req || WILL_FIRE_RL_rl_error ||
	     WILL_FIRE_RL_rl_idle ||
	     WILL_FIRE_RL_rl_data ;

  // register rg_hresp
  assign rg_hresp$D_IN =
	     WILL_FIRE_RL_rl_new_req && MUX_rg_hresp$write_1__VAL_1 ;
  assign rg_hresp$EN = WILL_FIRE_RL_rl_new_req || WILL_FIRE_RL_rl_error ;

  // register rg_hsize
  assign rg_hsize$D_IN = target_HSIZE ;
  assign rg_hsize$EN = CAN_FIRE_RL_rl_new_req ;

  // register rg_htrans
  assign rg_htrans$D_IN = target_HTRANS ;
  assign rg_htrans$EN = CAN_FIRE_RL_rl_new_req ;

  // register rg_hwrite
  assign rg_hwrite$D_IN = target_HWRITE ;
  assign rg_hwrite$EN = CAN_FIRE_RL_rl_new_req ;

  // register rg_state
  assign rg_state$D_IN =
	     WILL_FIRE_RL_rl_new_req ? MUX_rg_state$write_1__VAL_1 : 2'd0 ;
  assign rg_state$EN =
	     WILL_FIRE_RL_rl_new_req || WILL_FIRE_RL_rl_error ||
	     WILL_FIRE_RL_rl_data ;

  // remaining internal signals
  assign IF_rg_haddr_6_BITS_1_TO_0_7_EQ_0b0_8_THEN_0_CO_ETC___d65 =
	     (rg_haddr[1:0] == 2'b0) ?
	       { 16'd0, target_HWDATA[15:0] } :
	       { (rg_haddr[1:0] == 2'b10) ? target_HWDATA[31:16] : 16'd0,
		 rg_gpio_out } ;
  assign new_word__h1407 = { 16'd0, rg_gpio_out[15:8], target_HWDATA[7:0] } ;
  assign new_word__h1497 = { 16'd0, target_HWDATA[15:8], rg_gpio_out[7:0] } ;
  assign new_word__h1582 = { 8'd0, target_HWDATA[23:16], rg_gpio_out } ;
  assign new_word__h1667 = { target_HWDATA[31:24], 8'd0, rg_gpio_out } ;
  assign old_word__h1368 = { 16'd0, rg_gpio_out } ;
  always@(rg_haddr or
	  old_word__h1368 or
	  new_word__h1407 or
	  new_word__h1497 or new_word__h1582 or new_word__h1667)
  begin
    case (rg_haddr[1:0])
      2'b0:
	  IF_rg_haddr_6_BITS_1_TO_0_7_EQ_0b0_8_THEN_0_CO_ETC___d58 =
	      new_word__h1407;
      2'b01:
	  IF_rg_haddr_6_BITS_1_TO_0_7_EQ_0b0_8_THEN_0_CO_ETC___d58 =
	      new_word__h1497;
      2'b10:
	  IF_rg_haddr_6_BITS_1_TO_0_7_EQ_0b0_8_THEN_0_CO_ETC___d58 =
	      new_word__h1582;
      2'b11:
	  IF_rg_haddr_6_BITS_1_TO_0_7_EQ_0b0_8_THEN_0_CO_ETC___d58 =
	      new_word__h1667;
    endcase
  end
  always@(rg_hsize or
	  old_word__h1368 or
	  IF_rg_haddr_6_BITS_1_TO_0_7_EQ_0b0_8_THEN_0_CO_ETC___d58 or
	  IF_rg_haddr_6_BITS_1_TO_0_7_EQ_0b0_8_THEN_0_CO_ETC___d65 or
	  rg_haddr or target_HWDATA)
  begin
    case (rg_hsize)
      3'd0:
	  new_word__h792 =
	      IF_rg_haddr_6_BITS_1_TO_0_7_EQ_0b0_8_THEN_0_CO_ETC___d58;
      3'd1:
	  new_word__h792 =
	      IF_rg_haddr_6_BITS_1_TO_0_7_EQ_0b0_8_THEN_0_CO_ETC___d65;
      3'd2:
	  new_word__h792 =
	      (rg_haddr[1:0] == 2'b0) ? target_HWDATA : old_word__h1368;
      default: new_word__h792 = old_word__h1368;
    endcase
  end

  // handling of inlined registers

  always@(posedge CLK)
  begin
    if (RST_N == `BSV_RESET_VALUE)
      begin
        rg_gpio_out <= `BSV_ASSIGNMENT_DELAY 16'd0;
	rg_hready <= `BSV_ASSIGNMENT_DELAY 1'd1;
	rg_hresp <= `BSV_ASSIGNMENT_DELAY 1'd0;
	rg_hsize <= `BSV_ASSIGNMENT_DELAY 3'd2;
	rg_htrans <= `BSV_ASSIGNMENT_DELAY 2'd2;
	rg_hwrite <= `BSV_ASSIGNMENT_DELAY 1'd0;
	rg_state <= `BSV_ASSIGNMENT_DELAY 2'd0;
      end
    else
      begin
        if (rg_gpio_out$EN)
	  rg_gpio_out <= `BSV_ASSIGNMENT_DELAY rg_gpio_out$D_IN;
	if (rg_hready$EN) rg_hready <= `BSV_ASSIGNMENT_DELAY rg_hready$D_IN;
	if (rg_hresp$EN) rg_hresp <= `BSV_ASSIGNMENT_DELAY rg_hresp$D_IN;
	if (rg_hsize$EN) rg_hsize <= `BSV_ASSIGNMENT_DELAY rg_hsize$D_IN;
	if (rg_htrans$EN) rg_htrans <= `BSV_ASSIGNMENT_DELAY rg_htrans$D_IN;
	if (rg_hwrite$EN) rg_hwrite <= `BSV_ASSIGNMENT_DELAY rg_hwrite$D_IN;
	if (rg_state$EN) rg_state <= `BSV_ASSIGNMENT_DELAY rg_state$D_IN;
      end
    if (rg_haddr$EN) rg_haddr <= `BSV_ASSIGNMENT_DELAY rg_haddr$D_IN;
  end

  // synopsys translate_off
  `ifdef BSV_NO_INITIAL_BLOCKS
  `else // not BSV_NO_INITIAL_BLOCKS
  initial
  begin
    rg_gpio_out = 16'hAAAA;
    rg_haddr = 32'hAAAAAAAA;
    rg_hready = 1'h0;
    rg_hresp = 1'h0;
    rg_hsize = 3'h2;
    rg_htrans = 2'h2;
    rg_hwrite = 1'h0;
    rg_state = 2'h2;
  end
  `endif // BSV_NO_INITIAL_BLOCKS
  // synopsys translate_on
endmodule  // mkGPIO

