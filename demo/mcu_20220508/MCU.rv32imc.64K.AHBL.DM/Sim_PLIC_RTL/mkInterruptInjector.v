//
// Generated by Bluespec Compiler, version 2021.12.1-27-g9a7d5e05 (build 9a7d5e05)
//
//
// Ports:
// Name                         I/O  size props
// irq                            O     4 reg
// CLK                            I     1 clock
// RST_N                          I     1 reset
//
// No combinational paths from inputs to outputs
//
//

`ifdef BSV_ASSIGNMENT_DELAY
`else
  `define BSV_ASSIGNMENT_DELAY
`endif

`ifdef BSV_POSITIVE_RESET
  `define BSV_RESET_VALUE 1'b1
  `define BSV_RESET_EDGE posedge
`else
  `define BSV_RESET_VALUE 1'b0
  `define BSV_RESET_EDGE negedge
`endif

module mkInterruptInjector(CLK,
			   RST_N,

			   irq);
  input  CLK;
  input  RST_N;

  // value method irq
  output [3 : 0] irq;

  // signals for module outputs
  wire [3 : 0] irq;

  // register rg_counter
  reg [31 : 0] rg_counter;
  wire [31 : 0] rg_counter$D_IN;
  wire rg_counter$EN;

  // register rg_module_ready
  reg rg_module_ready;
  wire rg_module_ready$D_IN, rg_module_ready$EN;

  // register vrg_counter_0
  reg [31 : 0] vrg_counter_0;
  wire [31 : 0] vrg_counter_0$D_IN;
  wire vrg_counter_0$EN;

  // register vrg_counter_1
  reg [31 : 0] vrg_counter_1;
  wire [31 : 0] vrg_counter_1$D_IN;
  wire vrg_counter_1$EN;

  // register vrg_counter_2
  reg [31 : 0] vrg_counter_2;
  wire [31 : 0] vrg_counter_2$D_IN;
  wire vrg_counter_2$EN;

  // register vrg_counter_3
  reg [31 : 0] vrg_counter_3;
  wire [31 : 0] vrg_counter_3$D_IN;
  wire vrg_counter_3$EN;

  // register vrg_irq_0
  reg vrg_irq_0;
  wire vrg_irq_0$D_IN, vrg_irq_0$EN;

  // register vrg_irq_1
  reg vrg_irq_1;
  wire vrg_irq_1$D_IN, vrg_irq_1$EN;

  // register vrg_irq_2
  reg vrg_irq_2;
  wire vrg_irq_2$D_IN, vrg_irq_2$EN;

  // register vrg_irq_3
  reg vrg_irq_3;
  wire vrg_irq_3$D_IN, vrg_irq_3$EN;

  // rule scheduling signals
  wire CAN_FIRE_RL_rl_assert_irq,
       CAN_FIRE_RL_rl_assert_irq_1,
       CAN_FIRE_RL_rl_assert_irq_2,
       CAN_FIRE_RL_rl_assert_irq_3,
       CAN_FIRE_RL_rl_deassert_irq,
       CAN_FIRE_RL_rl_deassert_irq_1,
       CAN_FIRE_RL_rl_deassert_irq_2,
       CAN_FIRE_RL_rl_deassert_irq_3,
       WILL_FIRE_RL_rl_assert_irq,
       WILL_FIRE_RL_rl_assert_irq_1,
       WILL_FIRE_RL_rl_assert_irq_2,
       WILL_FIRE_RL_rl_assert_irq_3,
       WILL_FIRE_RL_rl_deassert_irq,
       WILL_FIRE_RL_rl_deassert_irq_1,
       WILL_FIRE_RL_rl_deassert_irq_2,
       WILL_FIRE_RL_rl_deassert_irq_3;

  // inputs to muxes for submodule ports
  wire [31 : 0] MUX_vrg_counter_0$write_1__VAL_1,
		MUX_vrg_counter_0$write_1__VAL_2,
		MUX_vrg_counter_1$write_1__VAL_1,
		MUX_vrg_counter_1$write_1__VAL_2,
		MUX_vrg_counter_2$write_1__VAL_1,
		MUX_vrg_counter_2$write_1__VAL_2,
		MUX_vrg_counter_3$write_1__VAL_1,
		MUX_vrg_counter_3$write_1__VAL_2;
  wire MUX_vrg_irq_0$write_1__SEL_1,
       MUX_vrg_irq_1$write_1__SEL_1,
       MUX_vrg_irq_2$write_1__SEL_1,
       MUX_vrg_irq_3$write_1__SEL_1;

  // remaining internal signals
  wire [31 : 0] nxt_count__h1224,
		nxt_count__h1472,
		nxt_count__h1720,
		nxt_count__h848;

  // value method irq
  assign irq = { vrg_irq_3, vrg_irq_2, vrg_irq_1, vrg_irq_0 } ;

  // rule RL_rl_assert_irq
  assign CAN_FIRE_RL_rl_assert_irq = !vrg_irq_0 ;
  assign WILL_FIRE_RL_rl_assert_irq = CAN_FIRE_RL_rl_assert_irq ;

  // rule RL_rl_deassert_irq
  assign CAN_FIRE_RL_rl_deassert_irq = vrg_irq_0 ;
  assign WILL_FIRE_RL_rl_deassert_irq = vrg_irq_0 ;

  // rule RL_rl_assert_irq_1
  assign CAN_FIRE_RL_rl_assert_irq_1 = !vrg_irq_1 ;
  assign WILL_FIRE_RL_rl_assert_irq_1 = CAN_FIRE_RL_rl_assert_irq_1 ;

  // rule RL_rl_deassert_irq_1
  assign CAN_FIRE_RL_rl_deassert_irq_1 = vrg_irq_1 ;
  assign WILL_FIRE_RL_rl_deassert_irq_1 = vrg_irq_1 ;

  // rule RL_rl_assert_irq_2
  assign CAN_FIRE_RL_rl_assert_irq_2 = !vrg_irq_2 ;
  assign WILL_FIRE_RL_rl_assert_irq_2 = CAN_FIRE_RL_rl_assert_irq_2 ;

  // rule RL_rl_deassert_irq_2
  assign CAN_FIRE_RL_rl_deassert_irq_2 = vrg_irq_2 ;
  assign WILL_FIRE_RL_rl_deassert_irq_2 = vrg_irq_2 ;

  // rule RL_rl_assert_irq_3
  assign CAN_FIRE_RL_rl_assert_irq_3 = !vrg_irq_3 ;
  assign WILL_FIRE_RL_rl_assert_irq_3 = CAN_FIRE_RL_rl_assert_irq_3 ;

  // rule RL_rl_deassert_irq_3
  assign CAN_FIRE_RL_rl_deassert_irq_3 = vrg_irq_3 ;
  assign WILL_FIRE_RL_rl_deassert_irq_3 = vrg_irq_3 ;

  // inputs to muxes for submodule ports
  assign MUX_vrg_irq_0$write_1__SEL_1 =
	     WILL_FIRE_RL_rl_assert_irq && nxt_count__h848[10] ;
  assign MUX_vrg_irq_1$write_1__SEL_1 =
	     WILL_FIRE_RL_rl_assert_irq_1 && nxt_count__h1224[11] ;
  assign MUX_vrg_irq_2$write_1__SEL_1 =
	     WILL_FIRE_RL_rl_assert_irq_2 && nxt_count__h1472[12] ;
  assign MUX_vrg_irq_3$write_1__SEL_1 =
	     WILL_FIRE_RL_rl_assert_irq_3 && nxt_count__h1720[13] ;
  assign MUX_vrg_counter_0$write_1__VAL_1 = vrg_counter_0 - 32'd1 ;
  assign MUX_vrg_counter_0$write_1__VAL_2 =
	     nxt_count__h848[10] ? 32'h00000100 : nxt_count__h848 ;
  assign MUX_vrg_counter_1$write_1__VAL_1 = vrg_counter_1 - 32'd1 ;
  assign MUX_vrg_counter_1$write_1__VAL_2 =
	     nxt_count__h1224[11] ? 32'h00000100 : nxt_count__h1224 ;
  assign MUX_vrg_counter_2$write_1__VAL_1 = vrg_counter_2 - 32'd1 ;
  assign MUX_vrg_counter_2$write_1__VAL_2 =
	     nxt_count__h1472[12] ? 32'h00000100 : nxt_count__h1472 ;
  assign MUX_vrg_counter_3$write_1__VAL_1 = vrg_counter_3 - 32'd1 ;
  assign MUX_vrg_counter_3$write_1__VAL_2 =
	     nxt_count__h1720[13] ? 32'h00000100 : nxt_count__h1720 ;

  // register rg_counter
  assign rg_counter$D_IN = 32'h0 ;
  assign rg_counter$EN = 1'b0 ;

  // register rg_module_ready
  assign rg_module_ready$D_IN = 1'b0 ;
  assign rg_module_ready$EN = 1'b0 ;

  // register vrg_counter_0
  assign vrg_counter_0$D_IN =
	     vrg_irq_0 ?
	       MUX_vrg_counter_0$write_1__VAL_1 :
	       MUX_vrg_counter_0$write_1__VAL_2 ;
  assign vrg_counter_0$EN = vrg_irq_0 || WILL_FIRE_RL_rl_assert_irq ;

  // register vrg_counter_1
  assign vrg_counter_1$D_IN =
	     vrg_irq_1 ?
	       MUX_vrg_counter_1$write_1__VAL_1 :
	       MUX_vrg_counter_1$write_1__VAL_2 ;
  assign vrg_counter_1$EN = vrg_irq_1 || WILL_FIRE_RL_rl_assert_irq_1 ;

  // register vrg_counter_2
  assign vrg_counter_2$D_IN =
	     vrg_irq_2 ?
	       MUX_vrg_counter_2$write_1__VAL_1 :
	       MUX_vrg_counter_2$write_1__VAL_2 ;
  assign vrg_counter_2$EN = vrg_irq_2 || WILL_FIRE_RL_rl_assert_irq_2 ;

  // register vrg_counter_3
  assign vrg_counter_3$D_IN =
	     vrg_irq_3 ?
	       MUX_vrg_counter_3$write_1__VAL_1 :
	       MUX_vrg_counter_3$write_1__VAL_2 ;
  assign vrg_counter_3$EN = vrg_irq_3 || WILL_FIRE_RL_rl_assert_irq_3 ;

  // register vrg_irq_0
  assign vrg_irq_0$D_IN = MUX_vrg_irq_0$write_1__SEL_1 ;
  assign vrg_irq_0$EN =
	     WILL_FIRE_RL_rl_assert_irq && nxt_count__h848[10] ||
	     vrg_irq_0 && vrg_counter_0 == 32'd1 ;

  // register vrg_irq_1
  assign vrg_irq_1$D_IN = MUX_vrg_irq_1$write_1__SEL_1 ;
  assign vrg_irq_1$EN =
	     WILL_FIRE_RL_rl_assert_irq_1 && nxt_count__h1224[11] ||
	     vrg_irq_1 && vrg_counter_1 == 32'd1 ;

  // register vrg_irq_2
  assign vrg_irq_2$D_IN = MUX_vrg_irq_2$write_1__SEL_1 ;
  assign vrg_irq_2$EN =
	     WILL_FIRE_RL_rl_assert_irq_2 && nxt_count__h1472[12] ||
	     vrg_irq_2 && vrg_counter_2 == 32'd1 ;

  // register vrg_irq_3
  assign vrg_irq_3$D_IN = MUX_vrg_irq_3$write_1__SEL_1 ;
  assign vrg_irq_3$EN =
	     WILL_FIRE_RL_rl_assert_irq_3 && nxt_count__h1720[13] ||
	     vrg_irq_3 && vrg_counter_3 == 32'd1 ;

  // remaining internal signals
  assign nxt_count__h1224 = vrg_counter_1 + 32'd1 ;
  assign nxt_count__h1472 = vrg_counter_2 + 32'd1 ;
  assign nxt_count__h1720 = vrg_counter_3 + 32'd1 ;
  assign nxt_count__h848 = vrg_counter_0 + 32'd1 ;

  // handling of inlined registers

  always@(posedge CLK)
  begin
    if (RST_N == `BSV_RESET_VALUE)
      begin
        rg_counter <= `BSV_ASSIGNMENT_DELAY 32'd0;
	rg_module_ready <= `BSV_ASSIGNMENT_DELAY 1'd1;
	vrg_counter_0 <= `BSV_ASSIGNMENT_DELAY 32'd0;
	vrg_counter_1 <= `BSV_ASSIGNMENT_DELAY 32'd0;
	vrg_counter_2 <= `BSV_ASSIGNMENT_DELAY 32'd0;
	vrg_counter_3 <= `BSV_ASSIGNMENT_DELAY 32'd0;
	vrg_irq_0 <= `BSV_ASSIGNMENT_DELAY 1'd0;
	vrg_irq_1 <= `BSV_ASSIGNMENT_DELAY 1'd0;
	vrg_irq_2 <= `BSV_ASSIGNMENT_DELAY 1'd0;
	vrg_irq_3 <= `BSV_ASSIGNMENT_DELAY 1'd0;
      end
    else
      begin
        if (rg_counter$EN)
	  rg_counter <= `BSV_ASSIGNMENT_DELAY rg_counter$D_IN;
	if (rg_module_ready$EN)
	  rg_module_ready <= `BSV_ASSIGNMENT_DELAY rg_module_ready$D_IN;
	if (vrg_counter_0$EN)
	  vrg_counter_0 <= `BSV_ASSIGNMENT_DELAY vrg_counter_0$D_IN;
	if (vrg_counter_1$EN)
	  vrg_counter_1 <= `BSV_ASSIGNMENT_DELAY vrg_counter_1$D_IN;
	if (vrg_counter_2$EN)
	  vrg_counter_2 <= `BSV_ASSIGNMENT_DELAY vrg_counter_2$D_IN;
	if (vrg_counter_3$EN)
	  vrg_counter_3 <= `BSV_ASSIGNMENT_DELAY vrg_counter_3$D_IN;
	if (vrg_irq_0$EN) vrg_irq_0 <= `BSV_ASSIGNMENT_DELAY vrg_irq_0$D_IN;
	if (vrg_irq_1$EN) vrg_irq_1 <= `BSV_ASSIGNMENT_DELAY vrg_irq_1$D_IN;
	if (vrg_irq_2$EN) vrg_irq_2 <= `BSV_ASSIGNMENT_DELAY vrg_irq_2$D_IN;
	if (vrg_irq_3$EN) vrg_irq_3 <= `BSV_ASSIGNMENT_DELAY vrg_irq_3$D_IN;
      end
  end

  // synopsys translate_off
  `ifdef BSV_NO_INITIAL_BLOCKS
  `else // not BSV_NO_INITIAL_BLOCKS
  initial
  begin
    rg_counter = 32'hAAAAAAAA;
    rg_module_ready = 1'h0;
    vrg_counter_0 = 32'hAAAAAAAA;
    vrg_counter_1 = 32'hAAAAAAAA;
    vrg_counter_2 = 32'hAAAAAAAA;
    vrg_counter_3 = 32'hAAAAAAAA;
    vrg_irq_0 = 1'h0;
    vrg_irq_1 = 1'h0;
    vrg_irq_2 = 1'h0;
    vrg_irq_3 = 1'h0;
  end
  `endif // BSV_NO_INITIAL_BLOCKS
  // synopsys translate_on
endmodule  // mkInterruptInjector

