
main_blinky.elf:     file format elf32-littleriscv


Disassembly of section .text:

c0000000 <boot>:
#endif

/* Startup code */
.globl boot
boot:
    li t6, 0x1800
c0000000:	00002fb7          	lui	t6,0x2
c0000004:	800f8f93          	addi	t6,t6,-2048 # 1800 <_STACK_SIZE+0x800>
    csrw mstatus, t6
c0000008:	300f9073          	csrw	mstatus,t6
    sd              a1, xDtbAddr, t6
#else
    sw              a1, xDtbAddr, t6
#endif
#endif
    j _mstart
c000000c:	0040006f          	j	c0000010 <_mstart>

c0000010 <_mstart>:

_mstart:
    li	x1, 0
c0000010:	00000093          	li	ra,0
    li	x2, 0
c0000014:	00000113          	li	sp,0
    li	x3, 0
c0000018:	00000193          	li	gp,0
    li	x4, 0
c000001c:	00000213          	li	tp,0
    li	x5, 0
c0000020:	00000293          	li	t0,0
	li	x6, 0
c0000024:	00000313          	li	t1,0
    li	x7, 0
c0000028:	00000393          	li	t2,0
    li	x8, 0
c000002c:	00000413          	li	s0,0
    li	x9, 0
c0000030:	00000493          	li	s1,0
    li	x10, 0
c0000034:	00000513          	li	a0,0
    li	x11, 0
c0000038:	00000593          	li	a1,0
    li	x12, 0
c000003c:	00000613          	li	a2,0
    li	x13, 0
c0000040:	00000693          	li	a3,0
    li	x14, 0
c0000044:	00000713          	li	a4,0
    li	x15, 0
c0000048:	00000793          	li	a5,0
    li	x16, 0
c000004c:	00000813          	li	a6,0
    li	x17, 0
c0000050:	00000893          	li	a7,0
    li	x18, 0
c0000054:	00000913          	li	s2,0
    li	x19, 0
c0000058:	00000993          	li	s3,0
    li	x20, 0
c000005c:	00000a13          	li	s4,0
    li	x21, 0
c0000060:	00000a93          	li	s5,0
    li	x22, 0
c0000064:	00000b13          	li	s6,0
    li	x23, 0
c0000068:	00000b93          	li	s7,0
    li	x24, 0
c000006c:	00000c13          	li	s8,0
    li	x25, 0
c0000070:	00000c93          	li	s9,0
    li	x26, 0
c0000074:	00000d13          	li	s10,0
    li	x27, 0
c0000078:	00000d93          	li	s11,0
    li	x28, 0
c000007c:	00000e13          	li	t3,0
    li	x29, 0
c0000080:	00000e93          	li	t4,0
    li	x30, 0
c0000084:	00000f13          	li	t5,0
    li	x31, 0
c0000088:	00000f93          	li	t6,0

    /* initialize global pointer */
    la	gp, _gp
c000008c:	08003197          	auipc	gp,0x8003
c0000090:	0a418193          	addi	gp,gp,164 # c8003130 <_gp>

c0000094 <init_bss>:

init_bss:
    /* init bss section */
    la	a0, __bss_start
c0000094:	08003517          	auipc	a0,0x8003
c0000098:	47450513          	addi	a0,a0,1140 # c8003508 <xQueueRegistry>
    la	a1, (__bss_end-4) /* section end is actually the start of the next section */
c000009c:	08043597          	auipc	a1,0x8043
c00000a0:	7b858593          	addi	a1,a1,1976 # c8043854 <__malloc_current_mallinfo+0x28>
    li	a2, 0x0
c00000a4:	00000613          	li	a2,0
    jal	fill_block
c00000a8:	044000ef          	jal	ra,c00000ec <fill_block>

c00000ac <init_sbss>:

init_sbss:
    /* init bss section */
    la	a0, __sbss_start
c00000ac:	08002517          	auipc	a0,0x8002
c00000b0:	7d450513          	addi	a0,a0,2004 # c8002880 <ullNextTime>
    la	a1, (__sbss_end-4) /* section end is actually the start of the next section */
c00000b4:	08003597          	auipc	a1,0x8003
c00000b8:	87458593          	addi	a1,a1,-1932 # c8002928 <errno>
    li	a2, 0x0
c00000bc:	00000613          	li	a2,0
    jal	fill_block
c00000c0:	02c000ef          	jal	ra,c00000ec <fill_block>

c00000c4 <write_stack_pattern>:

write_stack_pattern:
    /* init bss section */
    la	a0, _stack_end  /* note the stack grows from top to bottom */
c00000c4:	08043517          	auipc	a0,0x8043
c00000c8:	79450513          	addi	a0,a0,1940 # c8043858 <__bss_end>
    la	a1, (__stack-4)   /* section end is actually the start of the next section */
c00000cc:	08044597          	auipc	a1,0x8044
c00000d0:	78858593          	addi	a1,a1,1928 # c8044854 <__bss_end+0xffc>
    li	a2, 0xABABABAB
c00000d4:	ababb637          	lui	a2,0xababb
c00000d8:	bab60613          	addi	a2,a2,-1109 # abababab <_end+0xe3a3632b>
    jal	fill_block
c00000dc:	010000ef          	jal	ra,c00000ec <fill_block>

c00000e0 <init_stack>:

init_stack:
    /* set stack pointer */
    la	sp, _stack
c00000e0:	08044117          	auipc	sp,0x8044
c00000e4:	77810113          	addi	sp,sp,1912 # c8044858 <__stack>

	j	main
c00000e8:	2790906f          	j	c0009b60 <main>

c00000ec <fill_block>:

/* Fills memory blocks */
fill_block:
    sw		a2, 0(a0)
c00000ec:	00c52023          	sw	a2,0(a0)
    bgeu	a0, a1, fb_end
c00000f0:	00b57663          	bgeu	a0,a1,c00000fc <fb_end>
    addi	a0, a0, 4
c00000f4:	00450513          	addi	a0,a0,4
    j		fill_block
c00000f8:	ff5ff06f          	j	c00000ec <fill_block>

c00000fc <fb_end>:
fb_end:
    ret
c00000fc:	00008067          	ret

c0000100 <freertos_risc_v_trap_handler>:
/*-----------------------------------------------------------*/

.align 8

freertos_risc_v_trap_handler:
	addi sp, sp, -portCONTEXT_SIZE
c0000100:	f8810113          	addi	sp,sp,-120
	store_x x1, 1 * portWORD_SIZE( sp )
c0000104:	00112223          	sw	ra,4(sp)
	store_x x5, 2 * portWORD_SIZE( sp )
c0000108:	00512423          	sw	t0,8(sp)
	store_x x6, 3 * portWORD_SIZE( sp )
c000010c:	00612623          	sw	t1,12(sp)
	store_x x7, 4 * portWORD_SIZE( sp )
c0000110:	00712823          	sw	t2,16(sp)
	store_x x8, 5 * portWORD_SIZE( sp )
c0000114:	00812a23          	sw	s0,20(sp)
	store_x x9, 6 * portWORD_SIZE( sp )
c0000118:	00912c23          	sw	s1,24(sp)
	store_x x10, 7 * portWORD_SIZE( sp )
c000011c:	00a12e23          	sw	a0,28(sp)
	store_x x11, 8 * portWORD_SIZE( sp )
c0000120:	02b12023          	sw	a1,32(sp)
	store_x x12, 9 * portWORD_SIZE( sp )
c0000124:	02c12223          	sw	a2,36(sp)
	store_x x13, 10 * portWORD_SIZE( sp )
c0000128:	02d12423          	sw	a3,40(sp)
	store_x x14, 11 * portWORD_SIZE( sp )
c000012c:	02e12623          	sw	a4,44(sp)
	store_x x15, 12 * portWORD_SIZE( sp )
c0000130:	02f12823          	sw	a5,48(sp)
	store_x x16, 13 * portWORD_SIZE( sp )
c0000134:	03012a23          	sw	a6,52(sp)
	store_x x17, 14 * portWORD_SIZE( sp )
c0000138:	03112c23          	sw	a7,56(sp)
	store_x x18, 15 * portWORD_SIZE( sp )
c000013c:	03212e23          	sw	s2,60(sp)
	store_x x19, 16 * portWORD_SIZE( sp )
c0000140:	05312023          	sw	s3,64(sp)
	store_x x20, 17 * portWORD_SIZE( sp )
c0000144:	05412223          	sw	s4,68(sp)
	store_x x21, 18 * portWORD_SIZE( sp )
c0000148:	05512423          	sw	s5,72(sp)
	store_x x22, 19 * portWORD_SIZE( sp )
c000014c:	05612623          	sw	s6,76(sp)
	store_x x23, 20 * portWORD_SIZE( sp )
c0000150:	05712823          	sw	s7,80(sp)
	store_x x24, 21 * portWORD_SIZE( sp )
c0000154:	05812a23          	sw	s8,84(sp)
	store_x x25, 22 * portWORD_SIZE( sp )
c0000158:	05912c23          	sw	s9,88(sp)
	store_x x26, 23 * portWORD_SIZE( sp )
c000015c:	05a12e23          	sw	s10,92(sp)
	store_x x27, 24 * portWORD_SIZE( sp )
c0000160:	07b12023          	sw	s11,96(sp)
	store_x x28, 25 * portWORD_SIZE( sp )
c0000164:	07c12223          	sw	t3,100(sp)
	store_x x29, 26 * portWORD_SIZE( sp )
c0000168:	07d12423          	sw	t4,104(sp)
	store_x x30, 27 * portWORD_SIZE( sp )
c000016c:	07e12623          	sw	t5,108(sp)
	store_x x31, 28 * portWORD_SIZE( sp )
c0000170:	07f12823          	sw	t6,112(sp)

	csrr t0, mstatus					/* Required for MPIE bit. */
c0000174:	300022f3          	csrr	t0,mstatus
	store_x t0, 29 * portWORD_SIZE( sp )
c0000178:	06512a23          	sw	t0,116(sp)

	portasmSAVE_ADDITIONAL_REGISTERS	/* Defined in freertos_risc_v_chip_specific_extensions.h to save any registers unique to the RISC-V implementation. */

	load_x  t0, pxCurrentTCB			/* Load pxCurrentTCB. */
c000017c:	08002297          	auipc	t0,0x8002
c0000180:	7102a283          	lw	t0,1808(t0) # c800288c <pxCurrentTCB>
	store_x  sp, 0( t0 )				/* Write sp to first TCB member. */
c0000184:	0022a023          	sw	sp,0(t0)

	csrr a0, mcause
c0000188:	34202573          	csrr	a0,mcause
	csrr a1, mepc
c000018c:	341025f3          	csrr	a1,mepc

c0000190 <test_if_asynchronous>:

test_if_asynchronous:
	srli a2, a0, __riscv_xlen - 1		/* MSB of mcause is 1 if handing an asynchronous interrupt - shift to LSB to clear other bits. */
c0000190:	01f55613          	srli	a2,a0,0x1f
	beq a2, x0, handle_synchronous		/* Branch past interrupt handing if not asynchronous. */
c0000194:	08060663          	beqz	a2,c0000220 <handle_synchronous>
	store_x a1, 0( sp )					/* Asynch so save unmodified exception return address. */
c0000198:	00b12023          	sw	a1,0(sp)

c000019c <handle_asynchronous>:

#if( portasmHAS_MTIME != 0 )

	test_if_mtimer:						/* If there is a CLINT then the mtimer is used to generate the tick interrupt. */

		addi t0, x0, 1
c000019c:	00100293          	li	t0,1

		slli t0, t0, __riscv_xlen - 1   /* LSB is already set, shift into MSB.  Shift 31 on 32-bit or 63 on 64-bit cores. */
c00001a0:	01f29293          	slli	t0,t0,0x1f
		addi t1, t0, 7					/* 0x8000[]0007 == machine timer interrupt. */
c00001a4:	00728313          	addi	t1,t0,7
		bne a0, t1, test_if_external_interrupt
c00001a8:	06651063          	bne	a0,t1,c0000208 <test_if_external_interrupt>

		load_x t0, pullMachineTimerCompareRegister  /* Load address of compare register into t0. */
c00001ac:	08002297          	auipc	t0,0x8002
c00001b0:	6dc2a283          	lw	t0,1756(t0) # c8002888 <pullMachineTimerCompareRegister>
		load_x t1, pullNextTime  		/* Load the address of ullNextTime into t1. */
c00001b4:	08002317          	auipc	t1,0x8002
c00001b8:	7a832303          	lw	t1,1960(t1) # c800295c <pullNextTime>

		#if( __riscv_xlen == 32 )

			/* Update the 64-bit mtimer compare match value in two 32-bit writes. */
			li t4, -1
c00001bc:	fff00e93          	li	t4,-1
			lw t2, 0(t1)				/* Load the low word of ullNextTime into t2. */
c00001c0:	00032383          	lw	t2,0(t1)
			lw t3, 4(t1)				/* Load the high word of ullNextTime into t3. */
c00001c4:	00432e03          	lw	t3,4(t1)
			sw t4, 0(t0)				/* Low word no smaller than old value to start with - will be overwritten below. */
c00001c8:	01d2a023          	sw	t4,0(t0)
			sw t3, 4(t0)				/* Store high word of ullNextTime into compare register.  No smaller than new value. */
c00001cc:	01c2a223          	sw	t3,4(t0)
			sw t2, 0(t0)				/* Store low word of ullNextTime into compare register. */
c00001d0:	0072a023          	sw	t2,0(t0)
			lw t0, uxTimerIncrementsForOneTick	/* Load the value of ullTimerIncrementForOneTick into t0 (could this be optimized by storing in an array next to pullNextTime?). */
c00001d4:	08002297          	auipc	t0,0x8002
c00001d8:	7782a283          	lw	t0,1912(t0) # c800294c <uxTimerIncrementsForOneTick>
			add t4, t0, t2				/* Add the low word of ullNextTime to the timer increments for one tick (assumes timer increment for one tick fits in 32-bits). */
c00001dc:	00728eb3          	add	t4,t0,t2
			sltu t5, t4, t2				/* See if the sum of low words overflowed (what about the zero case?). */
c00001e0:	007ebf33          	sltu	t5,t4,t2
			add t6, t3, t5				/* Add overflow to high word of ullNextTime. */
c00001e4:	01ee0fb3          	add	t6,t3,t5
			sw t4, 0(t1)				/* Store new low word of ullNextTime. */
c00001e8:	01d32023          	sw	t4,0(t1)
			sw t6, 4(t1)				/* Store new high word of ullNextTime. */
c00001ec:	01f32223          	sw	t6,4(t1)
			add t4, t0, t2				/* Add ullNextTime to the timer increments for one tick. */
			sd t4, 0(t1)				/* Store ullNextTime. */

		#endif /* __riscv_xlen == 64 */

		load_x sp, xISRStackTop			/* Switch to ISR stack before function call. */
c00001f0:	08002117          	auipc	sp,0x8002
c00001f4:	75812103          	lw	sp,1880(sp) # c8002948 <xISRStackTop>
		jal xTaskIncrementTick
c00001f8:	0c8040ef          	jal	ra,c00042c0 <xTaskIncrementTick>
		beqz a0, processed_source		/* Don't switch context if incrementing tick didn't unblock a task. */
c00001fc:	04050e63          	beqz	a0,c0000258 <processed_source>
		jal vTaskSwitchContext
c0000200:	368040ef          	jal	ra,c0004568 <vTaskSwitchContext>
		j processed_source
c0000204:	0540006f          	j	c0000258 <processed_source>

c0000208 <test_if_external_interrupt>:

	test_if_external_interrupt:			/* If there is a CLINT and the mtimer interrupt is not pending then check to see if an external interrupt is pending. */
		addi t1, t1, 4					/* 0x80000007 + 4 = 0x8000000b == Machine external interrupt. */
c0000208:	00430313          	addi	t1,t1,4
		bne a0, t1, as_yet_unhandled	/* Something as yet unhandled. */
c000020c:	04651263          	bne	a0,t1,c0000250 <as_yet_unhandled>

#endif /* portasmHAS_MTIME */

	load_x sp, xISRStackTop				/* Switch to ISR stack before function call. */
c0000210:	08002117          	auipc	sp,0x8002
c0000214:	73812103          	lw	sp,1848(sp) # c8002948 <xISRStackTop>
	jal portasmHANDLE_INTERRUPT			/* Jump to the interrupt handler if there is no CLINT or if there is a CLINT and it has been determined that an external interrupt is pending. */
c0000218:	42d090ef          	jal	ra,c0009e44 <external_interrupt_handler>
	j processed_source
c000021c:	03c0006f          	j	c0000258 <processed_source>

c0000220 <handle_synchronous>:

handle_synchronous:
	addi a1, a1, 4						/* Synchronous so updated exception return address to the instruction after the instruction that generated the exeption. */
c0000220:	00458593          	addi	a1,a1,4
	store_x a1, 0( sp )					/* Save updated exception return address. */
c0000224:	00b12023          	sw	a1,0(sp)

c0000228 <test_if_environment_call>:

test_if_environment_call:
	li t0, 11 							/* 11 == environment call. */
c0000228:	00b00293          	li	t0,11
	bne a0, t0, is_exception			/* Not an M environment call, so some other exception. */
c000022c:	00551a63          	bne	a0,t0,c0000240 <is_exception>
	load_x sp, xISRStackTop				/* Switch to ISR stack before function call. */
c0000230:	08002117          	auipc	sp,0x8002
c0000234:	71812103          	lw	sp,1816(sp) # c8002948 <xISRStackTop>
	jal vTaskSwitchContext
c0000238:	330040ef          	jal	ra,c0004568 <vTaskSwitchContext>
	j processed_source
c000023c:	01c0006f          	j	c0000258 <processed_source>

c0000240 <is_exception>:

is_exception:
	csrr t0, mcause						/* For viewing in the debugger only. */
c0000240:	342022f3          	csrr	t0,mcause
	csrr t1, mepc						/* For viewing in the debugger only */
c0000244:	34102373          	csrr	t1,mepc
	csrr t2, mstatus
c0000248:	300023f3          	csrr	t2,mstatus
	j is_exception						/* No other exceptions handled yet. */
c000024c:	ff5ff06f          	j	c0000240 <is_exception>

c0000250 <as_yet_unhandled>:

as_yet_unhandled:
	csrr t0, mcause						/* For viewing in the debugger only. */
c0000250:	342022f3          	csrr	t0,mcause
	j as_yet_unhandled
c0000254:	ffdff06f          	j	c0000250 <as_yet_unhandled>

c0000258 <processed_source>:

processed_source:
	load_x  t1, pxCurrentTCB			/* Load pxCurrentTCB. */
c0000258:	08002317          	auipc	t1,0x8002
c000025c:	63432303          	lw	t1,1588(t1) # c800288c <pxCurrentTCB>
	load_x  sp, 0( t1 )				 	/* Read sp from first TCB member. */
c0000260:	00032103          	lw	sp,0(t1)

	/* Load mret with the address of the next instruction in the task to run next. */
	load_x t0, 0( sp )
c0000264:	00012283          	lw	t0,0(sp)
	csrw mepc, t0
c0000268:	34129073          	csrw	mepc,t0

	portasmRESTORE_ADDITIONAL_REGISTERS	/* Defined in freertos_risc_v_chip_specific_extensions.h to restore any registers unique to the RISC-V implementation. */

	/* Load mstatus with the interrupt enable bits used by the task. */
	load_x  t0, 29 * portWORD_SIZE( sp )
c000026c:	07412283          	lw	t0,116(sp)
	csrw mstatus, t0						/* Required for MPIE bit. */
c0000270:	30029073          	csrw	mstatus,t0

	load_x  x1, 1 * portWORD_SIZE( sp )
c0000274:	00412083          	lw	ra,4(sp)
	load_x  x5, 2 * portWORD_SIZE( sp )		/* t0 */
c0000278:	00812283          	lw	t0,8(sp)
	load_x  x6, 3 * portWORD_SIZE( sp )		/* t1 */
c000027c:	00c12303          	lw	t1,12(sp)
	load_x  x7, 4 * portWORD_SIZE( sp )		/* t2 */
c0000280:	01012383          	lw	t2,16(sp)
	load_x  x8, 5 * portWORD_SIZE( sp )		/* s0/fp */
c0000284:	01412403          	lw	s0,20(sp)
	load_x  x9, 6 * portWORD_SIZE( sp )		/* s1 */
c0000288:	01812483          	lw	s1,24(sp)
	load_x  x10, 7 * portWORD_SIZE( sp )	/* a0 */
c000028c:	01c12503          	lw	a0,28(sp)
	load_x  x11, 8 * portWORD_SIZE( sp )	/* a1 */
c0000290:	02012583          	lw	a1,32(sp)
	load_x  x12, 9 * portWORD_SIZE( sp )	/* a2 */
c0000294:	02412603          	lw	a2,36(sp)
	load_x  x13, 10 * portWORD_SIZE( sp )	/* a3 */
c0000298:	02812683          	lw	a3,40(sp)
	load_x  x14, 11 * portWORD_SIZE( sp )	/* a4 */
c000029c:	02c12703          	lw	a4,44(sp)
	load_x  x15, 12 * portWORD_SIZE( sp )	/* a5 */
c00002a0:	03012783          	lw	a5,48(sp)
	load_x  x16, 13 * portWORD_SIZE( sp )	/* a6 */
c00002a4:	03412803          	lw	a6,52(sp)
	load_x  x17, 14 * portWORD_SIZE( sp )	/* a7 */
c00002a8:	03812883          	lw	a7,56(sp)
	load_x  x18, 15 * portWORD_SIZE( sp )	/* s2 */
c00002ac:	03c12903          	lw	s2,60(sp)
	load_x  x19, 16 * portWORD_SIZE( sp )	/* s3 */
c00002b0:	04012983          	lw	s3,64(sp)
	load_x  x20, 17 * portWORD_SIZE( sp )	/* s4 */
c00002b4:	04412a03          	lw	s4,68(sp)
	load_x  x21, 18 * portWORD_SIZE( sp )	/* s5 */
c00002b8:	04812a83          	lw	s5,72(sp)
	load_x  x22, 19 * portWORD_SIZE( sp )	/* s6 */
c00002bc:	04c12b03          	lw	s6,76(sp)
	load_x  x23, 20 * portWORD_SIZE( sp )	/* s7 */
c00002c0:	05012b83          	lw	s7,80(sp)
	load_x  x24, 21 * portWORD_SIZE( sp )	/* s8 */
c00002c4:	05412c03          	lw	s8,84(sp)
	load_x  x25, 22 * portWORD_SIZE( sp )	/* s9 */
c00002c8:	05812c83          	lw	s9,88(sp)
	load_x  x26, 23 * portWORD_SIZE( sp )	/* s10 */
c00002cc:	05c12d03          	lw	s10,92(sp)
	load_x  x27, 24 * portWORD_SIZE( sp )	/* s11 */
c00002d0:	06012d83          	lw	s11,96(sp)
	load_x  x28, 25 * portWORD_SIZE( sp )	/* t3 */
c00002d4:	06412e03          	lw	t3,100(sp)
	load_x  x29, 26 * portWORD_SIZE( sp )	/* t4 */
c00002d8:	06812e83          	lw	t4,104(sp)
	load_x  x30, 27 * portWORD_SIZE( sp )	/* t5 */
c00002dc:	06c12f03          	lw	t5,108(sp)
	load_x  x31, 28 * portWORD_SIZE( sp )	/* t6 */
c00002e0:	07012f83          	lw	t6,112(sp)
	addi sp, sp, portCONTEXT_SIZE
c00002e4:	07810113          	addi	sp,sp,120

	mret
c00002e8:	30200073          	mret
c00002ec:	00000013          	nop
c00002f0:	00000013          	nop
c00002f4:	00000013          	nop
c00002f8:	00000013          	nop
c00002fc:	00000013          	nop

c0000300 <xPortStartFirstTask>:

#if( portasmHAS_MTIME != 0 )
	/* If there is a clint then interrupts can branch directly to the FreeRTOS
	trap handler.  Otherwise the interrupt controller will need to be configured
	outside of this file. */
	la t0, freertos_risc_v_trap_handler
c0000300:	00000297          	auipc	t0,0x0
c0000304:	e0028293          	addi	t0,t0,-512 # c0000100 <freertos_risc_v_trap_handler>
	csrw mtvec, t0
c0000308:	30529073          	csrw	mtvec,t0
#endif /* portasmHAS_CLILNT */

	load_x  sp, pxCurrentTCB			/* Load pxCurrentTCB. */
c000030c:	08002117          	auipc	sp,0x8002
c0000310:	58012103          	lw	sp,1408(sp) # c800288c <pxCurrentTCB>
	load_x  sp, 0( sp )				 	/* Read sp from first TCB member. */
c0000314:	00012103          	lw	sp,0(sp)

	load_x  x1, 0( sp ) /* Note for starting the scheduler the exception return address is used as the function return address. */
c0000318:	00012083          	lw	ra,0(sp)

	portasmRESTORE_ADDITIONAL_REGISTERS	/* Defined in freertos_risc_v_chip_specific_extensions.h to restore any registers unique to the RISC-V implementation. */

	load_x  t0, 29 * portWORD_SIZE( sp )	/* mstatus */
c000031c:	07412283          	lw	t0,116(sp)
	addi t0, t0, 0x08						/* Set MIE bit so the first task starts with interrupts enabled - required as returns with ret not eret. */
c0000320:	00828293          	addi	t0,t0,8
	csrrw  x0, mstatus, t0					/* Interrupts enabled from here! */
c0000324:	30029073          	csrw	mstatus,t0

	load_x  x5, 2 * portWORD_SIZE( sp )		/* t0 */
c0000328:	00812283          	lw	t0,8(sp)
	load_x  x6, 3 * portWORD_SIZE( sp )		/* t1 */
c000032c:	00c12303          	lw	t1,12(sp)
	load_x  x7, 4 * portWORD_SIZE( sp )		/* t2 */
c0000330:	01012383          	lw	t2,16(sp)
	load_x  x8, 5 * portWORD_SIZE( sp )		/* s0/fp */
c0000334:	01412403          	lw	s0,20(sp)
	load_x  x9, 6 * portWORD_SIZE( sp )		/* s1 */
c0000338:	01812483          	lw	s1,24(sp)
	load_x  x10, 7 * portWORD_SIZE( sp )	/* a0 */
c000033c:	01c12503          	lw	a0,28(sp)
	load_x  x11, 8 * portWORD_SIZE( sp )	/* a1 */
c0000340:	02012583          	lw	a1,32(sp)
	load_x  x12, 9 * portWORD_SIZE( sp )	/* a2 */
c0000344:	02412603          	lw	a2,36(sp)
	load_x  x13, 10 * portWORD_SIZE( sp )	/* a3 */
c0000348:	02812683          	lw	a3,40(sp)
	load_x  x14, 11 * portWORD_SIZE( sp )	/* a4 */
c000034c:	02c12703          	lw	a4,44(sp)
	load_x  x15, 12 * portWORD_SIZE( sp )	/* a5 */
c0000350:	03012783          	lw	a5,48(sp)
	load_x  x16, 13 * portWORD_SIZE( sp )	/* a6 */
c0000354:	03412803          	lw	a6,52(sp)
	load_x  x17, 14 * portWORD_SIZE( sp )	/* a7 */
c0000358:	03812883          	lw	a7,56(sp)
	load_x  x18, 15 * portWORD_SIZE( sp )	/* s2 */
c000035c:	03c12903          	lw	s2,60(sp)
	load_x  x19, 16 * portWORD_SIZE( sp )	/* s3 */
c0000360:	04012983          	lw	s3,64(sp)
	load_x  x20, 17 * portWORD_SIZE( sp )	/* s4 */
c0000364:	04412a03          	lw	s4,68(sp)
	load_x  x21, 18 * portWORD_SIZE( sp )	/* s5 */
c0000368:	04812a83          	lw	s5,72(sp)
	load_x  x22, 19 * portWORD_SIZE( sp )	/* s6 */
c000036c:	04c12b03          	lw	s6,76(sp)
	load_x  x23, 20 * portWORD_SIZE( sp )	/* s7 */
c0000370:	05012b83          	lw	s7,80(sp)
	load_x  x24, 21 * portWORD_SIZE( sp )	/* s8 */
c0000374:	05412c03          	lw	s8,84(sp)
	load_x  x25, 22 * portWORD_SIZE( sp )	/* s9 */
c0000378:	05812c83          	lw	s9,88(sp)
	load_x  x26, 23 * portWORD_SIZE( sp )	/* s10 */
c000037c:	05c12d03          	lw	s10,92(sp)
	load_x  x27, 24 * portWORD_SIZE( sp )	/* s11 */
c0000380:	06012d83          	lw	s11,96(sp)
	load_x  x28, 25 * portWORD_SIZE( sp )	/* t3 */
c0000384:	06412e03          	lw	t3,100(sp)
	load_x  x29, 26 * portWORD_SIZE( sp )	/* t4 */
c0000388:	06812e83          	lw	t4,104(sp)
	load_x  x30, 27 * portWORD_SIZE( sp )	/* t5 */
c000038c:	06c12f03          	lw	t5,108(sp)
	load_x  x31, 28 * portWORD_SIZE( sp )	/* t6 */
c0000390:	07012f83          	lw	t6,112(sp)
	addi	sp, sp, portCONTEXT_SIZE
c0000394:	07810113          	addi	sp,sp,120
	ret
c0000398:	00008067          	ret
c000039c:	00000013          	nop
c00003a0:	00000013          	nop
c00003a4:	00000013          	nop
c00003a8:	00000013          	nop
c00003ac:	00000013          	nop
c00003b0:	00000013          	nop
c00003b4:	00000013          	nop
c00003b8:	00000013          	nop
c00003bc:	00000013          	nop
c00003c0:	00000013          	nop
c00003c4:	00000013          	nop
c00003c8:	00000013          	nop
c00003cc:	00000013          	nop
c00003d0:	00000013          	nop
c00003d4:	00000013          	nop
c00003d8:	00000013          	nop
c00003dc:	00000013          	nop
c00003e0:	00000013          	nop
c00003e4:	00000013          	nop
c00003e8:	00000013          	nop
c00003ec:	00000013          	nop
c00003f0:	00000013          	nop
c00003f4:	00000013          	nop
c00003f8:	00000013          	nop
c00003fc:	00000013          	nop

c0000400 <pxPortInitialiseStack>:
 */
.align 8

pxPortInitialiseStack:

	csrr t0, mstatus					/* Obtain current mstatus value. */
c0000400:	300022f3          	csrr	t0,mstatus
	addi t1, x0, 0x188					/* Generate the value 0x1880, which are the MPIE and MPP bits to set in mstatus. */
c0000404:	18800313          	li	t1,392
	slli t1, t1, 4
c0000408:	00431313          	slli	t1,t1,0x4
	or t0, t0, t1						/* Set MPIE and MPP bits in mstatus value. */
c000040c:	0062e2b3          	or	t0,t0,t1

	addi a0, a0, -portWORD_SIZE
c0000410:	ffc50513          	addi	a0,a0,-4
	store_x t0, 0(a0)					/* mstatus onto the stack. */
c0000414:	00552023          	sw	t0,0(a0)
	addi a0, a0, -(22 * portWORD_SIZE)	/* Space for registers x11-x31. */
c0000418:	fa850513          	addi	a0,a0,-88
	store_x a2, 0(a0)					/* Task parameters (pvParameters parameter) goes into register X10/a0 on the stack. */
c000041c:	00c52023          	sw	a2,0(a0)
	addi a0, a0, -(6 * portWORD_SIZE)	/* Space for registers x5-x9. */
c0000420:	fe850513          	addi	a0,a0,-24
	store_x x0, 0(a0)					/* Return address onto the stack, could be portTASK_RETURN_ADDRESS */
c0000424:	00052023          	sw	zero,0(a0)
	addi t0, x0, portasmADDITIONAL_CONTEXT_SIZE /* The number of chip specific additional registers. */
c0000428:	00000293          	li	t0,0

c000042c <chip_specific_stack_frame>:
chip_specific_stack_frame:				/* First add any chip specific registers to the stack frame being created. */
	beq t0, x0, 1f						/* No more chip specific registers to save. */
c000042c:	00028a63          	beqz	t0,c0000440 <chip_specific_stack_frame+0x14>
	addi a0, a0, -portWORD_SIZE			/* Make space for chip specific register. */
c0000430:	ffc50513          	addi	a0,a0,-4
	store_x x0, 0(a0)					/* Give the chip specific register an initial value of zero. */
c0000434:	00052023          	sw	zero,0(a0)
	addi t0, t0, -1						/* Decrement the count of chip specific registers remaining. */
c0000438:	fff28293          	addi	t0,t0,-1
	j chip_specific_stack_frame			/* Until no more chip specific registers. */
c000043c:	ff1ff06f          	j	c000042c <chip_specific_stack_frame>
1:
	addi a0, a0, -portWORD_SIZE
c0000440:	ffc50513          	addi	a0,a0,-4
	store_x a1, 0(a0)					/* mret value (pxCode parameter) onto the stack. */
c0000444:	00b52023          	sw	a1,0(a0)
	ret
c0000448:	00008067          	ret
	...

c0000484 <vPortSetupTimerInterrupt>:
/*-----------------------------------------------------------*/

#if( configMTIME_BASE_ADDRESS != 0 ) && ( configMTIMECMP_BASE_ADDRESS != 0 )

	void vPortSetupTimerInterrupt( void )
	{
c0000484:	fd010113          	addi	sp,sp,-48
c0000488:	02812623          	sw	s0,44(sp)
c000048c:	03010413          	addi	s0,sp,48
	uint32_t ulCurrentTimeHigh, ulCurrentTimeLow;
	volatile uint32_t * const pulTimeHigh = ( volatile uint32_t * const ) ( ( configMTIME_BASE_ADDRESS ) + 4UL ); /* 8-byte typer so high 32-bit word is 4 bytes up. */
c0000490:	1000cf37          	lui	t5,0x1000c
c0000494:	ffcf0f13          	addi	t5,t5,-4 # 1000bffc <_DMEM_LENGTH+0xf80bffc>
c0000498:	ffe42623          	sw	t5,-20(s0)
	volatile uint32_t * const pulTimeLow = ( volatile uint32_t * const ) ( configMTIME_BASE_ADDRESS );
c000049c:	1000cf37          	lui	t5,0x1000c
c00004a0:	ff8f0f13          	addi	t5,t5,-8 # 1000bff8 <_DMEM_LENGTH+0xf80bff8>
c00004a4:	ffe42423          	sw	t5,-24(s0)
	volatile uint32_t ulHartId;

		__asm volatile( "csrr %0, mhartid" : "=r"( ulHartId ) );
c00004a8:	f1402f73          	csrr	t5,mhartid
c00004ac:	fde42e23          	sw	t5,-36(s0)
		pullMachineTimerCompareRegister  = ( volatile uint64_t * ) ( ullMachineTimerCompareRegisterBase + ( ulHartId * sizeof( uint64_t ) ) );
c00004b0:	fdc42f03          	lw	t5,-36(s0)
c00004b4:	003f1f93          	slli	t6,t5,0x3
c00004b8:	10004f37          	lui	t5,0x10004
c00004bc:	01ef8f33          	add	t5,t6,t5
c00004c0:	000f0f93          	mv	t6,t5
c00004c4:	08002f17          	auipc	t5,0x8002
c00004c8:	3c4f0f13          	addi	t5,t5,964 # c8002888 <pullMachineTimerCompareRegister>
c00004cc:	01ff2023          	sw	t6,0(t5)

		do
		{
			ulCurrentTimeHigh = *pulTimeHigh;
c00004d0:	fec42f03          	lw	t5,-20(s0)
c00004d4:	000f2f03          	lw	t5,0(t5)
c00004d8:	ffe42223          	sw	t5,-28(s0)
			ulCurrentTimeLow = *pulTimeLow;
c00004dc:	fe842f03          	lw	t5,-24(s0)
c00004e0:	000f2f03          	lw	t5,0(t5)
c00004e4:	ffe42023          	sw	t5,-32(s0)
		} while( ulCurrentTimeHigh != *pulTimeHigh );
c00004e8:	fec42f03          	lw	t5,-20(s0)
c00004ec:	000f2f03          	lw	t5,0(t5)
c00004f0:	fe442f83          	lw	t6,-28(s0)
c00004f4:	fdef9ee3          	bne	t6,t5,c00004d0 <vPortSetupTimerInterrupt+0x4c>

		ullNextTime = ( uint64_t ) ulCurrentTimeHigh;
c00004f8:	fe442f03          	lw	t5,-28(s0)
c00004fc:	000f0e13          	mv	t3,t5
c0000500:	00000e93          	li	t4,0
c0000504:	08002f17          	auipc	t5,0x8002
c0000508:	37cf0f13          	addi	t5,t5,892 # c8002880 <ullNextTime>
c000050c:	01cf2023          	sw	t3,0(t5)
c0000510:	01df2223          	sw	t4,4(t5)
		ullNextTime <<= 32ULL; /* High 4-byte word is 32-bits up. */
c0000514:	08002e17          	auipc	t3,0x8002
c0000518:	36ce0e13          	addi	t3,t3,876 # c8002880 <ullNextTime>
c000051c:	004e2e83          	lw	t4,4(t3)
c0000520:	000e2e03          	lw	t3,0(t3)
c0000524:	000e1393          	slli	t2,t3,0x0
c0000528:	00000313          	li	t1,0
c000052c:	08002e17          	auipc	t3,0x8002
c0000530:	354e0e13          	addi	t3,t3,852 # c8002880 <ullNextTime>
c0000534:	006e2023          	sw	t1,0(t3)
c0000538:	007e2223          	sw	t2,4(t3)
		ullNextTime |= ( uint64_t ) ulCurrentTimeLow;
c000053c:	fe042303          	lw	t1,-32(s0)
c0000540:	00030713          	mv	a4,t1
c0000544:	00000793          	li	a5,0
c0000548:	08002317          	auipc	t1,0x8002
c000054c:	33830313          	addi	t1,t1,824 # c8002880 <ullNextTime>
c0000550:	00432383          	lw	t2,4(t1)
c0000554:	00032303          	lw	t1,0(t1)
c0000558:	00676833          	or	a6,a4,t1
c000055c:	0077e8b3          	or	a7,a5,t2
c0000560:	08002797          	auipc	a5,0x8002
c0000564:	32078793          	addi	a5,a5,800 # c8002880 <ullNextTime>
c0000568:	0107a023          	sw	a6,0(a5)
c000056c:	0117a223          	sw	a7,4(a5)
		ullNextTime += ( uint64_t ) uxTimerIncrementsForOneTick;
c0000570:	0000c7b7          	lui	a5,0xc
c0000574:	35078793          	addi	a5,a5,848 # c350 <_STACK_SIZE+0xb350>
c0000578:	00078513          	mv	a0,a5
c000057c:	00000593          	li	a1,0
c0000580:	08002797          	auipc	a5,0x8002
c0000584:	30078793          	addi	a5,a5,768 # c8002880 <ullNextTime>
c0000588:	0007a803          	lw	a6,0(a5)
c000058c:	0047a883          	lw	a7,4(a5)
c0000590:	01050733          	add	a4,a0,a6
c0000594:	00070313          	mv	t1,a4
c0000598:	00a33333          	sltu	t1,t1,a0
c000059c:	011587b3          	add	a5,a1,a7
c00005a0:	00f305b3          	add	a1,t1,a5
c00005a4:	00058793          	mv	a5,a1
c00005a8:	08002597          	auipc	a1,0x8002
c00005ac:	2d858593          	addi	a1,a1,728 # c8002880 <ullNextTime>
c00005b0:	00e5a023          	sw	a4,0(a1)
c00005b4:	00f5a223          	sw	a5,4(a1)
		*pullMachineTimerCompareRegister = ullNextTime;
c00005b8:	08002797          	auipc	a5,0x8002
c00005bc:	2d078793          	addi	a5,a5,720 # c8002888 <pullMachineTimerCompareRegister>
c00005c0:	0007a583          	lw	a1,0(a5)
c00005c4:	08002797          	auipc	a5,0x8002
c00005c8:	2bc78793          	addi	a5,a5,700 # c8002880 <ullNextTime>
c00005cc:	0007a703          	lw	a4,0(a5)
c00005d0:	0047a783          	lw	a5,4(a5)
c00005d4:	00e5a023          	sw	a4,0(a1)
c00005d8:	00f5a223          	sw	a5,4(a1)

		/* Prepare the time to use after the next tick interrupt. */
		ullNextTime += ( uint64_t ) uxTimerIncrementsForOneTick;
c00005dc:	0000c7b7          	lui	a5,0xc
c00005e0:	35078793          	addi	a5,a5,848 # c350 <_STACK_SIZE+0xb350>
c00005e4:	00078613          	mv	a2,a5
c00005e8:	00000693          	li	a3,0
c00005ec:	08002797          	auipc	a5,0x8002
c00005f0:	29478793          	addi	a5,a5,660 # c8002880 <ullNextTime>
c00005f4:	0007a503          	lw	a0,0(a5)
c00005f8:	0047a583          	lw	a1,4(a5)
c00005fc:	00a60733          	add	a4,a2,a0
c0000600:	00070813          	mv	a6,a4
c0000604:	00c83833          	sltu	a6,a6,a2
c0000608:	00b687b3          	add	a5,a3,a1
c000060c:	00f806b3          	add	a3,a6,a5
c0000610:	00068793          	mv	a5,a3
c0000614:	08002697          	auipc	a3,0x8002
c0000618:	26c68693          	addi	a3,a3,620 # c8002880 <ullNextTime>
c000061c:	00e6a023          	sw	a4,0(a3)
c0000620:	00f6a223          	sw	a5,4(a3)
	}
c0000624:	00000013          	nop
c0000628:	02c12403          	lw	s0,44(sp)
c000062c:	03010113          	addi	sp,sp,48
c0000630:	00008067          	ret

c0000634 <xPortStartScheduler>:

#endif /* ( configMTIME_BASE_ADDRESS != 0 ) && ( configMTIME_BASE_ADDRESS != 0 ) */
/*-----------------------------------------------------------*/

BaseType_t xPortStartScheduler( void )
{
c0000634:	fe010113          	addi	sp,sp,-32
c0000638:	00112e23          	sw	ra,28(sp)
c000063c:	00812c23          	sw	s0,24(sp)
c0000640:	02010413          	addi	s0,sp,32
extern void xPortStartFirstTask( void );

	#if( configASSERT_DEFINED == 1 )
	{
		volatile uint32_t mtvec = 0;
c0000644:	fe042623          	sw	zero,-20(s0)

		/* Check the least significant two bits of mtvec are 00 - indicating
		single vector mode. */
		__asm volatile( "csrr %0, mtvec" : "=r"( mtvec ) );
c0000648:	305027f3          	csrr	a5,mtvec
c000064c:	fef42623          	sw	a5,-20(s0)
		configASSERT( ( mtvec & 0x03UL ) == 0 );
c0000650:	fec42783          	lw	a5,-20(s0)
c0000654:	0037f793          	andi	a5,a5,3
c0000658:	00078863          	beqz	a5,c0000668 <xPortStartScheduler+0x34>
c000065c:	30047073          	csrci	mstatus,8
c0000660:	00100073          	ebreak
c0000664:	0000006f          	j	c0000664 <xPortStartScheduler+0x30>

		/* Check alignment of the interrupt stack - which is the same as the
		stack that was being used by main() prior to the scheduler being
		started. */
		configASSERT( ( xISRStackTop & portBYTE_ALIGNMENT_MASK ) == 0 );
c0000668:	08002797          	auipc	a5,0x8002
c000066c:	2e078793          	addi	a5,a5,736 # c8002948 <xISRStackTop>
c0000670:	0007a783          	lw	a5,0(a5)
c0000674:	00f7f793          	andi	a5,a5,15
c0000678:	00078863          	beqz	a5,c0000688 <xPortStartScheduler+0x54>
c000067c:	30047073          	csrci	mstatus,8
c0000680:	00100073          	ebreak
c0000684:	0000006f          	j	c0000684 <xPortStartScheduler+0x50>
	#endif /* configASSERT_DEFINED */

	/* If there is a CLINT then it is ok to use the default implementation
	in this file, otherwise vPortSetupTimerInterrupt() must be implemented to
	configure whichever clock is to be used to generate the tick interrupt. */
	vPortSetupTimerInterrupt();
c0000688:	dfdff0ef          	jal	ra,c0000484 <vPortSetupTimerInterrupt>
	#if( ( configMTIME_BASE_ADDRESS != 0 ) && ( configMTIMECMP_BASE_ADDRESS != 0 ) )
	{
		/* Enable mtime and external interrupts.  1<<7 for timer interrupt, 1<<11
		for external interrupt.  _RB_ What happens here when mtime is not present as
		with pulpino? */
		__asm volatile( "csrs mie, %0" :: "r"(0x880) );
c000068c:	000017b7          	lui	a5,0x1
c0000690:	88078793          	addi	a5,a5,-1920 # 880 <_STACK_SIZE-0x780>
c0000694:	3047a073          	csrs	mie,a5
		/* Enable external interrupts. */
		__asm volatile( "csrs mie, %0" :: "r"(0x800) );
	}
	#endif /* ( configMTIME_BASE_ADDRESS != 0 ) && ( configMTIMECMP_BASE_ADDRESS != 0 ) */

	xPortStartFirstTask();
c0000698:	c69ff0ef          	jal	ra,c0000300 <xPortStartFirstTask>

	/* Should not get here as after calling xPortStartFirstTask() only tasks
	should be executing. */
	return pdFAIL;
c000069c:	00000793          	li	a5,0
}
c00006a0:	00078513          	mv	a0,a5
c00006a4:	01c12083          	lw	ra,28(sp)
c00006a8:	01812403          	lw	s0,24(sp)
c00006ac:	02010113          	addi	sp,sp,32
c00006b0:	00008067          	ret

c00006b4 <vPortEndScheduler>:
/*-----------------------------------------------------------*/

void vPortEndScheduler( void )
{
c00006b4:	ff010113          	addi	sp,sp,-16
c00006b8:	00812623          	sw	s0,12(sp)
c00006bc:	01010413          	addi	s0,sp,16
	/* Not implemented. */
	for( ;; );
c00006c0:	0000006f          	j	c00006c0 <vPortEndScheduler+0xc>

c00006c4 <vListInitialise>:
/*-----------------------------------------------------------
 * PUBLIC LIST API documented in list.h
 *----------------------------------------------------------*/

void vListInitialise( List_t * const pxList )
{
c00006c4:	fe010113          	addi	sp,sp,-32
c00006c8:	00812e23          	sw	s0,28(sp)
c00006cc:	02010413          	addi	s0,sp,32
c00006d0:	fea42623          	sw	a0,-20(s0)
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = ( ListItem_t * ) &( pxList->xListEnd );			/*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
c00006d4:	fec42783          	lw	a5,-20(s0)
c00006d8:	00878713          	addi	a4,a5,8
c00006dc:	fec42783          	lw	a5,-20(s0)
c00006e0:	00e7a223          	sw	a4,4(a5)

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
c00006e4:	fec42783          	lw	a5,-20(s0)
c00006e8:	fff00713          	li	a4,-1
c00006ec:	00e7a423          	sw	a4,8(a5)

	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = ( ListItem_t * ) &( pxList->xListEnd );	/*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
c00006f0:	fec42783          	lw	a5,-20(s0)
c00006f4:	00878713          	addi	a4,a5,8
c00006f8:	fec42783          	lw	a5,-20(s0)
c00006fc:	00e7a623          	sw	a4,12(a5)
	pxList->xListEnd.pxPrevious = ( ListItem_t * ) &( pxList->xListEnd );/*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
c0000700:	fec42783          	lw	a5,-20(s0)
c0000704:	00878713          	addi	a4,a5,8
c0000708:	fec42783          	lw	a5,-20(s0)
c000070c:	00e7a823          	sw	a4,16(a5)

	pxList->uxNumberOfItems = ( UBaseType_t ) 0U;
c0000710:	fec42783          	lw	a5,-20(s0)
c0000714:	0007a023          	sw	zero,0(a5)

	/* Write known values into the list if
	configUSE_LIST_DATA_INTEGRITY_CHECK_BYTES is set to 1. */
	listSET_LIST_INTEGRITY_CHECK_1_VALUE( pxList );
	listSET_LIST_INTEGRITY_CHECK_2_VALUE( pxList );
}
c0000718:	00000013          	nop
c000071c:	01c12403          	lw	s0,28(sp)
c0000720:	02010113          	addi	sp,sp,32
c0000724:	00008067          	ret

c0000728 <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( ListItem_t * const pxItem )
{
c0000728:	fe010113          	addi	sp,sp,-32
c000072c:	00812e23          	sw	s0,28(sp)
c0000730:	02010413          	addi	s0,sp,32
c0000734:	fea42623          	sw	a0,-20(s0)
	/* Make sure the list item is not recorded as being on a list. */
	pxItem->pxContainer = NULL;
c0000738:	fec42783          	lw	a5,-20(s0)
c000073c:	0007a823          	sw	zero,16(a5)

	/* Write known values into the list item if
	configUSE_LIST_DATA_INTEGRITY_CHECK_BYTES is set to 1. */
	listSET_FIRST_LIST_ITEM_INTEGRITY_CHECK_VALUE( pxItem );
	listSET_SECOND_LIST_ITEM_INTEGRITY_CHECK_VALUE( pxItem );
}
c0000740:	00000013          	nop
c0000744:	01c12403          	lw	s0,28(sp)
c0000748:	02010113          	addi	sp,sp,32
c000074c:	00008067          	ret

c0000750 <vListInsertEnd>:
/*-----------------------------------------------------------*/

void vListInsertEnd( List_t * const pxList, ListItem_t * const pxNewListItem )
{
c0000750:	fd010113          	addi	sp,sp,-48
c0000754:	02812623          	sw	s0,44(sp)
c0000758:	03010413          	addi	s0,sp,48
c000075c:	fca42e23          	sw	a0,-36(s0)
c0000760:	fcb42c23          	sw	a1,-40(s0)
ListItem_t * const pxIndex = pxList->pxIndex;
c0000764:	fdc42783          	lw	a5,-36(s0)
c0000768:	0047a783          	lw	a5,4(a5)
c000076c:	fef42623          	sw	a5,-20(s0)
	listTEST_LIST_ITEM_INTEGRITY( pxNewListItem );

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	listGET_OWNER_OF_NEXT_ENTRY(). */
	pxNewListItem->pxNext = pxIndex;
c0000770:	fd842783          	lw	a5,-40(s0)
c0000774:	fec42703          	lw	a4,-20(s0)
c0000778:	00e7a223          	sw	a4,4(a5)
	pxNewListItem->pxPrevious = pxIndex->pxPrevious;
c000077c:	fec42783          	lw	a5,-20(s0)
c0000780:	0087a703          	lw	a4,8(a5)
c0000784:	fd842783          	lw	a5,-40(s0)
c0000788:	00e7a423          	sw	a4,8(a5)

	/* Only used during decision coverage testing. */
	mtCOVERAGE_TEST_DELAY();

	pxIndex->pxPrevious->pxNext = pxNewListItem;
c000078c:	fec42783          	lw	a5,-20(s0)
c0000790:	0087a783          	lw	a5,8(a5)
c0000794:	fd842703          	lw	a4,-40(s0)
c0000798:	00e7a223          	sw	a4,4(a5)
	pxIndex->pxPrevious = pxNewListItem;
c000079c:	fec42783          	lw	a5,-20(s0)
c00007a0:	fd842703          	lw	a4,-40(s0)
c00007a4:	00e7a423          	sw	a4,8(a5)

	/* Remember which list the item is in. */
	pxNewListItem->pxContainer = pxList;
c00007a8:	fd842783          	lw	a5,-40(s0)
c00007ac:	fdc42703          	lw	a4,-36(s0)
c00007b0:	00e7a823          	sw	a4,16(a5)

	( pxList->uxNumberOfItems )++;
c00007b4:	fdc42783          	lw	a5,-36(s0)
c00007b8:	0007a783          	lw	a5,0(a5)
c00007bc:	00178713          	addi	a4,a5,1
c00007c0:	fdc42783          	lw	a5,-36(s0)
c00007c4:	00e7a023          	sw	a4,0(a5)
}
c00007c8:	00000013          	nop
c00007cc:	02c12403          	lw	s0,44(sp)
c00007d0:	03010113          	addi	sp,sp,48
c00007d4:	00008067          	ret

c00007d8 <vListInsert>:
/*-----------------------------------------------------------*/

void vListInsert( List_t * const pxList, ListItem_t * const pxNewListItem )
{
c00007d8:	fd010113          	addi	sp,sp,-48
c00007dc:	02812623          	sw	s0,44(sp)
c00007e0:	03010413          	addi	s0,sp,48
c00007e4:	fca42e23          	sw	a0,-36(s0)
c00007e8:	fcb42c23          	sw	a1,-40(s0)
ListItem_t *pxIterator;
const TickType_t xValueOfInsertion = pxNewListItem->xItemValue;
c00007ec:	fd842783          	lw	a5,-40(s0)
c00007f0:	0007a783          	lw	a5,0(a5)
c00007f4:	fef42423          	sw	a5,-24(s0)
	new list item should be placed after it.  This ensures that TCBs which are
	stored in ready lists (all of which have the same xItemValue value) get a
	share of the CPU.  However, if the xItemValue is the same as the back marker
	the iteration loop below will not end.  Therefore the value is checked
	first, and the algorithm slightly modified if necessary. */
	if( xValueOfInsertion == portMAX_DELAY )
c00007f8:	fe842703          	lw	a4,-24(s0)
c00007fc:	fff00793          	li	a5,-1
c0000800:	00f71a63          	bne	a4,a5,c0000814 <vListInsert+0x3c>
	{
		pxIterator = pxList->xListEnd.pxPrevious;
c0000804:	fdc42783          	lw	a5,-36(s0)
c0000808:	0107a783          	lw	a5,16(a5)
c000080c:	fef42623          	sw	a5,-20(s0)
c0000810:	0340006f          	j	c0000844 <vListInsert+0x6c>
			4) Using a queue or semaphore before it has been initialised or
			   before the scheduler has been started (are interrupts firing
			   before vTaskStartScheduler() has been called?).
		**********************************************************************/

		for( pxIterator = ( ListItem_t * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext ) /*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. *//*lint !e440 The iterator moves to a different value, not xValueOfInsertion. */
c0000814:	fdc42783          	lw	a5,-36(s0)
c0000818:	00878793          	addi	a5,a5,8
c000081c:	fef42623          	sw	a5,-20(s0)
c0000820:	0100006f          	j	c0000830 <vListInsert+0x58>
c0000824:	fec42783          	lw	a5,-20(s0)
c0000828:	0047a783          	lw	a5,4(a5)
c000082c:	fef42623          	sw	a5,-20(s0)
c0000830:	fec42783          	lw	a5,-20(s0)
c0000834:	0047a783          	lw	a5,4(a5)
c0000838:	0007a783          	lw	a5,0(a5)
c000083c:	fe842703          	lw	a4,-24(s0)
c0000840:	fef772e3          	bgeu	a4,a5,c0000824 <vListInsert+0x4c>
			/* There is nothing to do here, just iterating to the wanted
			insertion position. */
		}
	}

	pxNewListItem->pxNext = pxIterator->pxNext;
c0000844:	fec42783          	lw	a5,-20(s0)
c0000848:	0047a703          	lw	a4,4(a5)
c000084c:	fd842783          	lw	a5,-40(s0)
c0000850:	00e7a223          	sw	a4,4(a5)
	pxNewListItem->pxNext->pxPrevious = pxNewListItem;
c0000854:	fd842783          	lw	a5,-40(s0)
c0000858:	0047a783          	lw	a5,4(a5)
c000085c:	fd842703          	lw	a4,-40(s0)
c0000860:	00e7a423          	sw	a4,8(a5)
	pxNewListItem->pxPrevious = pxIterator;
c0000864:	fd842783          	lw	a5,-40(s0)
c0000868:	fec42703          	lw	a4,-20(s0)
c000086c:	00e7a423          	sw	a4,8(a5)
	pxIterator->pxNext = pxNewListItem;
c0000870:	fec42783          	lw	a5,-20(s0)
c0000874:	fd842703          	lw	a4,-40(s0)
c0000878:	00e7a223          	sw	a4,4(a5)

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pxContainer = pxList;
c000087c:	fd842783          	lw	a5,-40(s0)
c0000880:	fdc42703          	lw	a4,-36(s0)
c0000884:	00e7a823          	sw	a4,16(a5)

	( pxList->uxNumberOfItems )++;
c0000888:	fdc42783          	lw	a5,-36(s0)
c000088c:	0007a783          	lw	a5,0(a5)
c0000890:	00178713          	addi	a4,a5,1
c0000894:	fdc42783          	lw	a5,-36(s0)
c0000898:	00e7a023          	sw	a4,0(a5)
}
c000089c:	00000013          	nop
c00008a0:	02c12403          	lw	s0,44(sp)
c00008a4:	03010113          	addi	sp,sp,48
c00008a8:	00008067          	ret

c00008ac <uxListRemove>:
/*-----------------------------------------------------------*/

UBaseType_t uxListRemove( ListItem_t * const pxItemToRemove )
{
c00008ac:	fd010113          	addi	sp,sp,-48
c00008b0:	02812623          	sw	s0,44(sp)
c00008b4:	03010413          	addi	s0,sp,48
c00008b8:	fca42e23          	sw	a0,-36(s0)
/* The list item knows which list it is in.  Obtain the list from the list
item. */
List_t * const pxList = pxItemToRemove->pxContainer;
c00008bc:	fdc42783          	lw	a5,-36(s0)
c00008c0:	0107a783          	lw	a5,16(a5)
c00008c4:	fef42623          	sw	a5,-20(s0)

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
c00008c8:	fdc42783          	lw	a5,-36(s0)
c00008cc:	0047a783          	lw	a5,4(a5)
c00008d0:	fdc42703          	lw	a4,-36(s0)
c00008d4:	00872703          	lw	a4,8(a4)
c00008d8:	00e7a423          	sw	a4,8(a5)
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
c00008dc:	fdc42783          	lw	a5,-36(s0)
c00008e0:	0087a783          	lw	a5,8(a5)
c00008e4:	fdc42703          	lw	a4,-36(s0)
c00008e8:	00472703          	lw	a4,4(a4)
c00008ec:	00e7a223          	sw	a4,4(a5)

	/* Only used during decision coverage testing. */
	mtCOVERAGE_TEST_DELAY();

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
c00008f0:	fec42783          	lw	a5,-20(s0)
c00008f4:	0047a783          	lw	a5,4(a5)
c00008f8:	fdc42703          	lw	a4,-36(s0)
c00008fc:	00f71a63          	bne	a4,a5,c0000910 <uxListRemove+0x64>
	{
		pxList->pxIndex = pxItemToRemove->pxPrevious;
c0000900:	fdc42783          	lw	a5,-36(s0)
c0000904:	0087a703          	lw	a4,8(a5)
c0000908:	fec42783          	lw	a5,-20(s0)
c000090c:	00e7a223          	sw	a4,4(a5)
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	pxItemToRemove->pxContainer = NULL;
c0000910:	fdc42783          	lw	a5,-36(s0)
c0000914:	0007a823          	sw	zero,16(a5)
	( pxList->uxNumberOfItems )--;
c0000918:	fec42783          	lw	a5,-20(s0)
c000091c:	0007a783          	lw	a5,0(a5)
c0000920:	fff78713          	addi	a4,a5,-1
c0000924:	fec42783          	lw	a5,-20(s0)
c0000928:	00e7a023          	sw	a4,0(a5)

	return pxList->uxNumberOfItems;
c000092c:	fec42783          	lw	a5,-20(s0)
c0000930:	0007a783          	lw	a5,0(a5)
}
c0000934:	00078513          	mv	a0,a5
c0000938:	02c12403          	lw	s0,44(sp)
c000093c:	03010113          	addi	sp,sp,48
c0000940:	00008067          	ret

c0000944 <xQueueGenericReset>:
	}														\
	taskEXIT_CRITICAL()
/*-----------------------------------------------------------*/

BaseType_t xQueueGenericReset( QueueHandle_t xQueue, BaseType_t xNewQueue )
{
c0000944:	fd010113          	addi	sp,sp,-48
c0000948:	02112623          	sw	ra,44(sp)
c000094c:	02812423          	sw	s0,40(sp)
c0000950:	03010413          	addi	s0,sp,48
c0000954:	fca42e23          	sw	a0,-36(s0)
c0000958:	fcb42c23          	sw	a1,-40(s0)
Queue_t * const pxQueue = xQueue;
c000095c:	fdc42783          	lw	a5,-36(s0)
c0000960:	fef42623          	sw	a5,-20(s0)

	configASSERT( pxQueue );
c0000964:	fec42783          	lw	a5,-20(s0)
c0000968:	00079863          	bnez	a5,c0000978 <xQueueGenericReset+0x34>
c000096c:	30047073          	csrci	mstatus,8
c0000970:	00100073          	ebreak
c0000974:	0000006f          	j	c0000974 <xQueueGenericReset+0x30>

	taskENTER_CRITICAL();
c0000978:	7c9040ef          	jal	ra,c0005940 <vTaskEnterCritical>
	{
		pxQueue->u.xQueue.pcTail = pxQueue->pcHead + ( pxQueue->uxLength * pxQueue->uxItemSize ); /*lint !e9016 Pointer arithmetic allowed on char types, especially when it assists conveying intent. */
c000097c:	fec42783          	lw	a5,-20(s0)
c0000980:	0007a703          	lw	a4,0(a5)
c0000984:	fec42783          	lw	a5,-20(s0)
c0000988:	03c7a683          	lw	a3,60(a5)
c000098c:	fec42783          	lw	a5,-20(s0)
c0000990:	0407a783          	lw	a5,64(a5)
c0000994:	02f687b3          	mul	a5,a3,a5
c0000998:	00f70733          	add	a4,a4,a5
c000099c:	fec42783          	lw	a5,-20(s0)
c00009a0:	00e7a423          	sw	a4,8(a5)
		pxQueue->uxMessagesWaiting = ( UBaseType_t ) 0U;
c00009a4:	fec42783          	lw	a5,-20(s0)
c00009a8:	0207ac23          	sw	zero,56(a5)
		pxQueue->pcWriteTo = pxQueue->pcHead;
c00009ac:	fec42783          	lw	a5,-20(s0)
c00009b0:	0007a703          	lw	a4,0(a5)
c00009b4:	fec42783          	lw	a5,-20(s0)
c00009b8:	00e7a223          	sw	a4,4(a5)
		pxQueue->u.xQueue.pcReadFrom = pxQueue->pcHead + ( ( pxQueue->uxLength - 1U ) * pxQueue->uxItemSize ); /*lint !e9016 Pointer arithmetic allowed on char types, especially when it assists conveying intent. */
c00009bc:	fec42783          	lw	a5,-20(s0)
c00009c0:	0007a703          	lw	a4,0(a5)
c00009c4:	fec42783          	lw	a5,-20(s0)
c00009c8:	03c7a783          	lw	a5,60(a5)
c00009cc:	fff78693          	addi	a3,a5,-1
c00009d0:	fec42783          	lw	a5,-20(s0)
c00009d4:	0407a783          	lw	a5,64(a5)
c00009d8:	02f687b3          	mul	a5,a3,a5
c00009dc:	00f70733          	add	a4,a4,a5
c00009e0:	fec42783          	lw	a5,-20(s0)
c00009e4:	00e7a623          	sw	a4,12(a5)
		pxQueue->cRxLock = queueUNLOCKED;
c00009e8:	fec42783          	lw	a5,-20(s0)
c00009ec:	fff00713          	li	a4,-1
c00009f0:	04e78223          	sb	a4,68(a5)
		pxQueue->cTxLock = queueUNLOCKED;
c00009f4:	fec42783          	lw	a5,-20(s0)
c00009f8:	fff00713          	li	a4,-1
c00009fc:	04e782a3          	sb	a4,69(a5)

		if( xNewQueue == pdFALSE )
c0000a00:	fd842783          	lw	a5,-40(s0)
c0000a04:	02079863          	bnez	a5,c0000a34 <xQueueGenericReset+0xf0>
			/* If there are tasks blocked waiting to read from the queue, then
			the tasks will remain blocked as after this function exits the queue
			will still be empty.  If there are tasks blocked waiting to write to
			the queue, then one should be unblocked as after this function exits
			it will be possible to write to it. */
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
c0000a08:	fec42783          	lw	a5,-20(s0)
c0000a0c:	0107a783          	lw	a5,16(a5)
c0000a10:	04078263          	beqz	a5,c0000a54 <xQueueGenericReset+0x110>
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
c0000a14:	fec42783          	lw	a5,-20(s0)
c0000a18:	01078793          	addi	a5,a5,16
c0000a1c:	00078513          	mv	a0,a5
c0000a20:	68d030ef          	jal	ra,c00048ac <xTaskRemoveFromEventList>
c0000a24:	00050793          	mv	a5,a0
c0000a28:	02078663          	beqz	a5,c0000a54 <xQueueGenericReset+0x110>
				{
					queueYIELD_IF_USING_PREEMPTION();
c0000a2c:	00000073          	ecall
c0000a30:	0240006f          	j	c0000a54 <xQueueGenericReset+0x110>
			}
		}
		else
		{
			/* Ensure the event queues start in the correct state. */
			vListInitialise( &( pxQueue->xTasksWaitingToSend ) );
c0000a34:	fec42783          	lw	a5,-20(s0)
c0000a38:	01078793          	addi	a5,a5,16
c0000a3c:	00078513          	mv	a0,a5
c0000a40:	c85ff0ef          	jal	ra,c00006c4 <vListInitialise>
			vListInitialise( &( pxQueue->xTasksWaitingToReceive ) );
c0000a44:	fec42783          	lw	a5,-20(s0)
c0000a48:	02478793          	addi	a5,a5,36
c0000a4c:	00078513          	mv	a0,a5
c0000a50:	c75ff0ef          	jal	ra,c00006c4 <vListInitialise>
		}
	}
	taskEXIT_CRITICAL();
c0000a54:	741040ef          	jal	ra,c0005994 <vTaskExitCritical>

	/* A value is returned for calling semantic consistency with previous
	versions. */
	return pdPASS;
c0000a58:	00100793          	li	a5,1
}
c0000a5c:	00078513          	mv	a0,a5
c0000a60:	02c12083          	lw	ra,44(sp)
c0000a64:	02812403          	lw	s0,40(sp)
c0000a68:	03010113          	addi	sp,sp,48
c0000a6c:	00008067          	ret

c0000a70 <xQueueGenericCreate>:
/*-----------------------------------------------------------*/

#if( configSUPPORT_DYNAMIC_ALLOCATION == 1 )

	QueueHandle_t xQueueGenericCreate( const UBaseType_t uxQueueLength, const UBaseType_t uxItemSize, const uint8_t ucQueueType )
	{
c0000a70:	fd010113          	addi	sp,sp,-48
c0000a74:	02112623          	sw	ra,44(sp)
c0000a78:	02812423          	sw	s0,40(sp)
c0000a7c:	03010413          	addi	s0,sp,48
c0000a80:	fca42e23          	sw	a0,-36(s0)
c0000a84:	fcb42c23          	sw	a1,-40(s0)
c0000a88:	00060793          	mv	a5,a2
c0000a8c:	fcf40ba3          	sb	a5,-41(s0)
	Queue_t *pxNewQueue;
	size_t xQueueSizeInBytes;
	uint8_t *pucQueueStorage;

		configASSERT( uxQueueLength > ( UBaseType_t ) 0 );
c0000a90:	fdc42783          	lw	a5,-36(s0)
c0000a94:	00079863          	bnez	a5,c0000aa4 <xQueueGenericCreate+0x34>
c0000a98:	30047073          	csrci	mstatus,8
c0000a9c:	00100073          	ebreak
c0000aa0:	0000006f          	j	c0000aa0 <xQueueGenericCreate+0x30>

		/* Allocate enough space to hold the maximum number of items that
		can be in the queue at any time.  It is valid for uxItemSize to be
		zero in the case the queue is used as a semaphore. */
		xQueueSizeInBytes = ( size_t ) ( uxQueueLength * uxItemSize ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
c0000aa4:	fdc42703          	lw	a4,-36(s0)
c0000aa8:	fd842783          	lw	a5,-40(s0)
c0000aac:	02f707b3          	mul	a5,a4,a5
c0000ab0:	fef42623          	sw	a5,-20(s0)
		alignment requirements of the Queue_t structure - which in this case
		is an int8_t *.  Therefore, whenever the stack alignment requirements
		are greater than or equal to the pointer to char requirements the cast
		is safe.  In other cases alignment requirements are not strict (one or
		two bytes). */
		pxNewQueue = ( Queue_t * ) pvPortMalloc( sizeof( Queue_t ) + xQueueSizeInBytes ); /*lint !e9087 !e9079 see comment above. */
c0000ab4:	fec42783          	lw	a5,-20(s0)
c0000ab8:	05078793          	addi	a5,a5,80
c0000abc:	00078513          	mv	a0,a5
c0000ac0:	7f4080ef          	jal	ra,c00092b4 <pvPortMalloc>
c0000ac4:	fea42423          	sw	a0,-24(s0)

		if( pxNewQueue != NULL )
c0000ac8:	fe842783          	lw	a5,-24(s0)
c0000acc:	02078a63          	beqz	a5,c0000b00 <xQueueGenericCreate+0x90>
		{
			/* Jump past the queue structure to find the location of the queue
			storage area. */
			pucQueueStorage = ( uint8_t * ) pxNewQueue;
c0000ad0:	fe842783          	lw	a5,-24(s0)
c0000ad4:	fef42223          	sw	a5,-28(s0)
			pucQueueStorage += sizeof( Queue_t ); /*lint !e9016 Pointer arithmetic allowed on char types, especially when it assists conveying intent. */
c0000ad8:	fe442783          	lw	a5,-28(s0)
c0000adc:	05078793          	addi	a5,a5,80
c0000ae0:	fef42223          	sw	a5,-28(s0)
				deleted. */
				pxNewQueue->ucStaticallyAllocated = pdFALSE;
			}
			#endif /* configSUPPORT_STATIC_ALLOCATION */

			prvInitialiseNewQueue( uxQueueLength, uxItemSize, pucQueueStorage, ucQueueType, pxNewQueue );
c0000ae4:	fd744783          	lbu	a5,-41(s0)
c0000ae8:	fe842703          	lw	a4,-24(s0)
c0000aec:	00078693          	mv	a3,a5
c0000af0:	fe442603          	lw	a2,-28(s0)
c0000af4:	fd842583          	lw	a1,-40(s0)
c0000af8:	fdc42503          	lw	a0,-36(s0)
c0000afc:	01c000ef          	jal	ra,c0000b18 <prvInitialiseNewQueue>
		{
			traceQUEUE_CREATE_FAILED( ucQueueType );
			mtCOVERAGE_TEST_MARKER();
		}

		return pxNewQueue;
c0000b00:	fe842783          	lw	a5,-24(s0)
	}
c0000b04:	00078513          	mv	a0,a5
c0000b08:	02c12083          	lw	ra,44(sp)
c0000b0c:	02812403          	lw	s0,40(sp)
c0000b10:	03010113          	addi	sp,sp,48
c0000b14:	00008067          	ret

c0000b18 <prvInitialiseNewQueue>:

#endif /* configSUPPORT_STATIC_ALLOCATION */
/*-----------------------------------------------------------*/

static void prvInitialiseNewQueue( const UBaseType_t uxQueueLength, const UBaseType_t uxItemSize, uint8_t *pucQueueStorage, const uint8_t ucQueueType, Queue_t *pxNewQueue )
{
c0000b18:	fd010113          	addi	sp,sp,-48
c0000b1c:	02112623          	sw	ra,44(sp)
c0000b20:	02812423          	sw	s0,40(sp)
c0000b24:	03010413          	addi	s0,sp,48
c0000b28:	fea42623          	sw	a0,-20(s0)
c0000b2c:	feb42423          	sw	a1,-24(s0)
c0000b30:	fec42223          	sw	a2,-28(s0)
c0000b34:	00068793          	mv	a5,a3
c0000b38:	fce42e23          	sw	a4,-36(s0)
c0000b3c:	fef401a3          	sb	a5,-29(s0)
	/* Remove compiler warnings about unused parameters should
	configUSE_TRACE_FACILITY not be set to 1. */
	( void ) ucQueueType;

	if( uxItemSize == ( UBaseType_t ) 0 )
c0000b40:	fe842783          	lw	a5,-24(s0)
c0000b44:	00079a63          	bnez	a5,c0000b58 <prvInitialiseNewQueue+0x40>
	{
		/* No RAM was allocated for the queue storage area, but PC head cannot
		be set to NULL because NULL is used as a key to say the queue is used as
		a mutex.  Therefore just set pcHead to point to the queue as a benign
		value that is known to be within the memory map. */
		pxNewQueue->pcHead = ( int8_t * ) pxNewQueue;
c0000b48:	fdc42783          	lw	a5,-36(s0)
c0000b4c:	fdc42703          	lw	a4,-36(s0)
c0000b50:	00e7a023          	sw	a4,0(a5)
c0000b54:	0100006f          	j	c0000b64 <prvInitialiseNewQueue+0x4c>
	}
	else
	{
		/* Set the head to the start of the queue storage area. */
		pxNewQueue->pcHead = ( int8_t * ) pucQueueStorage;
c0000b58:	fdc42783          	lw	a5,-36(s0)
c0000b5c:	fe442703          	lw	a4,-28(s0)
c0000b60:	00e7a023          	sw	a4,0(a5)
	}

	/* Initialise the queue members as described where the queue type is
	defined. */
	pxNewQueue->uxLength = uxQueueLength;
c0000b64:	fdc42783          	lw	a5,-36(s0)
c0000b68:	fec42703          	lw	a4,-20(s0)
c0000b6c:	02e7ae23          	sw	a4,60(a5)
	pxNewQueue->uxItemSize = uxItemSize;
c0000b70:	fdc42783          	lw	a5,-36(s0)
c0000b74:	fe842703          	lw	a4,-24(s0)
c0000b78:	04e7a023          	sw	a4,64(a5)
	( void ) xQueueGenericReset( pxNewQueue, pdTRUE );
c0000b7c:	00100593          	li	a1,1
c0000b80:	fdc42503          	lw	a0,-36(s0)
c0000b84:	dc1ff0ef          	jal	ra,c0000944 <xQueueGenericReset>

	#if ( configUSE_TRACE_FACILITY == 1 )
	{
		pxNewQueue->ucQueueType = ucQueueType;
c0000b88:	fdc42783          	lw	a5,-36(s0)
c0000b8c:	fe344703          	lbu	a4,-29(s0)
c0000b90:	04e78623          	sb	a4,76(a5)
		pxNewQueue->pxQueueSetContainer = NULL;
	}
	#endif /* configUSE_QUEUE_SETS */

	traceQUEUE_CREATE( pxNewQueue );
}
c0000b94:	00000013          	nop
c0000b98:	02c12083          	lw	ra,44(sp)
c0000b9c:	02812403          	lw	s0,40(sp)
c0000ba0:	03010113          	addi	sp,sp,48
c0000ba4:	00008067          	ret

c0000ba8 <prvInitialiseMutex>:
/*-----------------------------------------------------------*/

#if( configUSE_MUTEXES == 1 )

	static void prvInitialiseMutex( Queue_t *pxNewQueue )
	{
c0000ba8:	fe010113          	addi	sp,sp,-32
c0000bac:	00112e23          	sw	ra,28(sp)
c0000bb0:	00812c23          	sw	s0,24(sp)
c0000bb4:	02010413          	addi	s0,sp,32
c0000bb8:	fea42623          	sw	a0,-20(s0)
		if( pxNewQueue != NULL )
c0000bbc:	fec42783          	lw	a5,-20(s0)
c0000bc0:	02078863          	beqz	a5,c0000bf0 <prvInitialiseMutex+0x48>
		{
			/* The queue create function will set all the queue structure members
			correctly for a generic queue, but this function is creating a
			mutex.  Overwrite those members that need to be set differently -
			in particular the information required for priority inheritance. */
			pxNewQueue->u.xSemaphore.xMutexHolder = NULL;
c0000bc4:	fec42783          	lw	a5,-20(s0)
c0000bc8:	0007a423          	sw	zero,8(a5)
			pxNewQueue->uxQueueType = queueQUEUE_IS_MUTEX;
c0000bcc:	fec42783          	lw	a5,-20(s0)
c0000bd0:	0007a023          	sw	zero,0(a5)

			/* In case this is a recursive mutex. */
			pxNewQueue->u.xSemaphore.uxRecursiveCallCount = 0;
c0000bd4:	fec42783          	lw	a5,-20(s0)
c0000bd8:	0007a623          	sw	zero,12(a5)

			traceCREATE_MUTEX( pxNewQueue );

			/* Start with the semaphore in the expected state. */
			( void ) xQueueGenericSend( pxNewQueue, NULL, ( TickType_t ) 0U, queueSEND_TO_BACK );
c0000bdc:	00000693          	li	a3,0
c0000be0:	00000613          	li	a2,0
c0000be4:	00000593          	li	a1,0
c0000be8:	fec42503          	lw	a0,-20(s0)
c0000bec:	308000ef          	jal	ra,c0000ef4 <xQueueGenericSend>
		}
		else
		{
			traceCREATE_MUTEX_FAILED();
		}
	}
c0000bf0:	00000013          	nop
c0000bf4:	01c12083          	lw	ra,28(sp)
c0000bf8:	01812403          	lw	s0,24(sp)
c0000bfc:	02010113          	addi	sp,sp,32
c0000c00:	00008067          	ret

c0000c04 <xQueueCreateMutex>:
/*-----------------------------------------------------------*/

#if( ( configUSE_MUTEXES == 1 ) && ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) )

	QueueHandle_t xQueueCreateMutex( const uint8_t ucQueueType )
	{
c0000c04:	fd010113          	addi	sp,sp,-48
c0000c08:	02112623          	sw	ra,44(sp)
c0000c0c:	02812423          	sw	s0,40(sp)
c0000c10:	03010413          	addi	s0,sp,48
c0000c14:	00050793          	mv	a5,a0
c0000c18:	fcf40fa3          	sb	a5,-33(s0)
	QueueHandle_t xNewQueue;
	const UBaseType_t uxMutexLength = ( UBaseType_t ) 1, uxMutexSize = ( UBaseType_t ) 0;
c0000c1c:	00100793          	li	a5,1
c0000c20:	fef42623          	sw	a5,-20(s0)
c0000c24:	fe042423          	sw	zero,-24(s0)

		xNewQueue = xQueueGenericCreate( uxMutexLength, uxMutexSize, ucQueueType );
c0000c28:	fdf44783          	lbu	a5,-33(s0)
c0000c2c:	00078613          	mv	a2,a5
c0000c30:	fe842583          	lw	a1,-24(s0)
c0000c34:	fec42503          	lw	a0,-20(s0)
c0000c38:	e39ff0ef          	jal	ra,c0000a70 <xQueueGenericCreate>
c0000c3c:	fea42223          	sw	a0,-28(s0)
		prvInitialiseMutex( ( Queue_t * ) xNewQueue );
c0000c40:	fe442503          	lw	a0,-28(s0)
c0000c44:	f65ff0ef          	jal	ra,c0000ba8 <prvInitialiseMutex>

		return xNewQueue;
c0000c48:	fe442783          	lw	a5,-28(s0)
	}
c0000c4c:	00078513          	mv	a0,a5
c0000c50:	02c12083          	lw	ra,44(sp)
c0000c54:	02812403          	lw	s0,40(sp)
c0000c58:	03010113          	addi	sp,sp,48
c0000c5c:	00008067          	ret

c0000c60 <xQueueGetMutexHolder>:
/*-----------------------------------------------------------*/

#if ( ( configUSE_MUTEXES == 1 ) && ( INCLUDE_xSemaphoreGetMutexHolder == 1 ) )

	TaskHandle_t xQueueGetMutexHolder( QueueHandle_t xSemaphore )
	{
c0000c60:	fd010113          	addi	sp,sp,-48
c0000c64:	02112623          	sw	ra,44(sp)
c0000c68:	02812423          	sw	s0,40(sp)
c0000c6c:	03010413          	addi	s0,sp,48
c0000c70:	fca42e23          	sw	a0,-36(s0)
	TaskHandle_t pxReturn;
	Queue_t * const pxSemaphore = ( Queue_t * ) xSemaphore;
c0000c74:	fdc42783          	lw	a5,-36(s0)
c0000c78:	fef42423          	sw	a5,-24(s0)
		/* This function is called by xSemaphoreGetMutexHolder(), and should not
		be called directly.  Note:  This is a good way of determining if the
		calling task is the mutex holder, but not a good way of determining the
		identity of the mutex holder, as the holder may change between the
		following critical section exiting and the function returning. */
		taskENTER_CRITICAL();
c0000c7c:	4c5040ef          	jal	ra,c0005940 <vTaskEnterCritical>
		{
			if( pxSemaphore->uxQueueType == queueQUEUE_IS_MUTEX )
c0000c80:	fe842783          	lw	a5,-24(s0)
c0000c84:	0007a783          	lw	a5,0(a5)
c0000c88:	00079a63          	bnez	a5,c0000c9c <xQueueGetMutexHolder+0x3c>
			{
				pxReturn = pxSemaphore->u.xSemaphore.xMutexHolder;
c0000c8c:	fe842783          	lw	a5,-24(s0)
c0000c90:	0087a783          	lw	a5,8(a5)
c0000c94:	fef42623          	sw	a5,-20(s0)
c0000c98:	0080006f          	j	c0000ca0 <xQueueGetMutexHolder+0x40>
			}
			else
			{
				pxReturn = NULL;
c0000c9c:	fe042623          	sw	zero,-20(s0)
			}
		}
		taskEXIT_CRITICAL();
c0000ca0:	4f5040ef          	jal	ra,c0005994 <vTaskExitCritical>

		return pxReturn;
c0000ca4:	fec42783          	lw	a5,-20(s0)
	} /*lint !e818 xSemaphore cannot be a pointer to const because it is a typedef. */
c0000ca8:	00078513          	mv	a0,a5
c0000cac:	02c12083          	lw	ra,44(sp)
c0000cb0:	02812403          	lw	s0,40(sp)
c0000cb4:	03010113          	addi	sp,sp,48
c0000cb8:	00008067          	ret

c0000cbc <xQueueGetMutexHolderFromISR>:
/*-----------------------------------------------------------*/

#if ( ( configUSE_MUTEXES == 1 ) && ( INCLUDE_xSemaphoreGetMutexHolder == 1 ) )

	TaskHandle_t xQueueGetMutexHolderFromISR( QueueHandle_t xSemaphore )
	{
c0000cbc:	fd010113          	addi	sp,sp,-48
c0000cc0:	02812623          	sw	s0,44(sp)
c0000cc4:	03010413          	addi	s0,sp,48
c0000cc8:	fca42e23          	sw	a0,-36(s0)
	TaskHandle_t pxReturn;

		configASSERT( xSemaphore );
c0000ccc:	fdc42783          	lw	a5,-36(s0)
c0000cd0:	00079863          	bnez	a5,c0000ce0 <xQueueGetMutexHolderFromISR+0x24>
c0000cd4:	30047073          	csrci	mstatus,8
c0000cd8:	00100073          	ebreak
c0000cdc:	0000006f          	j	c0000cdc <xQueueGetMutexHolderFromISR+0x20>

		/* Mutexes cannot be used in interrupt service routines, so the mutex
		holder should not change in an ISR, and therefore a critical section is
		not required here. */
		if( ( ( Queue_t * ) xSemaphore )->uxQueueType == queueQUEUE_IS_MUTEX )
c0000ce0:	fdc42783          	lw	a5,-36(s0)
c0000ce4:	0007a783          	lw	a5,0(a5)
c0000ce8:	00079a63          	bnez	a5,c0000cfc <xQueueGetMutexHolderFromISR+0x40>
		{
			pxReturn = ( ( Queue_t * ) xSemaphore )->u.xSemaphore.xMutexHolder;
c0000cec:	fdc42783          	lw	a5,-36(s0)
c0000cf0:	0087a783          	lw	a5,8(a5)
c0000cf4:	fef42623          	sw	a5,-20(s0)
c0000cf8:	0080006f          	j	c0000d00 <xQueueGetMutexHolderFromISR+0x44>
		}
		else
		{
			pxReturn = NULL;
c0000cfc:	fe042623          	sw	zero,-20(s0)
		}

		return pxReturn;
c0000d00:	fec42783          	lw	a5,-20(s0)
	} /*lint !e818 xSemaphore cannot be a pointer to const because it is a typedef. */
c0000d04:	00078513          	mv	a0,a5
c0000d08:	02c12403          	lw	s0,44(sp)
c0000d0c:	03010113          	addi	sp,sp,48
c0000d10:	00008067          	ret

c0000d14 <xQueueGiveMutexRecursive>:
/*-----------------------------------------------------------*/

#if ( configUSE_RECURSIVE_MUTEXES == 1 )

	BaseType_t xQueueGiveMutexRecursive( QueueHandle_t xMutex )
	{
c0000d14:	fd010113          	addi	sp,sp,-48
c0000d18:	02112623          	sw	ra,44(sp)
c0000d1c:	02812423          	sw	s0,40(sp)
c0000d20:	02912223          	sw	s1,36(sp)
c0000d24:	03010413          	addi	s0,sp,48
c0000d28:	fca42e23          	sw	a0,-36(s0)
	BaseType_t xReturn;
	Queue_t * const pxMutex = ( Queue_t * ) xMutex;
c0000d2c:	fdc42783          	lw	a5,-36(s0)
c0000d30:	fef42423          	sw	a5,-24(s0)

		configASSERT( pxMutex );
c0000d34:	fe842783          	lw	a5,-24(s0)
c0000d38:	00079863          	bnez	a5,c0000d48 <xQueueGiveMutexRecursive+0x34>
c0000d3c:	30047073          	csrci	mstatus,8
c0000d40:	00100073          	ebreak
c0000d44:	0000006f          	j	c0000d44 <xQueueGiveMutexRecursive+0x30>
		change outside of this task.  If this task does not hold the mutex then
		pxMutexHolder can never coincidentally equal the tasks handle, and as
		this is the only condition we are interested in it does not matter if
		pxMutexHolder is accessed simultaneously by another task.  Therefore no
		mutual exclusion is required to test the pxMutexHolder variable. */
		if( pxMutex->u.xSemaphore.xMutexHolder == xTaskGetCurrentTaskHandle() )
c0000d48:	fe842783          	lw	a5,-24(s0)
c0000d4c:	0087a483          	lw	s1,8(a5)
c0000d50:	614040ef          	jal	ra,c0005364 <xTaskGetCurrentTaskHandle>
c0000d54:	00050793          	mv	a5,a0
c0000d58:	04f49263          	bne	s1,a5,c0000d9c <xQueueGiveMutexRecursive+0x88>
			/* uxRecursiveCallCount cannot be zero if xMutexHolder is equal to
			the task handle, therefore no underflow check is required.  Also,
			uxRecursiveCallCount is only modified by the mutex holder, and as
			there can only be one, no mutual exclusion is required to modify the
			uxRecursiveCallCount member. */
			( pxMutex->u.xSemaphore.uxRecursiveCallCount )--;
c0000d5c:	fe842783          	lw	a5,-24(s0)
c0000d60:	00c7a783          	lw	a5,12(a5)
c0000d64:	fff78713          	addi	a4,a5,-1
c0000d68:	fe842783          	lw	a5,-24(s0)
c0000d6c:	00e7a623          	sw	a4,12(a5)

			/* Has the recursive call count unwound to 0? */
			if( pxMutex->u.xSemaphore.uxRecursiveCallCount == ( UBaseType_t ) 0 )
c0000d70:	fe842783          	lw	a5,-24(s0)
c0000d74:	00c7a783          	lw	a5,12(a5)
c0000d78:	00079c63          	bnez	a5,c0000d90 <xQueueGiveMutexRecursive+0x7c>
			{
				/* Return the mutex.  This will automatically unblock any other
				task that might be waiting to access the mutex. */
				( void ) xQueueGenericSend( pxMutex, NULL, queueMUTEX_GIVE_BLOCK_TIME, queueSEND_TO_BACK );
c0000d7c:	00000693          	li	a3,0
c0000d80:	00000613          	li	a2,0
c0000d84:	00000593          	li	a1,0
c0000d88:	fe842503          	lw	a0,-24(s0)
c0000d8c:	168000ef          	jal	ra,c0000ef4 <xQueueGenericSend>
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}

			xReturn = pdPASS;
c0000d90:	00100793          	li	a5,1
c0000d94:	fef42623          	sw	a5,-20(s0)
c0000d98:	0080006f          	j	c0000da0 <xQueueGiveMutexRecursive+0x8c>
		}
		else
		{
			/* The mutex cannot be given because the calling task is not the
			holder. */
			xReturn = pdFAIL;
c0000d9c:	fe042623          	sw	zero,-20(s0)

			traceGIVE_MUTEX_RECURSIVE_FAILED( pxMutex );
		}

		return xReturn;
c0000da0:	fec42783          	lw	a5,-20(s0)
	}
c0000da4:	00078513          	mv	a0,a5
c0000da8:	02c12083          	lw	ra,44(sp)
c0000dac:	02812403          	lw	s0,40(sp)
c0000db0:	02412483          	lw	s1,36(sp)
c0000db4:	03010113          	addi	sp,sp,48
c0000db8:	00008067          	ret

c0000dbc <xQueueTakeMutexRecursive>:
/*-----------------------------------------------------------*/

#if ( configUSE_RECURSIVE_MUTEXES == 1 )

	BaseType_t xQueueTakeMutexRecursive( QueueHandle_t xMutex, TickType_t xTicksToWait )
	{
c0000dbc:	fd010113          	addi	sp,sp,-48
c0000dc0:	02112623          	sw	ra,44(sp)
c0000dc4:	02812423          	sw	s0,40(sp)
c0000dc8:	02912223          	sw	s1,36(sp)
c0000dcc:	03010413          	addi	s0,sp,48
c0000dd0:	fca42e23          	sw	a0,-36(s0)
c0000dd4:	fcb42c23          	sw	a1,-40(s0)
	BaseType_t xReturn;
	Queue_t * const pxMutex = ( Queue_t * ) xMutex;
c0000dd8:	fdc42783          	lw	a5,-36(s0)
c0000ddc:	fef42423          	sw	a5,-24(s0)

		configASSERT( pxMutex );
c0000de0:	fe842783          	lw	a5,-24(s0)
c0000de4:	00079863          	bnez	a5,c0000df4 <xQueueTakeMutexRecursive+0x38>
c0000de8:	30047073          	csrci	mstatus,8
c0000dec:	00100073          	ebreak
c0000df0:	0000006f          	j	c0000df0 <xQueueTakeMutexRecursive+0x34>
		/* Comments regarding mutual exclusion as per those within
		xQueueGiveMutexRecursive(). */

		traceTAKE_MUTEX_RECURSIVE( pxMutex );

		if( pxMutex->u.xSemaphore.xMutexHolder == xTaskGetCurrentTaskHandle() )
c0000df4:	fe842783          	lw	a5,-24(s0)
c0000df8:	0087a483          	lw	s1,8(a5)
c0000dfc:	568040ef          	jal	ra,c0005364 <xTaskGetCurrentTaskHandle>
c0000e00:	00050793          	mv	a5,a0
c0000e04:	02f49263          	bne	s1,a5,c0000e28 <xQueueTakeMutexRecursive+0x6c>
		{
			( pxMutex->u.xSemaphore.uxRecursiveCallCount )++;
c0000e08:	fe842783          	lw	a5,-24(s0)
c0000e0c:	00c7a783          	lw	a5,12(a5)
c0000e10:	00178713          	addi	a4,a5,1
c0000e14:	fe842783          	lw	a5,-24(s0)
c0000e18:	00e7a623          	sw	a4,12(a5)
			xReturn = pdPASS;
c0000e1c:	00100793          	li	a5,1
c0000e20:	fef42623          	sw	a5,-20(s0)
c0000e24:	0300006f          	j	c0000e54 <xQueueTakeMutexRecursive+0x98>
		}
		else
		{
			xReturn = xQueueSemaphoreTake( pxMutex, xTicksToWait );
c0000e28:	fd842583          	lw	a1,-40(s0)
c0000e2c:	fe842503          	lw	a0,-24(s0)
c0000e30:	00d000ef          	jal	ra,c000163c <xQueueSemaphoreTake>
c0000e34:	fea42623          	sw	a0,-20(s0)

			/* pdPASS will only be returned if the mutex was successfully
			obtained.  The calling task may have entered the Blocked state
			before reaching here. */
			if( xReturn != pdFAIL )
c0000e38:	fec42783          	lw	a5,-20(s0)
c0000e3c:	00078c63          	beqz	a5,c0000e54 <xQueueTakeMutexRecursive+0x98>
			{
				( pxMutex->u.xSemaphore.uxRecursiveCallCount )++;
c0000e40:	fe842783          	lw	a5,-24(s0)
c0000e44:	00c7a783          	lw	a5,12(a5)
c0000e48:	00178713          	addi	a4,a5,1
c0000e4c:	fe842783          	lw	a5,-24(s0)
c0000e50:	00e7a623          	sw	a4,12(a5)
			{
				traceTAKE_MUTEX_RECURSIVE_FAILED( pxMutex );
			}
		}

		return xReturn;
c0000e54:	fec42783          	lw	a5,-20(s0)
	}
c0000e58:	00078513          	mv	a0,a5
c0000e5c:	02c12083          	lw	ra,44(sp)
c0000e60:	02812403          	lw	s0,40(sp)
c0000e64:	02412483          	lw	s1,36(sp)
c0000e68:	03010113          	addi	sp,sp,48
c0000e6c:	00008067          	ret

c0000e70 <xQueueCreateCountingSemaphore>:
/*-----------------------------------------------------------*/

#if( ( configUSE_COUNTING_SEMAPHORES == 1 ) && ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) )

	QueueHandle_t xQueueCreateCountingSemaphore( const UBaseType_t uxMaxCount, const UBaseType_t uxInitialCount )
	{
c0000e70:	fd010113          	addi	sp,sp,-48
c0000e74:	02112623          	sw	ra,44(sp)
c0000e78:	02812423          	sw	s0,40(sp)
c0000e7c:	03010413          	addi	s0,sp,48
c0000e80:	fca42e23          	sw	a0,-36(s0)
c0000e84:	fcb42c23          	sw	a1,-40(s0)
	QueueHandle_t xHandle;

		configASSERT( uxMaxCount != 0 );
c0000e88:	fdc42783          	lw	a5,-36(s0)
c0000e8c:	00079863          	bnez	a5,c0000e9c <xQueueCreateCountingSemaphore+0x2c>
c0000e90:	30047073          	csrci	mstatus,8
c0000e94:	00100073          	ebreak
c0000e98:	0000006f          	j	c0000e98 <xQueueCreateCountingSemaphore+0x28>
		configASSERT( uxInitialCount <= uxMaxCount );
c0000e9c:	fd842703          	lw	a4,-40(s0)
c0000ea0:	fdc42783          	lw	a5,-36(s0)
c0000ea4:	00e7f863          	bgeu	a5,a4,c0000eb4 <xQueueCreateCountingSemaphore+0x44>
c0000ea8:	30047073          	csrci	mstatus,8
c0000eac:	00100073          	ebreak
c0000eb0:	0000006f          	j	c0000eb0 <xQueueCreateCountingSemaphore+0x40>

		xHandle = xQueueGenericCreate( uxMaxCount, queueSEMAPHORE_QUEUE_ITEM_LENGTH, queueQUEUE_TYPE_COUNTING_SEMAPHORE );
c0000eb4:	00200613          	li	a2,2
c0000eb8:	00000593          	li	a1,0
c0000ebc:	fdc42503          	lw	a0,-36(s0)
c0000ec0:	bb1ff0ef          	jal	ra,c0000a70 <xQueueGenericCreate>
c0000ec4:	fea42623          	sw	a0,-20(s0)

		if( xHandle != NULL )
c0000ec8:	fec42783          	lw	a5,-20(s0)
c0000ecc:	00078863          	beqz	a5,c0000edc <xQueueCreateCountingSemaphore+0x6c>
		{
			( ( Queue_t * ) xHandle )->uxMessagesWaiting = uxInitialCount;
c0000ed0:	fec42783          	lw	a5,-20(s0)
c0000ed4:	fd842703          	lw	a4,-40(s0)
c0000ed8:	02e7ac23          	sw	a4,56(a5)
		else
		{
			traceCREATE_COUNTING_SEMAPHORE_FAILED();
		}

		return xHandle;
c0000edc:	fec42783          	lw	a5,-20(s0)
	}
c0000ee0:	00078513          	mv	a0,a5
c0000ee4:	02c12083          	lw	ra,44(sp)
c0000ee8:	02812403          	lw	s0,40(sp)
c0000eec:	03010113          	addi	sp,sp,48
c0000ef0:	00008067          	ret

c0000ef4 <xQueueGenericSend>:

#endif /* ( ( configUSE_COUNTING_SEMAPHORES == 1 ) && ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) ) */
/*-----------------------------------------------------------*/

BaseType_t xQueueGenericSend( QueueHandle_t xQueue, const void * const pvItemToQueue, TickType_t xTicksToWait, const BaseType_t xCopyPosition )
{
c0000ef4:	fc010113          	addi	sp,sp,-64
c0000ef8:	02112e23          	sw	ra,60(sp)
c0000efc:	02812c23          	sw	s0,56(sp)
c0000f00:	04010413          	addi	s0,sp,64
c0000f04:	fca42623          	sw	a0,-52(s0)
c0000f08:	fcb42423          	sw	a1,-56(s0)
c0000f0c:	fcc42223          	sw	a2,-60(s0)
c0000f10:	fcd42023          	sw	a3,-64(s0)
BaseType_t xEntryTimeSet = pdFALSE, xYieldRequired;
c0000f14:	fe042623          	sw	zero,-20(s0)
TimeOut_t xTimeOut;
Queue_t * const pxQueue = xQueue;
c0000f18:	fcc42783          	lw	a5,-52(s0)
c0000f1c:	fef42423          	sw	a5,-24(s0)

	configASSERT( pxQueue );
c0000f20:	fe842783          	lw	a5,-24(s0)
c0000f24:	00079863          	bnez	a5,c0000f34 <xQueueGenericSend+0x40>
c0000f28:	30047073          	csrci	mstatus,8
c0000f2c:	00100073          	ebreak
c0000f30:	0000006f          	j	c0000f30 <xQueueGenericSend+0x3c>
	configASSERT( !( ( pvItemToQueue == NULL ) && ( pxQueue->uxItemSize != ( UBaseType_t ) 0U ) ) );
c0000f34:	fc842783          	lw	a5,-56(s0)
c0000f38:	00079863          	bnez	a5,c0000f48 <xQueueGenericSend+0x54>
c0000f3c:	fe842783          	lw	a5,-24(s0)
c0000f40:	0407a783          	lw	a5,64(a5)
c0000f44:	00079663          	bnez	a5,c0000f50 <xQueueGenericSend+0x5c>
c0000f48:	00100793          	li	a5,1
c0000f4c:	0080006f          	j	c0000f54 <xQueueGenericSend+0x60>
c0000f50:	00000793          	li	a5,0
c0000f54:	00079863          	bnez	a5,c0000f64 <xQueueGenericSend+0x70>
c0000f58:	30047073          	csrci	mstatus,8
c0000f5c:	00100073          	ebreak
c0000f60:	0000006f          	j	c0000f60 <xQueueGenericSend+0x6c>
	configASSERT( !( ( xCopyPosition == queueOVERWRITE ) && ( pxQueue->uxLength != 1 ) ) );
c0000f64:	fc042703          	lw	a4,-64(s0)
c0000f68:	00200793          	li	a5,2
c0000f6c:	00f71a63          	bne	a4,a5,c0000f80 <xQueueGenericSend+0x8c>
c0000f70:	fe842783          	lw	a5,-24(s0)
c0000f74:	03c7a703          	lw	a4,60(a5)
c0000f78:	00100793          	li	a5,1
c0000f7c:	00f71663          	bne	a4,a5,c0000f88 <xQueueGenericSend+0x94>
c0000f80:	00100793          	li	a5,1
c0000f84:	0080006f          	j	c0000f8c <xQueueGenericSend+0x98>
c0000f88:	00000793          	li	a5,0
c0000f8c:	00079863          	bnez	a5,c0000f9c <xQueueGenericSend+0xa8>
c0000f90:	30047073          	csrci	mstatus,8
c0000f94:	00100073          	ebreak
c0000f98:	0000006f          	j	c0000f98 <xQueueGenericSend+0xa4>
	#if ( ( INCLUDE_xTaskGetSchedulerState == 1 ) || ( configUSE_TIMERS == 1 ) )
	{
		configASSERT( !( ( xTaskGetSchedulerState() == taskSCHEDULER_SUSPENDED ) && ( xTicksToWait != 0 ) ) );
c0000f9c:	3f8040ef          	jal	ra,c0005394 <xTaskGetSchedulerState>
c0000fa0:	00050793          	mv	a5,a0
c0000fa4:	00079663          	bnez	a5,c0000fb0 <xQueueGenericSend+0xbc>
c0000fa8:	fc442783          	lw	a5,-60(s0)
c0000fac:	00079663          	bnez	a5,c0000fb8 <xQueueGenericSend+0xc4>
c0000fb0:	00100793          	li	a5,1
c0000fb4:	0080006f          	j	c0000fbc <xQueueGenericSend+0xc8>
c0000fb8:	00000793          	li	a5,0
c0000fbc:	00079863          	bnez	a5,c0000fcc <xQueueGenericSend+0xd8>
c0000fc0:	30047073          	csrci	mstatus,8
c0000fc4:	00100073          	ebreak
c0000fc8:	0000006f          	j	c0000fc8 <xQueueGenericSend+0xd4>
	/*lint -save -e904 This function relaxes the coding standard somewhat to
	allow return statements within the function itself.  This is done in the
	interest of execution time efficiency. */
	for( ;; )
	{
		taskENTER_CRITICAL();
c0000fcc:	175040ef          	jal	ra,c0005940 <vTaskEnterCritical>
		{
			/* Is there room on the queue now?  The running task must be the
			highest priority task wanting to access the queue.  If the head item
			in the queue is to be overwritten then it does not matter if the
			queue is full. */
			if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
c0000fd0:	fe842783          	lw	a5,-24(s0)
c0000fd4:	0387a703          	lw	a4,56(a5)
c0000fd8:	fe842783          	lw	a5,-24(s0)
c0000fdc:	03c7a783          	lw	a5,60(a5)
c0000fe0:	00f76863          	bltu	a4,a5,c0000ff0 <xQueueGenericSend+0xfc>
c0000fe4:	fc042703          	lw	a4,-64(s0)
c0000fe8:	00200793          	li	a5,2
c0000fec:	04f71e63          	bne	a4,a5,c0001048 <xQueueGenericSend+0x154>
						}
					}
				}
				#else /* configUSE_QUEUE_SETS */
				{
					xYieldRequired = prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
c0000ff0:	fc042603          	lw	a2,-64(s0)
c0000ff4:	fc842583          	lw	a1,-56(s0)
c0000ff8:	fe842503          	lw	a0,-24(s0)
c0000ffc:	735000ef          	jal	ra,c0001f30 <prvCopyDataToQueue>
c0001000:	fea42223          	sw	a0,-28(s0)

					/* If there was a task waiting for data to arrive on the
					queue then unblock it now. */
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
c0001004:	fe842783          	lw	a5,-24(s0)
c0001008:	0247a783          	lw	a5,36(a5)
c000100c:	02078263          	beqz	a5,c0001030 <xQueueGenericSend+0x13c>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
c0001010:	fe842783          	lw	a5,-24(s0)
c0001014:	02478793          	addi	a5,a5,36
c0001018:	00078513          	mv	a0,a5
c000101c:	091030ef          	jal	ra,c00048ac <xTaskRemoveFromEventList>
c0001020:	00050793          	mv	a5,a0
c0001024:	00078c63          	beqz	a5,c000103c <xQueueGenericSend+0x148>
						{
							/* The unblocked task has a priority higher than
							our own so yield immediately.  Yes it is ok to do
							this from within the critical section - the kernel
							takes care of that. */
							queueYIELD_IF_USING_PREEMPTION();
c0001028:	00000073          	ecall
c000102c:	0100006f          	j	c000103c <xQueueGenericSend+0x148>
						else
						{
							mtCOVERAGE_TEST_MARKER();
						}
					}
					else if( xYieldRequired != pdFALSE )
c0001030:	fe442783          	lw	a5,-28(s0)
c0001034:	00078463          	beqz	a5,c000103c <xQueueGenericSend+0x148>
					{
						/* This path is a special case that will only get
						executed if the task was holding multiple mutexes and
						the mutexes were given back in an order that is
						different to that in which they were taken. */
						queueYIELD_IF_USING_PREEMPTION();
c0001038:	00000073          	ecall
						mtCOVERAGE_TEST_MARKER();
					}
				}
				#endif /* configUSE_QUEUE_SETS */

				taskEXIT_CRITICAL();
c000103c:	159040ef          	jal	ra,c0005994 <vTaskExitCritical>
				return pdPASS;
c0001040:	00100793          	li	a5,1
c0001044:	1040006f          	j	c0001148 <xQueueGenericSend+0x254>
			}
			else
			{
				if( xTicksToWait == ( TickType_t ) 0 )
c0001048:	fc442783          	lw	a5,-60(s0)
c000104c:	00079863          	bnez	a5,c000105c <xQueueGenericSend+0x168>
				{
					/* The queue was full and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
c0001050:	145040ef          	jal	ra,c0005994 <vTaskExitCritical>

					/* Return to the original privilege level before exiting
					the function. */
					traceQUEUE_SEND_FAILED( pxQueue );
					return errQUEUE_FULL;
c0001054:	00000793          	li	a5,0
c0001058:	0f00006f          	j	c0001148 <xQueueGenericSend+0x254>
				}
				else if( xEntryTimeSet == pdFALSE )
c000105c:	fec42783          	lw	a5,-20(s0)
c0001060:	00079c63          	bnez	a5,c0001078 <xQueueGenericSend+0x184>
				{
					/* The queue was full and a block time was specified so
					configure the timeout structure. */
					vTaskInternalSetTimeOutState( &xTimeOut );
c0001064:	fdc40793          	addi	a5,s0,-36
c0001068:	00078513          	mv	a0,a5
c000106c:	30d030ef          	jal	ra,c0004b78 <vTaskInternalSetTimeOutState>
					xEntryTimeSet = pdTRUE;
c0001070:	00100793          	li	a5,1
c0001074:	fef42623          	sw	a5,-20(s0)
					/* Entry time was already set. */
					mtCOVERAGE_TEST_MARKER();
				}
			}
		}
		taskEXIT_CRITICAL();
c0001078:	11d040ef          	jal	ra,c0005994 <vTaskExitCritical>

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
c000107c:	6e0020ef          	jal	ra,c000375c <vTaskSuspendAll>
		prvLockQueue( pxQueue );
c0001080:	0c1040ef          	jal	ra,c0005940 <vTaskEnterCritical>
c0001084:	fe842783          	lw	a5,-24(s0)
c0001088:	0447c783          	lbu	a5,68(a5)
c000108c:	01879713          	slli	a4,a5,0x18
c0001090:	41875713          	srai	a4,a4,0x18
c0001094:	fff00793          	li	a5,-1
c0001098:	00f71663          	bne	a4,a5,c00010a4 <xQueueGenericSend+0x1b0>
c000109c:	fe842783          	lw	a5,-24(s0)
c00010a0:	04078223          	sb	zero,68(a5)
c00010a4:	fe842783          	lw	a5,-24(s0)
c00010a8:	0457c783          	lbu	a5,69(a5)
c00010ac:	01879713          	slli	a4,a5,0x18
c00010b0:	41875713          	srai	a4,a4,0x18
c00010b4:	fff00793          	li	a5,-1
c00010b8:	00f71663          	bne	a4,a5,c00010c4 <xQueueGenericSend+0x1d0>
c00010bc:	fe842783          	lw	a5,-24(s0)
c00010c0:	040782a3          	sb	zero,69(a5)
c00010c4:	0d1040ef          	jal	ra,c0005994 <vTaskExitCritical>

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
c00010c8:	fc440713          	addi	a4,s0,-60
c00010cc:	fdc40793          	addi	a5,s0,-36
c00010d0:	00070593          	mv	a1,a4
c00010d4:	00078513          	mv	a0,a5
c00010d8:	2e9030ef          	jal	ra,c0004bc0 <xTaskCheckForTimeOut>
c00010dc:	00050793          	mv	a5,a0
c00010e0:	04079c63          	bnez	a5,c0001138 <xQueueGenericSend+0x244>
		{
			if( prvIsQueueFull( pxQueue ) != pdFALSE )
c00010e4:	fe842503          	lw	a0,-24(s0)
c00010e8:	218010ef          	jal	ra,c0002300 <prvIsQueueFull>
c00010ec:	00050793          	mv	a5,a0
c00010f0:	02078c63          	beqz	a5,c0001128 <xQueueGenericSend+0x234>
			{
				traceBLOCKING_ON_QUEUE_SEND( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
c00010f4:	fe842783          	lw	a5,-24(s0)
c00010f8:	01078793          	addi	a5,a5,16
c00010fc:	fc442703          	lw	a4,-60(s0)
c0001100:	00070593          	mv	a1,a4
c0001104:	00078513          	mv	a0,a5
c0001108:	61c030ef          	jal	ra,c0004724 <vTaskPlaceOnEventList>
				/* Unlocking the queue means queue events can effect the
				event list.  It is possible that interrupts occurring now
				remove this task from the event list again - but as the
				scheduler is suspended the task will go onto the pending
				ready last instead of the actual ready list. */
				prvUnlockQueue( pxQueue );
c000110c:	fe842503          	lw	a0,-24(s0)
c0001110:	044010ef          	jal	ra,c0002154 <prvUnlockQueue>
				/* Resuming the scheduler will move tasks from the pending
				ready list into the ready list - so it is feasible that this
				task is already in a ready list before it yields - in which
				case the yield will not cause a context switch unless there
				is also a higher priority task in the pending ready list. */
				if( xTaskResumeAll() == pdFALSE )
c0001114:	680020ef          	jal	ra,c0003794 <xTaskResumeAll>
c0001118:	00050793          	mv	a5,a0
c000111c:	ea0798e3          	bnez	a5,c0000fcc <xQueueGenericSend+0xd8>
				{
					portYIELD_WITHIN_API();
c0001120:	00000073          	ecall
c0001124:	ea9ff06f          	j	c0000fcc <xQueueGenericSend+0xd8>
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
c0001128:	fe842503          	lw	a0,-24(s0)
c000112c:	028010ef          	jal	ra,c0002154 <prvUnlockQueue>
				( void ) xTaskResumeAll();
c0001130:	664020ef          	jal	ra,c0003794 <xTaskResumeAll>
c0001134:	e99ff06f          	j	c0000fcc <xQueueGenericSend+0xd8>
			}
		}
		else
		{
			/* The timeout has expired. */
			prvUnlockQueue( pxQueue );
c0001138:	fe842503          	lw	a0,-24(s0)
c000113c:	018010ef          	jal	ra,c0002154 <prvUnlockQueue>
			( void ) xTaskResumeAll();
c0001140:	654020ef          	jal	ra,c0003794 <xTaskResumeAll>

			traceQUEUE_SEND_FAILED( pxQueue );
			return errQUEUE_FULL;
c0001144:	00000793          	li	a5,0
		}
	} /*lint -restore */
}
c0001148:	00078513          	mv	a0,a5
c000114c:	03c12083          	lw	ra,60(sp)
c0001150:	03812403          	lw	s0,56(sp)
c0001154:	04010113          	addi	sp,sp,64
c0001158:	00008067          	ret

c000115c <xQueueGenericSendFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xQueueGenericSendFromISR( QueueHandle_t xQueue, const void * const pvItemToQueue, BaseType_t * const pxHigherPriorityTaskWoken, const BaseType_t xCopyPosition )
{
c000115c:	fd010113          	addi	sp,sp,-48
c0001160:	02112623          	sw	ra,44(sp)
c0001164:	02812423          	sw	s0,40(sp)
c0001168:	03010413          	addi	s0,sp,48
c000116c:	fca42e23          	sw	a0,-36(s0)
c0001170:	fcb42c23          	sw	a1,-40(s0)
c0001174:	fcc42a23          	sw	a2,-44(s0)
c0001178:	fcd42823          	sw	a3,-48(s0)
BaseType_t xReturn;
UBaseType_t uxSavedInterruptStatus;
Queue_t * const pxQueue = xQueue;
c000117c:	fdc42783          	lw	a5,-36(s0)
c0001180:	fef42423          	sw	a5,-24(s0)

	configASSERT( pxQueue );
c0001184:	fe842783          	lw	a5,-24(s0)
c0001188:	00079863          	bnez	a5,c0001198 <xQueueGenericSendFromISR+0x3c>
c000118c:	30047073          	csrci	mstatus,8
c0001190:	00100073          	ebreak
c0001194:	0000006f          	j	c0001194 <xQueueGenericSendFromISR+0x38>
	configASSERT( !( ( pvItemToQueue == NULL ) && ( pxQueue->uxItemSize != ( UBaseType_t ) 0U ) ) );
c0001198:	fd842783          	lw	a5,-40(s0)
c000119c:	00079863          	bnez	a5,c00011ac <xQueueGenericSendFromISR+0x50>
c00011a0:	fe842783          	lw	a5,-24(s0)
c00011a4:	0407a783          	lw	a5,64(a5)
c00011a8:	00079663          	bnez	a5,c00011b4 <xQueueGenericSendFromISR+0x58>
c00011ac:	00100793          	li	a5,1
c00011b0:	0080006f          	j	c00011b8 <xQueueGenericSendFromISR+0x5c>
c00011b4:	00000793          	li	a5,0
c00011b8:	00079863          	bnez	a5,c00011c8 <xQueueGenericSendFromISR+0x6c>
c00011bc:	30047073          	csrci	mstatus,8
c00011c0:	00100073          	ebreak
c00011c4:	0000006f          	j	c00011c4 <xQueueGenericSendFromISR+0x68>
	configASSERT( !( ( xCopyPosition == queueOVERWRITE ) && ( pxQueue->uxLength != 1 ) ) );
c00011c8:	fd042703          	lw	a4,-48(s0)
c00011cc:	00200793          	li	a5,2
c00011d0:	00f71a63          	bne	a4,a5,c00011e4 <xQueueGenericSendFromISR+0x88>
c00011d4:	fe842783          	lw	a5,-24(s0)
c00011d8:	03c7a703          	lw	a4,60(a5)
c00011dc:	00100793          	li	a5,1
c00011e0:	00f71663          	bne	a4,a5,c00011ec <xQueueGenericSendFromISR+0x90>
c00011e4:	00100793          	li	a5,1
c00011e8:	0080006f          	j	c00011f0 <xQueueGenericSendFromISR+0x94>
c00011ec:	00000793          	li	a5,0
c00011f0:	00079863          	bnez	a5,c0001200 <xQueueGenericSendFromISR+0xa4>
c00011f4:	30047073          	csrci	mstatus,8
c00011f8:	00100073          	ebreak
c00011fc:	0000006f          	j	c00011fc <xQueueGenericSendFromISR+0xa0>
	/* Similar to xQueueGenericSend, except without blocking if there is no room
	in the queue.  Also don't directly wake a task that was blocked on a queue
	read, instead return a flag to say whether a context switch is required or
	not (i.e. has a task with a higher priority than us been woken by this
	post). */
	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
c0001200:	fe042223          	sw	zero,-28(s0)
	{
		if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
c0001204:	fe842783          	lw	a5,-24(s0)
c0001208:	0387a703          	lw	a4,56(a5)
c000120c:	fe842783          	lw	a5,-24(s0)
c0001210:	03c7a783          	lw	a5,60(a5)
c0001214:	00f76863          	bltu	a4,a5,c0001224 <xQueueGenericSendFromISR+0xc8>
c0001218:	fd042703          	lw	a4,-48(s0)
c000121c:	00200793          	li	a5,2
c0001220:	08f71863          	bne	a4,a5,c00012b0 <xQueueGenericSendFromISR+0x154>
		{
			const int8_t cTxLock = pxQueue->cTxLock;
c0001224:	fe842783          	lw	a5,-24(s0)
c0001228:	0457c783          	lbu	a5,69(a5)
c000122c:	fef401a3          	sb	a5,-29(s0)

			traceQUEUE_SEND_FROM_ISR( pxQueue );

			/* The event list is not altered if the queue is locked.  This will
			be done when the queue is unlocked later. */
			if( cTxLock == queueUNLOCKED )
c0001230:	fe340703          	lb	a4,-29(s0)
c0001234:	fff00793          	li	a5,-1
c0001238:	04f71863          	bne	a4,a5,c0001288 <xQueueGenericSendFromISR+0x12c>
					/* Semaphores use xQueueGiveFromISR(), so pxQueue will not be a
					semaphore or mutex.  That means prvCopyDataToQueue() cannot result
					in a task disinheriting a priority and prvCopyDataToQueue() can be
					called here even though the disinherit function does not check if
					the scheduler is suspended before accessing the ready lists. */
					( void ) prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
c000123c:	fd042603          	lw	a2,-48(s0)
c0001240:	fd842583          	lw	a1,-40(s0)
c0001244:	fe842503          	lw	a0,-24(s0)
c0001248:	4e9000ef          	jal	ra,c0001f30 <prvCopyDataToQueue>

					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
c000124c:	fe842783          	lw	a5,-24(s0)
c0001250:	0247a783          	lw	a5,36(a5)
c0001254:	04078863          	beqz	a5,c00012a4 <xQueueGenericSendFromISR+0x148>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
c0001258:	fe842783          	lw	a5,-24(s0)
c000125c:	02478793          	addi	a5,a5,36
c0001260:	00078513          	mv	a0,a5
c0001264:	648030ef          	jal	ra,c00048ac <xTaskRemoveFromEventList>
c0001268:	00050793          	mv	a5,a0
c000126c:	02078c63          	beqz	a5,c00012a4 <xQueueGenericSendFromISR+0x148>
						{
							/* The task waiting has a higher priority so record that a
							context	switch is required. */
							if( pxHigherPriorityTaskWoken != NULL )
c0001270:	fd442783          	lw	a5,-44(s0)
c0001274:	02078863          	beqz	a5,c00012a4 <xQueueGenericSendFromISR+0x148>
							{
								*pxHigherPriorityTaskWoken = pdTRUE;
c0001278:	fd442783          	lw	a5,-44(s0)
c000127c:	00100713          	li	a4,1
c0001280:	00e7a023          	sw	a4,0(a5)
c0001284:	0200006f          	j	c00012a4 <xQueueGenericSendFromISR+0x148>
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was posted while it was locked. */
				pxQueue->cTxLock = ( int8_t ) ( cTxLock + 1 );
c0001288:	fe344783          	lbu	a5,-29(s0)
c000128c:	00178793          	addi	a5,a5,1
c0001290:	0ff7f793          	andi	a5,a5,255
c0001294:	01879713          	slli	a4,a5,0x18
c0001298:	41875713          	srai	a4,a4,0x18
c000129c:	fe842783          	lw	a5,-24(s0)
c00012a0:	04e782a3          	sb	a4,69(a5)
			}

			xReturn = pdPASS;
c00012a4:	00100793          	li	a5,1
c00012a8:	fef42623          	sw	a5,-20(s0)
		{
c00012ac:	0080006f          	j	c00012b4 <xQueueGenericSendFromISR+0x158>
		}
		else
		{
			traceQUEUE_SEND_FROM_ISR_FAILED( pxQueue );
			xReturn = errQUEUE_FULL;
c00012b0:	fe042623          	sw	zero,-20(s0)
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
c00012b4:	fec42783          	lw	a5,-20(s0)
}
c00012b8:	00078513          	mv	a0,a5
c00012bc:	02c12083          	lw	ra,44(sp)
c00012c0:	02812403          	lw	s0,40(sp)
c00012c4:	03010113          	addi	sp,sp,48
c00012c8:	00008067          	ret

c00012cc <xQueueGiveFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xQueueGiveFromISR( QueueHandle_t xQueue, BaseType_t * const pxHigherPriorityTaskWoken )
{
c00012cc:	fc010113          	addi	sp,sp,-64
c00012d0:	02112e23          	sw	ra,60(sp)
c00012d4:	02812c23          	sw	s0,56(sp)
c00012d8:	04010413          	addi	s0,sp,64
c00012dc:	fca42623          	sw	a0,-52(s0)
c00012e0:	fcb42423          	sw	a1,-56(s0)
BaseType_t xReturn;
UBaseType_t uxSavedInterruptStatus;
Queue_t * const pxQueue = xQueue;
c00012e4:	fcc42783          	lw	a5,-52(s0)
c00012e8:	fef42423          	sw	a5,-24(s0)
	item size is 0.  Don't directly wake a task that was blocked on a queue
	read, instead return a flag to say whether a context switch is required or
	not (i.e. has a task with a higher priority than us been woken by this
	post). */

	configASSERT( pxQueue );
c00012ec:	fe842783          	lw	a5,-24(s0)
c00012f0:	00079863          	bnez	a5,c0001300 <xQueueGiveFromISR+0x34>
c00012f4:	30047073          	csrci	mstatus,8
c00012f8:	00100073          	ebreak
c00012fc:	0000006f          	j	c00012fc <xQueueGiveFromISR+0x30>

	/* xQueueGenericSendFromISR() should be used instead of xQueueGiveFromISR()
	if the item size is not 0. */
	configASSERT( pxQueue->uxItemSize == 0 );
c0001300:	fe842783          	lw	a5,-24(s0)
c0001304:	0407a783          	lw	a5,64(a5)
c0001308:	00078863          	beqz	a5,c0001318 <xQueueGiveFromISR+0x4c>
c000130c:	30047073          	csrci	mstatus,8
c0001310:	00100073          	ebreak
c0001314:	0000006f          	j	c0001314 <xQueueGiveFromISR+0x48>

	/* Normally a mutex would not be given from an interrupt, especially if
	there is a mutex holder, as priority inheritance makes no sense for an
	interrupts, only tasks. */
	configASSERT( !( ( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX ) && ( pxQueue->u.xSemaphore.xMutexHolder != NULL ) ) );
c0001318:	fe842783          	lw	a5,-24(s0)
c000131c:	0007a783          	lw	a5,0(a5)
c0001320:	00079863          	bnez	a5,c0001330 <xQueueGiveFromISR+0x64>
c0001324:	fe842783          	lw	a5,-24(s0)
c0001328:	0087a783          	lw	a5,8(a5)
c000132c:	00079663          	bnez	a5,c0001338 <xQueueGiveFromISR+0x6c>
c0001330:	00100793          	li	a5,1
c0001334:	0080006f          	j	c000133c <xQueueGiveFromISR+0x70>
c0001338:	00000793          	li	a5,0
c000133c:	00079863          	bnez	a5,c000134c <xQueueGiveFromISR+0x80>
c0001340:	30047073          	csrci	mstatus,8
c0001344:	00100073          	ebreak
c0001348:	0000006f          	j	c0001348 <xQueueGiveFromISR+0x7c>
	safe API to ensure interrupt entry is as fast and as simple as possible.
	More information (albeit Cortex-M specific) is provided on the following
	link: http://www.freertos.org/RTOS-Cortex-M3-M4.html */
	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
c000134c:	fe042223          	sw	zero,-28(s0)
	{
		const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
c0001350:	fe842783          	lw	a5,-24(s0)
c0001354:	0387a783          	lw	a5,56(a5)
c0001358:	fef42023          	sw	a5,-32(s0)

		/* When the queue is used to implement a semaphore no data is ever
		moved through the queue but it is still valid to see if the queue 'has
		space'. */
		if( uxMessagesWaiting < pxQueue->uxLength )
c000135c:	fe842783          	lw	a5,-24(s0)
c0001360:	03c7a783          	lw	a5,60(a5)
c0001364:	fe042703          	lw	a4,-32(s0)
c0001368:	08f77863          	bgeu	a4,a5,c00013f8 <xQueueGiveFromISR+0x12c>
		{
			const int8_t cTxLock = pxQueue->cTxLock;
c000136c:	fe842783          	lw	a5,-24(s0)
c0001370:	0457c783          	lbu	a5,69(a5)
c0001374:	fcf40fa3          	sb	a5,-33(s0)
			holder - and if there is a mutex holder then the mutex cannot be
			given from an ISR.  As this is the ISR version of the function it
			can be assumed there is no mutex holder and no need to determine if
			priority disinheritance is needed.  Simply increase the count of
			messages (semaphores) available. */
			pxQueue->uxMessagesWaiting = uxMessagesWaiting + ( UBaseType_t ) 1;
c0001378:	fe042783          	lw	a5,-32(s0)
c000137c:	00178713          	addi	a4,a5,1
c0001380:	fe842783          	lw	a5,-24(s0)
c0001384:	02e7ac23          	sw	a4,56(a5)

			/* The event list is not altered if the queue is locked.  This will
			be done when the queue is unlocked later. */
			if( cTxLock == queueUNLOCKED )
c0001388:	fdf40703          	lb	a4,-33(s0)
c000138c:	fff00793          	li	a5,-1
c0001390:	04f71063          	bne	a4,a5,c00013d0 <xQueueGiveFromISR+0x104>
						}
					}
				}
				#else /* configUSE_QUEUE_SETS */
				{
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
c0001394:	fe842783          	lw	a5,-24(s0)
c0001398:	0247a783          	lw	a5,36(a5)
c000139c:	04078863          	beqz	a5,c00013ec <xQueueGiveFromISR+0x120>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
c00013a0:	fe842783          	lw	a5,-24(s0)
c00013a4:	02478793          	addi	a5,a5,36
c00013a8:	00078513          	mv	a0,a5
c00013ac:	500030ef          	jal	ra,c00048ac <xTaskRemoveFromEventList>
c00013b0:	00050793          	mv	a5,a0
c00013b4:	02078c63          	beqz	a5,c00013ec <xQueueGiveFromISR+0x120>
						{
							/* The task waiting has a higher priority so record that a
							context	switch is required. */
							if( pxHigherPriorityTaskWoken != NULL )
c00013b8:	fc842783          	lw	a5,-56(s0)
c00013bc:	02078863          	beqz	a5,c00013ec <xQueueGiveFromISR+0x120>
							{
								*pxHigherPriorityTaskWoken = pdTRUE;
c00013c0:	fc842783          	lw	a5,-56(s0)
c00013c4:	00100713          	li	a4,1
c00013c8:	00e7a023          	sw	a4,0(a5)
c00013cc:	0200006f          	j	c00013ec <xQueueGiveFromISR+0x120>
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was posted while it was locked. */
				pxQueue->cTxLock = ( int8_t ) ( cTxLock + 1 );
c00013d0:	fdf44783          	lbu	a5,-33(s0)
c00013d4:	00178793          	addi	a5,a5,1
c00013d8:	0ff7f793          	andi	a5,a5,255
c00013dc:	01879713          	slli	a4,a5,0x18
c00013e0:	41875713          	srai	a4,a4,0x18
c00013e4:	fe842783          	lw	a5,-24(s0)
c00013e8:	04e782a3          	sb	a4,69(a5)
			}

			xReturn = pdPASS;
c00013ec:	00100793          	li	a5,1
c00013f0:	fef42623          	sw	a5,-20(s0)
c00013f4:	0080006f          	j	c00013fc <xQueueGiveFromISR+0x130>
		}
		else
		{
			traceQUEUE_SEND_FROM_ISR_FAILED( pxQueue );
			xReturn = errQUEUE_FULL;
c00013f8:	fe042623          	sw	zero,-20(s0)
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
c00013fc:	fec42783          	lw	a5,-20(s0)
}
c0001400:	00078513          	mv	a0,a5
c0001404:	03c12083          	lw	ra,60(sp)
c0001408:	03812403          	lw	s0,56(sp)
c000140c:	04010113          	addi	sp,sp,64
c0001410:	00008067          	ret

c0001414 <xQueueReceive>:
/*-----------------------------------------------------------*/

BaseType_t xQueueReceive( QueueHandle_t xQueue, void * const pvBuffer, TickType_t xTicksToWait )
{
c0001414:	fc010113          	addi	sp,sp,-64
c0001418:	02112e23          	sw	ra,60(sp)
c000141c:	02812c23          	sw	s0,56(sp)
c0001420:	04010413          	addi	s0,sp,64
c0001424:	fca42623          	sw	a0,-52(s0)
c0001428:	fcb42423          	sw	a1,-56(s0)
c000142c:	fcc42223          	sw	a2,-60(s0)
BaseType_t xEntryTimeSet = pdFALSE;
c0001430:	fe042623          	sw	zero,-20(s0)
TimeOut_t xTimeOut;
Queue_t * const pxQueue = xQueue;
c0001434:	fcc42783          	lw	a5,-52(s0)
c0001438:	fef42423          	sw	a5,-24(s0)

	/* Check the pointer is not NULL. */
	configASSERT( ( pxQueue ) );
c000143c:	fe842783          	lw	a5,-24(s0)
c0001440:	00079863          	bnez	a5,c0001450 <xQueueReceive+0x3c>
c0001444:	30047073          	csrci	mstatus,8
c0001448:	00100073          	ebreak
c000144c:	0000006f          	j	c000144c <xQueueReceive+0x38>

	/* The buffer into which data is received can only be NULL if the data size
	is zero (so no data is copied into the buffer. */
	configASSERT( !( ( ( pvBuffer ) == NULL ) && ( ( pxQueue )->uxItemSize != ( UBaseType_t ) 0U ) ) );
c0001450:	fc842783          	lw	a5,-56(s0)
c0001454:	00079863          	bnez	a5,c0001464 <xQueueReceive+0x50>
c0001458:	fe842783          	lw	a5,-24(s0)
c000145c:	0407a783          	lw	a5,64(a5)
c0001460:	00079663          	bnez	a5,c000146c <xQueueReceive+0x58>
c0001464:	00100793          	li	a5,1
c0001468:	0080006f          	j	c0001470 <xQueueReceive+0x5c>
c000146c:	00000793          	li	a5,0
c0001470:	00079863          	bnez	a5,c0001480 <xQueueReceive+0x6c>
c0001474:	30047073          	csrci	mstatus,8
c0001478:	00100073          	ebreak
c000147c:	0000006f          	j	c000147c <xQueueReceive+0x68>

	/* Cannot block if the scheduler is suspended. */
	#if ( ( INCLUDE_xTaskGetSchedulerState == 1 ) || ( configUSE_TIMERS == 1 ) )
	{
		configASSERT( !( ( xTaskGetSchedulerState() == taskSCHEDULER_SUSPENDED ) && ( xTicksToWait != 0 ) ) );
c0001480:	715030ef          	jal	ra,c0005394 <xTaskGetSchedulerState>
c0001484:	00050793          	mv	a5,a0
c0001488:	00079663          	bnez	a5,c0001494 <xQueueReceive+0x80>
c000148c:	fc442783          	lw	a5,-60(s0)
c0001490:	00079663          	bnez	a5,c000149c <xQueueReceive+0x88>
c0001494:	00100793          	li	a5,1
c0001498:	0080006f          	j	c00014a0 <xQueueReceive+0x8c>
c000149c:	00000793          	li	a5,0
c00014a0:	00079863          	bnez	a5,c00014b0 <xQueueReceive+0x9c>
c00014a4:	30047073          	csrci	mstatus,8
c00014a8:	00100073          	ebreak
c00014ac:	0000006f          	j	c00014ac <xQueueReceive+0x98>
	/*lint -save -e904  This function relaxes the coding standard somewhat to
	allow return statements within the function itself.  This is done in the
	interest of execution time efficiency. */
	for( ;; )
	{
		taskENTER_CRITICAL();
c00014b0:	490040ef          	jal	ra,c0005940 <vTaskEnterCritical>
		{
			const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
c00014b4:	fe842783          	lw	a5,-24(s0)
c00014b8:	0387a783          	lw	a5,56(a5)
c00014bc:	fef42223          	sw	a5,-28(s0)

			/* Is there data in the queue now?  To be running the calling task
			must be the highest priority task wanting to access the queue. */
			if( uxMessagesWaiting > ( UBaseType_t ) 0 )
c00014c0:	fe442783          	lw	a5,-28(s0)
c00014c4:	04078a63          	beqz	a5,c0001518 <xQueueReceive+0x104>
			{
				/* Data available, remove one item. */
				prvCopyDataFromQueue( pxQueue, pvBuffer );
c00014c8:	fc842583          	lw	a1,-56(s0)
c00014cc:	fe842503          	lw	a0,-24(s0)
c00014d0:	3ed000ef          	jal	ra,c00020bc <prvCopyDataFromQueue>
				traceQUEUE_RECEIVE( pxQueue );
				pxQueue->uxMessagesWaiting = uxMessagesWaiting - ( UBaseType_t ) 1;
c00014d4:	fe442783          	lw	a5,-28(s0)
c00014d8:	fff78713          	addi	a4,a5,-1
c00014dc:	fe842783          	lw	a5,-24(s0)
c00014e0:	02e7ac23          	sw	a4,56(a5)

				/* There is now space in the queue, were any tasks waiting to
				post to the queue?  If so, unblock the highest priority waiting
				task. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
c00014e4:	fe842783          	lw	a5,-24(s0)
c00014e8:	0107a783          	lw	a5,16(a5)
c00014ec:	02078063          	beqz	a5,c000150c <xQueueReceive+0xf8>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
c00014f0:	fe842783          	lw	a5,-24(s0)
c00014f4:	01078793          	addi	a5,a5,16
c00014f8:	00078513          	mv	a0,a5
c00014fc:	3b0030ef          	jal	ra,c00048ac <xTaskRemoveFromEventList>
c0001500:	00050793          	mv	a5,a0
c0001504:	00078463          	beqz	a5,c000150c <xQueueReceive+0xf8>
					{
						queueYIELD_IF_USING_PREEMPTION();
c0001508:	00000073          	ecall
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}

				taskEXIT_CRITICAL();
c000150c:	488040ef          	jal	ra,c0005994 <vTaskExitCritical>
				return pdPASS;
c0001510:	00100793          	li	a5,1
c0001514:	1140006f          	j	c0001628 <xQueueReceive+0x214>
			}
			else
			{
				if( xTicksToWait == ( TickType_t ) 0 )
c0001518:	fc442783          	lw	a5,-60(s0)
c000151c:	00079863          	bnez	a5,c000152c <xQueueReceive+0x118>
				{
					/* The queue was empty and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
c0001520:	474040ef          	jal	ra,c0005994 <vTaskExitCritical>
					traceQUEUE_RECEIVE_FAILED( pxQueue );
					return errQUEUE_EMPTY;
c0001524:	00000793          	li	a5,0
c0001528:	1000006f          	j	c0001628 <xQueueReceive+0x214>
				}
				else if( xEntryTimeSet == pdFALSE )
c000152c:	fec42783          	lw	a5,-20(s0)
c0001530:	00079c63          	bnez	a5,c0001548 <xQueueReceive+0x134>
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure. */
					vTaskInternalSetTimeOutState( &xTimeOut );
c0001534:	fdc40793          	addi	a5,s0,-36
c0001538:	00078513          	mv	a0,a5
c000153c:	63c030ef          	jal	ra,c0004b78 <vTaskInternalSetTimeOutState>
					xEntryTimeSet = pdTRUE;
c0001540:	00100793          	li	a5,1
c0001544:	fef42623          	sw	a5,-20(s0)
					/* Entry time was already set. */
					mtCOVERAGE_TEST_MARKER();
				}
			}
		}
		taskEXIT_CRITICAL();
c0001548:	44c040ef          	jal	ra,c0005994 <vTaskExitCritical>

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
c000154c:	210020ef          	jal	ra,c000375c <vTaskSuspendAll>
		prvLockQueue( pxQueue );
c0001550:	3f0040ef          	jal	ra,c0005940 <vTaskEnterCritical>
c0001554:	fe842783          	lw	a5,-24(s0)
c0001558:	0447c783          	lbu	a5,68(a5)
c000155c:	01879713          	slli	a4,a5,0x18
c0001560:	41875713          	srai	a4,a4,0x18
c0001564:	fff00793          	li	a5,-1
c0001568:	00f71663          	bne	a4,a5,c0001574 <xQueueReceive+0x160>
c000156c:	fe842783          	lw	a5,-24(s0)
c0001570:	04078223          	sb	zero,68(a5)
c0001574:	fe842783          	lw	a5,-24(s0)
c0001578:	0457c783          	lbu	a5,69(a5)
c000157c:	01879713          	slli	a4,a5,0x18
c0001580:	41875713          	srai	a4,a4,0x18
c0001584:	fff00793          	li	a5,-1
c0001588:	00f71663          	bne	a4,a5,c0001594 <xQueueReceive+0x180>
c000158c:	fe842783          	lw	a5,-24(s0)
c0001590:	040782a3          	sb	zero,69(a5)
c0001594:	400040ef          	jal	ra,c0005994 <vTaskExitCritical>

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
c0001598:	fc440713          	addi	a4,s0,-60
c000159c:	fdc40793          	addi	a5,s0,-36
c00015a0:	00070593          	mv	a1,a4
c00015a4:	00078513          	mv	a0,a5
c00015a8:	618030ef          	jal	ra,c0004bc0 <xTaskCheckForTimeOut>
c00015ac:	00050793          	mv	a5,a0
c00015b0:	04079c63          	bnez	a5,c0001608 <xQueueReceive+0x1f4>
		{
			/* The timeout has not expired.  If the queue is still empty place
			the task on the list of tasks waiting to receive from the queue. */
			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
c00015b4:	fe842503          	lw	a0,-24(s0)
c00015b8:	49d000ef          	jal	ra,c0002254 <prvIsQueueEmpty>
c00015bc:	00050793          	mv	a5,a0
c00015c0:	02078c63          	beqz	a5,c00015f8 <xQueueReceive+0x1e4>
			{
				traceBLOCKING_ON_QUEUE_RECEIVE( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
c00015c4:	fe842783          	lw	a5,-24(s0)
c00015c8:	02478793          	addi	a5,a5,36
c00015cc:	fc442703          	lw	a4,-60(s0)
c00015d0:	00070593          	mv	a1,a4
c00015d4:	00078513          	mv	a0,a5
c00015d8:	14c030ef          	jal	ra,c0004724 <vTaskPlaceOnEventList>
				prvUnlockQueue( pxQueue );
c00015dc:	fe842503          	lw	a0,-24(s0)
c00015e0:	375000ef          	jal	ra,c0002154 <prvUnlockQueue>
				if( xTaskResumeAll() == pdFALSE )
c00015e4:	1b0020ef          	jal	ra,c0003794 <xTaskResumeAll>
c00015e8:	00050793          	mv	a5,a0
c00015ec:	ec0792e3          	bnez	a5,c00014b0 <xQueueReceive+0x9c>
				{
					portYIELD_WITHIN_API();
c00015f0:	00000073          	ecall
c00015f4:	ebdff06f          	j	c00014b0 <xQueueReceive+0x9c>
			}
			else
			{
				/* The queue contains data again.  Loop back to try and read the
				data. */
				prvUnlockQueue( pxQueue );
c00015f8:	fe842503          	lw	a0,-24(s0)
c00015fc:	359000ef          	jal	ra,c0002154 <prvUnlockQueue>
				( void ) xTaskResumeAll();
c0001600:	194020ef          	jal	ra,c0003794 <xTaskResumeAll>
c0001604:	eadff06f          	j	c00014b0 <xQueueReceive+0x9c>
		}
		else
		{
			/* Timed out.  If there is no data in the queue exit, otherwise loop
			back and attempt to read the data. */
			prvUnlockQueue( pxQueue );
c0001608:	fe842503          	lw	a0,-24(s0)
c000160c:	349000ef          	jal	ra,c0002154 <prvUnlockQueue>
			( void ) xTaskResumeAll();
c0001610:	184020ef          	jal	ra,c0003794 <xTaskResumeAll>

			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
c0001614:	fe842503          	lw	a0,-24(s0)
c0001618:	43d000ef          	jal	ra,c0002254 <prvIsQueueEmpty>
c000161c:	00050793          	mv	a5,a0
c0001620:	e80788e3          	beqz	a5,c00014b0 <xQueueReceive+0x9c>
			{
				traceQUEUE_RECEIVE_FAILED( pxQueue );
				return errQUEUE_EMPTY;
c0001624:	00000793          	li	a5,0
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
	} /*lint -restore */
}
c0001628:	00078513          	mv	a0,a5
c000162c:	03c12083          	lw	ra,60(sp)
c0001630:	03812403          	lw	s0,56(sp)
c0001634:	04010113          	addi	sp,sp,64
c0001638:	00008067          	ret

c000163c <xQueueSemaphoreTake>:
/*-----------------------------------------------------------*/

BaseType_t xQueueSemaphoreTake( QueueHandle_t xQueue, TickType_t xTicksToWait )
{
c000163c:	fc010113          	addi	sp,sp,-64
c0001640:	02112e23          	sw	ra,60(sp)
c0001644:	02812c23          	sw	s0,56(sp)
c0001648:	04010413          	addi	s0,sp,64
c000164c:	fca42623          	sw	a0,-52(s0)
c0001650:	fcb42423          	sw	a1,-56(s0)
BaseType_t xEntryTimeSet = pdFALSE;
c0001654:	fe042623          	sw	zero,-20(s0)
TimeOut_t xTimeOut;
Queue_t * const pxQueue = xQueue;
c0001658:	fcc42783          	lw	a5,-52(s0)
c000165c:	fef42223          	sw	a5,-28(s0)

#if( configUSE_MUTEXES == 1 )
	BaseType_t xInheritanceOccurred = pdFALSE;
c0001660:	fe042423          	sw	zero,-24(s0)
#endif

	/* Check the queue pointer is not NULL. */
	configASSERT( ( pxQueue ) );
c0001664:	fe442783          	lw	a5,-28(s0)
c0001668:	00079863          	bnez	a5,c0001678 <xQueueSemaphoreTake+0x3c>
c000166c:	30047073          	csrci	mstatus,8
c0001670:	00100073          	ebreak
c0001674:	0000006f          	j	c0001674 <xQueueSemaphoreTake+0x38>

	/* Check this really is a semaphore, in which case the item size will be
	0. */
	configASSERT( pxQueue->uxItemSize == 0 );
c0001678:	fe442783          	lw	a5,-28(s0)
c000167c:	0407a783          	lw	a5,64(a5)
c0001680:	00078863          	beqz	a5,c0001690 <xQueueSemaphoreTake+0x54>
c0001684:	30047073          	csrci	mstatus,8
c0001688:	00100073          	ebreak
c000168c:	0000006f          	j	c000168c <xQueueSemaphoreTake+0x50>

	/* Cannot block if the scheduler is suspended. */
	#if ( ( INCLUDE_xTaskGetSchedulerState == 1 ) || ( configUSE_TIMERS == 1 ) )
	{
		configASSERT( !( ( xTaskGetSchedulerState() == taskSCHEDULER_SUSPENDED ) && ( xTicksToWait != 0 ) ) );
c0001690:	505030ef          	jal	ra,c0005394 <xTaskGetSchedulerState>
c0001694:	00050793          	mv	a5,a0
c0001698:	00079663          	bnez	a5,c00016a4 <xQueueSemaphoreTake+0x68>
c000169c:	fc842783          	lw	a5,-56(s0)
c00016a0:	00079663          	bnez	a5,c00016ac <xQueueSemaphoreTake+0x70>
c00016a4:	00100793          	li	a5,1
c00016a8:	0080006f          	j	c00016b0 <xQueueSemaphoreTake+0x74>
c00016ac:	00000793          	li	a5,0
c00016b0:	00079863          	bnez	a5,c00016c0 <xQueueSemaphoreTake+0x84>
c00016b4:	30047073          	csrci	mstatus,8
c00016b8:	00100073          	ebreak
c00016bc:	0000006f          	j	c00016bc <xQueueSemaphoreTake+0x80>
	/*lint -save -e904 This function relaxes the coding standard somewhat to allow return
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */
	for( ;; )
	{
		taskENTER_CRITICAL();
c00016c0:	280040ef          	jal	ra,c0005940 <vTaskEnterCritical>
		{
			/* Semaphores are queues with an item size of 0, and where the
			number of messages in the queue is the semaphore's count value. */
			const UBaseType_t uxSemaphoreCount = pxQueue->uxMessagesWaiting;
c00016c4:	fe442783          	lw	a5,-28(s0)
c00016c8:	0387a783          	lw	a5,56(a5)
c00016cc:	fef42023          	sw	a5,-32(s0)

			/* Is there data in the queue now?  To be running the calling task
			must be the highest priority task wanting to access the queue. */
			if( uxSemaphoreCount > ( UBaseType_t ) 0 )
c00016d0:	fe042783          	lw	a5,-32(s0)
c00016d4:	06078263          	beqz	a5,c0001738 <xQueueSemaphoreTake+0xfc>
			{
				traceQUEUE_RECEIVE( pxQueue );

				/* Semaphores are queues with a data size of zero and where the
				messages waiting is the semaphore's count.  Reduce the count. */
				pxQueue->uxMessagesWaiting = uxSemaphoreCount - ( UBaseType_t ) 1;
c00016d8:	fe042783          	lw	a5,-32(s0)
c00016dc:	fff78713          	addi	a4,a5,-1
c00016e0:	fe442783          	lw	a5,-28(s0)
c00016e4:	02e7ac23          	sw	a4,56(a5)

				#if ( configUSE_MUTEXES == 1 )
				{
					if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
c00016e8:	fe442783          	lw	a5,-28(s0)
c00016ec:	0007a783          	lw	a5,0(a5)
c00016f0:	00079a63          	bnez	a5,c0001704 <xQueueSemaphoreTake+0xc8>
					{
						/* Record the information required to implement
						priority inheritance should it become necessary. */
						pxQueue->u.xSemaphore.xMutexHolder = pvTaskIncrementMutexHeldCount();
c00016f4:	60c040ef          	jal	ra,c0005d00 <pvTaskIncrementMutexHeldCount>
c00016f8:	00050713          	mv	a4,a0
c00016fc:	fe442783          	lw	a5,-28(s0)
c0001700:	00e7a423          	sw	a4,8(a5)
				}
				#endif /* configUSE_MUTEXES */

				/* Check to see if other tasks are blocked waiting to give the
				semaphore, and if so, unblock the highest priority such task. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
c0001704:	fe442783          	lw	a5,-28(s0)
c0001708:	0107a783          	lw	a5,16(a5)
c000170c:	02078063          	beqz	a5,c000172c <xQueueSemaphoreTake+0xf0>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
c0001710:	fe442783          	lw	a5,-28(s0)
c0001714:	01078793          	addi	a5,a5,16
c0001718:	00078513          	mv	a0,a5
c000171c:	190030ef          	jal	ra,c00048ac <xTaskRemoveFromEventList>
c0001720:	00050793          	mv	a5,a0
c0001724:	00078463          	beqz	a5,c000172c <xQueueSemaphoreTake+0xf0>
					{
						queueYIELD_IF_USING_PREEMPTION();
c0001728:	00000073          	ecall
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}

				taskEXIT_CRITICAL();
c000172c:	268040ef          	jal	ra,c0005994 <vTaskExitCritical>
				return pdPASS;
c0001730:	00100793          	li	a5,1
c0001734:	1800006f          	j	c00018b4 <xQueueSemaphoreTake+0x278>
			}
			else
			{
				if( xTicksToWait == ( TickType_t ) 0 )
c0001738:	fc842783          	lw	a5,-56(s0)
c000173c:	02079263          	bnez	a5,c0001760 <xQueueSemaphoreTake+0x124>
					/* For inheritance to have occurred there must have been an
					initial timeout, and an adjusted timeout cannot become 0, as
					if it were 0 the function would have exited. */
					#if( configUSE_MUTEXES == 1 )
					{
						configASSERT( xInheritanceOccurred == pdFALSE );
c0001740:	fe842783          	lw	a5,-24(s0)
c0001744:	00078863          	beqz	a5,c0001754 <xQueueSemaphoreTake+0x118>
c0001748:	30047073          	csrci	mstatus,8
c000174c:	00100073          	ebreak
c0001750:	0000006f          	j	c0001750 <xQueueSemaphoreTake+0x114>
					}
					#endif /* configUSE_MUTEXES */

					/* The semaphore count was 0 and no block time is specified
					(or the block time has expired) so exit now. */
					taskEXIT_CRITICAL();
c0001754:	240040ef          	jal	ra,c0005994 <vTaskExitCritical>
					traceQUEUE_RECEIVE_FAILED( pxQueue );
					return errQUEUE_EMPTY;
c0001758:	00000793          	li	a5,0
c000175c:	1580006f          	j	c00018b4 <xQueueSemaphoreTake+0x278>
				}
				else if( xEntryTimeSet == pdFALSE )
c0001760:	fec42783          	lw	a5,-20(s0)
c0001764:	00079c63          	bnez	a5,c000177c <xQueueSemaphoreTake+0x140>
				{
					/* The semaphore count was 0 and a block time was specified
					so configure the timeout structure ready to block. */
					vTaskInternalSetTimeOutState( &xTimeOut );
c0001768:	fd440793          	addi	a5,s0,-44
c000176c:	00078513          	mv	a0,a5
c0001770:	408030ef          	jal	ra,c0004b78 <vTaskInternalSetTimeOutState>
					xEntryTimeSet = pdTRUE;
c0001774:	00100793          	li	a5,1
c0001778:	fef42623          	sw	a5,-20(s0)
					/* Entry time was already set. */
					mtCOVERAGE_TEST_MARKER();
				}
			}
		}
		taskEXIT_CRITICAL();
c000177c:	218040ef          	jal	ra,c0005994 <vTaskExitCritical>

		/* Interrupts and other tasks can give to and take from the semaphore
		now the critical section has been exited. */

		vTaskSuspendAll();
c0001780:	7dd010ef          	jal	ra,c000375c <vTaskSuspendAll>
		prvLockQueue( pxQueue );
c0001784:	1bc040ef          	jal	ra,c0005940 <vTaskEnterCritical>
c0001788:	fe442783          	lw	a5,-28(s0)
c000178c:	0447c783          	lbu	a5,68(a5)
c0001790:	01879713          	slli	a4,a5,0x18
c0001794:	41875713          	srai	a4,a4,0x18
c0001798:	fff00793          	li	a5,-1
c000179c:	00f71663          	bne	a4,a5,c00017a8 <xQueueSemaphoreTake+0x16c>
c00017a0:	fe442783          	lw	a5,-28(s0)
c00017a4:	04078223          	sb	zero,68(a5)
c00017a8:	fe442783          	lw	a5,-28(s0)
c00017ac:	0457c783          	lbu	a5,69(a5)
c00017b0:	01879713          	slli	a4,a5,0x18
c00017b4:	41875713          	srai	a4,a4,0x18
c00017b8:	fff00793          	li	a5,-1
c00017bc:	00f71663          	bne	a4,a5,c00017c8 <xQueueSemaphoreTake+0x18c>
c00017c0:	fe442783          	lw	a5,-28(s0)
c00017c4:	040782a3          	sb	zero,69(a5)
c00017c8:	1cc040ef          	jal	ra,c0005994 <vTaskExitCritical>

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
c00017cc:	fc840713          	addi	a4,s0,-56
c00017d0:	fd440793          	addi	a5,s0,-44
c00017d4:	00070593          	mv	a1,a4
c00017d8:	00078513          	mv	a0,a5
c00017dc:	3e4030ef          	jal	ra,c0004bc0 <xTaskCheckForTimeOut>
c00017e0:	00050793          	mv	a5,a0
c00017e4:	08079063          	bnez	a5,c0001864 <xQueueSemaphoreTake+0x228>
		{
			/* A block time is specified and not expired.  If the semaphore
			count is 0 then enter the Blocked state to wait for a semaphore to
			become available.  As semaphores are implemented with queues the
			queue being empty is equivalent to the semaphore count being 0. */
			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
c00017e8:	fe442503          	lw	a0,-28(s0)
c00017ec:	269000ef          	jal	ra,c0002254 <prvIsQueueEmpty>
c00017f0:	00050793          	mv	a5,a0
c00017f4:	06078063          	beqz	a5,c0001854 <xQueueSemaphoreTake+0x218>
			{
				traceBLOCKING_ON_QUEUE_RECEIVE( pxQueue );

				#if ( configUSE_MUTEXES == 1 )
				{
					if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
c00017f8:	fe442783          	lw	a5,-28(s0)
c00017fc:	0007a783          	lw	a5,0(a5)
c0001800:	02079063          	bnez	a5,c0001820 <xQueueSemaphoreTake+0x1e4>
					{
						taskENTER_CRITICAL();
c0001804:	13c040ef          	jal	ra,c0005940 <vTaskEnterCritical>
						{
							xInheritanceOccurred = xTaskPriorityInherit( pxQueue->u.xSemaphore.xMutexHolder );
c0001808:	fe442783          	lw	a5,-28(s0)
c000180c:	0087a783          	lw	a5,8(a5)
c0001810:	00078513          	mv	a0,a5
c0001814:	3dd030ef          	jal	ra,c00053f0 <xTaskPriorityInherit>
c0001818:	fea42423          	sw	a0,-24(s0)
						}
						taskEXIT_CRITICAL();
c000181c:	178040ef          	jal	ra,c0005994 <vTaskExitCritical>
						mtCOVERAGE_TEST_MARKER();
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
c0001820:	fe442783          	lw	a5,-28(s0)
c0001824:	02478793          	addi	a5,a5,36
c0001828:	fc842703          	lw	a4,-56(s0)
c000182c:	00070593          	mv	a1,a4
c0001830:	00078513          	mv	a0,a5
c0001834:	6f1020ef          	jal	ra,c0004724 <vTaskPlaceOnEventList>
				prvUnlockQueue( pxQueue );
c0001838:	fe442503          	lw	a0,-28(s0)
c000183c:	119000ef          	jal	ra,c0002154 <prvUnlockQueue>
				if( xTaskResumeAll() == pdFALSE )
c0001840:	755010ef          	jal	ra,c0003794 <xTaskResumeAll>
c0001844:	00050793          	mv	a5,a0
c0001848:	e6079ce3          	bnez	a5,c00016c0 <xQueueSemaphoreTake+0x84>
				{
					portYIELD_WITHIN_API();
c000184c:	00000073          	ecall
c0001850:	e71ff06f          	j	c00016c0 <xQueueSemaphoreTake+0x84>
			}
			else
			{
				/* There was no timeout and the semaphore count was not 0, so
				attempt to take the semaphore again. */
				prvUnlockQueue( pxQueue );
c0001854:	fe442503          	lw	a0,-28(s0)
c0001858:	0fd000ef          	jal	ra,c0002154 <prvUnlockQueue>
				( void ) xTaskResumeAll();
c000185c:	739010ef          	jal	ra,c0003794 <xTaskResumeAll>
c0001860:	e61ff06f          	j	c00016c0 <xQueueSemaphoreTake+0x84>
			}
		}
		else
		{
			/* Timed out. */
			prvUnlockQueue( pxQueue );
c0001864:	fe442503          	lw	a0,-28(s0)
c0001868:	0ed000ef          	jal	ra,c0002154 <prvUnlockQueue>
			( void ) xTaskResumeAll();
c000186c:	729010ef          	jal	ra,c0003794 <xTaskResumeAll>

			/* If the semaphore count is 0 exit now as the timeout has
			expired.  Otherwise return to attempt to take the semaphore that is
			known to be available.  As semaphores are implemented by queues the
			queue being empty is equivalent to the semaphore count being 0. */
			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
c0001870:	fe442503          	lw	a0,-28(s0)
c0001874:	1e1000ef          	jal	ra,c0002254 <prvIsQueueEmpty>
c0001878:	00050793          	mv	a5,a0
c000187c:	e40782e3          	beqz	a5,c00016c0 <xQueueSemaphoreTake+0x84>
				#if ( configUSE_MUTEXES == 1 )
				{
					/* xInheritanceOccurred could only have be set if
					pxQueue->uxQueueType == queueQUEUE_IS_MUTEX so no need to
					test the mutex type again to check it is actually a mutex. */
					if( xInheritanceOccurred != pdFALSE )
c0001880:	fe842783          	lw	a5,-24(s0)
c0001884:	02078663          	beqz	a5,c00018b0 <xQueueSemaphoreTake+0x274>
					{
						taskENTER_CRITICAL();
c0001888:	0b8040ef          	jal	ra,c0005940 <vTaskEnterCritical>
							/* This task blocking on the mutex caused another
							task to inherit this task's priority.  Now this task
							has timed out the priority should be disinherited
							again, but only as low as the next highest priority
							task that is waiting for the same mutex. */
							uxHighestWaitingPriority = prvGetDisinheritPriorityAfterTimeout( pxQueue );
c000188c:	fe442503          	lw	a0,-28(s0)
c0001890:	650000ef          	jal	ra,c0001ee0 <prvGetDisinheritPriorityAfterTimeout>
c0001894:	fca42e23          	sw	a0,-36(s0)
							vTaskPriorityDisinheritAfterTimeout( pxQueue->u.xSemaphore.xMutexHolder, uxHighestWaitingPriority );
c0001898:	fe442783          	lw	a5,-28(s0)
c000189c:	0087a783          	lw	a5,8(a5)
c00018a0:	fdc42583          	lw	a1,-36(s0)
c00018a4:	00078513          	mv	a0,a5
c00018a8:	6c5030ef          	jal	ra,c000576c <vTaskPriorityDisinheritAfterTimeout>
						}
						taskEXIT_CRITICAL();
c00018ac:	0e8040ef          	jal	ra,c0005994 <vTaskExitCritical>
					}
				}
				#endif /* configUSE_MUTEXES */

				traceQUEUE_RECEIVE_FAILED( pxQueue );
				return errQUEUE_EMPTY;
c00018b0:	00000793          	li	a5,0
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
	} /*lint -restore */
}
c00018b4:	00078513          	mv	a0,a5
c00018b8:	03c12083          	lw	ra,60(sp)
c00018bc:	03812403          	lw	s0,56(sp)
c00018c0:	04010113          	addi	sp,sp,64
c00018c4:	00008067          	ret

c00018c8 <xQueuePeek>:
/*-----------------------------------------------------------*/

BaseType_t xQueuePeek( QueueHandle_t xQueue, void * const pvBuffer, TickType_t xTicksToWait )
{
c00018c8:	fc010113          	addi	sp,sp,-64
c00018cc:	02112e23          	sw	ra,60(sp)
c00018d0:	02812c23          	sw	s0,56(sp)
c00018d4:	04010413          	addi	s0,sp,64
c00018d8:	fca42623          	sw	a0,-52(s0)
c00018dc:	fcb42423          	sw	a1,-56(s0)
c00018e0:	fcc42223          	sw	a2,-60(s0)
BaseType_t xEntryTimeSet = pdFALSE;
c00018e4:	fe042623          	sw	zero,-20(s0)
TimeOut_t xTimeOut;
int8_t *pcOriginalReadPosition;
Queue_t * const pxQueue = xQueue;
c00018e8:	fcc42783          	lw	a5,-52(s0)
c00018ec:	fef42423          	sw	a5,-24(s0)

	/* Check the pointer is not NULL. */
	configASSERT( ( pxQueue ) );
c00018f0:	fe842783          	lw	a5,-24(s0)
c00018f4:	00079863          	bnez	a5,c0001904 <xQueuePeek+0x3c>
c00018f8:	30047073          	csrci	mstatus,8
c00018fc:	00100073          	ebreak
c0001900:	0000006f          	j	c0001900 <xQueuePeek+0x38>

	/* The buffer into which data is received can only be NULL if the data size
	is zero (so no data is copied into the buffer. */
	configASSERT( !( ( ( pvBuffer ) == NULL ) && ( ( pxQueue )->uxItemSize != ( UBaseType_t ) 0U ) ) );
c0001904:	fc842783          	lw	a5,-56(s0)
c0001908:	00079863          	bnez	a5,c0001918 <xQueuePeek+0x50>
c000190c:	fe842783          	lw	a5,-24(s0)
c0001910:	0407a783          	lw	a5,64(a5)
c0001914:	00079663          	bnez	a5,c0001920 <xQueuePeek+0x58>
c0001918:	00100793          	li	a5,1
c000191c:	0080006f          	j	c0001924 <xQueuePeek+0x5c>
c0001920:	00000793          	li	a5,0
c0001924:	00079863          	bnez	a5,c0001934 <xQueuePeek+0x6c>
c0001928:	30047073          	csrci	mstatus,8
c000192c:	00100073          	ebreak
c0001930:	0000006f          	j	c0001930 <xQueuePeek+0x68>

	/* Cannot block if the scheduler is suspended. */
	#if ( ( INCLUDE_xTaskGetSchedulerState == 1 ) || ( configUSE_TIMERS == 1 ) )
	{
		configASSERT( !( ( xTaskGetSchedulerState() == taskSCHEDULER_SUSPENDED ) && ( xTicksToWait != 0 ) ) );
c0001934:	261030ef          	jal	ra,c0005394 <xTaskGetSchedulerState>
c0001938:	00050793          	mv	a5,a0
c000193c:	00079663          	bnez	a5,c0001948 <xQueuePeek+0x80>
c0001940:	fc442783          	lw	a5,-60(s0)
c0001944:	00079663          	bnez	a5,c0001950 <xQueuePeek+0x88>
c0001948:	00100793          	li	a5,1
c000194c:	0080006f          	j	c0001954 <xQueuePeek+0x8c>
c0001950:	00000793          	li	a5,0
c0001954:	00079863          	bnez	a5,c0001964 <xQueuePeek+0x9c>
c0001958:	30047073          	csrci	mstatus,8
c000195c:	00100073          	ebreak
c0001960:	0000006f          	j	c0001960 <xQueuePeek+0x98>
	/*lint -save -e904  This function relaxes the coding standard somewhat to
	allow return statements within the function itself.  This is done in the
	interest of execution time efficiency. */
	for( ;; )
	{
		taskENTER_CRITICAL();
c0001964:	7dd030ef          	jal	ra,c0005940 <vTaskEnterCritical>
		{
			const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
c0001968:	fe842783          	lw	a5,-24(s0)
c000196c:	0387a783          	lw	a5,56(a5)
c0001970:	fef42223          	sw	a5,-28(s0)

			/* Is there data in the queue now?  To be running the calling task
			must be the highest priority task wanting to access the queue. */
			if( uxMessagesWaiting > ( UBaseType_t ) 0 )
c0001974:	fe442783          	lw	a5,-28(s0)
c0001978:	04078e63          	beqz	a5,c00019d4 <xQueuePeek+0x10c>
			{
				/* Remember the read position so it can be reset after the data
				is read from the queue as this function is only peeking the
				data, not removing it. */
				pcOriginalReadPosition = pxQueue->u.xQueue.pcReadFrom;
c000197c:	fe842783          	lw	a5,-24(s0)
c0001980:	00c7a783          	lw	a5,12(a5)
c0001984:	fef42023          	sw	a5,-32(s0)

				prvCopyDataFromQueue( pxQueue, pvBuffer );
c0001988:	fc842583          	lw	a1,-56(s0)
c000198c:	fe842503          	lw	a0,-24(s0)
c0001990:	72c000ef          	jal	ra,c00020bc <prvCopyDataFromQueue>
				traceQUEUE_PEEK( pxQueue );

				/* The data is not being removed, so reset the read pointer. */
				pxQueue->u.xQueue.pcReadFrom = pcOriginalReadPosition;
c0001994:	fe842783          	lw	a5,-24(s0)
c0001998:	fe042703          	lw	a4,-32(s0)
c000199c:	00e7a623          	sw	a4,12(a5)

				/* The data is being left in the queue, so see if there are
				any other tasks waiting for the data. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
c00019a0:	fe842783          	lw	a5,-24(s0)
c00019a4:	0247a783          	lw	a5,36(a5)
c00019a8:	02078063          	beqz	a5,c00019c8 <xQueuePeek+0x100>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
c00019ac:	fe842783          	lw	a5,-24(s0)
c00019b0:	02478793          	addi	a5,a5,36
c00019b4:	00078513          	mv	a0,a5
c00019b8:	6f5020ef          	jal	ra,c00048ac <xTaskRemoveFromEventList>
c00019bc:	00050793          	mv	a5,a0
c00019c0:	00078463          	beqz	a5,c00019c8 <xQueuePeek+0x100>
					{
						/* The task waiting has a higher priority than this task. */
						queueYIELD_IF_USING_PREEMPTION();
c00019c4:	00000073          	ecall
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}

				taskEXIT_CRITICAL();
c00019c8:	7cd030ef          	jal	ra,c0005994 <vTaskExitCritical>
				return pdPASS;
c00019cc:	00100793          	li	a5,1
c00019d0:	1140006f          	j	c0001ae4 <xQueuePeek+0x21c>
			}
			else
			{
				if( xTicksToWait == ( TickType_t ) 0 )
c00019d4:	fc442783          	lw	a5,-60(s0)
c00019d8:	00079863          	bnez	a5,c00019e8 <xQueuePeek+0x120>
				{
					/* The queue was empty and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
c00019dc:	7b9030ef          	jal	ra,c0005994 <vTaskExitCritical>
					traceQUEUE_PEEK_FAILED( pxQueue );
					return errQUEUE_EMPTY;
c00019e0:	00000793          	li	a5,0
c00019e4:	1000006f          	j	c0001ae4 <xQueuePeek+0x21c>
				}
				else if( xEntryTimeSet == pdFALSE )
c00019e8:	fec42783          	lw	a5,-20(s0)
c00019ec:	00079c63          	bnez	a5,c0001a04 <xQueuePeek+0x13c>
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure ready to enter the blocked
					state. */
					vTaskInternalSetTimeOutState( &xTimeOut );
c00019f0:	fd840793          	addi	a5,s0,-40
c00019f4:	00078513          	mv	a0,a5
c00019f8:	180030ef          	jal	ra,c0004b78 <vTaskInternalSetTimeOutState>
					xEntryTimeSet = pdTRUE;
c00019fc:	00100793          	li	a5,1
c0001a00:	fef42623          	sw	a5,-20(s0)
					/* Entry time was already set. */
					mtCOVERAGE_TEST_MARKER();
				}
			}
		}
		taskEXIT_CRITICAL();
c0001a04:	791030ef          	jal	ra,c0005994 <vTaskExitCritical>

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
c0001a08:	555010ef          	jal	ra,c000375c <vTaskSuspendAll>
		prvLockQueue( pxQueue );
c0001a0c:	735030ef          	jal	ra,c0005940 <vTaskEnterCritical>
c0001a10:	fe842783          	lw	a5,-24(s0)
c0001a14:	0447c783          	lbu	a5,68(a5)
c0001a18:	01879713          	slli	a4,a5,0x18
c0001a1c:	41875713          	srai	a4,a4,0x18
c0001a20:	fff00793          	li	a5,-1
c0001a24:	00f71663          	bne	a4,a5,c0001a30 <xQueuePeek+0x168>
c0001a28:	fe842783          	lw	a5,-24(s0)
c0001a2c:	04078223          	sb	zero,68(a5)
c0001a30:	fe842783          	lw	a5,-24(s0)
c0001a34:	0457c783          	lbu	a5,69(a5)
c0001a38:	01879713          	slli	a4,a5,0x18
c0001a3c:	41875713          	srai	a4,a4,0x18
c0001a40:	fff00793          	li	a5,-1
c0001a44:	00f71663          	bne	a4,a5,c0001a50 <xQueuePeek+0x188>
c0001a48:	fe842783          	lw	a5,-24(s0)
c0001a4c:	040782a3          	sb	zero,69(a5)
c0001a50:	745030ef          	jal	ra,c0005994 <vTaskExitCritical>

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
c0001a54:	fc440713          	addi	a4,s0,-60
c0001a58:	fd840793          	addi	a5,s0,-40
c0001a5c:	00070593          	mv	a1,a4
c0001a60:	00078513          	mv	a0,a5
c0001a64:	15c030ef          	jal	ra,c0004bc0 <xTaskCheckForTimeOut>
c0001a68:	00050793          	mv	a5,a0
c0001a6c:	04079c63          	bnez	a5,c0001ac4 <xQueuePeek+0x1fc>
		{
			/* Timeout has not expired yet, check to see if there is data in the
			queue now, and if not enter the Blocked state to wait for data. */
			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
c0001a70:	fe842503          	lw	a0,-24(s0)
c0001a74:	7e0000ef          	jal	ra,c0002254 <prvIsQueueEmpty>
c0001a78:	00050793          	mv	a5,a0
c0001a7c:	02078c63          	beqz	a5,c0001ab4 <xQueuePeek+0x1ec>
			{
				traceBLOCKING_ON_QUEUE_PEEK( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
c0001a80:	fe842783          	lw	a5,-24(s0)
c0001a84:	02478793          	addi	a5,a5,36
c0001a88:	fc442703          	lw	a4,-60(s0)
c0001a8c:	00070593          	mv	a1,a4
c0001a90:	00078513          	mv	a0,a5
c0001a94:	491020ef          	jal	ra,c0004724 <vTaskPlaceOnEventList>
				prvUnlockQueue( pxQueue );
c0001a98:	fe842503          	lw	a0,-24(s0)
c0001a9c:	6b8000ef          	jal	ra,c0002154 <prvUnlockQueue>
				if( xTaskResumeAll() == pdFALSE )
c0001aa0:	4f5010ef          	jal	ra,c0003794 <xTaskResumeAll>
c0001aa4:	00050793          	mv	a5,a0
c0001aa8:	ea079ee3          	bnez	a5,c0001964 <xQueuePeek+0x9c>
				{
					portYIELD_WITHIN_API();
c0001aac:	00000073          	ecall
c0001ab0:	eb5ff06f          	j	c0001964 <xQueuePeek+0x9c>
			}
			else
			{
				/* There is data in the queue now, so don't enter the blocked
				state, instead return to try and obtain the data. */
				prvUnlockQueue( pxQueue );
c0001ab4:	fe842503          	lw	a0,-24(s0)
c0001ab8:	69c000ef          	jal	ra,c0002154 <prvUnlockQueue>
				( void ) xTaskResumeAll();
c0001abc:	4d9010ef          	jal	ra,c0003794 <xTaskResumeAll>
c0001ac0:	ea5ff06f          	j	c0001964 <xQueuePeek+0x9c>
		}
		else
		{
			/* The timeout has expired.  If there is still no data in the queue
			exit, otherwise go back and try to read the data again. */
			prvUnlockQueue( pxQueue );
c0001ac4:	fe842503          	lw	a0,-24(s0)
c0001ac8:	68c000ef          	jal	ra,c0002154 <prvUnlockQueue>
			( void ) xTaskResumeAll();
c0001acc:	4c9010ef          	jal	ra,c0003794 <xTaskResumeAll>

			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
c0001ad0:	fe842503          	lw	a0,-24(s0)
c0001ad4:	780000ef          	jal	ra,c0002254 <prvIsQueueEmpty>
c0001ad8:	00050793          	mv	a5,a0
c0001adc:	e80784e3          	beqz	a5,c0001964 <xQueuePeek+0x9c>
			{
				traceQUEUE_PEEK_FAILED( pxQueue );
				return errQUEUE_EMPTY;
c0001ae0:	00000793          	li	a5,0
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
	} /*lint -restore */
}
c0001ae4:	00078513          	mv	a0,a5
c0001ae8:	03c12083          	lw	ra,60(sp)
c0001aec:	03812403          	lw	s0,56(sp)
c0001af0:	04010113          	addi	sp,sp,64
c0001af4:	00008067          	ret

c0001af8 <xQueueReceiveFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xQueueReceiveFromISR( QueueHandle_t xQueue, void * const pvBuffer, BaseType_t * const pxHigherPriorityTaskWoken )
{
c0001af8:	fc010113          	addi	sp,sp,-64
c0001afc:	02112e23          	sw	ra,60(sp)
c0001b00:	02812c23          	sw	s0,56(sp)
c0001b04:	04010413          	addi	s0,sp,64
c0001b08:	fca42623          	sw	a0,-52(s0)
c0001b0c:	fcb42423          	sw	a1,-56(s0)
c0001b10:	fcc42223          	sw	a2,-60(s0)
BaseType_t xReturn;
UBaseType_t uxSavedInterruptStatus;
Queue_t * const pxQueue = xQueue;
c0001b14:	fcc42783          	lw	a5,-52(s0)
c0001b18:	fef42423          	sw	a5,-24(s0)

	configASSERT( pxQueue );
c0001b1c:	fe842783          	lw	a5,-24(s0)
c0001b20:	00079863          	bnez	a5,c0001b30 <xQueueReceiveFromISR+0x38>
c0001b24:	30047073          	csrci	mstatus,8
c0001b28:	00100073          	ebreak
c0001b2c:	0000006f          	j	c0001b2c <xQueueReceiveFromISR+0x34>
	configASSERT( !( ( pvBuffer == NULL ) && ( pxQueue->uxItemSize != ( UBaseType_t ) 0U ) ) );
c0001b30:	fc842783          	lw	a5,-56(s0)
c0001b34:	00079863          	bnez	a5,c0001b44 <xQueueReceiveFromISR+0x4c>
c0001b38:	fe842783          	lw	a5,-24(s0)
c0001b3c:	0407a783          	lw	a5,64(a5)
c0001b40:	00079663          	bnez	a5,c0001b4c <xQueueReceiveFromISR+0x54>
c0001b44:	00100793          	li	a5,1
c0001b48:	0080006f          	j	c0001b50 <xQueueReceiveFromISR+0x58>
c0001b4c:	00000793          	li	a5,0
c0001b50:	00079863          	bnez	a5,c0001b60 <xQueueReceiveFromISR+0x68>
c0001b54:	30047073          	csrci	mstatus,8
c0001b58:	00100073          	ebreak
c0001b5c:	0000006f          	j	c0001b5c <xQueueReceiveFromISR+0x64>
	safe API to ensure interrupt entry is as fast and as simple as possible.
	More information (albeit Cortex-M specific) is provided on the following
	link: http://www.freertos.org/RTOS-Cortex-M3-M4.html */
	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
c0001b60:	fe042223          	sw	zero,-28(s0)
	{
		const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
c0001b64:	fe842783          	lw	a5,-24(s0)
c0001b68:	0387a783          	lw	a5,56(a5)
c0001b6c:	fef42023          	sw	a5,-32(s0)

		/* Cannot block in an ISR, so check there is data available. */
		if( uxMessagesWaiting > ( UBaseType_t ) 0 )
c0001b70:	fe042783          	lw	a5,-32(s0)
c0001b74:	08078e63          	beqz	a5,c0001c10 <xQueueReceiveFromISR+0x118>
		{
			const int8_t cRxLock = pxQueue->cRxLock;
c0001b78:	fe842783          	lw	a5,-24(s0)
c0001b7c:	0447c783          	lbu	a5,68(a5)
c0001b80:	fcf40fa3          	sb	a5,-33(s0)

			traceQUEUE_RECEIVE_FROM_ISR( pxQueue );

			prvCopyDataFromQueue( pxQueue, pvBuffer );
c0001b84:	fc842583          	lw	a1,-56(s0)
c0001b88:	fe842503          	lw	a0,-24(s0)
c0001b8c:	530000ef          	jal	ra,c00020bc <prvCopyDataFromQueue>
			pxQueue->uxMessagesWaiting = uxMessagesWaiting - ( UBaseType_t ) 1;
c0001b90:	fe042783          	lw	a5,-32(s0)
c0001b94:	fff78713          	addi	a4,a5,-1
c0001b98:	fe842783          	lw	a5,-24(s0)
c0001b9c:	02e7ac23          	sw	a4,56(a5)

			/* If the queue is locked the event list will not be modified.
			Instead update the lock count so the task that unlocks the queue
			will know that an ISR has removed data while the queue was
			locked. */
			if( cRxLock == queueUNLOCKED )
c0001ba0:	fdf40703          	lb	a4,-33(s0)
c0001ba4:	fff00793          	li	a5,-1
c0001ba8:	04f71063          	bne	a4,a5,c0001be8 <xQueueReceiveFromISR+0xf0>
			{
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
c0001bac:	fe842783          	lw	a5,-24(s0)
c0001bb0:	0107a783          	lw	a5,16(a5)
c0001bb4:	04078863          	beqz	a5,c0001c04 <xQueueReceiveFromISR+0x10c>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
c0001bb8:	fe842783          	lw	a5,-24(s0)
c0001bbc:	01078793          	addi	a5,a5,16
c0001bc0:	00078513          	mv	a0,a5
c0001bc4:	4e9020ef          	jal	ra,c00048ac <xTaskRemoveFromEventList>
c0001bc8:	00050793          	mv	a5,a0
c0001bcc:	02078c63          	beqz	a5,c0001c04 <xQueueReceiveFromISR+0x10c>
					{
						/* The task waiting has a higher priority than us so
						force a context switch. */
						if( pxHigherPriorityTaskWoken != NULL )
c0001bd0:	fc442783          	lw	a5,-60(s0)
c0001bd4:	02078863          	beqz	a5,c0001c04 <xQueueReceiveFromISR+0x10c>
						{
							*pxHigherPriorityTaskWoken = pdTRUE;
c0001bd8:	fc442783          	lw	a5,-60(s0)
c0001bdc:	00100713          	li	a4,1
c0001be0:	00e7a023          	sw	a4,0(a5)
c0001be4:	0200006f          	j	c0001c04 <xQueueReceiveFromISR+0x10c>
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was removed while it was locked. */
				pxQueue->cRxLock = ( int8_t ) ( cRxLock + 1 );
c0001be8:	fdf44783          	lbu	a5,-33(s0)
c0001bec:	00178793          	addi	a5,a5,1
c0001bf0:	0ff7f793          	andi	a5,a5,255
c0001bf4:	01879713          	slli	a4,a5,0x18
c0001bf8:	41875713          	srai	a4,a4,0x18
c0001bfc:	fe842783          	lw	a5,-24(s0)
c0001c00:	04e78223          	sb	a4,68(a5)
			}

			xReturn = pdPASS;
c0001c04:	00100793          	li	a5,1
c0001c08:	fef42623          	sw	a5,-20(s0)
c0001c0c:	0080006f          	j	c0001c14 <xQueueReceiveFromISR+0x11c>
		}
		else
		{
			xReturn = pdFAIL;
c0001c10:	fe042623          	sw	zero,-20(s0)
			traceQUEUE_RECEIVE_FROM_ISR_FAILED( pxQueue );
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
c0001c14:	fec42783          	lw	a5,-20(s0)
}
c0001c18:	00078513          	mv	a0,a5
c0001c1c:	03c12083          	lw	ra,60(sp)
c0001c20:	03812403          	lw	s0,56(sp)
c0001c24:	04010113          	addi	sp,sp,64
c0001c28:	00008067          	ret

c0001c2c <xQueuePeekFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xQueuePeekFromISR( QueueHandle_t xQueue,  void * const pvBuffer )
{
c0001c2c:	fd010113          	addi	sp,sp,-48
c0001c30:	02112623          	sw	ra,44(sp)
c0001c34:	02812423          	sw	s0,40(sp)
c0001c38:	03010413          	addi	s0,sp,48
c0001c3c:	fca42e23          	sw	a0,-36(s0)
c0001c40:	fcb42c23          	sw	a1,-40(s0)
BaseType_t xReturn;
UBaseType_t uxSavedInterruptStatus;
int8_t *pcOriginalReadPosition;
Queue_t * const pxQueue = xQueue;
c0001c44:	fdc42783          	lw	a5,-36(s0)
c0001c48:	fef42423          	sw	a5,-24(s0)

	configASSERT( pxQueue );
c0001c4c:	fe842783          	lw	a5,-24(s0)
c0001c50:	00079863          	bnez	a5,c0001c60 <xQueuePeekFromISR+0x34>
c0001c54:	30047073          	csrci	mstatus,8
c0001c58:	00100073          	ebreak
c0001c5c:	0000006f          	j	c0001c5c <xQueuePeekFromISR+0x30>
	configASSERT( !( ( pvBuffer == NULL ) && ( pxQueue->uxItemSize != ( UBaseType_t ) 0U ) ) );
c0001c60:	fd842783          	lw	a5,-40(s0)
c0001c64:	00079863          	bnez	a5,c0001c74 <xQueuePeekFromISR+0x48>
c0001c68:	fe842783          	lw	a5,-24(s0)
c0001c6c:	0407a783          	lw	a5,64(a5)
c0001c70:	00079663          	bnez	a5,c0001c7c <xQueuePeekFromISR+0x50>
c0001c74:	00100793          	li	a5,1
c0001c78:	0080006f          	j	c0001c80 <xQueuePeekFromISR+0x54>
c0001c7c:	00000793          	li	a5,0
c0001c80:	00079863          	bnez	a5,c0001c90 <xQueuePeekFromISR+0x64>
c0001c84:	30047073          	csrci	mstatus,8
c0001c88:	00100073          	ebreak
c0001c8c:	0000006f          	j	c0001c8c <xQueuePeekFromISR+0x60>
	configASSERT( pxQueue->uxItemSize != 0 ); /* Can't peek a semaphore. */
c0001c90:	fe842783          	lw	a5,-24(s0)
c0001c94:	0407a783          	lw	a5,64(a5)
c0001c98:	00079863          	bnez	a5,c0001ca8 <xQueuePeekFromISR+0x7c>
c0001c9c:	30047073          	csrci	mstatus,8
c0001ca0:	00100073          	ebreak
c0001ca4:	0000006f          	j	c0001ca4 <xQueuePeekFromISR+0x78>
	safe API to ensure interrupt entry is as fast and as simple as possible.
	More information (albeit Cortex-M specific) is provided on the following
	link: http://www.freertos.org/RTOS-Cortex-M3-M4.html */
	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
c0001ca8:	fe042223          	sw	zero,-28(s0)
	{
		/* Cannot block in an ISR, so check there is data available. */
		if( pxQueue->uxMessagesWaiting > ( UBaseType_t ) 0 )
c0001cac:	fe842783          	lw	a5,-24(s0)
c0001cb0:	0387a783          	lw	a5,56(a5)
c0001cb4:	02078a63          	beqz	a5,c0001ce8 <xQueuePeekFromISR+0xbc>
		{
			traceQUEUE_PEEK_FROM_ISR( pxQueue );

			/* Remember the read position so it can be reset as nothing is
			actually being removed from the queue. */
			pcOriginalReadPosition = pxQueue->u.xQueue.pcReadFrom;
c0001cb8:	fe842783          	lw	a5,-24(s0)
c0001cbc:	00c7a783          	lw	a5,12(a5)
c0001cc0:	fef42023          	sw	a5,-32(s0)
			prvCopyDataFromQueue( pxQueue, pvBuffer );
c0001cc4:	fd842583          	lw	a1,-40(s0)
c0001cc8:	fe842503          	lw	a0,-24(s0)
c0001ccc:	3f0000ef          	jal	ra,c00020bc <prvCopyDataFromQueue>
			pxQueue->u.xQueue.pcReadFrom = pcOriginalReadPosition;
c0001cd0:	fe842783          	lw	a5,-24(s0)
c0001cd4:	fe042703          	lw	a4,-32(s0)
c0001cd8:	00e7a623          	sw	a4,12(a5)

			xReturn = pdPASS;
c0001cdc:	00100793          	li	a5,1
c0001ce0:	fef42623          	sw	a5,-20(s0)
c0001ce4:	0080006f          	j	c0001cec <xQueuePeekFromISR+0xc0>
		}
		else
		{
			xReturn = pdFAIL;
c0001ce8:	fe042623          	sw	zero,-20(s0)
			traceQUEUE_PEEK_FROM_ISR_FAILED( pxQueue );
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
c0001cec:	fec42783          	lw	a5,-20(s0)
}
c0001cf0:	00078513          	mv	a0,a5
c0001cf4:	02c12083          	lw	ra,44(sp)
c0001cf8:	02812403          	lw	s0,40(sp)
c0001cfc:	03010113          	addi	sp,sp,48
c0001d00:	00008067          	ret

c0001d04 <uxQueueMessagesWaiting>:
/*-----------------------------------------------------------*/

UBaseType_t uxQueueMessagesWaiting( const QueueHandle_t xQueue )
{
c0001d04:	fd010113          	addi	sp,sp,-48
c0001d08:	02112623          	sw	ra,44(sp)
c0001d0c:	02812423          	sw	s0,40(sp)
c0001d10:	03010413          	addi	s0,sp,48
c0001d14:	fca42e23          	sw	a0,-36(s0)
UBaseType_t uxReturn;

	configASSERT( xQueue );
c0001d18:	fdc42783          	lw	a5,-36(s0)
c0001d1c:	00079863          	bnez	a5,c0001d2c <uxQueueMessagesWaiting+0x28>
c0001d20:	30047073          	csrci	mstatus,8
c0001d24:	00100073          	ebreak
c0001d28:	0000006f          	j	c0001d28 <uxQueueMessagesWaiting+0x24>

	taskENTER_CRITICAL();
c0001d2c:	415030ef          	jal	ra,c0005940 <vTaskEnterCritical>
	{
		uxReturn = ( ( Queue_t * ) xQueue )->uxMessagesWaiting;
c0001d30:	fdc42783          	lw	a5,-36(s0)
c0001d34:	0387a783          	lw	a5,56(a5)
c0001d38:	fef42623          	sw	a5,-20(s0)
	}
	taskEXIT_CRITICAL();
c0001d3c:	459030ef          	jal	ra,c0005994 <vTaskExitCritical>

	return uxReturn;
c0001d40:	fec42783          	lw	a5,-20(s0)
} /*lint !e818 Pointer cannot be declared const as xQueue is a typedef not pointer. */
c0001d44:	00078513          	mv	a0,a5
c0001d48:	02c12083          	lw	ra,44(sp)
c0001d4c:	02812403          	lw	s0,40(sp)
c0001d50:	03010113          	addi	sp,sp,48
c0001d54:	00008067          	ret

c0001d58 <uxQueueSpacesAvailable>:
/*-----------------------------------------------------------*/

UBaseType_t uxQueueSpacesAvailable( const QueueHandle_t xQueue )
{
c0001d58:	fd010113          	addi	sp,sp,-48
c0001d5c:	02112623          	sw	ra,44(sp)
c0001d60:	02812423          	sw	s0,40(sp)
c0001d64:	03010413          	addi	s0,sp,48
c0001d68:	fca42e23          	sw	a0,-36(s0)
UBaseType_t uxReturn;
Queue_t * const pxQueue = xQueue;
c0001d6c:	fdc42783          	lw	a5,-36(s0)
c0001d70:	fef42623          	sw	a5,-20(s0)

	configASSERT( pxQueue );
c0001d74:	fec42783          	lw	a5,-20(s0)
c0001d78:	00079863          	bnez	a5,c0001d88 <uxQueueSpacesAvailable+0x30>
c0001d7c:	30047073          	csrci	mstatus,8
c0001d80:	00100073          	ebreak
c0001d84:	0000006f          	j	c0001d84 <uxQueueSpacesAvailable+0x2c>

	taskENTER_CRITICAL();
c0001d88:	3b9030ef          	jal	ra,c0005940 <vTaskEnterCritical>
	{
		uxReturn = pxQueue->uxLength - pxQueue->uxMessagesWaiting;
c0001d8c:	fec42783          	lw	a5,-20(s0)
c0001d90:	03c7a703          	lw	a4,60(a5)
c0001d94:	fec42783          	lw	a5,-20(s0)
c0001d98:	0387a783          	lw	a5,56(a5)
c0001d9c:	40f707b3          	sub	a5,a4,a5
c0001da0:	fef42423          	sw	a5,-24(s0)
	}
	taskEXIT_CRITICAL();
c0001da4:	3f1030ef          	jal	ra,c0005994 <vTaskExitCritical>

	return uxReturn;
c0001da8:	fe842783          	lw	a5,-24(s0)
} /*lint !e818 Pointer cannot be declared const as xQueue is a typedef not pointer. */
c0001dac:	00078513          	mv	a0,a5
c0001db0:	02c12083          	lw	ra,44(sp)
c0001db4:	02812403          	lw	s0,40(sp)
c0001db8:	03010113          	addi	sp,sp,48
c0001dbc:	00008067          	ret

c0001dc0 <uxQueueMessagesWaitingFromISR>:
/*-----------------------------------------------------------*/

UBaseType_t uxQueueMessagesWaitingFromISR( const QueueHandle_t xQueue )
{
c0001dc0:	fd010113          	addi	sp,sp,-48
c0001dc4:	02812623          	sw	s0,44(sp)
c0001dc8:	03010413          	addi	s0,sp,48
c0001dcc:	fca42e23          	sw	a0,-36(s0)
UBaseType_t uxReturn;
Queue_t * const pxQueue = xQueue;
c0001dd0:	fdc42783          	lw	a5,-36(s0)
c0001dd4:	fef42623          	sw	a5,-20(s0)

	configASSERT( pxQueue );
c0001dd8:	fec42783          	lw	a5,-20(s0)
c0001ddc:	00079863          	bnez	a5,c0001dec <uxQueueMessagesWaitingFromISR+0x2c>
c0001de0:	30047073          	csrci	mstatus,8
c0001de4:	00100073          	ebreak
c0001de8:	0000006f          	j	c0001de8 <uxQueueMessagesWaitingFromISR+0x28>
	uxReturn = pxQueue->uxMessagesWaiting;
c0001dec:	fec42783          	lw	a5,-20(s0)
c0001df0:	0387a783          	lw	a5,56(a5)
c0001df4:	fef42423          	sw	a5,-24(s0)

	return uxReturn;
c0001df8:	fe842783          	lw	a5,-24(s0)
} /*lint !e818 Pointer cannot be declared const as xQueue is a typedef not pointer. */
c0001dfc:	00078513          	mv	a0,a5
c0001e00:	02c12403          	lw	s0,44(sp)
c0001e04:	03010113          	addi	sp,sp,48
c0001e08:	00008067          	ret

c0001e0c <vQueueDelete>:
/*-----------------------------------------------------------*/

void vQueueDelete( QueueHandle_t xQueue )
{
c0001e0c:	fd010113          	addi	sp,sp,-48
c0001e10:	02112623          	sw	ra,44(sp)
c0001e14:	02812423          	sw	s0,40(sp)
c0001e18:	03010413          	addi	s0,sp,48
c0001e1c:	fca42e23          	sw	a0,-36(s0)
Queue_t * const pxQueue = xQueue;
c0001e20:	fdc42783          	lw	a5,-36(s0)
c0001e24:	fef42623          	sw	a5,-20(s0)

	configASSERT( pxQueue );
c0001e28:	fec42783          	lw	a5,-20(s0)
c0001e2c:	00079863          	bnez	a5,c0001e3c <vQueueDelete+0x30>
c0001e30:	30047073          	csrci	mstatus,8
c0001e34:	00100073          	ebreak
c0001e38:	0000006f          	j	c0001e38 <vQueueDelete+0x2c>
	traceQUEUE_DELETE( pxQueue );

	#if ( configQUEUE_REGISTRY_SIZE > 0 )
	{
		vQueueUnregisterQueue( pxQueue );
c0001e3c:	fec42503          	lw	a0,-20(s0)
c0001e40:	6a4000ef          	jal	ra,c00024e4 <vQueueUnregisterQueue>

	#if( ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) && ( configSUPPORT_STATIC_ALLOCATION == 0 ) )
	{
		/* The queue can only have been allocated dynamically - free it
		again. */
		vPortFree( pxQueue );
c0001e44:	fec42503          	lw	a0,-20(s0)
c0001e48:	6f0070ef          	jal	ra,c0009538 <vPortFree>
		/* The queue must have been statically allocated, so is not going to be
		deleted.  Avoid compiler warnings about the unused parameter. */
		( void ) pxQueue;
	}
	#endif /* configSUPPORT_DYNAMIC_ALLOCATION */
}
c0001e4c:	00000013          	nop
c0001e50:	02c12083          	lw	ra,44(sp)
c0001e54:	02812403          	lw	s0,40(sp)
c0001e58:	03010113          	addi	sp,sp,48
c0001e5c:	00008067          	ret

c0001e60 <uxQueueGetQueueNumber>:
/*-----------------------------------------------------------*/

#if ( configUSE_TRACE_FACILITY == 1 )

	UBaseType_t uxQueueGetQueueNumber( QueueHandle_t xQueue )
	{
c0001e60:	fe010113          	addi	sp,sp,-32
c0001e64:	00812e23          	sw	s0,28(sp)
c0001e68:	02010413          	addi	s0,sp,32
c0001e6c:	fea42623          	sw	a0,-20(s0)
		return ( ( Queue_t * ) xQueue )->uxQueueNumber;
c0001e70:	fec42783          	lw	a5,-20(s0)
c0001e74:	0487a783          	lw	a5,72(a5)
	}
c0001e78:	00078513          	mv	a0,a5
c0001e7c:	01c12403          	lw	s0,28(sp)
c0001e80:	02010113          	addi	sp,sp,32
c0001e84:	00008067          	ret

c0001e88 <vQueueSetQueueNumber>:
/*-----------------------------------------------------------*/

#if ( configUSE_TRACE_FACILITY == 1 )

	void vQueueSetQueueNumber( QueueHandle_t xQueue, UBaseType_t uxQueueNumber )
	{
c0001e88:	fe010113          	addi	sp,sp,-32
c0001e8c:	00812e23          	sw	s0,28(sp)
c0001e90:	02010413          	addi	s0,sp,32
c0001e94:	fea42623          	sw	a0,-20(s0)
c0001e98:	feb42423          	sw	a1,-24(s0)
		( ( Queue_t * ) xQueue )->uxQueueNumber = uxQueueNumber;
c0001e9c:	fec42783          	lw	a5,-20(s0)
c0001ea0:	fe842703          	lw	a4,-24(s0)
c0001ea4:	04e7a423          	sw	a4,72(a5)
	}
c0001ea8:	00000013          	nop
c0001eac:	01c12403          	lw	s0,28(sp)
c0001eb0:	02010113          	addi	sp,sp,32
c0001eb4:	00008067          	ret

c0001eb8 <ucQueueGetQueueType>:
/*-----------------------------------------------------------*/

#if ( configUSE_TRACE_FACILITY == 1 )

	uint8_t ucQueueGetQueueType( QueueHandle_t xQueue )
	{
c0001eb8:	fe010113          	addi	sp,sp,-32
c0001ebc:	00812e23          	sw	s0,28(sp)
c0001ec0:	02010413          	addi	s0,sp,32
c0001ec4:	fea42623          	sw	a0,-20(s0)
		return ( ( Queue_t * ) xQueue )->ucQueueType;
c0001ec8:	fec42783          	lw	a5,-20(s0)
c0001ecc:	04c7c783          	lbu	a5,76(a5)
	}
c0001ed0:	00078513          	mv	a0,a5
c0001ed4:	01c12403          	lw	s0,28(sp)
c0001ed8:	02010113          	addi	sp,sp,32
c0001edc:	00008067          	ret

c0001ee0 <prvGetDisinheritPriorityAfterTimeout>:
/*-----------------------------------------------------------*/

#if( configUSE_MUTEXES == 1 )

	static UBaseType_t prvGetDisinheritPriorityAfterTimeout( const Queue_t * const pxQueue )
	{
c0001ee0:	fd010113          	addi	sp,sp,-48
c0001ee4:	02812623          	sw	s0,44(sp)
c0001ee8:	03010413          	addi	s0,sp,48
c0001eec:	fca42e23          	sw	a0,-36(s0)
		priority, but the waiting task times out, then the holder should
		disinherit the priority - but only down to the highest priority of any
		other tasks that are waiting for the same mutex.  For this purpose,
		return the priority of the highest priority task that is waiting for the
		mutex. */
		if( listCURRENT_LIST_LENGTH( &( pxQueue->xTasksWaitingToReceive ) ) > 0U )
c0001ef0:	fdc42783          	lw	a5,-36(s0)
c0001ef4:	0247a783          	lw	a5,36(a5)
c0001ef8:	02078063          	beqz	a5,c0001f18 <prvGetDisinheritPriorityAfterTimeout+0x38>
		{
			uxHighestPriorityOfWaitingTasks = ( UBaseType_t ) configMAX_PRIORITIES - ( UBaseType_t ) listGET_ITEM_VALUE_OF_HEAD_ENTRY( &( pxQueue->xTasksWaitingToReceive ) );
c0001efc:	fdc42783          	lw	a5,-36(s0)
c0001f00:	0307a783          	lw	a5,48(a5)
c0001f04:	0007a783          	lw	a5,0(a5)
c0001f08:	00500713          	li	a4,5
c0001f0c:	40f707b3          	sub	a5,a4,a5
c0001f10:	fef42623          	sw	a5,-20(s0)
c0001f14:	0080006f          	j	c0001f1c <prvGetDisinheritPriorityAfterTimeout+0x3c>
		}
		else
		{
			uxHighestPriorityOfWaitingTasks = tskIDLE_PRIORITY;
c0001f18:	fe042623          	sw	zero,-20(s0)
		}

		return uxHighestPriorityOfWaitingTasks;
c0001f1c:	fec42783          	lw	a5,-20(s0)
	}
c0001f20:	00078513          	mv	a0,a5
c0001f24:	02c12403          	lw	s0,44(sp)
c0001f28:	03010113          	addi	sp,sp,48
c0001f2c:	00008067          	ret

c0001f30 <prvCopyDataToQueue>:

#endif /* configUSE_MUTEXES */
/*-----------------------------------------------------------*/

static BaseType_t prvCopyDataToQueue( Queue_t * const pxQueue, const void *pvItemToQueue, const BaseType_t xPosition )
{
c0001f30:	fd010113          	addi	sp,sp,-48
c0001f34:	02112623          	sw	ra,44(sp)
c0001f38:	02812423          	sw	s0,40(sp)
c0001f3c:	03010413          	addi	s0,sp,48
c0001f40:	fca42e23          	sw	a0,-36(s0)
c0001f44:	fcb42c23          	sw	a1,-40(s0)
c0001f48:	fcc42a23          	sw	a2,-44(s0)
BaseType_t xReturn = pdFALSE;
c0001f4c:	fe042623          	sw	zero,-20(s0)
UBaseType_t uxMessagesWaiting;

	/* This function is called from a critical section. */

	uxMessagesWaiting = pxQueue->uxMessagesWaiting;
c0001f50:	fdc42783          	lw	a5,-36(s0)
c0001f54:	0387a783          	lw	a5,56(a5)
c0001f58:	fef42423          	sw	a5,-24(s0)

	if( pxQueue->uxItemSize == ( UBaseType_t ) 0 )
c0001f5c:	fdc42783          	lw	a5,-36(s0)
c0001f60:	0407a783          	lw	a5,64(a5)
c0001f64:	02079863          	bnez	a5,c0001f94 <prvCopyDataToQueue+0x64>
	{
		#if ( configUSE_MUTEXES == 1 )
		{
			if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
c0001f68:	fdc42783          	lw	a5,-36(s0)
c0001f6c:	0007a783          	lw	a5,0(a5)
c0001f70:	12079263          	bnez	a5,c0002094 <prvCopyDataToQueue+0x164>
			{
				/* The mutex is no longer being held. */
				xReturn = xTaskPriorityDisinherit( pxQueue->u.xSemaphore.xMutexHolder );
c0001f74:	fdc42783          	lw	a5,-36(s0)
c0001f78:	0087a783          	lw	a5,8(a5)
c0001f7c:	00078513          	mv	a0,a5
c0001f80:	638030ef          	jal	ra,c00055b8 <xTaskPriorityDisinherit>
c0001f84:	fea42623          	sw	a0,-20(s0)
				pxQueue->u.xSemaphore.xMutexHolder = NULL;
c0001f88:	fdc42783          	lw	a5,-36(s0)
c0001f8c:	0007a423          	sw	zero,8(a5)
c0001f90:	1040006f          	j	c0002094 <prvCopyDataToQueue+0x164>
				mtCOVERAGE_TEST_MARKER();
			}
		}
		#endif /* configUSE_MUTEXES */
	}
	else if( xPosition == queueSEND_TO_BACK )
c0001f94:	fd442783          	lw	a5,-44(s0)
c0001f98:	06079463          	bnez	a5,c0002000 <prvCopyDataToQueue+0xd0>
	{
		( void ) memcpy( ( void * ) pxQueue->pcWriteTo, pvItemToQueue, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e418 !e9087 MISRA exception as the casts are only redundant for some ports, plus previous logic ensures a null pointer can only be passed to memcpy() if the copy size is 0.  Cast to void required by function signature and safe as no alignment requirement and copy length specified in bytes. */
c0001f9c:	fdc42783          	lw	a5,-36(s0)
c0001fa0:	0047a703          	lw	a4,4(a5)
c0001fa4:	fdc42783          	lw	a5,-36(s0)
c0001fa8:	0407a783          	lw	a5,64(a5)
c0001fac:	00078613          	mv	a2,a5
c0001fb0:	fd842583          	lw	a1,-40(s0)
c0001fb4:	00070513          	mv	a0,a4
c0001fb8:	3a91b0ef          	jal	ra,c001db60 <memcpy>
		pxQueue->pcWriteTo += pxQueue->uxItemSize; /*lint !e9016 Pointer arithmetic on char types ok, especially in this use case where it is the clearest way of conveying intent. */
c0001fbc:	fdc42783          	lw	a5,-36(s0)
c0001fc0:	0047a703          	lw	a4,4(a5)
c0001fc4:	fdc42783          	lw	a5,-36(s0)
c0001fc8:	0407a783          	lw	a5,64(a5)
c0001fcc:	00f70733          	add	a4,a4,a5
c0001fd0:	fdc42783          	lw	a5,-36(s0)
c0001fd4:	00e7a223          	sw	a4,4(a5)
		if( pxQueue->pcWriteTo >= pxQueue->u.xQueue.pcTail ) /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
c0001fd8:	fdc42783          	lw	a5,-36(s0)
c0001fdc:	0047a703          	lw	a4,4(a5)
c0001fe0:	fdc42783          	lw	a5,-36(s0)
c0001fe4:	0087a783          	lw	a5,8(a5)
c0001fe8:	0af76663          	bltu	a4,a5,c0002094 <prvCopyDataToQueue+0x164>
		{
			pxQueue->pcWriteTo = pxQueue->pcHead;
c0001fec:	fdc42783          	lw	a5,-36(s0)
c0001ff0:	0007a703          	lw	a4,0(a5)
c0001ff4:	fdc42783          	lw	a5,-36(s0)
c0001ff8:	00e7a223          	sw	a4,4(a5)
c0001ffc:	0980006f          	j	c0002094 <prvCopyDataToQueue+0x164>
			mtCOVERAGE_TEST_MARKER();
		}
	}
	else
	{
		( void ) memcpy( ( void * ) pxQueue->u.xQueue.pcReadFrom, pvItemToQueue, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e9087 !e418 MISRA exception as the casts are only redundant for some ports.  Cast to void required by function signature and safe as no alignment requirement and copy length specified in bytes.  Assert checks null pointer only used when length is 0. */
c0002000:	fdc42783          	lw	a5,-36(s0)
c0002004:	00c7a703          	lw	a4,12(a5)
c0002008:	fdc42783          	lw	a5,-36(s0)
c000200c:	0407a783          	lw	a5,64(a5)
c0002010:	00078613          	mv	a2,a5
c0002014:	fd842583          	lw	a1,-40(s0)
c0002018:	00070513          	mv	a0,a4
c000201c:	3451b0ef          	jal	ra,c001db60 <memcpy>
		pxQueue->u.xQueue.pcReadFrom -= pxQueue->uxItemSize;
c0002020:	fdc42783          	lw	a5,-36(s0)
c0002024:	00c7a703          	lw	a4,12(a5)
c0002028:	fdc42783          	lw	a5,-36(s0)
c000202c:	0407a783          	lw	a5,64(a5)
c0002030:	40f007b3          	neg	a5,a5
c0002034:	00f70733          	add	a4,a4,a5
c0002038:	fdc42783          	lw	a5,-36(s0)
c000203c:	00e7a623          	sw	a4,12(a5)
		if( pxQueue->u.xQueue.pcReadFrom < pxQueue->pcHead ) /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
c0002040:	fdc42783          	lw	a5,-36(s0)
c0002044:	00c7a703          	lw	a4,12(a5)
c0002048:	fdc42783          	lw	a5,-36(s0)
c000204c:	0007a783          	lw	a5,0(a5)
c0002050:	02f77263          	bgeu	a4,a5,c0002074 <prvCopyDataToQueue+0x144>
		{
			pxQueue->u.xQueue.pcReadFrom = ( pxQueue->u.xQueue.pcTail - pxQueue->uxItemSize );
c0002054:	fdc42783          	lw	a5,-36(s0)
c0002058:	0087a703          	lw	a4,8(a5)
c000205c:	fdc42783          	lw	a5,-36(s0)
c0002060:	0407a783          	lw	a5,64(a5)
c0002064:	40f007b3          	neg	a5,a5
c0002068:	00f70733          	add	a4,a4,a5
c000206c:	fdc42783          	lw	a5,-36(s0)
c0002070:	00e7a623          	sw	a4,12(a5)
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}

		if( xPosition == queueOVERWRITE )
c0002074:	fd442703          	lw	a4,-44(s0)
c0002078:	00200793          	li	a5,2
c000207c:	00f71c63          	bne	a4,a5,c0002094 <prvCopyDataToQueue+0x164>
		{
			if( uxMessagesWaiting > ( UBaseType_t ) 0 )
c0002080:	fe842783          	lw	a5,-24(s0)
c0002084:	00078863          	beqz	a5,c0002094 <prvCopyDataToQueue+0x164>
			{
				/* An item is not being added but overwritten, so subtract
				one from the recorded number of items in the queue so when
				one is added again below the number of recorded items remains
				correct. */
				--uxMessagesWaiting;
c0002088:	fe842783          	lw	a5,-24(s0)
c000208c:	fff78793          	addi	a5,a5,-1
c0002090:	fef42423          	sw	a5,-24(s0)
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}

	pxQueue->uxMessagesWaiting = uxMessagesWaiting + ( UBaseType_t ) 1;
c0002094:	fe842783          	lw	a5,-24(s0)
c0002098:	00178713          	addi	a4,a5,1
c000209c:	fdc42783          	lw	a5,-36(s0)
c00020a0:	02e7ac23          	sw	a4,56(a5)

	return xReturn;
c00020a4:	fec42783          	lw	a5,-20(s0)
}
c00020a8:	00078513          	mv	a0,a5
c00020ac:	02c12083          	lw	ra,44(sp)
c00020b0:	02812403          	lw	s0,40(sp)
c00020b4:	03010113          	addi	sp,sp,48
c00020b8:	00008067          	ret

c00020bc <prvCopyDataFromQueue>:
/*-----------------------------------------------------------*/

static void prvCopyDataFromQueue( Queue_t * const pxQueue, void * const pvBuffer )
{
c00020bc:	fe010113          	addi	sp,sp,-32
c00020c0:	00112e23          	sw	ra,28(sp)
c00020c4:	00812c23          	sw	s0,24(sp)
c00020c8:	02010413          	addi	s0,sp,32
c00020cc:	fea42623          	sw	a0,-20(s0)
c00020d0:	feb42423          	sw	a1,-24(s0)
	if( pxQueue->uxItemSize != ( UBaseType_t ) 0 )
c00020d4:	fec42783          	lw	a5,-20(s0)
c00020d8:	0407a783          	lw	a5,64(a5)
c00020dc:	06078263          	beqz	a5,c0002140 <prvCopyDataFromQueue+0x84>
	{
		pxQueue->u.xQueue.pcReadFrom += pxQueue->uxItemSize; /*lint !e9016 Pointer arithmetic on char types ok, especially in this use case where it is the clearest way of conveying intent. */
c00020e0:	fec42783          	lw	a5,-20(s0)
c00020e4:	00c7a703          	lw	a4,12(a5)
c00020e8:	fec42783          	lw	a5,-20(s0)
c00020ec:	0407a783          	lw	a5,64(a5)
c00020f0:	00f70733          	add	a4,a4,a5
c00020f4:	fec42783          	lw	a5,-20(s0)
c00020f8:	00e7a623          	sw	a4,12(a5)
		if( pxQueue->u.xQueue.pcReadFrom >= pxQueue->u.xQueue.pcTail ) /*lint !e946 MISRA exception justified as use of the relational operator is the cleanest solutions. */
c00020fc:	fec42783          	lw	a5,-20(s0)
c0002100:	00c7a703          	lw	a4,12(a5)
c0002104:	fec42783          	lw	a5,-20(s0)
c0002108:	0087a783          	lw	a5,8(a5)
c000210c:	00f76a63          	bltu	a4,a5,c0002120 <prvCopyDataFromQueue+0x64>
		{
			pxQueue->u.xQueue.pcReadFrom = pxQueue->pcHead;
c0002110:	fec42783          	lw	a5,-20(s0)
c0002114:	0007a703          	lw	a4,0(a5)
c0002118:	fec42783          	lw	a5,-20(s0)
c000211c:	00e7a623          	sw	a4,12(a5)
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
		( void ) memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->u.xQueue.pcReadFrom, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e418 !e9087 MISRA exception as the casts are only redundant for some ports.  Also previous logic ensures a null pointer can only be passed to memcpy() when the count is 0.  Cast to void required by function signature and safe as no alignment requirement and copy length specified in bytes. */
c0002120:	fec42783          	lw	a5,-20(s0)
c0002124:	00c7a703          	lw	a4,12(a5)
c0002128:	fec42783          	lw	a5,-20(s0)
c000212c:	0407a783          	lw	a5,64(a5)
c0002130:	00078613          	mv	a2,a5
c0002134:	00070593          	mv	a1,a4
c0002138:	fe842503          	lw	a0,-24(s0)
c000213c:	2251b0ef          	jal	ra,c001db60 <memcpy>
	}
}
c0002140:	00000013          	nop
c0002144:	01c12083          	lw	ra,28(sp)
c0002148:	01812403          	lw	s0,24(sp)
c000214c:	02010113          	addi	sp,sp,32
c0002150:	00008067          	ret

c0002154 <prvUnlockQueue>:
/*-----------------------------------------------------------*/

static void prvUnlockQueue( Queue_t * const pxQueue )
{
c0002154:	fd010113          	addi	sp,sp,-48
c0002158:	02112623          	sw	ra,44(sp)
c000215c:	02812423          	sw	s0,40(sp)
c0002160:	03010413          	addi	s0,sp,48
c0002164:	fca42e23          	sw	a0,-36(s0)

	/* The lock counts contains the number of extra data items placed or
	removed from the queue while the queue was locked.  When a queue is
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
c0002168:	7d8030ef          	jal	ra,c0005940 <vTaskEnterCritical>
	{
		int8_t cTxLock = pxQueue->cTxLock;
c000216c:	fdc42783          	lw	a5,-36(s0)
c0002170:	0457c783          	lbu	a5,69(a5)
c0002174:	fef407a3          	sb	a5,-17(s0)

		/* See if data was added to the queue while it was locked. */
		while( cTxLock > queueLOCKED_UNMODIFIED )
c0002178:	03c0006f          	j	c00021b4 <prvUnlockQueue+0x60>
			}
			#else /* configUSE_QUEUE_SETS */
			{
				/* Tasks that are removed from the event list will get added to
				the pending ready list as the scheduler is still suspended. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
c000217c:	fdc42783          	lw	a5,-36(s0)
c0002180:	0247a783          	lw	a5,36(a5)
c0002184:	02078e63          	beqz	a5,c00021c0 <prvUnlockQueue+0x6c>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
c0002188:	fdc42783          	lw	a5,-36(s0)
c000218c:	02478793          	addi	a5,a5,36
c0002190:	00078513          	mv	a0,a5
c0002194:	718020ef          	jal	ra,c00048ac <xTaskRemoveFromEventList>
c0002198:	00050793          	mv	a5,a0
c000219c:	00078463          	beqz	a5,c00021a4 <prvUnlockQueue+0x50>
					{
						/* The task waiting has a higher priority so record that
						a context switch is required. */
						vTaskMissedYield();
c00021a0:	369020ef          	jal	ra,c0004d08 <vTaskMissedYield>
					break;
				}
			}
			#endif /* configUSE_QUEUE_SETS */

			--cTxLock;
c00021a4:	fef44783          	lbu	a5,-17(s0)
c00021a8:	fff78793          	addi	a5,a5,-1
c00021ac:	0ff7f793          	andi	a5,a5,255
c00021b0:	fef407a3          	sb	a5,-17(s0)
		while( cTxLock > queueLOCKED_UNMODIFIED )
c00021b4:	fef40783          	lb	a5,-17(s0)
c00021b8:	fcf042e3          	bgtz	a5,c000217c <prvUnlockQueue+0x28>
c00021bc:	0080006f          	j	c00021c4 <prvUnlockQueue+0x70>
					break;
c00021c0:	00000013          	nop
		}

		pxQueue->cTxLock = queueUNLOCKED;
c00021c4:	fdc42783          	lw	a5,-36(s0)
c00021c8:	fff00713          	li	a4,-1
c00021cc:	04e782a3          	sb	a4,69(a5)
	}
	taskEXIT_CRITICAL();
c00021d0:	7c4030ef          	jal	ra,c0005994 <vTaskExitCritical>

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
c00021d4:	76c030ef          	jal	ra,c0005940 <vTaskEnterCritical>
	{
		int8_t cRxLock = pxQueue->cRxLock;
c00021d8:	fdc42783          	lw	a5,-36(s0)
c00021dc:	0447c783          	lbu	a5,68(a5)
c00021e0:	fef40723          	sb	a5,-18(s0)

		while( cRxLock > queueLOCKED_UNMODIFIED )
c00021e4:	03c0006f          	j	c0002220 <prvUnlockQueue+0xcc>
		{
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
c00021e8:	fdc42783          	lw	a5,-36(s0)
c00021ec:	0107a783          	lw	a5,16(a5)
c00021f0:	02078e63          	beqz	a5,c000222c <prvUnlockQueue+0xd8>
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
c00021f4:	fdc42783          	lw	a5,-36(s0)
c00021f8:	01078793          	addi	a5,a5,16
c00021fc:	00078513          	mv	a0,a5
c0002200:	6ac020ef          	jal	ra,c00048ac <xTaskRemoveFromEventList>
c0002204:	00050793          	mv	a5,a0
c0002208:	00078463          	beqz	a5,c0002210 <prvUnlockQueue+0xbc>
				{
					vTaskMissedYield();
c000220c:	2fd020ef          	jal	ra,c0004d08 <vTaskMissedYield>
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}

				--cRxLock;
c0002210:	fee44783          	lbu	a5,-18(s0)
c0002214:	fff78793          	addi	a5,a5,-1
c0002218:	0ff7f793          	andi	a5,a5,255
c000221c:	fef40723          	sb	a5,-18(s0)
		while( cRxLock > queueLOCKED_UNMODIFIED )
c0002220:	fee40783          	lb	a5,-18(s0)
c0002224:	fcf042e3          	bgtz	a5,c00021e8 <prvUnlockQueue+0x94>
c0002228:	0080006f          	j	c0002230 <prvUnlockQueue+0xdc>
			}
			else
			{
				break;
c000222c:	00000013          	nop
			}
		}

		pxQueue->cRxLock = queueUNLOCKED;
c0002230:	fdc42783          	lw	a5,-36(s0)
c0002234:	fff00713          	li	a4,-1
c0002238:	04e78223          	sb	a4,68(a5)
	}
	taskEXIT_CRITICAL();
c000223c:	758030ef          	jal	ra,c0005994 <vTaskExitCritical>
}
c0002240:	00000013          	nop
c0002244:	02c12083          	lw	ra,44(sp)
c0002248:	02812403          	lw	s0,40(sp)
c000224c:	03010113          	addi	sp,sp,48
c0002250:	00008067          	ret

c0002254 <prvIsQueueEmpty>:
/*-----------------------------------------------------------*/

static BaseType_t prvIsQueueEmpty( const Queue_t *pxQueue )
{
c0002254:	fd010113          	addi	sp,sp,-48
c0002258:	02112623          	sw	ra,44(sp)
c000225c:	02812423          	sw	s0,40(sp)
c0002260:	03010413          	addi	s0,sp,48
c0002264:	fca42e23          	sw	a0,-36(s0)
BaseType_t xReturn;

	taskENTER_CRITICAL();
c0002268:	6d8030ef          	jal	ra,c0005940 <vTaskEnterCritical>
	{
		if( pxQueue->uxMessagesWaiting == ( UBaseType_t )  0 )
c000226c:	fdc42783          	lw	a5,-36(s0)
c0002270:	0387a783          	lw	a5,56(a5)
c0002274:	00079863          	bnez	a5,c0002284 <prvIsQueueEmpty+0x30>
		{
			xReturn = pdTRUE;
c0002278:	00100793          	li	a5,1
c000227c:	fef42623          	sw	a5,-20(s0)
c0002280:	0080006f          	j	c0002288 <prvIsQueueEmpty+0x34>
		}
		else
		{
			xReturn = pdFALSE;
c0002284:	fe042623          	sw	zero,-20(s0)
		}
	}
	taskEXIT_CRITICAL();
c0002288:	70c030ef          	jal	ra,c0005994 <vTaskExitCritical>

	return xReturn;
c000228c:	fec42783          	lw	a5,-20(s0)
}
c0002290:	00078513          	mv	a0,a5
c0002294:	02c12083          	lw	ra,44(sp)
c0002298:	02812403          	lw	s0,40(sp)
c000229c:	03010113          	addi	sp,sp,48
c00022a0:	00008067          	ret

c00022a4 <xQueueIsQueueEmptyFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xQueueIsQueueEmptyFromISR( const QueueHandle_t xQueue )
{
c00022a4:	fd010113          	addi	sp,sp,-48
c00022a8:	02812623          	sw	s0,44(sp)
c00022ac:	03010413          	addi	s0,sp,48
c00022b0:	fca42e23          	sw	a0,-36(s0)
BaseType_t xReturn;
Queue_t * const pxQueue = xQueue;
c00022b4:	fdc42783          	lw	a5,-36(s0)
c00022b8:	fef42423          	sw	a5,-24(s0)

	configASSERT( pxQueue );
c00022bc:	fe842783          	lw	a5,-24(s0)
c00022c0:	00079863          	bnez	a5,c00022d0 <xQueueIsQueueEmptyFromISR+0x2c>
c00022c4:	30047073          	csrci	mstatus,8
c00022c8:	00100073          	ebreak
c00022cc:	0000006f          	j	c00022cc <xQueueIsQueueEmptyFromISR+0x28>
	if( pxQueue->uxMessagesWaiting == ( UBaseType_t ) 0 )
c00022d0:	fe842783          	lw	a5,-24(s0)
c00022d4:	0387a783          	lw	a5,56(a5)
c00022d8:	00079863          	bnez	a5,c00022e8 <xQueueIsQueueEmptyFromISR+0x44>
	{
		xReturn = pdTRUE;
c00022dc:	00100793          	li	a5,1
c00022e0:	fef42623          	sw	a5,-20(s0)
c00022e4:	0080006f          	j	c00022ec <xQueueIsQueueEmptyFromISR+0x48>
	}
	else
	{
		xReturn = pdFALSE;
c00022e8:	fe042623          	sw	zero,-20(s0)
	}

	return xReturn;
c00022ec:	fec42783          	lw	a5,-20(s0)
} /*lint !e818 xQueue could not be pointer to const because it is a typedef. */
c00022f0:	00078513          	mv	a0,a5
c00022f4:	02c12403          	lw	s0,44(sp)
c00022f8:	03010113          	addi	sp,sp,48
c00022fc:	00008067          	ret

c0002300 <prvIsQueueFull>:
/*-----------------------------------------------------------*/

static BaseType_t prvIsQueueFull( const Queue_t *pxQueue )
{
c0002300:	fd010113          	addi	sp,sp,-48
c0002304:	02112623          	sw	ra,44(sp)
c0002308:	02812423          	sw	s0,40(sp)
c000230c:	03010413          	addi	s0,sp,48
c0002310:	fca42e23          	sw	a0,-36(s0)
BaseType_t xReturn;

	taskENTER_CRITICAL();
c0002314:	62c030ef          	jal	ra,c0005940 <vTaskEnterCritical>
	{
		if( pxQueue->uxMessagesWaiting == pxQueue->uxLength )
c0002318:	fdc42783          	lw	a5,-36(s0)
c000231c:	0387a703          	lw	a4,56(a5)
c0002320:	fdc42783          	lw	a5,-36(s0)
c0002324:	03c7a783          	lw	a5,60(a5)
c0002328:	00f71863          	bne	a4,a5,c0002338 <prvIsQueueFull+0x38>
		{
			xReturn = pdTRUE;
c000232c:	00100793          	li	a5,1
c0002330:	fef42623          	sw	a5,-20(s0)
c0002334:	0080006f          	j	c000233c <prvIsQueueFull+0x3c>
		}
		else
		{
			xReturn = pdFALSE;
c0002338:	fe042623          	sw	zero,-20(s0)
		}
	}
	taskEXIT_CRITICAL();
c000233c:	658030ef          	jal	ra,c0005994 <vTaskExitCritical>

	return xReturn;
c0002340:	fec42783          	lw	a5,-20(s0)
}
c0002344:	00078513          	mv	a0,a5
c0002348:	02c12083          	lw	ra,44(sp)
c000234c:	02812403          	lw	s0,40(sp)
c0002350:	03010113          	addi	sp,sp,48
c0002354:	00008067          	ret

c0002358 <xQueueIsQueueFullFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xQueueIsQueueFullFromISR( const QueueHandle_t xQueue )
{
c0002358:	fd010113          	addi	sp,sp,-48
c000235c:	02812623          	sw	s0,44(sp)
c0002360:	03010413          	addi	s0,sp,48
c0002364:	fca42e23          	sw	a0,-36(s0)
BaseType_t xReturn;
Queue_t * const pxQueue = xQueue;
c0002368:	fdc42783          	lw	a5,-36(s0)
c000236c:	fef42423          	sw	a5,-24(s0)

	configASSERT( pxQueue );
c0002370:	fe842783          	lw	a5,-24(s0)
c0002374:	00079863          	bnez	a5,c0002384 <xQueueIsQueueFullFromISR+0x2c>
c0002378:	30047073          	csrci	mstatus,8
c000237c:	00100073          	ebreak
c0002380:	0000006f          	j	c0002380 <xQueueIsQueueFullFromISR+0x28>
	if( pxQueue->uxMessagesWaiting == pxQueue->uxLength )
c0002384:	fe842783          	lw	a5,-24(s0)
c0002388:	0387a703          	lw	a4,56(a5)
c000238c:	fe842783          	lw	a5,-24(s0)
c0002390:	03c7a783          	lw	a5,60(a5)
c0002394:	00f71863          	bne	a4,a5,c00023a4 <xQueueIsQueueFullFromISR+0x4c>
	{
		xReturn = pdTRUE;
c0002398:	00100793          	li	a5,1
c000239c:	fef42623          	sw	a5,-20(s0)
c00023a0:	0080006f          	j	c00023a8 <xQueueIsQueueFullFromISR+0x50>
	}
	else
	{
		xReturn = pdFALSE;
c00023a4:	fe042623          	sw	zero,-20(s0)
	}

	return xReturn;
c00023a8:	fec42783          	lw	a5,-20(s0)
} /*lint !e818 xQueue could not be pointer to const because it is a typedef. */
c00023ac:	00078513          	mv	a0,a5
c00023b0:	02c12403          	lw	s0,44(sp)
c00023b4:	03010113          	addi	sp,sp,48
c00023b8:	00008067          	ret

c00023bc <vQueueAddToRegistry>:
/*-----------------------------------------------------------*/

#if ( configQUEUE_REGISTRY_SIZE > 0 )

	void vQueueAddToRegistry( QueueHandle_t xQueue, const char *pcQueueName ) /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
	{
c00023bc:	fd010113          	addi	sp,sp,-48
c00023c0:	02812623          	sw	s0,44(sp)
c00023c4:	03010413          	addi	s0,sp,48
c00023c8:	fca42e23          	sw	a0,-36(s0)
c00023cc:	fcb42c23          	sw	a1,-40(s0)
	UBaseType_t ux;

		/* See if there is an empty space in the registry.  A NULL name denotes
		a free slot. */
		for( ux = ( UBaseType_t ) 0U; ux < ( UBaseType_t ) configQUEUE_REGISTRY_SIZE; ux++ )
c00023d0:	fe042623          	sw	zero,-20(s0)
c00023d4:	0680006f          	j	c000243c <vQueueAddToRegistry+0x80>
		{
			if( xQueueRegistry[ ux ].pcQueueName == NULL )
c00023d8:	08001717          	auipc	a4,0x8001
c00023dc:	13070713          	addi	a4,a4,304 # c8003508 <xQueueRegistry>
c00023e0:	fec42783          	lw	a5,-20(s0)
c00023e4:	00379793          	slli	a5,a5,0x3
c00023e8:	00f707b3          	add	a5,a4,a5
c00023ec:	0007a783          	lw	a5,0(a5)
c00023f0:	04079063          	bnez	a5,c0002430 <vQueueAddToRegistry+0x74>
			{
				/* Store the information on this queue. */
				xQueueRegistry[ ux ].pcQueueName = pcQueueName;
c00023f4:	08001717          	auipc	a4,0x8001
c00023f8:	11470713          	addi	a4,a4,276 # c8003508 <xQueueRegistry>
c00023fc:	fec42783          	lw	a5,-20(s0)
c0002400:	00379793          	slli	a5,a5,0x3
c0002404:	00f707b3          	add	a5,a4,a5
c0002408:	fd842703          	lw	a4,-40(s0)
c000240c:	00e7a023          	sw	a4,0(a5)
				xQueueRegistry[ ux ].xHandle = xQueue;
c0002410:	08001717          	auipc	a4,0x8001
c0002414:	0f870713          	addi	a4,a4,248 # c8003508 <xQueueRegistry>
c0002418:	fec42783          	lw	a5,-20(s0)
c000241c:	00379793          	slli	a5,a5,0x3
c0002420:	00f707b3          	add	a5,a4,a5
c0002424:	fdc42703          	lw	a4,-36(s0)
c0002428:	00e7a223          	sw	a4,4(a5)

				traceQUEUE_REGISTRY_ADD( xQueue, pcQueueName );
				break;
c000242c:	0200006f          	j	c000244c <vQueueAddToRegistry+0x90>
		for( ux = ( UBaseType_t ) 0U; ux < ( UBaseType_t ) configQUEUE_REGISTRY_SIZE; ux++ )
c0002430:	fec42783          	lw	a5,-20(s0)
c0002434:	00178793          	addi	a5,a5,1
c0002438:	fef42623          	sw	a5,-20(s0)
c000243c:	fec42703          	lw	a4,-20(s0)
c0002440:	00700793          	li	a5,7
c0002444:	f8e7fae3          	bgeu	a5,a4,c00023d8 <vQueueAddToRegistry+0x1c>
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
	}
c0002448:	00000013          	nop
c000244c:	00000013          	nop
c0002450:	02c12403          	lw	s0,44(sp)
c0002454:	03010113          	addi	sp,sp,48
c0002458:	00008067          	ret

c000245c <pcQueueGetName>:
/*-----------------------------------------------------------*/

#if ( configQUEUE_REGISTRY_SIZE > 0 )

	const char *pcQueueGetName( QueueHandle_t xQueue ) /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
	{
c000245c:	fd010113          	addi	sp,sp,-48
c0002460:	02812623          	sw	s0,44(sp)
c0002464:	03010413          	addi	s0,sp,48
c0002468:	fca42e23          	sw	a0,-36(s0)
	UBaseType_t ux;
	const char *pcReturn = NULL; /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
c000246c:	fe042423          	sw	zero,-24(s0)

		/* Note there is nothing here to protect against another task adding or
		removing entries from the registry while it is being searched. */
		for( ux = ( UBaseType_t ) 0U; ux < ( UBaseType_t ) configQUEUE_REGISTRY_SIZE; ux++ )
c0002470:	fe042623          	sw	zero,-20(s0)
c0002474:	0500006f          	j	c00024c4 <pcQueueGetName+0x68>
		{
			if( xQueueRegistry[ ux ].xHandle == xQueue )
c0002478:	08001717          	auipc	a4,0x8001
c000247c:	09070713          	addi	a4,a4,144 # c8003508 <xQueueRegistry>
c0002480:	fec42783          	lw	a5,-20(s0)
c0002484:	00379793          	slli	a5,a5,0x3
c0002488:	00f707b3          	add	a5,a4,a5
c000248c:	0047a783          	lw	a5,4(a5)
c0002490:	fdc42703          	lw	a4,-36(s0)
c0002494:	02f71263          	bne	a4,a5,c00024b8 <pcQueueGetName+0x5c>
			{
				pcReturn = xQueueRegistry[ ux ].pcQueueName;
c0002498:	08001717          	auipc	a4,0x8001
c000249c:	07070713          	addi	a4,a4,112 # c8003508 <xQueueRegistry>
c00024a0:	fec42783          	lw	a5,-20(s0)
c00024a4:	00379793          	slli	a5,a5,0x3
c00024a8:	00f707b3          	add	a5,a4,a5
c00024ac:	0007a783          	lw	a5,0(a5)
c00024b0:	fef42423          	sw	a5,-24(s0)
				break;
c00024b4:	01c0006f          	j	c00024d0 <pcQueueGetName+0x74>
		for( ux = ( UBaseType_t ) 0U; ux < ( UBaseType_t ) configQUEUE_REGISTRY_SIZE; ux++ )
c00024b8:	fec42783          	lw	a5,-20(s0)
c00024bc:	00178793          	addi	a5,a5,1
c00024c0:	fef42623          	sw	a5,-20(s0)
c00024c4:	fec42703          	lw	a4,-20(s0)
c00024c8:	00700793          	li	a5,7
c00024cc:	fae7f6e3          	bgeu	a5,a4,c0002478 <pcQueueGetName+0x1c>
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}

		return pcReturn;
c00024d0:	fe842783          	lw	a5,-24(s0)
	} /*lint !e818 xQueue cannot be a pointer to const because it is a typedef. */
c00024d4:	00078513          	mv	a0,a5
c00024d8:	02c12403          	lw	s0,44(sp)
c00024dc:	03010113          	addi	sp,sp,48
c00024e0:	00008067          	ret

c00024e4 <vQueueUnregisterQueue>:
/*-----------------------------------------------------------*/

#if ( configQUEUE_REGISTRY_SIZE > 0 )

	void vQueueUnregisterQueue( QueueHandle_t xQueue )
	{
c00024e4:	fd010113          	addi	sp,sp,-48
c00024e8:	02812623          	sw	s0,44(sp)
c00024ec:	03010413          	addi	s0,sp,48
c00024f0:	fca42e23          	sw	a0,-36(s0)
	UBaseType_t ux;

		/* See if the handle of the queue being unregistered in actually in the
		registry. */
		for( ux = ( UBaseType_t ) 0U; ux < ( UBaseType_t ) configQUEUE_REGISTRY_SIZE; ux++ )
c00024f4:	fe042623          	sw	zero,-20(s0)
c00024f8:	0640006f          	j	c000255c <vQueueUnregisterQueue+0x78>
		{
			if( xQueueRegistry[ ux ].xHandle == xQueue )
c00024fc:	08001717          	auipc	a4,0x8001
c0002500:	00c70713          	addi	a4,a4,12 # c8003508 <xQueueRegistry>
c0002504:	fec42783          	lw	a5,-20(s0)
c0002508:	00379793          	slli	a5,a5,0x3
c000250c:	00f707b3          	add	a5,a4,a5
c0002510:	0047a783          	lw	a5,4(a5)
c0002514:	fdc42703          	lw	a4,-36(s0)
c0002518:	02f71c63          	bne	a4,a5,c0002550 <vQueueUnregisterQueue+0x6c>
			{
				/* Set the name to NULL to show that this slot if free again. */
				xQueueRegistry[ ux ].pcQueueName = NULL;
c000251c:	08001717          	auipc	a4,0x8001
c0002520:	fec70713          	addi	a4,a4,-20 # c8003508 <xQueueRegistry>
c0002524:	fec42783          	lw	a5,-20(s0)
c0002528:	00379793          	slli	a5,a5,0x3
c000252c:	00f707b3          	add	a5,a4,a5
c0002530:	0007a023          	sw	zero,0(a5)

				/* Set the handle to NULL to ensure the same queue handle cannot
				appear in the registry twice if it is added, removed, then
				added again. */
				xQueueRegistry[ ux ].xHandle = ( QueueHandle_t ) 0;
c0002534:	08001717          	auipc	a4,0x8001
c0002538:	fd470713          	addi	a4,a4,-44 # c8003508 <xQueueRegistry>
c000253c:	fec42783          	lw	a5,-20(s0)
c0002540:	00379793          	slli	a5,a5,0x3
c0002544:	00f707b3          	add	a5,a4,a5
c0002548:	0007a223          	sw	zero,4(a5)
				break;
c000254c:	0200006f          	j	c000256c <vQueueUnregisterQueue+0x88>
		for( ux = ( UBaseType_t ) 0U; ux < ( UBaseType_t ) configQUEUE_REGISTRY_SIZE; ux++ )
c0002550:	fec42783          	lw	a5,-20(s0)
c0002554:	00178793          	addi	a5,a5,1
c0002558:	fef42623          	sw	a5,-20(s0)
c000255c:	fec42703          	lw	a4,-20(s0)
c0002560:	00700793          	li	a5,7
c0002564:	f8e7fce3          	bgeu	a5,a4,c00024fc <vQueueUnregisterQueue+0x18>
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}

	} /*lint !e818 xQueue could not be pointer to const because it is a typedef. */
c0002568:	00000013          	nop
c000256c:	00000013          	nop
c0002570:	02c12403          	lw	s0,44(sp)
c0002574:	03010113          	addi	sp,sp,48
c0002578:	00008067          	ret

c000257c <vQueueWaitForMessageRestricted>:
/*-----------------------------------------------------------*/

#if ( configUSE_TIMERS == 1 )

	void vQueueWaitForMessageRestricted( QueueHandle_t xQueue, TickType_t xTicksToWait, const BaseType_t xWaitIndefinitely )
	{
c000257c:	fd010113          	addi	sp,sp,-48
c0002580:	02112623          	sw	ra,44(sp)
c0002584:	02812423          	sw	s0,40(sp)
c0002588:	03010413          	addi	s0,sp,48
c000258c:	fca42e23          	sw	a0,-36(s0)
c0002590:	fcb42c23          	sw	a1,-40(s0)
c0002594:	fcc42a23          	sw	a2,-44(s0)
	Queue_t * const pxQueue = xQueue;
c0002598:	fdc42783          	lw	a5,-36(s0)
c000259c:	fef42623          	sw	a5,-20(s0)
		will not actually cause the task to block, just place it on a blocked
		list.  It will not block until the scheduler is unlocked - at which
		time a yield will be performed.  If an item is added to the queue while
		the queue is locked, and the calling task blocks on the queue, then the
		calling task will be immediately unblocked when the queue is unlocked. */
		prvLockQueue( pxQueue );
c00025a0:	3a0030ef          	jal	ra,c0005940 <vTaskEnterCritical>
c00025a4:	fec42783          	lw	a5,-20(s0)
c00025a8:	0447c783          	lbu	a5,68(a5)
c00025ac:	01879713          	slli	a4,a5,0x18
c00025b0:	41875713          	srai	a4,a4,0x18
c00025b4:	fff00793          	li	a5,-1
c00025b8:	00f71663          	bne	a4,a5,c00025c4 <vQueueWaitForMessageRestricted+0x48>
c00025bc:	fec42783          	lw	a5,-20(s0)
c00025c0:	04078223          	sb	zero,68(a5)
c00025c4:	fec42783          	lw	a5,-20(s0)
c00025c8:	0457c783          	lbu	a5,69(a5)
c00025cc:	01879713          	slli	a4,a5,0x18
c00025d0:	41875713          	srai	a4,a4,0x18
c00025d4:	fff00793          	li	a5,-1
c00025d8:	00f71663          	bne	a4,a5,c00025e4 <vQueueWaitForMessageRestricted+0x68>
c00025dc:	fec42783          	lw	a5,-20(s0)
c00025e0:	040782a3          	sb	zero,69(a5)
c00025e4:	3b0030ef          	jal	ra,c0005994 <vTaskExitCritical>
		if( pxQueue->uxMessagesWaiting == ( UBaseType_t ) 0U )
c00025e8:	fec42783          	lw	a5,-20(s0)
c00025ec:	0387a783          	lw	a5,56(a5)
c00025f0:	00079e63          	bnez	a5,c000260c <vQueueWaitForMessageRestricted+0x90>
		{
			/* There is nothing in the queue, block for the specified period. */
			vTaskPlaceOnEventListRestricted( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait, xWaitIndefinitely );
c00025f4:	fec42783          	lw	a5,-20(s0)
c00025f8:	02478793          	addi	a5,a5,36
c00025fc:	fd442603          	lw	a2,-44(s0)
c0002600:	fd842583          	lw	a1,-40(s0)
c0002604:	00078513          	mv	a0,a5
c0002608:	228020ef          	jal	ra,c0004830 <vTaskPlaceOnEventListRestricted>
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
		prvUnlockQueue( pxQueue );
c000260c:	fec42503          	lw	a0,-20(s0)
c0002610:	b45ff0ef          	jal	ra,c0002154 <prvUnlockQueue>
	}
c0002614:	00000013          	nop
c0002618:	02c12083          	lw	ra,44(sp)
c000261c:	02812403          	lw	s0,40(sp)
c0002620:	03010113          	addi	sp,sp,48
c0002624:	00008067          	ret

c0002628 <xTaskCreate>:
							const char * const pcName,		/*lint !e971 Unqualified char types are allowed for strings and single characters only. */
							const configSTACK_DEPTH_TYPE usStackDepth,
							void * const pvParameters,
							UBaseType_t uxPriority,
							TaskHandle_t * const pxCreatedTask )
	{
c0002628:	fc010113          	addi	sp,sp,-64
c000262c:	02112e23          	sw	ra,60(sp)
c0002630:	02812c23          	sw	s0,56(sp)
c0002634:	04010413          	addi	s0,sp,64
c0002638:	fca42e23          	sw	a0,-36(s0)
c000263c:	fcb42c23          	sw	a1,-40(s0)
c0002640:	fcc42a23          	sw	a2,-44(s0)
c0002644:	fcd42823          	sw	a3,-48(s0)
c0002648:	fce42623          	sw	a4,-52(s0)
c000264c:	fcf42423          	sw	a5,-56(s0)
		#else /* portSTACK_GROWTH */
		{
		StackType_t *pxStack;

			/* Allocate space for the stack used by the task being created. */
			pxStack = pvPortMalloc( ( ( ( size_t ) usStackDepth ) * sizeof( StackType_t ) ) ); /*lint !e9079 All values returned by pvPortMalloc() have at least the alignment required by the MCU's stack and this allocation is the stack. */
c0002650:	fd442783          	lw	a5,-44(s0)
c0002654:	00279793          	slli	a5,a5,0x2
c0002658:	00078513          	mv	a0,a5
c000265c:	459060ef          	jal	ra,c00092b4 <pvPortMalloc>
c0002660:	fea42223          	sw	a0,-28(s0)

			if( pxStack != NULL )
c0002664:	fe442783          	lw	a5,-28(s0)
c0002668:	02078a63          	beqz	a5,c000269c <xTaskCreate+0x74>
			{
				/* Allocate space for the TCB. */
				pxNewTCB = ( TCB_t * ) pvPortMalloc( sizeof( TCB_t ) ); /*lint !e9087 !e9079 All values returned by pvPortMalloc() have at least the alignment required by the MCU's stack, and the first member of TCB_t is always a pointer to the task's stack. */
c000266c:	06400513          	li	a0,100
c0002670:	445060ef          	jal	ra,c00092b4 <pvPortMalloc>
c0002674:	fea42623          	sw	a0,-20(s0)

				if( pxNewTCB != NULL )
c0002678:	fec42783          	lw	a5,-20(s0)
c000267c:	00078a63          	beqz	a5,c0002690 <xTaskCreate+0x68>
				{
					/* Store the stack location in the TCB. */
					pxNewTCB->pxStack = pxStack;
c0002680:	fec42783          	lw	a5,-20(s0)
c0002684:	fe442703          	lw	a4,-28(s0)
c0002688:	02e7a823          	sw	a4,48(a5)
c000268c:	0140006f          	j	c00026a0 <xTaskCreate+0x78>
				}
				else
				{
					/* The stack cannot be used as the TCB was not created.  Free
					it again. */
					vPortFree( pxStack );
c0002690:	fe442503          	lw	a0,-28(s0)
c0002694:	6a5060ef          	jal	ra,c0009538 <vPortFree>
c0002698:	0080006f          	j	c00026a0 <xTaskCreate+0x78>
				}
			}
			else
			{
				pxNewTCB = NULL;
c000269c:	fe042623          	sw	zero,-20(s0)
			}
		}
		#endif /* portSTACK_GROWTH */

		if( pxNewTCB != NULL )
c00026a0:	fec42783          	lw	a5,-20(s0)
c00026a4:	02078e63          	beqz	a5,c00026e0 <xTaskCreate+0xb8>
				task was created dynamically in case it is later deleted. */
				pxNewTCB->ucStaticallyAllocated = tskDYNAMICALLY_ALLOCATED_STACK_AND_TCB;
			}
			#endif /* tskSTATIC_AND_DYNAMIC_ALLOCATION_POSSIBLE */

			prvInitialiseNewTask( pxTaskCode, pcName, ( uint32_t ) usStackDepth, pvParameters, uxPriority, pxCreatedTask, pxNewTCB, NULL );
c00026a8:	00000893          	li	a7,0
c00026ac:	fec42803          	lw	a6,-20(s0)
c00026b0:	fc842783          	lw	a5,-56(s0)
c00026b4:	fcc42703          	lw	a4,-52(s0)
c00026b8:	fd042683          	lw	a3,-48(s0)
c00026bc:	fd442603          	lw	a2,-44(s0)
c00026c0:	fd842583          	lw	a1,-40(s0)
c00026c4:	fdc42503          	lw	a0,-36(s0)
c00026c8:	038000ef          	jal	ra,c0002700 <prvInitialiseNewTask>
			prvAddNewTaskToReadyList( pxNewTCB );
c00026cc:	fec42503          	lw	a0,-20(s0)
c00026d0:	230000ef          	jal	ra,c0002900 <prvAddNewTaskToReadyList>
			xReturn = pdPASS;
c00026d4:	00100793          	li	a5,1
c00026d8:	fef42423          	sw	a5,-24(s0)
c00026dc:	00c0006f          	j	c00026e8 <xTaskCreate+0xc0>
		}
		else
		{
			xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
c00026e0:	fff00793          	li	a5,-1
c00026e4:	fef42423          	sw	a5,-24(s0)
		}

		return xReturn;
c00026e8:	fe842783          	lw	a5,-24(s0)
	}
c00026ec:	00078513          	mv	a0,a5
c00026f0:	03c12083          	lw	ra,60(sp)
c00026f4:	03812403          	lw	s0,56(sp)
c00026f8:	04010113          	addi	sp,sp,64
c00026fc:	00008067          	ret

c0002700 <prvInitialiseNewTask>:
									void * const pvParameters,
									UBaseType_t uxPriority,
									TaskHandle_t * const pxCreatedTask,
									TCB_t *pxNewTCB,
									const MemoryRegion_t * const xRegions )
{
c0002700:	fc010113          	addi	sp,sp,-64
c0002704:	02112e23          	sw	ra,60(sp)
c0002708:	02812c23          	sw	s0,56(sp)
c000270c:	04010413          	addi	s0,sp,64
c0002710:	fca42e23          	sw	a0,-36(s0)
c0002714:	fcb42c23          	sw	a1,-40(s0)
c0002718:	fcc42a23          	sw	a2,-44(s0)
c000271c:	fcd42823          	sw	a3,-48(s0)
c0002720:	fce42623          	sw	a4,-52(s0)
c0002724:	fcf42423          	sw	a5,-56(s0)
c0002728:	fd042223          	sw	a6,-60(s0)
c000272c:	fd142023          	sw	a7,-64(s0)

	/* Avoid dependency on memset() if it is not required. */
	#if( tskSET_NEW_STACKS_TO_KNOWN_VALUE == 1 )
	{
		/* Fill the stack with a known value to assist debugging. */
		( void ) memset( pxNewTCB->pxStack, ( int ) tskSTACK_FILL_BYTE, ( size_t ) ulStackDepth * sizeof( StackType_t ) );
c0002730:	fc442783          	lw	a5,-60(s0)
c0002734:	0307a703          	lw	a4,48(a5)
c0002738:	fd442783          	lw	a5,-44(s0)
c000273c:	00279793          	slli	a5,a5,0x2
c0002740:	00078613          	mv	a2,a5
c0002744:	0a500593          	li	a1,165
c0002748:	00070513          	mv	a0,a4
c000274c:	53c1b0ef          	jal	ra,c001dc88 <memset>
	grows from high memory to low (as per the 80x86) or vice versa.
	portSTACK_GROWTH is used to make the result positive or negative as required
	by the port. */
	#if( portSTACK_GROWTH < 0 )
	{
		pxTopOfStack = &( pxNewTCB->pxStack[ ulStackDepth - ( uint32_t ) 1 ] );
c0002750:	fc442783          	lw	a5,-60(s0)
c0002754:	0307a703          	lw	a4,48(a5)
c0002758:	fd442683          	lw	a3,-44(s0)
c000275c:	400007b7          	lui	a5,0x40000
c0002760:	fff78793          	addi	a5,a5,-1 # 3fffffff <_DMEM_LENGTH+0x3f7fffff>
c0002764:	00f687b3          	add	a5,a3,a5
c0002768:	00279793          	slli	a5,a5,0x2
c000276c:	00f707b3          	add	a5,a4,a5
c0002770:	fef42423          	sw	a5,-24(s0)
		pxTopOfStack = ( StackType_t * ) ( ( ( portPOINTER_SIZE_TYPE ) pxTopOfStack ) & ( ~( ( portPOINTER_SIZE_TYPE ) portBYTE_ALIGNMENT_MASK ) ) ); /*lint !e923 !e9033 !e9078 MISRA exception.  Avoiding casts between pointers and integers is not practical.  Size differences accounted for using portPOINTER_SIZE_TYPE type.  Checked by assert(). */
c0002774:	fe842783          	lw	a5,-24(s0)
c0002778:	ff07f793          	andi	a5,a5,-16
c000277c:	fef42423          	sw	a5,-24(s0)

		/* Check the alignment of the calculated top of stack is correct. */
		configASSERT( ( ( ( portPOINTER_SIZE_TYPE ) pxTopOfStack & ( portPOINTER_SIZE_TYPE ) portBYTE_ALIGNMENT_MASK ) == 0UL ) );
c0002780:	fe842783          	lw	a5,-24(s0)
c0002784:	00f7f793          	andi	a5,a5,15
c0002788:	00078863          	beqz	a5,c0002798 <prvInitialiseNewTask+0x98>
c000278c:	30047073          	csrci	mstatus,8
c0002790:	00100073          	ebreak
c0002794:	0000006f          	j	c0002794 <prvInitialiseNewTask+0x94>

		#if( configRECORD_STACK_HIGH_ADDRESS == 1 )
		{
			/* Also record the stack's high address, which may assist
			debugging. */
			pxNewTCB->pxEndOfStack = pxTopOfStack;
c0002798:	fc442783          	lw	a5,-60(s0)
c000279c:	fe842703          	lw	a4,-24(s0)
c00027a0:	04e7a223          	sw	a4,68(a5)
		pxNewTCB->pxEndOfStack = pxNewTCB->pxStack + ( ulStackDepth - ( uint32_t ) 1 );
	}
	#endif /* portSTACK_GROWTH */

	/* Store the task name in the TCB. */
	if( pcName != NULL )
c00027a4:	fd842783          	lw	a5,-40(s0)
c00027a8:	06078663          	beqz	a5,c0002814 <prvInitialiseNewTask+0x114>
	{
		for( x = ( UBaseType_t ) 0; x < ( UBaseType_t ) configMAX_TASK_NAME_LEN; x++ )
c00027ac:	fe042623          	sw	zero,-20(s0)
c00027b0:	0440006f          	j	c00027f4 <prvInitialiseNewTask+0xf4>
		{
			pxNewTCB->pcTaskName[ x ] = pcName[ x ];
c00027b4:	fd842703          	lw	a4,-40(s0)
c00027b8:	fec42783          	lw	a5,-20(s0)
c00027bc:	00f707b3          	add	a5,a4,a5
c00027c0:	0007c703          	lbu	a4,0(a5)
c00027c4:	fc442683          	lw	a3,-60(s0)
c00027c8:	fec42783          	lw	a5,-20(s0)
c00027cc:	00f687b3          	add	a5,a3,a5
c00027d0:	02e78a23          	sb	a4,52(a5)

			/* Don't copy all configMAX_TASK_NAME_LEN if the string is shorter than
			configMAX_TASK_NAME_LEN characters just in case the memory after the
			string is not accessible (extremely unlikely). */
			if( pcName[ x ] == ( char ) 0x00 )
c00027d4:	fd842703          	lw	a4,-40(s0)
c00027d8:	fec42783          	lw	a5,-20(s0)
c00027dc:	00f707b3          	add	a5,a4,a5
c00027e0:	0007c783          	lbu	a5,0(a5)
c00027e4:	02078063          	beqz	a5,c0002804 <prvInitialiseNewTask+0x104>
		for( x = ( UBaseType_t ) 0; x < ( UBaseType_t ) configMAX_TASK_NAME_LEN; x++ )
c00027e8:	fec42783          	lw	a5,-20(s0)
c00027ec:	00178793          	addi	a5,a5,1
c00027f0:	fef42623          	sw	a5,-20(s0)
c00027f4:	fec42703          	lw	a4,-20(s0)
c00027f8:	00f00793          	li	a5,15
c00027fc:	fae7fce3          	bgeu	a5,a4,c00027b4 <prvInitialiseNewTask+0xb4>
c0002800:	0080006f          	j	c0002808 <prvInitialiseNewTask+0x108>
			{
				break;
c0002804:	00000013          	nop
			}
		}

		/* Ensure the name string is terminated in the case that the string length
		was greater or equal to configMAX_TASK_NAME_LEN. */
		pxNewTCB->pcTaskName[ configMAX_TASK_NAME_LEN - 1 ] = '\0';
c0002808:	fc442783          	lw	a5,-60(s0)
c000280c:	040781a3          	sb	zero,67(a5)
c0002810:	00c0006f          	j	c000281c <prvInitialiseNewTask+0x11c>
	}
	else
	{
		/* The task has not been given a name, so just ensure there is a NULL
		terminator when it is read out. */
		pxNewTCB->pcTaskName[ 0 ] = 0x00;
c0002814:	fc442783          	lw	a5,-60(s0)
c0002818:	02078a23          	sb	zero,52(a5)
	}

	/* This is used as an array index so must ensure it's not too large.  First
	remove the privilege bit if one is present. */
	if( uxPriority >= ( UBaseType_t ) configMAX_PRIORITIES )
c000281c:	fcc42703          	lw	a4,-52(s0)
c0002820:	00400793          	li	a5,4
c0002824:	00e7f663          	bgeu	a5,a4,c0002830 <prvInitialiseNewTask+0x130>
	{
		uxPriority = ( UBaseType_t ) configMAX_PRIORITIES - ( UBaseType_t ) 1U;
c0002828:	00400793          	li	a5,4
c000282c:	fcf42623          	sw	a5,-52(s0)
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	pxNewTCB->uxPriority = uxPriority;
c0002830:	fc442783          	lw	a5,-60(s0)
c0002834:	fcc42703          	lw	a4,-52(s0)
c0002838:	02e7a623          	sw	a4,44(a5)
	#if ( configUSE_MUTEXES == 1 )
	{
		pxNewTCB->uxBasePriority = uxPriority;
c000283c:	fc442783          	lw	a5,-60(s0)
c0002840:	fcc42703          	lw	a4,-52(s0)
c0002844:	04e7aa23          	sw	a4,84(a5)
		pxNewTCB->uxMutexesHeld = 0;
c0002848:	fc442783          	lw	a5,-60(s0)
c000284c:	0407ac23          	sw	zero,88(a5)
	}
	#endif /* configUSE_MUTEXES */

	vListInitialiseItem( &( pxNewTCB->xStateListItem ) );
c0002850:	fc442783          	lw	a5,-60(s0)
c0002854:	00478793          	addi	a5,a5,4
c0002858:	00078513          	mv	a0,a5
c000285c:	ecdfd0ef          	jal	ra,c0000728 <vListInitialiseItem>
	vListInitialiseItem( &( pxNewTCB->xEventListItem ) );
c0002860:	fc442783          	lw	a5,-60(s0)
c0002864:	01878793          	addi	a5,a5,24
c0002868:	00078513          	mv	a0,a5
c000286c:	ebdfd0ef          	jal	ra,c0000728 <vListInitialiseItem>

	/* Set the pxNewTCB as a link back from the ListItem_t.  This is so we can get
	back to	the containing TCB from a generic item in a list. */
	listSET_LIST_ITEM_OWNER( &( pxNewTCB->xStateListItem ), pxNewTCB );
c0002870:	fc442783          	lw	a5,-60(s0)
c0002874:	fc442703          	lw	a4,-60(s0)
c0002878:	00e7a823          	sw	a4,16(a5)

	/* Event lists are always in priority order. */
	listSET_LIST_ITEM_VALUE( &( pxNewTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
c000287c:	00500713          	li	a4,5
c0002880:	fcc42783          	lw	a5,-52(s0)
c0002884:	40f70733          	sub	a4,a4,a5
c0002888:	fc442783          	lw	a5,-60(s0)
c000288c:	00e7ac23          	sw	a4,24(a5)
	listSET_LIST_ITEM_OWNER( &( pxNewTCB->xEventListItem ), pxNewTCB );
c0002890:	fc442783          	lw	a5,-60(s0)
c0002894:	fc442703          	lw	a4,-60(s0)
c0002898:	02e7a223          	sw	a4,36(a5)

	#if ( portCRITICAL_NESTING_IN_TCB == 1 )
	{
		pxNewTCB->uxCriticalNesting = ( UBaseType_t ) 0U;
c000289c:	fc442783          	lw	a5,-60(s0)
c00028a0:	0407a423          	sw	zero,72(a5)
	}
	#endif

	#if ( configUSE_TASK_NOTIFICATIONS == 1 )
	{
		pxNewTCB->ulNotifiedValue = 0;
c00028a4:	fc442783          	lw	a5,-60(s0)
c00028a8:	0407ae23          	sw	zero,92(a5)
		pxNewTCB->ucNotifyState = taskNOT_WAITING_NOTIFICATION;
c00028ac:	fc442783          	lw	a5,-60(s0)
c00028b0:	06078023          	sb	zero,96(a5)
	}
	#endif

	#if( INCLUDE_xTaskAbortDelay == 1 )
	{
		pxNewTCB->ucDelayAborted = pdFALSE;
c00028b4:	fc442783          	lw	a5,-60(s0)
c00028b8:	060780a3          	sb	zero,97(a5)
			}
			#endif /* portSTACK_GROWTH */
		}
		#else /* portHAS_STACK_OVERFLOW_CHECKING */
		{
			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters );
c00028bc:	fd042603          	lw	a2,-48(s0)
c00028c0:	fdc42583          	lw	a1,-36(s0)
c00028c4:	fe842503          	lw	a0,-24(s0)
c00028c8:	b39fd0ef          	jal	ra,c0000400 <pxPortInitialiseStack>
c00028cc:	00050713          	mv	a4,a0
c00028d0:	fc442783          	lw	a5,-60(s0)
c00028d4:	00e7a023          	sw	a4,0(a5)
		}
		#endif /* portHAS_STACK_OVERFLOW_CHECKING */
	}
	#endif /* portUSING_MPU_WRAPPERS */

	if( pxCreatedTask != NULL )
c00028d8:	fc842783          	lw	a5,-56(s0)
c00028dc:	00078863          	beqz	a5,c00028ec <prvInitialiseNewTask+0x1ec>
	{
		/* Pass the handle out in an anonymous way.  The handle can be used to
		change the created task's priority, delete the created task, etc.*/
		*pxCreatedTask = ( TaskHandle_t ) pxNewTCB;
c00028e0:	fc842783          	lw	a5,-56(s0)
c00028e4:	fc442703          	lw	a4,-60(s0)
c00028e8:	00e7a023          	sw	a4,0(a5)
	}
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}
}
c00028ec:	00000013          	nop
c00028f0:	03c12083          	lw	ra,60(sp)
c00028f4:	03812403          	lw	s0,56(sp)
c00028f8:	04010113          	addi	sp,sp,64
c00028fc:	00008067          	ret

c0002900 <prvAddNewTaskToReadyList>:
/*-----------------------------------------------------------*/

static void prvAddNewTaskToReadyList( TCB_t *pxNewTCB )
{
c0002900:	fe010113          	addi	sp,sp,-32
c0002904:	00112e23          	sw	ra,28(sp)
c0002908:	00812c23          	sw	s0,24(sp)
c000290c:	02010413          	addi	s0,sp,32
c0002910:	fea42623          	sw	a0,-20(s0)
	/* Ensure interrupts don't access the task lists while the lists are being
	updated. */
	taskENTER_CRITICAL();
c0002914:	02c030ef          	jal	ra,c0005940 <vTaskEnterCritical>
	{
		uxCurrentNumberOfTasks++;
c0002918:	08001797          	auipc	a5,0x8001
c000291c:	d0478793          	addi	a5,a5,-764 # c800361c <uxCurrentNumberOfTasks>
c0002920:	0007a783          	lw	a5,0(a5)
c0002924:	00178713          	addi	a4,a5,1
c0002928:	08001797          	auipc	a5,0x8001
c000292c:	cf478793          	addi	a5,a5,-780 # c800361c <uxCurrentNumberOfTasks>
c0002930:	00e7a023          	sw	a4,0(a5)
		if( pxCurrentTCB == NULL )
c0002934:	08000797          	auipc	a5,0x8000
c0002938:	f5878793          	addi	a5,a5,-168 # c800288c <pxCurrentTCB>
c000293c:	0007a783          	lw	a5,0(a5)
c0002940:	02079863          	bnez	a5,c0002970 <prvAddNewTaskToReadyList+0x70>
		{
			/* There are no other tasks, or all the other tasks are in
			the suspended state - make this the current task. */
			pxCurrentTCB = pxNewTCB;
c0002944:	08000797          	auipc	a5,0x8000
c0002948:	f4878793          	addi	a5,a5,-184 # c800288c <pxCurrentTCB>
c000294c:	fec42703          	lw	a4,-20(s0)
c0002950:	00e7a023          	sw	a4,0(a5)

			if( uxCurrentNumberOfTasks == ( UBaseType_t ) 1 )
c0002954:	08001797          	auipc	a5,0x8001
c0002958:	cc878793          	addi	a5,a5,-824 # c800361c <uxCurrentNumberOfTasks>
c000295c:	0007a703          	lw	a4,0(a5)
c0002960:	00100793          	li	a5,1
c0002964:	04f71463          	bne	a4,a5,c00029ac <prvAddNewTaskToReadyList+0xac>
			{
				/* This is the first task to be created so do the preliminary
				initialisation required.  We will not recover if this call
				fails, but we will report the failure. */
				prvInitialiseTaskLists();
c0002968:	474020ef          	jal	ra,c0004ddc <prvInitialiseTaskLists>
c000296c:	0400006f          	j	c00029ac <prvAddNewTaskToReadyList+0xac>
		else
		{
			/* If the scheduler is not already running, make this task the
			current task if it is the highest priority task to be created
			so far. */
			if( xSchedulerRunning == pdFALSE )
c0002970:	08001797          	auipc	a5,0x8001
c0002974:	cb878793          	addi	a5,a5,-840 # c8003628 <xSchedulerRunning>
c0002978:	0007a783          	lw	a5,0(a5)
c000297c:	02079863          	bnez	a5,c00029ac <prvAddNewTaskToReadyList+0xac>
			{
				if( pxCurrentTCB->uxPriority <= pxNewTCB->uxPriority )
c0002980:	08000797          	auipc	a5,0x8000
c0002984:	f0c78793          	addi	a5,a5,-244 # c800288c <pxCurrentTCB>
c0002988:	0007a783          	lw	a5,0(a5)
c000298c:	02c7a703          	lw	a4,44(a5)
c0002990:	fec42783          	lw	a5,-20(s0)
c0002994:	02c7a783          	lw	a5,44(a5)
c0002998:	00e7ea63          	bltu	a5,a4,c00029ac <prvAddNewTaskToReadyList+0xac>
				{
					pxCurrentTCB = pxNewTCB;
c000299c:	08000797          	auipc	a5,0x8000
c00029a0:	ef078793          	addi	a5,a5,-272 # c800288c <pxCurrentTCB>
c00029a4:	fec42703          	lw	a4,-20(s0)
c00029a8:	00e7a023          	sw	a4,0(a5)
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}

		uxTaskNumber++;
c00029ac:	08001797          	auipc	a5,0x8001
c00029b0:	c8c78793          	addi	a5,a5,-884 # c8003638 <uxTaskNumber>
c00029b4:	0007a783          	lw	a5,0(a5)
c00029b8:	00178713          	addi	a4,a5,1
c00029bc:	08001797          	auipc	a5,0x8001
c00029c0:	c7c78793          	addi	a5,a5,-900 # c8003638 <uxTaskNumber>
c00029c4:	00e7a023          	sw	a4,0(a5)

		#if ( configUSE_TRACE_FACILITY == 1 )
		{
			/* Add a counter into the TCB for tracing only. */
			pxNewTCB->uxTCBNumber = uxTaskNumber;
c00029c8:	08001797          	auipc	a5,0x8001
c00029cc:	c7078793          	addi	a5,a5,-912 # c8003638 <uxTaskNumber>
c00029d0:	0007a703          	lw	a4,0(a5)
c00029d4:	fec42783          	lw	a5,-20(s0)
c00029d8:	04e7a623          	sw	a4,76(a5)
		}
		#endif /* configUSE_TRACE_FACILITY */
		traceTASK_CREATE( pxNewTCB );

		prvAddTaskToReadyList( pxNewTCB );
c00029dc:	fec42783          	lw	a5,-20(s0)
c00029e0:	02c7a783          	lw	a5,44(a5)
c00029e4:	00100713          	li	a4,1
c00029e8:	00f71733          	sll	a4,a4,a5
c00029ec:	08001797          	auipc	a5,0x8001
c00029f0:	c3878793          	addi	a5,a5,-968 # c8003624 <uxTopReadyPriority>
c00029f4:	0007a783          	lw	a5,0(a5)
c00029f8:	00f76733          	or	a4,a4,a5
c00029fc:	08001797          	auipc	a5,0x8001
c0002a00:	c2878793          	addi	a5,a5,-984 # c8003624 <uxTopReadyPriority>
c0002a04:	00e7a023          	sw	a4,0(a5)
c0002a08:	fec42783          	lw	a5,-20(s0)
c0002a0c:	02c7a703          	lw	a4,44(a5)
c0002a10:	00070793          	mv	a5,a4
c0002a14:	00279793          	slli	a5,a5,0x2
c0002a18:	00e787b3          	add	a5,a5,a4
c0002a1c:	00279793          	slli	a5,a5,0x2
c0002a20:	08001717          	auipc	a4,0x8001
c0002a24:	b2870713          	addi	a4,a4,-1240 # c8003548 <pxReadyTasksLists>
c0002a28:	00e78733          	add	a4,a5,a4
c0002a2c:	fec42783          	lw	a5,-20(s0)
c0002a30:	00478793          	addi	a5,a5,4
c0002a34:	00078593          	mv	a1,a5
c0002a38:	00070513          	mv	a0,a4
c0002a3c:	d15fd0ef          	jal	ra,c0000750 <vListInsertEnd>

		portSETUP_TCB( pxNewTCB );
	}
	taskEXIT_CRITICAL();
c0002a40:	755020ef          	jal	ra,c0005994 <vTaskExitCritical>

	if( xSchedulerRunning != pdFALSE )
c0002a44:	08001797          	auipc	a5,0x8001
c0002a48:	be478793          	addi	a5,a5,-1052 # c8003628 <xSchedulerRunning>
c0002a4c:	0007a783          	lw	a5,0(a5)
c0002a50:	02078263          	beqz	a5,c0002a74 <prvAddNewTaskToReadyList+0x174>
	{
		/* If the created task is of a higher priority than the current task
		then it should run now. */
		if( pxCurrentTCB->uxPriority < pxNewTCB->uxPriority )
c0002a54:	08000797          	auipc	a5,0x8000
c0002a58:	e3878793          	addi	a5,a5,-456 # c800288c <pxCurrentTCB>
c0002a5c:	0007a783          	lw	a5,0(a5)
c0002a60:	02c7a703          	lw	a4,44(a5)
c0002a64:	fec42783          	lw	a5,-20(s0)
c0002a68:	02c7a783          	lw	a5,44(a5)
c0002a6c:	00f77463          	bgeu	a4,a5,c0002a74 <prvAddNewTaskToReadyList+0x174>
		{
			taskYIELD_IF_USING_PREEMPTION();
c0002a70:	00000073          	ecall
	}
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}
}
c0002a74:	00000013          	nop
c0002a78:	01c12083          	lw	ra,28(sp)
c0002a7c:	01812403          	lw	s0,24(sp)
c0002a80:	02010113          	addi	sp,sp,32
c0002a84:	00008067          	ret

c0002a88 <vTaskDelete>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelete == 1 )

	void vTaskDelete( TaskHandle_t xTaskToDelete )
	{
c0002a88:	fd010113          	addi	sp,sp,-48
c0002a8c:	02112623          	sw	ra,44(sp)
c0002a90:	02812423          	sw	s0,40(sp)
c0002a94:	03010413          	addi	s0,sp,48
c0002a98:	fca42e23          	sw	a0,-36(s0)
	TCB_t *pxTCB;

		taskENTER_CRITICAL();
c0002a9c:	6a5020ef          	jal	ra,c0005940 <vTaskEnterCritical>
		{
			/* If null is passed in here then it is the calling task that is
			being deleted. */
			pxTCB = prvGetTCBFromHandle( xTaskToDelete );
c0002aa0:	fdc42783          	lw	a5,-36(s0)
c0002aa4:	00079a63          	bnez	a5,c0002ab8 <vTaskDelete+0x30>
c0002aa8:	08000797          	auipc	a5,0x8000
c0002aac:	de478793          	addi	a5,a5,-540 # c800288c <pxCurrentTCB>
c0002ab0:	0007a783          	lw	a5,0(a5)
c0002ab4:	0080006f          	j	c0002abc <vTaskDelete+0x34>
c0002ab8:	fdc42783          	lw	a5,-36(s0)
c0002abc:	fef42623          	sw	a5,-20(s0)

			/* Remove task from the ready/delayed list. */
			if( uxListRemove( &( pxTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
c0002ac0:	fec42783          	lw	a5,-20(s0)
c0002ac4:	00478793          	addi	a5,a5,4
c0002ac8:	00078513          	mv	a0,a5
c0002acc:	de1fd0ef          	jal	ra,c00008ac <uxListRemove>
c0002ad0:	00050793          	mv	a5,a0
c0002ad4:	06079063          	bnez	a5,c0002b34 <vTaskDelete+0xac>
			{
				taskRESET_READY_PRIORITY( pxTCB->uxPriority );
c0002ad8:	fec42783          	lw	a5,-20(s0)
c0002adc:	02c7a703          	lw	a4,44(a5)
c0002ae0:	08001697          	auipc	a3,0x8001
c0002ae4:	a6868693          	addi	a3,a3,-1432 # c8003548 <pxReadyTasksLists>
c0002ae8:	00070793          	mv	a5,a4
c0002aec:	00279793          	slli	a5,a5,0x2
c0002af0:	00e787b3          	add	a5,a5,a4
c0002af4:	00279793          	slli	a5,a5,0x2
c0002af8:	00f687b3          	add	a5,a3,a5
c0002afc:	0007a783          	lw	a5,0(a5)
c0002b00:	02079a63          	bnez	a5,c0002b34 <vTaskDelete+0xac>
c0002b04:	fec42783          	lw	a5,-20(s0)
c0002b08:	02c7a783          	lw	a5,44(a5)
c0002b0c:	00100713          	li	a4,1
c0002b10:	00f717b3          	sll	a5,a4,a5
c0002b14:	fff7c713          	not	a4,a5
c0002b18:	08001797          	auipc	a5,0x8001
c0002b1c:	b0c78793          	addi	a5,a5,-1268 # c8003624 <uxTopReadyPriority>
c0002b20:	0007a783          	lw	a5,0(a5)
c0002b24:	00f77733          	and	a4,a4,a5
c0002b28:	08001797          	auipc	a5,0x8001
c0002b2c:	afc78793          	addi	a5,a5,-1284 # c8003624 <uxTopReadyPriority>
c0002b30:	00e7a023          	sw	a4,0(a5)
			{
				mtCOVERAGE_TEST_MARKER();
			}

			/* Is the task waiting on an event also? */
			if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
c0002b34:	fec42783          	lw	a5,-20(s0)
c0002b38:	0287a783          	lw	a5,40(a5)
c0002b3c:	00078a63          	beqz	a5,c0002b50 <vTaskDelete+0xc8>
			{
				( void ) uxListRemove( &( pxTCB->xEventListItem ) );
c0002b40:	fec42783          	lw	a5,-20(s0)
c0002b44:	01878793          	addi	a5,a5,24
c0002b48:	00078513          	mv	a0,a5
c0002b4c:	d61fd0ef          	jal	ra,c00008ac <uxListRemove>

			/* Increment the uxTaskNumber also so kernel aware debuggers can
			detect that the task lists need re-generating.  This is done before
			portPRE_TASK_DELETE_HOOK() as in the Windows port that macro will
			not return. */
			uxTaskNumber++;
c0002b50:	08001797          	auipc	a5,0x8001
c0002b54:	ae878793          	addi	a5,a5,-1304 # c8003638 <uxTaskNumber>
c0002b58:	0007a783          	lw	a5,0(a5)
c0002b5c:	00178713          	addi	a4,a5,1
c0002b60:	08001797          	auipc	a5,0x8001
c0002b64:	ad878793          	addi	a5,a5,-1320 # c8003638 <uxTaskNumber>
c0002b68:	00e7a023          	sw	a4,0(a5)

			if( pxTCB == pxCurrentTCB )
c0002b6c:	08000797          	auipc	a5,0x8000
c0002b70:	d2078793          	addi	a5,a5,-736 # c800288c <pxCurrentTCB>
c0002b74:	0007a783          	lw	a5,0(a5)
c0002b78:	fec42703          	lw	a4,-20(s0)
c0002b7c:	02f71e63          	bne	a4,a5,c0002bb8 <vTaskDelete+0x130>
				/* A task is deleting itself.  This cannot complete within the
				task itself, as a context switch to another task is required.
				Place the task in the termination list.  The idle task will
				check the termination list and free up any memory allocated by
				the scheduler for the TCB and stack of the deleted task. */
				vListInsertEnd( &xTasksWaitingTermination, &( pxTCB->xStateListItem ) );
c0002b80:	fec42783          	lw	a5,-20(s0)
c0002b84:	00478793          	addi	a5,a5,4
c0002b88:	00078593          	mv	a1,a5
c0002b8c:	08001517          	auipc	a0,0x8001
c0002b90:	a6450513          	addi	a0,a0,-1436 # c80035f0 <xTasksWaitingTermination>
c0002b94:	bbdfd0ef          	jal	ra,c0000750 <vListInsertEnd>

				/* Increment the ucTasksDeleted variable so the idle task knows
				there is a task that has been deleted and that it should therefore
				check the xTasksWaitingTermination list. */
				++uxDeletedTasksWaitingCleanUp;
c0002b98:	08001797          	auipc	a5,0x8001
c0002b9c:	a6c78793          	addi	a5,a5,-1428 # c8003604 <uxDeletedTasksWaitingCleanUp>
c0002ba0:	0007a783          	lw	a5,0(a5)
c0002ba4:	00178713          	addi	a4,a5,1
c0002ba8:	08001797          	auipc	a5,0x8001
c0002bac:	a5c78793          	addi	a5,a5,-1444 # c8003604 <uxDeletedTasksWaitingCleanUp>
c0002bb0:	00e7a023          	sw	a4,0(a5)
c0002bb4:	02c0006f          	j	c0002be0 <vTaskDelete+0x158>
				required. */
				portPRE_TASK_DELETE_HOOK( pxTCB, &xYieldPending );
			}
			else
			{
				--uxCurrentNumberOfTasks;
c0002bb8:	08001797          	auipc	a5,0x8001
c0002bbc:	a6478793          	addi	a5,a5,-1436 # c800361c <uxCurrentNumberOfTasks>
c0002bc0:	0007a783          	lw	a5,0(a5)
c0002bc4:	fff78713          	addi	a4,a5,-1
c0002bc8:	08001797          	auipc	a5,0x8001
c0002bcc:	a5478793          	addi	a5,a5,-1452 # c800361c <uxCurrentNumberOfTasks>
c0002bd0:	00e7a023          	sw	a4,0(a5)
				traceTASK_DELETE( pxTCB );
				prvDeleteTCB( pxTCB );
c0002bd4:	fec42503          	lw	a0,-20(s0)
c0002bd8:	6dc020ef          	jal	ra,c00052b4 <prvDeleteTCB>

				/* Reset the next expected unblock time in case it referred to
				the task that has just been deleted. */
				prvResetNextTaskUnblockTime();
c0002bdc:	718020ef          	jal	ra,c00052f4 <prvResetNextTaskUnblockTime>
			}
		}
		taskEXIT_CRITICAL();
c0002be0:	5b5020ef          	jal	ra,c0005994 <vTaskExitCritical>

		/* Force a reschedule if it is the currently running task that has just
		been deleted. */
		if( xSchedulerRunning != pdFALSE )
c0002be4:	08001797          	auipc	a5,0x8001
c0002be8:	a4478793          	addi	a5,a5,-1468 # c8003628 <xSchedulerRunning>
c0002bec:	0007a783          	lw	a5,0(a5)
c0002bf0:	02078c63          	beqz	a5,c0002c28 <vTaskDelete+0x1a0>
		{
			if( pxTCB == pxCurrentTCB )
c0002bf4:	08000797          	auipc	a5,0x8000
c0002bf8:	c9878793          	addi	a5,a5,-872 # c800288c <pxCurrentTCB>
c0002bfc:	0007a783          	lw	a5,0(a5)
c0002c00:	fec42703          	lw	a4,-20(s0)
c0002c04:	02f71263          	bne	a4,a5,c0002c28 <vTaskDelete+0x1a0>
			{
				configASSERT( uxSchedulerSuspended == 0 );
c0002c08:	08001797          	auipc	a5,0x8001
c0002c0c:	a3c78793          	addi	a5,a5,-1476 # c8003644 <uxSchedulerSuspended>
c0002c10:	0007a783          	lw	a5,0(a5)
c0002c14:	00078863          	beqz	a5,c0002c24 <vTaskDelete+0x19c>
c0002c18:	30047073          	csrci	mstatus,8
c0002c1c:	00100073          	ebreak
c0002c20:	0000006f          	j	c0002c20 <vTaskDelete+0x198>
				portYIELD_WITHIN_API();
c0002c24:	00000073          	ecall
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
	}
c0002c28:	00000013          	nop
c0002c2c:	02c12083          	lw	ra,44(sp)
c0002c30:	02812403          	lw	s0,40(sp)
c0002c34:	03010113          	addi	sp,sp,48
c0002c38:	00008067          	ret

c0002c3c <vTaskDelayUntil>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelayUntil == 1 )

	void vTaskDelayUntil( TickType_t * const pxPreviousWakeTime, const TickType_t xTimeIncrement )
	{
c0002c3c:	fd010113          	addi	sp,sp,-48
c0002c40:	02112623          	sw	ra,44(sp)
c0002c44:	02812423          	sw	s0,40(sp)
c0002c48:	03010413          	addi	s0,sp,48
c0002c4c:	fca42e23          	sw	a0,-36(s0)
c0002c50:	fcb42c23          	sw	a1,-40(s0)
	TickType_t xTimeToWake;
	BaseType_t xAlreadyYielded, xShouldDelay = pdFALSE;
c0002c54:	fe042623          	sw	zero,-20(s0)

		configASSERT( pxPreviousWakeTime );
c0002c58:	fdc42783          	lw	a5,-36(s0)
c0002c5c:	00079863          	bnez	a5,c0002c6c <vTaskDelayUntil+0x30>
c0002c60:	30047073          	csrci	mstatus,8
c0002c64:	00100073          	ebreak
c0002c68:	0000006f          	j	c0002c68 <vTaskDelayUntil+0x2c>
		configASSERT( ( xTimeIncrement > 0U ) );
c0002c6c:	fd842783          	lw	a5,-40(s0)
c0002c70:	00079863          	bnez	a5,c0002c80 <vTaskDelayUntil+0x44>
c0002c74:	30047073          	csrci	mstatus,8
c0002c78:	00100073          	ebreak
c0002c7c:	0000006f          	j	c0002c7c <vTaskDelayUntil+0x40>
		configASSERT( uxSchedulerSuspended == 0 );
c0002c80:	08001797          	auipc	a5,0x8001
c0002c84:	9c478793          	addi	a5,a5,-1596 # c8003644 <uxSchedulerSuspended>
c0002c88:	0007a783          	lw	a5,0(a5)
c0002c8c:	00078863          	beqz	a5,c0002c9c <vTaskDelayUntil+0x60>
c0002c90:	30047073          	csrci	mstatus,8
c0002c94:	00100073          	ebreak
c0002c98:	0000006f          	j	c0002c98 <vTaskDelayUntil+0x5c>

		vTaskSuspendAll();
c0002c9c:	2c1000ef          	jal	ra,c000375c <vTaskSuspendAll>
		{
			/* Minor optimisation.  The tick count cannot change in this
			block. */
			const TickType_t xConstTickCount = xTickCount;
c0002ca0:	08001797          	auipc	a5,0x8001
c0002ca4:	98078793          	addi	a5,a5,-1664 # c8003620 <xTickCount>
c0002ca8:	0007a783          	lw	a5,0(a5)
c0002cac:	fef42423          	sw	a5,-24(s0)

			/* Generate the tick time at which the task wants to wake. */
			xTimeToWake = *pxPreviousWakeTime + xTimeIncrement;
c0002cb0:	fdc42783          	lw	a5,-36(s0)
c0002cb4:	0007a783          	lw	a5,0(a5)
c0002cb8:	fd842703          	lw	a4,-40(s0)
c0002cbc:	00f707b3          	add	a5,a4,a5
c0002cc0:	fef42223          	sw	a5,-28(s0)

			if( xConstTickCount < *pxPreviousWakeTime )
c0002cc4:	fdc42783          	lw	a5,-36(s0)
c0002cc8:	0007a783          	lw	a5,0(a5)
c0002ccc:	fe842703          	lw	a4,-24(s0)
c0002cd0:	02f77663          	bgeu	a4,a5,c0002cfc <vTaskDelayUntil+0xc0>
				/* The tick count has overflowed since this function was
				lasted called.  In this case the only time we should ever
				actually delay is if the wake time has also	overflowed,
				and the wake time is greater than the tick time.  When this
				is the case it is as if neither time had overflowed. */
				if( ( xTimeToWake < *pxPreviousWakeTime ) && ( xTimeToWake > xConstTickCount ) )
c0002cd4:	fdc42783          	lw	a5,-36(s0)
c0002cd8:	0007a783          	lw	a5,0(a5)
c0002cdc:	fe442703          	lw	a4,-28(s0)
c0002ce0:	04f77063          	bgeu	a4,a5,c0002d20 <vTaskDelayUntil+0xe4>
c0002ce4:	fe442703          	lw	a4,-28(s0)
c0002ce8:	fe842783          	lw	a5,-24(s0)
c0002cec:	02e7fa63          	bgeu	a5,a4,c0002d20 <vTaskDelayUntil+0xe4>
				{
					xShouldDelay = pdTRUE;
c0002cf0:	00100793          	li	a5,1
c0002cf4:	fef42623          	sw	a5,-20(s0)
c0002cf8:	0280006f          	j	c0002d20 <vTaskDelayUntil+0xe4>
			else
			{
				/* The tick time has not overflowed.  In this case we will
				delay if either the wake time has overflowed, and/or the
				tick time is less than the wake time. */
				if( ( xTimeToWake < *pxPreviousWakeTime ) || ( xTimeToWake > xConstTickCount ) )
c0002cfc:	fdc42783          	lw	a5,-36(s0)
c0002d00:	0007a783          	lw	a5,0(a5)
c0002d04:	fe442703          	lw	a4,-28(s0)
c0002d08:	00f76863          	bltu	a4,a5,c0002d18 <vTaskDelayUntil+0xdc>
c0002d0c:	fe442703          	lw	a4,-28(s0)
c0002d10:	fe842783          	lw	a5,-24(s0)
c0002d14:	00e7f663          	bgeu	a5,a4,c0002d20 <vTaskDelayUntil+0xe4>
				{
					xShouldDelay = pdTRUE;
c0002d18:	00100793          	li	a5,1
c0002d1c:	fef42623          	sw	a5,-20(s0)
					mtCOVERAGE_TEST_MARKER();
				}
			}

			/* Update the wake time ready for the next call. */
			*pxPreviousWakeTime = xTimeToWake;
c0002d20:	fdc42783          	lw	a5,-36(s0)
c0002d24:	fe442703          	lw	a4,-28(s0)
c0002d28:	00e7a023          	sw	a4,0(a5)

			if( xShouldDelay != pdFALSE )
c0002d2c:	fec42783          	lw	a5,-20(s0)
c0002d30:	00078e63          	beqz	a5,c0002d4c <vTaskDelayUntil+0x110>
			{
				traceTASK_DELAY_UNTIL( xTimeToWake );

				/* prvAddCurrentTaskToDelayedList() needs the block time, not
				the time to wake, so subtract the current tick count. */
				prvAddCurrentTaskToDelayedList( xTimeToWake - xConstTickCount, pdFALSE );
c0002d34:	fe442703          	lw	a4,-28(s0)
c0002d38:	fe842783          	lw	a5,-24(s0)
c0002d3c:	40f707b3          	sub	a5,a4,a5
c0002d40:	00000593          	li	a1,0
c0002d44:	00078513          	mv	a0,a5
c0002d48:	105030ef          	jal	ra,c000664c <prvAddCurrentTaskToDelayedList>
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
		xAlreadyYielded = xTaskResumeAll();
c0002d4c:	249000ef          	jal	ra,c0003794 <xTaskResumeAll>
c0002d50:	fea42023          	sw	a0,-32(s0)

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( xAlreadyYielded == pdFALSE )
c0002d54:	fe042783          	lw	a5,-32(s0)
c0002d58:	00079463          	bnez	a5,c0002d60 <vTaskDelayUntil+0x124>
		{
			portYIELD_WITHIN_API();
c0002d5c:	00000073          	ecall
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
c0002d60:	00000013          	nop
c0002d64:	02c12083          	lw	ra,44(sp)
c0002d68:	02812403          	lw	s0,40(sp)
c0002d6c:	03010113          	addi	sp,sp,48
c0002d70:	00008067          	ret

c0002d74 <vTaskDelay>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelay == 1 )

	void vTaskDelay( const TickType_t xTicksToDelay )
	{
c0002d74:	fd010113          	addi	sp,sp,-48
c0002d78:	02112623          	sw	ra,44(sp)
c0002d7c:	02812423          	sw	s0,40(sp)
c0002d80:	03010413          	addi	s0,sp,48
c0002d84:	fca42e23          	sw	a0,-36(s0)
	BaseType_t xAlreadyYielded = pdFALSE;
c0002d88:	fe042623          	sw	zero,-20(s0)

		/* A delay time of zero just forces a reschedule. */
		if( xTicksToDelay > ( TickType_t ) 0U )
c0002d8c:	fdc42783          	lw	a5,-36(s0)
c0002d90:	02078c63          	beqz	a5,c0002dc8 <vTaskDelay+0x54>
		{
			configASSERT( uxSchedulerSuspended == 0 );
c0002d94:	08001797          	auipc	a5,0x8001
c0002d98:	8b078793          	addi	a5,a5,-1872 # c8003644 <uxSchedulerSuspended>
c0002d9c:	0007a783          	lw	a5,0(a5)
c0002da0:	00078863          	beqz	a5,c0002db0 <vTaskDelay+0x3c>
c0002da4:	30047073          	csrci	mstatus,8
c0002da8:	00100073          	ebreak
c0002dac:	0000006f          	j	c0002dac <vTaskDelay+0x38>
			vTaskSuspendAll();
c0002db0:	1ad000ef          	jal	ra,c000375c <vTaskSuspendAll>
				list or removed from the blocked list until the scheduler
				is resumed.

				This task cannot be in an event list as it is the currently
				executing task. */
				prvAddCurrentTaskToDelayedList( xTicksToDelay, pdFALSE );
c0002db4:	00000593          	li	a1,0
c0002db8:	fdc42503          	lw	a0,-36(s0)
c0002dbc:	091030ef          	jal	ra,c000664c <prvAddCurrentTaskToDelayedList>
			}
			xAlreadyYielded = xTaskResumeAll();
c0002dc0:	1d5000ef          	jal	ra,c0003794 <xTaskResumeAll>
c0002dc4:	fea42623          	sw	a0,-20(s0)
			mtCOVERAGE_TEST_MARKER();
		}

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( xAlreadyYielded == pdFALSE )
c0002dc8:	fec42783          	lw	a5,-20(s0)
c0002dcc:	00079463          	bnez	a5,c0002dd4 <vTaskDelay+0x60>
		{
			portYIELD_WITHIN_API();
c0002dd0:	00000073          	ecall
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
c0002dd4:	00000013          	nop
c0002dd8:	02c12083          	lw	ra,44(sp)
c0002ddc:	02812403          	lw	s0,40(sp)
c0002de0:	03010113          	addi	sp,sp,48
c0002de4:	00008067          	ret

c0002de8 <eTaskGetState>:
/*-----------------------------------------------------------*/

#if( ( INCLUDE_eTaskGetState == 1 ) || ( configUSE_TRACE_FACILITY == 1 ) || ( INCLUDE_xTaskAbortDelay == 1 ) )

	eTaskState eTaskGetState( TaskHandle_t xTask )
	{
c0002de8:	fc010113          	addi	sp,sp,-64
c0002dec:	02112e23          	sw	ra,60(sp)
c0002df0:	02812c23          	sw	s0,56(sp)
c0002df4:	04010413          	addi	s0,sp,64
c0002df8:	fca42623          	sw	a0,-52(s0)
	eTaskState eReturn;
	List_t const * pxStateList, *pxDelayedList, *pxOverflowedDelayedList;
	const TCB_t * const pxTCB = xTask;
c0002dfc:	fcc42783          	lw	a5,-52(s0)
c0002e00:	fef42423          	sw	a5,-24(s0)

		configASSERT( pxTCB );
c0002e04:	fe842783          	lw	a5,-24(s0)
c0002e08:	00079863          	bnez	a5,c0002e18 <eTaskGetState+0x30>
c0002e0c:	30047073          	csrci	mstatus,8
c0002e10:	00100073          	ebreak
c0002e14:	0000006f          	j	c0002e14 <eTaskGetState+0x2c>

		if( pxTCB == pxCurrentTCB )
c0002e18:	08000797          	auipc	a5,0x8000
c0002e1c:	a7478793          	addi	a5,a5,-1420 # c800288c <pxCurrentTCB>
c0002e20:	0007a783          	lw	a5,0(a5)
c0002e24:	fe842703          	lw	a4,-24(s0)
c0002e28:	00f71663          	bne	a4,a5,c0002e34 <eTaskGetState+0x4c>
		{
			/* The task calling this function is querying its own state. */
			eReturn = eRunning;
c0002e2c:	fe042623          	sw	zero,-20(s0)
c0002e30:	0dc0006f          	j	c0002f0c <eTaskGetState+0x124>
		}
		else
		{
			taskENTER_CRITICAL();
c0002e34:	30d020ef          	jal	ra,c0005940 <vTaskEnterCritical>
			{
				pxStateList = listLIST_ITEM_CONTAINER( &( pxTCB->xStateListItem ) );
c0002e38:	fe842783          	lw	a5,-24(s0)
c0002e3c:	0147a783          	lw	a5,20(a5)
c0002e40:	fef42223          	sw	a5,-28(s0)
				pxDelayedList = pxDelayedTaskList;
c0002e44:	08000797          	auipc	a5,0x8000
c0002e48:	79078793          	addi	a5,a5,1936 # c80035d4 <pxDelayedTaskList>
c0002e4c:	0007a783          	lw	a5,0(a5)
c0002e50:	fef42023          	sw	a5,-32(s0)
				pxOverflowedDelayedList = pxOverflowDelayedTaskList;
c0002e54:	08000797          	auipc	a5,0x8000
c0002e58:	78478793          	addi	a5,a5,1924 # c80035d8 <pxOverflowDelayedTaskList>
c0002e5c:	0007a783          	lw	a5,0(a5)
c0002e60:	fcf42e23          	sw	a5,-36(s0)
			}
			taskEXIT_CRITICAL();
c0002e64:	331020ef          	jal	ra,c0005994 <vTaskExitCritical>

			if( ( pxStateList == pxDelayedList ) || ( pxStateList == pxOverflowedDelayedList ) )
c0002e68:	fe442703          	lw	a4,-28(s0)
c0002e6c:	fe042783          	lw	a5,-32(s0)
c0002e70:	00f70863          	beq	a4,a5,c0002e80 <eTaskGetState+0x98>
c0002e74:	fe442703          	lw	a4,-28(s0)
c0002e78:	fdc42783          	lw	a5,-36(s0)
c0002e7c:	00f71863          	bne	a4,a5,c0002e8c <eTaskGetState+0xa4>
			{
				/* The task being queried is referenced from one of the Blocked
				lists. */
				eReturn = eBlocked;
c0002e80:	00200793          	li	a5,2
c0002e84:	fef42623          	sw	a5,-20(s0)
c0002e88:	0840006f          	j	c0002f0c <eTaskGetState+0x124>
			}

			#if ( INCLUDE_vTaskSuspend == 1 )
				else if( pxStateList == &xSuspendedTaskList )
c0002e8c:	fe442703          	lw	a4,-28(s0)
c0002e90:	08000797          	auipc	a5,0x8000
c0002e94:	77878793          	addi	a5,a5,1912 # c8003608 <xSuspendedTaskList>
c0002e98:	04f71463          	bne	a4,a5,c0002ee0 <eTaskGetState+0xf8>
				{
					/* The task being queried is referenced from the suspended
					list.  Is it genuinely suspended or is it blocked
					indefinitely? */
					if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) == NULL )
c0002e9c:	fe842783          	lw	a5,-24(s0)
c0002ea0:	0287a783          	lw	a5,40(a5)
c0002ea4:	02079863          	bnez	a5,c0002ed4 <eTaskGetState+0xec>
						{
							/* The task does not appear on the event list item of
							and of the RTOS objects, but could still be in the
							blocked state if it is waiting on its notification
							rather than waiting on an object. */
							if( pxTCB->ucNotifyState == taskWAITING_NOTIFICATION )
c0002ea8:	fe842783          	lw	a5,-24(s0)
c0002eac:	0607c783          	lbu	a5,96(a5)
c0002eb0:	0ff7f713          	andi	a4,a5,255
c0002eb4:	00100793          	li	a5,1
c0002eb8:	00f71863          	bne	a4,a5,c0002ec8 <eTaskGetState+0xe0>
							{
								eReturn = eBlocked;
c0002ebc:	00200793          	li	a5,2
c0002ec0:	fef42623          	sw	a5,-20(s0)
c0002ec4:	0480006f          	j	c0002f0c <eTaskGetState+0x124>
							}
							else
							{
								eReturn = eSuspended;
c0002ec8:	00300793          	li	a5,3
c0002ecc:	fef42623          	sw	a5,-20(s0)
c0002ed0:	03c0006f          	j	c0002f0c <eTaskGetState+0x124>
						}
						#endif
					}
					else
					{
						eReturn = eBlocked;
c0002ed4:	00200793          	li	a5,2
c0002ed8:	fef42623          	sw	a5,-20(s0)
c0002edc:	0300006f          	j	c0002f0c <eTaskGetState+0x124>
					}
				}
			#endif

			#if ( INCLUDE_vTaskDelete == 1 )
				else if( ( pxStateList == &xTasksWaitingTermination ) || ( pxStateList == NULL ) )
c0002ee0:	fe442703          	lw	a4,-28(s0)
c0002ee4:	08000797          	auipc	a5,0x8000
c0002ee8:	70c78793          	addi	a5,a5,1804 # c80035f0 <xTasksWaitingTermination>
c0002eec:	00f70663          	beq	a4,a5,c0002ef8 <eTaskGetState+0x110>
c0002ef0:	fe442783          	lw	a5,-28(s0)
c0002ef4:	00079863          	bnez	a5,c0002f04 <eTaskGetState+0x11c>
				{
					/* The task being queried is referenced from the deleted
					tasks list, or it is not referenced from any lists at
					all. */
					eReturn = eDeleted;
c0002ef8:	00400793          	li	a5,4
c0002efc:	fef42623          	sw	a5,-20(s0)
c0002f00:	00c0006f          	j	c0002f0c <eTaskGetState+0x124>

			else /*lint !e525 Negative indentation is intended to make use of pre-processor clearer. */
			{
				/* If the task is not in any other state, it must be in the
				Ready (including pending ready) state. */
				eReturn = eReady;
c0002f04:	00100793          	li	a5,1
c0002f08:	fef42623          	sw	a5,-20(s0)
			}
		}

		return eReturn;
c0002f0c:	fec42783          	lw	a5,-20(s0)
	} /*lint !e818 xTask cannot be a pointer to const because it is a typedef. */
c0002f10:	00078513          	mv	a0,a5
c0002f14:	03c12083          	lw	ra,60(sp)
c0002f18:	03812403          	lw	s0,56(sp)
c0002f1c:	04010113          	addi	sp,sp,64
c0002f20:	00008067          	ret

c0002f24 <uxTaskPriorityGet>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_uxTaskPriorityGet == 1 )

	UBaseType_t uxTaskPriorityGet( const TaskHandle_t xTask )
	{
c0002f24:	fd010113          	addi	sp,sp,-48
c0002f28:	02112623          	sw	ra,44(sp)
c0002f2c:	02812423          	sw	s0,40(sp)
c0002f30:	03010413          	addi	s0,sp,48
c0002f34:	fca42e23          	sw	a0,-36(s0)
	TCB_t const *pxTCB;
	UBaseType_t uxReturn;

		taskENTER_CRITICAL();
c0002f38:	209020ef          	jal	ra,c0005940 <vTaskEnterCritical>
		{
			/* If null is passed in here then it is the priority of the task
			that called uxTaskPriorityGet() that is being queried. */
			pxTCB = prvGetTCBFromHandle( xTask );
c0002f3c:	fdc42783          	lw	a5,-36(s0)
c0002f40:	00079a63          	bnez	a5,c0002f54 <uxTaskPriorityGet+0x30>
c0002f44:	08000797          	auipc	a5,0x8000
c0002f48:	94878793          	addi	a5,a5,-1720 # c800288c <pxCurrentTCB>
c0002f4c:	0007a783          	lw	a5,0(a5)
c0002f50:	0080006f          	j	c0002f58 <uxTaskPriorityGet+0x34>
c0002f54:	fdc42783          	lw	a5,-36(s0)
c0002f58:	fef42623          	sw	a5,-20(s0)
			uxReturn = pxTCB->uxPriority;
c0002f5c:	fec42783          	lw	a5,-20(s0)
c0002f60:	02c7a783          	lw	a5,44(a5)
c0002f64:	fef42423          	sw	a5,-24(s0)
		}
		taskEXIT_CRITICAL();
c0002f68:	22d020ef          	jal	ra,c0005994 <vTaskExitCritical>

		return uxReturn;
c0002f6c:	fe842783          	lw	a5,-24(s0)
	}
c0002f70:	00078513          	mv	a0,a5
c0002f74:	02c12083          	lw	ra,44(sp)
c0002f78:	02812403          	lw	s0,40(sp)
c0002f7c:	03010113          	addi	sp,sp,48
c0002f80:	00008067          	ret

c0002f84 <uxTaskPriorityGetFromISR>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_uxTaskPriorityGet == 1 )

	UBaseType_t uxTaskPriorityGetFromISR( const TaskHandle_t xTask )
	{
c0002f84:	fd010113          	addi	sp,sp,-48
c0002f88:	02812623          	sw	s0,44(sp)
c0002f8c:	03010413          	addi	s0,sp,48
c0002f90:	fca42e23          	sw	a0,-36(s0)
		simple as possible.  More information (albeit Cortex-M specific) is
		provided on the following link:
		https://www.freertos.org/RTOS-Cortex-M3-M4.html */
		portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

		uxSavedInterruptState = portSET_INTERRUPT_MASK_FROM_ISR();
c0002f94:	fe042623          	sw	zero,-20(s0)
		{
			/* If null is passed in here then it is the priority of the calling
			task that is being queried. */
			pxTCB = prvGetTCBFromHandle( xTask );
c0002f98:	fdc42783          	lw	a5,-36(s0)
c0002f9c:	00079a63          	bnez	a5,c0002fb0 <uxTaskPriorityGetFromISR+0x2c>
c0002fa0:	08000797          	auipc	a5,0x8000
c0002fa4:	8ec78793          	addi	a5,a5,-1812 # c800288c <pxCurrentTCB>
c0002fa8:	0007a783          	lw	a5,0(a5)
c0002fac:	0080006f          	j	c0002fb4 <uxTaskPriorityGetFromISR+0x30>
c0002fb0:	fdc42783          	lw	a5,-36(s0)
c0002fb4:	fef42423          	sw	a5,-24(s0)
			uxReturn = pxTCB->uxPriority;
c0002fb8:	fe842783          	lw	a5,-24(s0)
c0002fbc:	02c7a783          	lw	a5,44(a5)
c0002fc0:	fef42223          	sw	a5,-28(s0)
		}
		portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptState );

		return uxReturn;
c0002fc4:	fe442783          	lw	a5,-28(s0)
	}
c0002fc8:	00078513          	mv	a0,a5
c0002fcc:	02c12403          	lw	s0,44(sp)
c0002fd0:	03010113          	addi	sp,sp,48
c0002fd4:	00008067          	ret

c0002fd8 <vTaskPrioritySet>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskPrioritySet == 1 )

	void vTaskPrioritySet( TaskHandle_t xTask, UBaseType_t uxNewPriority )
	{
c0002fd8:	fd010113          	addi	sp,sp,-48
c0002fdc:	02112623          	sw	ra,44(sp)
c0002fe0:	02812423          	sw	s0,40(sp)
c0002fe4:	03010413          	addi	s0,sp,48
c0002fe8:	fca42e23          	sw	a0,-36(s0)
c0002fec:	fcb42c23          	sw	a1,-40(s0)
	TCB_t *pxTCB;
	UBaseType_t uxCurrentBasePriority, uxPriorityUsedOnEntry;
	BaseType_t xYieldRequired = pdFALSE;
c0002ff0:	fe042623          	sw	zero,-20(s0)

		configASSERT( ( uxNewPriority < configMAX_PRIORITIES ) );
c0002ff4:	fd842703          	lw	a4,-40(s0)
c0002ff8:	00400793          	li	a5,4
c0002ffc:	00e7f863          	bgeu	a5,a4,c000300c <vTaskPrioritySet+0x34>
c0003000:	30047073          	csrci	mstatus,8
c0003004:	00100073          	ebreak
c0003008:	0000006f          	j	c0003008 <vTaskPrioritySet+0x30>

		/* Ensure the new priority is valid. */
		if( uxNewPriority >= ( UBaseType_t ) configMAX_PRIORITIES )
c000300c:	fd842703          	lw	a4,-40(s0)
c0003010:	00400793          	li	a5,4
c0003014:	00e7f663          	bgeu	a5,a4,c0003020 <vTaskPrioritySet+0x48>
		{
			uxNewPriority = ( UBaseType_t ) configMAX_PRIORITIES - ( UBaseType_t ) 1U;
c0003018:	00400793          	li	a5,4
c000301c:	fcf42c23          	sw	a5,-40(s0)
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}

		taskENTER_CRITICAL();
c0003020:	121020ef          	jal	ra,c0005940 <vTaskEnterCritical>
		{
			/* If null is passed in here then it is the priority of the calling
			task that is being changed. */
			pxTCB = prvGetTCBFromHandle( xTask );
c0003024:	fdc42783          	lw	a5,-36(s0)
c0003028:	00079a63          	bnez	a5,c000303c <vTaskPrioritySet+0x64>
c000302c:	08000797          	auipc	a5,0x8000
c0003030:	86078793          	addi	a5,a5,-1952 # c800288c <pxCurrentTCB>
c0003034:	0007a783          	lw	a5,0(a5)
c0003038:	0080006f          	j	c0003040 <vTaskPrioritySet+0x68>
c000303c:	fdc42783          	lw	a5,-36(s0)
c0003040:	fef42423          	sw	a5,-24(s0)

			traceTASK_PRIORITY_SET( pxTCB, uxNewPriority );

			#if ( configUSE_MUTEXES == 1 )
			{
				uxCurrentBasePriority = pxTCB->uxBasePriority;
c0003044:	fe842783          	lw	a5,-24(s0)
c0003048:	0547a783          	lw	a5,84(a5)
c000304c:	fef42223          	sw	a5,-28(s0)
			{
				uxCurrentBasePriority = pxTCB->uxPriority;
			}
			#endif

			if( uxCurrentBasePriority != uxNewPriority )
c0003050:	fe442703          	lw	a4,-28(s0)
c0003054:	fd842783          	lw	a5,-40(s0)
c0003058:	18f70e63          	beq	a4,a5,c00031f4 <vTaskPrioritySet+0x21c>
			{
				/* The priority change may have readied a task of higher
				priority than the calling task. */
				if( uxNewPriority > uxCurrentBasePriority )
c000305c:	fd842703          	lw	a4,-40(s0)
c0003060:	fe442783          	lw	a5,-28(s0)
c0003064:	02e7fe63          	bgeu	a5,a4,c00030a0 <vTaskPrioritySet+0xc8>
				{
					if( pxTCB != pxCurrentTCB )
c0003068:	08000797          	auipc	a5,0x8000
c000306c:	82478793          	addi	a5,a5,-2012 # c800288c <pxCurrentTCB>
c0003070:	0007a783          	lw	a5,0(a5)
c0003074:	fe842703          	lw	a4,-24(s0)
c0003078:	04f70263          	beq	a4,a5,c00030bc <vTaskPrioritySet+0xe4>
					{
						/* The priority of a task other than the currently
						running task is being raised.  Is the priority being
						raised above that of the running task? */
						if( uxNewPriority >= pxCurrentTCB->uxPriority )
c000307c:	08000797          	auipc	a5,0x8000
c0003080:	81078793          	addi	a5,a5,-2032 # c800288c <pxCurrentTCB>
c0003084:	0007a783          	lw	a5,0(a5)
c0003088:	02c7a783          	lw	a5,44(a5)
c000308c:	fd842703          	lw	a4,-40(s0)
c0003090:	02f76663          	bltu	a4,a5,c00030bc <vTaskPrioritySet+0xe4>
						{
							xYieldRequired = pdTRUE;
c0003094:	00100793          	li	a5,1
c0003098:	fef42623          	sw	a5,-20(s0)
c000309c:	0200006f          	j	c00030bc <vTaskPrioritySet+0xe4>
						/* The priority of the running task is being raised,
						but the running task must already be the highest
						priority task able to run so no yield is required. */
					}
				}
				else if( pxTCB == pxCurrentTCB )
c00030a0:	07fff797          	auipc	a5,0x7fff
c00030a4:	7ec78793          	addi	a5,a5,2028 # c800288c <pxCurrentTCB>
c00030a8:	0007a783          	lw	a5,0(a5)
c00030ac:	fe842703          	lw	a4,-24(s0)
c00030b0:	00f71663          	bne	a4,a5,c00030bc <vTaskPrioritySet+0xe4>
				{
					/* Setting the priority of the running task down means
					there may now be another task of higher priority that
					is ready to execute. */
					xYieldRequired = pdTRUE;
c00030b4:	00100793          	li	a5,1
c00030b8:	fef42623          	sw	a5,-20(s0)
				}

				/* Remember the ready list the task might be referenced from
				before its uxPriority member is changed so the
				taskRESET_READY_PRIORITY() macro can function correctly. */
				uxPriorityUsedOnEntry = pxTCB->uxPriority;
c00030bc:	fe842783          	lw	a5,-24(s0)
c00030c0:	02c7a783          	lw	a5,44(a5)
c00030c4:	fef42023          	sw	a5,-32(s0)

				#if ( configUSE_MUTEXES == 1 )
				{
					/* Only change the priority being used if the task is not
					currently using an inherited priority. */
					if( pxTCB->uxBasePriority == pxTCB->uxPriority )
c00030c8:	fe842783          	lw	a5,-24(s0)
c00030cc:	0547a703          	lw	a4,84(a5)
c00030d0:	fe842783          	lw	a5,-24(s0)
c00030d4:	02c7a783          	lw	a5,44(a5)
c00030d8:	00f71863          	bne	a4,a5,c00030e8 <vTaskPrioritySet+0x110>
					{
						pxTCB->uxPriority = uxNewPriority;
c00030dc:	fe842783          	lw	a5,-24(s0)
c00030e0:	fd842703          	lw	a4,-40(s0)
c00030e4:	02e7a623          	sw	a4,44(a5)
					{
						mtCOVERAGE_TEST_MARKER();
					}

					/* The base priority gets set whatever. */
					pxTCB->uxBasePriority = uxNewPriority;
c00030e8:	fe842783          	lw	a5,-24(s0)
c00030ec:	fd842703          	lw	a4,-40(s0)
c00030f0:	04e7aa23          	sw	a4,84(a5)
				}
				#endif

				/* Only reset the event list item value if the value is not
				being used for anything else. */
				if( ( listGET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ) ) & taskEVENT_LIST_ITEM_VALUE_IN_USE ) == 0UL )
c00030f4:	fe842783          	lw	a5,-24(s0)
c00030f8:	0187a783          	lw	a5,24(a5)
c00030fc:	0007cc63          	bltz	a5,c0003114 <vTaskPrioritySet+0x13c>
				{
					listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) uxNewPriority ) ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
c0003100:	00500713          	li	a4,5
c0003104:	fd842783          	lw	a5,-40(s0)
c0003108:	40f70733          	sub	a4,a4,a5
c000310c:	fe842783          	lw	a5,-24(s0)
c0003110:	00e7ac23          	sw	a4,24(a5)

				/* If the task is in the blocked or suspended list we need do
				nothing more than change its priority variable. However, if
				the task is in a ready list it needs to be removed and placed
				in the list appropriate to its new priority. */
				if( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ uxPriorityUsedOnEntry ] ), &( pxTCB->xStateListItem ) ) != pdFALSE )
c0003114:	fe842783          	lw	a5,-24(s0)
c0003118:	0147a683          	lw	a3,20(a5)
c000311c:	fe042703          	lw	a4,-32(s0)
c0003120:	00070793          	mv	a5,a4
c0003124:	00279793          	slli	a5,a5,0x2
c0003128:	00e787b3          	add	a5,a5,a4
c000312c:	00279793          	slli	a5,a5,0x2
c0003130:	08000717          	auipc	a4,0x8000
c0003134:	41870713          	addi	a4,a4,1048 # c8003548 <pxReadyTasksLists>
c0003138:	00e787b3          	add	a5,a5,a4
c000313c:	0af69663          	bne	a3,a5,c00031e8 <vTaskPrioritySet+0x210>
				{
					/* The task is currently in its ready list - remove before
					adding it to it's new ready list.  As we are in a critical
					section we can do this even if the scheduler is suspended. */
					if( uxListRemove( &( pxTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
c0003140:	fe842783          	lw	a5,-24(s0)
c0003144:	00478793          	addi	a5,a5,4
c0003148:	00078513          	mv	a0,a5
c000314c:	f60fd0ef          	jal	ra,c00008ac <uxListRemove>
c0003150:	00050793          	mv	a5,a0
c0003154:	02079863          	bnez	a5,c0003184 <vTaskPrioritySet+0x1ac>
					{
						/* It is known that the task is in its ready list so
						there is no need to check again and the port level
						reset macro can be called directly. */
						portRESET_READY_PRIORITY( uxPriorityUsedOnEntry, uxTopReadyPriority );
c0003158:	fe042783          	lw	a5,-32(s0)
c000315c:	00100713          	li	a4,1
c0003160:	00f717b3          	sll	a5,a4,a5
c0003164:	fff7c713          	not	a4,a5
c0003168:	08000797          	auipc	a5,0x8000
c000316c:	4bc78793          	addi	a5,a5,1212 # c8003624 <uxTopReadyPriority>
c0003170:	0007a783          	lw	a5,0(a5)
c0003174:	00f77733          	and	a4,a4,a5
c0003178:	08000797          	auipc	a5,0x8000
c000317c:	4ac78793          	addi	a5,a5,1196 # c8003624 <uxTopReadyPriority>
c0003180:	00e7a023          	sw	a4,0(a5)
					}
					else
					{
						mtCOVERAGE_TEST_MARKER();
					}
					prvAddTaskToReadyList( pxTCB );
c0003184:	fe842783          	lw	a5,-24(s0)
c0003188:	02c7a783          	lw	a5,44(a5)
c000318c:	00100713          	li	a4,1
c0003190:	00f71733          	sll	a4,a4,a5
c0003194:	08000797          	auipc	a5,0x8000
c0003198:	49078793          	addi	a5,a5,1168 # c8003624 <uxTopReadyPriority>
c000319c:	0007a783          	lw	a5,0(a5)
c00031a0:	00f76733          	or	a4,a4,a5
c00031a4:	08000797          	auipc	a5,0x8000
c00031a8:	48078793          	addi	a5,a5,1152 # c8003624 <uxTopReadyPriority>
c00031ac:	00e7a023          	sw	a4,0(a5)
c00031b0:	fe842783          	lw	a5,-24(s0)
c00031b4:	02c7a703          	lw	a4,44(a5)
c00031b8:	00070793          	mv	a5,a4
c00031bc:	00279793          	slli	a5,a5,0x2
c00031c0:	00e787b3          	add	a5,a5,a4
c00031c4:	00279793          	slli	a5,a5,0x2
c00031c8:	08000717          	auipc	a4,0x8000
c00031cc:	38070713          	addi	a4,a4,896 # c8003548 <pxReadyTasksLists>
c00031d0:	00e78733          	add	a4,a5,a4
c00031d4:	fe842783          	lw	a5,-24(s0)
c00031d8:	00478793          	addi	a5,a5,4
c00031dc:	00078593          	mv	a1,a5
c00031e0:	00070513          	mv	a0,a4
c00031e4:	d6cfd0ef          	jal	ra,c0000750 <vListInsertEnd>
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}

				if( xYieldRequired != pdFALSE )
c00031e8:	fec42783          	lw	a5,-20(s0)
c00031ec:	00078463          	beqz	a5,c00031f4 <vTaskPrioritySet+0x21c>
				{
					taskYIELD_IF_USING_PREEMPTION();
c00031f0:	00000073          	ecall
				/* Remove compiler warning about unused variables when the port
				optimised task selection is not being used. */
				( void ) uxPriorityUsedOnEntry;
			}
		}
		taskEXIT_CRITICAL();
c00031f4:	7a0020ef          	jal	ra,c0005994 <vTaskExitCritical>
	}
c00031f8:	00000013          	nop
c00031fc:	02c12083          	lw	ra,44(sp)
c0003200:	02812403          	lw	s0,40(sp)
c0003204:	03010113          	addi	sp,sp,48
c0003208:	00008067          	ret

c000320c <vTaskSuspend>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskSuspend == 1 )

	void vTaskSuspend( TaskHandle_t xTaskToSuspend )
	{
c000320c:	fd010113          	addi	sp,sp,-48
c0003210:	02112623          	sw	ra,44(sp)
c0003214:	02812423          	sw	s0,40(sp)
c0003218:	03010413          	addi	s0,sp,48
c000321c:	fca42e23          	sw	a0,-36(s0)
	TCB_t *pxTCB;

		taskENTER_CRITICAL();
c0003220:	720020ef          	jal	ra,c0005940 <vTaskEnterCritical>
		{
			/* If null is passed in here then it is the running task that is
			being suspended. */
			pxTCB = prvGetTCBFromHandle( xTaskToSuspend );
c0003224:	fdc42783          	lw	a5,-36(s0)
c0003228:	00079a63          	bnez	a5,c000323c <vTaskSuspend+0x30>
c000322c:	07fff797          	auipc	a5,0x7fff
c0003230:	66078793          	addi	a5,a5,1632 # c800288c <pxCurrentTCB>
c0003234:	0007a783          	lw	a5,0(a5)
c0003238:	0080006f          	j	c0003240 <vTaskSuspend+0x34>
c000323c:	fdc42783          	lw	a5,-36(s0)
c0003240:	fef42623          	sw	a5,-20(s0)

			traceTASK_SUSPEND( pxTCB );

			/* Remove task from the ready/delayed list and place in the
			suspended list. */
			if( uxListRemove( &( pxTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
c0003244:	fec42783          	lw	a5,-20(s0)
c0003248:	00478793          	addi	a5,a5,4
c000324c:	00078513          	mv	a0,a5
c0003250:	e5cfd0ef          	jal	ra,c00008ac <uxListRemove>
c0003254:	00050793          	mv	a5,a0
c0003258:	06079063          	bnez	a5,c00032b8 <vTaskSuspend+0xac>
			{
				taskRESET_READY_PRIORITY( pxTCB->uxPriority );
c000325c:	fec42783          	lw	a5,-20(s0)
c0003260:	02c7a703          	lw	a4,44(a5)
c0003264:	08000697          	auipc	a3,0x8000
c0003268:	2e468693          	addi	a3,a3,740 # c8003548 <pxReadyTasksLists>
c000326c:	00070793          	mv	a5,a4
c0003270:	00279793          	slli	a5,a5,0x2
c0003274:	00e787b3          	add	a5,a5,a4
c0003278:	00279793          	slli	a5,a5,0x2
c000327c:	00f687b3          	add	a5,a3,a5
c0003280:	0007a783          	lw	a5,0(a5)
c0003284:	02079a63          	bnez	a5,c00032b8 <vTaskSuspend+0xac>
c0003288:	fec42783          	lw	a5,-20(s0)
c000328c:	02c7a783          	lw	a5,44(a5)
c0003290:	00100713          	li	a4,1
c0003294:	00f717b3          	sll	a5,a4,a5
c0003298:	fff7c713          	not	a4,a5
c000329c:	08000797          	auipc	a5,0x8000
c00032a0:	38878793          	addi	a5,a5,904 # c8003624 <uxTopReadyPriority>
c00032a4:	0007a783          	lw	a5,0(a5)
c00032a8:	00f77733          	and	a4,a4,a5
c00032ac:	08000797          	auipc	a5,0x8000
c00032b0:	37878793          	addi	a5,a5,888 # c8003624 <uxTopReadyPriority>
c00032b4:	00e7a023          	sw	a4,0(a5)
			{
				mtCOVERAGE_TEST_MARKER();
			}

			/* Is the task waiting on an event also? */
			if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
c00032b8:	fec42783          	lw	a5,-20(s0)
c00032bc:	0287a783          	lw	a5,40(a5)
c00032c0:	00078a63          	beqz	a5,c00032d4 <vTaskSuspend+0xc8>
			{
				( void ) uxListRemove( &( pxTCB->xEventListItem ) );
c00032c4:	fec42783          	lw	a5,-20(s0)
c00032c8:	01878793          	addi	a5,a5,24
c00032cc:	00078513          	mv	a0,a5
c00032d0:	ddcfd0ef          	jal	ra,c00008ac <uxListRemove>
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}

			vListInsertEnd( &xSuspendedTaskList, &( pxTCB->xStateListItem ) );
c00032d4:	fec42783          	lw	a5,-20(s0)
c00032d8:	00478793          	addi	a5,a5,4
c00032dc:	00078593          	mv	a1,a5
c00032e0:	08000517          	auipc	a0,0x8000
c00032e4:	32850513          	addi	a0,a0,808 # c8003608 <xSuspendedTaskList>
c00032e8:	c68fd0ef          	jal	ra,c0000750 <vListInsertEnd>

			#if( configUSE_TASK_NOTIFICATIONS == 1 )
			{
				if( pxTCB->ucNotifyState == taskWAITING_NOTIFICATION )
c00032ec:	fec42783          	lw	a5,-20(s0)
c00032f0:	0607c783          	lbu	a5,96(a5)
c00032f4:	0ff7f713          	andi	a4,a5,255
c00032f8:	00100793          	li	a5,1
c00032fc:	00f71663          	bne	a4,a5,c0003308 <vTaskSuspend+0xfc>
				{
					/* The task was blocked to wait for a notification, but is
					now suspended, so no notification was received. */
					pxTCB->ucNotifyState = taskNOT_WAITING_NOTIFICATION;
c0003300:	fec42783          	lw	a5,-20(s0)
c0003304:	06078023          	sb	zero,96(a5)
				}
			}
			#endif
		}
		taskEXIT_CRITICAL();
c0003308:	68c020ef          	jal	ra,c0005994 <vTaskExitCritical>

		if( xSchedulerRunning != pdFALSE )
c000330c:	08000797          	auipc	a5,0x8000
c0003310:	31c78793          	addi	a5,a5,796 # c8003628 <xSchedulerRunning>
c0003314:	0007a783          	lw	a5,0(a5)
c0003318:	00078863          	beqz	a5,c0003328 <vTaskSuspend+0x11c>
		{
			/* Reset the next expected unblock time in case it referred to the
			task that is now in the Suspended state. */
			taskENTER_CRITICAL();
c000331c:	624020ef          	jal	ra,c0005940 <vTaskEnterCritical>
			{
				prvResetNextTaskUnblockTime();
c0003320:	7d5010ef          	jal	ra,c00052f4 <prvResetNextTaskUnblockTime>
			}
			taskEXIT_CRITICAL();
c0003324:	670020ef          	jal	ra,c0005994 <vTaskExitCritical>
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}

		if( pxTCB == pxCurrentTCB )
c0003328:	07fff797          	auipc	a5,0x7fff
c000332c:	56478793          	addi	a5,a5,1380 # c800288c <pxCurrentTCB>
c0003330:	0007a783          	lw	a5,0(a5)
c0003334:	fec42703          	lw	a4,-20(s0)
c0003338:	06f71463          	bne	a4,a5,c00033a0 <vTaskSuspend+0x194>
		{
			if( xSchedulerRunning != pdFALSE )
c000333c:	08000797          	auipc	a5,0x8000
c0003340:	2ec78793          	addi	a5,a5,748 # c8003628 <xSchedulerRunning>
c0003344:	0007a783          	lw	a5,0(a5)
c0003348:	02078463          	beqz	a5,c0003370 <vTaskSuspend+0x164>
			{
				/* The current task has just been suspended. */
				configASSERT( uxSchedulerSuspended == 0 );
c000334c:	08000797          	auipc	a5,0x8000
c0003350:	2f878793          	addi	a5,a5,760 # c8003644 <uxSchedulerSuspended>
c0003354:	0007a783          	lw	a5,0(a5)
c0003358:	00078863          	beqz	a5,c0003368 <vTaskSuspend+0x15c>
c000335c:	30047073          	csrci	mstatus,8
c0003360:	00100073          	ebreak
c0003364:	0000006f          	j	c0003364 <vTaskSuspend+0x158>
				portYIELD_WITHIN_API();
c0003368:	00000073          	ecall
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
c000336c:	0340006f          	j	c00033a0 <vTaskSuspend+0x194>
				if( listCURRENT_LIST_LENGTH( &xSuspendedTaskList ) == uxCurrentNumberOfTasks ) /*lint !e931 Right has no side effect, just volatile. */
c0003370:	08000797          	auipc	a5,0x8000
c0003374:	29878793          	addi	a5,a5,664 # c8003608 <xSuspendedTaskList>
c0003378:	0007a703          	lw	a4,0(a5)
c000337c:	08000797          	auipc	a5,0x8000
c0003380:	2a078793          	addi	a5,a5,672 # c800361c <uxCurrentNumberOfTasks>
c0003384:	0007a783          	lw	a5,0(a5)
c0003388:	00f71a63          	bne	a4,a5,c000339c <vTaskSuspend+0x190>
					pxCurrentTCB = NULL;
c000338c:	07fff797          	auipc	a5,0x7fff
c0003390:	50078793          	addi	a5,a5,1280 # c800288c <pxCurrentTCB>
c0003394:	0007a023          	sw	zero,0(a5)
	}
c0003398:	0080006f          	j	c00033a0 <vTaskSuspend+0x194>
					vTaskSwitchContext();
c000339c:	1cc010ef          	jal	ra,c0004568 <vTaskSwitchContext>
	}
c00033a0:	00000013          	nop
c00033a4:	02c12083          	lw	ra,44(sp)
c00033a8:	02812403          	lw	s0,40(sp)
c00033ac:	03010113          	addi	sp,sp,48
c00033b0:	00008067          	ret

c00033b4 <prvTaskIsTaskSuspended>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskSuspend == 1 )

	static BaseType_t prvTaskIsTaskSuspended( const TaskHandle_t xTask )
	{
c00033b4:	fd010113          	addi	sp,sp,-48
c00033b8:	02812623          	sw	s0,44(sp)
c00033bc:	03010413          	addi	s0,sp,48
c00033c0:	fca42e23          	sw	a0,-36(s0)
	BaseType_t xReturn = pdFALSE;
c00033c4:	fe042623          	sw	zero,-20(s0)
	const TCB_t * const pxTCB = xTask;
c00033c8:	fdc42783          	lw	a5,-36(s0)
c00033cc:	fef42423          	sw	a5,-24(s0)

		/* Accesses xPendingReadyList so must be called from a critical
		section. */

		/* It does not make sense to check if the calling task is suspended. */
		configASSERT( xTask );
c00033d0:	fdc42783          	lw	a5,-36(s0)
c00033d4:	00079863          	bnez	a5,c00033e4 <prvTaskIsTaskSuspended+0x30>
c00033d8:	30047073          	csrci	mstatus,8
c00033dc:	00100073          	ebreak
c00033e0:	0000006f          	j	c00033e0 <prvTaskIsTaskSuspended+0x2c>

		/* Is the task being resumed actually in the suspended list? */
		if( listIS_CONTAINED_WITHIN( &xSuspendedTaskList, &( pxTCB->xStateListItem ) ) != pdFALSE )
c00033e4:	fe842783          	lw	a5,-24(s0)
c00033e8:	0147a703          	lw	a4,20(a5)
c00033ec:	08000797          	auipc	a5,0x8000
c00033f0:	21c78793          	addi	a5,a5,540 # c8003608 <xSuspendedTaskList>
c00033f4:	02f71663          	bne	a4,a5,c0003420 <prvTaskIsTaskSuspended+0x6c>
		{
			/* Has the task already been resumed from within an ISR? */
			if( listIS_CONTAINED_WITHIN( &xPendingReadyList, &( pxTCB->xEventListItem ) ) == pdFALSE )
c00033f8:	fe842783          	lw	a5,-24(s0)
c00033fc:	0287a703          	lw	a4,40(a5)
c0003400:	08000797          	auipc	a5,0x8000
c0003404:	1dc78793          	addi	a5,a5,476 # c80035dc <xPendingReadyList>
c0003408:	00f70c63          	beq	a4,a5,c0003420 <prvTaskIsTaskSuspended+0x6c>
			{
				/* Is it in the suspended list because it is in the	Suspended
				state, or because is is blocked with no timeout? */
				if( listIS_CONTAINED_WITHIN( NULL, &( pxTCB->xEventListItem ) ) != pdFALSE ) /*lint !e961.  The cast is only redundant when NULL is used. */
c000340c:	fe842783          	lw	a5,-24(s0)
c0003410:	0287a783          	lw	a5,40(a5)
c0003414:	00079663          	bnez	a5,c0003420 <prvTaskIsTaskSuspended+0x6c>
				{
					xReturn = pdTRUE;
c0003418:	00100793          	li	a5,1
c000341c:	fef42623          	sw	a5,-20(s0)
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}

		return xReturn;
c0003420:	fec42783          	lw	a5,-20(s0)
	} /*lint !e818 xTask cannot be a pointer to const because it is a typedef. */
c0003424:	00078513          	mv	a0,a5
c0003428:	02c12403          	lw	s0,44(sp)
c000342c:	03010113          	addi	sp,sp,48
c0003430:	00008067          	ret

c0003434 <vTaskResume>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskSuspend == 1 )

	void vTaskResume( TaskHandle_t xTaskToResume )
	{
c0003434:	fd010113          	addi	sp,sp,-48
c0003438:	02112623          	sw	ra,44(sp)
c000343c:	02812423          	sw	s0,40(sp)
c0003440:	03010413          	addi	s0,sp,48
c0003444:	fca42e23          	sw	a0,-36(s0)
	TCB_t * const pxTCB = xTaskToResume;
c0003448:	fdc42783          	lw	a5,-36(s0)
c000344c:	fef42623          	sw	a5,-20(s0)

		/* It does not make sense to resume the calling task. */
		configASSERT( xTaskToResume );
c0003450:	fdc42783          	lw	a5,-36(s0)
c0003454:	00079863          	bnez	a5,c0003464 <vTaskResume+0x30>
c0003458:	30047073          	csrci	mstatus,8
c000345c:	00100073          	ebreak
c0003460:	0000006f          	j	c0003460 <vTaskResume+0x2c>

		/* The parameter cannot be NULL as it is impossible to resume the
		currently executing task. */
		if( ( pxTCB != pxCurrentTCB ) && ( pxTCB != NULL ) )
c0003464:	07fff797          	auipc	a5,0x7fff
c0003468:	42878793          	addi	a5,a5,1064 # c800288c <pxCurrentTCB>
c000346c:	0007a783          	lw	a5,0(a5)
c0003470:	fec42703          	lw	a4,-20(s0)
c0003474:	0af70c63          	beq	a4,a5,c000352c <vTaskResume+0xf8>
c0003478:	fec42783          	lw	a5,-20(s0)
c000347c:	0a078863          	beqz	a5,c000352c <vTaskResume+0xf8>
		{
			taskENTER_CRITICAL();
c0003480:	4c0020ef          	jal	ra,c0005940 <vTaskEnterCritical>
			{
				if( prvTaskIsTaskSuspended( pxTCB ) != pdFALSE )
c0003484:	fec42503          	lw	a0,-20(s0)
c0003488:	f2dff0ef          	jal	ra,c00033b4 <prvTaskIsTaskSuspended>
c000348c:	00050793          	mv	a5,a0
c0003490:	08078c63          	beqz	a5,c0003528 <vTaskResume+0xf4>
				{
					traceTASK_RESUME( pxTCB );

					/* The ready list can be accessed even if the scheduler is
					suspended because this is inside a critical section. */
					( void ) uxListRemove(  &( pxTCB->xStateListItem ) );
c0003494:	fec42783          	lw	a5,-20(s0)
c0003498:	00478793          	addi	a5,a5,4
c000349c:	00078513          	mv	a0,a5
c00034a0:	c0cfd0ef          	jal	ra,c00008ac <uxListRemove>
					prvAddTaskToReadyList( pxTCB );
c00034a4:	fec42783          	lw	a5,-20(s0)
c00034a8:	02c7a783          	lw	a5,44(a5)
c00034ac:	00100713          	li	a4,1
c00034b0:	00f71733          	sll	a4,a4,a5
c00034b4:	08000797          	auipc	a5,0x8000
c00034b8:	17078793          	addi	a5,a5,368 # c8003624 <uxTopReadyPriority>
c00034bc:	0007a783          	lw	a5,0(a5)
c00034c0:	00f76733          	or	a4,a4,a5
c00034c4:	08000797          	auipc	a5,0x8000
c00034c8:	16078793          	addi	a5,a5,352 # c8003624 <uxTopReadyPriority>
c00034cc:	00e7a023          	sw	a4,0(a5)
c00034d0:	fec42783          	lw	a5,-20(s0)
c00034d4:	02c7a703          	lw	a4,44(a5)
c00034d8:	00070793          	mv	a5,a4
c00034dc:	00279793          	slli	a5,a5,0x2
c00034e0:	00e787b3          	add	a5,a5,a4
c00034e4:	00279793          	slli	a5,a5,0x2
c00034e8:	08000717          	auipc	a4,0x8000
c00034ec:	06070713          	addi	a4,a4,96 # c8003548 <pxReadyTasksLists>
c00034f0:	00e78733          	add	a4,a5,a4
c00034f4:	fec42783          	lw	a5,-20(s0)
c00034f8:	00478793          	addi	a5,a5,4
c00034fc:	00078593          	mv	a1,a5
c0003500:	00070513          	mv	a0,a4
c0003504:	a4cfd0ef          	jal	ra,c0000750 <vListInsertEnd>

					/* A higher priority task may have just been resumed. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
c0003508:	fec42783          	lw	a5,-20(s0)
c000350c:	02c7a703          	lw	a4,44(a5)
c0003510:	07fff797          	auipc	a5,0x7fff
c0003514:	37c78793          	addi	a5,a5,892 # c800288c <pxCurrentTCB>
c0003518:	0007a783          	lw	a5,0(a5)
c000351c:	02c7a783          	lw	a5,44(a5)
c0003520:	00f76463          	bltu	a4,a5,c0003528 <vTaskResume+0xf4>
					{
						/* This yield may not cause the task just resumed to run,
						but will leave the lists in the correct state for the
						next yield. */
						taskYIELD_IF_USING_PREEMPTION();
c0003524:	00000073          	ecall
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}
			}
			taskEXIT_CRITICAL();
c0003528:	46c020ef          	jal	ra,c0005994 <vTaskExitCritical>
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
c000352c:	00000013          	nop
c0003530:	02c12083          	lw	ra,44(sp)
c0003534:	02812403          	lw	s0,40(sp)
c0003538:	03010113          	addi	sp,sp,48
c000353c:	00008067          	ret

c0003540 <xTaskResumeFromISR>:
/*-----------------------------------------------------------*/

#if ( ( INCLUDE_xTaskResumeFromISR == 1 ) && ( INCLUDE_vTaskSuspend == 1 ) )

	BaseType_t xTaskResumeFromISR( TaskHandle_t xTaskToResume )
	{
c0003540:	fd010113          	addi	sp,sp,-48
c0003544:	02112623          	sw	ra,44(sp)
c0003548:	02812423          	sw	s0,40(sp)
c000354c:	03010413          	addi	s0,sp,48
c0003550:	fca42e23          	sw	a0,-36(s0)
	BaseType_t xYieldRequired = pdFALSE;
c0003554:	fe042623          	sw	zero,-20(s0)
	TCB_t * const pxTCB = xTaskToResume;
c0003558:	fdc42783          	lw	a5,-36(s0)
c000355c:	fef42423          	sw	a5,-24(s0)
	UBaseType_t uxSavedInterruptStatus;

		configASSERT( xTaskToResume );
c0003560:	fdc42783          	lw	a5,-36(s0)
c0003564:	00079863          	bnez	a5,c0003574 <xTaskResumeFromISR+0x34>
c0003568:	30047073          	csrci	mstatus,8
c000356c:	00100073          	ebreak
c0003570:	0000006f          	j	c0003570 <xTaskResumeFromISR+0x30>
		simple as possible.  More information (albeit Cortex-M specific) is
		provided on the following link:
		https://www.freertos.org/RTOS-Cortex-M3-M4.html */
		portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

		uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
c0003574:	fe042223          	sw	zero,-28(s0)
		{
			if( prvTaskIsTaskSuspended( pxTCB ) != pdFALSE )
c0003578:	fe842503          	lw	a0,-24(s0)
c000357c:	e39ff0ef          	jal	ra,c00033b4 <prvTaskIsTaskSuspended>
c0003580:	00050793          	mv	a5,a0
c0003584:	0c078463          	beqz	a5,c000364c <xTaskResumeFromISR+0x10c>
			{
				traceTASK_RESUME_FROM_ISR( pxTCB );

				/* Check the ready lists can be accessed. */
				if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
c0003588:	08000797          	auipc	a5,0x8000
c000358c:	0bc78793          	addi	a5,a5,188 # c8003644 <uxSchedulerSuspended>
c0003590:	0007a783          	lw	a5,0(a5)
c0003594:	0a079063          	bnez	a5,c0003634 <xTaskResumeFromISR+0xf4>
				{
					/* Ready lists can be accessed so move the task from the
					suspended list to the ready list directly. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
c0003598:	fe842783          	lw	a5,-24(s0)
c000359c:	02c7a703          	lw	a4,44(a5)
c00035a0:	07fff797          	auipc	a5,0x7fff
c00035a4:	2ec78793          	addi	a5,a5,748 # c800288c <pxCurrentTCB>
c00035a8:	0007a783          	lw	a5,0(a5)
c00035ac:	02c7a783          	lw	a5,44(a5)
c00035b0:	00f76663          	bltu	a4,a5,c00035bc <xTaskResumeFromISR+0x7c>
					{
						xYieldRequired = pdTRUE;
c00035b4:	00100793          	li	a5,1
c00035b8:	fef42623          	sw	a5,-20(s0)
					else
					{
						mtCOVERAGE_TEST_MARKER();
					}

					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
c00035bc:	fe842783          	lw	a5,-24(s0)
c00035c0:	00478793          	addi	a5,a5,4
c00035c4:	00078513          	mv	a0,a5
c00035c8:	ae4fd0ef          	jal	ra,c00008ac <uxListRemove>
					prvAddTaskToReadyList( pxTCB );
c00035cc:	fe842783          	lw	a5,-24(s0)
c00035d0:	02c7a783          	lw	a5,44(a5)
c00035d4:	00100713          	li	a4,1
c00035d8:	00f71733          	sll	a4,a4,a5
c00035dc:	08000797          	auipc	a5,0x8000
c00035e0:	04878793          	addi	a5,a5,72 # c8003624 <uxTopReadyPriority>
c00035e4:	0007a783          	lw	a5,0(a5)
c00035e8:	00f76733          	or	a4,a4,a5
c00035ec:	08000797          	auipc	a5,0x8000
c00035f0:	03878793          	addi	a5,a5,56 # c8003624 <uxTopReadyPriority>
c00035f4:	00e7a023          	sw	a4,0(a5)
c00035f8:	fe842783          	lw	a5,-24(s0)
c00035fc:	02c7a703          	lw	a4,44(a5)
c0003600:	00070793          	mv	a5,a4
c0003604:	00279793          	slli	a5,a5,0x2
c0003608:	00e787b3          	add	a5,a5,a4
c000360c:	00279793          	slli	a5,a5,0x2
c0003610:	08000717          	auipc	a4,0x8000
c0003614:	f3870713          	addi	a4,a4,-200 # c8003548 <pxReadyTasksLists>
c0003618:	00e78733          	add	a4,a5,a4
c000361c:	fe842783          	lw	a5,-24(s0)
c0003620:	00478793          	addi	a5,a5,4
c0003624:	00078593          	mv	a1,a5
c0003628:	00070513          	mv	a0,a4
c000362c:	924fd0ef          	jal	ra,c0000750 <vListInsertEnd>
c0003630:	01c0006f          	j	c000364c <xTaskResumeFromISR+0x10c>
				else
				{
					/* The delayed or ready lists cannot be accessed so the task
					is held in the pending ready list until the scheduler is
					unsuspended. */
					vListInsertEnd( &( xPendingReadyList ), &( pxTCB->xEventListItem ) );
c0003634:	fe842783          	lw	a5,-24(s0)
c0003638:	01878793          	addi	a5,a5,24
c000363c:	00078593          	mv	a1,a5
c0003640:	08000517          	auipc	a0,0x8000
c0003644:	f9c50513          	addi	a0,a0,-100 # c80035dc <xPendingReadyList>
c0003648:	908fd0ef          	jal	ra,c0000750 <vListInsertEnd>
				mtCOVERAGE_TEST_MARKER();
			}
		}
		portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

		return xYieldRequired;
c000364c:	fec42783          	lw	a5,-20(s0)
	}
c0003650:	00078513          	mv	a0,a5
c0003654:	02c12083          	lw	ra,44(sp)
c0003658:	02812403          	lw	s0,40(sp)
c000365c:	03010113          	addi	sp,sp,48
c0003660:	00008067          	ret

c0003664 <vTaskStartScheduler>:

#endif /* ( ( INCLUDE_xTaskResumeFromISR == 1 ) && ( INCLUDE_vTaskSuspend == 1 ) ) */
/*-----------------------------------------------------------*/

void vTaskStartScheduler( void )
{
c0003664:	fe010113          	addi	sp,sp,-32
c0003668:	00112e23          	sw	ra,28(sp)
c000366c:	00812c23          	sw	s0,24(sp)
c0003670:	02010413          	addi	s0,sp,32
		}
	}
	#else
	{
		/* The Idle task is being created using dynamically allocated RAM. */
		xReturn = xTaskCreate(	prvIdleTask,
c0003674:	08000797          	auipc	a5,0x8000
c0003678:	fcc78793          	addi	a5,a5,-52 # c8003640 <xIdleTaskHandle>
c000367c:	00000713          	li	a4,0
c0003680:	00000693          	li	a3,0
c0003684:	20000613          	li	a2,512
c0003688:	07ffd597          	auipc	a1,0x7ffd
c000368c:	97858593          	addi	a1,a1,-1672 # c8000000 <__rodata_start>
c0003690:	00001517          	auipc	a0,0x1
c0003694:	72c50513          	addi	a0,a0,1836 # c0004dbc <prvIdleTask>
c0003698:	f91fe0ef          	jal	ra,c0002628 <xTaskCreate>
c000369c:	fea42623          	sw	a0,-20(s0)
	}
	#endif /* configSUPPORT_STATIC_ALLOCATION */

	#if ( configUSE_TIMERS == 1 )
	{
		if( xReturn == pdPASS )
c00036a0:	fec42703          	lw	a4,-20(s0)
c00036a4:	00100793          	li	a5,1
c00036a8:	00f71663          	bne	a4,a5,c00036b4 <vTaskStartScheduler+0x50>
		{
			xReturn = xTimerCreateTimerTask();
c00036ac:	124030ef          	jal	ra,c00067d0 <xTimerCreateTimerTask>
c00036b0:	fea42623          	sw	a0,-20(s0)
			mtCOVERAGE_TEST_MARKER();
		}
	}
	#endif /* configUSE_TIMERS */

	if( xReturn == pdPASS )
c00036b4:	fec42703          	lw	a4,-20(s0)
c00036b8:	00100793          	li	a5,1
c00036bc:	02f71e63          	bne	a4,a5,c00036f8 <vTaskStartScheduler+0x94>
		/* Interrupts are turned off here, to ensure a tick does not occur
		before or during the call to xPortStartScheduler().  The stacks of
		the created tasks contain a status word with interrupts switched on
		so interrupts will automatically get re-enabled when the first task
		starts to run. */
		portDISABLE_INTERRUPTS();
c00036c0:	30047073          	csrci	mstatus,8
			for additional information. */
			_impure_ptr = &( pxCurrentTCB->xNewLib_reent );
		}
		#endif /* configUSE_NEWLIB_REENTRANT */

		xNextTaskUnblockTime = portMAX_DELAY;
c00036c4:	08000797          	auipc	a5,0x8000
c00036c8:	f7878793          	addi	a5,a5,-136 # c800363c <xNextTaskUnblockTime>
c00036cc:	fff00713          	li	a4,-1
c00036d0:	00e7a023          	sw	a4,0(a5)
		xSchedulerRunning = pdTRUE;
c00036d4:	08000797          	auipc	a5,0x8000
c00036d8:	f5478793          	addi	a5,a5,-172 # c8003628 <xSchedulerRunning>
c00036dc:	00100713          	li	a4,1
c00036e0:	00e7a023          	sw	a4,0(a5)
		xTickCount = ( TickType_t ) configINITIAL_TICK_COUNT;
c00036e4:	08000797          	auipc	a5,0x8000
c00036e8:	f3c78793          	addi	a5,a5,-196 # c8003620 <xTickCount>
c00036ec:	0007a023          	sw	zero,0(a5)

		traceTASK_SWITCHED_IN();

		/* Setting up the timer tick is hardware specific and thus in the
		portable interface. */
		if( xPortStartScheduler() != pdFALSE )
c00036f0:	f45fc0ef          	jal	ra,c0000634 <xPortStartScheduler>
	}

	/* Prevent compiler warnings if INCLUDE_xTaskGetIdleTaskHandle is set to 0,
	meaning xIdleTaskHandle is not used anywhere else. */
	( void ) xIdleTaskHandle;
}
c00036f4:	01c0006f          	j	c0003710 <vTaskStartScheduler+0xac>
		configASSERT( xReturn != errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY );
c00036f8:	fec42703          	lw	a4,-20(s0)
c00036fc:	fff00793          	li	a5,-1
c0003700:	00f71863          	bne	a4,a5,c0003710 <vTaskStartScheduler+0xac>
c0003704:	30047073          	csrci	mstatus,8
c0003708:	00100073          	ebreak
c000370c:	0000006f          	j	c000370c <vTaskStartScheduler+0xa8>
}
c0003710:	00000013          	nop
c0003714:	01c12083          	lw	ra,28(sp)
c0003718:	01812403          	lw	s0,24(sp)
c000371c:	02010113          	addi	sp,sp,32
c0003720:	00008067          	ret

c0003724 <vTaskEndScheduler>:
/*-----------------------------------------------------------*/

void vTaskEndScheduler( void )
{
c0003724:	ff010113          	addi	sp,sp,-16
c0003728:	00112623          	sw	ra,12(sp)
c000372c:	00812423          	sw	s0,8(sp)
c0003730:	01010413          	addi	s0,sp,16
	/* Stop the scheduler interrupts and call the portable scheduler end
	routine so the original ISRs can be restored if necessary.  The port
	layer must ensure interrupts enable	bit is left in the correct state. */
	portDISABLE_INTERRUPTS();
c0003734:	30047073          	csrci	mstatus,8
	xSchedulerRunning = pdFALSE;
c0003738:	08000797          	auipc	a5,0x8000
c000373c:	ef078793          	addi	a5,a5,-272 # c8003628 <xSchedulerRunning>
c0003740:	0007a023          	sw	zero,0(a5)
	vPortEndScheduler();
c0003744:	f71fc0ef          	jal	ra,c00006b4 <vPortEndScheduler>
}
c0003748:	00000013          	nop
c000374c:	00c12083          	lw	ra,12(sp)
c0003750:	00812403          	lw	s0,8(sp)
c0003754:	01010113          	addi	sp,sp,16
c0003758:	00008067          	ret

c000375c <vTaskSuspendAll>:
/*----------------------------------------------------------*/

void vTaskSuspendAll( void )
{
c000375c:	ff010113          	addi	sp,sp,-16
c0003760:	00812623          	sw	s0,12(sp)
c0003764:	01010413          	addi	s0,sp,16
	/* A critical section is not required as the variable is of type
	BaseType_t.  Please read Richard Barry's reply in the following link to a
	post in the FreeRTOS support forum before reporting this as a bug! -
	http://goo.gl/wu4acr */
	++uxSchedulerSuspended;
c0003768:	08000797          	auipc	a5,0x8000
c000376c:	edc78793          	addi	a5,a5,-292 # c8003644 <uxSchedulerSuspended>
c0003770:	0007a783          	lw	a5,0(a5)
c0003774:	00178713          	addi	a4,a5,1
c0003778:	08000797          	auipc	a5,0x8000
c000377c:	ecc78793          	addi	a5,a5,-308 # c8003644 <uxSchedulerSuspended>
c0003780:	00e7a023          	sw	a4,0(a5)
	portMEMORY_BARRIER();
}
c0003784:	00000013          	nop
c0003788:	00c12403          	lw	s0,12(sp)
c000378c:	01010113          	addi	sp,sp,16
c0003790:	00008067          	ret

c0003794 <xTaskResumeAll>:

#endif /* configUSE_TICKLESS_IDLE */
/*----------------------------------------------------------*/

BaseType_t xTaskResumeAll( void )
{
c0003794:	fe010113          	addi	sp,sp,-32
c0003798:	00112e23          	sw	ra,28(sp)
c000379c:	00812c23          	sw	s0,24(sp)
c00037a0:	02010413          	addi	s0,sp,32
TCB_t *pxTCB = NULL;
c00037a4:	fe042623          	sw	zero,-20(s0)
BaseType_t xAlreadyYielded = pdFALSE;
c00037a8:	fe042423          	sw	zero,-24(s0)
TickType_t xTicksToNextUnblockTime;

	/* If uxSchedulerSuspended is zero then this function does not match a
	previous call to vTaskSuspendAll(). */
	configASSERT( uxSchedulerSuspended );
c00037ac:	08000797          	auipc	a5,0x8000
c00037b0:	e9878793          	addi	a5,a5,-360 # c8003644 <uxSchedulerSuspended>
c00037b4:	0007a783          	lw	a5,0(a5)
c00037b8:	00079863          	bnez	a5,c00037c8 <xTaskResumeAll+0x34>
c00037bc:	30047073          	csrci	mstatus,8
c00037c0:	00100073          	ebreak
c00037c4:	0000006f          	j	c00037c4 <xTaskResumeAll+0x30>
	/* It is possible that an ISR caused a task to be removed from an event
	list while the scheduler was suspended.  If this was the case then the
	removed task will have been added to the xPendingReadyList.  Once the
	scheduler has been resumed it is safe to move all the pending ready
	tasks from this list into their appropriate ready list. */
	taskENTER_CRITICAL();
c00037c8:	178020ef          	jal	ra,c0005940 <vTaskEnterCritical>
	{
		--uxSchedulerSuspended;
c00037cc:	08000797          	auipc	a5,0x8000
c00037d0:	e7878793          	addi	a5,a5,-392 # c8003644 <uxSchedulerSuspended>
c00037d4:	0007a783          	lw	a5,0(a5)
c00037d8:	fff78713          	addi	a4,a5,-1
c00037dc:	08000797          	auipc	a5,0x8000
c00037e0:	e6878793          	addi	a5,a5,-408 # c8003644 <uxSchedulerSuspended>
c00037e4:	00e7a023          	sw	a4,0(a5)

		if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
c00037e8:	08000797          	auipc	a5,0x8000
c00037ec:	e5c78793          	addi	a5,a5,-420 # c8003644 <uxSchedulerSuspended>
c00037f0:	0007a783          	lw	a5,0(a5)
c00037f4:	20079e63          	bnez	a5,c0003a10 <xTaskResumeAll+0x27c>
		{
			if( uxCurrentNumberOfTasks > ( UBaseType_t ) 0U )
c00037f8:	08000797          	auipc	a5,0x8000
c00037fc:	e2478793          	addi	a5,a5,-476 # c800361c <uxCurrentNumberOfTasks>
c0003800:	0007a783          	lw	a5,0(a5)
c0003804:	20078663          	beqz	a5,c0003a10 <xTaskResumeAll+0x27c>
			{
				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( &xPendingReadyList ) == pdFALSE )
c0003808:	0c80006f          	j	c00038d0 <xTaskResumeAll+0x13c>
				{
					pxTCB = listGET_OWNER_OF_HEAD_ENTRY( ( &xPendingReadyList ) ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
c000380c:	08000797          	auipc	a5,0x8000
c0003810:	dd078793          	addi	a5,a5,-560 # c80035dc <xPendingReadyList>
c0003814:	00c7a783          	lw	a5,12(a5)
c0003818:	00c7a783          	lw	a5,12(a5)
c000381c:	fef42623          	sw	a5,-20(s0)
					( void ) uxListRemove( &( pxTCB->xEventListItem ) );
c0003820:	fec42783          	lw	a5,-20(s0)
c0003824:	01878793          	addi	a5,a5,24
c0003828:	00078513          	mv	a0,a5
c000382c:	880fd0ef          	jal	ra,c00008ac <uxListRemove>
					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
c0003830:	fec42783          	lw	a5,-20(s0)
c0003834:	00478793          	addi	a5,a5,4
c0003838:	00078513          	mv	a0,a5
c000383c:	870fd0ef          	jal	ra,c00008ac <uxListRemove>
					prvAddTaskToReadyList( pxTCB );
c0003840:	fec42783          	lw	a5,-20(s0)
c0003844:	02c7a783          	lw	a5,44(a5)
c0003848:	00100713          	li	a4,1
c000384c:	00f71733          	sll	a4,a4,a5
c0003850:	08000797          	auipc	a5,0x8000
c0003854:	dd478793          	addi	a5,a5,-556 # c8003624 <uxTopReadyPriority>
c0003858:	0007a783          	lw	a5,0(a5)
c000385c:	00f76733          	or	a4,a4,a5
c0003860:	08000797          	auipc	a5,0x8000
c0003864:	dc478793          	addi	a5,a5,-572 # c8003624 <uxTopReadyPriority>
c0003868:	00e7a023          	sw	a4,0(a5)
c000386c:	fec42783          	lw	a5,-20(s0)
c0003870:	02c7a703          	lw	a4,44(a5)
c0003874:	00070793          	mv	a5,a4
c0003878:	00279793          	slli	a5,a5,0x2
c000387c:	00e787b3          	add	a5,a5,a4
c0003880:	00279793          	slli	a5,a5,0x2
c0003884:	08000717          	auipc	a4,0x8000
c0003888:	cc470713          	addi	a4,a4,-828 # c8003548 <pxReadyTasksLists>
c000388c:	00e78733          	add	a4,a5,a4
c0003890:	fec42783          	lw	a5,-20(s0)
c0003894:	00478793          	addi	a5,a5,4
c0003898:	00078593          	mv	a1,a5
c000389c:	00070513          	mv	a0,a4
c00038a0:	eb1fc0ef          	jal	ra,c0000750 <vListInsertEnd>

					/* If the moved task has a priority higher than the current
					task then a yield must be performed. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
c00038a4:	fec42783          	lw	a5,-20(s0)
c00038a8:	02c7a703          	lw	a4,44(a5)
c00038ac:	07fff797          	auipc	a5,0x7fff
c00038b0:	fe078793          	addi	a5,a5,-32 # c800288c <pxCurrentTCB>
c00038b4:	0007a783          	lw	a5,0(a5)
c00038b8:	02c7a783          	lw	a5,44(a5)
c00038bc:	00f76a63          	bltu	a4,a5,c00038d0 <xTaskResumeAll+0x13c>
					{
						xYieldPending = pdTRUE;
c00038c0:	08000797          	auipc	a5,0x8000
c00038c4:	d7078793          	addi	a5,a5,-656 # c8003630 <xYieldPending>
c00038c8:	00100713          	li	a4,1
c00038cc:	00e7a023          	sw	a4,0(a5)
				while( listLIST_IS_EMPTY( &xPendingReadyList ) == pdFALSE )
c00038d0:	08000797          	auipc	a5,0x8000
c00038d4:	d0c78793          	addi	a5,a5,-756 # c80035dc <xPendingReadyList>
c00038d8:	0007a783          	lw	a5,0(a5)
c00038dc:	f20798e3          	bnez	a5,c000380c <xTaskResumeAll+0x78>
					{
						mtCOVERAGE_TEST_MARKER();
					}
				}

				if( pxTCB != NULL )
c00038e0:	fec42783          	lw	a5,-20(s0)
c00038e4:	10078063          	beqz	a5,c00039e4 <xTaskResumeAll+0x250>
					which may have prevented the next unblock time from being
					re-calculated, in which case re-calculate it now.  Mainly
					important for low power tickless implementations, where
					this can prevent an unnecessary exit from low power
					state. */
					prvResetNextTaskUnblockTime();
c00038e8:	20d010ef          	jal	ra,c00052f4 <prvResetNextTaskUnblockTime>

				/* If any ticks occurred while the scheduler was suspended then
				they should be processed now.  This ensures the tick count does
				not	slip, and that any delayed tasks are resumed at the correct
				time. */
				while( xPendedTicks > ( TickType_t ) 0 )
c00038ec:	0f80006f          	j	c00039e4 <xTaskResumeAll+0x250>
					the time now and the time at which the tick count overflows
					then xNextTaskUnblockTime will the tick overflow time.
					This means xNextTaskUnblockTime can never be less than
					xTickCount, and the following can therefore not
					underflow. */
					configASSERT( xNextTaskUnblockTime >= xTickCount );
c00038f0:	08000797          	auipc	a5,0x8000
c00038f4:	d4c78793          	addi	a5,a5,-692 # c800363c <xNextTaskUnblockTime>
c00038f8:	0007a703          	lw	a4,0(a5)
c00038fc:	08000797          	auipc	a5,0x8000
c0003900:	d2478793          	addi	a5,a5,-732 # c8003620 <xTickCount>
c0003904:	0007a783          	lw	a5,0(a5)
c0003908:	00f77863          	bgeu	a4,a5,c0003918 <xTaskResumeAll+0x184>
c000390c:	30047073          	csrci	mstatus,8
c0003910:	00100073          	ebreak
c0003914:	0000006f          	j	c0003914 <xTaskResumeAll+0x180>
					xTicksToNextUnblockTime = xNextTaskUnblockTime - xTickCount;
c0003918:	08000797          	auipc	a5,0x8000
c000391c:	d2478793          	addi	a5,a5,-732 # c800363c <xNextTaskUnblockTime>
c0003920:	0007a703          	lw	a4,0(a5)
c0003924:	08000797          	auipc	a5,0x8000
c0003928:	cfc78793          	addi	a5,a5,-772 # c8003620 <xTickCount>
c000392c:	0007a783          	lw	a5,0(a5)
c0003930:	40f707b3          	sub	a5,a4,a5
c0003934:	fef42223          	sw	a5,-28(s0)

					/* Don't want to move the tick count more than the number
					of ticks that are pending, so cap if necessary. */
					if( xTicksToNextUnblockTime > xPendedTicks )
c0003938:	08000797          	auipc	a5,0x8000
c000393c:	cf478793          	addi	a5,a5,-780 # c800362c <xPendedTicks>
c0003940:	0007a783          	lw	a5,0(a5)
c0003944:	fe442703          	lw	a4,-28(s0)
c0003948:	00e7fa63          	bgeu	a5,a4,c000395c <xTaskResumeAll+0x1c8>
					{
						xTicksToNextUnblockTime = xPendedTicks;
c000394c:	08000797          	auipc	a5,0x8000
c0003950:	ce078793          	addi	a5,a5,-800 # c800362c <xPendedTicks>
c0003954:	0007a783          	lw	a5,0(a5)
c0003958:	fef42223          	sw	a5,-28(s0)
					}

					if( xTicksToNextUnblockTime == 0 )
c000395c:	fe442783          	lw	a5,-28(s0)
c0003960:	00079863          	bnez	a5,c0003970 <xTaskResumeAll+0x1dc>
						count is about to overflow and xTicksToNetUnblockTime
						holds the time at which the tick count will overflow
						(rather than the time at which the next task will
						unblock).  Set to 1 otherwise xPendedTicks won't be
						decremented below. */
						xTicksToNextUnblockTime = ( TickType_t ) 1;
c0003964:	00100793          	li	a5,1
c0003968:	fef42223          	sw	a5,-28(s0)
c000396c:	0340006f          	j	c00039a0 <xTaskResumeAll+0x20c>
					}
					else if( xTicksToNextUnblockTime > ( TickType_t ) 1 )
c0003970:	fe442703          	lw	a4,-28(s0)
c0003974:	00100793          	li	a5,1
c0003978:	02e7f463          	bgeu	a5,a4,c00039a0 <xTaskResumeAll+0x20c>
						/* Move the tick count one short of the next unblock
						time, then call xTaskIncrementTick() to move the tick
						count up to the next unblock time to unblock the task,
						if any.  This will also swap the blocked task and
						overflow blocked task lists if necessary. */
						xTickCount += ( xTicksToNextUnblockTime - ( TickType_t ) 1 );
c000397c:	08000797          	auipc	a5,0x8000
c0003980:	ca478793          	addi	a5,a5,-860 # c8003620 <xTickCount>
c0003984:	0007a703          	lw	a4,0(a5)
c0003988:	fe442783          	lw	a5,-28(s0)
c000398c:	00f707b3          	add	a5,a4,a5
c0003990:	fff78713          	addi	a4,a5,-1
c0003994:	08000797          	auipc	a5,0x8000
c0003998:	c8c78793          	addi	a5,a5,-884 # c8003620 <xTickCount>
c000399c:	00e7a023          	sw	a4,0(a5)
					}
					xYieldPending |= xTaskIncrementTick();
c00039a0:	121000ef          	jal	ra,c00042c0 <xTaskIncrementTick>
c00039a4:	00050713          	mv	a4,a0
c00039a8:	08000797          	auipc	a5,0x8000
c00039ac:	c8878793          	addi	a5,a5,-888 # c8003630 <xYieldPending>
c00039b0:	0007a783          	lw	a5,0(a5)
c00039b4:	00f76733          	or	a4,a4,a5
c00039b8:	08000797          	auipc	a5,0x8000
c00039bc:	c7878793          	addi	a5,a5,-904 # c8003630 <xYieldPending>
c00039c0:	00e7a023          	sw	a4,0(a5)

					/* Adjust for the number of ticks just added to
					xTickCount and go around the loop again if
					xTicksToCatchUp is still greater than 0. */
					xPendedTicks -= xTicksToNextUnblockTime;
c00039c4:	08000797          	auipc	a5,0x8000
c00039c8:	c6878793          	addi	a5,a5,-920 # c800362c <xPendedTicks>
c00039cc:	0007a703          	lw	a4,0(a5)
c00039d0:	fe442783          	lw	a5,-28(s0)
c00039d4:	40f70733          	sub	a4,a4,a5
c00039d8:	08000797          	auipc	a5,0x8000
c00039dc:	c5478793          	addi	a5,a5,-940 # c800362c <xPendedTicks>
c00039e0:	00e7a023          	sw	a4,0(a5)
				while( xPendedTicks > ( TickType_t ) 0 )
c00039e4:	08000797          	auipc	a5,0x8000
c00039e8:	c4878793          	addi	a5,a5,-952 # c800362c <xPendedTicks>
c00039ec:	0007a783          	lw	a5,0(a5)
c00039f0:	f00790e3          	bnez	a5,c00038f0 <xTaskResumeAll+0x15c>
				}

				if( xYieldPending != pdFALSE )
c00039f4:	08000797          	auipc	a5,0x8000
c00039f8:	c3c78793          	addi	a5,a5,-964 # c8003630 <xYieldPending>
c00039fc:	0007a783          	lw	a5,0(a5)
c0003a00:	00078863          	beqz	a5,c0003a10 <xTaskResumeAll+0x27c>
				{
					#if( configUSE_PREEMPTION != 0 )
					{
						xAlreadyYielded = pdTRUE;
c0003a04:	00100793          	li	a5,1
c0003a08:	fef42423          	sw	a5,-24(s0)
					}
					#endif
					taskYIELD_IF_USING_PREEMPTION();
c0003a0c:	00000073          	ecall
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
	taskEXIT_CRITICAL();
c0003a10:	785010ef          	jal	ra,c0005994 <vTaskExitCritical>

	return xAlreadyYielded;
c0003a14:	fe842783          	lw	a5,-24(s0)
}
c0003a18:	00078513          	mv	a0,a5
c0003a1c:	01c12083          	lw	ra,28(sp)
c0003a20:	01812403          	lw	s0,24(sp)
c0003a24:	02010113          	addi	sp,sp,32
c0003a28:	00008067          	ret

c0003a2c <xTaskGetTickCount>:
/*-----------------------------------------------------------*/

TickType_t xTaskGetTickCount( void )
{
c0003a2c:	fe010113          	addi	sp,sp,-32
c0003a30:	00812e23          	sw	s0,28(sp)
c0003a34:	02010413          	addi	s0,sp,32
TickType_t xTicks;

	/* Critical section required if running on a 16 bit processor. */
	portTICK_TYPE_ENTER_CRITICAL();
	{
		xTicks = xTickCount;
c0003a38:	08000797          	auipc	a5,0x8000
c0003a3c:	be878793          	addi	a5,a5,-1048 # c8003620 <xTickCount>
c0003a40:	0007a783          	lw	a5,0(a5)
c0003a44:	fef42623          	sw	a5,-20(s0)
	}
	portTICK_TYPE_EXIT_CRITICAL();

	return xTicks;
c0003a48:	fec42783          	lw	a5,-20(s0)
}
c0003a4c:	00078513          	mv	a0,a5
c0003a50:	01c12403          	lw	s0,28(sp)
c0003a54:	02010113          	addi	sp,sp,32
c0003a58:	00008067          	ret

c0003a5c <xTaskGetTickCountFromISR>:
/*-----------------------------------------------------------*/

TickType_t xTaskGetTickCountFromISR( void )
{
c0003a5c:	fe010113          	addi	sp,sp,-32
c0003a60:	00812e23          	sw	s0,28(sp)
c0003a64:	02010413          	addi	s0,sp,32
	safe API to ensure interrupt entry is as fast and as simple as possible.
	More information (albeit Cortex-M specific) is provided on the following
	link: https://www.freertos.org/RTOS-Cortex-M3-M4.html */
	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

	uxSavedInterruptStatus = portTICK_TYPE_SET_INTERRUPT_MASK_FROM_ISR();
c0003a68:	fe042623          	sw	zero,-20(s0)
	{
		xReturn = xTickCount;
c0003a6c:	08000797          	auipc	a5,0x8000
c0003a70:	bb478793          	addi	a5,a5,-1100 # c8003620 <xTickCount>
c0003a74:	0007a783          	lw	a5,0(a5)
c0003a78:	fef42423          	sw	a5,-24(s0)
	}
	portTICK_TYPE_CLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
c0003a7c:	fe842783          	lw	a5,-24(s0)
}
c0003a80:	00078513          	mv	a0,a5
c0003a84:	01c12403          	lw	s0,28(sp)
c0003a88:	02010113          	addi	sp,sp,32
c0003a8c:	00008067          	ret

c0003a90 <uxTaskGetNumberOfTasks>:
/*-----------------------------------------------------------*/

UBaseType_t uxTaskGetNumberOfTasks( void )
{
c0003a90:	ff010113          	addi	sp,sp,-16
c0003a94:	00812623          	sw	s0,12(sp)
c0003a98:	01010413          	addi	s0,sp,16
	/* A critical section is not required because the variables are of type
	BaseType_t. */
	return uxCurrentNumberOfTasks;
c0003a9c:	08000797          	auipc	a5,0x8000
c0003aa0:	b8078793          	addi	a5,a5,-1152 # c800361c <uxCurrentNumberOfTasks>
c0003aa4:	0007a783          	lw	a5,0(a5)
}
c0003aa8:	00078513          	mv	a0,a5
c0003aac:	00c12403          	lw	s0,12(sp)
c0003ab0:	01010113          	addi	sp,sp,16
c0003ab4:	00008067          	ret

c0003ab8 <pcTaskGetName>:
/*-----------------------------------------------------------*/

char *pcTaskGetName( TaskHandle_t xTaskToQuery ) /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
{
c0003ab8:	fd010113          	addi	sp,sp,-48
c0003abc:	02812623          	sw	s0,44(sp)
c0003ac0:	03010413          	addi	s0,sp,48
c0003ac4:	fca42e23          	sw	a0,-36(s0)
TCB_t *pxTCB;

	/* If null is passed in here then the name of the calling task is being
	queried. */
	pxTCB = prvGetTCBFromHandle( xTaskToQuery );
c0003ac8:	fdc42783          	lw	a5,-36(s0)
c0003acc:	00079a63          	bnez	a5,c0003ae0 <pcTaskGetName+0x28>
c0003ad0:	07fff797          	auipc	a5,0x7fff
c0003ad4:	dbc78793          	addi	a5,a5,-580 # c800288c <pxCurrentTCB>
c0003ad8:	0007a783          	lw	a5,0(a5)
c0003adc:	0080006f          	j	c0003ae4 <pcTaskGetName+0x2c>
c0003ae0:	fdc42783          	lw	a5,-36(s0)
c0003ae4:	fef42623          	sw	a5,-20(s0)
	configASSERT( pxTCB );
c0003ae8:	fec42783          	lw	a5,-20(s0)
c0003aec:	00079863          	bnez	a5,c0003afc <pcTaskGetName+0x44>
c0003af0:	30047073          	csrci	mstatus,8
c0003af4:	00100073          	ebreak
c0003af8:	0000006f          	j	c0003af8 <pcTaskGetName+0x40>
	return &( pxTCB->pcTaskName[ 0 ] );
c0003afc:	fec42783          	lw	a5,-20(s0)
c0003b00:	03478793          	addi	a5,a5,52
}
c0003b04:	00078513          	mv	a0,a5
c0003b08:	02c12403          	lw	s0,44(sp)
c0003b0c:	03010113          	addi	sp,sp,48
c0003b10:	00008067          	ret

c0003b14 <prvSearchForNameWithinSingleList>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_xTaskGetHandle == 1 )

	static TCB_t *prvSearchForNameWithinSingleList( List_t *pxList, const char pcNameToQuery[] )
	{
c0003b14:	fc010113          	addi	sp,sp,-64
c0003b18:	02812e23          	sw	s0,60(sp)
c0003b1c:	04010413          	addi	s0,sp,64
c0003b20:	fca42623          	sw	a0,-52(s0)
c0003b24:	fcb42423          	sw	a1,-56(s0)
	TCB_t *pxNextTCB, *pxFirstTCB, *pxReturn = NULL;
c0003b28:	fe042623          	sw	zero,-20(s0)
	char cNextChar;
	BaseType_t xBreakLoop;

		/* This function is called with the scheduler suspended. */

		if( listCURRENT_LIST_LENGTH( pxList ) > ( UBaseType_t ) 0 )
c0003b2c:	fcc42783          	lw	a5,-52(s0)
c0003b30:	0007a783          	lw	a5,0(a5)
c0003b34:	14078663          	beqz	a5,c0003c80 <prvSearchForNameWithinSingleList+0x16c>
		{
			listGET_OWNER_OF_NEXT_ENTRY( pxFirstTCB, pxList );  /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
c0003b38:	fcc42783          	lw	a5,-52(s0)
c0003b3c:	fef42023          	sw	a5,-32(s0)
c0003b40:	fe042783          	lw	a5,-32(s0)
c0003b44:	0047a783          	lw	a5,4(a5)
c0003b48:	0047a703          	lw	a4,4(a5)
c0003b4c:	fe042783          	lw	a5,-32(s0)
c0003b50:	00e7a223          	sw	a4,4(a5)
c0003b54:	fe042783          	lw	a5,-32(s0)
c0003b58:	0047a703          	lw	a4,4(a5)
c0003b5c:	fe042783          	lw	a5,-32(s0)
c0003b60:	00878793          	addi	a5,a5,8
c0003b64:	00f71c63          	bne	a4,a5,c0003b7c <prvSearchForNameWithinSingleList+0x68>
c0003b68:	fe042783          	lw	a5,-32(s0)
c0003b6c:	0047a783          	lw	a5,4(a5)
c0003b70:	0047a703          	lw	a4,4(a5)
c0003b74:	fe042783          	lw	a5,-32(s0)
c0003b78:	00e7a223          	sw	a4,4(a5)
c0003b7c:	fe042783          	lw	a5,-32(s0)
c0003b80:	0047a783          	lw	a5,4(a5)
c0003b84:	00c7a783          	lw	a5,12(a5)
c0003b88:	fcf42e23          	sw	a5,-36(s0)

			do
			{
				listGET_OWNER_OF_NEXT_ENTRY( pxNextTCB, pxList ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
c0003b8c:	fcc42783          	lw	a5,-52(s0)
c0003b90:	fcf42c23          	sw	a5,-40(s0)
c0003b94:	fd842783          	lw	a5,-40(s0)
c0003b98:	0047a783          	lw	a5,4(a5)
c0003b9c:	0047a703          	lw	a4,4(a5)
c0003ba0:	fd842783          	lw	a5,-40(s0)
c0003ba4:	00e7a223          	sw	a4,4(a5)
c0003ba8:	fd842783          	lw	a5,-40(s0)
c0003bac:	0047a703          	lw	a4,4(a5)
c0003bb0:	fd842783          	lw	a5,-40(s0)
c0003bb4:	00878793          	addi	a5,a5,8
c0003bb8:	00f71c63          	bne	a4,a5,c0003bd0 <prvSearchForNameWithinSingleList+0xbc>
c0003bbc:	fd842783          	lw	a5,-40(s0)
c0003bc0:	0047a783          	lw	a5,4(a5)
c0003bc4:	0047a703          	lw	a4,4(a5)
c0003bc8:	fd842783          	lw	a5,-40(s0)
c0003bcc:	00e7a223          	sw	a4,4(a5)
c0003bd0:	fd842783          	lw	a5,-40(s0)
c0003bd4:	0047a783          	lw	a5,4(a5)
c0003bd8:	00c7a783          	lw	a5,12(a5)
c0003bdc:	fcf42a23          	sw	a5,-44(s0)

				/* Check each character in the name looking for a match or
				mismatch. */
				xBreakLoop = pdFALSE;
c0003be0:	fe042223          	sw	zero,-28(s0)
				for( x = ( UBaseType_t ) 0; x < ( UBaseType_t ) configMAX_TASK_NAME_LEN; x++ )
c0003be4:	fe042423          	sw	zero,-24(s0)
c0003be8:	0680006f          	j	c0003c50 <prvSearchForNameWithinSingleList+0x13c>
				{
					cNextChar = pxNextTCB->pcTaskName[ x ];
c0003bec:	fd442703          	lw	a4,-44(s0)
c0003bf0:	fe842783          	lw	a5,-24(s0)
c0003bf4:	00f707b3          	add	a5,a4,a5
c0003bf8:	0347c783          	lbu	a5,52(a5)
c0003bfc:	fcf409a3          	sb	a5,-45(s0)

					if( cNextChar != pcNameToQuery[ x ] )
c0003c00:	fc842703          	lw	a4,-56(s0)
c0003c04:	fe842783          	lw	a5,-24(s0)
c0003c08:	00f707b3          	add	a5,a4,a5
c0003c0c:	0007c783          	lbu	a5,0(a5)
c0003c10:	fd344703          	lbu	a4,-45(s0)
c0003c14:	00f70863          	beq	a4,a5,c0003c24 <prvSearchForNameWithinSingleList+0x110>
					{
						/* Characters didn't match. */
						xBreakLoop = pdTRUE;
c0003c18:	00100793          	li	a5,1
c0003c1c:	fef42223          	sw	a5,-28(s0)
c0003c20:	01c0006f          	j	c0003c3c <prvSearchForNameWithinSingleList+0x128>
					}
					else if( cNextChar == ( char ) 0x00 )
c0003c24:	fd344783          	lbu	a5,-45(s0)
c0003c28:	00079a63          	bnez	a5,c0003c3c <prvSearchForNameWithinSingleList+0x128>
					{
						/* Both strings terminated, a match must have been
						found. */
						pxReturn = pxNextTCB;
c0003c2c:	fd442783          	lw	a5,-44(s0)
c0003c30:	fef42623          	sw	a5,-20(s0)
						xBreakLoop = pdTRUE;
c0003c34:	00100793          	li	a5,1
c0003c38:	fef42223          	sw	a5,-28(s0)
					else
					{
						mtCOVERAGE_TEST_MARKER();
					}

					if( xBreakLoop != pdFALSE )
c0003c3c:	fe442783          	lw	a5,-28(s0)
c0003c40:	02079063          	bnez	a5,c0003c60 <prvSearchForNameWithinSingleList+0x14c>
				for( x = ( UBaseType_t ) 0; x < ( UBaseType_t ) configMAX_TASK_NAME_LEN; x++ )
c0003c44:	fe842783          	lw	a5,-24(s0)
c0003c48:	00178793          	addi	a5,a5,1
c0003c4c:	fef42423          	sw	a5,-24(s0)
c0003c50:	fe842703          	lw	a4,-24(s0)
c0003c54:	00f00793          	li	a5,15
c0003c58:	f8e7fae3          	bgeu	a5,a4,c0003bec <prvSearchForNameWithinSingleList+0xd8>
c0003c5c:	0080006f          	j	c0003c64 <prvSearchForNameWithinSingleList+0x150>
					{
						break;
c0003c60:	00000013          	nop
					}
				}

				if( pxReturn != NULL )
c0003c64:	fec42783          	lw	a5,-20(s0)
c0003c68:	00079a63          	bnez	a5,c0003c7c <prvSearchForNameWithinSingleList+0x168>
				{
					/* The handle has been found. */
					break;
				}

			} while( pxNextTCB != pxFirstTCB );
c0003c6c:	fd442703          	lw	a4,-44(s0)
c0003c70:	fdc42783          	lw	a5,-36(s0)
c0003c74:	f0f71ce3          	bne	a4,a5,c0003b8c <prvSearchForNameWithinSingleList+0x78>
c0003c78:	0080006f          	j	c0003c80 <prvSearchForNameWithinSingleList+0x16c>
					break;
c0003c7c:	00000013          	nop
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}

		return pxReturn;
c0003c80:	fec42783          	lw	a5,-20(s0)
	}
c0003c84:	00078513          	mv	a0,a5
c0003c88:	03c12403          	lw	s0,60(sp)
c0003c8c:	04010113          	addi	sp,sp,64
c0003c90:	00008067          	ret

c0003c94 <xTaskGetHandle>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_xTaskGetHandle == 1 )

	TaskHandle_t xTaskGetHandle( const char *pcNameToQuery ) /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
	{
c0003c94:	fd010113          	addi	sp,sp,-48
c0003c98:	02112623          	sw	ra,44(sp)
c0003c9c:	02812423          	sw	s0,40(sp)
c0003ca0:	03010413          	addi	s0,sp,48
c0003ca4:	fca42e23          	sw	a0,-36(s0)
	UBaseType_t uxQueue = configMAX_PRIORITIES;
c0003ca8:	00500793          	li	a5,5
c0003cac:	fef42623          	sw	a5,-20(s0)
	TCB_t* pxTCB;

		/* Task names will be truncated to configMAX_TASK_NAME_LEN - 1 bytes. */
		configASSERT( strlen( pcNameToQuery ) < configMAX_TASK_NAME_LEN );
c0003cb0:	fdc42503          	lw	a0,-36(s0)
c0003cb4:	3b41a0ef          	jal	ra,c001e068 <strlen>
c0003cb8:	00050713          	mv	a4,a0
c0003cbc:	00f00793          	li	a5,15
c0003cc0:	00e7f863          	bgeu	a5,a4,c0003cd0 <xTaskGetHandle+0x3c>
c0003cc4:	30047073          	csrci	mstatus,8
c0003cc8:	00100073          	ebreak
c0003ccc:	0000006f          	j	c0003ccc <xTaskGetHandle+0x38>

		vTaskSuspendAll();
c0003cd0:	a8dff0ef          	jal	ra,c000375c <vTaskSuspendAll>
		{
			/* Search the ready lists. */
			do
			{
				uxQueue--;
c0003cd4:	fec42783          	lw	a5,-20(s0)
c0003cd8:	fff78793          	addi	a5,a5,-1
c0003cdc:	fef42623          	sw	a5,-20(s0)
				pxTCB = prvSearchForNameWithinSingleList( ( List_t * ) &( pxReadyTasksLists[ uxQueue ] ), pcNameToQuery );
c0003ce0:	fec42703          	lw	a4,-20(s0)
c0003ce4:	00070793          	mv	a5,a4
c0003ce8:	00279793          	slli	a5,a5,0x2
c0003cec:	00e787b3          	add	a5,a5,a4
c0003cf0:	00279793          	slli	a5,a5,0x2
c0003cf4:	08000717          	auipc	a4,0x8000
c0003cf8:	85470713          	addi	a4,a4,-1964 # c8003548 <pxReadyTasksLists>
c0003cfc:	00e787b3          	add	a5,a5,a4
c0003d00:	fdc42583          	lw	a1,-36(s0)
c0003d04:	00078513          	mv	a0,a5
c0003d08:	e0dff0ef          	jal	ra,c0003b14 <prvSearchForNameWithinSingleList>
c0003d0c:	fea42423          	sw	a0,-24(s0)

				if( pxTCB != NULL )
c0003d10:	fe842783          	lw	a5,-24(s0)
c0003d14:	00079863          	bnez	a5,c0003d24 <xTaskGetHandle+0x90>
				{
					/* Found the handle. */
					break;
				}

			} while( uxQueue > ( UBaseType_t ) tskIDLE_PRIORITY ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
c0003d18:	fec42783          	lw	a5,-20(s0)
c0003d1c:	fa079ce3          	bnez	a5,c0003cd4 <xTaskGetHandle+0x40>
c0003d20:	0080006f          	j	c0003d28 <xTaskGetHandle+0x94>
					break;
c0003d24:	00000013          	nop

			/* Search the delayed lists. */
			if( pxTCB == NULL )
c0003d28:	fe842783          	lw	a5,-24(s0)
c0003d2c:	02079063          	bnez	a5,c0003d4c <xTaskGetHandle+0xb8>
			{
				pxTCB = prvSearchForNameWithinSingleList( ( List_t * ) pxDelayedTaskList, pcNameToQuery );
c0003d30:	08000797          	auipc	a5,0x8000
c0003d34:	8a478793          	addi	a5,a5,-1884 # c80035d4 <pxDelayedTaskList>
c0003d38:	0007a783          	lw	a5,0(a5)
c0003d3c:	fdc42583          	lw	a1,-36(s0)
c0003d40:	00078513          	mv	a0,a5
c0003d44:	dd1ff0ef          	jal	ra,c0003b14 <prvSearchForNameWithinSingleList>
c0003d48:	fea42423          	sw	a0,-24(s0)
			}

			if( pxTCB == NULL )
c0003d4c:	fe842783          	lw	a5,-24(s0)
c0003d50:	02079063          	bnez	a5,c0003d70 <xTaskGetHandle+0xdc>
			{
				pxTCB = prvSearchForNameWithinSingleList( ( List_t * ) pxOverflowDelayedTaskList, pcNameToQuery );
c0003d54:	08000797          	auipc	a5,0x8000
c0003d58:	88478793          	addi	a5,a5,-1916 # c80035d8 <pxOverflowDelayedTaskList>
c0003d5c:	0007a783          	lw	a5,0(a5)
c0003d60:	fdc42583          	lw	a1,-36(s0)
c0003d64:	00078513          	mv	a0,a5
c0003d68:	dadff0ef          	jal	ra,c0003b14 <prvSearchForNameWithinSingleList>
c0003d6c:	fea42423          	sw	a0,-24(s0)
			}

			#if ( INCLUDE_vTaskSuspend == 1 )
			{
				if( pxTCB == NULL )
c0003d70:	fe842783          	lw	a5,-24(s0)
c0003d74:	00079c63          	bnez	a5,c0003d8c <xTaskGetHandle+0xf8>
				{
					/* Search the suspended list. */
					pxTCB = prvSearchForNameWithinSingleList( &xSuspendedTaskList, pcNameToQuery );
c0003d78:	fdc42583          	lw	a1,-36(s0)
c0003d7c:	08000517          	auipc	a0,0x8000
c0003d80:	88c50513          	addi	a0,a0,-1908 # c8003608 <xSuspendedTaskList>
c0003d84:	d91ff0ef          	jal	ra,c0003b14 <prvSearchForNameWithinSingleList>
c0003d88:	fea42423          	sw	a0,-24(s0)
			}
			#endif

			#if( INCLUDE_vTaskDelete == 1 )
			{
				if( pxTCB == NULL )
c0003d8c:	fe842783          	lw	a5,-24(s0)
c0003d90:	00079c63          	bnez	a5,c0003da8 <xTaskGetHandle+0x114>
				{
					/* Search the deleted list. */
					pxTCB = prvSearchForNameWithinSingleList( &xTasksWaitingTermination, pcNameToQuery );
c0003d94:	fdc42583          	lw	a1,-36(s0)
c0003d98:	08000517          	auipc	a0,0x8000
c0003d9c:	85850513          	addi	a0,a0,-1960 # c80035f0 <xTasksWaitingTermination>
c0003da0:	d75ff0ef          	jal	ra,c0003b14 <prvSearchForNameWithinSingleList>
c0003da4:	fea42423          	sw	a0,-24(s0)
				}
			}
			#endif
		}
		( void ) xTaskResumeAll();
c0003da8:	9edff0ef          	jal	ra,c0003794 <xTaskResumeAll>

		return pxTCB;
c0003dac:	fe842783          	lw	a5,-24(s0)
	}
c0003db0:	00078513          	mv	a0,a5
c0003db4:	02c12083          	lw	ra,44(sp)
c0003db8:	02812403          	lw	s0,40(sp)
c0003dbc:	03010113          	addi	sp,sp,48
c0003dc0:	00008067          	ret

c0003dc4 <uxTaskGetSystemState>:
/*-----------------------------------------------------------*/

#if ( configUSE_TRACE_FACILITY == 1 )

	UBaseType_t uxTaskGetSystemState( TaskStatus_t * const pxTaskStatusArray, const UBaseType_t uxArraySize, uint32_t * const pulTotalRunTime )
	{
c0003dc4:	fd010113          	addi	sp,sp,-48
c0003dc8:	02112623          	sw	ra,44(sp)
c0003dcc:	02812423          	sw	s0,40(sp)
c0003dd0:	03010413          	addi	s0,sp,48
c0003dd4:	fca42e23          	sw	a0,-36(s0)
c0003dd8:	fcb42c23          	sw	a1,-40(s0)
c0003ddc:	fcc42a23          	sw	a2,-44(s0)
	UBaseType_t uxTask = 0, uxQueue = configMAX_PRIORITIES;
c0003de0:	fe042623          	sw	zero,-20(s0)
c0003de4:	00500793          	li	a5,5
c0003de8:	fef42423          	sw	a5,-24(s0)

		vTaskSuspendAll();
c0003dec:	971ff0ef          	jal	ra,c000375c <vTaskSuspendAll>
		{
			/* Is there a space in the array for each task in the system? */
			if( uxArraySize >= uxCurrentNumberOfTasks )
c0003df0:	08000797          	auipc	a5,0x8000
c0003df4:	82c78793          	addi	a5,a5,-2004 # c800361c <uxCurrentNumberOfTasks>
c0003df8:	0007a783          	lw	a5,0(a5)
c0003dfc:	fd842703          	lw	a4,-40(s0)
c0003e00:	1af76463          	bltu	a4,a5,c0003fa8 <uxTaskGetSystemState+0x1e4>
			{
				/* Fill in an TaskStatus_t structure with information on each
				task in the Ready state. */
				do
				{
					uxQueue--;
c0003e04:	fe842783          	lw	a5,-24(s0)
c0003e08:	fff78793          	addi	a5,a5,-1
c0003e0c:	fef42423          	sw	a5,-24(s0)
					uxTask += prvListTasksWithinSingleList( &( pxTaskStatusArray[ uxTask ] ), &( pxReadyTasksLists[ uxQueue ] ), eReady );
c0003e10:	fec42703          	lw	a4,-20(s0)
c0003e14:	00070793          	mv	a5,a4
c0003e18:	00379793          	slli	a5,a5,0x3
c0003e1c:	00e787b3          	add	a5,a5,a4
c0003e20:	00279793          	slli	a5,a5,0x2
c0003e24:	00078713          	mv	a4,a5
c0003e28:	fdc42783          	lw	a5,-36(s0)
c0003e2c:	00e786b3          	add	a3,a5,a4
c0003e30:	fe842703          	lw	a4,-24(s0)
c0003e34:	00070793          	mv	a5,a4
c0003e38:	00279793          	slli	a5,a5,0x2
c0003e3c:	00e787b3          	add	a5,a5,a4
c0003e40:	00279793          	slli	a5,a5,0x2
c0003e44:	07fff717          	auipc	a4,0x7fff
c0003e48:	70470713          	addi	a4,a4,1796 # c8003548 <pxReadyTasksLists>
c0003e4c:	00e787b3          	add	a5,a5,a4
c0003e50:	00100613          	li	a2,1
c0003e54:	00078593          	mv	a1,a5
c0003e58:	00068513          	mv	a0,a3
c0003e5c:	25c010ef          	jal	ra,c00050b8 <prvListTasksWithinSingleList>
c0003e60:	00050713          	mv	a4,a0
c0003e64:	fec42783          	lw	a5,-20(s0)
c0003e68:	00e787b3          	add	a5,a5,a4
c0003e6c:	fef42623          	sw	a5,-20(s0)

				} while( uxQueue > ( UBaseType_t ) tskIDLE_PRIORITY ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
c0003e70:	fe842783          	lw	a5,-24(s0)
c0003e74:	f80798e3          	bnez	a5,c0003e04 <uxTaskGetSystemState+0x40>

				/* Fill in an TaskStatus_t structure with information on each
				task in the Blocked state. */
				uxTask += prvListTasksWithinSingleList( &( pxTaskStatusArray[ uxTask ] ), ( List_t * ) pxDelayedTaskList, eBlocked );
c0003e78:	fec42703          	lw	a4,-20(s0)
c0003e7c:	00070793          	mv	a5,a4
c0003e80:	00379793          	slli	a5,a5,0x3
c0003e84:	00e787b3          	add	a5,a5,a4
c0003e88:	00279793          	slli	a5,a5,0x2
c0003e8c:	00078713          	mv	a4,a5
c0003e90:	fdc42783          	lw	a5,-36(s0)
c0003e94:	00e78733          	add	a4,a5,a4
c0003e98:	07fff797          	auipc	a5,0x7fff
c0003e9c:	73c78793          	addi	a5,a5,1852 # c80035d4 <pxDelayedTaskList>
c0003ea0:	0007a783          	lw	a5,0(a5)
c0003ea4:	00200613          	li	a2,2
c0003ea8:	00078593          	mv	a1,a5
c0003eac:	00070513          	mv	a0,a4
c0003eb0:	208010ef          	jal	ra,c00050b8 <prvListTasksWithinSingleList>
c0003eb4:	00050713          	mv	a4,a0
c0003eb8:	fec42783          	lw	a5,-20(s0)
c0003ebc:	00e787b3          	add	a5,a5,a4
c0003ec0:	fef42623          	sw	a5,-20(s0)
				uxTask += prvListTasksWithinSingleList( &( pxTaskStatusArray[ uxTask ] ), ( List_t * ) pxOverflowDelayedTaskList, eBlocked );
c0003ec4:	fec42703          	lw	a4,-20(s0)
c0003ec8:	00070793          	mv	a5,a4
c0003ecc:	00379793          	slli	a5,a5,0x3
c0003ed0:	00e787b3          	add	a5,a5,a4
c0003ed4:	00279793          	slli	a5,a5,0x2
c0003ed8:	00078713          	mv	a4,a5
c0003edc:	fdc42783          	lw	a5,-36(s0)
c0003ee0:	00e78733          	add	a4,a5,a4
c0003ee4:	07fff797          	auipc	a5,0x7fff
c0003ee8:	6f478793          	addi	a5,a5,1780 # c80035d8 <pxOverflowDelayedTaskList>
c0003eec:	0007a783          	lw	a5,0(a5)
c0003ef0:	00200613          	li	a2,2
c0003ef4:	00078593          	mv	a1,a5
c0003ef8:	00070513          	mv	a0,a4
c0003efc:	1bc010ef          	jal	ra,c00050b8 <prvListTasksWithinSingleList>
c0003f00:	00050713          	mv	a4,a0
c0003f04:	fec42783          	lw	a5,-20(s0)
c0003f08:	00e787b3          	add	a5,a5,a4
c0003f0c:	fef42623          	sw	a5,-20(s0)

				#if( INCLUDE_vTaskDelete == 1 )
				{
					/* Fill in an TaskStatus_t structure with information on
					each task that has been deleted but not yet cleaned up. */
					uxTask += prvListTasksWithinSingleList( &( pxTaskStatusArray[ uxTask ] ), &xTasksWaitingTermination, eDeleted );
c0003f10:	fec42703          	lw	a4,-20(s0)
c0003f14:	00070793          	mv	a5,a4
c0003f18:	00379793          	slli	a5,a5,0x3
c0003f1c:	00e787b3          	add	a5,a5,a4
c0003f20:	00279793          	slli	a5,a5,0x2
c0003f24:	00078713          	mv	a4,a5
c0003f28:	fdc42783          	lw	a5,-36(s0)
c0003f2c:	00e787b3          	add	a5,a5,a4
c0003f30:	00400613          	li	a2,4
c0003f34:	07fff597          	auipc	a1,0x7fff
c0003f38:	6bc58593          	addi	a1,a1,1724 # c80035f0 <xTasksWaitingTermination>
c0003f3c:	00078513          	mv	a0,a5
c0003f40:	178010ef          	jal	ra,c00050b8 <prvListTasksWithinSingleList>
c0003f44:	00050713          	mv	a4,a0
c0003f48:	fec42783          	lw	a5,-20(s0)
c0003f4c:	00e787b3          	add	a5,a5,a4
c0003f50:	fef42623          	sw	a5,-20(s0)

				#if ( INCLUDE_vTaskSuspend == 1 )
				{
					/* Fill in an TaskStatus_t structure with information on
					each task in the Suspended state. */
					uxTask += prvListTasksWithinSingleList( &( pxTaskStatusArray[ uxTask ] ), &xSuspendedTaskList, eSuspended );
c0003f54:	fec42703          	lw	a4,-20(s0)
c0003f58:	00070793          	mv	a5,a4
c0003f5c:	00379793          	slli	a5,a5,0x3
c0003f60:	00e787b3          	add	a5,a5,a4
c0003f64:	00279793          	slli	a5,a5,0x2
c0003f68:	00078713          	mv	a4,a5
c0003f6c:	fdc42783          	lw	a5,-36(s0)
c0003f70:	00e787b3          	add	a5,a5,a4
c0003f74:	00300613          	li	a2,3
c0003f78:	07fff597          	auipc	a1,0x7fff
c0003f7c:	69058593          	addi	a1,a1,1680 # c8003608 <xSuspendedTaskList>
c0003f80:	00078513          	mv	a0,a5
c0003f84:	134010ef          	jal	ra,c00050b8 <prvListTasksWithinSingleList>
c0003f88:	00050713          	mv	a4,a0
c0003f8c:	fec42783          	lw	a5,-20(s0)
c0003f90:	00e787b3          	add	a5,a5,a4
c0003f94:	fef42623          	sw	a5,-20(s0)
						#endif
					}
				}
				#else
				{
					if( pulTotalRunTime != NULL )
c0003f98:	fd442783          	lw	a5,-44(s0)
c0003f9c:	00078663          	beqz	a5,c0003fa8 <uxTaskGetSystemState+0x1e4>
					{
						*pulTotalRunTime = 0;
c0003fa0:	fd442783          	lw	a5,-44(s0)
c0003fa4:	0007a023          	sw	zero,0(a5)
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
		( void ) xTaskResumeAll();
c0003fa8:	fecff0ef          	jal	ra,c0003794 <xTaskResumeAll>

		return uxTask;
c0003fac:	fec42783          	lw	a5,-20(s0)
	}
c0003fb0:	00078513          	mv	a0,a5
c0003fb4:	02c12083          	lw	ra,44(sp)
c0003fb8:	02812403          	lw	s0,40(sp)
c0003fbc:	03010113          	addi	sp,sp,48
c0003fc0:	00008067          	ret

c0003fc4 <xTaskCatchUpTicks>:

#endif /* configUSE_TICKLESS_IDLE */
/*----------------------------------------------------------*/

BaseType_t xTaskCatchUpTicks( TickType_t xTicksToCatchUp )
{
c0003fc4:	fd010113          	addi	sp,sp,-48
c0003fc8:	02112623          	sw	ra,44(sp)
c0003fcc:	02812423          	sw	s0,40(sp)
c0003fd0:	03010413          	addi	s0,sp,48
c0003fd4:	fca42e23          	sw	a0,-36(s0)
BaseType_t xYieldRequired = pdFALSE;
c0003fd8:	fe042623          	sw	zero,-20(s0)

	/* Must not be called with the scheduler suspended as the implementation
	relies on xPendedTicks being wound down to 0 in xTaskResumeAll(). */
	configASSERT( uxSchedulerSuspended == 0 );
c0003fdc:	07fff797          	auipc	a5,0x7fff
c0003fe0:	66878793          	addi	a5,a5,1640 # c8003644 <uxSchedulerSuspended>
c0003fe4:	0007a783          	lw	a5,0(a5)
c0003fe8:	00078863          	beqz	a5,c0003ff8 <xTaskCatchUpTicks+0x34>
c0003fec:	30047073          	csrci	mstatus,8
c0003ff0:	00100073          	ebreak
c0003ff4:	0000006f          	j	c0003ff4 <xTaskCatchUpTicks+0x30>

	/* Use xPendedTicks to mimic xTicksToCatchUp number of ticks occurring when
	the scheduler is suspended so the ticks are executed in xTaskResumeAll(). */
	vTaskSuspendAll();
c0003ff8:	f64ff0ef          	jal	ra,c000375c <vTaskSuspendAll>
	xPendedTicks += xTicksToCatchUp;
c0003ffc:	07fff797          	auipc	a5,0x7fff
c0004000:	63078793          	addi	a5,a5,1584 # c800362c <xPendedTicks>
c0004004:	0007a703          	lw	a4,0(a5)
c0004008:	fdc42783          	lw	a5,-36(s0)
c000400c:	00f70733          	add	a4,a4,a5
c0004010:	07fff797          	auipc	a5,0x7fff
c0004014:	61c78793          	addi	a5,a5,1564 # c800362c <xPendedTicks>
c0004018:	00e7a023          	sw	a4,0(a5)
	xYieldRequired = xTaskResumeAll();
c000401c:	f78ff0ef          	jal	ra,c0003794 <xTaskResumeAll>
c0004020:	fea42623          	sw	a0,-20(s0)

	return xYieldRequired;
c0004024:	fec42783          	lw	a5,-20(s0)
}
c0004028:	00078513          	mv	a0,a5
c000402c:	02c12083          	lw	ra,44(sp)
c0004030:	02812403          	lw	s0,40(sp)
c0004034:	03010113          	addi	sp,sp,48
c0004038:	00008067          	ret

c000403c <xTaskAbortDelayFromISR>:
/*----------------------------------------------------------*/

#if ( INCLUDE_xTaskAbortDelay == 1 )

	BaseType_t xTaskAbortDelayFromISR( TaskHandle_t xTask, BaseType_t * const pxHigherPriorityTaskWoken )
	{
c000403c:	fd010113          	addi	sp,sp,-48
c0004040:	02112623          	sw	ra,44(sp)
c0004044:	02812423          	sw	s0,40(sp)
c0004048:	03010413          	addi	s0,sp,48
c000404c:	fca42e23          	sw	a0,-36(s0)
c0004050:	fcb42c23          	sw	a1,-40(s0)
	TCB_t *pxTCB = xTask;
c0004054:	fdc42783          	lw	a5,-36(s0)
c0004058:	fef42423          	sw	a5,-24(s0)
	BaseType_t xReturn;
	UBaseType_t uxSavedInterruptStatus;

		configASSERT( pxTCB );
c000405c:	fe842783          	lw	a5,-24(s0)
c0004060:	00079863          	bnez	a5,c0004070 <xTaskAbortDelayFromISR+0x34>
c0004064:	30047073          	csrci	mstatus,8
c0004068:	00100073          	ebreak
c000406c:	0000006f          	j	c000406c <xTaskAbortDelayFromISR+0x30>
		safe API to ensure interrupt entry is as fast and as simple as possible.
		More information (albeit Cortex-M specific) is provided on the following
		link: http://www.freertos.org/RTOS-Cortex-M3-M4.html */
		portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

		uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
c0004070:	fe042223          	sw	zero,-28(s0)
		{
			/* A task can only be prematurely removed from the Blocked state if
			it is actually in the Blocked state. */
			if( eTaskGetState( xTask ) == eBlocked )
c0004074:	fdc42503          	lw	a0,-36(s0)
c0004078:	d71fe0ef          	jal	ra,c0002de8 <eTaskGetState>
c000407c:	00050713          	mv	a4,a0
c0004080:	00200793          	li	a5,2
c0004084:	0cf71e63          	bne	a4,a5,c0004160 <xTaskAbortDelayFromISR+0x124>
			{
				xReturn = pdPASS;
c0004088:	00100793          	li	a5,1
c000408c:	fef42623          	sw	a5,-20(s0)

				/* Remove the reference to the task from the blocked list.  A higher
				priority interrupt won't touch the xStateListItem because of the
				critical section. */
				( void ) uxListRemove( &( pxTCB->xStateListItem ) );
c0004090:	fe842783          	lw	a5,-24(s0)
c0004094:	00478793          	addi	a5,a5,4
c0004098:	00078513          	mv	a0,a5
c000409c:	811fc0ef          	jal	ra,c00008ac <uxListRemove>

				/* Is the task waiting on an event also?  If so remove it from
				the event list too. */
				if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
c00040a0:	fe842783          	lw	a5,-24(s0)
c00040a4:	0287a783          	lw	a5,40(a5)
c00040a8:	02078063          	beqz	a5,c00040c8 <xTaskAbortDelayFromISR+0x8c>
				{
					( void ) uxListRemove( &( pxTCB->xEventListItem ) );
c00040ac:	fe842783          	lw	a5,-24(s0)
c00040b0:	01878793          	addi	a5,a5,24
c00040b4:	00078513          	mv	a0,a5
c00040b8:	ff4fc0ef          	jal	ra,c00008ac <uxListRemove>

					/* This lets the task know it was forcibly removed from the
					blocked state so it should not re-evaluate its block time and
					then block again. */
					pxTCB->ucDelayAborted = pdTRUE;
c00040bc:	fe842783          	lw	a5,-24(s0)
c00040c0:	00100713          	li	a4,1
c00040c4:	06e780a3          	sb	a4,97(a5)
				{
					mtCOVERAGE_TEST_MARKER();
				}

				/* Place the unblocked task into the appropriate ready list. */
				prvAddTaskToReadyList( pxTCB );
c00040c8:	fe842783          	lw	a5,-24(s0)
c00040cc:	02c7a783          	lw	a5,44(a5)
c00040d0:	00100713          	li	a4,1
c00040d4:	00f71733          	sll	a4,a4,a5
c00040d8:	07fff797          	auipc	a5,0x7fff
c00040dc:	54c78793          	addi	a5,a5,1356 # c8003624 <uxTopReadyPriority>
c00040e0:	0007a783          	lw	a5,0(a5)
c00040e4:	00f76733          	or	a4,a4,a5
c00040e8:	07fff797          	auipc	a5,0x7fff
c00040ec:	53c78793          	addi	a5,a5,1340 # c8003624 <uxTopReadyPriority>
c00040f0:	00e7a023          	sw	a4,0(a5)
c00040f4:	fe842783          	lw	a5,-24(s0)
c00040f8:	02c7a703          	lw	a4,44(a5)
c00040fc:	00070793          	mv	a5,a4
c0004100:	00279793          	slli	a5,a5,0x2
c0004104:	00e787b3          	add	a5,a5,a4
c0004108:	00279793          	slli	a5,a5,0x2
c000410c:	07fff717          	auipc	a4,0x7fff
c0004110:	43c70713          	addi	a4,a4,1084 # c8003548 <pxReadyTasksLists>
c0004114:	00e78733          	add	a4,a5,a4
c0004118:	fe842783          	lw	a5,-24(s0)
c000411c:	00478793          	addi	a5,a5,4
c0004120:	00078593          	mv	a1,a5
c0004124:	00070513          	mv	a0,a4
c0004128:	e28fc0ef          	jal	ra,c0000750 <vListInsertEnd>

				if( pxTCB->uxPriority > pxCurrentTCB->uxPriority )
c000412c:	fe842783          	lw	a5,-24(s0)
c0004130:	02c7a703          	lw	a4,44(a5)
c0004134:	07ffe797          	auipc	a5,0x7ffe
c0004138:	75878793          	addi	a5,a5,1880 # c800288c <pxCurrentTCB>
c000413c:	0007a783          	lw	a5,0(a5)
c0004140:	02c7a783          	lw	a5,44(a5)
c0004144:	02e7f063          	bgeu	a5,a4,c0004164 <xTaskAbortDelayFromISR+0x128>
				{
					if( pxHigherPriorityTaskWoken != NULL )
c0004148:	fd842783          	lw	a5,-40(s0)
c000414c:	00078c63          	beqz	a5,c0004164 <xTaskAbortDelayFromISR+0x128>
					{
						/* Pend the yield to be performed when the scheduler
						is unsuspended. */
						*pxHigherPriorityTaskWoken = pdTRUE;
c0004150:	fd842783          	lw	a5,-40(s0)
c0004154:	00100713          	li	a4,1
c0004158:	00e7a023          	sw	a4,0(a5)
c000415c:	0080006f          	j	c0004164 <xTaskAbortDelayFromISR+0x128>
					mtCOVERAGE_TEST_MARKER();
				}
			}
			else
			{
				xReturn = pdFAIL;
c0004160:	fe042623          	sw	zero,-20(s0)
			}
		}
		portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

		return xReturn;
c0004164:	fec42783          	lw	a5,-20(s0)
	}
c0004168:	00078513          	mv	a0,a5
c000416c:	02c12083          	lw	ra,44(sp)
c0004170:	02812403          	lw	s0,40(sp)
c0004174:	03010113          	addi	sp,sp,48
c0004178:	00008067          	ret

c000417c <xTaskAbortDelay>:
/*----------------------------------------------------------*/

#if ( INCLUDE_xTaskAbortDelay == 1 )

	BaseType_t xTaskAbortDelay( TaskHandle_t xTask )
	{
c000417c:	fd010113          	addi	sp,sp,-48
c0004180:	02112623          	sw	ra,44(sp)
c0004184:	02812423          	sw	s0,40(sp)
c0004188:	03010413          	addi	s0,sp,48
c000418c:	fca42e23          	sw	a0,-36(s0)
	TCB_t *pxTCB = xTask;
c0004190:	fdc42783          	lw	a5,-36(s0)
c0004194:	fef42423          	sw	a5,-24(s0)
	BaseType_t xReturn;

		configASSERT( pxTCB );
c0004198:	fe842783          	lw	a5,-24(s0)
c000419c:	00079863          	bnez	a5,c00041ac <xTaskAbortDelay+0x30>
c00041a0:	30047073          	csrci	mstatus,8
c00041a4:	00100073          	ebreak
c00041a8:	0000006f          	j	c00041a8 <xTaskAbortDelay+0x2c>

		vTaskSuspendAll();
c00041ac:	db0ff0ef          	jal	ra,c000375c <vTaskSuspendAll>
		{
			/* A task can only be prematurely removed from the Blocked state if
			it is actually in the Blocked state. */
			if( eTaskGetState( xTask ) == eBlocked )
c00041b0:	fdc42503          	lw	a0,-36(s0)
c00041b4:	c35fe0ef          	jal	ra,c0002de8 <eTaskGetState>
c00041b8:	00050713          	mv	a4,a0
c00041bc:	00200793          	li	a5,2
c00041c0:	0ef71063          	bne	a4,a5,c00042a0 <xTaskAbortDelay+0x124>
			{
				xReturn = pdPASS;
c00041c4:	00100793          	li	a5,1
c00041c8:	fef42623          	sw	a5,-20(s0)

				/* Remove the reference to the task from the blocked list.  An
				interrupt won't touch the xStateListItem because the
				scheduler is suspended. */
				( void ) uxListRemove( &( pxTCB->xStateListItem ) );
c00041cc:	fe842783          	lw	a5,-24(s0)
c00041d0:	00478793          	addi	a5,a5,4
c00041d4:	00078513          	mv	a0,a5
c00041d8:	ed4fc0ef          	jal	ra,c00008ac <uxListRemove>

				/* Is the task waiting on an event also?  If so remove it from
				the event list too.  Interrupts can touch the event list item,
				even though the scheduler is suspended, so a critical section
				is used. */
				taskENTER_CRITICAL();
c00041dc:	764010ef          	jal	ra,c0005940 <vTaskEnterCritical>
				{
					if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
c00041e0:	fe842783          	lw	a5,-24(s0)
c00041e4:	0287a783          	lw	a5,40(a5)
c00041e8:	02078063          	beqz	a5,c0004208 <xTaskAbortDelay+0x8c>
					{
						( void ) uxListRemove( &( pxTCB->xEventListItem ) );
c00041ec:	fe842783          	lw	a5,-24(s0)
c00041f0:	01878793          	addi	a5,a5,24
c00041f4:	00078513          	mv	a0,a5
c00041f8:	eb4fc0ef          	jal	ra,c00008ac <uxListRemove>

						/* This lets the task know it was forcibly removed from the
						blocked state so it should not re-evaluate its block time and
						then block again. */
						pxTCB->ucDelayAborted = pdTRUE;
c00041fc:	fe842783          	lw	a5,-24(s0)
c0004200:	00100713          	li	a4,1
c0004204:	06e780a3          	sb	a4,97(a5)
					else
					{
						mtCOVERAGE_TEST_MARKER();
					}
				}
				taskEXIT_CRITICAL();
c0004208:	78c010ef          	jal	ra,c0005994 <vTaskExitCritical>

				/* Place the unblocked task into the appropriate ready list. */
				prvAddTaskToReadyList( pxTCB );
c000420c:	fe842783          	lw	a5,-24(s0)
c0004210:	02c7a783          	lw	a5,44(a5)
c0004214:	00100713          	li	a4,1
c0004218:	00f71733          	sll	a4,a4,a5
c000421c:	07fff797          	auipc	a5,0x7fff
c0004220:	40878793          	addi	a5,a5,1032 # c8003624 <uxTopReadyPriority>
c0004224:	0007a783          	lw	a5,0(a5)
c0004228:	00f76733          	or	a4,a4,a5
c000422c:	07fff797          	auipc	a5,0x7fff
c0004230:	3f878793          	addi	a5,a5,1016 # c8003624 <uxTopReadyPriority>
c0004234:	00e7a023          	sw	a4,0(a5)
c0004238:	fe842783          	lw	a5,-24(s0)
c000423c:	02c7a703          	lw	a4,44(a5)
c0004240:	00070793          	mv	a5,a4
c0004244:	00279793          	slli	a5,a5,0x2
c0004248:	00e787b3          	add	a5,a5,a4
c000424c:	00279793          	slli	a5,a5,0x2
c0004250:	07fff717          	auipc	a4,0x7fff
c0004254:	2f870713          	addi	a4,a4,760 # c8003548 <pxReadyTasksLists>
c0004258:	00e78733          	add	a4,a5,a4
c000425c:	fe842783          	lw	a5,-24(s0)
c0004260:	00478793          	addi	a5,a5,4
c0004264:	00078593          	mv	a1,a5
c0004268:	00070513          	mv	a0,a4
c000426c:	ce4fc0ef          	jal	ra,c0000750 <vListInsertEnd>
				#if (  configUSE_PREEMPTION == 1 )
				{
					/* Preemption is on, but a context switch should only be
					performed if the unblocked task has a priority that is
					equal to or higher than the currently executing task. */
					if( pxTCB->uxPriority > pxCurrentTCB->uxPriority )
c0004270:	fe842783          	lw	a5,-24(s0)
c0004274:	02c7a703          	lw	a4,44(a5)
c0004278:	07ffe797          	auipc	a5,0x7ffe
c000427c:	61478793          	addi	a5,a5,1556 # c800288c <pxCurrentTCB>
c0004280:	0007a783          	lw	a5,0(a5)
c0004284:	02c7a783          	lw	a5,44(a5)
c0004288:	00e7fe63          	bgeu	a5,a4,c00042a4 <xTaskAbortDelay+0x128>
					{
						/* Pend the yield to be performed when the scheduler
						is unsuspended. */
						xYieldPending = pdTRUE;
c000428c:	07fff797          	auipc	a5,0x7fff
c0004290:	3a478793          	addi	a5,a5,932 # c8003630 <xYieldPending>
c0004294:	00100713          	li	a4,1
c0004298:	00e7a023          	sw	a4,0(a5)
c000429c:	0080006f          	j	c00042a4 <xTaskAbortDelay+0x128>
				}
				#endif /* configUSE_PREEMPTION */
			}
			else
			{
				xReturn = pdFAIL;
c00042a0:	fe042623          	sw	zero,-20(s0)
			}
		}
		( void ) xTaskResumeAll();
c00042a4:	cf0ff0ef          	jal	ra,c0003794 <xTaskResumeAll>

		return xReturn;
c00042a8:	fec42783          	lw	a5,-20(s0)
	}
c00042ac:	00078513          	mv	a0,a5
c00042b0:	02c12083          	lw	ra,44(sp)
c00042b4:	02812403          	lw	s0,40(sp)
c00042b8:	03010113          	addi	sp,sp,48
c00042bc:	00008067          	ret

c00042c0 <xTaskIncrementTick>:

#endif /* INCLUDE_xTaskAbortDelay */
/*----------------------------------------------------------*/

BaseType_t xTaskIncrementTick( void )
{
c00042c0:	fd010113          	addi	sp,sp,-48
c00042c4:	02112623          	sw	ra,44(sp)
c00042c8:	02812423          	sw	s0,40(sp)
c00042cc:	03010413          	addi	s0,sp,48
TCB_t * pxTCB;
TickType_t xItemValue;
BaseType_t xSwitchRequired = pdFALSE;
c00042d0:	fe042623          	sw	zero,-20(s0)

	/* Called by the portable layer each time a tick interrupt occurs.
	Increments the tick then checks to see if the new tick value will cause any
	tasks to be unblocked. */
	traceTASK_INCREMENT_TICK( xTickCount );
	if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
c00042d4:	07fff797          	auipc	a5,0x7fff
c00042d8:	37078793          	addi	a5,a5,880 # c8003644 <uxSchedulerSuspended>
c00042dc:	0007a783          	lw	a5,0(a5)
c00042e0:	24079863          	bnez	a5,c0004530 <xTaskIncrementTick+0x270>
	{
		/* Minor optimisation.  The tick count cannot change in this
		block. */
		const TickType_t xConstTickCount = xTickCount + ( TickType_t ) 1;
c00042e4:	07fff797          	auipc	a5,0x7fff
c00042e8:	33c78793          	addi	a5,a5,828 # c8003620 <xTickCount>
c00042ec:	0007a783          	lw	a5,0(a5)
c00042f0:	00178793          	addi	a5,a5,1
c00042f4:	fef42423          	sw	a5,-24(s0)

		/* Increment the RTOS tick, switching the delayed and overflowed
		delayed lists if it wraps to 0. */
		xTickCount = xConstTickCount;
c00042f8:	07fff797          	auipc	a5,0x7fff
c00042fc:	32878793          	addi	a5,a5,808 # c8003620 <xTickCount>
c0004300:	fe842703          	lw	a4,-24(s0)
c0004304:	00e7a023          	sw	a4,0(a5)

		if( xConstTickCount == ( TickType_t ) 0U ) /*lint !e774 'if' does not always evaluate to false as it is looking for an overflow. */
c0004308:	fe842783          	lw	a5,-24(s0)
c000430c:	06079e63          	bnez	a5,c0004388 <xTaskIncrementTick+0xc8>
		{
			taskSWITCH_DELAYED_LISTS();
c0004310:	07fff797          	auipc	a5,0x7fff
c0004314:	2c478793          	addi	a5,a5,708 # c80035d4 <pxDelayedTaskList>
c0004318:	0007a783          	lw	a5,0(a5)
c000431c:	0007a783          	lw	a5,0(a5)
c0004320:	00078863          	beqz	a5,c0004330 <xTaskIncrementTick+0x70>
c0004324:	30047073          	csrci	mstatus,8
c0004328:	00100073          	ebreak
c000432c:	0000006f          	j	c000432c <xTaskIncrementTick+0x6c>
c0004330:	07fff797          	auipc	a5,0x7fff
c0004334:	2a478793          	addi	a5,a5,676 # c80035d4 <pxDelayedTaskList>
c0004338:	0007a783          	lw	a5,0(a5)
c000433c:	fef42223          	sw	a5,-28(s0)
c0004340:	07fff797          	auipc	a5,0x7fff
c0004344:	29878793          	addi	a5,a5,664 # c80035d8 <pxOverflowDelayedTaskList>
c0004348:	0007a703          	lw	a4,0(a5)
c000434c:	07fff797          	auipc	a5,0x7fff
c0004350:	28878793          	addi	a5,a5,648 # c80035d4 <pxDelayedTaskList>
c0004354:	00e7a023          	sw	a4,0(a5)
c0004358:	07fff797          	auipc	a5,0x7fff
c000435c:	28078793          	addi	a5,a5,640 # c80035d8 <pxOverflowDelayedTaskList>
c0004360:	fe442703          	lw	a4,-28(s0)
c0004364:	00e7a023          	sw	a4,0(a5)
c0004368:	07fff797          	auipc	a5,0x7fff
c000436c:	2cc78793          	addi	a5,a5,716 # c8003634 <xNumOfOverflows>
c0004370:	0007a783          	lw	a5,0(a5)
c0004374:	00178713          	addi	a4,a5,1
c0004378:	07fff797          	auipc	a5,0x7fff
c000437c:	2bc78793          	addi	a5,a5,700 # c8003634 <xNumOfOverflows>
c0004380:	00e7a023          	sw	a4,0(a5)
c0004384:	771000ef          	jal	ra,c00052f4 <prvResetNextTaskUnblockTime>

		/* See if this tick has made a timeout expire.  Tasks are stored in
		the	queue in the order of their wake time - meaning once one task
		has been found whose block time has not expired there is no need to
		look any further down the list. */
		if( xConstTickCount >= xNextTaskUnblockTime )
c0004388:	07fff797          	auipc	a5,0x7fff
c000438c:	2b478793          	addi	a5,a5,692 # c800363c <xNextTaskUnblockTime>
c0004390:	0007a783          	lw	a5,0(a5)
c0004394:	fe842703          	lw	a4,-24(s0)
c0004398:	12f76463          	bltu	a4,a5,c00044c0 <xTaskIncrementTick+0x200>
		{
			for( ;; )
			{
				if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
c000439c:	07fff797          	auipc	a5,0x7fff
c00043a0:	23878793          	addi	a5,a5,568 # c80035d4 <pxDelayedTaskList>
c00043a4:	0007a783          	lw	a5,0(a5)
c00043a8:	0007a783          	lw	a5,0(a5)
c00043ac:	00079c63          	bnez	a5,c00043c4 <xTaskIncrementTick+0x104>
					/* The delayed list is empty.  Set xNextTaskUnblockTime
					to the maximum possible value so it is extremely
					unlikely that the
					if( xTickCount >= xNextTaskUnblockTime ) test will pass
					next time through. */
					xNextTaskUnblockTime = portMAX_DELAY; /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
c00043b0:	07fff797          	auipc	a5,0x7fff
c00043b4:	28c78793          	addi	a5,a5,652 # c800363c <xNextTaskUnblockTime>
c00043b8:	fff00713          	li	a4,-1
c00043bc:	00e7a023          	sw	a4,0(a5)
					break;
c00043c0:	1000006f          	j	c00044c0 <xTaskIncrementTick+0x200>
				{
					/* The delayed list is not empty, get the value of the
					item at the head of the delayed list.  This is the time
					at which the task at the head of the delayed list must
					be removed from the Blocked state. */
					pxTCB = listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
c00043c4:	07fff797          	auipc	a5,0x7fff
c00043c8:	21078793          	addi	a5,a5,528 # c80035d4 <pxDelayedTaskList>
c00043cc:	0007a783          	lw	a5,0(a5)
c00043d0:	00c7a783          	lw	a5,12(a5)
c00043d4:	00c7a783          	lw	a5,12(a5)
c00043d8:	fef42023          	sw	a5,-32(s0)
					xItemValue = listGET_LIST_ITEM_VALUE( &( pxTCB->xStateListItem ) );
c00043dc:	fe042783          	lw	a5,-32(s0)
c00043e0:	0047a783          	lw	a5,4(a5)
c00043e4:	fcf42e23          	sw	a5,-36(s0)

					if( xConstTickCount < xItemValue )
c00043e8:	fe842703          	lw	a4,-24(s0)
c00043ec:	fdc42783          	lw	a5,-36(s0)
c00043f0:	00f77c63          	bgeu	a4,a5,c0004408 <xTaskIncrementTick+0x148>
						/* It is not time to unblock this item yet, but the
						item value is the time at which the task at the head
						of the blocked list must be removed from the Blocked
						state -	so record the item value in
						xNextTaskUnblockTime. */
						xNextTaskUnblockTime = xItemValue;
c00043f4:	07fff797          	auipc	a5,0x7fff
c00043f8:	24878793          	addi	a5,a5,584 # c800363c <xNextTaskUnblockTime>
c00043fc:	fdc42703          	lw	a4,-36(s0)
c0004400:	00e7a023          	sw	a4,0(a5)
						break; /*lint !e9011 Code structure here is deedmed easier to understand with multiple breaks. */
c0004404:	0bc0006f          	j	c00044c0 <xTaskIncrementTick+0x200>
					{
						mtCOVERAGE_TEST_MARKER();
					}

					/* It is time to remove the item from the Blocked state. */
					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
c0004408:	fe042783          	lw	a5,-32(s0)
c000440c:	00478793          	addi	a5,a5,4
c0004410:	00078513          	mv	a0,a5
c0004414:	c98fc0ef          	jal	ra,c00008ac <uxListRemove>

					/* Is the task waiting on an event also?  If so remove
					it from the event list. */
					if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
c0004418:	fe042783          	lw	a5,-32(s0)
c000441c:	0287a783          	lw	a5,40(a5)
c0004420:	00078a63          	beqz	a5,c0004434 <xTaskIncrementTick+0x174>
					{
						( void ) uxListRemove( &( pxTCB->xEventListItem ) );
c0004424:	fe042783          	lw	a5,-32(s0)
c0004428:	01878793          	addi	a5,a5,24
c000442c:	00078513          	mv	a0,a5
c0004430:	c7cfc0ef          	jal	ra,c00008ac <uxListRemove>
						mtCOVERAGE_TEST_MARKER();
					}

					/* Place the unblocked task into the appropriate ready
					list. */
					prvAddTaskToReadyList( pxTCB );
c0004434:	fe042783          	lw	a5,-32(s0)
c0004438:	02c7a783          	lw	a5,44(a5)
c000443c:	00100713          	li	a4,1
c0004440:	00f71733          	sll	a4,a4,a5
c0004444:	07fff797          	auipc	a5,0x7fff
c0004448:	1e078793          	addi	a5,a5,480 # c8003624 <uxTopReadyPriority>
c000444c:	0007a783          	lw	a5,0(a5)
c0004450:	00f76733          	or	a4,a4,a5
c0004454:	07fff797          	auipc	a5,0x7fff
c0004458:	1d078793          	addi	a5,a5,464 # c8003624 <uxTopReadyPriority>
c000445c:	00e7a023          	sw	a4,0(a5)
c0004460:	fe042783          	lw	a5,-32(s0)
c0004464:	02c7a703          	lw	a4,44(a5)
c0004468:	00070793          	mv	a5,a4
c000446c:	00279793          	slli	a5,a5,0x2
c0004470:	00e787b3          	add	a5,a5,a4
c0004474:	00279793          	slli	a5,a5,0x2
c0004478:	07fff717          	auipc	a4,0x7fff
c000447c:	0d070713          	addi	a4,a4,208 # c8003548 <pxReadyTasksLists>
c0004480:	00e78733          	add	a4,a5,a4
c0004484:	fe042783          	lw	a5,-32(s0)
c0004488:	00478793          	addi	a5,a5,4
c000448c:	00078593          	mv	a1,a5
c0004490:	00070513          	mv	a0,a4
c0004494:	abcfc0ef          	jal	ra,c0000750 <vListInsertEnd>
					{
						/* Preemption is on, but a context switch should
						only be performed if the unblocked task has a
						priority that is equal to or higher than the
						currently executing task. */
						if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
c0004498:	fe042783          	lw	a5,-32(s0)
c000449c:	02c7a703          	lw	a4,44(a5)
c00044a0:	07ffe797          	auipc	a5,0x7ffe
c00044a4:	3ec78793          	addi	a5,a5,1004 # c800288c <pxCurrentTCB>
c00044a8:	0007a783          	lw	a5,0(a5)
c00044ac:	02c7a783          	lw	a5,44(a5)
c00044b0:	eef766e3          	bltu	a4,a5,c000439c <xTaskIncrementTick+0xdc>
						{
							xSwitchRequired = pdTRUE;
c00044b4:	00100793          	li	a5,1
c00044b8:	fef42623          	sw	a5,-20(s0)
				if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
c00044bc:	ee1ff06f          	j	c000439c <xTaskIncrementTick+0xdc>
		/* Tasks of equal priority to the currently running task will share
		processing time (time slice) if preemption is on, and the application
		writer has not explicitly turned time slicing off. */
		#if ( ( configUSE_PREEMPTION == 1 ) && ( configUSE_TIME_SLICING == 1 ) )
		{
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ pxCurrentTCB->uxPriority ] ) ) > ( UBaseType_t ) 1 )
c00044c0:	07ffe797          	auipc	a5,0x7ffe
c00044c4:	3cc78793          	addi	a5,a5,972 # c800288c <pxCurrentTCB>
c00044c8:	0007a783          	lw	a5,0(a5)
c00044cc:	02c7a703          	lw	a4,44(a5)
c00044d0:	07fff697          	auipc	a3,0x7fff
c00044d4:	07868693          	addi	a3,a3,120 # c8003548 <pxReadyTasksLists>
c00044d8:	00070793          	mv	a5,a4
c00044dc:	00279793          	slli	a5,a5,0x2
c00044e0:	00e787b3          	add	a5,a5,a4
c00044e4:	00279793          	slli	a5,a5,0x2
c00044e8:	00f687b3          	add	a5,a3,a5
c00044ec:	0007a703          	lw	a4,0(a5)
c00044f0:	00100793          	li	a5,1
c00044f4:	00e7f663          	bgeu	a5,a4,c0004500 <xTaskIncrementTick+0x240>
			{
				xSwitchRequired = pdTRUE;
c00044f8:	00100793          	li	a5,1
c00044fc:	fef42623          	sw	a5,-20(s0)

		#if ( configUSE_TICK_HOOK == 1 )
		{
			/* Guard against the tick hook being called when the pended tick
			count is being unwound (when the scheduler is being unlocked). */
			if( xPendedTicks == ( TickType_t ) 0 )
c0004500:	07fff797          	auipc	a5,0x7fff
c0004504:	12c78793          	addi	a5,a5,300 # c800362c <xPendedTicks>
c0004508:	0007a783          	lw	a5,0(a5)
c000450c:	00079463          	bnez	a5,c0004514 <xTaskIncrementTick+0x254>
			{
				vApplicationTickHook();
c0004510:	6c4050ef          	jal	ra,c0009bd4 <vApplicationTickHook>
		}
		#endif /* configUSE_TICK_HOOK */

		#if ( configUSE_PREEMPTION == 1 )
		{
			if( xYieldPending != pdFALSE )
c0004514:	07fff797          	auipc	a5,0x7fff
c0004518:	11c78793          	addi	a5,a5,284 # c8003630 <xYieldPending>
c000451c:	0007a783          	lw	a5,0(a5)
c0004520:	02078863          	beqz	a5,c0004550 <xTaskIncrementTick+0x290>
			{
				xSwitchRequired = pdTRUE;
c0004524:	00100793          	li	a5,1
c0004528:	fef42623          	sw	a5,-20(s0)
c000452c:	0240006f          	j	c0004550 <xTaskIncrementTick+0x290>
		}
		#endif /* configUSE_PREEMPTION */
	}
	else
	{
		++xPendedTicks;
c0004530:	07fff797          	auipc	a5,0x7fff
c0004534:	0fc78793          	addi	a5,a5,252 # c800362c <xPendedTicks>
c0004538:	0007a783          	lw	a5,0(a5)
c000453c:	00178713          	addi	a4,a5,1
c0004540:	07fff797          	auipc	a5,0x7fff
c0004544:	0ec78793          	addi	a5,a5,236 # c800362c <xPendedTicks>
c0004548:	00e7a023          	sw	a4,0(a5)

		/* The tick hook gets called at regular intervals, even if the
		scheduler is locked. */
		#if ( configUSE_TICK_HOOK == 1 )
		{
			vApplicationTickHook();
c000454c:	688050ef          	jal	ra,c0009bd4 <vApplicationTickHook>
		}
		#endif
	}

	return xSwitchRequired;
c0004550:	fec42783          	lw	a5,-20(s0)
}
c0004554:	00078513          	mv	a0,a5
c0004558:	02c12083          	lw	ra,44(sp)
c000455c:	02812403          	lw	s0,40(sp)
c0004560:	03010113          	addi	sp,sp,48
c0004564:	00008067          	ret

c0004568 <vTaskSwitchContext>:

#endif /* configUSE_APPLICATION_TASK_TAG */
/*-----------------------------------------------------------*/

void vTaskSwitchContext( void )
{
c0004568:	fe010113          	addi	sp,sp,-32
c000456c:	00112e23          	sw	ra,28(sp)
c0004570:	00812c23          	sw	s0,24(sp)
c0004574:	02010413          	addi	s0,sp,32
	if( uxSchedulerSuspended != ( UBaseType_t ) pdFALSE )
c0004578:	07fff797          	auipc	a5,0x7fff
c000457c:	0cc78793          	addi	a5,a5,204 # c8003644 <uxSchedulerSuspended>
c0004580:	0007a783          	lw	a5,0(a5)
c0004584:	00078c63          	beqz	a5,c000459c <vTaskSwitchContext+0x34>
	{
		/* The scheduler is currently suspended - do not allow a context
		switch. */
		xYieldPending = pdTRUE;
c0004588:	07fff797          	auipc	a5,0x7fff
c000458c:	0a878793          	addi	a5,a5,168 # c8003630 <xYieldPending>
c0004590:	00100713          	li	a4,1
c0004594:	00e7a023          	sw	a4,0(a5)
			for additional information. */
			_impure_ptr = &( pxCurrentTCB->xNewLib_reent );
		}
		#endif /* configUSE_NEWLIB_REENTRANT */
	}
}
c0004598:	1780006f          	j	c0004710 <vTaskSwitchContext+0x1a8>
		xYieldPending = pdFALSE;
c000459c:	07fff797          	auipc	a5,0x7fff
c00045a0:	09478793          	addi	a5,a5,148 # c8003630 <xYieldPending>
c00045a4:	0007a023          	sw	zero,0(a5)
		taskCHECK_FOR_STACK_OVERFLOW();
c00045a8:	07ffe797          	auipc	a5,0x7ffe
c00045ac:	2e478793          	addi	a5,a5,740 # c800288c <pxCurrentTCB>
c00045b0:	0007a783          	lw	a5,0(a5)
c00045b4:	0307a783          	lw	a5,48(a5)
c00045b8:	fef42623          	sw	a5,-20(s0)
c00045bc:	a5a5a7b7          	lui	a5,0xa5a5a
c00045c0:	5a578793          	addi	a5,a5,1445 # a5a5a5a5 <_end+0xdd9d5d25>
c00045c4:	fef42423          	sw	a5,-24(s0)
c00045c8:	fec42783          	lw	a5,-20(s0)
c00045cc:	0007a783          	lw	a5,0(a5)
c00045d0:	fe842703          	lw	a4,-24(s0)
c00045d4:	04f71063          	bne	a4,a5,c0004614 <vTaskSwitchContext+0xac>
c00045d8:	fec42783          	lw	a5,-20(s0)
c00045dc:	00478793          	addi	a5,a5,4
c00045e0:	0007a783          	lw	a5,0(a5)
c00045e4:	fe842703          	lw	a4,-24(s0)
c00045e8:	02f71663          	bne	a4,a5,c0004614 <vTaskSwitchContext+0xac>
c00045ec:	fec42783          	lw	a5,-20(s0)
c00045f0:	00878793          	addi	a5,a5,8
c00045f4:	0007a783          	lw	a5,0(a5)
c00045f8:	fe842703          	lw	a4,-24(s0)
c00045fc:	00f71c63          	bne	a4,a5,c0004614 <vTaskSwitchContext+0xac>
c0004600:	fec42783          	lw	a5,-20(s0)
c0004604:	00c78793          	addi	a5,a5,12
c0004608:	0007a783          	lw	a5,0(a5)
c000460c:	fe842703          	lw	a4,-24(s0)
c0004610:	02f70663          	beq	a4,a5,c000463c <vTaskSwitchContext+0xd4>
c0004614:	07ffe797          	auipc	a5,0x7ffe
c0004618:	27878793          	addi	a5,a5,632 # c800288c <pxCurrentTCB>
c000461c:	0007a703          	lw	a4,0(a5)
c0004620:	07ffe797          	auipc	a5,0x7ffe
c0004624:	26c78793          	addi	a5,a5,620 # c800288c <pxCurrentTCB>
c0004628:	0007a783          	lw	a5,0(a5)
c000462c:	03478793          	addi	a5,a5,52
c0004630:	00078593          	mv	a1,a5
c0004634:	00070513          	mv	a0,a4
c0004638:	57c050ef          	jal	ra,c0009bb4 <vApplicationStackOverflowHook>
		taskSELECT_HIGHEST_PRIORITY_TASK(); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
c000463c:	07fff797          	auipc	a5,0x7fff
c0004640:	fe878793          	addi	a5,a5,-24 # c8003624 <uxTopReadyPriority>
c0004644:	0007a783          	lw	a5,0(a5)
c0004648:	00078513          	mv	a0,a5
c000464c:	7e1280ef          	jal	ra,c002d62c <__clzsi2>
c0004650:	00050793          	mv	a5,a0
c0004654:	00078713          	mv	a4,a5
c0004658:	01f00793          	li	a5,31
c000465c:	40e787b3          	sub	a5,a5,a4
c0004660:	fef42223          	sw	a5,-28(s0)
c0004664:	07fff697          	auipc	a3,0x7fff
c0004668:	ee468693          	addi	a3,a3,-284 # c8003548 <pxReadyTasksLists>
c000466c:	fe442703          	lw	a4,-28(s0)
c0004670:	00070793          	mv	a5,a4
c0004674:	00279793          	slli	a5,a5,0x2
c0004678:	00e787b3          	add	a5,a5,a4
c000467c:	00279793          	slli	a5,a5,0x2
c0004680:	00f687b3          	add	a5,a3,a5
c0004684:	0007a783          	lw	a5,0(a5)
c0004688:	00079863          	bnez	a5,c0004698 <vTaskSwitchContext+0x130>
c000468c:	30047073          	csrci	mstatus,8
c0004690:	00100073          	ebreak
c0004694:	0000006f          	j	c0004694 <vTaskSwitchContext+0x12c>
c0004698:	fe442703          	lw	a4,-28(s0)
c000469c:	00070793          	mv	a5,a4
c00046a0:	00279793          	slli	a5,a5,0x2
c00046a4:	00e787b3          	add	a5,a5,a4
c00046a8:	00279793          	slli	a5,a5,0x2
c00046ac:	07fff717          	auipc	a4,0x7fff
c00046b0:	e9c70713          	addi	a4,a4,-356 # c8003548 <pxReadyTasksLists>
c00046b4:	00e787b3          	add	a5,a5,a4
c00046b8:	fef42023          	sw	a5,-32(s0)
c00046bc:	fe042783          	lw	a5,-32(s0)
c00046c0:	0047a783          	lw	a5,4(a5)
c00046c4:	0047a703          	lw	a4,4(a5)
c00046c8:	fe042783          	lw	a5,-32(s0)
c00046cc:	00e7a223          	sw	a4,4(a5)
c00046d0:	fe042783          	lw	a5,-32(s0)
c00046d4:	0047a703          	lw	a4,4(a5)
c00046d8:	fe042783          	lw	a5,-32(s0)
c00046dc:	00878793          	addi	a5,a5,8
c00046e0:	00f71c63          	bne	a4,a5,c00046f8 <vTaskSwitchContext+0x190>
c00046e4:	fe042783          	lw	a5,-32(s0)
c00046e8:	0047a783          	lw	a5,4(a5)
c00046ec:	0047a703          	lw	a4,4(a5)
c00046f0:	fe042783          	lw	a5,-32(s0)
c00046f4:	00e7a223          	sw	a4,4(a5)
c00046f8:	fe042783          	lw	a5,-32(s0)
c00046fc:	0047a783          	lw	a5,4(a5)
c0004700:	00c7a703          	lw	a4,12(a5)
c0004704:	07ffe797          	auipc	a5,0x7ffe
c0004708:	18878793          	addi	a5,a5,392 # c800288c <pxCurrentTCB>
c000470c:	00e7a023          	sw	a4,0(a5)
}
c0004710:	00000013          	nop
c0004714:	01c12083          	lw	ra,28(sp)
c0004718:	01812403          	lw	s0,24(sp)
c000471c:	02010113          	addi	sp,sp,32
c0004720:	00008067          	ret

c0004724 <vTaskPlaceOnEventList>:
/*-----------------------------------------------------------*/

void vTaskPlaceOnEventList( List_t * const pxEventList, const TickType_t xTicksToWait )
{
c0004724:	fe010113          	addi	sp,sp,-32
c0004728:	00112e23          	sw	ra,28(sp)
c000472c:	00812c23          	sw	s0,24(sp)
c0004730:	02010413          	addi	s0,sp,32
c0004734:	fea42623          	sw	a0,-20(s0)
c0004738:	feb42423          	sw	a1,-24(s0)
	configASSERT( pxEventList );
c000473c:	fec42783          	lw	a5,-20(s0)
c0004740:	00079863          	bnez	a5,c0004750 <vTaskPlaceOnEventList+0x2c>
c0004744:	30047073          	csrci	mstatus,8
c0004748:	00100073          	ebreak
c000474c:	0000006f          	j	c000474c <vTaskPlaceOnEventList+0x28>

	/* Place the event list item of the TCB in the appropriate event list.
	This is placed in the list in priority order so the highest priority task
	is the first to be woken by the event.  The queue that contains the event
	list is locked, preventing simultaneous access from interrupts. */
	vListInsert( pxEventList, &( pxCurrentTCB->xEventListItem ) );
c0004750:	07ffe797          	auipc	a5,0x7ffe
c0004754:	13c78793          	addi	a5,a5,316 # c800288c <pxCurrentTCB>
c0004758:	0007a783          	lw	a5,0(a5)
c000475c:	01878793          	addi	a5,a5,24
c0004760:	00078593          	mv	a1,a5
c0004764:	fec42503          	lw	a0,-20(s0)
c0004768:	870fc0ef          	jal	ra,c00007d8 <vListInsert>

	prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
c000476c:	00100593          	li	a1,1
c0004770:	fe842503          	lw	a0,-24(s0)
c0004774:	6d9010ef          	jal	ra,c000664c <prvAddCurrentTaskToDelayedList>
}
c0004778:	00000013          	nop
c000477c:	01c12083          	lw	ra,28(sp)
c0004780:	01812403          	lw	s0,24(sp)
c0004784:	02010113          	addi	sp,sp,32
c0004788:	00008067          	ret

c000478c <vTaskPlaceOnUnorderedEventList>:
/*-----------------------------------------------------------*/

void vTaskPlaceOnUnorderedEventList( List_t * pxEventList, const TickType_t xItemValue, const TickType_t xTicksToWait )
{
c000478c:	fe010113          	addi	sp,sp,-32
c0004790:	00112e23          	sw	ra,28(sp)
c0004794:	00812c23          	sw	s0,24(sp)
c0004798:	02010413          	addi	s0,sp,32
c000479c:	fea42623          	sw	a0,-20(s0)
c00047a0:	feb42423          	sw	a1,-24(s0)
c00047a4:	fec42223          	sw	a2,-28(s0)
	configASSERT( pxEventList );
c00047a8:	fec42783          	lw	a5,-20(s0)
c00047ac:	00079863          	bnez	a5,c00047bc <vTaskPlaceOnUnorderedEventList+0x30>
c00047b0:	30047073          	csrci	mstatus,8
c00047b4:	00100073          	ebreak
c00047b8:	0000006f          	j	c00047b8 <vTaskPlaceOnUnorderedEventList+0x2c>

	/* THIS FUNCTION MUST BE CALLED WITH THE SCHEDULER SUSPENDED.  It is used by
	the event groups implementation. */
	configASSERT( uxSchedulerSuspended != 0 );
c00047bc:	07fff797          	auipc	a5,0x7fff
c00047c0:	e8878793          	addi	a5,a5,-376 # c8003644 <uxSchedulerSuspended>
c00047c4:	0007a783          	lw	a5,0(a5)
c00047c8:	00079863          	bnez	a5,c00047d8 <vTaskPlaceOnUnorderedEventList+0x4c>
c00047cc:	30047073          	csrci	mstatus,8
c00047d0:	00100073          	ebreak
c00047d4:	0000006f          	j	c00047d4 <vTaskPlaceOnUnorderedEventList+0x48>

	/* Store the item value in the event list item.  It is safe to access the
	event list item here as interrupts won't access the event list item of a
	task that is not in the Blocked state. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ), xItemValue | taskEVENT_LIST_ITEM_VALUE_IN_USE );
c00047d8:	07ffe797          	auipc	a5,0x7ffe
c00047dc:	0b478793          	addi	a5,a5,180 # c800288c <pxCurrentTCB>
c00047e0:	0007a783          	lw	a5,0(a5)
c00047e4:	fe842683          	lw	a3,-24(s0)
c00047e8:	80000737          	lui	a4,0x80000
c00047ec:	00e6e733          	or	a4,a3,a4
c00047f0:	00e7ac23          	sw	a4,24(a5)
	/* Place the event list item of the TCB at the end of the appropriate event
	list.  It is safe to access the event list here because it is part of an
	event group implementation - and interrupts don't access event groups
	directly (instead they access them indirectly by pending function calls to
	the task level). */
	vListInsertEnd( pxEventList, &( pxCurrentTCB->xEventListItem ) );
c00047f4:	07ffe797          	auipc	a5,0x7ffe
c00047f8:	09878793          	addi	a5,a5,152 # c800288c <pxCurrentTCB>
c00047fc:	0007a783          	lw	a5,0(a5)
c0004800:	01878793          	addi	a5,a5,24
c0004804:	00078593          	mv	a1,a5
c0004808:	fec42503          	lw	a0,-20(s0)
c000480c:	f45fb0ef          	jal	ra,c0000750 <vListInsertEnd>

	prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
c0004810:	00100593          	li	a1,1
c0004814:	fe442503          	lw	a0,-28(s0)
c0004818:	635010ef          	jal	ra,c000664c <prvAddCurrentTaskToDelayedList>
}
c000481c:	00000013          	nop
c0004820:	01c12083          	lw	ra,28(sp)
c0004824:	01812403          	lw	s0,24(sp)
c0004828:	02010113          	addi	sp,sp,32
c000482c:	00008067          	ret

c0004830 <vTaskPlaceOnEventListRestricted>:
/*-----------------------------------------------------------*/

#if( configUSE_TIMERS == 1 )

	void vTaskPlaceOnEventListRestricted( List_t * const pxEventList, TickType_t xTicksToWait, const BaseType_t xWaitIndefinitely )
	{
c0004830:	fe010113          	addi	sp,sp,-32
c0004834:	00112e23          	sw	ra,28(sp)
c0004838:	00812c23          	sw	s0,24(sp)
c000483c:	02010413          	addi	s0,sp,32
c0004840:	fea42623          	sw	a0,-20(s0)
c0004844:	feb42423          	sw	a1,-24(s0)
c0004848:	fec42223          	sw	a2,-28(s0)
		configASSERT( pxEventList );
c000484c:	fec42783          	lw	a5,-20(s0)
c0004850:	00079863          	bnez	a5,c0004860 <vTaskPlaceOnEventListRestricted+0x30>
c0004854:	30047073          	csrci	mstatus,8
c0004858:	00100073          	ebreak
c000485c:	0000006f          	j	c000485c <vTaskPlaceOnEventListRestricted+0x2c>

		/* Place the event list item of the TCB in the appropriate event list.
		In this case it is assume that this is the only task that is going to
		be waiting on this event list, so the faster vListInsertEnd() function
		can be used in place of vListInsert. */
		vListInsertEnd( pxEventList, &( pxCurrentTCB->xEventListItem ) );
c0004860:	07ffe797          	auipc	a5,0x7ffe
c0004864:	02c78793          	addi	a5,a5,44 # c800288c <pxCurrentTCB>
c0004868:	0007a783          	lw	a5,0(a5)
c000486c:	01878793          	addi	a5,a5,24
c0004870:	00078593          	mv	a1,a5
c0004874:	fec42503          	lw	a0,-20(s0)
c0004878:	ed9fb0ef          	jal	ra,c0000750 <vListInsertEnd>

		/* If the task should block indefinitely then set the block time to a
		value that will be recognised as an indefinite delay inside the
		prvAddCurrentTaskToDelayedList() function. */
		if( xWaitIndefinitely != pdFALSE )
c000487c:	fe442783          	lw	a5,-28(s0)
c0004880:	00078663          	beqz	a5,c000488c <vTaskPlaceOnEventListRestricted+0x5c>
		{
			xTicksToWait = portMAX_DELAY;
c0004884:	fff00793          	li	a5,-1
c0004888:	fef42423          	sw	a5,-24(s0)
		}

		traceTASK_DELAY_UNTIL( ( xTickCount + xTicksToWait ) );
		prvAddCurrentTaskToDelayedList( xTicksToWait, xWaitIndefinitely );
c000488c:	fe442583          	lw	a1,-28(s0)
c0004890:	fe842503          	lw	a0,-24(s0)
c0004894:	5b9010ef          	jal	ra,c000664c <prvAddCurrentTaskToDelayedList>
	}
c0004898:	00000013          	nop
c000489c:	01c12083          	lw	ra,28(sp)
c00048a0:	01812403          	lw	s0,24(sp)
c00048a4:	02010113          	addi	sp,sp,32
c00048a8:	00008067          	ret

c00048ac <xTaskRemoveFromEventList>:

#endif /* configUSE_TIMERS */
/*-----------------------------------------------------------*/

BaseType_t xTaskRemoveFromEventList( const List_t * const pxEventList )
{
c00048ac:	fd010113          	addi	sp,sp,-48
c00048b0:	02112623          	sw	ra,44(sp)
c00048b4:	02812423          	sw	s0,40(sp)
c00048b8:	03010413          	addi	s0,sp,48
c00048bc:	fca42e23          	sw	a0,-36(s0)
	get called - the lock count on the queue will get modified instead.  This
	means exclusive access to the event list is guaranteed here.

	This function assumes that a check has already been made to ensure that
	pxEventList is not empty. */
	pxUnblockedTCB = listGET_OWNER_OF_HEAD_ENTRY( pxEventList ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
c00048c0:	fdc42783          	lw	a5,-36(s0)
c00048c4:	00c7a783          	lw	a5,12(a5)
c00048c8:	00c7a783          	lw	a5,12(a5)
c00048cc:	fef42423          	sw	a5,-24(s0)
	configASSERT( pxUnblockedTCB );
c00048d0:	fe842783          	lw	a5,-24(s0)
c00048d4:	00079863          	bnez	a5,c00048e4 <xTaskRemoveFromEventList+0x38>
c00048d8:	30047073          	csrci	mstatus,8
c00048dc:	00100073          	ebreak
c00048e0:	0000006f          	j	c00048e0 <xTaskRemoveFromEventList+0x34>
	( void ) uxListRemove( &( pxUnblockedTCB->xEventListItem ) );
c00048e4:	fe842783          	lw	a5,-24(s0)
c00048e8:	01878793          	addi	a5,a5,24
c00048ec:	00078513          	mv	a0,a5
c00048f0:	fbdfb0ef          	jal	ra,c00008ac <uxListRemove>

	if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
c00048f4:	07fff797          	auipc	a5,0x7fff
c00048f8:	d5078793          	addi	a5,a5,-688 # c8003644 <uxSchedulerSuspended>
c00048fc:	0007a783          	lw	a5,0(a5)
c0004900:	06079e63          	bnez	a5,c000497c <xTaskRemoveFromEventList+0xd0>
	{
		( void ) uxListRemove( &( pxUnblockedTCB->xStateListItem ) );
c0004904:	fe842783          	lw	a5,-24(s0)
c0004908:	00478793          	addi	a5,a5,4
c000490c:	00078513          	mv	a0,a5
c0004910:	f9dfb0ef          	jal	ra,c00008ac <uxListRemove>
		prvAddTaskToReadyList( pxUnblockedTCB );
c0004914:	fe842783          	lw	a5,-24(s0)
c0004918:	02c7a783          	lw	a5,44(a5)
c000491c:	00100713          	li	a4,1
c0004920:	00f71733          	sll	a4,a4,a5
c0004924:	07fff797          	auipc	a5,0x7fff
c0004928:	d0078793          	addi	a5,a5,-768 # c8003624 <uxTopReadyPriority>
c000492c:	0007a783          	lw	a5,0(a5)
c0004930:	00f76733          	or	a4,a4,a5
c0004934:	07fff797          	auipc	a5,0x7fff
c0004938:	cf078793          	addi	a5,a5,-784 # c8003624 <uxTopReadyPriority>
c000493c:	00e7a023          	sw	a4,0(a5)
c0004940:	fe842783          	lw	a5,-24(s0)
c0004944:	02c7a703          	lw	a4,44(a5)
c0004948:	00070793          	mv	a5,a4
c000494c:	00279793          	slli	a5,a5,0x2
c0004950:	00e787b3          	add	a5,a5,a4
c0004954:	00279793          	slli	a5,a5,0x2
c0004958:	07fff717          	auipc	a4,0x7fff
c000495c:	bf070713          	addi	a4,a4,-1040 # c8003548 <pxReadyTasksLists>
c0004960:	00e78733          	add	a4,a5,a4
c0004964:	fe842783          	lw	a5,-24(s0)
c0004968:	00478793          	addi	a5,a5,4
c000496c:	00078593          	mv	a1,a5
c0004970:	00070513          	mv	a0,a4
c0004974:	dddfb0ef          	jal	ra,c0000750 <vListInsertEnd>
c0004978:	01c0006f          	j	c0004994 <xTaskRemoveFromEventList+0xe8>
	}
	else
	{
		/* The delayed and ready lists cannot be accessed, so hold this task
		pending until the scheduler is resumed. */
		vListInsertEnd( &( xPendingReadyList ), &( pxUnblockedTCB->xEventListItem ) );
c000497c:	fe842783          	lw	a5,-24(s0)
c0004980:	01878793          	addi	a5,a5,24
c0004984:	00078593          	mv	a1,a5
c0004988:	07fff517          	auipc	a0,0x7fff
c000498c:	c5450513          	addi	a0,a0,-940 # c80035dc <xPendingReadyList>
c0004990:	dc1fb0ef          	jal	ra,c0000750 <vListInsertEnd>
	}

	if( pxUnblockedTCB->uxPriority > pxCurrentTCB->uxPriority )
c0004994:	fe842783          	lw	a5,-24(s0)
c0004998:	02c7a703          	lw	a4,44(a5)
c000499c:	07ffe797          	auipc	a5,0x7ffe
c00049a0:	ef078793          	addi	a5,a5,-272 # c800288c <pxCurrentTCB>
c00049a4:	0007a783          	lw	a5,0(a5)
c00049a8:	02c7a783          	lw	a5,44(a5)
c00049ac:	02e7f063          	bgeu	a5,a4,c00049cc <xTaskRemoveFromEventList+0x120>
	{
		/* Return true if the task removed from the event list has a higher
		priority than the calling task.  This allows the calling task to know if
		it should force a context switch now. */
		xReturn = pdTRUE;
c00049b0:	00100793          	li	a5,1
c00049b4:	fef42623          	sw	a5,-20(s0)

		/* Mark that a yield is pending in case the user is not using the
		"xHigherPriorityTaskWoken" parameter to an ISR safe FreeRTOS function. */
		xYieldPending = pdTRUE;
c00049b8:	07fff797          	auipc	a5,0x7fff
c00049bc:	c7878793          	addi	a5,a5,-904 # c8003630 <xYieldPending>
c00049c0:	00100713          	li	a4,1
c00049c4:	00e7a023          	sw	a4,0(a5)
c00049c8:	0080006f          	j	c00049d0 <xTaskRemoveFromEventList+0x124>
	}
	else
	{
		xReturn = pdFALSE;
c00049cc:	fe042623          	sw	zero,-20(s0)
	}

	return xReturn;
c00049d0:	fec42783          	lw	a5,-20(s0)
}
c00049d4:	00078513          	mv	a0,a5
c00049d8:	02c12083          	lw	ra,44(sp)
c00049dc:	02812403          	lw	s0,40(sp)
c00049e0:	03010113          	addi	sp,sp,48
c00049e4:	00008067          	ret

c00049e8 <vTaskRemoveFromUnorderedEventList>:
/*-----------------------------------------------------------*/

void vTaskRemoveFromUnorderedEventList( ListItem_t * pxEventListItem, const TickType_t xItemValue )
{
c00049e8:	fd010113          	addi	sp,sp,-48
c00049ec:	02112623          	sw	ra,44(sp)
c00049f0:	02812423          	sw	s0,40(sp)
c00049f4:	03010413          	addi	s0,sp,48
c00049f8:	fca42e23          	sw	a0,-36(s0)
c00049fc:	fcb42c23          	sw	a1,-40(s0)
TCB_t *pxUnblockedTCB;

	/* THIS FUNCTION MUST BE CALLED WITH THE SCHEDULER SUSPENDED.  It is used by
	the event flags implementation. */
	configASSERT( uxSchedulerSuspended != pdFALSE );
c0004a00:	07fff797          	auipc	a5,0x7fff
c0004a04:	c4478793          	addi	a5,a5,-956 # c8003644 <uxSchedulerSuspended>
c0004a08:	0007a783          	lw	a5,0(a5)
c0004a0c:	00079863          	bnez	a5,c0004a1c <vTaskRemoveFromUnorderedEventList+0x34>
c0004a10:	30047073          	csrci	mstatus,8
c0004a14:	00100073          	ebreak
c0004a18:	0000006f          	j	c0004a18 <vTaskRemoveFromUnorderedEventList+0x30>

	/* Store the new item value in the event list. */
	listSET_LIST_ITEM_VALUE( pxEventListItem, xItemValue | taskEVENT_LIST_ITEM_VALUE_IN_USE );
c0004a1c:	fd842703          	lw	a4,-40(s0)
c0004a20:	800007b7          	lui	a5,0x80000
c0004a24:	00f76733          	or	a4,a4,a5
c0004a28:	fdc42783          	lw	a5,-36(s0)
c0004a2c:	00e7a023          	sw	a4,0(a5) # 80000000 <_end+0xb7f7b780>

	/* Remove the event list form the event flag.  Interrupts do not access
	event flags. */
	pxUnblockedTCB = listGET_LIST_ITEM_OWNER( pxEventListItem ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
c0004a30:	fdc42783          	lw	a5,-36(s0)
c0004a34:	00c7a783          	lw	a5,12(a5)
c0004a38:	fef42623          	sw	a5,-20(s0)
	configASSERT( pxUnblockedTCB );
c0004a3c:	fec42783          	lw	a5,-20(s0)
c0004a40:	00079863          	bnez	a5,c0004a50 <vTaskRemoveFromUnorderedEventList+0x68>
c0004a44:	30047073          	csrci	mstatus,8
c0004a48:	00100073          	ebreak
c0004a4c:	0000006f          	j	c0004a4c <vTaskRemoveFromUnorderedEventList+0x64>
	( void ) uxListRemove( pxEventListItem );
c0004a50:	fdc42503          	lw	a0,-36(s0)
c0004a54:	e59fb0ef          	jal	ra,c00008ac <uxListRemove>
	#endif

	/* Remove the task from the delayed list and add it to the ready list.  The
	scheduler is suspended so interrupts will not be accessing the ready
	lists. */
	( void ) uxListRemove( &( pxUnblockedTCB->xStateListItem ) );
c0004a58:	fec42783          	lw	a5,-20(s0)
c0004a5c:	00478793          	addi	a5,a5,4
c0004a60:	00078513          	mv	a0,a5
c0004a64:	e49fb0ef          	jal	ra,c00008ac <uxListRemove>
	prvAddTaskToReadyList( pxUnblockedTCB );
c0004a68:	fec42783          	lw	a5,-20(s0)
c0004a6c:	02c7a783          	lw	a5,44(a5)
c0004a70:	00100713          	li	a4,1
c0004a74:	00f71733          	sll	a4,a4,a5
c0004a78:	07fff797          	auipc	a5,0x7fff
c0004a7c:	bac78793          	addi	a5,a5,-1108 # c8003624 <uxTopReadyPriority>
c0004a80:	0007a783          	lw	a5,0(a5)
c0004a84:	00f76733          	or	a4,a4,a5
c0004a88:	07fff797          	auipc	a5,0x7fff
c0004a8c:	b9c78793          	addi	a5,a5,-1124 # c8003624 <uxTopReadyPriority>
c0004a90:	00e7a023          	sw	a4,0(a5)
c0004a94:	fec42783          	lw	a5,-20(s0)
c0004a98:	02c7a703          	lw	a4,44(a5)
c0004a9c:	00070793          	mv	a5,a4
c0004aa0:	00279793          	slli	a5,a5,0x2
c0004aa4:	00e787b3          	add	a5,a5,a4
c0004aa8:	00279793          	slli	a5,a5,0x2
c0004aac:	07fff717          	auipc	a4,0x7fff
c0004ab0:	a9c70713          	addi	a4,a4,-1380 # c8003548 <pxReadyTasksLists>
c0004ab4:	00e78733          	add	a4,a5,a4
c0004ab8:	fec42783          	lw	a5,-20(s0)
c0004abc:	00478793          	addi	a5,a5,4
c0004ac0:	00078593          	mv	a1,a5
c0004ac4:	00070513          	mv	a0,a4
c0004ac8:	c89fb0ef          	jal	ra,c0000750 <vListInsertEnd>

	if( pxUnblockedTCB->uxPriority > pxCurrentTCB->uxPriority )
c0004acc:	fec42783          	lw	a5,-20(s0)
c0004ad0:	02c7a703          	lw	a4,44(a5)
c0004ad4:	07ffe797          	auipc	a5,0x7ffe
c0004ad8:	db878793          	addi	a5,a5,-584 # c800288c <pxCurrentTCB>
c0004adc:	0007a783          	lw	a5,0(a5)
c0004ae0:	02c7a783          	lw	a5,44(a5)
c0004ae4:	00e7fa63          	bgeu	a5,a4,c0004af8 <vTaskRemoveFromUnorderedEventList+0x110>
	{
		/* The unblocked task has a priority above that of the calling task, so
		a context switch is required.  This function is called with the
		scheduler suspended so xYieldPending is set so the context switch
		occurs immediately that the scheduler is resumed (unsuspended). */
		xYieldPending = pdTRUE;
c0004ae8:	07fff797          	auipc	a5,0x7fff
c0004aec:	b4878793          	addi	a5,a5,-1208 # c8003630 <xYieldPending>
c0004af0:	00100713          	li	a4,1
c0004af4:	00e7a023          	sw	a4,0(a5)
	}
}
c0004af8:	00000013          	nop
c0004afc:	02c12083          	lw	ra,44(sp)
c0004b00:	02812403          	lw	s0,40(sp)
c0004b04:	03010113          	addi	sp,sp,48
c0004b08:	00008067          	ret

c0004b0c <vTaskSetTimeOutState>:
/*-----------------------------------------------------------*/

void vTaskSetTimeOutState( TimeOut_t * const pxTimeOut )
{
c0004b0c:	fe010113          	addi	sp,sp,-32
c0004b10:	00112e23          	sw	ra,28(sp)
c0004b14:	00812c23          	sw	s0,24(sp)
c0004b18:	02010413          	addi	s0,sp,32
c0004b1c:	fea42623          	sw	a0,-20(s0)
	configASSERT( pxTimeOut );
c0004b20:	fec42783          	lw	a5,-20(s0)
c0004b24:	00079863          	bnez	a5,c0004b34 <vTaskSetTimeOutState+0x28>
c0004b28:	30047073          	csrci	mstatus,8
c0004b2c:	00100073          	ebreak
c0004b30:	0000006f          	j	c0004b30 <vTaskSetTimeOutState+0x24>
	taskENTER_CRITICAL();
c0004b34:	60d000ef          	jal	ra,c0005940 <vTaskEnterCritical>
	{
		pxTimeOut->xOverflowCount = xNumOfOverflows;
c0004b38:	07fff797          	auipc	a5,0x7fff
c0004b3c:	afc78793          	addi	a5,a5,-1284 # c8003634 <xNumOfOverflows>
c0004b40:	0007a703          	lw	a4,0(a5)
c0004b44:	fec42783          	lw	a5,-20(s0)
c0004b48:	00e7a023          	sw	a4,0(a5)
		pxTimeOut->xTimeOnEntering = xTickCount;
c0004b4c:	07fff797          	auipc	a5,0x7fff
c0004b50:	ad478793          	addi	a5,a5,-1324 # c8003620 <xTickCount>
c0004b54:	0007a703          	lw	a4,0(a5)
c0004b58:	fec42783          	lw	a5,-20(s0)
c0004b5c:	00e7a223          	sw	a4,4(a5)
	}
	taskEXIT_CRITICAL();
c0004b60:	635000ef          	jal	ra,c0005994 <vTaskExitCritical>
}
c0004b64:	00000013          	nop
c0004b68:	01c12083          	lw	ra,28(sp)
c0004b6c:	01812403          	lw	s0,24(sp)
c0004b70:	02010113          	addi	sp,sp,32
c0004b74:	00008067          	ret

c0004b78 <vTaskInternalSetTimeOutState>:
/*-----------------------------------------------------------*/

void vTaskInternalSetTimeOutState( TimeOut_t * const pxTimeOut )
{
c0004b78:	fe010113          	addi	sp,sp,-32
c0004b7c:	00812e23          	sw	s0,28(sp)
c0004b80:	02010413          	addi	s0,sp,32
c0004b84:	fea42623          	sw	a0,-20(s0)
	/* For internal use only as it does not use a critical section. */
	pxTimeOut->xOverflowCount = xNumOfOverflows;
c0004b88:	07fff797          	auipc	a5,0x7fff
c0004b8c:	aac78793          	addi	a5,a5,-1364 # c8003634 <xNumOfOverflows>
c0004b90:	0007a703          	lw	a4,0(a5)
c0004b94:	fec42783          	lw	a5,-20(s0)
c0004b98:	00e7a023          	sw	a4,0(a5)
	pxTimeOut->xTimeOnEntering = xTickCount;
c0004b9c:	07fff797          	auipc	a5,0x7fff
c0004ba0:	a8478793          	addi	a5,a5,-1404 # c8003620 <xTickCount>
c0004ba4:	0007a703          	lw	a4,0(a5)
c0004ba8:	fec42783          	lw	a5,-20(s0)
c0004bac:	00e7a223          	sw	a4,4(a5)
}
c0004bb0:	00000013          	nop
c0004bb4:	01c12403          	lw	s0,28(sp)
c0004bb8:	02010113          	addi	sp,sp,32
c0004bbc:	00008067          	ret

c0004bc0 <xTaskCheckForTimeOut>:
/*-----------------------------------------------------------*/

BaseType_t xTaskCheckForTimeOut( TimeOut_t * const pxTimeOut, TickType_t * const pxTicksToWait )
{
c0004bc0:	fd010113          	addi	sp,sp,-48
c0004bc4:	02112623          	sw	ra,44(sp)
c0004bc8:	02812423          	sw	s0,40(sp)
c0004bcc:	03010413          	addi	s0,sp,48
c0004bd0:	fca42e23          	sw	a0,-36(s0)
c0004bd4:	fcb42c23          	sw	a1,-40(s0)
BaseType_t xReturn;

	configASSERT( pxTimeOut );
c0004bd8:	fdc42783          	lw	a5,-36(s0)
c0004bdc:	00079863          	bnez	a5,c0004bec <xTaskCheckForTimeOut+0x2c>
c0004be0:	30047073          	csrci	mstatus,8
c0004be4:	00100073          	ebreak
c0004be8:	0000006f          	j	c0004be8 <xTaskCheckForTimeOut+0x28>
	configASSERT( pxTicksToWait );
c0004bec:	fd842783          	lw	a5,-40(s0)
c0004bf0:	00079863          	bnez	a5,c0004c00 <xTaskCheckForTimeOut+0x40>
c0004bf4:	30047073          	csrci	mstatus,8
c0004bf8:	00100073          	ebreak
c0004bfc:	0000006f          	j	c0004bfc <xTaskCheckForTimeOut+0x3c>

	taskENTER_CRITICAL();
c0004c00:	541000ef          	jal	ra,c0005940 <vTaskEnterCritical>
	{
		/* Minor optimisation.  The tick count cannot change in this block. */
		const TickType_t xConstTickCount = xTickCount;
c0004c04:	07fff797          	auipc	a5,0x7fff
c0004c08:	a1c78793          	addi	a5,a5,-1508 # c8003620 <xTickCount>
c0004c0c:	0007a783          	lw	a5,0(a5)
c0004c10:	fef42423          	sw	a5,-24(s0)
		const TickType_t xElapsedTime = xConstTickCount - pxTimeOut->xTimeOnEntering;
c0004c14:	fdc42783          	lw	a5,-36(s0)
c0004c18:	0047a783          	lw	a5,4(a5)
c0004c1c:	fe842703          	lw	a4,-24(s0)
c0004c20:	40f707b3          	sub	a5,a4,a5
c0004c24:	fef42223          	sw	a5,-28(s0)

		#if( INCLUDE_xTaskAbortDelay == 1 )
			if( pxCurrentTCB->ucDelayAborted != ( uint8_t ) pdFALSE )
c0004c28:	07ffe797          	auipc	a5,0x7ffe
c0004c2c:	c6478793          	addi	a5,a5,-924 # c800288c <pxCurrentTCB>
c0004c30:	0007a783          	lw	a5,0(a5)
c0004c34:	0617c783          	lbu	a5,97(a5)
c0004c38:	02078063          	beqz	a5,c0004c58 <xTaskCheckForTimeOut+0x98>
			{
				/* The delay was aborted, which is not the same as a time out,
				but has the same result. */
				pxCurrentTCB->ucDelayAborted = pdFALSE;
c0004c3c:	07ffe797          	auipc	a5,0x7ffe
c0004c40:	c5078793          	addi	a5,a5,-944 # c800288c <pxCurrentTCB>
c0004c44:	0007a783          	lw	a5,0(a5)
c0004c48:	060780a3          	sb	zero,97(a5)
				xReturn = pdTRUE;
c0004c4c:	00100793          	li	a5,1
c0004c50:	fef42623          	sw	a5,-20(s0)
c0004c54:	0980006f          	j	c0004cec <xTaskCheckForTimeOut+0x12c>
			}
			else
		#endif

		#if ( INCLUDE_vTaskSuspend == 1 )
			if( *pxTicksToWait == portMAX_DELAY )
c0004c58:	fd842783          	lw	a5,-40(s0)
c0004c5c:	0007a703          	lw	a4,0(a5)
c0004c60:	fff00793          	li	a5,-1
c0004c64:	00f71663          	bne	a4,a5,c0004c70 <xTaskCheckForTimeOut+0xb0>
			{
				/* If INCLUDE_vTaskSuspend is set to 1 and the block time
				specified is the maximum block time then the task should block
				indefinitely, and therefore never time out. */
				xReturn = pdFALSE;
c0004c68:	fe042623          	sw	zero,-20(s0)
c0004c6c:	0800006f          	j	c0004cec <xTaskCheckForTimeOut+0x12c>
			}
			else
		#endif

		if( ( xNumOfOverflows != pxTimeOut->xOverflowCount ) && ( xConstTickCount >= pxTimeOut->xTimeOnEntering ) ) /*lint !e525 Indentation preferred as is to make code within pre-processor directives clearer. */
c0004c70:	fdc42783          	lw	a5,-36(s0)
c0004c74:	0007a703          	lw	a4,0(a5)
c0004c78:	07fff797          	auipc	a5,0x7fff
c0004c7c:	9bc78793          	addi	a5,a5,-1604 # c8003634 <xNumOfOverflows>
c0004c80:	0007a783          	lw	a5,0(a5)
c0004c84:	02f70063          	beq	a4,a5,c0004ca4 <xTaskCheckForTimeOut+0xe4>
c0004c88:	fdc42783          	lw	a5,-36(s0)
c0004c8c:	0047a783          	lw	a5,4(a5)
c0004c90:	fe842703          	lw	a4,-24(s0)
c0004c94:	00f76863          	bltu	a4,a5,c0004ca4 <xTaskCheckForTimeOut+0xe4>
			/* The tick count is greater than the time at which
			vTaskSetTimeout() was called, but has also overflowed since
			vTaskSetTimeOut() was called.  It must have wrapped all the way
			around and gone past again. This passed since vTaskSetTimeout()
			was called. */
			xReturn = pdTRUE;
c0004c98:	00100793          	li	a5,1
c0004c9c:	fef42623          	sw	a5,-20(s0)
c0004ca0:	04c0006f          	j	c0004cec <xTaskCheckForTimeOut+0x12c>
		}
		else if( xElapsedTime < *pxTicksToWait ) /*lint !e961 Explicit casting is only redundant with some compilers, whereas others require it to prevent integer conversion errors. */
c0004ca4:	fd842783          	lw	a5,-40(s0)
c0004ca8:	0007a783          	lw	a5,0(a5)
c0004cac:	fe442703          	lw	a4,-28(s0)
c0004cb0:	02f77663          	bgeu	a4,a5,c0004cdc <xTaskCheckForTimeOut+0x11c>
		{
			/* Not a genuine timeout. Adjust parameters for time remaining. */
			*pxTicksToWait -= xElapsedTime;
c0004cb4:	fd842783          	lw	a5,-40(s0)
c0004cb8:	0007a703          	lw	a4,0(a5)
c0004cbc:	fe442783          	lw	a5,-28(s0)
c0004cc0:	40f70733          	sub	a4,a4,a5
c0004cc4:	fd842783          	lw	a5,-40(s0)
c0004cc8:	00e7a023          	sw	a4,0(a5)
			vTaskInternalSetTimeOutState( pxTimeOut );
c0004ccc:	fdc42503          	lw	a0,-36(s0)
c0004cd0:	ea9ff0ef          	jal	ra,c0004b78 <vTaskInternalSetTimeOutState>
			xReturn = pdFALSE;
c0004cd4:	fe042623          	sw	zero,-20(s0)
c0004cd8:	0140006f          	j	c0004cec <xTaskCheckForTimeOut+0x12c>
		}
		else
		{
			*pxTicksToWait = 0;
c0004cdc:	fd842783          	lw	a5,-40(s0)
c0004ce0:	0007a023          	sw	zero,0(a5)
			xReturn = pdTRUE;
c0004ce4:	00100793          	li	a5,1
c0004ce8:	fef42623          	sw	a5,-20(s0)
		}
	}
	taskEXIT_CRITICAL();
c0004cec:	4a9000ef          	jal	ra,c0005994 <vTaskExitCritical>

	return xReturn;
c0004cf0:	fec42783          	lw	a5,-20(s0)
}
c0004cf4:	00078513          	mv	a0,a5
c0004cf8:	02c12083          	lw	ra,44(sp)
c0004cfc:	02812403          	lw	s0,40(sp)
c0004d00:	03010113          	addi	sp,sp,48
c0004d04:	00008067          	ret

c0004d08 <vTaskMissedYield>:
/*-----------------------------------------------------------*/

void vTaskMissedYield( void )
{
c0004d08:	ff010113          	addi	sp,sp,-16
c0004d0c:	00812623          	sw	s0,12(sp)
c0004d10:	01010413          	addi	s0,sp,16
	xYieldPending = pdTRUE;
c0004d14:	07fff797          	auipc	a5,0x7fff
c0004d18:	91c78793          	addi	a5,a5,-1764 # c8003630 <xYieldPending>
c0004d1c:	00100713          	li	a4,1
c0004d20:	00e7a023          	sw	a4,0(a5)
}
c0004d24:	00000013          	nop
c0004d28:	00c12403          	lw	s0,12(sp)
c0004d2c:	01010113          	addi	sp,sp,16
c0004d30:	00008067          	ret

c0004d34 <uxTaskGetTaskNumber>:
/*-----------------------------------------------------------*/

#if ( configUSE_TRACE_FACILITY == 1 )

	UBaseType_t uxTaskGetTaskNumber( TaskHandle_t xTask )
	{
c0004d34:	fd010113          	addi	sp,sp,-48
c0004d38:	02812623          	sw	s0,44(sp)
c0004d3c:	03010413          	addi	s0,sp,48
c0004d40:	fca42e23          	sw	a0,-36(s0)
	UBaseType_t uxReturn;
	TCB_t const *pxTCB;

		if( xTask != NULL )
c0004d44:	fdc42783          	lw	a5,-36(s0)
c0004d48:	00078e63          	beqz	a5,c0004d64 <uxTaskGetTaskNumber+0x30>
		{
			pxTCB = xTask;
c0004d4c:	fdc42783          	lw	a5,-36(s0)
c0004d50:	fef42423          	sw	a5,-24(s0)
			uxReturn = pxTCB->uxTaskNumber;
c0004d54:	fe842783          	lw	a5,-24(s0)
c0004d58:	0507a783          	lw	a5,80(a5)
c0004d5c:	fef42623          	sw	a5,-20(s0)
c0004d60:	0080006f          	j	c0004d68 <uxTaskGetTaskNumber+0x34>
		}
		else
		{
			uxReturn = 0U;
c0004d64:	fe042623          	sw	zero,-20(s0)
		}

		return uxReturn;
c0004d68:	fec42783          	lw	a5,-20(s0)
	}
c0004d6c:	00078513          	mv	a0,a5
c0004d70:	02c12403          	lw	s0,44(sp)
c0004d74:	03010113          	addi	sp,sp,48
c0004d78:	00008067          	ret

c0004d7c <vTaskSetTaskNumber>:
/*-----------------------------------------------------------*/

#if ( configUSE_TRACE_FACILITY == 1 )

	void vTaskSetTaskNumber( TaskHandle_t xTask, const UBaseType_t uxHandle )
	{
c0004d7c:	fd010113          	addi	sp,sp,-48
c0004d80:	02812623          	sw	s0,44(sp)
c0004d84:	03010413          	addi	s0,sp,48
c0004d88:	fca42e23          	sw	a0,-36(s0)
c0004d8c:	fcb42c23          	sw	a1,-40(s0)
	TCB_t * pxTCB;

		if( xTask != NULL )
c0004d90:	fdc42783          	lw	a5,-36(s0)
c0004d94:	00078c63          	beqz	a5,c0004dac <vTaskSetTaskNumber+0x30>
		{
			pxTCB = xTask;
c0004d98:	fdc42783          	lw	a5,-36(s0)
c0004d9c:	fef42623          	sw	a5,-20(s0)
			pxTCB->uxTaskNumber = uxHandle;
c0004da0:	fec42783          	lw	a5,-20(s0)
c0004da4:	fd842703          	lw	a4,-40(s0)
c0004da8:	04e7a823          	sw	a4,80(a5)
		}
	}
c0004dac:	00000013          	nop
c0004db0:	02c12403          	lw	s0,44(sp)
c0004db4:	03010113          	addi	sp,sp,48
c0004db8:	00008067          	ret

c0004dbc <prvIdleTask>:
 *
 * void prvIdleTask( void *pvParameters );
 *
 */
static portTASK_FUNCTION( prvIdleTask, pvParameters )
{
c0004dbc:	fe010113          	addi	sp,sp,-32
c0004dc0:	00112e23          	sw	ra,28(sp)
c0004dc4:	00812c23          	sw	s0,24(sp)
c0004dc8:	02010413          	addi	s0,sp,32
c0004dcc:	fea42623          	sw	a0,-20(s0)

	for( ;; )
	{
		/* See if any tasks have deleted themselves - if so then the idle task
		is responsible for freeing the deleted task's TCB and stack. */
		prvCheckTasksWaitingTermination();
c0004dd0:	0dc000ef          	jal	ra,c0004eac <prvCheckTasksWaitingTermination>
			/* Call the user defined function from within the idle task.  This
			allows the application designer to add background functionality
			without the overhead of a separate task.
			NOTE: vApplicationIdleHook() MUST NOT, UNDER ANY CIRCUMSTANCES,
			CALL A FUNCTION THAT MIGHT BLOCK. */
			vApplicationIdleHook();
c0004dd4:	5c5040ef          	jal	ra,c0009b98 <vApplicationIdleHook>
		prvCheckTasksWaitingTermination();
c0004dd8:	ff9ff06f          	j	c0004dd0 <prvIdleTask+0x14>

c0004ddc <prvInitialiseTaskLists>:

#endif /* portUSING_MPU_WRAPPERS */
/*-----------------------------------------------------------*/

static void prvInitialiseTaskLists( void )
{
c0004ddc:	fe010113          	addi	sp,sp,-32
c0004de0:	00112e23          	sw	ra,28(sp)
c0004de4:	00812c23          	sw	s0,24(sp)
c0004de8:	02010413          	addi	s0,sp,32
UBaseType_t uxPriority;

	for( uxPriority = ( UBaseType_t ) 0U; uxPriority < ( UBaseType_t ) configMAX_PRIORITIES; uxPriority++ )
c0004dec:	fe042623          	sw	zero,-20(s0)
c0004df0:	0380006f          	j	c0004e28 <prvInitialiseTaskLists+0x4c>
	{
		vListInitialise( &( pxReadyTasksLists[ uxPriority ] ) );
c0004df4:	fec42703          	lw	a4,-20(s0)
c0004df8:	00070793          	mv	a5,a4
c0004dfc:	00279793          	slli	a5,a5,0x2
c0004e00:	00e787b3          	add	a5,a5,a4
c0004e04:	00279793          	slli	a5,a5,0x2
c0004e08:	07ffe717          	auipc	a4,0x7ffe
c0004e0c:	74070713          	addi	a4,a4,1856 # c8003548 <pxReadyTasksLists>
c0004e10:	00e787b3          	add	a5,a5,a4
c0004e14:	00078513          	mv	a0,a5
c0004e18:	8adfb0ef          	jal	ra,c00006c4 <vListInitialise>
	for( uxPriority = ( UBaseType_t ) 0U; uxPriority < ( UBaseType_t ) configMAX_PRIORITIES; uxPriority++ )
c0004e1c:	fec42783          	lw	a5,-20(s0)
c0004e20:	00178793          	addi	a5,a5,1
c0004e24:	fef42623          	sw	a5,-20(s0)
c0004e28:	fec42703          	lw	a4,-20(s0)
c0004e2c:	00400793          	li	a5,4
c0004e30:	fce7f2e3          	bgeu	a5,a4,c0004df4 <prvInitialiseTaskLists+0x18>
	}

	vListInitialise( &xDelayedTaskList1 );
c0004e34:	07ffe517          	auipc	a0,0x7ffe
c0004e38:	77850513          	addi	a0,a0,1912 # c80035ac <xDelayedTaskList1>
c0004e3c:	889fb0ef          	jal	ra,c00006c4 <vListInitialise>
	vListInitialise( &xDelayedTaskList2 );
c0004e40:	07ffe517          	auipc	a0,0x7ffe
c0004e44:	78050513          	addi	a0,a0,1920 # c80035c0 <xDelayedTaskList2>
c0004e48:	87dfb0ef          	jal	ra,c00006c4 <vListInitialise>
	vListInitialise( &xPendingReadyList );
c0004e4c:	07ffe517          	auipc	a0,0x7ffe
c0004e50:	79050513          	addi	a0,a0,1936 # c80035dc <xPendingReadyList>
c0004e54:	871fb0ef          	jal	ra,c00006c4 <vListInitialise>

	#if ( INCLUDE_vTaskDelete == 1 )
	{
		vListInitialise( &xTasksWaitingTermination );
c0004e58:	07ffe517          	auipc	a0,0x7ffe
c0004e5c:	79850513          	addi	a0,a0,1944 # c80035f0 <xTasksWaitingTermination>
c0004e60:	865fb0ef          	jal	ra,c00006c4 <vListInitialise>
	}
	#endif /* INCLUDE_vTaskDelete */

	#if ( INCLUDE_vTaskSuspend == 1 )
	{
		vListInitialise( &xSuspendedTaskList );
c0004e64:	07ffe517          	auipc	a0,0x7ffe
c0004e68:	7a450513          	addi	a0,a0,1956 # c8003608 <xSuspendedTaskList>
c0004e6c:	859fb0ef          	jal	ra,c00006c4 <vListInitialise>
	}
	#endif /* INCLUDE_vTaskSuspend */

	/* Start with pxDelayedTaskList using list1 and the pxOverflowDelayedTaskList
	using list2. */
	pxDelayedTaskList = &xDelayedTaskList1;
c0004e70:	07ffe797          	auipc	a5,0x7ffe
c0004e74:	76478793          	addi	a5,a5,1892 # c80035d4 <pxDelayedTaskList>
c0004e78:	07ffe717          	auipc	a4,0x7ffe
c0004e7c:	73470713          	addi	a4,a4,1844 # c80035ac <xDelayedTaskList1>
c0004e80:	00e7a023          	sw	a4,0(a5)
	pxOverflowDelayedTaskList = &xDelayedTaskList2;
c0004e84:	07ffe797          	auipc	a5,0x7ffe
c0004e88:	75478793          	addi	a5,a5,1876 # c80035d8 <pxOverflowDelayedTaskList>
c0004e8c:	07ffe717          	auipc	a4,0x7ffe
c0004e90:	73470713          	addi	a4,a4,1844 # c80035c0 <xDelayedTaskList2>
c0004e94:	00e7a023          	sw	a4,0(a5)
}
c0004e98:	00000013          	nop
c0004e9c:	01c12083          	lw	ra,28(sp)
c0004ea0:	01812403          	lw	s0,24(sp)
c0004ea4:	02010113          	addi	sp,sp,32
c0004ea8:	00008067          	ret

c0004eac <prvCheckTasksWaitingTermination>:
/*-----------------------------------------------------------*/

static void prvCheckTasksWaitingTermination( void )
{
c0004eac:	fe010113          	addi	sp,sp,-32
c0004eb0:	00112e23          	sw	ra,28(sp)
c0004eb4:	00812c23          	sw	s0,24(sp)
c0004eb8:	02010413          	addi	s0,sp,32
	{
		TCB_t *pxTCB;

		/* uxDeletedTasksWaitingCleanUp is used to prevent taskENTER_CRITICAL()
		being called too often in the idle task. */
		while( uxDeletedTasksWaitingCleanUp > ( UBaseType_t ) 0U )
c0004ebc:	0700006f          	j	c0004f2c <prvCheckTasksWaitingTermination+0x80>
		{
			taskENTER_CRITICAL();
c0004ec0:	281000ef          	jal	ra,c0005940 <vTaskEnterCritical>
			{
				pxTCB = listGET_OWNER_OF_HEAD_ENTRY( ( &xTasksWaitingTermination ) ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
c0004ec4:	07ffe797          	auipc	a5,0x7ffe
c0004ec8:	72c78793          	addi	a5,a5,1836 # c80035f0 <xTasksWaitingTermination>
c0004ecc:	00c7a783          	lw	a5,12(a5)
c0004ed0:	00c7a783          	lw	a5,12(a5)
c0004ed4:	fef42623          	sw	a5,-20(s0)
				( void ) uxListRemove( &( pxTCB->xStateListItem ) );
c0004ed8:	fec42783          	lw	a5,-20(s0)
c0004edc:	00478793          	addi	a5,a5,4
c0004ee0:	00078513          	mv	a0,a5
c0004ee4:	9c9fb0ef          	jal	ra,c00008ac <uxListRemove>
				--uxCurrentNumberOfTasks;
c0004ee8:	07ffe797          	auipc	a5,0x7ffe
c0004eec:	73478793          	addi	a5,a5,1844 # c800361c <uxCurrentNumberOfTasks>
c0004ef0:	0007a783          	lw	a5,0(a5)
c0004ef4:	fff78713          	addi	a4,a5,-1
c0004ef8:	07ffe797          	auipc	a5,0x7ffe
c0004efc:	72478793          	addi	a5,a5,1828 # c800361c <uxCurrentNumberOfTasks>
c0004f00:	00e7a023          	sw	a4,0(a5)
				--uxDeletedTasksWaitingCleanUp;
c0004f04:	07ffe797          	auipc	a5,0x7ffe
c0004f08:	70078793          	addi	a5,a5,1792 # c8003604 <uxDeletedTasksWaitingCleanUp>
c0004f0c:	0007a783          	lw	a5,0(a5)
c0004f10:	fff78713          	addi	a4,a5,-1
c0004f14:	07ffe797          	auipc	a5,0x7ffe
c0004f18:	6f078793          	addi	a5,a5,1776 # c8003604 <uxDeletedTasksWaitingCleanUp>
c0004f1c:	00e7a023          	sw	a4,0(a5)
			}
			taskEXIT_CRITICAL();
c0004f20:	275000ef          	jal	ra,c0005994 <vTaskExitCritical>

			prvDeleteTCB( pxTCB );
c0004f24:	fec42503          	lw	a0,-20(s0)
c0004f28:	38c000ef          	jal	ra,c00052b4 <prvDeleteTCB>
		while( uxDeletedTasksWaitingCleanUp > ( UBaseType_t ) 0U )
c0004f2c:	07ffe797          	auipc	a5,0x7ffe
c0004f30:	6d878793          	addi	a5,a5,1752 # c8003604 <uxDeletedTasksWaitingCleanUp>
c0004f34:	0007a783          	lw	a5,0(a5)
c0004f38:	f80794e3          	bnez	a5,c0004ec0 <prvCheckTasksWaitingTermination+0x14>
		}
	}
	#endif /* INCLUDE_vTaskDelete */
}
c0004f3c:	00000013          	nop
c0004f40:	00000013          	nop
c0004f44:	01c12083          	lw	ra,28(sp)
c0004f48:	01812403          	lw	s0,24(sp)
c0004f4c:	02010113          	addi	sp,sp,32
c0004f50:	00008067          	ret

c0004f54 <vTaskGetInfo>:
/*-----------------------------------------------------------*/

#if( configUSE_TRACE_FACILITY == 1 )

	void vTaskGetInfo( TaskHandle_t xTask, TaskStatus_t *pxTaskStatus, BaseType_t xGetFreeStackSpace, eTaskState eState )
	{
c0004f54:	fd010113          	addi	sp,sp,-48
c0004f58:	02112623          	sw	ra,44(sp)
c0004f5c:	02812423          	sw	s0,40(sp)
c0004f60:	03010413          	addi	s0,sp,48
c0004f64:	fca42e23          	sw	a0,-36(s0)
c0004f68:	fcb42c23          	sw	a1,-40(s0)
c0004f6c:	fcc42a23          	sw	a2,-44(s0)
c0004f70:	fcd42823          	sw	a3,-48(s0)
	TCB_t *pxTCB;

		/* xTask is NULL then get the state of the calling task. */
		pxTCB = prvGetTCBFromHandle( xTask );
c0004f74:	fdc42783          	lw	a5,-36(s0)
c0004f78:	00079a63          	bnez	a5,c0004f8c <vTaskGetInfo+0x38>
c0004f7c:	07ffe797          	auipc	a5,0x7ffe
c0004f80:	91078793          	addi	a5,a5,-1776 # c800288c <pxCurrentTCB>
c0004f84:	0007a783          	lw	a5,0(a5)
c0004f88:	0080006f          	j	c0004f90 <vTaskGetInfo+0x3c>
c0004f8c:	fdc42783          	lw	a5,-36(s0)
c0004f90:	fef42623          	sw	a5,-20(s0)

		pxTaskStatus->xHandle = ( TaskHandle_t ) pxTCB;
c0004f94:	fd842783          	lw	a5,-40(s0)
c0004f98:	fec42703          	lw	a4,-20(s0)
c0004f9c:	00e7a023          	sw	a4,0(a5)
		pxTaskStatus->pcTaskName = ( const char * ) &( pxTCB->pcTaskName [ 0 ] );
c0004fa0:	fec42783          	lw	a5,-20(s0)
c0004fa4:	03478713          	addi	a4,a5,52
c0004fa8:	fd842783          	lw	a5,-40(s0)
c0004fac:	00e7a223          	sw	a4,4(a5)
		pxTaskStatus->uxCurrentPriority = pxTCB->uxPriority;
c0004fb0:	fec42783          	lw	a5,-20(s0)
c0004fb4:	02c7a703          	lw	a4,44(a5)
c0004fb8:	fd842783          	lw	a5,-40(s0)
c0004fbc:	00e7a823          	sw	a4,16(a5)
		pxTaskStatus->pxStackBase = pxTCB->pxStack;
c0004fc0:	fec42783          	lw	a5,-20(s0)
c0004fc4:	0307a703          	lw	a4,48(a5)
c0004fc8:	fd842783          	lw	a5,-40(s0)
c0004fcc:	00e7ae23          	sw	a4,28(a5)
		pxTaskStatus->xTaskNumber = pxTCB->uxTCBNumber;
c0004fd0:	fec42783          	lw	a5,-20(s0)
c0004fd4:	04c7a703          	lw	a4,76(a5)
c0004fd8:	fd842783          	lw	a5,-40(s0)
c0004fdc:	00e7a423          	sw	a4,8(a5)

		#if ( configUSE_MUTEXES == 1 )
		{
			pxTaskStatus->uxBasePriority = pxTCB->uxBasePriority;
c0004fe0:	fec42783          	lw	a5,-20(s0)
c0004fe4:	0547a703          	lw	a4,84(a5)
c0004fe8:	fd842783          	lw	a5,-40(s0)
c0004fec:	00e7aa23          	sw	a4,20(a5)
		{
			pxTaskStatus->ulRunTimeCounter = pxTCB->ulRunTimeCounter;
		}
		#else
		{
			pxTaskStatus->ulRunTimeCounter = 0;
c0004ff0:	fd842783          	lw	a5,-40(s0)
c0004ff4:	0007ac23          	sw	zero,24(a5)
		#endif

		/* Obtaining the task state is a little fiddly, so is only done if the
		value of eState passed into this function is eInvalid - otherwise the
		state is just set to whatever is passed in. */
		if( eState != eInvalid )
c0004ff8:	fd042703          	lw	a4,-48(s0)
c0004ffc:	00500793          	li	a5,5
c0005000:	06f70063          	beq	a4,a5,c0005060 <vTaskGetInfo+0x10c>
		{
			if( pxTCB == pxCurrentTCB )
c0005004:	07ffe797          	auipc	a5,0x7ffe
c0005008:	88878793          	addi	a5,a5,-1912 # c800288c <pxCurrentTCB>
c000500c:	0007a783          	lw	a5,0(a5)
c0005010:	fec42703          	lw	a4,-20(s0)
c0005014:	00f71863          	bne	a4,a5,c0005024 <vTaskGetInfo+0xd0>
			{
				pxTaskStatus->eCurrentState = eRunning;
c0005018:	fd842783          	lw	a5,-40(s0)
c000501c:	0007a623          	sw	zero,12(a5)
c0005020:	0540006f          	j	c0005074 <vTaskGetInfo+0x120>
			}
			else
			{
				pxTaskStatus->eCurrentState = eState;
c0005024:	fd842783          	lw	a5,-40(s0)
c0005028:	fd042703          	lw	a4,-48(s0)
c000502c:	00e7a623          	sw	a4,12(a5)
				#if ( INCLUDE_vTaskSuspend == 1 )
				{
					/* If the task is in the suspended list then there is a
					chance it is actually just blocked indefinitely - so really
					it should be reported as being in the Blocked state. */
					if( eState == eSuspended )
c0005030:	fd042703          	lw	a4,-48(s0)
c0005034:	00300793          	li	a5,3
c0005038:	02f71e63          	bne	a4,a5,c0005074 <vTaskGetInfo+0x120>
					{
						vTaskSuspendAll();
c000503c:	f20fe0ef          	jal	ra,c000375c <vTaskSuspendAll>
						{
							if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
c0005040:	fec42783          	lw	a5,-20(s0)
c0005044:	0287a783          	lw	a5,40(a5)
c0005048:	00078863          	beqz	a5,c0005058 <vTaskGetInfo+0x104>
							{
								pxTaskStatus->eCurrentState = eBlocked;
c000504c:	fd842783          	lw	a5,-40(s0)
c0005050:	00200713          	li	a4,2
c0005054:	00e7a623          	sw	a4,12(a5)
							}
						}
						( void ) xTaskResumeAll();
c0005058:	f3cfe0ef          	jal	ra,c0003794 <xTaskResumeAll>
c000505c:	0180006f          	j	c0005074 <vTaskGetInfo+0x120>
				#endif /* INCLUDE_vTaskSuspend */
			}
		}
		else
		{
			pxTaskStatus->eCurrentState = eTaskGetState( pxTCB );
c0005060:	fec42503          	lw	a0,-20(s0)
c0005064:	d85fd0ef          	jal	ra,c0002de8 <eTaskGetState>
c0005068:	00050713          	mv	a4,a0
c000506c:	fd842783          	lw	a5,-40(s0)
c0005070:	00e7a623          	sw	a4,12(a5)
		}

		/* Obtaining the stack space takes some time, so the xGetFreeStackSpace
		parameter is provided to allow it to be skipped. */
		if( xGetFreeStackSpace != pdFALSE )
c0005074:	fd442783          	lw	a5,-44(s0)
c0005078:	02078263          	beqz	a5,c000509c <vTaskGetInfo+0x148>
			{
				pxTaskStatus->usStackHighWaterMark = prvTaskCheckFreeStackSpace( ( uint8_t * ) pxTCB->pxEndOfStack );
			}
			#else
			{
				pxTaskStatus->usStackHighWaterMark = prvTaskCheckFreeStackSpace( ( uint8_t * ) pxTCB->pxStack );
c000507c:	fec42783          	lw	a5,-20(s0)
c0005080:	0307a783          	lw	a5,48(a5)
c0005084:	00078513          	mv	a0,a5
c0005088:	168000ef          	jal	ra,c00051f0 <prvTaskCheckFreeStackSpace>
c000508c:	00050713          	mv	a4,a0
c0005090:	fd842783          	lw	a5,-40(s0)
c0005094:	02e7a023          	sw	a4,32(a5)
		}
		else
		{
			pxTaskStatus->usStackHighWaterMark = 0;
		}
	}
c0005098:	00c0006f          	j	c00050a4 <vTaskGetInfo+0x150>
			pxTaskStatus->usStackHighWaterMark = 0;
c000509c:	fd842783          	lw	a5,-40(s0)
c00050a0:	0207a023          	sw	zero,32(a5)
	}
c00050a4:	00000013          	nop
c00050a8:	02c12083          	lw	ra,44(sp)
c00050ac:	02812403          	lw	s0,40(sp)
c00050b0:	03010113          	addi	sp,sp,48
c00050b4:	00008067          	ret

c00050b8 <prvListTasksWithinSingleList>:
/*-----------------------------------------------------------*/

#if ( configUSE_TRACE_FACILITY == 1 )

	static UBaseType_t prvListTasksWithinSingleList( TaskStatus_t *pxTaskStatusArray, List_t *pxList, eTaskState eState )
	{
c00050b8:	fc010113          	addi	sp,sp,-64
c00050bc:	02112e23          	sw	ra,60(sp)
c00050c0:	02812c23          	sw	s0,56(sp)
c00050c4:	04010413          	addi	s0,sp,64
c00050c8:	fca42623          	sw	a0,-52(s0)
c00050cc:	fcb42423          	sw	a1,-56(s0)
c00050d0:	fcc42223          	sw	a2,-60(s0)
	configLIST_VOLATILE TCB_t *pxNextTCB, *pxFirstTCB;
	UBaseType_t uxTask = 0;
c00050d4:	fe042623          	sw	zero,-20(s0)

		if( listCURRENT_LIST_LENGTH( pxList ) > ( UBaseType_t ) 0 )
c00050d8:	fc842783          	lw	a5,-56(s0)
c00050dc:	0007a783          	lw	a5,0(a5)
c00050e0:	0e078c63          	beqz	a5,c00051d8 <prvListTasksWithinSingleList+0x120>
		{
			listGET_OWNER_OF_NEXT_ENTRY( pxFirstTCB, pxList ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
c00050e4:	fc842783          	lw	a5,-56(s0)
c00050e8:	fef42423          	sw	a5,-24(s0)
c00050ec:	fe842783          	lw	a5,-24(s0)
c00050f0:	0047a783          	lw	a5,4(a5)
c00050f4:	0047a703          	lw	a4,4(a5)
c00050f8:	fe842783          	lw	a5,-24(s0)
c00050fc:	00e7a223          	sw	a4,4(a5)
c0005100:	fe842783          	lw	a5,-24(s0)
c0005104:	0047a703          	lw	a4,4(a5)
c0005108:	fe842783          	lw	a5,-24(s0)
c000510c:	00878793          	addi	a5,a5,8
c0005110:	00f71c63          	bne	a4,a5,c0005128 <prvListTasksWithinSingleList+0x70>
c0005114:	fe842783          	lw	a5,-24(s0)
c0005118:	0047a783          	lw	a5,4(a5)
c000511c:	0047a703          	lw	a4,4(a5)
c0005120:	fe842783          	lw	a5,-24(s0)
c0005124:	00e7a223          	sw	a4,4(a5)
c0005128:	fe842783          	lw	a5,-24(s0)
c000512c:	0047a783          	lw	a5,4(a5)
c0005130:	00c7a783          	lw	a5,12(a5)
c0005134:	fef42223          	sw	a5,-28(s0)
			pxTaskStatusArray array for each task that is referenced from
			pxList.  See the definition of TaskStatus_t in task.h for the
			meaning of each TaskStatus_t structure member. */
			do
			{
				listGET_OWNER_OF_NEXT_ENTRY( pxNextTCB, pxList ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
c0005138:	fc842783          	lw	a5,-56(s0)
c000513c:	fef42023          	sw	a5,-32(s0)
c0005140:	fe042783          	lw	a5,-32(s0)
c0005144:	0047a783          	lw	a5,4(a5)
c0005148:	0047a703          	lw	a4,4(a5)
c000514c:	fe042783          	lw	a5,-32(s0)
c0005150:	00e7a223          	sw	a4,4(a5)
c0005154:	fe042783          	lw	a5,-32(s0)
c0005158:	0047a703          	lw	a4,4(a5)
c000515c:	fe042783          	lw	a5,-32(s0)
c0005160:	00878793          	addi	a5,a5,8
c0005164:	00f71c63          	bne	a4,a5,c000517c <prvListTasksWithinSingleList+0xc4>
c0005168:	fe042783          	lw	a5,-32(s0)
c000516c:	0047a783          	lw	a5,4(a5)
c0005170:	0047a703          	lw	a4,4(a5)
c0005174:	fe042783          	lw	a5,-32(s0)
c0005178:	00e7a223          	sw	a4,4(a5)
c000517c:	fe042783          	lw	a5,-32(s0)
c0005180:	0047a783          	lw	a5,4(a5)
c0005184:	00c7a783          	lw	a5,12(a5)
c0005188:	fcf42e23          	sw	a5,-36(s0)
				vTaskGetInfo( ( TaskHandle_t ) pxNextTCB, &( pxTaskStatusArray[ uxTask ] ), pdTRUE, eState );
c000518c:	fec42703          	lw	a4,-20(s0)
c0005190:	00070793          	mv	a5,a4
c0005194:	00379793          	slli	a5,a5,0x3
c0005198:	00e787b3          	add	a5,a5,a4
c000519c:	00279793          	slli	a5,a5,0x2
c00051a0:	00078713          	mv	a4,a5
c00051a4:	fcc42783          	lw	a5,-52(s0)
c00051a8:	00e787b3          	add	a5,a5,a4
c00051ac:	fc442683          	lw	a3,-60(s0)
c00051b0:	00100613          	li	a2,1
c00051b4:	00078593          	mv	a1,a5
c00051b8:	fdc42503          	lw	a0,-36(s0)
c00051bc:	d99ff0ef          	jal	ra,c0004f54 <vTaskGetInfo>
				uxTask++;
c00051c0:	fec42783          	lw	a5,-20(s0)
c00051c4:	00178793          	addi	a5,a5,1
c00051c8:	fef42623          	sw	a5,-20(s0)
			} while( pxNextTCB != pxFirstTCB );
c00051cc:	fdc42703          	lw	a4,-36(s0)
c00051d0:	fe442783          	lw	a5,-28(s0)
c00051d4:	f6f712e3          	bne	a4,a5,c0005138 <prvListTasksWithinSingleList+0x80>
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}

		return uxTask;
c00051d8:	fec42783          	lw	a5,-20(s0)
	}
c00051dc:	00078513          	mv	a0,a5
c00051e0:	03c12083          	lw	ra,60(sp)
c00051e4:	03812403          	lw	s0,56(sp)
c00051e8:	04010113          	addi	sp,sp,64
c00051ec:	00008067          	ret

c00051f0 <prvTaskCheckFreeStackSpace>:
/*-----------------------------------------------------------*/

#if ( ( configUSE_TRACE_FACILITY == 1 ) || ( INCLUDE_uxTaskGetStackHighWaterMark == 1 ) || ( INCLUDE_uxTaskGetStackHighWaterMark2 == 1 ) )

	static configSTACK_DEPTH_TYPE prvTaskCheckFreeStackSpace( const uint8_t * pucStackByte )
	{
c00051f0:	fd010113          	addi	sp,sp,-48
c00051f4:	02812623          	sw	s0,44(sp)
c00051f8:	03010413          	addi	s0,sp,48
c00051fc:	fca42e23          	sw	a0,-36(s0)
	uint32_t ulCount = 0U;
c0005200:	fe042623          	sw	zero,-20(s0)

		while( *pucStackByte == ( uint8_t ) tskSTACK_FILL_BYTE )
c0005204:	01c0006f          	j	c0005220 <prvTaskCheckFreeStackSpace+0x30>
		{
			pucStackByte -= portSTACK_GROWTH;
c0005208:	fdc42783          	lw	a5,-36(s0)
c000520c:	00178793          	addi	a5,a5,1
c0005210:	fcf42e23          	sw	a5,-36(s0)
			ulCount++;
c0005214:	fec42783          	lw	a5,-20(s0)
c0005218:	00178793          	addi	a5,a5,1
c000521c:	fef42623          	sw	a5,-20(s0)
		while( *pucStackByte == ( uint8_t ) tskSTACK_FILL_BYTE )
c0005220:	fdc42783          	lw	a5,-36(s0)
c0005224:	0007c703          	lbu	a4,0(a5)
c0005228:	0a500793          	li	a5,165
c000522c:	fcf70ee3          	beq	a4,a5,c0005208 <prvTaskCheckFreeStackSpace+0x18>
		}

		ulCount /= ( uint32_t ) sizeof( StackType_t ); /*lint !e961 Casting is not redundant on smaller architectures. */
c0005230:	fec42783          	lw	a5,-20(s0)
c0005234:	0027d793          	srli	a5,a5,0x2
c0005238:	fef42623          	sw	a5,-20(s0)

		return ( configSTACK_DEPTH_TYPE ) ulCount;
c000523c:	fec42783          	lw	a5,-20(s0)
	}
c0005240:	00078513          	mv	a0,a5
c0005244:	02c12403          	lw	s0,44(sp)
c0005248:	03010113          	addi	sp,sp,48
c000524c:	00008067          	ret

c0005250 <uxTaskGetStackHighWaterMark>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_uxTaskGetStackHighWaterMark == 1 )

	UBaseType_t uxTaskGetStackHighWaterMark( TaskHandle_t xTask )
	{
c0005250:	fd010113          	addi	sp,sp,-48
c0005254:	02112623          	sw	ra,44(sp)
c0005258:	02812423          	sw	s0,40(sp)
c000525c:	03010413          	addi	s0,sp,48
c0005260:	fca42e23          	sw	a0,-36(s0)
	TCB_t *pxTCB;
	uint8_t *pucEndOfStack;
	UBaseType_t uxReturn;

		pxTCB = prvGetTCBFromHandle( xTask );
c0005264:	fdc42783          	lw	a5,-36(s0)
c0005268:	00079a63          	bnez	a5,c000527c <uxTaskGetStackHighWaterMark+0x2c>
c000526c:	07ffd797          	auipc	a5,0x7ffd
c0005270:	62078793          	addi	a5,a5,1568 # c800288c <pxCurrentTCB>
c0005274:	0007a783          	lw	a5,0(a5)
c0005278:	0080006f          	j	c0005280 <uxTaskGetStackHighWaterMark+0x30>
c000527c:	fdc42783          	lw	a5,-36(s0)
c0005280:	fef42623          	sw	a5,-20(s0)

		#if portSTACK_GROWTH < 0
		{
			pucEndOfStack = ( uint8_t * ) pxTCB->pxStack;
c0005284:	fec42783          	lw	a5,-20(s0)
c0005288:	0307a783          	lw	a5,48(a5)
c000528c:	fef42423          	sw	a5,-24(s0)
		{
			pucEndOfStack = ( uint8_t * ) pxTCB->pxEndOfStack;
		}
		#endif

		uxReturn = ( UBaseType_t ) prvTaskCheckFreeStackSpace( pucEndOfStack );
c0005290:	fe842503          	lw	a0,-24(s0)
c0005294:	f5dff0ef          	jal	ra,c00051f0 <prvTaskCheckFreeStackSpace>
c0005298:	fea42223          	sw	a0,-28(s0)

		return uxReturn;
c000529c:	fe442783          	lw	a5,-28(s0)
	}
c00052a0:	00078513          	mv	a0,a5
c00052a4:	02c12083          	lw	ra,44(sp)
c00052a8:	02812403          	lw	s0,40(sp)
c00052ac:	03010113          	addi	sp,sp,48
c00052b0:	00008067          	ret

c00052b4 <prvDeleteTCB>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelete == 1 )

	static void prvDeleteTCB( TCB_t *pxTCB )
	{
c00052b4:	fe010113          	addi	sp,sp,-32
c00052b8:	00112e23          	sw	ra,28(sp)
c00052bc:	00812c23          	sw	s0,24(sp)
c00052c0:	02010413          	addi	s0,sp,32
c00052c4:	fea42623          	sw	a0,-20(s0)

		#if( ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) && ( configSUPPORT_STATIC_ALLOCATION == 0 ) && ( portUSING_MPU_WRAPPERS == 0 ) )
		{
			/* The task can only have been allocated dynamically - free both
			the stack and TCB. */
			vPortFree( pxTCB->pxStack );
c00052c8:	fec42783          	lw	a5,-20(s0)
c00052cc:	0307a783          	lw	a5,48(a5)
c00052d0:	00078513          	mv	a0,a5
c00052d4:	264040ef          	jal	ra,c0009538 <vPortFree>
			vPortFree( pxTCB );
c00052d8:	fec42503          	lw	a0,-20(s0)
c00052dc:	25c040ef          	jal	ra,c0009538 <vPortFree>
				configASSERT( pxTCB->ucStaticallyAllocated == tskSTATICALLY_ALLOCATED_STACK_AND_TCB	);
				mtCOVERAGE_TEST_MARKER();
			}
		}
		#endif /* configSUPPORT_DYNAMIC_ALLOCATION */
	}
c00052e0:	00000013          	nop
c00052e4:	01c12083          	lw	ra,28(sp)
c00052e8:	01812403          	lw	s0,24(sp)
c00052ec:	02010113          	addi	sp,sp,32
c00052f0:	00008067          	ret

c00052f4 <prvResetNextTaskUnblockTime>:

#endif /* INCLUDE_vTaskDelete */
/*-----------------------------------------------------------*/

static void prvResetNextTaskUnblockTime( void )
{
c00052f4:	fe010113          	addi	sp,sp,-32
c00052f8:	00812e23          	sw	s0,28(sp)
c00052fc:	02010413          	addi	s0,sp,32
TCB_t *pxTCB;

	if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
c0005300:	07ffe797          	auipc	a5,0x7ffe
c0005304:	2d478793          	addi	a5,a5,724 # c80035d4 <pxDelayedTaskList>
c0005308:	0007a783          	lw	a5,0(a5)
c000530c:	0007a783          	lw	a5,0(a5)
c0005310:	00079c63          	bnez	a5,c0005328 <prvResetNextTaskUnblockTime+0x34>
	{
		/* The new current delayed list is empty.  Set xNextTaskUnblockTime to
		the maximum possible value so it is	extremely unlikely that the
		if( xTickCount >= xNextTaskUnblockTime ) test will pass until
		there is an item in the delayed list. */
		xNextTaskUnblockTime = portMAX_DELAY;
c0005314:	07ffe797          	auipc	a5,0x7ffe
c0005318:	32878793          	addi	a5,a5,808 # c800363c <xNextTaskUnblockTime>
c000531c:	fff00713          	li	a4,-1
c0005320:	00e7a023          	sw	a4,0(a5)
		which the task at the head of the delayed list should be removed
		from the Blocked state. */
		( pxTCB ) = listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
		xNextTaskUnblockTime = listGET_LIST_ITEM_VALUE( &( ( pxTCB )->xStateListItem ) );
	}
}
c0005324:	0300006f          	j	c0005354 <prvResetNextTaskUnblockTime+0x60>
		( pxTCB ) = listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
c0005328:	07ffe797          	auipc	a5,0x7ffe
c000532c:	2ac78793          	addi	a5,a5,684 # c80035d4 <pxDelayedTaskList>
c0005330:	0007a783          	lw	a5,0(a5)
c0005334:	00c7a783          	lw	a5,12(a5)
c0005338:	00c7a783          	lw	a5,12(a5)
c000533c:	fef42623          	sw	a5,-20(s0)
		xNextTaskUnblockTime = listGET_LIST_ITEM_VALUE( &( ( pxTCB )->xStateListItem ) );
c0005340:	fec42783          	lw	a5,-20(s0)
c0005344:	0047a703          	lw	a4,4(a5)
c0005348:	07ffe797          	auipc	a5,0x7ffe
c000534c:	2f478793          	addi	a5,a5,756 # c800363c <xNextTaskUnblockTime>
c0005350:	00e7a023          	sw	a4,0(a5)
}
c0005354:	00000013          	nop
c0005358:	01c12403          	lw	s0,28(sp)
c000535c:	02010113          	addi	sp,sp,32
c0005360:	00008067          	ret

c0005364 <xTaskGetCurrentTaskHandle>:
/*-----------------------------------------------------------*/

#if ( ( INCLUDE_xTaskGetCurrentTaskHandle == 1 ) || ( configUSE_MUTEXES == 1 ) )

	TaskHandle_t xTaskGetCurrentTaskHandle( void )
	{
c0005364:	fe010113          	addi	sp,sp,-32
c0005368:	00812e23          	sw	s0,28(sp)
c000536c:	02010413          	addi	s0,sp,32
	TaskHandle_t xReturn;

		/* A critical section is not required as this is not called from
		an interrupt and the current TCB will always be the same for any
		individual execution thread. */
		xReturn = pxCurrentTCB;
c0005370:	07ffd797          	auipc	a5,0x7ffd
c0005374:	51c78793          	addi	a5,a5,1308 # c800288c <pxCurrentTCB>
c0005378:	0007a783          	lw	a5,0(a5)
c000537c:	fef42623          	sw	a5,-20(s0)

		return xReturn;
c0005380:	fec42783          	lw	a5,-20(s0)
	}
c0005384:	00078513          	mv	a0,a5
c0005388:	01c12403          	lw	s0,28(sp)
c000538c:	02010113          	addi	sp,sp,32
c0005390:	00008067          	ret

c0005394 <xTaskGetSchedulerState>:
/*-----------------------------------------------------------*/

#if ( ( INCLUDE_xTaskGetSchedulerState == 1 ) || ( configUSE_TIMERS == 1 ) )

	BaseType_t xTaskGetSchedulerState( void )
	{
c0005394:	fe010113          	addi	sp,sp,-32
c0005398:	00812e23          	sw	s0,28(sp)
c000539c:	02010413          	addi	s0,sp,32
	BaseType_t xReturn;

		if( xSchedulerRunning == pdFALSE )
c00053a0:	07ffe797          	auipc	a5,0x7ffe
c00053a4:	28878793          	addi	a5,a5,648 # c8003628 <xSchedulerRunning>
c00053a8:	0007a783          	lw	a5,0(a5)
c00053ac:	00079863          	bnez	a5,c00053bc <xTaskGetSchedulerState+0x28>
		{
			xReturn = taskSCHEDULER_NOT_STARTED;
c00053b0:	00100793          	li	a5,1
c00053b4:	fef42623          	sw	a5,-20(s0)
c00053b8:	0240006f          	j	c00053dc <xTaskGetSchedulerState+0x48>
		}
		else
		{
			if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
c00053bc:	07ffe797          	auipc	a5,0x7ffe
c00053c0:	28878793          	addi	a5,a5,648 # c8003644 <uxSchedulerSuspended>
c00053c4:	0007a783          	lw	a5,0(a5)
c00053c8:	00079863          	bnez	a5,c00053d8 <xTaskGetSchedulerState+0x44>
			{
				xReturn = taskSCHEDULER_RUNNING;
c00053cc:	00200793          	li	a5,2
c00053d0:	fef42623          	sw	a5,-20(s0)
c00053d4:	0080006f          	j	c00053dc <xTaskGetSchedulerState+0x48>
			}
			else
			{
				xReturn = taskSCHEDULER_SUSPENDED;
c00053d8:	fe042623          	sw	zero,-20(s0)
			}
		}

		return xReturn;
c00053dc:	fec42783          	lw	a5,-20(s0)
	}
c00053e0:	00078513          	mv	a0,a5
c00053e4:	01c12403          	lw	s0,28(sp)
c00053e8:	02010113          	addi	sp,sp,32
c00053ec:	00008067          	ret

c00053f0 <xTaskPriorityInherit>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

	BaseType_t xTaskPriorityInherit( TaskHandle_t const pxMutexHolder )
	{
c00053f0:	fd010113          	addi	sp,sp,-48
c00053f4:	02112623          	sw	ra,44(sp)
c00053f8:	02812423          	sw	s0,40(sp)
c00053fc:	03010413          	addi	s0,sp,48
c0005400:	fca42e23          	sw	a0,-36(s0)
	TCB_t * const pxMutexHolderTCB = pxMutexHolder;
c0005404:	fdc42783          	lw	a5,-36(s0)
c0005408:	fef42423          	sw	a5,-24(s0)
	BaseType_t xReturn = pdFALSE;
c000540c:	fe042623          	sw	zero,-20(s0)

		/* If the mutex was given back by an interrupt while the queue was
		locked then the mutex holder might now be NULL.  _RB_ Is this still
		needed as interrupts can no longer use mutexes? */
		if( pxMutexHolder != NULL )
c0005410:	fdc42783          	lw	a5,-36(s0)
c0005414:	18078663          	beqz	a5,c00055a0 <xTaskPriorityInherit+0x1b0>
		{
			/* If the holder of the mutex has a priority below the priority of
			the task attempting to obtain the mutex then it will temporarily
			inherit the priority of the task attempting to obtain the mutex. */
			if( pxMutexHolderTCB->uxPriority < pxCurrentTCB->uxPriority )
c0005418:	fe842783          	lw	a5,-24(s0)
c000541c:	02c7a703          	lw	a4,44(a5)
c0005420:	07ffd797          	auipc	a5,0x7ffd
c0005424:	46c78793          	addi	a5,a5,1132 # c800288c <pxCurrentTCB>
c0005428:	0007a783          	lw	a5,0(a5)
c000542c:	02c7a783          	lw	a5,44(a5)
c0005430:	14f77663          	bgeu	a4,a5,c000557c <xTaskPriorityInherit+0x18c>
			{
				/* Adjust the mutex holder state to account for its new
				priority.  Only reset the event list item value if the value is
				not being used for anything else. */
				if( ( listGET_LIST_ITEM_VALUE( &( pxMutexHolderTCB->xEventListItem ) ) & taskEVENT_LIST_ITEM_VALUE_IN_USE ) == 0UL )
c0005434:	fe842783          	lw	a5,-24(s0)
c0005438:	0187a783          	lw	a5,24(a5)
c000543c:	0207c263          	bltz	a5,c0005460 <xTaskPriorityInherit+0x70>
				{
					listSET_LIST_ITEM_VALUE( &( pxMutexHolderTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) pxCurrentTCB->uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
c0005440:	07ffd797          	auipc	a5,0x7ffd
c0005444:	44c78793          	addi	a5,a5,1100 # c800288c <pxCurrentTCB>
c0005448:	0007a783          	lw	a5,0(a5)
c000544c:	02c7a783          	lw	a5,44(a5)
c0005450:	00500713          	li	a4,5
c0005454:	40f70733          	sub	a4,a4,a5
c0005458:	fe842783          	lw	a5,-24(s0)
c000545c:	00e7ac23          	sw	a4,24(a5)
					mtCOVERAGE_TEST_MARKER();
				}

				/* If the task being modified is in the ready state it will need
				to be moved into a new list. */
				if( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ pxMutexHolderTCB->uxPriority ] ), &( pxMutexHolderTCB->xStateListItem ) ) != pdFALSE )
c0005460:	fe842783          	lw	a5,-24(s0)
c0005464:	0147a683          	lw	a3,20(a5)
c0005468:	fe842783          	lw	a5,-24(s0)
c000546c:	02c7a703          	lw	a4,44(a5)
c0005470:	00070793          	mv	a5,a4
c0005474:	00279793          	slli	a5,a5,0x2
c0005478:	00e787b3          	add	a5,a5,a4
c000547c:	00279793          	slli	a5,a5,0x2
c0005480:	07ffe717          	auipc	a4,0x7ffe
c0005484:	0c870713          	addi	a4,a4,200 # c8003548 <pxReadyTasksLists>
c0005488:	00e787b3          	add	a5,a5,a4
c000548c:	0cf69663          	bne	a3,a5,c0005558 <xTaskPriorityInherit+0x168>
				{
					if( uxListRemove( &( pxMutexHolderTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
c0005490:	fe842783          	lw	a5,-24(s0)
c0005494:	00478793          	addi	a5,a5,4
c0005498:	00078513          	mv	a0,a5
c000549c:	c10fb0ef          	jal	ra,c00008ac <uxListRemove>
c00054a0:	00050793          	mv	a5,a0
c00054a4:	02079a63          	bnez	a5,c00054d8 <xTaskPriorityInherit+0xe8>
					{
						/* It is known that the task is in its ready list so
						there is no need to check again and the port level
						reset macro can be called directly. */
						portRESET_READY_PRIORITY( pxMutexHolderTCB->uxPriority, uxTopReadyPriority );
c00054a8:	fe842783          	lw	a5,-24(s0)
c00054ac:	02c7a783          	lw	a5,44(a5)
c00054b0:	00100713          	li	a4,1
c00054b4:	00f717b3          	sll	a5,a4,a5
c00054b8:	fff7c713          	not	a4,a5
c00054bc:	07ffe797          	auipc	a5,0x7ffe
c00054c0:	16878793          	addi	a5,a5,360 # c8003624 <uxTopReadyPriority>
c00054c4:	0007a783          	lw	a5,0(a5)
c00054c8:	00f77733          	and	a4,a4,a5
c00054cc:	07ffe797          	auipc	a5,0x7ffe
c00054d0:	15878793          	addi	a5,a5,344 # c8003624 <uxTopReadyPriority>
c00054d4:	00e7a023          	sw	a4,0(a5)
					{
						mtCOVERAGE_TEST_MARKER();
					}

					/* Inherit the priority before being moved into the new list. */
					pxMutexHolderTCB->uxPriority = pxCurrentTCB->uxPriority;
c00054d8:	07ffd797          	auipc	a5,0x7ffd
c00054dc:	3b478793          	addi	a5,a5,948 # c800288c <pxCurrentTCB>
c00054e0:	0007a783          	lw	a5,0(a5)
c00054e4:	02c7a703          	lw	a4,44(a5)
c00054e8:	fe842783          	lw	a5,-24(s0)
c00054ec:	02e7a623          	sw	a4,44(a5)
					prvAddTaskToReadyList( pxMutexHolderTCB );
c00054f0:	fe842783          	lw	a5,-24(s0)
c00054f4:	02c7a783          	lw	a5,44(a5)
c00054f8:	00100713          	li	a4,1
c00054fc:	00f71733          	sll	a4,a4,a5
c0005500:	07ffe797          	auipc	a5,0x7ffe
c0005504:	12478793          	addi	a5,a5,292 # c8003624 <uxTopReadyPriority>
c0005508:	0007a783          	lw	a5,0(a5)
c000550c:	00f76733          	or	a4,a4,a5
c0005510:	07ffe797          	auipc	a5,0x7ffe
c0005514:	11478793          	addi	a5,a5,276 # c8003624 <uxTopReadyPriority>
c0005518:	00e7a023          	sw	a4,0(a5)
c000551c:	fe842783          	lw	a5,-24(s0)
c0005520:	02c7a703          	lw	a4,44(a5)
c0005524:	00070793          	mv	a5,a4
c0005528:	00279793          	slli	a5,a5,0x2
c000552c:	00e787b3          	add	a5,a5,a4
c0005530:	00279793          	slli	a5,a5,0x2
c0005534:	07ffe717          	auipc	a4,0x7ffe
c0005538:	01470713          	addi	a4,a4,20 # c8003548 <pxReadyTasksLists>
c000553c:	00e78733          	add	a4,a5,a4
c0005540:	fe842783          	lw	a5,-24(s0)
c0005544:	00478793          	addi	a5,a5,4
c0005548:	00078593          	mv	a1,a5
c000554c:	00070513          	mv	a0,a4
c0005550:	a00fb0ef          	jal	ra,c0000750 <vListInsertEnd>
c0005554:	01c0006f          	j	c0005570 <xTaskPriorityInherit+0x180>
				}
				else
				{
					/* Just inherit the priority. */
					pxMutexHolderTCB->uxPriority = pxCurrentTCB->uxPriority;
c0005558:	07ffd797          	auipc	a5,0x7ffd
c000555c:	33478793          	addi	a5,a5,820 # c800288c <pxCurrentTCB>
c0005560:	0007a783          	lw	a5,0(a5)
c0005564:	02c7a703          	lw	a4,44(a5)
c0005568:	fe842783          	lw	a5,-24(s0)
c000556c:	02e7a623          	sw	a4,44(a5)
				}

				traceTASK_PRIORITY_INHERIT( pxMutexHolderTCB, pxCurrentTCB->uxPriority );

				/* Inheritance occurred. */
				xReturn = pdTRUE;
c0005570:	00100793          	li	a5,1
c0005574:	fef42623          	sw	a5,-20(s0)
c0005578:	0280006f          	j	c00055a0 <xTaskPriorityInherit+0x1b0>
			}
			else
			{
				if( pxMutexHolderTCB->uxBasePriority < pxCurrentTCB->uxPriority )
c000557c:	fe842783          	lw	a5,-24(s0)
c0005580:	0547a703          	lw	a4,84(a5)
c0005584:	07ffd797          	auipc	a5,0x7ffd
c0005588:	30878793          	addi	a5,a5,776 # c800288c <pxCurrentTCB>
c000558c:	0007a783          	lw	a5,0(a5)
c0005590:	02c7a783          	lw	a5,44(a5)
c0005594:	00f77663          	bgeu	a4,a5,c00055a0 <xTaskPriorityInherit+0x1b0>
					current priority of the mutex holder is not lower than the
					priority of the task attempting to take the mutex.
					Therefore the mutex holder must have already inherited a
					priority, but inheritance would have occurred if that had
					not been the case. */
					xReturn = pdTRUE;
c0005598:	00100793          	li	a5,1
c000559c:	fef42623          	sw	a5,-20(s0)
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}

		return xReturn;
c00055a0:	fec42783          	lw	a5,-20(s0)
	}
c00055a4:	00078513          	mv	a0,a5
c00055a8:	02c12083          	lw	ra,44(sp)
c00055ac:	02812403          	lw	s0,40(sp)
c00055b0:	03010113          	addi	sp,sp,48
c00055b4:	00008067          	ret

c00055b8 <xTaskPriorityDisinherit>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

	BaseType_t xTaskPriorityDisinherit( TaskHandle_t const pxMutexHolder )
	{
c00055b8:	fd010113          	addi	sp,sp,-48
c00055bc:	02112623          	sw	ra,44(sp)
c00055c0:	02812423          	sw	s0,40(sp)
c00055c4:	03010413          	addi	s0,sp,48
c00055c8:	fca42e23          	sw	a0,-36(s0)
	TCB_t * const pxTCB = pxMutexHolder;
c00055cc:	fdc42783          	lw	a5,-36(s0)
c00055d0:	fef42423          	sw	a5,-24(s0)
	BaseType_t xReturn = pdFALSE;
c00055d4:	fe042623          	sw	zero,-20(s0)

		if( pxMutexHolder != NULL )
c00055d8:	fdc42783          	lw	a5,-36(s0)
c00055dc:	16078c63          	beqz	a5,c0005754 <xTaskPriorityDisinherit+0x19c>
		{
			/* A task can only have an inherited priority if it holds the mutex.
			If the mutex is held by a task then it cannot be given from an
			interrupt, and if a mutex is given by the holding task then it must
			be the running state task. */
			configASSERT( pxTCB == pxCurrentTCB );
c00055e0:	07ffd797          	auipc	a5,0x7ffd
c00055e4:	2ac78793          	addi	a5,a5,684 # c800288c <pxCurrentTCB>
c00055e8:	0007a783          	lw	a5,0(a5)
c00055ec:	fe842703          	lw	a4,-24(s0)
c00055f0:	00f70863          	beq	a4,a5,c0005600 <xTaskPriorityDisinherit+0x48>
c00055f4:	30047073          	csrci	mstatus,8
c00055f8:	00100073          	ebreak
c00055fc:	0000006f          	j	c00055fc <xTaskPriorityDisinherit+0x44>
			configASSERT( pxTCB->uxMutexesHeld );
c0005600:	fe842783          	lw	a5,-24(s0)
c0005604:	0587a783          	lw	a5,88(a5)
c0005608:	00079863          	bnez	a5,c0005618 <xTaskPriorityDisinherit+0x60>
c000560c:	30047073          	csrci	mstatus,8
c0005610:	00100073          	ebreak
c0005614:	0000006f          	j	c0005614 <xTaskPriorityDisinherit+0x5c>
			( pxTCB->uxMutexesHeld )--;
c0005618:	fe842783          	lw	a5,-24(s0)
c000561c:	0587a783          	lw	a5,88(a5)
c0005620:	fff78713          	addi	a4,a5,-1
c0005624:	fe842783          	lw	a5,-24(s0)
c0005628:	04e7ac23          	sw	a4,88(a5)

			/* Has the holder of the mutex inherited the priority of another
			task? */
			if( pxTCB->uxPriority != pxTCB->uxBasePriority )
c000562c:	fe842783          	lw	a5,-24(s0)
c0005630:	02c7a703          	lw	a4,44(a5)
c0005634:	fe842783          	lw	a5,-24(s0)
c0005638:	0547a783          	lw	a5,84(a5)
c000563c:	10f70c63          	beq	a4,a5,c0005754 <xTaskPriorityDisinherit+0x19c>
			{
				/* Only disinherit if no other mutexes are held. */
				if( pxTCB->uxMutexesHeld == ( UBaseType_t ) 0 )
c0005640:	fe842783          	lw	a5,-24(s0)
c0005644:	0587a783          	lw	a5,88(a5)
c0005648:	10079663          	bnez	a5,c0005754 <xTaskPriorityDisinherit+0x19c>
					/* A task can only have an inherited priority if it holds
					the mutex.  If the mutex is held by a task then it cannot be
					given from an interrupt, and if a mutex is given by the
					holding task then it must be the running state task.  Remove
					the holding task from the ready/delayed list. */
					if( uxListRemove( &( pxTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
c000564c:	fe842783          	lw	a5,-24(s0)
c0005650:	00478793          	addi	a5,a5,4
c0005654:	00078513          	mv	a0,a5
c0005658:	a54fb0ef          	jal	ra,c00008ac <uxListRemove>
c000565c:	00050793          	mv	a5,a0
c0005660:	06079063          	bnez	a5,c00056c0 <xTaskPriorityDisinherit+0x108>
					{
						taskRESET_READY_PRIORITY( pxTCB->uxPriority );
c0005664:	fe842783          	lw	a5,-24(s0)
c0005668:	02c7a703          	lw	a4,44(a5)
c000566c:	07ffe697          	auipc	a3,0x7ffe
c0005670:	edc68693          	addi	a3,a3,-292 # c8003548 <pxReadyTasksLists>
c0005674:	00070793          	mv	a5,a4
c0005678:	00279793          	slli	a5,a5,0x2
c000567c:	00e787b3          	add	a5,a5,a4
c0005680:	00279793          	slli	a5,a5,0x2
c0005684:	00f687b3          	add	a5,a3,a5
c0005688:	0007a783          	lw	a5,0(a5)
c000568c:	02079a63          	bnez	a5,c00056c0 <xTaskPriorityDisinherit+0x108>
c0005690:	fe842783          	lw	a5,-24(s0)
c0005694:	02c7a783          	lw	a5,44(a5)
c0005698:	00100713          	li	a4,1
c000569c:	00f717b3          	sll	a5,a4,a5
c00056a0:	fff7c713          	not	a4,a5
c00056a4:	07ffe797          	auipc	a5,0x7ffe
c00056a8:	f8078793          	addi	a5,a5,-128 # c8003624 <uxTopReadyPriority>
c00056ac:	0007a783          	lw	a5,0(a5)
c00056b0:	00f77733          	and	a4,a4,a5
c00056b4:	07ffe797          	auipc	a5,0x7ffe
c00056b8:	f7078793          	addi	a5,a5,-144 # c8003624 <uxTopReadyPriority>
c00056bc:	00e7a023          	sw	a4,0(a5)
					}

					/* Disinherit the priority before adding the task into the
					new	ready list. */
					traceTASK_PRIORITY_DISINHERIT( pxTCB, pxTCB->uxBasePriority );
					pxTCB->uxPriority = pxTCB->uxBasePriority;
c00056c0:	fe842783          	lw	a5,-24(s0)
c00056c4:	0547a703          	lw	a4,84(a5)
c00056c8:	fe842783          	lw	a5,-24(s0)
c00056cc:	02e7a623          	sw	a4,44(a5)

					/* Reset the event list item value.  It cannot be in use for
					any other purpose if this task is running, and it must be
					running to give back the mutex. */
					listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) pxTCB->uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
c00056d0:	fe842783          	lw	a5,-24(s0)
c00056d4:	02c7a783          	lw	a5,44(a5)
c00056d8:	00500713          	li	a4,5
c00056dc:	40f70733          	sub	a4,a4,a5
c00056e0:	fe842783          	lw	a5,-24(s0)
c00056e4:	00e7ac23          	sw	a4,24(a5)
					prvAddTaskToReadyList( pxTCB );
c00056e8:	fe842783          	lw	a5,-24(s0)
c00056ec:	02c7a783          	lw	a5,44(a5)
c00056f0:	00100713          	li	a4,1
c00056f4:	00f71733          	sll	a4,a4,a5
c00056f8:	07ffe797          	auipc	a5,0x7ffe
c00056fc:	f2c78793          	addi	a5,a5,-212 # c8003624 <uxTopReadyPriority>
c0005700:	0007a783          	lw	a5,0(a5)
c0005704:	00f76733          	or	a4,a4,a5
c0005708:	07ffe797          	auipc	a5,0x7ffe
c000570c:	f1c78793          	addi	a5,a5,-228 # c8003624 <uxTopReadyPriority>
c0005710:	00e7a023          	sw	a4,0(a5)
c0005714:	fe842783          	lw	a5,-24(s0)
c0005718:	02c7a703          	lw	a4,44(a5)
c000571c:	00070793          	mv	a5,a4
c0005720:	00279793          	slli	a5,a5,0x2
c0005724:	00e787b3          	add	a5,a5,a4
c0005728:	00279793          	slli	a5,a5,0x2
c000572c:	07ffe717          	auipc	a4,0x7ffe
c0005730:	e1c70713          	addi	a4,a4,-484 # c8003548 <pxReadyTasksLists>
c0005734:	00e78733          	add	a4,a5,a4
c0005738:	fe842783          	lw	a5,-24(s0)
c000573c:	00478793          	addi	a5,a5,4
c0005740:	00078593          	mv	a1,a5
c0005744:	00070513          	mv	a0,a4
c0005748:	808fb0ef          	jal	ra,c0000750 <vListInsertEnd>
					in an order different to that in which they were taken.
					If a context switch did not occur when the first mutex was
					returned, even if a task was waiting on it, then a context
					switch should occur when the last mutex is returned whether
					a task is waiting on it or not. */
					xReturn = pdTRUE;
c000574c:	00100793          	li	a5,1
c0005750:	fef42623          	sw	a5,-20(s0)
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}

		return xReturn;
c0005754:	fec42783          	lw	a5,-20(s0)
	}
c0005758:	00078513          	mv	a0,a5
c000575c:	02c12083          	lw	ra,44(sp)
c0005760:	02812403          	lw	s0,40(sp)
c0005764:	03010113          	addi	sp,sp,48
c0005768:	00008067          	ret

c000576c <vTaskPriorityDisinheritAfterTimeout>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

	void vTaskPriorityDisinheritAfterTimeout( TaskHandle_t const pxMutexHolder, UBaseType_t uxHighestPriorityWaitingTask )
	{
c000576c:	fd010113          	addi	sp,sp,-48
c0005770:	02112623          	sw	ra,44(sp)
c0005774:	02812423          	sw	s0,40(sp)
c0005778:	03010413          	addi	s0,sp,48
c000577c:	fca42e23          	sw	a0,-36(s0)
c0005780:	fcb42c23          	sw	a1,-40(s0)
	TCB_t * const pxTCB = pxMutexHolder;
c0005784:	fdc42783          	lw	a5,-36(s0)
c0005788:	fef42423          	sw	a5,-24(s0)
	UBaseType_t uxPriorityUsedOnEntry, uxPriorityToUse;
	const UBaseType_t uxOnlyOneMutexHeld = ( UBaseType_t ) 1;
c000578c:	00100793          	li	a5,1
c0005790:	fef42223          	sw	a5,-28(s0)

		if( pxMutexHolder != NULL )
c0005794:	fdc42783          	lw	a5,-36(s0)
c0005798:	18078a63          	beqz	a5,c000592c <vTaskPriorityDisinheritAfterTimeout+0x1c0>
		{
			/* If pxMutexHolder is not NULL then the holder must hold at least
			one mutex. */
			configASSERT( pxTCB->uxMutexesHeld );
c000579c:	fe842783          	lw	a5,-24(s0)
c00057a0:	0587a783          	lw	a5,88(a5)
c00057a4:	00079863          	bnez	a5,c00057b4 <vTaskPriorityDisinheritAfterTimeout+0x48>
c00057a8:	30047073          	csrci	mstatus,8
c00057ac:	00100073          	ebreak
c00057b0:	0000006f          	j	c00057b0 <vTaskPriorityDisinheritAfterTimeout+0x44>

			/* Determine the priority to which the priority of the task that
			holds the mutex should be set.  This will be the greater of the
			holding task's base priority and the priority of the highest
			priority task that is waiting to obtain the mutex. */
			if( pxTCB->uxBasePriority < uxHighestPriorityWaitingTask )
c00057b4:	fe842783          	lw	a5,-24(s0)
c00057b8:	0547a783          	lw	a5,84(a5)
c00057bc:	fd842703          	lw	a4,-40(s0)
c00057c0:	00e7f863          	bgeu	a5,a4,c00057d0 <vTaskPriorityDisinheritAfterTimeout+0x64>
			{
				uxPriorityToUse = uxHighestPriorityWaitingTask;
c00057c4:	fd842783          	lw	a5,-40(s0)
c00057c8:	fef42623          	sw	a5,-20(s0)
c00057cc:	0100006f          	j	c00057dc <vTaskPriorityDisinheritAfterTimeout+0x70>
			}
			else
			{
				uxPriorityToUse = pxTCB->uxBasePriority;
c00057d0:	fe842783          	lw	a5,-24(s0)
c00057d4:	0547a783          	lw	a5,84(a5)
c00057d8:	fef42623          	sw	a5,-20(s0)
			}

			/* Does the priority need to change? */
			if( pxTCB->uxPriority != uxPriorityToUse )
c00057dc:	fe842783          	lw	a5,-24(s0)
c00057e0:	02c7a783          	lw	a5,44(a5)
c00057e4:	fec42703          	lw	a4,-20(s0)
c00057e8:	14f70263          	beq	a4,a5,c000592c <vTaskPriorityDisinheritAfterTimeout+0x1c0>
			{
				/* Only disinherit if no other mutexes are held.  This is a
				simplification in the priority inheritance implementation.  If
				the task that holds the mutex is also holding other mutexes then
				the other mutexes may have caused the priority inheritance. */
				if( pxTCB->uxMutexesHeld == uxOnlyOneMutexHeld )
c00057ec:	fe842783          	lw	a5,-24(s0)
c00057f0:	0587a783          	lw	a5,88(a5)
c00057f4:	fe442703          	lw	a4,-28(s0)
c00057f8:	12f71a63          	bne	a4,a5,c000592c <vTaskPriorityDisinheritAfterTimeout+0x1c0>
				{
					/* If a task has timed out because it already holds the
					mutex it was trying to obtain then it cannot of inherited
					its own priority. */
					configASSERT( pxTCB != pxCurrentTCB );
c00057fc:	07ffd797          	auipc	a5,0x7ffd
c0005800:	09078793          	addi	a5,a5,144 # c800288c <pxCurrentTCB>
c0005804:	0007a783          	lw	a5,0(a5)
c0005808:	fe842703          	lw	a4,-24(s0)
c000580c:	00f71863          	bne	a4,a5,c000581c <vTaskPriorityDisinheritAfterTimeout+0xb0>
c0005810:	30047073          	csrci	mstatus,8
c0005814:	00100073          	ebreak
c0005818:	0000006f          	j	c0005818 <vTaskPriorityDisinheritAfterTimeout+0xac>

					/* Disinherit the priority, remembering the previous
					priority to facilitate determining the subject task's
					state. */
					traceTASK_PRIORITY_DISINHERIT( pxTCB, pxTCB->uxBasePriority );
					uxPriorityUsedOnEntry = pxTCB->uxPriority;
c000581c:	fe842783          	lw	a5,-24(s0)
c0005820:	02c7a783          	lw	a5,44(a5)
c0005824:	fef42023          	sw	a5,-32(s0)
					pxTCB->uxPriority = uxPriorityToUse;
c0005828:	fe842783          	lw	a5,-24(s0)
c000582c:	fec42703          	lw	a4,-20(s0)
c0005830:	02e7a623          	sw	a4,44(a5)

					/* Only reset the event list item value if the value is not
					being used for anything else. */
					if( ( listGET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ) ) & taskEVENT_LIST_ITEM_VALUE_IN_USE ) == 0UL )
c0005834:	fe842783          	lw	a5,-24(s0)
c0005838:	0187a783          	lw	a5,24(a5)
c000583c:	0007cc63          	bltz	a5,c0005854 <vTaskPriorityDisinheritAfterTimeout+0xe8>
					{
						listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) uxPriorityToUse ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
c0005840:	00500713          	li	a4,5
c0005844:	fec42783          	lw	a5,-20(s0)
c0005848:	40f70733          	sub	a4,a4,a5
c000584c:	fe842783          	lw	a5,-24(s0)
c0005850:	00e7ac23          	sw	a4,24(a5)
					then the task that holds the mutex could be in either the
					Ready, Blocked or Suspended states.  Only remove the task
					from its current state list if it is in the Ready state as
					the task's priority is going to change and there is one
					Ready list per priority. */
					if( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ uxPriorityUsedOnEntry ] ), &( pxTCB->xStateListItem ) ) != pdFALSE )
c0005854:	fe842783          	lw	a5,-24(s0)
c0005858:	0147a683          	lw	a3,20(a5)
c000585c:	fe042703          	lw	a4,-32(s0)
c0005860:	00070793          	mv	a5,a4
c0005864:	00279793          	slli	a5,a5,0x2
c0005868:	00e787b3          	add	a5,a5,a4
c000586c:	00279793          	slli	a5,a5,0x2
c0005870:	07ffe717          	auipc	a4,0x7ffe
c0005874:	cd870713          	addi	a4,a4,-808 # c8003548 <pxReadyTasksLists>
c0005878:	00e787b3          	add	a5,a5,a4
c000587c:	0af69863          	bne	a3,a5,c000592c <vTaskPriorityDisinheritAfterTimeout+0x1c0>
					{
						if( uxListRemove( &( pxTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
c0005880:	fe842783          	lw	a5,-24(s0)
c0005884:	00478793          	addi	a5,a5,4
c0005888:	00078513          	mv	a0,a5
c000588c:	820fb0ef          	jal	ra,c00008ac <uxListRemove>
c0005890:	00050793          	mv	a5,a0
c0005894:	02079a63          	bnez	a5,c00058c8 <vTaskPriorityDisinheritAfterTimeout+0x15c>
						{
							/* It is known that the task is in its ready list so
							there is no need to check again and the port level
							reset macro can be called directly. */
							portRESET_READY_PRIORITY( pxTCB->uxPriority, uxTopReadyPriority );
c0005898:	fe842783          	lw	a5,-24(s0)
c000589c:	02c7a783          	lw	a5,44(a5)
c00058a0:	00100713          	li	a4,1
c00058a4:	00f717b3          	sll	a5,a4,a5
c00058a8:	fff7c713          	not	a4,a5
c00058ac:	07ffe797          	auipc	a5,0x7ffe
c00058b0:	d7878793          	addi	a5,a5,-648 # c8003624 <uxTopReadyPriority>
c00058b4:	0007a783          	lw	a5,0(a5)
c00058b8:	00f77733          	and	a4,a4,a5
c00058bc:	07ffe797          	auipc	a5,0x7ffe
c00058c0:	d6878793          	addi	a5,a5,-664 # c8003624 <uxTopReadyPriority>
c00058c4:	00e7a023          	sw	a4,0(a5)
						else
						{
							mtCOVERAGE_TEST_MARKER();
						}

						prvAddTaskToReadyList( pxTCB );
c00058c8:	fe842783          	lw	a5,-24(s0)
c00058cc:	02c7a783          	lw	a5,44(a5)
c00058d0:	00100713          	li	a4,1
c00058d4:	00f71733          	sll	a4,a4,a5
c00058d8:	07ffe797          	auipc	a5,0x7ffe
c00058dc:	d4c78793          	addi	a5,a5,-692 # c8003624 <uxTopReadyPriority>
c00058e0:	0007a783          	lw	a5,0(a5)
c00058e4:	00f76733          	or	a4,a4,a5
c00058e8:	07ffe797          	auipc	a5,0x7ffe
c00058ec:	d3c78793          	addi	a5,a5,-708 # c8003624 <uxTopReadyPriority>
c00058f0:	00e7a023          	sw	a4,0(a5)
c00058f4:	fe842783          	lw	a5,-24(s0)
c00058f8:	02c7a703          	lw	a4,44(a5)
c00058fc:	00070793          	mv	a5,a4
c0005900:	00279793          	slli	a5,a5,0x2
c0005904:	00e787b3          	add	a5,a5,a4
c0005908:	00279793          	slli	a5,a5,0x2
c000590c:	07ffe717          	auipc	a4,0x7ffe
c0005910:	c3c70713          	addi	a4,a4,-964 # c8003548 <pxReadyTasksLists>
c0005914:	00e78733          	add	a4,a5,a4
c0005918:	fe842783          	lw	a5,-24(s0)
c000591c:	00478793          	addi	a5,a5,4
c0005920:	00078593          	mv	a1,a5
c0005924:	00070513          	mv	a0,a4
c0005928:	e29fa0ef          	jal	ra,c0000750 <vListInsertEnd>
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
c000592c:	00000013          	nop
c0005930:	02c12083          	lw	ra,44(sp)
c0005934:	02812403          	lw	s0,40(sp)
c0005938:	03010113          	addi	sp,sp,48
c000593c:	00008067          	ret

c0005940 <vTaskEnterCritical>:
/*-----------------------------------------------------------*/

#if ( portCRITICAL_NESTING_IN_TCB == 1 )

	void vTaskEnterCritical( void )
	{
c0005940:	ff010113          	addi	sp,sp,-16
c0005944:	00812623          	sw	s0,12(sp)
c0005948:	01010413          	addi	s0,sp,16
		portDISABLE_INTERRUPTS();
c000594c:	30047073          	csrci	mstatus,8

		if( xSchedulerRunning != pdFALSE )
c0005950:	07ffe797          	auipc	a5,0x7ffe
c0005954:	cd878793          	addi	a5,a5,-808 # c8003628 <xSchedulerRunning>
c0005958:	0007a783          	lw	a5,0(a5)
c000595c:	02078463          	beqz	a5,c0005984 <vTaskEnterCritical+0x44>
		{
			( pxCurrentTCB->uxCriticalNesting )++;
c0005960:	07ffd797          	auipc	a5,0x7ffd
c0005964:	f2c78793          	addi	a5,a5,-212 # c800288c <pxCurrentTCB>
c0005968:	0007a783          	lw	a5,0(a5)
c000596c:	0487a703          	lw	a4,72(a5)
c0005970:	00170713          	addi	a4,a4,1
c0005974:	04e7a423          	sw	a4,72(a5)
			function so	assert() if it is being called from an interrupt
			context.  Only API functions that end in "FromISR" can be used in an
			interrupt.  Only assert if the critical nesting count is 1 to
			protect against recursive calls if the assert function also uses a
			critical section. */
			if( pxCurrentTCB->uxCriticalNesting == 1 )
c0005978:	07ffd797          	auipc	a5,0x7ffd
c000597c:	f1478793          	addi	a5,a5,-236 # c800288c <pxCurrentTCB>
c0005980:	0007a783          	lw	a5,0(a5)
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
c0005984:	00000013          	nop
c0005988:	00c12403          	lw	s0,12(sp)
c000598c:	01010113          	addi	sp,sp,16
c0005990:	00008067          	ret

c0005994 <vTaskExitCritical>:
/*-----------------------------------------------------------*/

#if ( portCRITICAL_NESTING_IN_TCB == 1 )

	void vTaskExitCritical( void )
	{
c0005994:	ff010113          	addi	sp,sp,-16
c0005998:	00812623          	sw	s0,12(sp)
c000599c:	01010413          	addi	s0,sp,16
		if( xSchedulerRunning != pdFALSE )
c00059a0:	07ffe797          	auipc	a5,0x7ffe
c00059a4:	c8878793          	addi	a5,a5,-888 # c8003628 <xSchedulerRunning>
c00059a8:	0007a783          	lw	a5,0(a5)
c00059ac:	04078463          	beqz	a5,c00059f4 <vTaskExitCritical+0x60>
		{
			if( pxCurrentTCB->uxCriticalNesting > 0U )
c00059b0:	07ffd797          	auipc	a5,0x7ffd
c00059b4:	edc78793          	addi	a5,a5,-292 # c800288c <pxCurrentTCB>
c00059b8:	0007a783          	lw	a5,0(a5)
c00059bc:	0487a783          	lw	a5,72(a5)
c00059c0:	02078a63          	beqz	a5,c00059f4 <vTaskExitCritical+0x60>
			{
				( pxCurrentTCB->uxCriticalNesting )--;
c00059c4:	07ffd797          	auipc	a5,0x7ffd
c00059c8:	ec878793          	addi	a5,a5,-312 # c800288c <pxCurrentTCB>
c00059cc:	0007a783          	lw	a5,0(a5)
c00059d0:	0487a703          	lw	a4,72(a5)
c00059d4:	fff70713          	addi	a4,a4,-1
c00059d8:	04e7a423          	sw	a4,72(a5)

				if( pxCurrentTCB->uxCriticalNesting == 0U )
c00059dc:	07ffd797          	auipc	a5,0x7ffd
c00059e0:	eb078793          	addi	a5,a5,-336 # c800288c <pxCurrentTCB>
c00059e4:	0007a783          	lw	a5,0(a5)
c00059e8:	0487a783          	lw	a5,72(a5)
c00059ec:	00079463          	bnez	a5,c00059f4 <vTaskExitCritical+0x60>
				{
					portENABLE_INTERRUPTS();
c00059f0:	30046073          	csrsi	mstatus,8
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
c00059f4:	00000013          	nop
c00059f8:	00c12403          	lw	s0,12(sp)
c00059fc:	01010113          	addi	sp,sp,16
c0005a00:	00008067          	ret

c0005a04 <prvWriteNameToBuffer>:
/*-----------------------------------------------------------*/

#if ( ( configUSE_TRACE_FACILITY == 1 ) && ( configUSE_STATS_FORMATTING_FUNCTIONS > 0 ) )

	static char *prvWriteNameToBuffer( char *pcBuffer, const char *pcTaskName )
	{
c0005a04:	fd010113          	addi	sp,sp,-48
c0005a08:	02112623          	sw	ra,44(sp)
c0005a0c:	02812423          	sw	s0,40(sp)
c0005a10:	03010413          	addi	s0,sp,48
c0005a14:	fca42e23          	sw	a0,-36(s0)
c0005a18:	fcb42c23          	sw	a1,-40(s0)
	size_t x;

		/* Start by copying the entire string. */
		strcpy( pcBuffer, pcTaskName );
c0005a1c:	fd842583          	lw	a1,-40(s0)
c0005a20:	fdc42503          	lw	a0,-36(s0)
c0005a24:	594180ef          	jal	ra,c001dfb8 <strcpy>

		/* Pad the end of the string with spaces to ensure columns line up when
		printed out. */
		for( x = strlen( pcBuffer ); x < ( size_t ) ( configMAX_TASK_NAME_LEN - 1 ); x++ )
c0005a28:	fdc42503          	lw	a0,-36(s0)
c0005a2c:	63c180ef          	jal	ra,c001e068 <strlen>
c0005a30:	fea42623          	sw	a0,-20(s0)
c0005a34:	0240006f          	j	c0005a58 <prvWriteNameToBuffer+0x54>
		{
			pcBuffer[ x ] = ' ';
c0005a38:	fdc42703          	lw	a4,-36(s0)
c0005a3c:	fec42783          	lw	a5,-20(s0)
c0005a40:	00f707b3          	add	a5,a4,a5
c0005a44:	02000713          	li	a4,32
c0005a48:	00e78023          	sb	a4,0(a5)
		for( x = strlen( pcBuffer ); x < ( size_t ) ( configMAX_TASK_NAME_LEN - 1 ); x++ )
c0005a4c:	fec42783          	lw	a5,-20(s0)
c0005a50:	00178793          	addi	a5,a5,1
c0005a54:	fef42623          	sw	a5,-20(s0)
c0005a58:	fec42703          	lw	a4,-20(s0)
c0005a5c:	00e00793          	li	a5,14
c0005a60:	fce7fce3          	bgeu	a5,a4,c0005a38 <prvWriteNameToBuffer+0x34>
		}

		/* Terminate. */
		pcBuffer[ x ] = ( char ) 0x00;
c0005a64:	fdc42703          	lw	a4,-36(s0)
c0005a68:	fec42783          	lw	a5,-20(s0)
c0005a6c:	00f707b3          	add	a5,a4,a5
c0005a70:	00078023          	sb	zero,0(a5)

		/* Return the new end of string. */
		return &( pcBuffer[ x ] );
c0005a74:	fdc42703          	lw	a4,-36(s0)
c0005a78:	fec42783          	lw	a5,-20(s0)
c0005a7c:	00f707b3          	add	a5,a4,a5
	}
c0005a80:	00078513          	mv	a0,a5
c0005a84:	02c12083          	lw	ra,44(sp)
c0005a88:	02812403          	lw	s0,40(sp)
c0005a8c:	03010113          	addi	sp,sp,48
c0005a90:	00008067          	ret

c0005a94 <vTaskList>:
/*-----------------------------------------------------------*/

#if ( ( configUSE_TRACE_FACILITY == 1 ) && ( configUSE_STATS_FORMATTING_FUNCTIONS > 0 ) && ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) )

	void vTaskList( char * pcWriteBuffer )
	{
c0005a94:	fd010113          	addi	sp,sp,-48
c0005a98:	02112623          	sw	ra,44(sp)
c0005a9c:	02812423          	sw	s0,40(sp)
c0005aa0:	03010413          	addi	s0,sp,48
c0005aa4:	fca42e23          	sw	a0,-36(s0)
		 * through a call to vTaskList().
		 */


		/* Make sure the write buffer does not contain a string. */
		*pcWriteBuffer = ( char ) 0x00;
c0005aa8:	fdc42783          	lw	a5,-36(s0)
c0005aac:	00078023          	sb	zero,0(a5)

		/* Take a snapshot of the number of tasks in case it changes while this
		function is executing. */
		uxArraySize = uxCurrentNumberOfTasks;
c0005ab0:	07ffe797          	auipc	a5,0x7ffe
c0005ab4:	b6c78793          	addi	a5,a5,-1172 # c800361c <uxCurrentNumberOfTasks>
c0005ab8:	0007a783          	lw	a5,0(a5)
c0005abc:	fef42223          	sw	a5,-28(s0)

		/* Allocate an array index for each task.  NOTE!  if
		configSUPPORT_DYNAMIC_ALLOCATION is set to 0 then pvPortMalloc() will
		equate to NULL. */
		pxTaskStatusArray = pvPortMalloc( uxCurrentNumberOfTasks * sizeof( TaskStatus_t ) ); /*lint !e9079 All values returned by pvPortMalloc() have at least the alignment required by the MCU's stack and this allocation allocates a struct that has the alignment requirements of a pointer. */
c0005ac0:	07ffe797          	auipc	a5,0x7ffe
c0005ac4:	b5c78793          	addi	a5,a5,-1188 # c800361c <uxCurrentNumberOfTasks>
c0005ac8:	0007a703          	lw	a4,0(a5)
c0005acc:	00070793          	mv	a5,a4
c0005ad0:	00379793          	slli	a5,a5,0x3
c0005ad4:	00e787b3          	add	a5,a5,a4
c0005ad8:	00279793          	slli	a5,a5,0x2
c0005adc:	00078513          	mv	a0,a5
c0005ae0:	7d4030ef          	jal	ra,c00092b4 <pvPortMalloc>
c0005ae4:	fea42023          	sw	a0,-32(s0)

		if( pxTaskStatusArray != NULL )
c0005ae8:	fe042783          	lw	a5,-32(s0)
c0005aec:	1a078263          	beqz	a5,c0005c90 <vTaskList+0x1fc>
		{
			/* Generate the (binary) data. */
			uxArraySize = uxTaskGetSystemState( pxTaskStatusArray, uxArraySize, NULL );
c0005af0:	00000613          	li	a2,0
c0005af4:	fe442583          	lw	a1,-28(s0)
c0005af8:	fe042503          	lw	a0,-32(s0)
c0005afc:	ac8fe0ef          	jal	ra,c0003dc4 <uxTaskGetSystemState>
c0005b00:	fea42223          	sw	a0,-28(s0)

			/* Create a human readable table from the binary data. */
			for( x = 0; x < uxArraySize; x++ )
c0005b04:	fe042623          	sw	zero,-20(s0)
c0005b08:	1740006f          	j	c0005c7c <vTaskList+0x1e8>
			{
				switch( pxTaskStatusArray[ x ].eCurrentState )
c0005b0c:	fec42703          	lw	a4,-20(s0)
c0005b10:	00070793          	mv	a5,a4
c0005b14:	00379793          	slli	a5,a5,0x3
c0005b18:	00e787b3          	add	a5,a5,a4
c0005b1c:	00279793          	slli	a5,a5,0x2
c0005b20:	00078713          	mv	a4,a5
c0005b24:	fe042783          	lw	a5,-32(s0)
c0005b28:	00e787b3          	add	a5,a5,a4
c0005b2c:	00c7a783          	lw	a5,12(a5)
c0005b30:	00400713          	li	a4,4
c0005b34:	06f76263          	bltu	a4,a5,c0005b98 <vTaskList+0x104>
c0005b38:	00279713          	slli	a4,a5,0x2
c0005b3c:	07ffa797          	auipc	a5,0x7ffa
c0005b40:	4dc78793          	addi	a5,a5,1244 # c8000018 <__rodata_start+0x18>
c0005b44:	00f707b3          	add	a5,a4,a5
c0005b48:	0007a703          	lw	a4,0(a5)
c0005b4c:	07ffa797          	auipc	a5,0x7ffa
c0005b50:	4cc78793          	addi	a5,a5,1228 # c8000018 <__rodata_start+0x18>
c0005b54:	00f707b3          	add	a5,a4,a5
c0005b58:	00078067          	jr	a5
				{
					case eRunning:		cStatus = tskRUNNING_CHAR;
c0005b5c:	05800793          	li	a5,88
c0005b60:	fef405a3          	sb	a5,-21(s0)
										break;
c0005b64:	03c0006f          	j	c0005ba0 <vTaskList+0x10c>

					case eReady:		cStatus = tskREADY_CHAR;
c0005b68:	05200793          	li	a5,82
c0005b6c:	fef405a3          	sb	a5,-21(s0)
										break;
c0005b70:	0300006f          	j	c0005ba0 <vTaskList+0x10c>

					case eBlocked:		cStatus = tskBLOCKED_CHAR;
c0005b74:	04200793          	li	a5,66
c0005b78:	fef405a3          	sb	a5,-21(s0)
										break;
c0005b7c:	0240006f          	j	c0005ba0 <vTaskList+0x10c>

					case eSuspended:	cStatus = tskSUSPENDED_CHAR;
c0005b80:	05300793          	li	a5,83
c0005b84:	fef405a3          	sb	a5,-21(s0)
										break;
c0005b88:	0180006f          	j	c0005ba0 <vTaskList+0x10c>

					case eDeleted:		cStatus = tskDELETED_CHAR;
c0005b8c:	04400793          	li	a5,68
c0005b90:	fef405a3          	sb	a5,-21(s0)
										break;
c0005b94:	00c0006f          	j	c0005ba0 <vTaskList+0x10c>

					case eInvalid:		/* Fall through. */
					default:			/* Should not get here, but it is included
										to prevent static checking errors. */
										cStatus = ( char ) 0x00;
c0005b98:	fe0405a3          	sb	zero,-21(s0)
										break;
c0005b9c:	00000013          	nop
				}

				/* Write the task name to the string, padding with spaces so it
				can be printed in tabular form more easily. */
				pcWriteBuffer = prvWriteNameToBuffer( pcWriteBuffer, pxTaskStatusArray[ x ].pcTaskName );
c0005ba0:	fec42703          	lw	a4,-20(s0)
c0005ba4:	00070793          	mv	a5,a4
c0005ba8:	00379793          	slli	a5,a5,0x3
c0005bac:	00e787b3          	add	a5,a5,a4
c0005bb0:	00279793          	slli	a5,a5,0x2
c0005bb4:	00078713          	mv	a4,a5
c0005bb8:	fe042783          	lw	a5,-32(s0)
c0005bbc:	00e787b3          	add	a5,a5,a4
c0005bc0:	0047a783          	lw	a5,4(a5)
c0005bc4:	00078593          	mv	a1,a5
c0005bc8:	fdc42503          	lw	a0,-36(s0)
c0005bcc:	e39ff0ef          	jal	ra,c0005a04 <prvWriteNameToBuffer>
c0005bd0:	fca42e23          	sw	a0,-36(s0)

				/* Write the rest of the string. */
				sprintf( pcWriteBuffer, "\t%c\t%u\t%u\t%u\r\n", cStatus, ( unsigned int ) pxTaskStatusArray[ x ].uxCurrentPriority, ( unsigned int ) pxTaskStatusArray[ x ].usStackHighWaterMark, ( unsigned int ) pxTaskStatusArray[ x ].xTaskNumber ); /*lint !e586 sprintf() allowed as this is compiled with many compilers and this is a utility function only - not part of the core kernel implementation. */
c0005bd4:	feb44603          	lbu	a2,-21(s0)
c0005bd8:	fec42703          	lw	a4,-20(s0)
c0005bdc:	00070793          	mv	a5,a4
c0005be0:	00379793          	slli	a5,a5,0x3
c0005be4:	00e787b3          	add	a5,a5,a4
c0005be8:	00279793          	slli	a5,a5,0x2
c0005bec:	00078713          	mv	a4,a5
c0005bf0:	fe042783          	lw	a5,-32(s0)
c0005bf4:	00e787b3          	add	a5,a5,a4
c0005bf8:	0107a683          	lw	a3,16(a5)
c0005bfc:	fec42703          	lw	a4,-20(s0)
c0005c00:	00070793          	mv	a5,a4
c0005c04:	00379793          	slli	a5,a5,0x3
c0005c08:	00e787b3          	add	a5,a5,a4
c0005c0c:	00279793          	slli	a5,a5,0x2
c0005c10:	00078713          	mv	a4,a5
c0005c14:	fe042783          	lw	a5,-32(s0)
c0005c18:	00e787b3          	add	a5,a5,a4
c0005c1c:	0207a583          	lw	a1,32(a5)
c0005c20:	fec42703          	lw	a4,-20(s0)
c0005c24:	00070793          	mv	a5,a4
c0005c28:	00379793          	slli	a5,a5,0x3
c0005c2c:	00e787b3          	add	a5,a5,a4
c0005c30:	00279793          	slli	a5,a5,0x2
c0005c34:	00078713          	mv	a4,a5
c0005c38:	fe042783          	lw	a5,-32(s0)
c0005c3c:	00e787b3          	add	a5,a5,a4
c0005c40:	0087a783          	lw	a5,8(a5)
c0005c44:	00058713          	mv	a4,a1
c0005c48:	07ffa597          	auipc	a1,0x7ffa
c0005c4c:	3c058593          	addi	a1,a1,960 # c8000008 <__rodata_start+0x8>
c0005c50:	fdc42503          	lw	a0,-36(s0)
c0005c54:	2e8180ef          	jal	ra,c001df3c <sprintf>
				pcWriteBuffer += strlen( pcWriteBuffer ); /*lint !e9016 Pointer arithmetic ok on char pointers especially as in this case where it best denotes the intent of the code. */
c0005c58:	fdc42503          	lw	a0,-36(s0)
c0005c5c:	40c180ef          	jal	ra,c001e068 <strlen>
c0005c60:	00050713          	mv	a4,a0
c0005c64:	fdc42783          	lw	a5,-36(s0)
c0005c68:	00e787b3          	add	a5,a5,a4
c0005c6c:	fcf42e23          	sw	a5,-36(s0)
			for( x = 0; x < uxArraySize; x++ )
c0005c70:	fec42783          	lw	a5,-20(s0)
c0005c74:	00178793          	addi	a5,a5,1
c0005c78:	fef42623          	sw	a5,-20(s0)
c0005c7c:	fec42703          	lw	a4,-20(s0)
c0005c80:	fe442783          	lw	a5,-28(s0)
c0005c84:	e8f764e3          	bltu	a4,a5,c0005b0c <vTaskList+0x78>
			}

			/* Free the array again.  NOTE!  If configSUPPORT_DYNAMIC_ALLOCATION
			is 0 then vPortFree() will be #defined to nothing. */
			vPortFree( pxTaskStatusArray );
c0005c88:	fe042503          	lw	a0,-32(s0)
c0005c8c:	0ad030ef          	jal	ra,c0009538 <vPortFree>
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
c0005c90:	00000013          	nop
c0005c94:	02c12083          	lw	ra,44(sp)
c0005c98:	02812403          	lw	s0,40(sp)
c0005c9c:	03010113          	addi	sp,sp,48
c0005ca0:	00008067          	ret

c0005ca4 <uxTaskResetEventItemValue>:

#endif /* ( ( configGENERATE_RUN_TIME_STATS == 1 ) && ( configUSE_STATS_FORMATTING_FUNCTIONS > 0 ) && ( configSUPPORT_STATIC_ALLOCATION == 1 ) ) */
/*-----------------------------------------------------------*/

TickType_t uxTaskResetEventItemValue( void )
{
c0005ca4:	fe010113          	addi	sp,sp,-32
c0005ca8:	00812e23          	sw	s0,28(sp)
c0005cac:	02010413          	addi	s0,sp,32
TickType_t uxReturn;

	uxReturn = listGET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ) );
c0005cb0:	07ffd797          	auipc	a5,0x7ffd
c0005cb4:	bdc78793          	addi	a5,a5,-1060 # c800288c <pxCurrentTCB>
c0005cb8:	0007a783          	lw	a5,0(a5)
c0005cbc:	0187a783          	lw	a5,24(a5)
c0005cc0:	fef42623          	sw	a5,-20(s0)

	/* Reset the event list item to its normal value - so it can be used with
	queues and semaphores. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ), ( ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) pxCurrentTCB->uxPriority ) ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
c0005cc4:	07ffd797          	auipc	a5,0x7ffd
c0005cc8:	bc878793          	addi	a5,a5,-1080 # c800288c <pxCurrentTCB>
c0005ccc:	0007a783          	lw	a5,0(a5)
c0005cd0:	02c7a703          	lw	a4,44(a5)
c0005cd4:	07ffd797          	auipc	a5,0x7ffd
c0005cd8:	bb878793          	addi	a5,a5,-1096 # c800288c <pxCurrentTCB>
c0005cdc:	0007a783          	lw	a5,0(a5)
c0005ce0:	00500693          	li	a3,5
c0005ce4:	40e68733          	sub	a4,a3,a4
c0005ce8:	00e7ac23          	sw	a4,24(a5)

	return uxReturn;
c0005cec:	fec42783          	lw	a5,-20(s0)
}
c0005cf0:	00078513          	mv	a0,a5
c0005cf4:	01c12403          	lw	s0,28(sp)
c0005cf8:	02010113          	addi	sp,sp,32
c0005cfc:	00008067          	ret

c0005d00 <pvTaskIncrementMutexHeldCount>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

	TaskHandle_t pvTaskIncrementMutexHeldCount( void )
	{
c0005d00:	ff010113          	addi	sp,sp,-16
c0005d04:	00812623          	sw	s0,12(sp)
c0005d08:	01010413          	addi	s0,sp,16
		/* If xSemaphoreCreateMutex() is called before any tasks have been created
		then pxCurrentTCB will be NULL. */
		if( pxCurrentTCB != NULL )
c0005d0c:	07ffd797          	auipc	a5,0x7ffd
c0005d10:	b8078793          	addi	a5,a5,-1152 # c800288c <pxCurrentTCB>
c0005d14:	0007a783          	lw	a5,0(a5)
c0005d18:	00078e63          	beqz	a5,c0005d34 <pvTaskIncrementMutexHeldCount+0x34>
		{
			( pxCurrentTCB->uxMutexesHeld )++;
c0005d1c:	07ffd797          	auipc	a5,0x7ffd
c0005d20:	b7078793          	addi	a5,a5,-1168 # c800288c <pxCurrentTCB>
c0005d24:	0007a783          	lw	a5,0(a5)
c0005d28:	0587a703          	lw	a4,88(a5)
c0005d2c:	00170713          	addi	a4,a4,1
c0005d30:	04e7ac23          	sw	a4,88(a5)
		}

		return pxCurrentTCB;
c0005d34:	07ffd797          	auipc	a5,0x7ffd
c0005d38:	b5878793          	addi	a5,a5,-1192 # c800288c <pxCurrentTCB>
c0005d3c:	0007a783          	lw	a5,0(a5)
	}
c0005d40:	00078513          	mv	a0,a5
c0005d44:	00c12403          	lw	s0,12(sp)
c0005d48:	01010113          	addi	sp,sp,16
c0005d4c:	00008067          	ret

c0005d50 <ulTaskNotifyTake>:
/*-----------------------------------------------------------*/

#if( configUSE_TASK_NOTIFICATIONS == 1 )

	uint32_t ulTaskNotifyTake( BaseType_t xClearCountOnExit, TickType_t xTicksToWait )
	{
c0005d50:	fd010113          	addi	sp,sp,-48
c0005d54:	02112623          	sw	ra,44(sp)
c0005d58:	02812423          	sw	s0,40(sp)
c0005d5c:	03010413          	addi	s0,sp,48
c0005d60:	fca42e23          	sw	a0,-36(s0)
c0005d64:	fcb42c23          	sw	a1,-40(s0)
	uint32_t ulReturn;

		taskENTER_CRITICAL();
c0005d68:	bd9ff0ef          	jal	ra,c0005940 <vTaskEnterCritical>
		{
			/* Only block if the notification count is not already non-zero. */
			if( pxCurrentTCB->ulNotifiedValue == 0UL )
c0005d6c:	07ffd797          	auipc	a5,0x7ffd
c0005d70:	b2078793          	addi	a5,a5,-1248 # c800288c <pxCurrentTCB>
c0005d74:	0007a783          	lw	a5,0(a5)
c0005d78:	05c7a783          	lw	a5,92(a5)
c0005d7c:	02079863          	bnez	a5,c0005dac <ulTaskNotifyTake+0x5c>
			{
				/* Mark this task as waiting for a notification. */
				pxCurrentTCB->ucNotifyState = taskWAITING_NOTIFICATION;
c0005d80:	07ffd797          	auipc	a5,0x7ffd
c0005d84:	b0c78793          	addi	a5,a5,-1268 # c800288c <pxCurrentTCB>
c0005d88:	0007a783          	lw	a5,0(a5)
c0005d8c:	00100713          	li	a4,1
c0005d90:	06e78023          	sb	a4,96(a5)

				if( xTicksToWait > ( TickType_t ) 0 )
c0005d94:	fd842783          	lw	a5,-40(s0)
c0005d98:	00078a63          	beqz	a5,c0005dac <ulTaskNotifyTake+0x5c>
				{
					prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
c0005d9c:	00100593          	li	a1,1
c0005da0:	fd842503          	lw	a0,-40(s0)
c0005da4:	0a9000ef          	jal	ra,c000664c <prvAddCurrentTaskToDelayedList>

					/* All ports are written to allow a yield in a critical
					section (some will yield immediately, others wait until the
					critical section exits) - but it is not something that
					application code should ever do. */
					portYIELD_WITHIN_API();
c0005da8:	00000073          	ecall
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
		taskEXIT_CRITICAL();
c0005dac:	be9ff0ef          	jal	ra,c0005994 <vTaskExitCritical>

		taskENTER_CRITICAL();
c0005db0:	b91ff0ef          	jal	ra,c0005940 <vTaskEnterCritical>
		{
			traceTASK_NOTIFY_TAKE();
			ulReturn = pxCurrentTCB->ulNotifiedValue;
c0005db4:	07ffd797          	auipc	a5,0x7ffd
c0005db8:	ad878793          	addi	a5,a5,-1320 # c800288c <pxCurrentTCB>
c0005dbc:	0007a783          	lw	a5,0(a5)
c0005dc0:	05c7a783          	lw	a5,92(a5)
c0005dc4:	fef42623          	sw	a5,-20(s0)

			if( ulReturn != 0UL )
c0005dc8:	fec42783          	lw	a5,-20(s0)
c0005dcc:	02078c63          	beqz	a5,c0005e04 <ulTaskNotifyTake+0xb4>
			{
				if( xClearCountOnExit != pdFALSE )
c0005dd0:	fdc42783          	lw	a5,-36(s0)
c0005dd4:	00078c63          	beqz	a5,c0005dec <ulTaskNotifyTake+0x9c>
				{
					pxCurrentTCB->ulNotifiedValue = 0UL;
c0005dd8:	07ffd797          	auipc	a5,0x7ffd
c0005ddc:	ab478793          	addi	a5,a5,-1356 # c800288c <pxCurrentTCB>
c0005de0:	0007a783          	lw	a5,0(a5)
c0005de4:	0407ae23          	sw	zero,92(a5)
c0005de8:	01c0006f          	j	c0005e04 <ulTaskNotifyTake+0xb4>
				}
				else
				{
					pxCurrentTCB->ulNotifiedValue = ulReturn - ( uint32_t ) 1;
c0005dec:	07ffd797          	auipc	a5,0x7ffd
c0005df0:	aa078793          	addi	a5,a5,-1376 # c800288c <pxCurrentTCB>
c0005df4:	0007a783          	lw	a5,0(a5)
c0005df8:	fec42703          	lw	a4,-20(s0)
c0005dfc:	fff70713          	addi	a4,a4,-1
c0005e00:	04e7ae23          	sw	a4,92(a5)
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}

			pxCurrentTCB->ucNotifyState = taskNOT_WAITING_NOTIFICATION;
c0005e04:	07ffd797          	auipc	a5,0x7ffd
c0005e08:	a8878793          	addi	a5,a5,-1400 # c800288c <pxCurrentTCB>
c0005e0c:	0007a783          	lw	a5,0(a5)
c0005e10:	06078023          	sb	zero,96(a5)
		}
		taskEXIT_CRITICAL();
c0005e14:	b81ff0ef          	jal	ra,c0005994 <vTaskExitCritical>

		return ulReturn;
c0005e18:	fec42783          	lw	a5,-20(s0)
	}
c0005e1c:	00078513          	mv	a0,a5
c0005e20:	02c12083          	lw	ra,44(sp)
c0005e24:	02812403          	lw	s0,40(sp)
c0005e28:	03010113          	addi	sp,sp,48
c0005e2c:	00008067          	ret

c0005e30 <xTaskNotifyWait>:
/*-----------------------------------------------------------*/

#if( configUSE_TASK_NOTIFICATIONS == 1 )

	BaseType_t xTaskNotifyWait( uint32_t ulBitsToClearOnEntry, uint32_t ulBitsToClearOnExit, uint32_t *pulNotificationValue, TickType_t xTicksToWait )
	{
c0005e30:	fd010113          	addi	sp,sp,-48
c0005e34:	02112623          	sw	ra,44(sp)
c0005e38:	02812423          	sw	s0,40(sp)
c0005e3c:	03010413          	addi	s0,sp,48
c0005e40:	fca42e23          	sw	a0,-36(s0)
c0005e44:	fcb42c23          	sw	a1,-40(s0)
c0005e48:	fcc42a23          	sw	a2,-44(s0)
c0005e4c:	fcd42823          	sw	a3,-48(s0)
	BaseType_t xReturn;

		taskENTER_CRITICAL();
c0005e50:	af1ff0ef          	jal	ra,c0005940 <vTaskEnterCritical>
		{
			/* Only block if a notification is not already pending. */
			if( pxCurrentTCB->ucNotifyState != taskNOTIFICATION_RECEIVED )
c0005e54:	07ffd797          	auipc	a5,0x7ffd
c0005e58:	a3878793          	addi	a5,a5,-1480 # c800288c <pxCurrentTCB>
c0005e5c:	0007a783          	lw	a5,0(a5)
c0005e60:	0607c783          	lbu	a5,96(a5)
c0005e64:	0ff7f713          	andi	a4,a5,255
c0005e68:	00200793          	li	a5,2
c0005e6c:	04f70863          	beq	a4,a5,c0005ebc <xTaskNotifyWait+0x8c>
			{
				/* Clear bits in the task's notification value as bits may get
				set	by the notifying task or interrupt.  This can be used to
				clear the value to zero. */
				pxCurrentTCB->ulNotifiedValue &= ~ulBitsToClearOnEntry;
c0005e70:	07ffd797          	auipc	a5,0x7ffd
c0005e74:	a1c78793          	addi	a5,a5,-1508 # c800288c <pxCurrentTCB>
c0005e78:	0007a783          	lw	a5,0(a5)
c0005e7c:	05c7a683          	lw	a3,92(a5)
c0005e80:	fdc42703          	lw	a4,-36(s0)
c0005e84:	fff74713          	not	a4,a4
c0005e88:	00e6f733          	and	a4,a3,a4
c0005e8c:	04e7ae23          	sw	a4,92(a5)

				/* Mark this task as waiting for a notification. */
				pxCurrentTCB->ucNotifyState = taskWAITING_NOTIFICATION;
c0005e90:	07ffd797          	auipc	a5,0x7ffd
c0005e94:	9fc78793          	addi	a5,a5,-1540 # c800288c <pxCurrentTCB>
c0005e98:	0007a783          	lw	a5,0(a5)
c0005e9c:	00100713          	li	a4,1
c0005ea0:	06e78023          	sb	a4,96(a5)

				if( xTicksToWait > ( TickType_t ) 0 )
c0005ea4:	fd042783          	lw	a5,-48(s0)
c0005ea8:	00078a63          	beqz	a5,c0005ebc <xTaskNotifyWait+0x8c>
				{
					prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
c0005eac:	00100593          	li	a1,1
c0005eb0:	fd042503          	lw	a0,-48(s0)
c0005eb4:	798000ef          	jal	ra,c000664c <prvAddCurrentTaskToDelayedList>

					/* All ports are written to allow a yield in a critical
					section (some will yield immediately, others wait until the
					critical section exits) - but it is not something that
					application code should ever do. */
					portYIELD_WITHIN_API();
c0005eb8:	00000073          	ecall
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
		taskEXIT_CRITICAL();
c0005ebc:	ad9ff0ef          	jal	ra,c0005994 <vTaskExitCritical>

		taskENTER_CRITICAL();
c0005ec0:	a81ff0ef          	jal	ra,c0005940 <vTaskEnterCritical>
		{
			traceTASK_NOTIFY_WAIT();

			if( pulNotificationValue != NULL )
c0005ec4:	fd442783          	lw	a5,-44(s0)
c0005ec8:	00078e63          	beqz	a5,c0005ee4 <xTaskNotifyWait+0xb4>
			{
				/* Output the current notification value, which may or may not
				have changed. */
				*pulNotificationValue = pxCurrentTCB->ulNotifiedValue;
c0005ecc:	07ffd797          	auipc	a5,0x7ffd
c0005ed0:	9c078793          	addi	a5,a5,-1600 # c800288c <pxCurrentTCB>
c0005ed4:	0007a783          	lw	a5,0(a5)
c0005ed8:	05c7a703          	lw	a4,92(a5)
c0005edc:	fd442783          	lw	a5,-44(s0)
c0005ee0:	00e7a023          	sw	a4,0(a5)

			/* If ucNotifyValue is set then either the task never entered the
			blocked state (because a notification was already pending) or the
			task unblocked because of a notification.  Otherwise the task
			unblocked because of a timeout. */
			if( pxCurrentTCB->ucNotifyState != taskNOTIFICATION_RECEIVED )
c0005ee4:	07ffd797          	auipc	a5,0x7ffd
c0005ee8:	9a878793          	addi	a5,a5,-1624 # c800288c <pxCurrentTCB>
c0005eec:	0007a783          	lw	a5,0(a5)
c0005ef0:	0607c783          	lbu	a5,96(a5)
c0005ef4:	0ff7f713          	andi	a4,a5,255
c0005ef8:	00200793          	li	a5,2
c0005efc:	00f70663          	beq	a4,a5,c0005f08 <xTaskNotifyWait+0xd8>
			{
				/* A notification was not received. */
				xReturn = pdFALSE;
c0005f00:	fe042623          	sw	zero,-20(s0)
c0005f04:	02c0006f          	j	c0005f30 <xTaskNotifyWait+0x100>
			}
			else
			{
				/* A notification was already pending or a notification was
				received while the task was waiting. */
				pxCurrentTCB->ulNotifiedValue &= ~ulBitsToClearOnExit;
c0005f08:	07ffd797          	auipc	a5,0x7ffd
c0005f0c:	98478793          	addi	a5,a5,-1660 # c800288c <pxCurrentTCB>
c0005f10:	0007a783          	lw	a5,0(a5)
c0005f14:	05c7a683          	lw	a3,92(a5)
c0005f18:	fd842703          	lw	a4,-40(s0)
c0005f1c:	fff74713          	not	a4,a4
c0005f20:	00e6f733          	and	a4,a3,a4
c0005f24:	04e7ae23          	sw	a4,92(a5)
				xReturn = pdTRUE;
c0005f28:	00100793          	li	a5,1
c0005f2c:	fef42623          	sw	a5,-20(s0)
			}

			pxCurrentTCB->ucNotifyState = taskNOT_WAITING_NOTIFICATION;
c0005f30:	07ffd797          	auipc	a5,0x7ffd
c0005f34:	95c78793          	addi	a5,a5,-1700 # c800288c <pxCurrentTCB>
c0005f38:	0007a783          	lw	a5,0(a5)
c0005f3c:	06078023          	sb	zero,96(a5)
		}
		taskEXIT_CRITICAL();
c0005f40:	a55ff0ef          	jal	ra,c0005994 <vTaskExitCritical>

		return xReturn;
c0005f44:	fec42783          	lw	a5,-20(s0)
	}
c0005f48:	00078513          	mv	a0,a5
c0005f4c:	02c12083          	lw	ra,44(sp)
c0005f50:	02812403          	lw	s0,40(sp)
c0005f54:	03010113          	addi	sp,sp,48
c0005f58:	00008067          	ret

c0005f5c <xTaskGenericNotify>:
/*-----------------------------------------------------------*/

#if( configUSE_TASK_NOTIFICATIONS == 1 )

	BaseType_t xTaskGenericNotify( TaskHandle_t xTaskToNotify, uint32_t ulValue, eNotifyAction eAction, uint32_t *pulPreviousNotificationValue )
	{
c0005f5c:	fd010113          	addi	sp,sp,-48
c0005f60:	02112623          	sw	ra,44(sp)
c0005f64:	02812423          	sw	s0,40(sp)
c0005f68:	03010413          	addi	s0,sp,48
c0005f6c:	fca42e23          	sw	a0,-36(s0)
c0005f70:	fcb42c23          	sw	a1,-40(s0)
c0005f74:	fcc42a23          	sw	a2,-44(s0)
c0005f78:	fcd42823          	sw	a3,-48(s0)
	TCB_t * pxTCB;
	BaseType_t xReturn = pdPASS;
c0005f7c:	00100793          	li	a5,1
c0005f80:	fef42623          	sw	a5,-20(s0)
	uint8_t ucOriginalNotifyState;

		configASSERT( xTaskToNotify );
c0005f84:	fdc42783          	lw	a5,-36(s0)
c0005f88:	00079863          	bnez	a5,c0005f98 <xTaskGenericNotify+0x3c>
c0005f8c:	30047073          	csrci	mstatus,8
c0005f90:	00100073          	ebreak
c0005f94:	0000006f          	j	c0005f94 <xTaskGenericNotify+0x38>
		pxTCB = xTaskToNotify;
c0005f98:	fdc42783          	lw	a5,-36(s0)
c0005f9c:	fef42423          	sw	a5,-24(s0)

		taskENTER_CRITICAL();
c0005fa0:	9a1ff0ef          	jal	ra,c0005940 <vTaskEnterCritical>
		{
			if( pulPreviousNotificationValue != NULL )
c0005fa4:	fd042783          	lw	a5,-48(s0)
c0005fa8:	00078a63          	beqz	a5,c0005fbc <xTaskGenericNotify+0x60>
			{
				*pulPreviousNotificationValue = pxTCB->ulNotifiedValue;
c0005fac:	fe842783          	lw	a5,-24(s0)
c0005fb0:	05c7a703          	lw	a4,92(a5)
c0005fb4:	fd042783          	lw	a5,-48(s0)
c0005fb8:	00e7a023          	sw	a4,0(a5)
			}

			ucOriginalNotifyState = pxTCB->ucNotifyState;
c0005fbc:	fe842783          	lw	a5,-24(s0)
c0005fc0:	0607c783          	lbu	a5,96(a5)
c0005fc4:	fef403a3          	sb	a5,-25(s0)

			pxTCB->ucNotifyState = taskNOTIFICATION_RECEIVED;
c0005fc8:	fe842783          	lw	a5,-24(s0)
c0005fcc:	00200713          	li	a4,2
c0005fd0:	06e78023          	sb	a4,96(a5)
c0005fd4:	fd442703          	lw	a4,-44(s0)
c0005fd8:	00400793          	li	a5,4
c0005fdc:	08e7ea63          	bltu	a5,a4,c0006070 <xTaskGenericNotify+0x114>
c0005fe0:	fd442783          	lw	a5,-44(s0)
c0005fe4:	00279713          	slli	a4,a5,0x2
c0005fe8:	07ffa797          	auipc	a5,0x7ffa
c0005fec:	04478793          	addi	a5,a5,68 # c800002c <__rodata_start+0x2c>
c0005ff0:	00f707b3          	add	a5,a4,a5
c0005ff4:	0007a703          	lw	a4,0(a5)
c0005ff8:	07ffa797          	auipc	a5,0x7ffa
c0005ffc:	03478793          	addi	a5,a5,52 # c800002c <__rodata_start+0x2c>
c0006000:	00f707b3          	add	a5,a4,a5
c0006004:	00078067          	jr	a5

			switch( eAction )
			{
				case eSetBits	:
					pxTCB->ulNotifiedValue |= ulValue;
c0006008:	fe842783          	lw	a5,-24(s0)
c000600c:	05c7a703          	lw	a4,92(a5)
c0006010:	fd842783          	lw	a5,-40(s0)
c0006014:	00f76733          	or	a4,a4,a5
c0006018:	fe842783          	lw	a5,-24(s0)
c000601c:	04e7ae23          	sw	a4,92(a5)
					break;
c0006020:	0780006f          	j	c0006098 <xTaskGenericNotify+0x13c>

				case eIncrement	:
					( pxTCB->ulNotifiedValue )++;
c0006024:	fe842783          	lw	a5,-24(s0)
c0006028:	05c7a783          	lw	a5,92(a5)
c000602c:	00178713          	addi	a4,a5,1
c0006030:	fe842783          	lw	a5,-24(s0)
c0006034:	04e7ae23          	sw	a4,92(a5)
					break;
c0006038:	0600006f          	j	c0006098 <xTaskGenericNotify+0x13c>

				case eSetValueWithOverwrite	:
					pxTCB->ulNotifiedValue = ulValue;
c000603c:	fe842783          	lw	a5,-24(s0)
c0006040:	fd842703          	lw	a4,-40(s0)
c0006044:	04e7ae23          	sw	a4,92(a5)
					break;
c0006048:	0500006f          	j	c0006098 <xTaskGenericNotify+0x13c>

				case eSetValueWithoutOverwrite :
					if( ucOriginalNotifyState != taskNOTIFICATION_RECEIVED )
c000604c:	fe744703          	lbu	a4,-25(s0)
c0006050:	00200793          	li	a5,2
c0006054:	00f70a63          	beq	a4,a5,c0006068 <xTaskGenericNotify+0x10c>
					{
						pxTCB->ulNotifiedValue = ulValue;
c0006058:	fe842783          	lw	a5,-24(s0)
c000605c:	fd842703          	lw	a4,-40(s0)
c0006060:	04e7ae23          	sw	a4,92(a5)
					else
					{
						/* The value could not be written to the task. */
						xReturn = pdFAIL;
					}
					break;
c0006064:	0340006f          	j	c0006098 <xTaskGenericNotify+0x13c>
						xReturn = pdFAIL;
c0006068:	fe042623          	sw	zero,-20(s0)
					break;
c000606c:	02c0006f          	j	c0006098 <xTaskGenericNotify+0x13c>

				default:
					/* Should not get here if all enums are handled.
					Artificially force an assert by testing a value the
					compiler can't assume is const. */
					configASSERT( pxTCB->ulNotifiedValue == ~0UL );
c0006070:	fe842783          	lw	a5,-24(s0)
c0006074:	05c7a703          	lw	a4,92(a5)
c0006078:	fff00793          	li	a5,-1
c000607c:	00f70c63          	beq	a4,a5,c0006094 <xTaskGenericNotify+0x138>
c0006080:	30047073          	csrci	mstatus,8
c0006084:	00100073          	ebreak
c0006088:	0000006f          	j	c0006088 <xTaskGenericNotify+0x12c>
					break;
c000608c:	00000013          	nop
c0006090:	0080006f          	j	c0006098 <xTaskGenericNotify+0x13c>

					break;
c0006094:	00000013          	nop

			traceTASK_NOTIFY();

			/* If the task is in the blocked state specifically to wait for a
			notification then unblock it now. */
			if( ucOriginalNotifyState == taskWAITING_NOTIFICATION )
c0006098:	fe744703          	lbu	a4,-25(s0)
c000609c:	00100793          	li	a5,1
c00060a0:	0af71863          	bne	a4,a5,c0006150 <xTaskGenericNotify+0x1f4>
			{
				( void ) uxListRemove( &( pxTCB->xStateListItem ) );
c00060a4:	fe842783          	lw	a5,-24(s0)
c00060a8:	00478793          	addi	a5,a5,4
c00060ac:	00078513          	mv	a0,a5
c00060b0:	ffcfa0ef          	jal	ra,c00008ac <uxListRemove>
				prvAddTaskToReadyList( pxTCB );
c00060b4:	fe842783          	lw	a5,-24(s0)
c00060b8:	02c7a783          	lw	a5,44(a5)
c00060bc:	00100713          	li	a4,1
c00060c0:	00f71733          	sll	a4,a4,a5
c00060c4:	07ffd797          	auipc	a5,0x7ffd
c00060c8:	56078793          	addi	a5,a5,1376 # c8003624 <uxTopReadyPriority>
c00060cc:	0007a783          	lw	a5,0(a5)
c00060d0:	00f76733          	or	a4,a4,a5
c00060d4:	07ffd797          	auipc	a5,0x7ffd
c00060d8:	55078793          	addi	a5,a5,1360 # c8003624 <uxTopReadyPriority>
c00060dc:	00e7a023          	sw	a4,0(a5)
c00060e0:	fe842783          	lw	a5,-24(s0)
c00060e4:	02c7a703          	lw	a4,44(a5)
c00060e8:	00070793          	mv	a5,a4
c00060ec:	00279793          	slli	a5,a5,0x2
c00060f0:	00e787b3          	add	a5,a5,a4
c00060f4:	00279793          	slli	a5,a5,0x2
c00060f8:	07ffd717          	auipc	a4,0x7ffd
c00060fc:	45070713          	addi	a4,a4,1104 # c8003548 <pxReadyTasksLists>
c0006100:	00e78733          	add	a4,a5,a4
c0006104:	fe842783          	lw	a5,-24(s0)
c0006108:	00478793          	addi	a5,a5,4
c000610c:	00078593          	mv	a1,a5
c0006110:	00070513          	mv	a0,a4
c0006114:	e3cfa0ef          	jal	ra,c0000750 <vListInsertEnd>

				/* The task should not have been on an event list. */
				configASSERT( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) == NULL );
c0006118:	fe842783          	lw	a5,-24(s0)
c000611c:	0287a783          	lw	a5,40(a5)
c0006120:	00078863          	beqz	a5,c0006130 <xTaskGenericNotify+0x1d4>
c0006124:	30047073          	csrci	mstatus,8
c0006128:	00100073          	ebreak
c000612c:	0000006f          	j	c000612c <xTaskGenericNotify+0x1d0>
					earliest possible time. */
					prvResetNextTaskUnblockTime();
				}
				#endif

				if( pxTCB->uxPriority > pxCurrentTCB->uxPriority )
c0006130:	fe842783          	lw	a5,-24(s0)
c0006134:	02c7a703          	lw	a4,44(a5)
c0006138:	07ffc797          	auipc	a5,0x7ffc
c000613c:	75478793          	addi	a5,a5,1876 # c800288c <pxCurrentTCB>
c0006140:	0007a783          	lw	a5,0(a5)
c0006144:	02c7a783          	lw	a5,44(a5)
c0006148:	00e7f463          	bgeu	a5,a4,c0006150 <xTaskGenericNotify+0x1f4>
				{
					/* The notified task has a priority above the currently
					executing task so a yield is required. */
					taskYIELD_IF_USING_PREEMPTION();
c000614c:	00000073          	ecall
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
		taskEXIT_CRITICAL();
c0006150:	845ff0ef          	jal	ra,c0005994 <vTaskExitCritical>

		return xReturn;
c0006154:	fec42783          	lw	a5,-20(s0)
	}
c0006158:	00078513          	mv	a0,a5
c000615c:	02c12083          	lw	ra,44(sp)
c0006160:	02812403          	lw	s0,40(sp)
c0006164:	03010113          	addi	sp,sp,48
c0006168:	00008067          	ret

c000616c <xTaskGenericNotifyFromISR>:
/*-----------------------------------------------------------*/

#if( configUSE_TASK_NOTIFICATIONS == 1 )

	BaseType_t xTaskGenericNotifyFromISR( TaskHandle_t xTaskToNotify, uint32_t ulValue, eNotifyAction eAction, uint32_t *pulPreviousNotificationValue, BaseType_t *pxHigherPriorityTaskWoken )
	{
c000616c:	fc010113          	addi	sp,sp,-64
c0006170:	02112e23          	sw	ra,60(sp)
c0006174:	02812c23          	sw	s0,56(sp)
c0006178:	04010413          	addi	s0,sp,64
c000617c:	fca42e23          	sw	a0,-36(s0)
c0006180:	fcb42c23          	sw	a1,-40(s0)
c0006184:	fcc42a23          	sw	a2,-44(s0)
c0006188:	fcd42823          	sw	a3,-48(s0)
c000618c:	fce42623          	sw	a4,-52(s0)
	TCB_t * pxTCB;
	uint8_t ucOriginalNotifyState;
	BaseType_t xReturn = pdPASS;
c0006190:	00100793          	li	a5,1
c0006194:	fef42623          	sw	a5,-20(s0)
	UBaseType_t uxSavedInterruptStatus;

		configASSERT( xTaskToNotify );
c0006198:	fdc42783          	lw	a5,-36(s0)
c000619c:	00079863          	bnez	a5,c00061ac <xTaskGenericNotifyFromISR+0x40>
c00061a0:	30047073          	csrci	mstatus,8
c00061a4:	00100073          	ebreak
c00061a8:	0000006f          	j	c00061a8 <xTaskGenericNotifyFromISR+0x3c>
		simple as possible.  More information (albeit Cortex-M specific) is
		provided on the following link:
		http://www.freertos.org/RTOS-Cortex-M3-M4.html */
		portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

		pxTCB = xTaskToNotify;
c00061ac:	fdc42783          	lw	a5,-36(s0)
c00061b0:	fef42423          	sw	a5,-24(s0)

		uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
c00061b4:	fe042223          	sw	zero,-28(s0)
		{
			if( pulPreviousNotificationValue != NULL )
c00061b8:	fd042783          	lw	a5,-48(s0)
c00061bc:	00078a63          	beqz	a5,c00061d0 <xTaskGenericNotifyFromISR+0x64>
			{
				*pulPreviousNotificationValue = pxTCB->ulNotifiedValue;
c00061c0:	fe842783          	lw	a5,-24(s0)
c00061c4:	05c7a703          	lw	a4,92(a5)
c00061c8:	fd042783          	lw	a5,-48(s0)
c00061cc:	00e7a023          	sw	a4,0(a5)
			}

			ucOriginalNotifyState = pxTCB->ucNotifyState;
c00061d0:	fe842783          	lw	a5,-24(s0)
c00061d4:	0607c783          	lbu	a5,96(a5)
c00061d8:	fef401a3          	sb	a5,-29(s0)
			pxTCB->ucNotifyState = taskNOTIFICATION_RECEIVED;
c00061dc:	fe842783          	lw	a5,-24(s0)
c00061e0:	00200713          	li	a4,2
c00061e4:	06e78023          	sb	a4,96(a5)
c00061e8:	fd442703          	lw	a4,-44(s0)
c00061ec:	00400793          	li	a5,4
c00061f0:	08e7ea63          	bltu	a5,a4,c0006284 <xTaskGenericNotifyFromISR+0x118>
c00061f4:	fd442783          	lw	a5,-44(s0)
c00061f8:	00279713          	slli	a4,a5,0x2
c00061fc:	07ffa797          	auipc	a5,0x7ffa
c0006200:	e4478793          	addi	a5,a5,-444 # c8000040 <__rodata_start+0x40>
c0006204:	00f707b3          	add	a5,a4,a5
c0006208:	0007a703          	lw	a4,0(a5)
c000620c:	07ffa797          	auipc	a5,0x7ffa
c0006210:	e3478793          	addi	a5,a5,-460 # c8000040 <__rodata_start+0x40>
c0006214:	00f707b3          	add	a5,a4,a5
c0006218:	00078067          	jr	a5

			switch( eAction )
			{
				case eSetBits	:
					pxTCB->ulNotifiedValue |= ulValue;
c000621c:	fe842783          	lw	a5,-24(s0)
c0006220:	05c7a703          	lw	a4,92(a5)
c0006224:	fd842783          	lw	a5,-40(s0)
c0006228:	00f76733          	or	a4,a4,a5
c000622c:	fe842783          	lw	a5,-24(s0)
c0006230:	04e7ae23          	sw	a4,92(a5)
					break;
c0006234:	0780006f          	j	c00062ac <xTaskGenericNotifyFromISR+0x140>

				case eIncrement	:
					( pxTCB->ulNotifiedValue )++;
c0006238:	fe842783          	lw	a5,-24(s0)
c000623c:	05c7a783          	lw	a5,92(a5)
c0006240:	00178713          	addi	a4,a5,1
c0006244:	fe842783          	lw	a5,-24(s0)
c0006248:	04e7ae23          	sw	a4,92(a5)
					break;
c000624c:	0600006f          	j	c00062ac <xTaskGenericNotifyFromISR+0x140>

				case eSetValueWithOverwrite	:
					pxTCB->ulNotifiedValue = ulValue;
c0006250:	fe842783          	lw	a5,-24(s0)
c0006254:	fd842703          	lw	a4,-40(s0)
c0006258:	04e7ae23          	sw	a4,92(a5)
					break;
c000625c:	0500006f          	j	c00062ac <xTaskGenericNotifyFromISR+0x140>

				case eSetValueWithoutOverwrite :
					if( ucOriginalNotifyState != taskNOTIFICATION_RECEIVED )
c0006260:	fe344703          	lbu	a4,-29(s0)
c0006264:	00200793          	li	a5,2
c0006268:	00f70a63          	beq	a4,a5,c000627c <xTaskGenericNotifyFromISR+0x110>
					{
						pxTCB->ulNotifiedValue = ulValue;
c000626c:	fe842783          	lw	a5,-24(s0)
c0006270:	fd842703          	lw	a4,-40(s0)
c0006274:	04e7ae23          	sw	a4,92(a5)
					else
					{
						/* The value could not be written to the task. */
						xReturn = pdFAIL;
					}
					break;
c0006278:	0340006f          	j	c00062ac <xTaskGenericNotifyFromISR+0x140>
						xReturn = pdFAIL;
c000627c:	fe042623          	sw	zero,-20(s0)
					break;
c0006280:	02c0006f          	j	c00062ac <xTaskGenericNotifyFromISR+0x140>

				default:
					/* Should not get here if all enums are handled.
					Artificially force an assert by testing a value the
					compiler can't assume is const. */
					configASSERT( pxTCB->ulNotifiedValue == ~0UL );
c0006284:	fe842783          	lw	a5,-24(s0)
c0006288:	05c7a703          	lw	a4,92(a5)
c000628c:	fff00793          	li	a5,-1
c0006290:	00f70c63          	beq	a4,a5,c00062a8 <xTaskGenericNotifyFromISR+0x13c>
c0006294:	30047073          	csrci	mstatus,8
c0006298:	00100073          	ebreak
c000629c:	0000006f          	j	c000629c <xTaskGenericNotifyFromISR+0x130>
					break;
c00062a0:	00000013          	nop
c00062a4:	0080006f          	j	c00062ac <xTaskGenericNotifyFromISR+0x140>
					break;
c00062a8:	00000013          	nop

			traceTASK_NOTIFY_FROM_ISR();

			/* If the task is in the blocked state specifically to wait for a
			notification then unblock it now. */
			if( ucOriginalNotifyState == taskWAITING_NOTIFICATION )
c00062ac:	fe344703          	lbu	a4,-29(s0)
c00062b0:	00100793          	li	a5,1
c00062b4:	0ef71e63          	bne	a4,a5,c00063b0 <xTaskGenericNotifyFromISR+0x244>
			{
				/* The task should not have been on an event list. */
				configASSERT( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) == NULL );
c00062b8:	fe842783          	lw	a5,-24(s0)
c00062bc:	0287a783          	lw	a5,40(a5)
c00062c0:	00078863          	beqz	a5,c00062d0 <xTaskGenericNotifyFromISR+0x164>
c00062c4:	30047073          	csrci	mstatus,8
c00062c8:	00100073          	ebreak
c00062cc:	0000006f          	j	c00062cc <xTaskGenericNotifyFromISR+0x160>

				if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
c00062d0:	07ffd797          	auipc	a5,0x7ffd
c00062d4:	37478793          	addi	a5,a5,884 # c8003644 <uxSchedulerSuspended>
c00062d8:	0007a783          	lw	a5,0(a5)
c00062dc:	06079e63          	bnez	a5,c0006358 <xTaskGenericNotifyFromISR+0x1ec>
				{
					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
c00062e0:	fe842783          	lw	a5,-24(s0)
c00062e4:	00478793          	addi	a5,a5,4
c00062e8:	00078513          	mv	a0,a5
c00062ec:	dc0fa0ef          	jal	ra,c00008ac <uxListRemove>
					prvAddTaskToReadyList( pxTCB );
c00062f0:	fe842783          	lw	a5,-24(s0)
c00062f4:	02c7a783          	lw	a5,44(a5)
c00062f8:	00100713          	li	a4,1
c00062fc:	00f71733          	sll	a4,a4,a5
c0006300:	07ffd797          	auipc	a5,0x7ffd
c0006304:	32478793          	addi	a5,a5,804 # c8003624 <uxTopReadyPriority>
c0006308:	0007a783          	lw	a5,0(a5)
c000630c:	00f76733          	or	a4,a4,a5
c0006310:	07ffd797          	auipc	a5,0x7ffd
c0006314:	31478793          	addi	a5,a5,788 # c8003624 <uxTopReadyPriority>
c0006318:	00e7a023          	sw	a4,0(a5)
c000631c:	fe842783          	lw	a5,-24(s0)
c0006320:	02c7a703          	lw	a4,44(a5)
c0006324:	00070793          	mv	a5,a4
c0006328:	00279793          	slli	a5,a5,0x2
c000632c:	00e787b3          	add	a5,a5,a4
c0006330:	00279793          	slli	a5,a5,0x2
c0006334:	07ffd717          	auipc	a4,0x7ffd
c0006338:	21470713          	addi	a4,a4,532 # c8003548 <pxReadyTasksLists>
c000633c:	00e78733          	add	a4,a5,a4
c0006340:	fe842783          	lw	a5,-24(s0)
c0006344:	00478793          	addi	a5,a5,4
c0006348:	00078593          	mv	a1,a5
c000634c:	00070513          	mv	a0,a4
c0006350:	c00fa0ef          	jal	ra,c0000750 <vListInsertEnd>
c0006354:	01c0006f          	j	c0006370 <xTaskGenericNotifyFromISR+0x204>
				}
				else
				{
					/* The delayed and ready lists cannot be accessed, so hold
					this task pending until the scheduler is resumed. */
					vListInsertEnd( &( xPendingReadyList ), &( pxTCB->xEventListItem ) );
c0006358:	fe842783          	lw	a5,-24(s0)
c000635c:	01878793          	addi	a5,a5,24
c0006360:	00078593          	mv	a1,a5
c0006364:	07ffd517          	auipc	a0,0x7ffd
c0006368:	27850513          	addi	a0,a0,632 # c80035dc <xPendingReadyList>
c000636c:	be4fa0ef          	jal	ra,c0000750 <vListInsertEnd>
				}

				if( pxTCB->uxPriority > pxCurrentTCB->uxPriority )
c0006370:	fe842783          	lw	a5,-24(s0)
c0006374:	02c7a703          	lw	a4,44(a5)
c0006378:	07ffc797          	auipc	a5,0x7ffc
c000637c:	51478793          	addi	a5,a5,1300 # c800288c <pxCurrentTCB>
c0006380:	0007a783          	lw	a5,0(a5)
c0006384:	02c7a783          	lw	a5,44(a5)
c0006388:	02e7f463          	bgeu	a5,a4,c00063b0 <xTaskGenericNotifyFromISR+0x244>
				{
					/* The notified task has a priority above the currently
					executing task so a yield is required. */
					if( pxHigherPriorityTaskWoken != NULL )
c000638c:	fcc42783          	lw	a5,-52(s0)
c0006390:	00078863          	beqz	a5,c00063a0 <xTaskGenericNotifyFromISR+0x234>
					{
						*pxHigherPriorityTaskWoken = pdTRUE;
c0006394:	fcc42783          	lw	a5,-52(s0)
c0006398:	00100713          	li	a4,1
c000639c:	00e7a023          	sw	a4,0(a5)
					}

					/* Mark that a yield is pending in case the user is not
					using the "xHigherPriorityTaskWoken" parameter to an ISR
					safe FreeRTOS function. */
					xYieldPending = pdTRUE;
c00063a0:	07ffd797          	auipc	a5,0x7ffd
c00063a4:	29078793          	addi	a5,a5,656 # c8003630 <xYieldPending>
c00063a8:	00100713          	li	a4,1
c00063ac:	00e7a023          	sw	a4,0(a5)
				}
			}
		}
		portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

		return xReturn;
c00063b0:	fec42783          	lw	a5,-20(s0)
	}
c00063b4:	00078513          	mv	a0,a5
c00063b8:	03c12083          	lw	ra,60(sp)
c00063bc:	03812403          	lw	s0,56(sp)
c00063c0:	04010113          	addi	sp,sp,64
c00063c4:	00008067          	ret

c00063c8 <vTaskNotifyGiveFromISR>:
/*-----------------------------------------------------------*/

#if( configUSE_TASK_NOTIFICATIONS == 1 )

	void vTaskNotifyGiveFromISR( TaskHandle_t xTaskToNotify, BaseType_t *pxHigherPriorityTaskWoken )
	{
c00063c8:	fd010113          	addi	sp,sp,-48
c00063cc:	02112623          	sw	ra,44(sp)
c00063d0:	02812423          	sw	s0,40(sp)
c00063d4:	03010413          	addi	s0,sp,48
c00063d8:	fca42e23          	sw	a0,-36(s0)
c00063dc:	fcb42c23          	sw	a1,-40(s0)
	TCB_t * pxTCB;
	uint8_t ucOriginalNotifyState;
	UBaseType_t uxSavedInterruptStatus;

		configASSERT( xTaskToNotify );
c00063e0:	fdc42783          	lw	a5,-36(s0)
c00063e4:	00079863          	bnez	a5,c00063f4 <vTaskNotifyGiveFromISR+0x2c>
c00063e8:	30047073          	csrci	mstatus,8
c00063ec:	00100073          	ebreak
c00063f0:	0000006f          	j	c00063f0 <vTaskNotifyGiveFromISR+0x28>
		simple as possible.  More information (albeit Cortex-M specific) is
		provided on the following link:
		http://www.freertos.org/RTOS-Cortex-M3-M4.html */
		portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

		pxTCB = xTaskToNotify;
c00063f4:	fdc42783          	lw	a5,-36(s0)
c00063f8:	fef42623          	sw	a5,-20(s0)

		uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
c00063fc:	fe042423          	sw	zero,-24(s0)
		{
			ucOriginalNotifyState = pxTCB->ucNotifyState;
c0006400:	fec42783          	lw	a5,-20(s0)
c0006404:	0607c783          	lbu	a5,96(a5)
c0006408:	fef403a3          	sb	a5,-25(s0)
			pxTCB->ucNotifyState = taskNOTIFICATION_RECEIVED;
c000640c:	fec42783          	lw	a5,-20(s0)
c0006410:	00200713          	li	a4,2
c0006414:	06e78023          	sb	a4,96(a5)

			/* 'Giving' is equivalent to incrementing a count in a counting
			semaphore. */
			( pxTCB->ulNotifiedValue )++;
c0006418:	fec42783          	lw	a5,-20(s0)
c000641c:	05c7a783          	lw	a5,92(a5)
c0006420:	00178713          	addi	a4,a5,1
c0006424:	fec42783          	lw	a5,-20(s0)
c0006428:	04e7ae23          	sw	a4,92(a5)

			traceTASK_NOTIFY_GIVE_FROM_ISR();

			/* If the task is in the blocked state specifically to wait for a
			notification then unblock it now. */
			if( ucOriginalNotifyState == taskWAITING_NOTIFICATION )
c000642c:	fe744703          	lbu	a4,-25(s0)
c0006430:	00100793          	li	a5,1
c0006434:	0ef71e63          	bne	a4,a5,c0006530 <vTaskNotifyGiveFromISR+0x168>
			{
				/* The task should not have been on an event list. */
				configASSERT( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) == NULL );
c0006438:	fec42783          	lw	a5,-20(s0)
c000643c:	0287a783          	lw	a5,40(a5)
c0006440:	00078863          	beqz	a5,c0006450 <vTaskNotifyGiveFromISR+0x88>
c0006444:	30047073          	csrci	mstatus,8
c0006448:	00100073          	ebreak
c000644c:	0000006f          	j	c000644c <vTaskNotifyGiveFromISR+0x84>

				if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
c0006450:	07ffd797          	auipc	a5,0x7ffd
c0006454:	1f478793          	addi	a5,a5,500 # c8003644 <uxSchedulerSuspended>
c0006458:	0007a783          	lw	a5,0(a5)
c000645c:	06079e63          	bnez	a5,c00064d8 <vTaskNotifyGiveFromISR+0x110>
				{
					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
c0006460:	fec42783          	lw	a5,-20(s0)
c0006464:	00478793          	addi	a5,a5,4
c0006468:	00078513          	mv	a0,a5
c000646c:	c40fa0ef          	jal	ra,c00008ac <uxListRemove>
					prvAddTaskToReadyList( pxTCB );
c0006470:	fec42783          	lw	a5,-20(s0)
c0006474:	02c7a783          	lw	a5,44(a5)
c0006478:	00100713          	li	a4,1
c000647c:	00f71733          	sll	a4,a4,a5
c0006480:	07ffd797          	auipc	a5,0x7ffd
c0006484:	1a478793          	addi	a5,a5,420 # c8003624 <uxTopReadyPriority>
c0006488:	0007a783          	lw	a5,0(a5)
c000648c:	00f76733          	or	a4,a4,a5
c0006490:	07ffd797          	auipc	a5,0x7ffd
c0006494:	19478793          	addi	a5,a5,404 # c8003624 <uxTopReadyPriority>
c0006498:	00e7a023          	sw	a4,0(a5)
c000649c:	fec42783          	lw	a5,-20(s0)
c00064a0:	02c7a703          	lw	a4,44(a5)
c00064a4:	00070793          	mv	a5,a4
c00064a8:	00279793          	slli	a5,a5,0x2
c00064ac:	00e787b3          	add	a5,a5,a4
c00064b0:	00279793          	slli	a5,a5,0x2
c00064b4:	07ffd717          	auipc	a4,0x7ffd
c00064b8:	09470713          	addi	a4,a4,148 # c8003548 <pxReadyTasksLists>
c00064bc:	00e78733          	add	a4,a5,a4
c00064c0:	fec42783          	lw	a5,-20(s0)
c00064c4:	00478793          	addi	a5,a5,4
c00064c8:	00078593          	mv	a1,a5
c00064cc:	00070513          	mv	a0,a4
c00064d0:	a80fa0ef          	jal	ra,c0000750 <vListInsertEnd>
c00064d4:	01c0006f          	j	c00064f0 <vTaskNotifyGiveFromISR+0x128>
				}
				else
				{
					/* The delayed and ready lists cannot be accessed, so hold
					this task pending until the scheduler is resumed. */
					vListInsertEnd( &( xPendingReadyList ), &( pxTCB->xEventListItem ) );
c00064d8:	fec42783          	lw	a5,-20(s0)
c00064dc:	01878793          	addi	a5,a5,24
c00064e0:	00078593          	mv	a1,a5
c00064e4:	07ffd517          	auipc	a0,0x7ffd
c00064e8:	0f850513          	addi	a0,a0,248 # c80035dc <xPendingReadyList>
c00064ec:	a64fa0ef          	jal	ra,c0000750 <vListInsertEnd>
				}

				if( pxTCB->uxPriority > pxCurrentTCB->uxPriority )
c00064f0:	fec42783          	lw	a5,-20(s0)
c00064f4:	02c7a703          	lw	a4,44(a5)
c00064f8:	07ffc797          	auipc	a5,0x7ffc
c00064fc:	39478793          	addi	a5,a5,916 # c800288c <pxCurrentTCB>
c0006500:	0007a783          	lw	a5,0(a5)
c0006504:	02c7a783          	lw	a5,44(a5)
c0006508:	02e7f463          	bgeu	a5,a4,c0006530 <vTaskNotifyGiveFromISR+0x168>
				{
					/* The notified task has a priority above the currently
					executing task so a yield is required. */
					if( pxHigherPriorityTaskWoken != NULL )
c000650c:	fd842783          	lw	a5,-40(s0)
c0006510:	00078863          	beqz	a5,c0006520 <vTaskNotifyGiveFromISR+0x158>
					{
						*pxHigherPriorityTaskWoken = pdTRUE;
c0006514:	fd842783          	lw	a5,-40(s0)
c0006518:	00100713          	li	a4,1
c000651c:	00e7a023          	sw	a4,0(a5)
					}

					/* Mark that a yield is pending in case the user is not
					using the "xHigherPriorityTaskWoken" parameter in an ISR
					safe FreeRTOS function. */
					xYieldPending = pdTRUE;
c0006520:	07ffd797          	auipc	a5,0x7ffd
c0006524:	11078793          	addi	a5,a5,272 # c8003630 <xYieldPending>
c0006528:	00100713          	li	a4,1
c000652c:	00e7a023          	sw	a4,0(a5)
					mtCOVERAGE_TEST_MARKER();
				}
			}
		}
		portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
	}
c0006530:	00000013          	nop
c0006534:	02c12083          	lw	ra,44(sp)
c0006538:	02812403          	lw	s0,40(sp)
c000653c:	03010113          	addi	sp,sp,48
c0006540:	00008067          	ret

c0006544 <xTaskNotifyStateClear>:
/*-----------------------------------------------------------*/

#if( configUSE_TASK_NOTIFICATIONS == 1 )

	BaseType_t xTaskNotifyStateClear( TaskHandle_t xTask )
	{
c0006544:	fd010113          	addi	sp,sp,-48
c0006548:	02112623          	sw	ra,44(sp)
c000654c:	02812423          	sw	s0,40(sp)
c0006550:	03010413          	addi	s0,sp,48
c0006554:	fca42e23          	sw	a0,-36(s0)
	TCB_t *pxTCB;
	BaseType_t xReturn;

		/* If null is passed in here then it is the calling task that is having
		its notification state cleared. */
		pxTCB = prvGetTCBFromHandle( xTask );
c0006558:	fdc42783          	lw	a5,-36(s0)
c000655c:	00079a63          	bnez	a5,c0006570 <xTaskNotifyStateClear+0x2c>
c0006560:	07ffc797          	auipc	a5,0x7ffc
c0006564:	32c78793          	addi	a5,a5,812 # c800288c <pxCurrentTCB>
c0006568:	0007a783          	lw	a5,0(a5)
c000656c:	0080006f          	j	c0006574 <xTaskNotifyStateClear+0x30>
c0006570:	fdc42783          	lw	a5,-36(s0)
c0006574:	fef42423          	sw	a5,-24(s0)

		taskENTER_CRITICAL();
c0006578:	bc8ff0ef          	jal	ra,c0005940 <vTaskEnterCritical>
		{
			if( pxTCB->ucNotifyState == taskNOTIFICATION_RECEIVED )
c000657c:	fe842783          	lw	a5,-24(s0)
c0006580:	0607c783          	lbu	a5,96(a5)
c0006584:	0ff7f713          	andi	a4,a5,255
c0006588:	00200793          	li	a5,2
c000658c:	00f71c63          	bne	a4,a5,c00065a4 <xTaskNotifyStateClear+0x60>
			{
				pxTCB->ucNotifyState = taskNOT_WAITING_NOTIFICATION;
c0006590:	fe842783          	lw	a5,-24(s0)
c0006594:	06078023          	sb	zero,96(a5)
				xReturn = pdPASS;
c0006598:	00100793          	li	a5,1
c000659c:	fef42623          	sw	a5,-20(s0)
c00065a0:	0080006f          	j	c00065a8 <xTaskNotifyStateClear+0x64>
			}
			else
			{
				xReturn = pdFAIL;
c00065a4:	fe042623          	sw	zero,-20(s0)
			}
		}
		taskEXIT_CRITICAL();
c00065a8:	becff0ef          	jal	ra,c0005994 <vTaskExitCritical>

		return xReturn;
c00065ac:	fec42783          	lw	a5,-20(s0)
	}
c00065b0:	00078513          	mv	a0,a5
c00065b4:	02c12083          	lw	ra,44(sp)
c00065b8:	02812403          	lw	s0,40(sp)
c00065bc:	03010113          	addi	sp,sp,48
c00065c0:	00008067          	ret

c00065c4 <ulTaskNotifyValueClear>:
/*-----------------------------------------------------------*/

#if( configUSE_TASK_NOTIFICATIONS == 1 )

	uint32_t ulTaskNotifyValueClear( TaskHandle_t xTask, uint32_t ulBitsToClear )
	{
c00065c4:	fd010113          	addi	sp,sp,-48
c00065c8:	02112623          	sw	ra,44(sp)
c00065cc:	02812423          	sw	s0,40(sp)
c00065d0:	03010413          	addi	s0,sp,48
c00065d4:	fca42e23          	sw	a0,-36(s0)
c00065d8:	fcb42c23          	sw	a1,-40(s0)
	TCB_t *pxTCB;
	uint32_t ulReturn;

		/* If null is passed in here then it is the calling task that is having
		its notification state cleared. */
		pxTCB = prvGetTCBFromHandle( xTask );
c00065dc:	fdc42783          	lw	a5,-36(s0)
c00065e0:	00079a63          	bnez	a5,c00065f4 <ulTaskNotifyValueClear+0x30>
c00065e4:	07ffc797          	auipc	a5,0x7ffc
c00065e8:	2a878793          	addi	a5,a5,680 # c800288c <pxCurrentTCB>
c00065ec:	0007a783          	lw	a5,0(a5)
c00065f0:	0080006f          	j	c00065f8 <ulTaskNotifyValueClear+0x34>
c00065f4:	fdc42783          	lw	a5,-36(s0)
c00065f8:	fef42623          	sw	a5,-20(s0)

		taskENTER_CRITICAL();
c00065fc:	b44ff0ef          	jal	ra,c0005940 <vTaskEnterCritical>
		{
			/* Return the notification as it was before the bits were cleared,
			then clear the bit mask. */
			ulReturn = pxCurrentTCB->ulNotifiedValue;
c0006600:	07ffc797          	auipc	a5,0x7ffc
c0006604:	28c78793          	addi	a5,a5,652 # c800288c <pxCurrentTCB>
c0006608:	0007a783          	lw	a5,0(a5)
c000660c:	05c7a783          	lw	a5,92(a5)
c0006610:	fef42423          	sw	a5,-24(s0)
			pxTCB->ulNotifiedValue &= ~ulBitsToClear;
c0006614:	fec42783          	lw	a5,-20(s0)
c0006618:	05c7a703          	lw	a4,92(a5)
c000661c:	fd842783          	lw	a5,-40(s0)
c0006620:	fff7c793          	not	a5,a5
c0006624:	00f77733          	and	a4,a4,a5
c0006628:	fec42783          	lw	a5,-20(s0)
c000662c:	04e7ae23          	sw	a4,92(a5)
		}
		taskEXIT_CRITICAL();
c0006630:	b64ff0ef          	jal	ra,c0005994 <vTaskExitCritical>

		return ulReturn;
c0006634:	fe842783          	lw	a5,-24(s0)
	}
c0006638:	00078513          	mv	a0,a5
c000663c:	02c12083          	lw	ra,44(sp)
c0006640:	02812403          	lw	s0,40(sp)
c0006644:	03010113          	addi	sp,sp,48
c0006648:	00008067          	ret

c000664c <prvAddCurrentTaskToDelayedList>:

#endif
/*-----------------------------------------------------------*/

static void prvAddCurrentTaskToDelayedList( TickType_t xTicksToWait, const BaseType_t xCanBlockIndefinitely )
{
c000664c:	fd010113          	addi	sp,sp,-48
c0006650:	02112623          	sw	ra,44(sp)
c0006654:	02812423          	sw	s0,40(sp)
c0006658:	03010413          	addi	s0,sp,48
c000665c:	fca42e23          	sw	a0,-36(s0)
c0006660:	fcb42c23          	sw	a1,-40(s0)
TickType_t xTimeToWake;
const TickType_t xConstTickCount = xTickCount;
c0006664:	07ffd797          	auipc	a5,0x7ffd
c0006668:	fbc78793          	addi	a5,a5,-68 # c8003620 <xTickCount>
c000666c:	0007a783          	lw	a5,0(a5)
c0006670:	fef42623          	sw	a5,-20(s0)
	#if( INCLUDE_xTaskAbortDelay == 1 )
	{
		/* About to enter a delayed list, so ensure the ucDelayAborted flag is
		reset to pdFALSE so it can be detected as having been set to pdTRUE
		when the task leaves the Blocked state. */
		pxCurrentTCB->ucDelayAborted = pdFALSE;
c0006674:	07ffc797          	auipc	a5,0x7ffc
c0006678:	21878793          	addi	a5,a5,536 # c800288c <pxCurrentTCB>
c000667c:	0007a783          	lw	a5,0(a5)
c0006680:	060780a3          	sb	zero,97(a5)
	}
	#endif

	/* Remove the task from the ready list before adding it to the blocked list
	as the same list item is used for both lists. */
	if( uxListRemove( &( pxCurrentTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
c0006684:	07ffc797          	auipc	a5,0x7ffc
c0006688:	20878793          	addi	a5,a5,520 # c800288c <pxCurrentTCB>
c000668c:	0007a783          	lw	a5,0(a5)
c0006690:	00478793          	addi	a5,a5,4
c0006694:	00078513          	mv	a0,a5
c0006698:	a14fa0ef          	jal	ra,c00008ac <uxListRemove>
c000669c:	00050793          	mv	a5,a0
c00066a0:	02079e63          	bnez	a5,c00066dc <prvAddCurrentTaskToDelayedList+0x90>
	{
		/* The current task must be in a ready list, so there is no need to
		check, and the port reset macro can be called directly. */
		portRESET_READY_PRIORITY( pxCurrentTCB->uxPriority, uxTopReadyPriority ); /*lint !e931 pxCurrentTCB cannot change as it is the calling task.  pxCurrentTCB->uxPriority and uxTopReadyPriority cannot change as called with scheduler suspended or in a critical section. */
c00066a4:	07ffc797          	auipc	a5,0x7ffc
c00066a8:	1e878793          	addi	a5,a5,488 # c800288c <pxCurrentTCB>
c00066ac:	0007a783          	lw	a5,0(a5)
c00066b0:	02c7a783          	lw	a5,44(a5)
c00066b4:	00100713          	li	a4,1
c00066b8:	00f717b3          	sll	a5,a4,a5
c00066bc:	fff7c713          	not	a4,a5
c00066c0:	07ffd797          	auipc	a5,0x7ffd
c00066c4:	f6478793          	addi	a5,a5,-156 # c8003624 <uxTopReadyPriority>
c00066c8:	0007a783          	lw	a5,0(a5)
c00066cc:	00f77733          	and	a4,a4,a5
c00066d0:	07ffd797          	auipc	a5,0x7ffd
c00066d4:	f5478793          	addi	a5,a5,-172 # c8003624 <uxTopReadyPriority>
c00066d8:	00e7a023          	sw	a4,0(a5)
		mtCOVERAGE_TEST_MARKER();
	}

	#if ( INCLUDE_vTaskSuspend == 1 )
	{
		if( ( xTicksToWait == portMAX_DELAY ) && ( xCanBlockIndefinitely != pdFALSE ) )
c00066dc:	fdc42703          	lw	a4,-36(s0)
c00066e0:	fff00793          	li	a5,-1
c00066e4:	02f71863          	bne	a4,a5,c0006714 <prvAddCurrentTaskToDelayedList+0xc8>
c00066e8:	fd842783          	lw	a5,-40(s0)
c00066ec:	02078463          	beqz	a5,c0006714 <prvAddCurrentTaskToDelayedList+0xc8>
		{
			/* Add the task to the suspended task list instead of a delayed task
			list to ensure it is not woken by a timing event.  It will block
			indefinitely. */
			vListInsertEnd( &xSuspendedTaskList, &( pxCurrentTCB->xStateListItem ) );
c00066f0:	07ffc797          	auipc	a5,0x7ffc
c00066f4:	19c78793          	addi	a5,a5,412 # c800288c <pxCurrentTCB>
c00066f8:	0007a783          	lw	a5,0(a5)
c00066fc:	00478793          	addi	a5,a5,4
c0006700:	00078593          	mv	a1,a5
c0006704:	07ffd517          	auipc	a0,0x7ffd
c0006708:	f0450513          	addi	a0,a0,-252 # c8003608 <xSuspendedTaskList>
c000670c:	844fa0ef          	jal	ra,c0000750 <vListInsertEnd>

		/* Avoid compiler warning when INCLUDE_vTaskSuspend is not 1. */
		( void ) xCanBlockIndefinitely;
	}
	#endif /* INCLUDE_vTaskSuspend */
}
c0006710:	0ac0006f          	j	c00067bc <prvAddCurrentTaskToDelayedList+0x170>
			xTimeToWake = xConstTickCount + xTicksToWait;
c0006714:	fec42703          	lw	a4,-20(s0)
c0006718:	fdc42783          	lw	a5,-36(s0)
c000671c:	00f707b3          	add	a5,a4,a5
c0006720:	fef42423          	sw	a5,-24(s0)
			listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xStateListItem ), xTimeToWake );
c0006724:	07ffc797          	auipc	a5,0x7ffc
c0006728:	16878793          	addi	a5,a5,360 # c800288c <pxCurrentTCB>
c000672c:	0007a783          	lw	a5,0(a5)
c0006730:	fe842703          	lw	a4,-24(s0)
c0006734:	00e7a223          	sw	a4,4(a5)
			if( xTimeToWake < xConstTickCount )
c0006738:	fe842703          	lw	a4,-24(s0)
c000673c:	fec42783          	lw	a5,-20(s0)
c0006740:	02f77863          	bgeu	a4,a5,c0006770 <prvAddCurrentTaskToDelayedList+0x124>
				vListInsert( pxOverflowDelayedTaskList, &( pxCurrentTCB->xStateListItem ) );
c0006744:	07ffd797          	auipc	a5,0x7ffd
c0006748:	e9478793          	addi	a5,a5,-364 # c80035d8 <pxOverflowDelayedTaskList>
c000674c:	0007a703          	lw	a4,0(a5)
c0006750:	07ffc797          	auipc	a5,0x7ffc
c0006754:	13c78793          	addi	a5,a5,316 # c800288c <pxCurrentTCB>
c0006758:	0007a783          	lw	a5,0(a5)
c000675c:	00478793          	addi	a5,a5,4
c0006760:	00078593          	mv	a1,a5
c0006764:	00070513          	mv	a0,a4
c0006768:	870fa0ef          	jal	ra,c00007d8 <vListInsert>
}
c000676c:	0500006f          	j	c00067bc <prvAddCurrentTaskToDelayedList+0x170>
				vListInsert( pxDelayedTaskList, &( pxCurrentTCB->xStateListItem ) );
c0006770:	07ffd797          	auipc	a5,0x7ffd
c0006774:	e6478793          	addi	a5,a5,-412 # c80035d4 <pxDelayedTaskList>
c0006778:	0007a703          	lw	a4,0(a5)
c000677c:	07ffc797          	auipc	a5,0x7ffc
c0006780:	11078793          	addi	a5,a5,272 # c800288c <pxCurrentTCB>
c0006784:	0007a783          	lw	a5,0(a5)
c0006788:	00478793          	addi	a5,a5,4
c000678c:	00078593          	mv	a1,a5
c0006790:	00070513          	mv	a0,a4
c0006794:	844fa0ef          	jal	ra,c00007d8 <vListInsert>
				if( xTimeToWake < xNextTaskUnblockTime )
c0006798:	07ffd797          	auipc	a5,0x7ffd
c000679c:	ea478793          	addi	a5,a5,-348 # c800363c <xNextTaskUnblockTime>
c00067a0:	0007a783          	lw	a5,0(a5)
c00067a4:	fe842703          	lw	a4,-24(s0)
c00067a8:	00f77a63          	bgeu	a4,a5,c00067bc <prvAddCurrentTaskToDelayedList+0x170>
					xNextTaskUnblockTime = xTimeToWake;
c00067ac:	07ffd797          	auipc	a5,0x7ffd
c00067b0:	e9078793          	addi	a5,a5,-368 # c800363c <xNextTaskUnblockTime>
c00067b4:	fe842703          	lw	a4,-24(s0)
c00067b8:	00e7a023          	sw	a4,0(a5)
}
c00067bc:	00000013          	nop
c00067c0:	02c12083          	lw	ra,44(sp)
c00067c4:	02812403          	lw	s0,40(sp)
c00067c8:	03010113          	addi	sp,sp,48
c00067cc:	00008067          	ret

c00067d0 <xTimerCreateTimerTask>:
									TimerCallbackFunction_t pxCallbackFunction,
									Timer_t *pxNewTimer ) PRIVILEGED_FUNCTION;
/*-----------------------------------------------------------*/

BaseType_t xTimerCreateTimerTask( void )
{
c00067d0:	fe010113          	addi	sp,sp,-32
c00067d4:	00112e23          	sw	ra,28(sp)
c00067d8:	00812c23          	sw	s0,24(sp)
c00067dc:	02010413          	addi	s0,sp,32
BaseType_t xReturn = pdFAIL;
c00067e0:	fe042623          	sw	zero,-20(s0)

	/* This function is called when the scheduler is started if
	configUSE_TIMERS is set to 1.  Check that the infrastructure used by the
	timer service task has been created/initialised.  If timers have already
	been created then the initialisation will already have been performed. */
	prvCheckForValidListAndQueue();
c00067e4:	401000ef          	jal	ra,c00073e4 <prvCheckForValidListAndQueue>

	if( xTimerQueue != NULL )
c00067e8:	07ffd797          	auipc	a5,0x7ffd
c00067ec:	e9078793          	addi	a5,a5,-368 # c8003678 <xTimerQueue>
c00067f0:	0007a783          	lw	a5,0(a5)
c00067f4:	02078863          	beqz	a5,c0006824 <xTimerCreateTimerTask+0x54>
				xReturn = pdPASS;
			}
		}
		#else
		{
			xReturn = xTaskCreate(	prvTimerTask,
c00067f8:	07ffd797          	auipc	a5,0x7ffd
c00067fc:	e8478793          	addi	a5,a5,-380 # c800367c <xTimerTaskHandle>
c0006800:	00400713          	li	a4,4
c0006804:	00000693          	li	a3,0
c0006808:	20000613          	li	a2,512
c000680c:	07ffa597          	auipc	a1,0x7ffa
c0006810:	84858593          	addi	a1,a1,-1976 # c8000054 <__rodata_start+0x54>
c0006814:	00000517          	auipc	a0,0x0
c0006818:	51050513          	addi	a0,a0,1296 # c0006d24 <prvTimerTask>
c000681c:	e0dfb0ef          	jal	ra,c0002628 <xTaskCreate>
c0006820:	fea42623          	sw	a0,-20(s0)
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	configASSERT( xReturn );
c0006824:	fec42783          	lw	a5,-20(s0)
c0006828:	00079863          	bnez	a5,c0006838 <xTimerCreateTimerTask+0x68>
c000682c:	30047073          	csrci	mstatus,8
c0006830:	00100073          	ebreak
c0006834:	0000006f          	j	c0006834 <xTimerCreateTimerTask+0x64>
	return xReturn;
c0006838:	fec42783          	lw	a5,-20(s0)
}
c000683c:	00078513          	mv	a0,a5
c0006840:	01c12083          	lw	ra,28(sp)
c0006844:	01812403          	lw	s0,24(sp)
c0006848:	02010113          	addi	sp,sp,32
c000684c:	00008067          	ret

c0006850 <xTimerCreate>:
	TimerHandle_t xTimerCreate(	const char * const pcTimerName,			/*lint !e971 Unqualified char types are allowed for strings and single characters only. */
								const TickType_t xTimerPeriodInTicks,
								const UBaseType_t uxAutoReload,
								void * const pvTimerID,
								TimerCallbackFunction_t pxCallbackFunction )
	{
c0006850:	fc010113          	addi	sp,sp,-64
c0006854:	02112e23          	sw	ra,60(sp)
c0006858:	02812c23          	sw	s0,56(sp)
c000685c:	04010413          	addi	s0,sp,64
c0006860:	fca42e23          	sw	a0,-36(s0)
c0006864:	fcb42c23          	sw	a1,-40(s0)
c0006868:	fcc42a23          	sw	a2,-44(s0)
c000686c:	fcd42823          	sw	a3,-48(s0)
c0006870:	fce42623          	sw	a4,-52(s0)
	Timer_t *pxNewTimer;

		pxNewTimer = ( Timer_t * ) pvPortMalloc( sizeof( Timer_t ) ); /*lint !e9087 !e9079 All values returned by pvPortMalloc() have at least the alignment required by the MCU's stack, and the first member of Timer_t is always a pointer to the timer's mame. */
c0006874:	02c00513          	li	a0,44
c0006878:	23d020ef          	jal	ra,c00092b4 <pvPortMalloc>
c000687c:	fea42623          	sw	a0,-20(s0)

		if( pxNewTimer != NULL )
c0006880:	fec42783          	lw	a5,-20(s0)
c0006884:	02078463          	beqz	a5,c00068ac <xTimerCreate+0x5c>
		{
			/* Status is thus far zero as the timer is not created statically
			and has not been started.  The autoreload bit may get set in
			prvInitialiseNewTimer. */
			pxNewTimer->ucStatus = 0x00;
c0006888:	fec42783          	lw	a5,-20(s0)
c000688c:	02078423          	sb	zero,40(a5)
			prvInitialiseNewTimer( pcTimerName, xTimerPeriodInTicks, uxAutoReload, pvTimerID, pxCallbackFunction, pxNewTimer );
c0006890:	fec42783          	lw	a5,-20(s0)
c0006894:	fcc42703          	lw	a4,-52(s0)
c0006898:	fd042683          	lw	a3,-48(s0)
c000689c:	fd442603          	lw	a2,-44(s0)
c00068a0:	fd842583          	lw	a1,-40(s0)
c00068a4:	fdc42503          	lw	a0,-36(s0)
c00068a8:	01c000ef          	jal	ra,c00068c4 <prvInitialiseNewTimer>
		}

		return pxNewTimer;
c00068ac:	fec42783          	lw	a5,-20(s0)
	}
c00068b0:	00078513          	mv	a0,a5
c00068b4:	03c12083          	lw	ra,60(sp)
c00068b8:	03812403          	lw	s0,56(sp)
c00068bc:	04010113          	addi	sp,sp,64
c00068c0:	00008067          	ret

c00068c4 <prvInitialiseNewTimer>:
									const TickType_t xTimerPeriodInTicks,
									const UBaseType_t uxAutoReload,
									void * const pvTimerID,
									TimerCallbackFunction_t pxCallbackFunction,
									Timer_t *pxNewTimer )
{
c00068c4:	fd010113          	addi	sp,sp,-48
c00068c8:	02112623          	sw	ra,44(sp)
c00068cc:	02812423          	sw	s0,40(sp)
c00068d0:	03010413          	addi	s0,sp,48
c00068d4:	fea42623          	sw	a0,-20(s0)
c00068d8:	feb42423          	sw	a1,-24(s0)
c00068dc:	fec42223          	sw	a2,-28(s0)
c00068e0:	fed42023          	sw	a3,-32(s0)
c00068e4:	fce42e23          	sw	a4,-36(s0)
c00068e8:	fcf42c23          	sw	a5,-40(s0)
	/* 0 is not a valid value for xTimerPeriodInTicks. */
	configASSERT( ( xTimerPeriodInTicks > 0 ) );
c00068ec:	fe842783          	lw	a5,-24(s0)
c00068f0:	00079863          	bnez	a5,c0006900 <prvInitialiseNewTimer+0x3c>
c00068f4:	30047073          	csrci	mstatus,8
c00068f8:	00100073          	ebreak
c00068fc:	0000006f          	j	c00068fc <prvInitialiseNewTimer+0x38>

	if( pxNewTimer != NULL )
c0006900:	fd842783          	lw	a5,-40(s0)
c0006904:	06078463          	beqz	a5,c000696c <prvInitialiseNewTimer+0xa8>
	{
		/* Ensure the infrastructure used by the timer service task has been
		created/initialised. */
		prvCheckForValidListAndQueue();
c0006908:	2dd000ef          	jal	ra,c00073e4 <prvCheckForValidListAndQueue>

		/* Initialise the timer structure members using the function
		parameters. */
		pxNewTimer->pcTimerName = pcTimerName;
c000690c:	fd842783          	lw	a5,-40(s0)
c0006910:	fec42703          	lw	a4,-20(s0)
c0006914:	00e7a023          	sw	a4,0(a5)
		pxNewTimer->xTimerPeriodInTicks = xTimerPeriodInTicks;
c0006918:	fd842783          	lw	a5,-40(s0)
c000691c:	fe842703          	lw	a4,-24(s0)
c0006920:	00e7ac23          	sw	a4,24(a5)
		pxNewTimer->pvTimerID = pvTimerID;
c0006924:	fd842783          	lw	a5,-40(s0)
c0006928:	fe042703          	lw	a4,-32(s0)
c000692c:	00e7ae23          	sw	a4,28(a5)
		pxNewTimer->pxCallbackFunction = pxCallbackFunction;
c0006930:	fd842783          	lw	a5,-40(s0)
c0006934:	fdc42703          	lw	a4,-36(s0)
c0006938:	02e7a023          	sw	a4,32(a5)
		vListInitialiseItem( &( pxNewTimer->xTimerListItem ) );
c000693c:	fd842783          	lw	a5,-40(s0)
c0006940:	00478793          	addi	a5,a5,4
c0006944:	00078513          	mv	a0,a5
c0006948:	de1f90ef          	jal	ra,c0000728 <vListInitialiseItem>
		if( uxAutoReload != pdFALSE )
c000694c:	fe442783          	lw	a5,-28(s0)
c0006950:	00078e63          	beqz	a5,c000696c <prvInitialiseNewTimer+0xa8>
		{
			pxNewTimer->ucStatus |= tmrSTATUS_IS_AUTORELOAD;
c0006954:	fd842783          	lw	a5,-40(s0)
c0006958:	0287c783          	lbu	a5,40(a5)
c000695c:	0047e793          	ori	a5,a5,4
c0006960:	0ff7f713          	andi	a4,a5,255
c0006964:	fd842783          	lw	a5,-40(s0)
c0006968:	02e78423          	sb	a4,40(a5)
		}
		traceTIMER_CREATE( pxNewTimer );
	}
}
c000696c:	00000013          	nop
c0006970:	02c12083          	lw	ra,44(sp)
c0006974:	02812403          	lw	s0,40(sp)
c0006978:	03010113          	addi	sp,sp,48
c000697c:	00008067          	ret

c0006980 <xTimerGenericCommand>:
/*-----------------------------------------------------------*/

BaseType_t xTimerGenericCommand( TimerHandle_t xTimer, const BaseType_t xCommandID, const TickType_t xOptionalValue, BaseType_t * const pxHigherPriorityTaskWoken, const TickType_t xTicksToWait )
{
c0006980:	fb010113          	addi	sp,sp,-80
c0006984:	04112623          	sw	ra,76(sp)
c0006988:	04812423          	sw	s0,72(sp)
c000698c:	05010413          	addi	s0,sp,80
c0006990:	fca42623          	sw	a0,-52(s0)
c0006994:	fcb42423          	sw	a1,-56(s0)
c0006998:	fcc42223          	sw	a2,-60(s0)
c000699c:	fcd42023          	sw	a3,-64(s0)
c00069a0:	fae42e23          	sw	a4,-68(s0)
BaseType_t xReturn = pdFAIL;
c00069a4:	fe042623          	sw	zero,-20(s0)
DaemonTaskMessage_t xMessage;

	configASSERT( xTimer );
c00069a8:	fcc42783          	lw	a5,-52(s0)
c00069ac:	00079863          	bnez	a5,c00069bc <xTimerGenericCommand+0x3c>
c00069b0:	30047073          	csrci	mstatus,8
c00069b4:	00100073          	ebreak
c00069b8:	0000006f          	j	c00069b8 <xTimerGenericCommand+0x38>

	/* Send a message to the timer service task to perform a particular action
	on a particular timer definition. */
	if( xTimerQueue != NULL )
c00069bc:	07ffd797          	auipc	a5,0x7ffd
c00069c0:	cbc78793          	addi	a5,a5,-836 # c8003678 <xTimerQueue>
c00069c4:	0007a783          	lw	a5,0(a5)
c00069c8:	0a078c63          	beqz	a5,c0006a80 <xTimerGenericCommand+0x100>
	{
		/* Send a command to the timer service task to start the xTimer timer. */
		xMessage.xMessageID = xCommandID;
c00069cc:	fc842783          	lw	a5,-56(s0)
c00069d0:	fcf42e23          	sw	a5,-36(s0)
		xMessage.u.xTimerParameters.xMessageValue = xOptionalValue;
c00069d4:	fc442783          	lw	a5,-60(s0)
c00069d8:	fef42023          	sw	a5,-32(s0)
		xMessage.u.xTimerParameters.pxTimer = xTimer;
c00069dc:	fcc42783          	lw	a5,-52(s0)
c00069e0:	fef42223          	sw	a5,-28(s0)

		if( xCommandID < tmrFIRST_FROM_ISR_COMMAND )
c00069e4:	fc842703          	lw	a4,-56(s0)
c00069e8:	00500793          	li	a5,5
c00069ec:	06e7c663          	blt	a5,a4,c0006a58 <xTimerGenericCommand+0xd8>
		{
			if( xTaskGetSchedulerState() == taskSCHEDULER_RUNNING )
c00069f0:	9a5fe0ef          	jal	ra,c0005394 <xTaskGetSchedulerState>
c00069f4:	00050713          	mv	a4,a0
c00069f8:	00200793          	li	a5,2
c00069fc:	02f71863          	bne	a4,a5,c0006a2c <xTimerGenericCommand+0xac>
			{
				xReturn = xQueueSendToBack( xTimerQueue, &xMessage, xTicksToWait );
c0006a00:	07ffd797          	auipc	a5,0x7ffd
c0006a04:	c7878793          	addi	a5,a5,-904 # c8003678 <xTimerQueue>
c0006a08:	0007a783          	lw	a5,0(a5)
c0006a0c:	fdc40713          	addi	a4,s0,-36
c0006a10:	00000693          	li	a3,0
c0006a14:	fbc42603          	lw	a2,-68(s0)
c0006a18:	00070593          	mv	a1,a4
c0006a1c:	00078513          	mv	a0,a5
c0006a20:	cd4fa0ef          	jal	ra,c0000ef4 <xQueueGenericSend>
c0006a24:	fea42623          	sw	a0,-20(s0)
c0006a28:	0580006f          	j	c0006a80 <xTimerGenericCommand+0x100>
			}
			else
			{
				xReturn = xQueueSendToBack( xTimerQueue, &xMessage, tmrNO_DELAY );
c0006a2c:	07ffd797          	auipc	a5,0x7ffd
c0006a30:	c4c78793          	addi	a5,a5,-948 # c8003678 <xTimerQueue>
c0006a34:	0007a783          	lw	a5,0(a5)
c0006a38:	fdc40713          	addi	a4,s0,-36
c0006a3c:	00000693          	li	a3,0
c0006a40:	00000613          	li	a2,0
c0006a44:	00070593          	mv	a1,a4
c0006a48:	00078513          	mv	a0,a5
c0006a4c:	ca8fa0ef          	jal	ra,c0000ef4 <xQueueGenericSend>
c0006a50:	fea42623          	sw	a0,-20(s0)
c0006a54:	02c0006f          	j	c0006a80 <xTimerGenericCommand+0x100>
			}
		}
		else
		{
			xReturn = xQueueSendToBackFromISR( xTimerQueue, &xMessage, pxHigherPriorityTaskWoken );
c0006a58:	07ffd797          	auipc	a5,0x7ffd
c0006a5c:	c2078793          	addi	a5,a5,-992 # c8003678 <xTimerQueue>
c0006a60:	0007a783          	lw	a5,0(a5)
c0006a64:	fdc40713          	addi	a4,s0,-36
c0006a68:	00000693          	li	a3,0
c0006a6c:	fc042603          	lw	a2,-64(s0)
c0006a70:	00070593          	mv	a1,a4
c0006a74:	00078513          	mv	a0,a5
c0006a78:	ee4fa0ef          	jal	ra,c000115c <xQueueGenericSendFromISR>
c0006a7c:	fea42623          	sw	a0,-20(s0)
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	return xReturn;
c0006a80:	fec42783          	lw	a5,-20(s0)
}
c0006a84:	00078513          	mv	a0,a5
c0006a88:	04c12083          	lw	ra,76(sp)
c0006a8c:	04812403          	lw	s0,72(sp)
c0006a90:	05010113          	addi	sp,sp,80
c0006a94:	00008067          	ret

c0006a98 <xTimerGetTimerDaemonTaskHandle>:
/*-----------------------------------------------------------*/

TaskHandle_t xTimerGetTimerDaemonTaskHandle( void )
{
c0006a98:	ff010113          	addi	sp,sp,-16
c0006a9c:	00812623          	sw	s0,12(sp)
c0006aa0:	01010413          	addi	s0,sp,16
	/* If xTimerGetTimerDaemonTaskHandle() is called before the scheduler has been
	started, then xTimerTaskHandle will be NULL. */
	configASSERT( ( xTimerTaskHandle != NULL ) );
c0006aa4:	07ffd797          	auipc	a5,0x7ffd
c0006aa8:	bd878793          	addi	a5,a5,-1064 # c800367c <xTimerTaskHandle>
c0006aac:	0007a783          	lw	a5,0(a5)
c0006ab0:	00079863          	bnez	a5,c0006ac0 <xTimerGetTimerDaemonTaskHandle+0x28>
c0006ab4:	30047073          	csrci	mstatus,8
c0006ab8:	00100073          	ebreak
c0006abc:	0000006f          	j	c0006abc <xTimerGetTimerDaemonTaskHandle+0x24>
	return xTimerTaskHandle;
c0006ac0:	07ffd797          	auipc	a5,0x7ffd
c0006ac4:	bbc78793          	addi	a5,a5,-1092 # c800367c <xTimerTaskHandle>
c0006ac8:	0007a783          	lw	a5,0(a5)
}
c0006acc:	00078513          	mv	a0,a5
c0006ad0:	00c12403          	lw	s0,12(sp)
c0006ad4:	01010113          	addi	sp,sp,16
c0006ad8:	00008067          	ret

c0006adc <xTimerGetPeriod>:
/*-----------------------------------------------------------*/

TickType_t xTimerGetPeriod( TimerHandle_t xTimer )
{
c0006adc:	fd010113          	addi	sp,sp,-48
c0006ae0:	02812623          	sw	s0,44(sp)
c0006ae4:	03010413          	addi	s0,sp,48
c0006ae8:	fca42e23          	sw	a0,-36(s0)
Timer_t *pxTimer = xTimer;
c0006aec:	fdc42783          	lw	a5,-36(s0)
c0006af0:	fef42623          	sw	a5,-20(s0)

	configASSERT( xTimer );
c0006af4:	fdc42783          	lw	a5,-36(s0)
c0006af8:	00079863          	bnez	a5,c0006b08 <xTimerGetPeriod+0x2c>
c0006afc:	30047073          	csrci	mstatus,8
c0006b00:	00100073          	ebreak
c0006b04:	0000006f          	j	c0006b04 <xTimerGetPeriod+0x28>
	return pxTimer->xTimerPeriodInTicks;
c0006b08:	fec42783          	lw	a5,-20(s0)
c0006b0c:	0187a783          	lw	a5,24(a5)
}
c0006b10:	00078513          	mv	a0,a5
c0006b14:	02c12403          	lw	s0,44(sp)
c0006b18:	03010113          	addi	sp,sp,48
c0006b1c:	00008067          	ret

c0006b20 <vTimerSetReloadMode>:
/*-----------------------------------------------------------*/

void vTimerSetReloadMode( TimerHandle_t xTimer, const UBaseType_t uxAutoReload )
{
c0006b20:	fd010113          	addi	sp,sp,-48
c0006b24:	02112623          	sw	ra,44(sp)
c0006b28:	02812423          	sw	s0,40(sp)
c0006b2c:	03010413          	addi	s0,sp,48
c0006b30:	fca42e23          	sw	a0,-36(s0)
c0006b34:	fcb42c23          	sw	a1,-40(s0)
Timer_t * pxTimer =  xTimer;
c0006b38:	fdc42783          	lw	a5,-36(s0)
c0006b3c:	fef42623          	sw	a5,-20(s0)

	configASSERT( xTimer );
c0006b40:	fdc42783          	lw	a5,-36(s0)
c0006b44:	00079863          	bnez	a5,c0006b54 <vTimerSetReloadMode+0x34>
c0006b48:	30047073          	csrci	mstatus,8
c0006b4c:	00100073          	ebreak
c0006b50:	0000006f          	j	c0006b50 <vTimerSetReloadMode+0x30>
	taskENTER_CRITICAL();
c0006b54:	dedfe0ef          	jal	ra,c0005940 <vTaskEnterCritical>
	{
		if( uxAutoReload != pdFALSE )
c0006b58:	fd842783          	lw	a5,-40(s0)
c0006b5c:	02078063          	beqz	a5,c0006b7c <vTimerSetReloadMode+0x5c>
		{
			pxTimer->ucStatus |= tmrSTATUS_IS_AUTORELOAD;
c0006b60:	fec42783          	lw	a5,-20(s0)
c0006b64:	0287c783          	lbu	a5,40(a5)
c0006b68:	0047e793          	ori	a5,a5,4
c0006b6c:	0ff7f713          	andi	a4,a5,255
c0006b70:	fec42783          	lw	a5,-20(s0)
c0006b74:	02e78423          	sb	a4,40(a5)
c0006b78:	01c0006f          	j	c0006b94 <vTimerSetReloadMode+0x74>
		}
		else
		{
			pxTimer->ucStatus &= ~tmrSTATUS_IS_AUTORELOAD;
c0006b7c:	fec42783          	lw	a5,-20(s0)
c0006b80:	0287c783          	lbu	a5,40(a5)
c0006b84:	ffb7f793          	andi	a5,a5,-5
c0006b88:	0ff7f713          	andi	a4,a5,255
c0006b8c:	fec42783          	lw	a5,-20(s0)
c0006b90:	02e78423          	sb	a4,40(a5)
		}
	}
	taskEXIT_CRITICAL();
c0006b94:	e01fe0ef          	jal	ra,c0005994 <vTaskExitCritical>
}
c0006b98:	00000013          	nop
c0006b9c:	02c12083          	lw	ra,44(sp)
c0006ba0:	02812403          	lw	s0,40(sp)
c0006ba4:	03010113          	addi	sp,sp,48
c0006ba8:	00008067          	ret

c0006bac <xTimerGetExpiryTime>:
/*-----------------------------------------------------------*/

TickType_t xTimerGetExpiryTime( TimerHandle_t xTimer )
{
c0006bac:	fd010113          	addi	sp,sp,-48
c0006bb0:	02812623          	sw	s0,44(sp)
c0006bb4:	03010413          	addi	s0,sp,48
c0006bb8:	fca42e23          	sw	a0,-36(s0)
Timer_t * pxTimer =  xTimer;
c0006bbc:	fdc42783          	lw	a5,-36(s0)
c0006bc0:	fef42623          	sw	a5,-20(s0)
TickType_t xReturn;

	configASSERT( xTimer );
c0006bc4:	fdc42783          	lw	a5,-36(s0)
c0006bc8:	00079863          	bnez	a5,c0006bd8 <xTimerGetExpiryTime+0x2c>
c0006bcc:	30047073          	csrci	mstatus,8
c0006bd0:	00100073          	ebreak
c0006bd4:	0000006f          	j	c0006bd4 <xTimerGetExpiryTime+0x28>
	xReturn = listGET_LIST_ITEM_VALUE( &( pxTimer->xTimerListItem ) );
c0006bd8:	fec42783          	lw	a5,-20(s0)
c0006bdc:	0047a783          	lw	a5,4(a5)
c0006be0:	fef42423          	sw	a5,-24(s0)
	return xReturn;
c0006be4:	fe842783          	lw	a5,-24(s0)
}
c0006be8:	00078513          	mv	a0,a5
c0006bec:	02c12403          	lw	s0,44(sp)
c0006bf0:	03010113          	addi	sp,sp,48
c0006bf4:	00008067          	ret

c0006bf8 <pcTimerGetName>:
/*-----------------------------------------------------------*/

const char * pcTimerGetName( TimerHandle_t xTimer ) /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
{
c0006bf8:	fd010113          	addi	sp,sp,-48
c0006bfc:	02812623          	sw	s0,44(sp)
c0006c00:	03010413          	addi	s0,sp,48
c0006c04:	fca42e23          	sw	a0,-36(s0)
Timer_t *pxTimer = xTimer;
c0006c08:	fdc42783          	lw	a5,-36(s0)
c0006c0c:	fef42623          	sw	a5,-20(s0)

	configASSERT( xTimer );
c0006c10:	fdc42783          	lw	a5,-36(s0)
c0006c14:	00079863          	bnez	a5,c0006c24 <pcTimerGetName+0x2c>
c0006c18:	30047073          	csrci	mstatus,8
c0006c1c:	00100073          	ebreak
c0006c20:	0000006f          	j	c0006c20 <pcTimerGetName+0x28>
	return pxTimer->pcTimerName;
c0006c24:	fec42783          	lw	a5,-20(s0)
c0006c28:	0007a783          	lw	a5,0(a5)
}
c0006c2c:	00078513          	mv	a0,a5
c0006c30:	02c12403          	lw	s0,44(sp)
c0006c34:	03010113          	addi	sp,sp,48
c0006c38:	00008067          	ret

c0006c3c <prvProcessExpiredTimer>:
/*-----------------------------------------------------------*/

static void prvProcessExpiredTimer( const TickType_t xNextExpireTime, const TickType_t xTimeNow )
{
c0006c3c:	fd010113          	addi	sp,sp,-48
c0006c40:	02112623          	sw	ra,44(sp)
c0006c44:	02812423          	sw	s0,40(sp)
c0006c48:	03010413          	addi	s0,sp,48
c0006c4c:	fca42e23          	sw	a0,-36(s0)
c0006c50:	fcb42c23          	sw	a1,-40(s0)
BaseType_t xResult;
Timer_t * const pxTimer = ( Timer_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxCurrentTimerList ); /*lint !e9087 !e9079 void * is used as this macro is used with tasks and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
c0006c54:	07ffd797          	auipc	a5,0x7ffd
c0006c58:	a1c78793          	addi	a5,a5,-1508 # c8003670 <pxCurrentTimerList>
c0006c5c:	0007a783          	lw	a5,0(a5)
c0006c60:	00c7a783          	lw	a5,12(a5)
c0006c64:	00c7a783          	lw	a5,12(a5)
c0006c68:	fef42623          	sw	a5,-20(s0)

	/* Remove the timer from the list of active timers.  A check has already
	been performed to ensure the list is not empty. */
	( void ) uxListRemove( &( pxTimer->xTimerListItem ) );
c0006c6c:	fec42783          	lw	a5,-20(s0)
c0006c70:	00478793          	addi	a5,a5,4
c0006c74:	00078513          	mv	a0,a5
c0006c78:	c35f90ef          	jal	ra,c00008ac <uxListRemove>
	traceTIMER_EXPIRED( pxTimer );

	/* If the timer is an auto reload timer then calculate the next
	expiry time and re-insert the timer in the list of active timers. */
	if( ( pxTimer->ucStatus & tmrSTATUS_IS_AUTORELOAD ) != 0 )
c0006c7c:	fec42783          	lw	a5,-20(s0)
c0006c80:	0287c783          	lbu	a5,40(a5)
c0006c84:	0047f793          	andi	a5,a5,4
c0006c88:	06078063          	beqz	a5,c0006ce8 <prvProcessExpiredTimer+0xac>
	{
		/* The timer is inserted into a list using a time relative to anything
		other than the current time.  It will therefore be inserted into the
		correct list relative to the time this task thinks it is now. */
		if( prvInsertTimerInActiveList( pxTimer, ( xNextExpireTime + pxTimer->xTimerPeriodInTicks ), xTimeNow, xNextExpireTime ) != pdFALSE )
c0006c8c:	fec42783          	lw	a5,-20(s0)
c0006c90:	0187a703          	lw	a4,24(a5)
c0006c94:	fdc42783          	lw	a5,-36(s0)
c0006c98:	00f707b3          	add	a5,a4,a5
c0006c9c:	fdc42683          	lw	a3,-36(s0)
c0006ca0:	fd842603          	lw	a2,-40(s0)
c0006ca4:	00078593          	mv	a1,a5
c0006ca8:	fec42503          	lw	a0,-20(s0)
c0006cac:	27c000ef          	jal	ra,c0006f28 <prvInsertTimerInActiveList>
c0006cb0:	00050793          	mv	a5,a0
c0006cb4:	04078663          	beqz	a5,c0006d00 <prvProcessExpiredTimer+0xc4>
		{
			/* The timer expired before it was added to the active timer
			list.  Reload it now.  */
			xResult = xTimerGenericCommand( pxTimer, tmrCOMMAND_START_DONT_TRACE, xNextExpireTime, NULL, tmrNO_DELAY );
c0006cb8:	00000713          	li	a4,0
c0006cbc:	00000693          	li	a3,0
c0006cc0:	fdc42603          	lw	a2,-36(s0)
c0006cc4:	00000593          	li	a1,0
c0006cc8:	fec42503          	lw	a0,-20(s0)
c0006ccc:	cb5ff0ef          	jal	ra,c0006980 <xTimerGenericCommand>
c0006cd0:	fea42423          	sw	a0,-24(s0)
			configASSERT( xResult );
c0006cd4:	fe842783          	lw	a5,-24(s0)
c0006cd8:	02079463          	bnez	a5,c0006d00 <prvProcessExpiredTimer+0xc4>
c0006cdc:	30047073          	csrci	mstatus,8
c0006ce0:	00100073          	ebreak
c0006ce4:	0000006f          	j	c0006ce4 <prvProcessExpiredTimer+0xa8>
			mtCOVERAGE_TEST_MARKER();
		}
	}
	else
	{
		pxTimer->ucStatus &= ~tmrSTATUS_IS_ACTIVE;
c0006ce8:	fec42783          	lw	a5,-20(s0)
c0006cec:	0287c783          	lbu	a5,40(a5)
c0006cf0:	ffe7f793          	andi	a5,a5,-2
c0006cf4:	0ff7f713          	andi	a4,a5,255
c0006cf8:	fec42783          	lw	a5,-20(s0)
c0006cfc:	02e78423          	sb	a4,40(a5)
		mtCOVERAGE_TEST_MARKER();
	}

	/* Call the timer callback. */
	pxTimer->pxCallbackFunction( ( TimerHandle_t ) pxTimer );
c0006d00:	fec42783          	lw	a5,-20(s0)
c0006d04:	0207a783          	lw	a5,32(a5)
c0006d08:	fec42503          	lw	a0,-20(s0)
c0006d0c:	000780e7          	jalr	a5
}
c0006d10:	00000013          	nop
c0006d14:	02c12083          	lw	ra,44(sp)
c0006d18:	02812403          	lw	s0,40(sp)
c0006d1c:	03010113          	addi	sp,sp,48
c0006d20:	00008067          	ret

c0006d24 <prvTimerTask>:
/*-----------------------------------------------------------*/

static portTASK_FUNCTION( prvTimerTask, pvParameters )
{
c0006d24:	fd010113          	addi	sp,sp,-48
c0006d28:	02112623          	sw	ra,44(sp)
c0006d2c:	02812423          	sw	s0,40(sp)
c0006d30:	03010413          	addi	s0,sp,48
c0006d34:	fca42e23          	sw	a0,-36(s0)

	for( ;; )
	{
		/* Query the timers list to see if it contains any timers, and if so,
		obtain the time at which the next timer will expire. */
		xNextExpireTime = prvGetNextExpireTime( &xListWasEmpty );
c0006d38:	fe840793          	addi	a5,s0,-24
c0006d3c:	00078513          	mv	a0,a5
c0006d40:	0fc000ef          	jal	ra,c0006e3c <prvGetNextExpireTime>
c0006d44:	fea42623          	sw	a0,-20(s0)

		/* If a timer has expired, process it.  Otherwise, block this task
		until either a timer does expire, or a command is received. */
		prvProcessTimerOrBlockTask( xNextExpireTime, xListWasEmpty );
c0006d48:	fe842783          	lw	a5,-24(s0)
c0006d4c:	00078593          	mv	a1,a5
c0006d50:	fec42503          	lw	a0,-20(s0)
c0006d54:	00c000ef          	jal	ra,c0006d60 <prvProcessTimerOrBlockTask>

		/* Empty the command queue. */
		prvProcessReceivedCommands();
c0006d58:	2bc000ef          	jal	ra,c0007014 <prvProcessReceivedCommands>
		xNextExpireTime = prvGetNextExpireTime( &xListWasEmpty );
c0006d5c:	fddff06f          	j	c0006d38 <prvTimerTask+0x14>

c0006d60 <prvProcessTimerOrBlockTask>:
	}
}
/*-----------------------------------------------------------*/

static void prvProcessTimerOrBlockTask( const TickType_t xNextExpireTime, BaseType_t xListWasEmpty )
{
c0006d60:	fd010113          	addi	sp,sp,-48
c0006d64:	02112623          	sw	ra,44(sp)
c0006d68:	02812423          	sw	s0,40(sp)
c0006d6c:	03010413          	addi	s0,sp,48
c0006d70:	fca42e23          	sw	a0,-36(s0)
c0006d74:	fcb42c23          	sw	a1,-40(s0)
TickType_t xTimeNow;
BaseType_t xTimerListsWereSwitched;

	vTaskSuspendAll();
c0006d78:	9e5fc0ef          	jal	ra,c000375c <vTaskSuspendAll>
		/* Obtain the time now to make an assessment as to whether the timer
		has expired or not.  If obtaining the time causes the lists to switch
		then don't process this timer as any timers that remained in the list
		when the lists were switched will have been processed within the
		prvSampleTimeNow() function. */
		xTimeNow = prvSampleTimeNow( &xTimerListsWereSwitched );
c0006d7c:	fe840793          	addi	a5,s0,-24
c0006d80:	00078513          	mv	a0,a5
c0006d84:	130000ef          	jal	ra,c0006eb4 <prvSampleTimeNow>
c0006d88:	fea42623          	sw	a0,-20(s0)
		if( xTimerListsWereSwitched == pdFALSE )
c0006d8c:	fe842783          	lw	a5,-24(s0)
c0006d90:	08079a63          	bnez	a5,c0006e24 <prvProcessTimerOrBlockTask+0xc4>
		{
			/* The tick count has not overflowed, has the timer expired? */
			if( ( xListWasEmpty == pdFALSE ) && ( xNextExpireTime <= xTimeNow ) )
c0006d94:	fd842783          	lw	a5,-40(s0)
c0006d98:	02079263          	bnez	a5,c0006dbc <prvProcessTimerOrBlockTask+0x5c>
c0006d9c:	fdc42703          	lw	a4,-36(s0)
c0006da0:	fec42783          	lw	a5,-20(s0)
c0006da4:	00e7ec63          	bltu	a5,a4,c0006dbc <prvProcessTimerOrBlockTask+0x5c>
			{
				( void ) xTaskResumeAll();
c0006da8:	9edfc0ef          	jal	ra,c0003794 <xTaskResumeAll>
				prvProcessExpiredTimer( xNextExpireTime, xTimeNow );
c0006dac:	fec42583          	lw	a1,-20(s0)
c0006db0:	fdc42503          	lw	a0,-36(s0)
c0006db4:	e89ff0ef          	jal	ra,c0006c3c <prvProcessExpiredTimer>
		else
		{
			( void ) xTaskResumeAll();
		}
	}
}
c0006db8:	0700006f          	j	c0006e28 <prvProcessTimerOrBlockTask+0xc8>
				if( xListWasEmpty != pdFALSE )
c0006dbc:	fd842783          	lw	a5,-40(s0)
c0006dc0:	02078463          	beqz	a5,c0006de8 <prvProcessTimerOrBlockTask+0x88>
					xListWasEmpty = listLIST_IS_EMPTY( pxOverflowTimerList );
c0006dc4:	07ffd797          	auipc	a5,0x7ffd
c0006dc8:	8b078793          	addi	a5,a5,-1872 # c8003674 <pxOverflowTimerList>
c0006dcc:	0007a783          	lw	a5,0(a5)
c0006dd0:	0007a783          	lw	a5,0(a5)
c0006dd4:	00079663          	bnez	a5,c0006de0 <prvProcessTimerOrBlockTask+0x80>
c0006dd8:	00100793          	li	a5,1
c0006ddc:	0080006f          	j	c0006de4 <prvProcessTimerOrBlockTask+0x84>
c0006de0:	00000793          	li	a5,0
c0006de4:	fcf42c23          	sw	a5,-40(s0)
				vQueueWaitForMessageRestricted( xTimerQueue, ( xNextExpireTime - xTimeNow ), xListWasEmpty );
c0006de8:	07ffd797          	auipc	a5,0x7ffd
c0006dec:	89078793          	addi	a5,a5,-1904 # c8003678 <xTimerQueue>
c0006df0:	0007a683          	lw	a3,0(a5)
c0006df4:	fdc42703          	lw	a4,-36(s0)
c0006df8:	fec42783          	lw	a5,-20(s0)
c0006dfc:	40f707b3          	sub	a5,a4,a5
c0006e00:	fd842603          	lw	a2,-40(s0)
c0006e04:	00078593          	mv	a1,a5
c0006e08:	00068513          	mv	a0,a3
c0006e0c:	f70fb0ef          	jal	ra,c000257c <vQueueWaitForMessageRestricted>
				if( xTaskResumeAll() == pdFALSE )
c0006e10:	985fc0ef          	jal	ra,c0003794 <xTaskResumeAll>
c0006e14:	00050793          	mv	a5,a0
c0006e18:	00079863          	bnez	a5,c0006e28 <prvProcessTimerOrBlockTask+0xc8>
					portYIELD_WITHIN_API();
c0006e1c:	00000073          	ecall
}
c0006e20:	0080006f          	j	c0006e28 <prvProcessTimerOrBlockTask+0xc8>
			( void ) xTaskResumeAll();
c0006e24:	971fc0ef          	jal	ra,c0003794 <xTaskResumeAll>
}
c0006e28:	00000013          	nop
c0006e2c:	02c12083          	lw	ra,44(sp)
c0006e30:	02812403          	lw	s0,40(sp)
c0006e34:	03010113          	addi	sp,sp,48
c0006e38:	00008067          	ret

c0006e3c <prvGetNextExpireTime>:
/*-----------------------------------------------------------*/

static TickType_t prvGetNextExpireTime( BaseType_t * const pxListWasEmpty )
{
c0006e3c:	fd010113          	addi	sp,sp,-48
c0006e40:	02812623          	sw	s0,44(sp)
c0006e44:	03010413          	addi	s0,sp,48
c0006e48:	fca42e23          	sw	a0,-36(s0)
	the timer with the nearest expiry time will expire.  If there are no
	active timers then just set the next expire time to 0.  That will cause
	this task to unblock when the tick count overflows, at which point the
	timer lists will be switched and the next expiry time can be
	re-assessed.  */
	*pxListWasEmpty = listLIST_IS_EMPTY( pxCurrentTimerList );
c0006e4c:	07ffd797          	auipc	a5,0x7ffd
c0006e50:	82478793          	addi	a5,a5,-2012 # c8003670 <pxCurrentTimerList>
c0006e54:	0007a783          	lw	a5,0(a5)
c0006e58:	0007a783          	lw	a5,0(a5)
c0006e5c:	00079663          	bnez	a5,c0006e68 <prvGetNextExpireTime+0x2c>
c0006e60:	00100793          	li	a5,1
c0006e64:	0080006f          	j	c0006e6c <prvGetNextExpireTime+0x30>
c0006e68:	00000793          	li	a5,0
c0006e6c:	fdc42703          	lw	a4,-36(s0)
c0006e70:	00f72023          	sw	a5,0(a4)
	if( *pxListWasEmpty == pdFALSE )
c0006e74:	fdc42783          	lw	a5,-36(s0)
c0006e78:	0007a783          	lw	a5,0(a5)
c0006e7c:	02079063          	bnez	a5,c0006e9c <prvGetNextExpireTime+0x60>
	{
		xNextExpireTime = listGET_ITEM_VALUE_OF_HEAD_ENTRY( pxCurrentTimerList );
c0006e80:	07ffc797          	auipc	a5,0x7ffc
c0006e84:	7f078793          	addi	a5,a5,2032 # c8003670 <pxCurrentTimerList>
c0006e88:	0007a783          	lw	a5,0(a5)
c0006e8c:	00c7a783          	lw	a5,12(a5)
c0006e90:	0007a783          	lw	a5,0(a5)
c0006e94:	fef42623          	sw	a5,-20(s0)
c0006e98:	0080006f          	j	c0006ea0 <prvGetNextExpireTime+0x64>
	}
	else
	{
		/* Ensure the task unblocks when the tick count rolls over. */
		xNextExpireTime = ( TickType_t ) 0U;
c0006e9c:	fe042623          	sw	zero,-20(s0)
	}

	return xNextExpireTime;
c0006ea0:	fec42783          	lw	a5,-20(s0)
}
c0006ea4:	00078513          	mv	a0,a5
c0006ea8:	02c12403          	lw	s0,44(sp)
c0006eac:	03010113          	addi	sp,sp,48
c0006eb0:	00008067          	ret

c0006eb4 <prvSampleTimeNow>:
/*-----------------------------------------------------------*/

static TickType_t prvSampleTimeNow( BaseType_t * const pxTimerListsWereSwitched )
{
c0006eb4:	fd010113          	addi	sp,sp,-48
c0006eb8:	02112623          	sw	ra,44(sp)
c0006ebc:	02812423          	sw	s0,40(sp)
c0006ec0:	03010413          	addi	s0,sp,48
c0006ec4:	fca42e23          	sw	a0,-36(s0)
TickType_t xTimeNow;
PRIVILEGED_DATA static TickType_t xLastTime = ( TickType_t ) 0U; /*lint !e956 Variable is only accessible to one task. */

	xTimeNow = xTaskGetTickCount();
c0006ec8:	b65fc0ef          	jal	ra,c0003a2c <xTaskGetTickCount>
c0006ecc:	fea42623          	sw	a0,-20(s0)

	if( xTimeNow < xLastTime )
c0006ed0:	07ffc797          	auipc	a5,0x7ffc
c0006ed4:	7b078793          	addi	a5,a5,1968 # c8003680 <xLastTime.0>
c0006ed8:	0007a783          	lw	a5,0(a5)
c0006edc:	fec42703          	lw	a4,-20(s0)
c0006ee0:	00f77c63          	bgeu	a4,a5,c0006ef8 <prvSampleTimeNow+0x44>
	{
		prvSwitchTimerLists();
c0006ee4:	3a0000ef          	jal	ra,c0007284 <prvSwitchTimerLists>
		*pxTimerListsWereSwitched = pdTRUE;
c0006ee8:	fdc42783          	lw	a5,-36(s0)
c0006eec:	00100713          	li	a4,1
c0006ef0:	00e7a023          	sw	a4,0(a5)
c0006ef4:	00c0006f          	j	c0006f00 <prvSampleTimeNow+0x4c>
	}
	else
	{
		*pxTimerListsWereSwitched = pdFALSE;
c0006ef8:	fdc42783          	lw	a5,-36(s0)
c0006efc:	0007a023          	sw	zero,0(a5)
	}

	xLastTime = xTimeNow;
c0006f00:	07ffc797          	auipc	a5,0x7ffc
c0006f04:	78078793          	addi	a5,a5,1920 # c8003680 <xLastTime.0>
c0006f08:	fec42703          	lw	a4,-20(s0)
c0006f0c:	00e7a023          	sw	a4,0(a5)

	return xTimeNow;
c0006f10:	fec42783          	lw	a5,-20(s0)
}
c0006f14:	00078513          	mv	a0,a5
c0006f18:	02c12083          	lw	ra,44(sp)
c0006f1c:	02812403          	lw	s0,40(sp)
c0006f20:	03010113          	addi	sp,sp,48
c0006f24:	00008067          	ret

c0006f28 <prvInsertTimerInActiveList>:
/*-----------------------------------------------------------*/

static BaseType_t prvInsertTimerInActiveList( Timer_t * const pxTimer, const TickType_t xNextExpiryTime, const TickType_t xTimeNow, const TickType_t xCommandTime )
{
c0006f28:	fd010113          	addi	sp,sp,-48
c0006f2c:	02112623          	sw	ra,44(sp)
c0006f30:	02812423          	sw	s0,40(sp)
c0006f34:	03010413          	addi	s0,sp,48
c0006f38:	fca42e23          	sw	a0,-36(s0)
c0006f3c:	fcb42c23          	sw	a1,-40(s0)
c0006f40:	fcc42a23          	sw	a2,-44(s0)
c0006f44:	fcd42823          	sw	a3,-48(s0)
BaseType_t xProcessTimerNow = pdFALSE;
c0006f48:	fe042623          	sw	zero,-20(s0)

	listSET_LIST_ITEM_VALUE( &( pxTimer->xTimerListItem ), xNextExpiryTime );
c0006f4c:	fdc42783          	lw	a5,-36(s0)
c0006f50:	fd842703          	lw	a4,-40(s0)
c0006f54:	00e7a223          	sw	a4,4(a5)
	listSET_LIST_ITEM_OWNER( &( pxTimer->xTimerListItem ), pxTimer );
c0006f58:	fdc42783          	lw	a5,-36(s0)
c0006f5c:	fdc42703          	lw	a4,-36(s0)
c0006f60:	00e7a823          	sw	a4,16(a5)

	if( xNextExpiryTime <= xTimeNow )
c0006f64:	fd842703          	lw	a4,-40(s0)
c0006f68:	fd442783          	lw	a5,-44(s0)
c0006f6c:	04e7e663          	bltu	a5,a4,c0006fb8 <prvInsertTimerInActiveList+0x90>
	{
		/* Has the expiry time elapsed between the command to start/reset a
		timer was issued, and the time the command was processed? */
		if( ( ( TickType_t ) ( xTimeNow - xCommandTime ) ) >= pxTimer->xTimerPeriodInTicks ) /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
c0006f70:	fd442703          	lw	a4,-44(s0)
c0006f74:	fd042783          	lw	a5,-48(s0)
c0006f78:	40f70733          	sub	a4,a4,a5
c0006f7c:	fdc42783          	lw	a5,-36(s0)
c0006f80:	0187a783          	lw	a5,24(a5)
c0006f84:	00f76863          	bltu	a4,a5,c0006f94 <prvInsertTimerInActiveList+0x6c>
		{
			/* The time between a command being issued and the command being
			processed actually exceeds the timers period.  */
			xProcessTimerNow = pdTRUE;
c0006f88:	00100793          	li	a5,1
c0006f8c:	fef42623          	sw	a5,-20(s0)
c0006f90:	06c0006f          	j	c0006ffc <prvInsertTimerInActiveList+0xd4>
		}
		else
		{
			vListInsert( pxOverflowTimerList, &( pxTimer->xTimerListItem ) );
c0006f94:	07ffc797          	auipc	a5,0x7ffc
c0006f98:	6e078793          	addi	a5,a5,1760 # c8003674 <pxOverflowTimerList>
c0006f9c:	0007a703          	lw	a4,0(a5)
c0006fa0:	fdc42783          	lw	a5,-36(s0)
c0006fa4:	00478793          	addi	a5,a5,4
c0006fa8:	00078593          	mv	a1,a5
c0006fac:	00070513          	mv	a0,a4
c0006fb0:	829f90ef          	jal	ra,c00007d8 <vListInsert>
c0006fb4:	0480006f          	j	c0006ffc <prvInsertTimerInActiveList+0xd4>
		}
	}
	else
	{
		if( ( xTimeNow < xCommandTime ) && ( xNextExpiryTime >= xCommandTime ) )
c0006fb8:	fd442703          	lw	a4,-44(s0)
c0006fbc:	fd042783          	lw	a5,-48(s0)
c0006fc0:	00f77e63          	bgeu	a4,a5,c0006fdc <prvInsertTimerInActiveList+0xb4>
c0006fc4:	fd842703          	lw	a4,-40(s0)
c0006fc8:	fd042783          	lw	a5,-48(s0)
c0006fcc:	00f76863          	bltu	a4,a5,c0006fdc <prvInsertTimerInActiveList+0xb4>
		{
			/* If, since the command was issued, the tick count has overflowed
			but the expiry time has not, then the timer must have already passed
			its expiry time and should be processed immediately. */
			xProcessTimerNow = pdTRUE;
c0006fd0:	00100793          	li	a5,1
c0006fd4:	fef42623          	sw	a5,-20(s0)
c0006fd8:	0240006f          	j	c0006ffc <prvInsertTimerInActiveList+0xd4>
		}
		else
		{
			vListInsert( pxCurrentTimerList, &( pxTimer->xTimerListItem ) );
c0006fdc:	07ffc797          	auipc	a5,0x7ffc
c0006fe0:	69478793          	addi	a5,a5,1684 # c8003670 <pxCurrentTimerList>
c0006fe4:	0007a703          	lw	a4,0(a5)
c0006fe8:	fdc42783          	lw	a5,-36(s0)
c0006fec:	00478793          	addi	a5,a5,4
c0006ff0:	00078593          	mv	a1,a5
c0006ff4:	00070513          	mv	a0,a4
c0006ff8:	fe0f90ef          	jal	ra,c00007d8 <vListInsert>
		}
	}

	return xProcessTimerNow;
c0006ffc:	fec42783          	lw	a5,-20(s0)
}
c0007000:	00078513          	mv	a0,a5
c0007004:	02c12083          	lw	ra,44(sp)
c0007008:	02812403          	lw	s0,40(sp)
c000700c:	03010113          	addi	sp,sp,48
c0007010:	00008067          	ret

c0007014 <prvProcessReceivedCommands>:
/*-----------------------------------------------------------*/

static void	prvProcessReceivedCommands( void )
{
c0007014:	fc010113          	addi	sp,sp,-64
c0007018:	02112e23          	sw	ra,60(sp)
c000701c:	02812c23          	sw	s0,56(sp)
c0007020:	04010413          	addi	s0,sp,64
DaemonTaskMessage_t xMessage;
Timer_t *pxTimer;
BaseType_t xTimerListsWereSwitched, xResult;
TickType_t xTimeNow;

	while( xQueueReceive( xTimerQueue, &xMessage, tmrNO_DELAY ) != pdFAIL ) /*lint !e603 xMessage does not have to be initialised as it is passed out, not in, and it is not used unless xQueueReceive() returns pdTRUE. */
c0007024:	2200006f          	j	c0007244 <prvProcessReceivedCommands+0x230>
	{
		#if ( INCLUDE_xTimerPendFunctionCall == 1 )
		{
			/* Negative commands are pended function calls rather than timer
			commands. */
			if( xMessage.xMessageID < ( BaseType_t ) 0 )
c0007028:	fd042783          	lw	a5,-48(s0)
c000702c:	0407d463          	bgez	a5,c0007074 <prvProcessReceivedCommands+0x60>
			{
				const CallbackParameters_t * const pxCallback = &( xMessage.u.xCallbackParameters );
c0007030:	fd040793          	addi	a5,s0,-48
c0007034:	00478793          	addi	a5,a5,4
c0007038:	fef42623          	sw	a5,-20(s0)

				/* The timer uses the xCallbackParameters member to request a
				callback be executed.  Check the callback is not NULL. */
				configASSERT( pxCallback );
c000703c:	fec42783          	lw	a5,-20(s0)
c0007040:	00079863          	bnez	a5,c0007050 <prvProcessReceivedCommands+0x3c>
c0007044:	30047073          	csrci	mstatus,8
c0007048:	00100073          	ebreak
c000704c:	0000006f          	j	c000704c <prvProcessReceivedCommands+0x38>

				/* Call the function. */
				pxCallback->pxCallbackFunction( pxCallback->pvParameter1, pxCallback->ulParameter2 );
c0007050:	fec42783          	lw	a5,-20(s0)
c0007054:	0007a683          	lw	a3,0(a5)
c0007058:	fec42783          	lw	a5,-20(s0)
c000705c:	0047a703          	lw	a4,4(a5)
c0007060:	fec42783          	lw	a5,-20(s0)
c0007064:	0087a783          	lw	a5,8(a5)
c0007068:	00078593          	mv	a1,a5
c000706c:	00070513          	mv	a0,a4
c0007070:	000680e7          	jalr	a3
		}
		#endif /* INCLUDE_xTimerPendFunctionCall */

		/* Commands that are positive are timer commands rather than pended
		function calls. */
		if( xMessage.xMessageID >= ( BaseType_t ) 0 )
c0007074:	fd042783          	lw	a5,-48(s0)
c0007078:	1c07c463          	bltz	a5,c0007240 <prvProcessReceivedCommands+0x22c>
		{
			/* The messages uses the xTimerParameters member to work on a
			software timer. */
			pxTimer = xMessage.u.xTimerParameters.pxTimer;
c000707c:	fd842783          	lw	a5,-40(s0)
c0007080:	fef42423          	sw	a5,-24(s0)

			if( listIS_CONTAINED_WITHIN( NULL, &( pxTimer->xTimerListItem ) ) == pdFALSE ) /*lint !e961. The cast is only redundant when NULL is passed into the macro. */
c0007084:	fe842783          	lw	a5,-24(s0)
c0007088:	0147a783          	lw	a5,20(a5)
c000708c:	00078a63          	beqz	a5,c00070a0 <prvProcessReceivedCommands+0x8c>
			{
				/* The timer is in a list, remove it. */
				( void ) uxListRemove( &( pxTimer->xTimerListItem ) );
c0007090:	fe842783          	lw	a5,-24(s0)
c0007094:	00478793          	addi	a5,a5,4
c0007098:	00078513          	mv	a0,a5
c000709c:	811f90ef          	jal	ra,c00008ac <uxListRemove>
			it must be present in the function call.  prvSampleTimeNow() must be
			called after the message is received from xTimerQueue so there is no
			possibility of a higher priority task adding a message to the message
			queue with a time that is ahead of the timer daemon task (because it
			pre-empted the timer daemon task after the xTimeNow value was set). */
			xTimeNow = prvSampleTimeNow( &xTimerListsWereSwitched );
c00070a0:	fcc40793          	addi	a5,s0,-52
c00070a4:	00078513          	mv	a0,a5
c00070a8:	e0dff0ef          	jal	ra,c0006eb4 <prvSampleTimeNow>
c00070ac:	fea42223          	sw	a0,-28(s0)

			switch( xMessage.xMessageID )
c00070b0:	fd042783          	lw	a5,-48(s0)
c00070b4:	00900713          	li	a4,9
c00070b8:	18f76663          	bltu	a4,a5,c0007244 <prvProcessReceivedCommands+0x230>
c00070bc:	00279713          	slli	a4,a5,0x2
c00070c0:	07ff9797          	auipc	a5,0x7ff9
c00070c4:	f9c78793          	addi	a5,a5,-100 # c800005c <__rodata_start+0x5c>
c00070c8:	00f707b3          	add	a5,a4,a5
c00070cc:	0007a703          	lw	a4,0(a5)
c00070d0:	07ff9797          	auipc	a5,0x7ff9
c00070d4:	f8c78793          	addi	a5,a5,-116 # c800005c <__rodata_start+0x5c>
c00070d8:	00f707b3          	add	a5,a4,a5
c00070dc:	00078067          	jr	a5
				case tmrCOMMAND_START_FROM_ISR :
				case tmrCOMMAND_RESET :
				case tmrCOMMAND_RESET_FROM_ISR :
				case tmrCOMMAND_START_DONT_TRACE :
					/* Start or restart a timer. */
					pxTimer->ucStatus |= tmrSTATUS_IS_ACTIVE;
c00070e0:	fe842783          	lw	a5,-24(s0)
c00070e4:	0287c783          	lbu	a5,40(a5)
c00070e8:	0017e793          	ori	a5,a5,1
c00070ec:	0ff7f713          	andi	a4,a5,255
c00070f0:	fe842783          	lw	a5,-24(s0)
c00070f4:	02e78423          	sb	a4,40(a5)
					if( prvInsertTimerInActiveList( pxTimer,  xMessage.u.xTimerParameters.xMessageValue + pxTimer->xTimerPeriodInTicks, xTimeNow, xMessage.u.xTimerParameters.xMessageValue ) != pdFALSE )
c00070f8:	fd442703          	lw	a4,-44(s0)
c00070fc:	fe842783          	lw	a5,-24(s0)
c0007100:	0187a783          	lw	a5,24(a5)
c0007104:	00f707b3          	add	a5,a4,a5
c0007108:	fd442703          	lw	a4,-44(s0)
c000710c:	00070693          	mv	a3,a4
c0007110:	fe442603          	lw	a2,-28(s0)
c0007114:	00078593          	mv	a1,a5
c0007118:	fe842503          	lw	a0,-24(s0)
c000711c:	e0dff0ef          	jal	ra,c0006f28 <prvInsertTimerInActiveList>
c0007120:	00050793          	mv	a5,a0
c0007124:	12078063          	beqz	a5,c0007244 <prvProcessReceivedCommands+0x230>
					{
						/* The timer expired before it was added to the active
						timer list.  Process it now. */
						pxTimer->pxCallbackFunction( ( TimerHandle_t ) pxTimer );
c0007128:	fe842783          	lw	a5,-24(s0)
c000712c:	0207a783          	lw	a5,32(a5)
c0007130:	fe842503          	lw	a0,-24(s0)
c0007134:	000780e7          	jalr	a5
						traceTIMER_EXPIRED( pxTimer );

						if( ( pxTimer->ucStatus & tmrSTATUS_IS_AUTORELOAD ) != 0 )
c0007138:	fe842783          	lw	a5,-24(s0)
c000713c:	0287c783          	lbu	a5,40(a5)
c0007140:	0047f793          	andi	a5,a5,4
c0007144:	10078063          	beqz	a5,c0007244 <prvProcessReceivedCommands+0x230>
						{
							xResult = xTimerGenericCommand( pxTimer, tmrCOMMAND_START_DONT_TRACE, xMessage.u.xTimerParameters.xMessageValue + pxTimer->xTimerPeriodInTicks, NULL, tmrNO_DELAY );
c0007148:	fd442703          	lw	a4,-44(s0)
c000714c:	fe842783          	lw	a5,-24(s0)
c0007150:	0187a783          	lw	a5,24(a5)
c0007154:	00f707b3          	add	a5,a4,a5
c0007158:	00000713          	li	a4,0
c000715c:	00000693          	li	a3,0
c0007160:	00078613          	mv	a2,a5
c0007164:	00000593          	li	a1,0
c0007168:	fe842503          	lw	a0,-24(s0)
c000716c:	815ff0ef          	jal	ra,c0006980 <xTimerGenericCommand>
c0007170:	fea42023          	sw	a0,-32(s0)
							configASSERT( xResult );
c0007174:	fe042783          	lw	a5,-32(s0)
c0007178:	0c079663          	bnez	a5,c0007244 <prvProcessReceivedCommands+0x230>
c000717c:	30047073          	csrci	mstatus,8
c0007180:	00100073          	ebreak
c0007184:	0000006f          	j	c0007184 <prvProcessReceivedCommands+0x170>
					break;

				case tmrCOMMAND_STOP :
				case tmrCOMMAND_STOP_FROM_ISR :
					/* The timer has already been removed from the active list. */
					pxTimer->ucStatus &= ~tmrSTATUS_IS_ACTIVE;
c0007188:	fe842783          	lw	a5,-24(s0)
c000718c:	0287c783          	lbu	a5,40(a5)
c0007190:	ffe7f793          	andi	a5,a5,-2
c0007194:	0ff7f713          	andi	a4,a5,255
c0007198:	fe842783          	lw	a5,-24(s0)
c000719c:	02e78423          	sb	a4,40(a5)
					break;
c00071a0:	0a40006f          	j	c0007244 <prvProcessReceivedCommands+0x230>

				case tmrCOMMAND_CHANGE_PERIOD :
				case tmrCOMMAND_CHANGE_PERIOD_FROM_ISR :
					pxTimer->ucStatus |= tmrSTATUS_IS_ACTIVE;
c00071a4:	fe842783          	lw	a5,-24(s0)
c00071a8:	0287c783          	lbu	a5,40(a5)
c00071ac:	0017e793          	ori	a5,a5,1
c00071b0:	0ff7f713          	andi	a4,a5,255
c00071b4:	fe842783          	lw	a5,-24(s0)
c00071b8:	02e78423          	sb	a4,40(a5)
					pxTimer->xTimerPeriodInTicks = xMessage.u.xTimerParameters.xMessageValue;
c00071bc:	fd442703          	lw	a4,-44(s0)
c00071c0:	fe842783          	lw	a5,-24(s0)
c00071c4:	00e7ac23          	sw	a4,24(a5)
					configASSERT( ( pxTimer->xTimerPeriodInTicks > 0 ) );
c00071c8:	fe842783          	lw	a5,-24(s0)
c00071cc:	0187a783          	lw	a5,24(a5)
c00071d0:	00079863          	bnez	a5,c00071e0 <prvProcessReceivedCommands+0x1cc>
c00071d4:	30047073          	csrci	mstatus,8
c00071d8:	00100073          	ebreak
c00071dc:	0000006f          	j	c00071dc <prvProcessReceivedCommands+0x1c8>
					be longer or shorter than the old one.  The command time is
					therefore set to the current time, and as the period cannot
					be zero the next expiry time can only be in the future,
					meaning (unlike for the xTimerStart() case above) there is
					no fail case that needs to be handled here. */
					( void ) prvInsertTimerInActiveList( pxTimer, ( xTimeNow + pxTimer->xTimerPeriodInTicks ), xTimeNow, xTimeNow );
c00071e0:	fe842783          	lw	a5,-24(s0)
c00071e4:	0187a703          	lw	a4,24(a5)
c00071e8:	fe442783          	lw	a5,-28(s0)
c00071ec:	00f707b3          	add	a5,a4,a5
c00071f0:	fe442683          	lw	a3,-28(s0)
c00071f4:	fe442603          	lw	a2,-28(s0)
c00071f8:	00078593          	mv	a1,a5
c00071fc:	fe842503          	lw	a0,-24(s0)
c0007200:	d29ff0ef          	jal	ra,c0006f28 <prvInsertTimerInActiveList>
					break;
c0007204:	0400006f          	j	c0007244 <prvProcessReceivedCommands+0x230>
					#if ( configSUPPORT_DYNAMIC_ALLOCATION == 1 )
					{
						/* The timer has already been removed from the active list,
						just free up the memory if the memory was dynamically
						allocated. */
						if( ( pxTimer->ucStatus & tmrSTATUS_IS_STATICALLY_ALLOCATED ) == ( uint8_t ) 0 )
c0007208:	fe842783          	lw	a5,-24(s0)
c000720c:	0287c783          	lbu	a5,40(a5)
c0007210:	0027f793          	andi	a5,a5,2
c0007214:	00079863          	bnez	a5,c0007224 <prvProcessReceivedCommands+0x210>
						{
							vPortFree( pxTimer );
c0007218:	fe842503          	lw	a0,-24(s0)
c000721c:	31c020ef          	jal	ra,c0009538 <vPortFree>
c0007220:	0240006f          	j	c0007244 <prvProcessReceivedCommands+0x230>
						}
						else
						{
							pxTimer->ucStatus &= ~tmrSTATUS_IS_ACTIVE;
c0007224:	fe842783          	lw	a5,-24(s0)
c0007228:	0287c783          	lbu	a5,40(a5)
c000722c:	ffe7f793          	andi	a5,a5,-2
c0007230:	0ff7f713          	andi	a4,a5,255
c0007234:	fe842783          	lw	a5,-24(s0)
c0007238:	02e78423          	sb	a4,40(a5)
						no need to free the memory - just mark the timer as
						"not active". */
						pxTimer->ucStatus &= ~tmrSTATUS_IS_ACTIVE;
					}
					#endif /* configSUPPORT_DYNAMIC_ALLOCATION */
					break;
c000723c:	0080006f          	j	c0007244 <prvProcessReceivedCommands+0x230>

				default	:
					/* Don't expect to get here. */
					break;
			}
		}
c0007240:	00000013          	nop
	while( xQueueReceive( xTimerQueue, &xMessage, tmrNO_DELAY ) != pdFAIL ) /*lint !e603 xMessage does not have to be initialised as it is passed out, not in, and it is not used unless xQueueReceive() returns pdTRUE. */
c0007244:	07ffc797          	auipc	a5,0x7ffc
c0007248:	43478793          	addi	a5,a5,1076 # c8003678 <xTimerQueue>
c000724c:	0007a783          	lw	a5,0(a5)
c0007250:	fd040713          	addi	a4,s0,-48
c0007254:	00000613          	li	a2,0
c0007258:	00070593          	mv	a1,a4
c000725c:	00078513          	mv	a0,a5
c0007260:	9b4fa0ef          	jal	ra,c0001414 <xQueueReceive>
c0007264:	00050793          	mv	a5,a0
c0007268:	dc0790e3          	bnez	a5,c0007028 <prvProcessReceivedCommands+0x14>
	}
}
c000726c:	00000013          	nop
c0007270:	00000013          	nop
c0007274:	03c12083          	lw	ra,60(sp)
c0007278:	03812403          	lw	s0,56(sp)
c000727c:	04010113          	addi	sp,sp,64
c0007280:	00008067          	ret

c0007284 <prvSwitchTimerLists>:
/*-----------------------------------------------------------*/

static void prvSwitchTimerLists( void )
{
c0007284:	fd010113          	addi	sp,sp,-48
c0007288:	02112623          	sw	ra,44(sp)
c000728c:	02812423          	sw	s0,40(sp)
c0007290:	03010413          	addi	s0,sp,48

	/* The tick count has overflowed.  The timer lists must be switched.
	If there are any timers still referenced from the current timer list
	then they must have expired and should be processed before the lists
	are switched. */
	while( listLIST_IS_EMPTY( pxCurrentTimerList ) == pdFALSE )
c0007294:	0f00006f          	j	c0007384 <prvSwitchTimerLists+0x100>
	{
		xNextExpireTime = listGET_ITEM_VALUE_OF_HEAD_ENTRY( pxCurrentTimerList );
c0007298:	07ffc797          	auipc	a5,0x7ffc
c000729c:	3d878793          	addi	a5,a5,984 # c8003670 <pxCurrentTimerList>
c00072a0:	0007a783          	lw	a5,0(a5)
c00072a4:	00c7a783          	lw	a5,12(a5)
c00072a8:	0007a783          	lw	a5,0(a5)
c00072ac:	fef42423          	sw	a5,-24(s0)

		/* Remove the timer from the list. */
		pxTimer = ( Timer_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxCurrentTimerList ); /*lint !e9087 !e9079 void * is used as this macro is used with tasks and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
c00072b0:	07ffc797          	auipc	a5,0x7ffc
c00072b4:	3c078793          	addi	a5,a5,960 # c8003670 <pxCurrentTimerList>
c00072b8:	0007a783          	lw	a5,0(a5)
c00072bc:	00c7a783          	lw	a5,12(a5)
c00072c0:	00c7a783          	lw	a5,12(a5)
c00072c4:	fef42223          	sw	a5,-28(s0)
		( void ) uxListRemove( &( pxTimer->xTimerListItem ) );
c00072c8:	fe442783          	lw	a5,-28(s0)
c00072cc:	00478793          	addi	a5,a5,4
c00072d0:	00078513          	mv	a0,a5
c00072d4:	dd8f90ef          	jal	ra,c00008ac <uxListRemove>
		traceTIMER_EXPIRED( pxTimer );

		/* Execute its callback, then send a command to restart the timer if
		it is an auto-reload timer.  It cannot be restarted here as the lists
		have not yet been switched. */
		pxTimer->pxCallbackFunction( ( TimerHandle_t ) pxTimer );
c00072d8:	fe442783          	lw	a5,-28(s0)
c00072dc:	0207a783          	lw	a5,32(a5)
c00072e0:	fe442503          	lw	a0,-28(s0)
c00072e4:	000780e7          	jalr	a5

		if( ( pxTimer->ucStatus & tmrSTATUS_IS_AUTORELOAD ) != 0 )
c00072e8:	fe442783          	lw	a5,-28(s0)
c00072ec:	0287c783          	lbu	a5,40(a5)
c00072f0:	0047f793          	andi	a5,a5,4
c00072f4:	08078863          	beqz	a5,c0007384 <prvSwitchTimerLists+0x100>
			the timer going into the same timer list then it has already expired
			and the timer should be re-inserted into the current list so it is
			processed again within this loop.  Otherwise a command should be sent
			to restart the timer to ensure it is only inserted into a list after
			the lists have been swapped. */
			xReloadTime = ( xNextExpireTime + pxTimer->xTimerPeriodInTicks );
c00072f8:	fe442783          	lw	a5,-28(s0)
c00072fc:	0187a783          	lw	a5,24(a5)
c0007300:	fe842703          	lw	a4,-24(s0)
c0007304:	00f707b3          	add	a5,a4,a5
c0007308:	fef42023          	sw	a5,-32(s0)
			if( xReloadTime > xNextExpireTime )
c000730c:	fe042703          	lw	a4,-32(s0)
c0007310:	fe842783          	lw	a5,-24(s0)
c0007314:	04e7f063          	bgeu	a5,a4,c0007354 <prvSwitchTimerLists+0xd0>
			{
				listSET_LIST_ITEM_VALUE( &( pxTimer->xTimerListItem ), xReloadTime );
c0007318:	fe442783          	lw	a5,-28(s0)
c000731c:	fe042703          	lw	a4,-32(s0)
c0007320:	00e7a223          	sw	a4,4(a5)
				listSET_LIST_ITEM_OWNER( &( pxTimer->xTimerListItem ), pxTimer );
c0007324:	fe442783          	lw	a5,-28(s0)
c0007328:	fe442703          	lw	a4,-28(s0)
c000732c:	00e7a823          	sw	a4,16(a5)
				vListInsert( pxCurrentTimerList, &( pxTimer->xTimerListItem ) );
c0007330:	07ffc797          	auipc	a5,0x7ffc
c0007334:	34078793          	addi	a5,a5,832 # c8003670 <pxCurrentTimerList>
c0007338:	0007a703          	lw	a4,0(a5)
c000733c:	fe442783          	lw	a5,-28(s0)
c0007340:	00478793          	addi	a5,a5,4
c0007344:	00078593          	mv	a1,a5
c0007348:	00070513          	mv	a0,a4
c000734c:	c8cf90ef          	jal	ra,c00007d8 <vListInsert>
c0007350:	0340006f          	j	c0007384 <prvSwitchTimerLists+0x100>
			}
			else
			{
				xResult = xTimerGenericCommand( pxTimer, tmrCOMMAND_START_DONT_TRACE, xNextExpireTime, NULL, tmrNO_DELAY );
c0007354:	00000713          	li	a4,0
c0007358:	00000693          	li	a3,0
c000735c:	fe842603          	lw	a2,-24(s0)
c0007360:	00000593          	li	a1,0
c0007364:	fe442503          	lw	a0,-28(s0)
c0007368:	e18ff0ef          	jal	ra,c0006980 <xTimerGenericCommand>
c000736c:	fca42e23          	sw	a0,-36(s0)
				configASSERT( xResult );
c0007370:	fdc42783          	lw	a5,-36(s0)
c0007374:	00079863          	bnez	a5,c0007384 <prvSwitchTimerLists+0x100>
c0007378:	30047073          	csrci	mstatus,8
c000737c:	00100073          	ebreak
c0007380:	0000006f          	j	c0007380 <prvSwitchTimerLists+0xfc>
	while( listLIST_IS_EMPTY( pxCurrentTimerList ) == pdFALSE )
c0007384:	07ffc797          	auipc	a5,0x7ffc
c0007388:	2ec78793          	addi	a5,a5,748 # c8003670 <pxCurrentTimerList>
c000738c:	0007a783          	lw	a5,0(a5)
c0007390:	0007a783          	lw	a5,0(a5)
c0007394:	f00792e3          	bnez	a5,c0007298 <prvSwitchTimerLists+0x14>
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}

	pxTemp = pxCurrentTimerList;
c0007398:	07ffc797          	auipc	a5,0x7ffc
c000739c:	2d878793          	addi	a5,a5,728 # c8003670 <pxCurrentTimerList>
c00073a0:	0007a783          	lw	a5,0(a5)
c00073a4:	fef42623          	sw	a5,-20(s0)
	pxCurrentTimerList = pxOverflowTimerList;
c00073a8:	07ffc797          	auipc	a5,0x7ffc
c00073ac:	2cc78793          	addi	a5,a5,716 # c8003674 <pxOverflowTimerList>
c00073b0:	0007a703          	lw	a4,0(a5)
c00073b4:	07ffc797          	auipc	a5,0x7ffc
c00073b8:	2bc78793          	addi	a5,a5,700 # c8003670 <pxCurrentTimerList>
c00073bc:	00e7a023          	sw	a4,0(a5)
	pxOverflowTimerList = pxTemp;
c00073c0:	07ffc797          	auipc	a5,0x7ffc
c00073c4:	2b478793          	addi	a5,a5,692 # c8003674 <pxOverflowTimerList>
c00073c8:	fec42703          	lw	a4,-20(s0)
c00073cc:	00e7a023          	sw	a4,0(a5)
}
c00073d0:	00000013          	nop
c00073d4:	02c12083          	lw	ra,44(sp)
c00073d8:	02812403          	lw	s0,40(sp)
c00073dc:	03010113          	addi	sp,sp,48
c00073e0:	00008067          	ret

c00073e4 <prvCheckForValidListAndQueue>:
/*-----------------------------------------------------------*/

static void prvCheckForValidListAndQueue( void )
{
c00073e4:	ff010113          	addi	sp,sp,-16
c00073e8:	00112623          	sw	ra,12(sp)
c00073ec:	00812423          	sw	s0,8(sp)
c00073f0:	01010413          	addi	s0,sp,16
	/* Check that the list from which active timers are referenced, and the
	queue used to communicate with the timer service, have been
	initialised. */
	taskENTER_CRITICAL();
c00073f4:	d4cfe0ef          	jal	ra,c0005940 <vTaskEnterCritical>
	{
		if( xTimerQueue == NULL )
c00073f8:	07ffc797          	auipc	a5,0x7ffc
c00073fc:	28078793          	addi	a5,a5,640 # c8003678 <xTimerQueue>
c0007400:	0007a783          	lw	a5,0(a5)
c0007404:	08079863          	bnez	a5,c0007494 <prvCheckForValidListAndQueue+0xb0>
		{
			vListInitialise( &xActiveTimerList1 );
c0007408:	07ffc517          	auipc	a0,0x7ffc
c000740c:	24050513          	addi	a0,a0,576 # c8003648 <xActiveTimerList1>
c0007410:	ab4f90ef          	jal	ra,c00006c4 <vListInitialise>
			vListInitialise( &xActiveTimerList2 );
c0007414:	07ffc517          	auipc	a0,0x7ffc
c0007418:	24850513          	addi	a0,a0,584 # c800365c <xActiveTimerList2>
c000741c:	aa8f90ef          	jal	ra,c00006c4 <vListInitialise>
			pxCurrentTimerList = &xActiveTimerList1;
c0007420:	07ffc797          	auipc	a5,0x7ffc
c0007424:	25078793          	addi	a5,a5,592 # c8003670 <pxCurrentTimerList>
c0007428:	07ffc717          	auipc	a4,0x7ffc
c000742c:	22070713          	addi	a4,a4,544 # c8003648 <xActiveTimerList1>
c0007430:	00e7a023          	sw	a4,0(a5)
			pxOverflowTimerList = &xActiveTimerList2;
c0007434:	07ffc797          	auipc	a5,0x7ffc
c0007438:	24078793          	addi	a5,a5,576 # c8003674 <pxOverflowTimerList>
c000743c:	07ffc717          	auipc	a4,0x7ffc
c0007440:	22070713          	addi	a4,a4,544 # c800365c <xActiveTimerList2>
c0007444:	00e7a023          	sw	a4,0(a5)

				xTimerQueue = xQueueCreateStatic( ( UBaseType_t ) configTIMER_QUEUE_LENGTH, ( UBaseType_t ) sizeof( DaemonTaskMessage_t ), &( ucStaticTimerQueueStorage[ 0 ] ), &xStaticTimerQueue );
			}
			#else
			{
				xTimerQueue = xQueueCreate( ( UBaseType_t ) configTIMER_QUEUE_LENGTH, sizeof( DaemonTaskMessage_t ) );
c0007448:	00000613          	li	a2,0
c000744c:	01000593          	li	a1,16
c0007450:	00400513          	li	a0,4
c0007454:	e1cf90ef          	jal	ra,c0000a70 <xQueueGenericCreate>
c0007458:	00050713          	mv	a4,a0
c000745c:	07ffc797          	auipc	a5,0x7ffc
c0007460:	21c78793          	addi	a5,a5,540 # c8003678 <xTimerQueue>
c0007464:	00e7a023          	sw	a4,0(a5)
			}
			#endif

			#if ( configQUEUE_REGISTRY_SIZE > 0 )
			{
				if( xTimerQueue != NULL )
c0007468:	07ffc797          	auipc	a5,0x7ffc
c000746c:	21078793          	addi	a5,a5,528 # c8003678 <xTimerQueue>
c0007470:	0007a783          	lw	a5,0(a5)
c0007474:	02078063          	beqz	a5,c0007494 <prvCheckForValidListAndQueue+0xb0>
				{
					vQueueAddToRegistry( xTimerQueue, "TmrQ" );
c0007478:	07ffc797          	auipc	a5,0x7ffc
c000747c:	20078793          	addi	a5,a5,512 # c8003678 <xTimerQueue>
c0007480:	0007a783          	lw	a5,0(a5)
c0007484:	07ff9597          	auipc	a1,0x7ff9
c0007488:	c0058593          	addi	a1,a1,-1024 # c8000084 <__rodata_start+0x84>
c000748c:	00078513          	mv	a0,a5
c0007490:	f2dfa0ef          	jal	ra,c00023bc <vQueueAddToRegistry>
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
	taskEXIT_CRITICAL();
c0007494:	d00fe0ef          	jal	ra,c0005994 <vTaskExitCritical>
}
c0007498:	00000013          	nop
c000749c:	00c12083          	lw	ra,12(sp)
c00074a0:	00812403          	lw	s0,8(sp)
c00074a4:	01010113          	addi	sp,sp,16
c00074a8:	00008067          	ret

c00074ac <xTimerIsTimerActive>:
/*-----------------------------------------------------------*/

BaseType_t xTimerIsTimerActive( TimerHandle_t xTimer )
{
c00074ac:	fd010113          	addi	sp,sp,-48
c00074b0:	02112623          	sw	ra,44(sp)
c00074b4:	02812423          	sw	s0,40(sp)
c00074b8:	03010413          	addi	s0,sp,48
c00074bc:	fca42e23          	sw	a0,-36(s0)
BaseType_t xReturn;
Timer_t *pxTimer = xTimer;
c00074c0:	fdc42783          	lw	a5,-36(s0)
c00074c4:	fef42423          	sw	a5,-24(s0)

	configASSERT( xTimer );
c00074c8:	fdc42783          	lw	a5,-36(s0)
c00074cc:	00079863          	bnez	a5,c00074dc <xTimerIsTimerActive+0x30>
c00074d0:	30047073          	csrci	mstatus,8
c00074d4:	00100073          	ebreak
c00074d8:	0000006f          	j	c00074d8 <xTimerIsTimerActive+0x2c>

	/* Is the timer in the list of active timers? */
	taskENTER_CRITICAL();
c00074dc:	c64fe0ef          	jal	ra,c0005940 <vTaskEnterCritical>
	{
		if( ( pxTimer->ucStatus & tmrSTATUS_IS_ACTIVE ) == 0 )
c00074e0:	fe842783          	lw	a5,-24(s0)
c00074e4:	0287c783          	lbu	a5,40(a5)
c00074e8:	0017f793          	andi	a5,a5,1
c00074ec:	00079663          	bnez	a5,c00074f8 <xTimerIsTimerActive+0x4c>
		{
			xReturn = pdFALSE;
c00074f0:	fe042623          	sw	zero,-20(s0)
c00074f4:	00c0006f          	j	c0007500 <xTimerIsTimerActive+0x54>
		}
		else
		{
			xReturn = pdTRUE;
c00074f8:	00100793          	li	a5,1
c00074fc:	fef42623          	sw	a5,-20(s0)
		}
	}
	taskEXIT_CRITICAL();
c0007500:	c94fe0ef          	jal	ra,c0005994 <vTaskExitCritical>

	return xReturn;
c0007504:	fec42783          	lw	a5,-20(s0)
} /*lint !e818 Can't be pointer to const due to the typedef. */
c0007508:	00078513          	mv	a0,a5
c000750c:	02c12083          	lw	ra,44(sp)
c0007510:	02812403          	lw	s0,40(sp)
c0007514:	03010113          	addi	sp,sp,48
c0007518:	00008067          	ret

c000751c <pvTimerGetTimerID>:
/*-----------------------------------------------------------*/

void *pvTimerGetTimerID( const TimerHandle_t xTimer )
{
c000751c:	fd010113          	addi	sp,sp,-48
c0007520:	02112623          	sw	ra,44(sp)
c0007524:	02812423          	sw	s0,40(sp)
c0007528:	03010413          	addi	s0,sp,48
c000752c:	fca42e23          	sw	a0,-36(s0)
Timer_t * const pxTimer = xTimer;
c0007530:	fdc42783          	lw	a5,-36(s0)
c0007534:	fef42623          	sw	a5,-20(s0)
void *pvReturn;

	configASSERT( xTimer );
c0007538:	fdc42783          	lw	a5,-36(s0)
c000753c:	00079863          	bnez	a5,c000754c <pvTimerGetTimerID+0x30>
c0007540:	30047073          	csrci	mstatus,8
c0007544:	00100073          	ebreak
c0007548:	0000006f          	j	c0007548 <pvTimerGetTimerID+0x2c>

	taskENTER_CRITICAL();
c000754c:	bf4fe0ef          	jal	ra,c0005940 <vTaskEnterCritical>
	{
		pvReturn = pxTimer->pvTimerID;
c0007550:	fec42783          	lw	a5,-20(s0)
c0007554:	01c7a783          	lw	a5,28(a5)
c0007558:	fef42423          	sw	a5,-24(s0)
	}
	taskEXIT_CRITICAL();
c000755c:	c38fe0ef          	jal	ra,c0005994 <vTaskExitCritical>

	return pvReturn;
c0007560:	fe842783          	lw	a5,-24(s0)
}
c0007564:	00078513          	mv	a0,a5
c0007568:	02c12083          	lw	ra,44(sp)
c000756c:	02812403          	lw	s0,40(sp)
c0007570:	03010113          	addi	sp,sp,48
c0007574:	00008067          	ret

c0007578 <vTimerSetTimerID>:
/*-----------------------------------------------------------*/

void vTimerSetTimerID( TimerHandle_t xTimer, void *pvNewID )
{
c0007578:	fd010113          	addi	sp,sp,-48
c000757c:	02112623          	sw	ra,44(sp)
c0007580:	02812423          	sw	s0,40(sp)
c0007584:	03010413          	addi	s0,sp,48
c0007588:	fca42e23          	sw	a0,-36(s0)
c000758c:	fcb42c23          	sw	a1,-40(s0)
Timer_t * const pxTimer = xTimer;
c0007590:	fdc42783          	lw	a5,-36(s0)
c0007594:	fef42623          	sw	a5,-20(s0)

	configASSERT( xTimer );
c0007598:	fdc42783          	lw	a5,-36(s0)
c000759c:	00079863          	bnez	a5,c00075ac <vTimerSetTimerID+0x34>
c00075a0:	30047073          	csrci	mstatus,8
c00075a4:	00100073          	ebreak
c00075a8:	0000006f          	j	c00075a8 <vTimerSetTimerID+0x30>

	taskENTER_CRITICAL();
c00075ac:	b94fe0ef          	jal	ra,c0005940 <vTaskEnterCritical>
	{
		pxTimer->pvTimerID = pvNewID;
c00075b0:	fec42783          	lw	a5,-20(s0)
c00075b4:	fd842703          	lw	a4,-40(s0)
c00075b8:	00e7ae23          	sw	a4,28(a5)
	}
	taskEXIT_CRITICAL();
c00075bc:	bd8fe0ef          	jal	ra,c0005994 <vTaskExitCritical>
}
c00075c0:	00000013          	nop
c00075c4:	02c12083          	lw	ra,44(sp)
c00075c8:	02812403          	lw	s0,40(sp)
c00075cc:	03010113          	addi	sp,sp,48
c00075d0:	00008067          	ret

c00075d4 <xTimerPendFunctionCallFromISR>:
/*-----------------------------------------------------------*/

#if( INCLUDE_xTimerPendFunctionCall == 1 )

	BaseType_t xTimerPendFunctionCallFromISR( PendedFunction_t xFunctionToPend, void *pvParameter1, uint32_t ulParameter2, BaseType_t *pxHigherPriorityTaskWoken )
	{
c00075d4:	fc010113          	addi	sp,sp,-64
c00075d8:	02112e23          	sw	ra,60(sp)
c00075dc:	02812c23          	sw	s0,56(sp)
c00075e0:	04010413          	addi	s0,sp,64
c00075e4:	fca42623          	sw	a0,-52(s0)
c00075e8:	fcb42423          	sw	a1,-56(s0)
c00075ec:	fcc42223          	sw	a2,-60(s0)
c00075f0:	fcd42023          	sw	a3,-64(s0)
	DaemonTaskMessage_t xMessage;
	BaseType_t xReturn;

		/* Complete the message with the function parameters and post it to the
		daemon task. */
		xMessage.xMessageID = tmrCOMMAND_EXECUTE_CALLBACK_FROM_ISR;
c00075f4:	ffe00793          	li	a5,-2
c00075f8:	fcf42e23          	sw	a5,-36(s0)
		xMessage.u.xCallbackParameters.pxCallbackFunction = xFunctionToPend;
c00075fc:	fcc42783          	lw	a5,-52(s0)
c0007600:	fef42023          	sw	a5,-32(s0)
		xMessage.u.xCallbackParameters.pvParameter1 = pvParameter1;
c0007604:	fc842783          	lw	a5,-56(s0)
c0007608:	fef42223          	sw	a5,-28(s0)
		xMessage.u.xCallbackParameters.ulParameter2 = ulParameter2;
c000760c:	fc442783          	lw	a5,-60(s0)
c0007610:	fef42423          	sw	a5,-24(s0)

		xReturn = xQueueSendFromISR( xTimerQueue, &xMessage, pxHigherPriorityTaskWoken );
c0007614:	07ffc797          	auipc	a5,0x7ffc
c0007618:	06478793          	addi	a5,a5,100 # c8003678 <xTimerQueue>
c000761c:	0007a783          	lw	a5,0(a5)
c0007620:	fdc40713          	addi	a4,s0,-36
c0007624:	00000693          	li	a3,0
c0007628:	fc042603          	lw	a2,-64(s0)
c000762c:	00070593          	mv	a1,a4
c0007630:	00078513          	mv	a0,a5
c0007634:	b29f90ef          	jal	ra,c000115c <xQueueGenericSendFromISR>
c0007638:	fea42623          	sw	a0,-20(s0)

		tracePEND_FUNC_CALL_FROM_ISR( xFunctionToPend, pvParameter1, ulParameter2, xReturn );

		return xReturn;
c000763c:	fec42783          	lw	a5,-20(s0)
	}
c0007640:	00078513          	mv	a0,a5
c0007644:	03c12083          	lw	ra,60(sp)
c0007648:	03812403          	lw	s0,56(sp)
c000764c:	04010113          	addi	sp,sp,64
c0007650:	00008067          	ret

c0007654 <xTimerPendFunctionCall>:
/*-----------------------------------------------------------*/

#if( INCLUDE_xTimerPendFunctionCall == 1 )

	BaseType_t xTimerPendFunctionCall( PendedFunction_t xFunctionToPend, void *pvParameter1, uint32_t ulParameter2, TickType_t xTicksToWait )
	{
c0007654:	fc010113          	addi	sp,sp,-64
c0007658:	02112e23          	sw	ra,60(sp)
c000765c:	02812c23          	sw	s0,56(sp)
c0007660:	04010413          	addi	s0,sp,64
c0007664:	fca42623          	sw	a0,-52(s0)
c0007668:	fcb42423          	sw	a1,-56(s0)
c000766c:	fcc42223          	sw	a2,-60(s0)
c0007670:	fcd42023          	sw	a3,-64(s0)
	BaseType_t xReturn;

		/* This function can only be called after a timer has been created or
		after the scheduler has been started because, until then, the timer
		queue does not exist. */
		configASSERT( xTimerQueue );
c0007674:	07ffc797          	auipc	a5,0x7ffc
c0007678:	00478793          	addi	a5,a5,4 # c8003678 <xTimerQueue>
c000767c:	0007a783          	lw	a5,0(a5)
c0007680:	00079863          	bnez	a5,c0007690 <xTimerPendFunctionCall+0x3c>
c0007684:	30047073          	csrci	mstatus,8
c0007688:	00100073          	ebreak
c000768c:	0000006f          	j	c000768c <xTimerPendFunctionCall+0x38>

		/* Complete the message with the function parameters and post it to the
		daemon task. */
		xMessage.xMessageID = tmrCOMMAND_EXECUTE_CALLBACK;
c0007690:	fff00793          	li	a5,-1
c0007694:	fcf42e23          	sw	a5,-36(s0)
		xMessage.u.xCallbackParameters.pxCallbackFunction = xFunctionToPend;
c0007698:	fcc42783          	lw	a5,-52(s0)
c000769c:	fef42023          	sw	a5,-32(s0)
		xMessage.u.xCallbackParameters.pvParameter1 = pvParameter1;
c00076a0:	fc842783          	lw	a5,-56(s0)
c00076a4:	fef42223          	sw	a5,-28(s0)
		xMessage.u.xCallbackParameters.ulParameter2 = ulParameter2;
c00076a8:	fc442783          	lw	a5,-60(s0)
c00076ac:	fef42423          	sw	a5,-24(s0)

		xReturn = xQueueSendToBack( xTimerQueue, &xMessage, xTicksToWait );
c00076b0:	07ffc797          	auipc	a5,0x7ffc
c00076b4:	fc878793          	addi	a5,a5,-56 # c8003678 <xTimerQueue>
c00076b8:	0007a783          	lw	a5,0(a5)
c00076bc:	fdc40713          	addi	a4,s0,-36
c00076c0:	00000693          	li	a3,0
c00076c4:	fc042603          	lw	a2,-64(s0)
c00076c8:	00070593          	mv	a1,a4
c00076cc:	00078513          	mv	a0,a5
c00076d0:	825f90ef          	jal	ra,c0000ef4 <xQueueGenericSend>
c00076d4:	fea42623          	sw	a0,-20(s0)

		tracePEND_FUNC_CALL( xFunctionToPend, pvParameter1, ulParameter2, xReturn );

		return xReturn;
c00076d8:	fec42783          	lw	a5,-20(s0)
	}
c00076dc:	00078513          	mv	a0,a5
c00076e0:	03c12083          	lw	ra,60(sp)
c00076e4:	03812403          	lw	s0,56(sp)
c00076e8:	04010113          	addi	sp,sp,64
c00076ec:	00008067          	ret

c00076f0 <uxTimerGetTimerNumber>:
/*-----------------------------------------------------------*/

#if ( configUSE_TRACE_FACILITY == 1 )

	UBaseType_t uxTimerGetTimerNumber( TimerHandle_t xTimer )
	{
c00076f0:	fe010113          	addi	sp,sp,-32
c00076f4:	00812e23          	sw	s0,28(sp)
c00076f8:	02010413          	addi	s0,sp,32
c00076fc:	fea42623          	sw	a0,-20(s0)
		return ( ( Timer_t * ) xTimer )->uxTimerNumber;
c0007700:	fec42783          	lw	a5,-20(s0)
c0007704:	0247a783          	lw	a5,36(a5)
	}
c0007708:	00078513          	mv	a0,a5
c000770c:	01c12403          	lw	s0,28(sp)
c0007710:	02010113          	addi	sp,sp,32
c0007714:	00008067          	ret

c0007718 <vTimerSetTimerNumber>:
/*-----------------------------------------------------------*/

#if ( configUSE_TRACE_FACILITY == 1 )

	void vTimerSetTimerNumber( TimerHandle_t xTimer, UBaseType_t uxTimerNumber )
	{
c0007718:	fe010113          	addi	sp,sp,-32
c000771c:	00812e23          	sw	s0,28(sp)
c0007720:	02010413          	addi	s0,sp,32
c0007724:	fea42623          	sw	a0,-20(s0)
c0007728:	feb42423          	sw	a1,-24(s0)
		( ( Timer_t * ) xTimer )->uxTimerNumber = uxTimerNumber;
c000772c:	fec42783          	lw	a5,-20(s0)
c0007730:	fe842703          	lw	a4,-24(s0)
c0007734:	02e7a223          	sw	a4,36(a5)
	}
c0007738:	00000013          	nop
c000773c:	01c12403          	lw	s0,28(sp)
c0007740:	02010113          	addi	sp,sp,32
c0007744:	00008067          	ret

c0007748 <xEventGroupCreate>:
/*-----------------------------------------------------------*/

#if( configSUPPORT_DYNAMIC_ALLOCATION == 1 )

	EventGroupHandle_t xEventGroupCreate( void )
	{
c0007748:	fe010113          	addi	sp,sp,-32
c000774c:	00112e23          	sw	ra,28(sp)
c0007750:	00812c23          	sw	s0,24(sp)
c0007754:	02010413          	addi	s0,sp,32
		TickType_t alignment requirements the cast is safe.  In other cases,
		where the natural word size of the architecture is less than
		sizeof( TickType_t ), the TickType_t variables will be accessed in two
		or more reads operations, and the alignment requirements is only that
		of each individual read. */
		pxEventBits = ( EventGroup_t * ) pvPortMalloc( sizeof( EventGroup_t ) ); /*lint !e9087 !e9079 see comment above. */
c0007758:	01c00513          	li	a0,28
c000775c:	359010ef          	jal	ra,c00092b4 <pvPortMalloc>
c0007760:	fea42623          	sw	a0,-20(s0)

		if( pxEventBits != NULL )
c0007764:	fec42783          	lw	a5,-20(s0)
c0007768:	00078e63          	beqz	a5,c0007784 <xEventGroupCreate+0x3c>
		{
			pxEventBits->uxEventBits = 0;
c000776c:	fec42783          	lw	a5,-20(s0)
c0007770:	0007a023          	sw	zero,0(a5)
			vListInitialise( &( pxEventBits->xTasksWaitingForBits ) );
c0007774:	fec42783          	lw	a5,-20(s0)
c0007778:	00478793          	addi	a5,a5,4
c000777c:	00078513          	mv	a0,a5
c0007780:	f45f80ef          	jal	ra,c00006c4 <vListInitialise>
		else
		{
			traceEVENT_GROUP_CREATE_FAILED(); /*lint !e9063 Else branch only exists to allow tracing and does not generate code if trace macros are not defined. */
		}

		return pxEventBits;
c0007784:	fec42783          	lw	a5,-20(s0)
	}
c0007788:	00078513          	mv	a0,a5
c000778c:	01c12083          	lw	ra,28(sp)
c0007790:	01812403          	lw	s0,24(sp)
c0007794:	02010113          	addi	sp,sp,32
c0007798:	00008067          	ret

c000779c <xEventGroupSync>:

#endif /* configSUPPORT_DYNAMIC_ALLOCATION */
/*-----------------------------------------------------------*/

EventBits_t xEventGroupSync( EventGroupHandle_t xEventGroup, const EventBits_t uxBitsToSet, const EventBits_t uxBitsToWaitFor, TickType_t xTicksToWait )
{
c000779c:	fc010113          	addi	sp,sp,-64
c00077a0:	02112e23          	sw	ra,60(sp)
c00077a4:	02812c23          	sw	s0,56(sp)
c00077a8:	04010413          	addi	s0,sp,64
c00077ac:	fca42623          	sw	a0,-52(s0)
c00077b0:	fcb42423          	sw	a1,-56(s0)
c00077b4:	fcc42223          	sw	a2,-60(s0)
c00077b8:	fcd42023          	sw	a3,-64(s0)
EventBits_t uxOriginalBitValue, uxReturn;
EventGroup_t *pxEventBits = xEventGroup;
c00077bc:	fcc42783          	lw	a5,-52(s0)
c00077c0:	fef42423          	sw	a5,-24(s0)
BaseType_t xAlreadyYielded;
BaseType_t xTimeoutOccurred = pdFALSE;
c00077c4:	fe042223          	sw	zero,-28(s0)

	configASSERT( ( uxBitsToWaitFor & eventEVENT_BITS_CONTROL_BYTES ) == 0 );
c00077c8:	fc442703          	lw	a4,-60(s0)
c00077cc:	ff0007b7          	lui	a5,0xff000
c00077d0:	00f777b3          	and	a5,a4,a5
c00077d4:	00078863          	beqz	a5,c00077e4 <xEventGroupSync+0x48>
c00077d8:	30047073          	csrci	mstatus,8
c00077dc:	00100073          	ebreak
c00077e0:	0000006f          	j	c00077e0 <xEventGroupSync+0x44>
	configASSERT( uxBitsToWaitFor != 0 );
c00077e4:	fc442783          	lw	a5,-60(s0)
c00077e8:	00079863          	bnez	a5,c00077f8 <xEventGroupSync+0x5c>
c00077ec:	30047073          	csrci	mstatus,8
c00077f0:	00100073          	ebreak
c00077f4:	0000006f          	j	c00077f4 <xEventGroupSync+0x58>
	#if ( ( INCLUDE_xTaskGetSchedulerState == 1 ) || ( configUSE_TIMERS == 1 ) )
	{
		configASSERT( !( ( xTaskGetSchedulerState() == taskSCHEDULER_SUSPENDED ) && ( xTicksToWait != 0 ) ) );
c00077f8:	b9dfd0ef          	jal	ra,c0005394 <xTaskGetSchedulerState>
c00077fc:	00050793          	mv	a5,a0
c0007800:	00079663          	bnez	a5,c000780c <xEventGroupSync+0x70>
c0007804:	fc042783          	lw	a5,-64(s0)
c0007808:	00079663          	bnez	a5,c0007814 <xEventGroupSync+0x78>
c000780c:	00100793          	li	a5,1
c0007810:	0080006f          	j	c0007818 <xEventGroupSync+0x7c>
c0007814:	00000793          	li	a5,0
c0007818:	00079863          	bnez	a5,c0007828 <xEventGroupSync+0x8c>
c000781c:	30047073          	csrci	mstatus,8
c0007820:	00100073          	ebreak
c0007824:	0000006f          	j	c0007824 <xEventGroupSync+0x88>
	}
	#endif

	vTaskSuspendAll();
c0007828:	f35fb0ef          	jal	ra,c000375c <vTaskSuspendAll>
	{
		uxOriginalBitValue = pxEventBits->uxEventBits;
c000782c:	fe842783          	lw	a5,-24(s0)
c0007830:	0007a783          	lw	a5,0(a5) # ff000000 <_end+0x36f7b780>
c0007834:	fef42023          	sw	a5,-32(s0)

		( void ) xEventGroupSetBits( xEventGroup, uxBitsToSet );
c0007838:	fc842583          	lw	a1,-56(s0)
c000783c:	fcc42503          	lw	a0,-52(s0)
c0007840:	49c000ef          	jal	ra,c0007cdc <xEventGroupSetBits>

		if( ( ( uxOriginalBitValue | uxBitsToSet ) & uxBitsToWaitFor ) == uxBitsToWaitFor )
c0007844:	fe042703          	lw	a4,-32(s0)
c0007848:	fc842783          	lw	a5,-56(s0)
c000784c:	00f76733          	or	a4,a4,a5
c0007850:	fc442783          	lw	a5,-60(s0)
c0007854:	00f777b3          	and	a5,a4,a5
c0007858:	fc442703          	lw	a4,-60(s0)
c000785c:	02f71c63          	bne	a4,a5,c0007894 <xEventGroupSync+0xf8>
		{
			/* All the rendezvous bits are now set - no need to block. */
			uxReturn = ( uxOriginalBitValue | uxBitsToSet );
c0007860:	fe042703          	lw	a4,-32(s0)
c0007864:	fc842783          	lw	a5,-56(s0)
c0007868:	00f767b3          	or	a5,a4,a5
c000786c:	fef42623          	sw	a5,-20(s0)

			/* Rendezvous always clear the bits.  They will have been cleared
			already unless this is the only task in the rendezvous. */
			pxEventBits->uxEventBits &= ~uxBitsToWaitFor;
c0007870:	fe842783          	lw	a5,-24(s0)
c0007874:	0007a703          	lw	a4,0(a5)
c0007878:	fc442783          	lw	a5,-60(s0)
c000787c:	fff7c793          	not	a5,a5
c0007880:	00f77733          	and	a4,a4,a5
c0007884:	fe842783          	lw	a5,-24(s0)
c0007888:	00e7a023          	sw	a4,0(a5)

			xTicksToWait = 0;
c000788c:	fc042023          	sw	zero,-64(s0)
c0007890:	04c0006f          	j	c00078dc <xEventGroupSync+0x140>
		}
		else
		{
			if( xTicksToWait != ( TickType_t ) 0 )
c0007894:	fc042783          	lw	a5,-64(s0)
c0007898:	02078863          	beqz	a5,c00078c8 <xEventGroupSync+0x12c>
				traceEVENT_GROUP_SYNC_BLOCK( xEventGroup, uxBitsToSet, uxBitsToWaitFor );

				/* Store the bits that the calling task is waiting for in the
				task's event list item so the kernel knows when a match is
				found.  Then enter the blocked state. */
				vTaskPlaceOnUnorderedEventList( &( pxEventBits->xTasksWaitingForBits ), ( uxBitsToWaitFor | eventCLEAR_EVENTS_ON_EXIT_BIT | eventWAIT_FOR_ALL_BITS ), xTicksToWait );
c000789c:	fe842783          	lw	a5,-24(s0)
c00078a0:	00478693          	addi	a3,a5,4
c00078a4:	fc442703          	lw	a4,-60(s0)
c00078a8:	050007b7          	lui	a5,0x5000
c00078ac:	00f767b3          	or	a5,a4,a5
c00078b0:	fc042603          	lw	a2,-64(s0)
c00078b4:	00078593          	mv	a1,a5
c00078b8:	00068513          	mv	a0,a3
c00078bc:	ed1fc0ef          	jal	ra,c000478c <vTaskPlaceOnUnorderedEventList>

				/* This assignment is obsolete as uxReturn will get set after
				the task unblocks, but some compilers mistakenly generate a
				warning about uxReturn being returned without being set if the
				assignment is omitted. */
				uxReturn = 0;
c00078c0:	fe042623          	sw	zero,-20(s0)
c00078c4:	0180006f          	j	c00078dc <xEventGroupSync+0x140>
			}
			else
			{
				/* The rendezvous bits were not set, but no block time was
				specified - just return the current event bit value. */
				uxReturn = pxEventBits->uxEventBits;
c00078c8:	fe842783          	lw	a5,-24(s0)
c00078cc:	0007a783          	lw	a5,0(a5) # 5000000 <_DMEM_LENGTH+0x4800000>
c00078d0:	fef42623          	sw	a5,-20(s0)
				xTimeoutOccurred = pdTRUE;
c00078d4:	00100793          	li	a5,1
c00078d8:	fef42223          	sw	a5,-28(s0)
			}
		}
	}
	xAlreadyYielded = xTaskResumeAll();
c00078dc:	eb9fb0ef          	jal	ra,c0003794 <xTaskResumeAll>
c00078e0:	fca42e23          	sw	a0,-36(s0)

	if( xTicksToWait != ( TickType_t ) 0 )
c00078e4:	fc042783          	lw	a5,-64(s0)
c00078e8:	08078463          	beqz	a5,c0007970 <xEventGroupSync+0x1d4>
	{
		if( xAlreadyYielded == pdFALSE )
c00078ec:	fdc42783          	lw	a5,-36(s0)
c00078f0:	00079463          	bnez	a5,c00078f8 <xEventGroupSync+0x15c>
		{
			portYIELD_WITHIN_API();
c00078f4:	00000073          	ecall

		/* The task blocked to wait for its required bits to be set - at this
		point either the required bits were set or the block time expired.  If
		the required bits were set they will have been stored in the task's
		event list item, and they should now be retrieved then cleared. */
		uxReturn = uxTaskResetEventItemValue();
c00078f8:	bacfe0ef          	jal	ra,c0005ca4 <uxTaskResetEventItemValue>
c00078fc:	fea42623          	sw	a0,-20(s0)

		if( ( uxReturn & eventUNBLOCKED_DUE_TO_BIT_SET ) == ( EventBits_t ) 0 )
c0007900:	fec42703          	lw	a4,-20(s0)
c0007904:	020007b7          	lui	a5,0x2000
c0007908:	00f777b3          	and	a5,a4,a5
c000790c:	04079863          	bnez	a5,c000795c <xEventGroupSync+0x1c0>
		{
			/* The task timed out, just return the current event bit value. */
			taskENTER_CRITICAL();
c0007910:	830fe0ef          	jal	ra,c0005940 <vTaskEnterCritical>
			{
				uxReturn = pxEventBits->uxEventBits;
c0007914:	fe842783          	lw	a5,-24(s0)
c0007918:	0007a783          	lw	a5,0(a5) # 2000000 <_DMEM_LENGTH+0x1800000>
c000791c:	fef42623          	sw	a5,-20(s0)

				/* Although the task got here because it timed out before the
				bits it was waiting for were set, it is possible that since it
				unblocked another task has set the bits.  If this is the case
				then it needs to clear the bits before exiting. */
				if( ( uxReturn & uxBitsToWaitFor ) == uxBitsToWaitFor )
c0007920:	fec42703          	lw	a4,-20(s0)
c0007924:	fc442783          	lw	a5,-60(s0)
c0007928:	00f777b3          	and	a5,a4,a5
c000792c:	fc442703          	lw	a4,-60(s0)
c0007930:	02f71063          	bne	a4,a5,c0007950 <xEventGroupSync+0x1b4>
				{
					pxEventBits->uxEventBits &= ~uxBitsToWaitFor;
c0007934:	fe842783          	lw	a5,-24(s0)
c0007938:	0007a703          	lw	a4,0(a5)
c000793c:	fc442783          	lw	a5,-60(s0)
c0007940:	fff7c793          	not	a5,a5
c0007944:	00f77733          	and	a4,a4,a5
c0007948:	fe842783          	lw	a5,-24(s0)
c000794c:	00e7a023          	sw	a4,0(a5)
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}
			}
			taskEXIT_CRITICAL();
c0007950:	844fe0ef          	jal	ra,c0005994 <vTaskExitCritical>

			xTimeoutOccurred = pdTRUE;
c0007954:	00100793          	li	a5,1
c0007958:	fef42223          	sw	a5,-28(s0)
			/* The task unblocked because the bits were set. */
		}

		/* Control bits might be set as the task had blocked should not be
		returned. */
		uxReturn &= ~eventEVENT_BITS_CONTROL_BYTES;
c000795c:	fec42703          	lw	a4,-20(s0)
c0007960:	010007b7          	lui	a5,0x1000
c0007964:	fff78793          	addi	a5,a5,-1 # ffffff <_DMEM_LENGTH+0x7fffff>
c0007968:	00f777b3          	and	a5,a4,a5
c000796c:	fef42623          	sw	a5,-20(s0)
	traceEVENT_GROUP_SYNC_END( xEventGroup, uxBitsToSet, uxBitsToWaitFor, xTimeoutOccurred );

	/* Prevent compiler warnings when trace macros are not used. */
	( void ) xTimeoutOccurred;

	return uxReturn;
c0007970:	fec42783          	lw	a5,-20(s0)
}
c0007974:	00078513          	mv	a0,a5
c0007978:	03c12083          	lw	ra,60(sp)
c000797c:	03812403          	lw	s0,56(sp)
c0007980:	04010113          	addi	sp,sp,64
c0007984:	00008067          	ret

c0007988 <xEventGroupWaitBits>:
/*-----------------------------------------------------------*/

EventBits_t xEventGroupWaitBits( EventGroupHandle_t xEventGroup, const EventBits_t uxBitsToWaitFor, const BaseType_t xClearOnExit, const BaseType_t xWaitForAllBits, TickType_t xTicksToWait )
{
c0007988:	fb010113          	addi	sp,sp,-80
c000798c:	04112623          	sw	ra,76(sp)
c0007990:	04812423          	sw	s0,72(sp)
c0007994:	05010413          	addi	s0,sp,80
c0007998:	fca42623          	sw	a0,-52(s0)
c000799c:	fcb42423          	sw	a1,-56(s0)
c00079a0:	fcc42223          	sw	a2,-60(s0)
c00079a4:	fcd42023          	sw	a3,-64(s0)
c00079a8:	fae42e23          	sw	a4,-68(s0)
EventGroup_t *pxEventBits = xEventGroup;
c00079ac:	fcc42783          	lw	a5,-52(s0)
c00079b0:	fef42223          	sw	a5,-28(s0)
EventBits_t uxReturn, uxControlBits = 0;
c00079b4:	fe042423          	sw	zero,-24(s0)
BaseType_t xWaitConditionMet, xAlreadyYielded;
BaseType_t xTimeoutOccurred = pdFALSE;
c00079b8:	fe042023          	sw	zero,-32(s0)

	/* Check the user is not attempting to wait on the bits used by the kernel
	itself, and that at least one bit is being requested. */
	configASSERT( xEventGroup );
c00079bc:	fcc42783          	lw	a5,-52(s0)
c00079c0:	00079863          	bnez	a5,c00079d0 <xEventGroupWaitBits+0x48>
c00079c4:	30047073          	csrci	mstatus,8
c00079c8:	00100073          	ebreak
c00079cc:	0000006f          	j	c00079cc <xEventGroupWaitBits+0x44>
	configASSERT( ( uxBitsToWaitFor & eventEVENT_BITS_CONTROL_BYTES ) == 0 );
c00079d0:	fc842703          	lw	a4,-56(s0)
c00079d4:	ff0007b7          	lui	a5,0xff000
c00079d8:	00f777b3          	and	a5,a4,a5
c00079dc:	00078863          	beqz	a5,c00079ec <xEventGroupWaitBits+0x64>
c00079e0:	30047073          	csrci	mstatus,8
c00079e4:	00100073          	ebreak
c00079e8:	0000006f          	j	c00079e8 <xEventGroupWaitBits+0x60>
	configASSERT( uxBitsToWaitFor != 0 );
c00079ec:	fc842783          	lw	a5,-56(s0)
c00079f0:	00079863          	bnez	a5,c0007a00 <xEventGroupWaitBits+0x78>
c00079f4:	30047073          	csrci	mstatus,8
c00079f8:	00100073          	ebreak
c00079fc:	0000006f          	j	c00079fc <xEventGroupWaitBits+0x74>
	#if ( ( INCLUDE_xTaskGetSchedulerState == 1 ) || ( configUSE_TIMERS == 1 ) )
	{
		configASSERT( !( ( xTaskGetSchedulerState() == taskSCHEDULER_SUSPENDED ) && ( xTicksToWait != 0 ) ) );
c0007a00:	995fd0ef          	jal	ra,c0005394 <xTaskGetSchedulerState>
c0007a04:	00050793          	mv	a5,a0
c0007a08:	00079663          	bnez	a5,c0007a14 <xEventGroupWaitBits+0x8c>
c0007a0c:	fbc42783          	lw	a5,-68(s0)
c0007a10:	00079663          	bnez	a5,c0007a1c <xEventGroupWaitBits+0x94>
c0007a14:	00100793          	li	a5,1
c0007a18:	0080006f          	j	c0007a20 <xEventGroupWaitBits+0x98>
c0007a1c:	00000793          	li	a5,0
c0007a20:	00079863          	bnez	a5,c0007a30 <xEventGroupWaitBits+0xa8>
c0007a24:	30047073          	csrci	mstatus,8
c0007a28:	00100073          	ebreak
c0007a2c:	0000006f          	j	c0007a2c <xEventGroupWaitBits+0xa4>
	}
	#endif

	vTaskSuspendAll();
c0007a30:	d2dfb0ef          	jal	ra,c000375c <vTaskSuspendAll>
	{
		const EventBits_t uxCurrentEventBits = pxEventBits->uxEventBits;
c0007a34:	fe442783          	lw	a5,-28(s0)
c0007a38:	0007a783          	lw	a5,0(a5) # ff000000 <_end+0x36f7b780>
c0007a3c:	fcf42e23          	sw	a5,-36(s0)

		/* Check to see if the wait condition is already met or not. */
		xWaitConditionMet = prvTestWaitCondition( uxCurrentEventBits, uxBitsToWaitFor, xWaitForAllBits );
c0007a40:	fc042603          	lw	a2,-64(s0)
c0007a44:	fc842583          	lw	a1,-56(s0)
c0007a48:	fdc42503          	lw	a0,-36(s0)
c0007a4c:	550000ef          	jal	ra,c0007f9c <prvTestWaitCondition>
c0007a50:	fca42c23          	sw	a0,-40(s0)

		if( xWaitConditionMet != pdFALSE )
c0007a54:	fd842783          	lw	a5,-40(s0)
c0007a58:	02078c63          	beqz	a5,c0007a90 <xEventGroupWaitBits+0x108>
		{
			/* The wait condition has already been met so there is no need to
			block. */
			uxReturn = uxCurrentEventBits;
c0007a5c:	fdc42783          	lw	a5,-36(s0)
c0007a60:	fef42623          	sw	a5,-20(s0)
			xTicksToWait = ( TickType_t ) 0;
c0007a64:	fa042e23          	sw	zero,-68(s0)

			/* Clear the wait bits if requested to do so. */
			if( xClearOnExit != pdFALSE )
c0007a68:	fc442783          	lw	a5,-60(s0)
c0007a6c:	08078c63          	beqz	a5,c0007b04 <xEventGroupWaitBits+0x17c>
			{
				pxEventBits->uxEventBits &= ~uxBitsToWaitFor;
c0007a70:	fe442783          	lw	a5,-28(s0)
c0007a74:	0007a703          	lw	a4,0(a5)
c0007a78:	fc842783          	lw	a5,-56(s0)
c0007a7c:	fff7c793          	not	a5,a5
c0007a80:	00f77733          	and	a4,a4,a5
c0007a84:	fe442783          	lw	a5,-28(s0)
c0007a88:	00e7a023          	sw	a4,0(a5)
c0007a8c:	0780006f          	j	c0007b04 <xEventGroupWaitBits+0x17c>
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
		else if( xTicksToWait == ( TickType_t ) 0 )
c0007a90:	fbc42783          	lw	a5,-68(s0)
c0007a94:	00079c63          	bnez	a5,c0007aac <xEventGroupWaitBits+0x124>
		{
			/* The wait condition has not been met, but no block time was
			specified, so just return the current value. */
			uxReturn = uxCurrentEventBits;
c0007a98:	fdc42783          	lw	a5,-36(s0)
c0007a9c:	fef42623          	sw	a5,-20(s0)
			xTimeoutOccurred = pdTRUE;
c0007aa0:	00100793          	li	a5,1
c0007aa4:	fef42023          	sw	a5,-32(s0)
c0007aa8:	05c0006f          	j	c0007b04 <xEventGroupWaitBits+0x17c>
		{
			/* The task is going to block to wait for its required bits to be
			set.  uxControlBits are used to remember the specified behaviour of
			this call to xEventGroupWaitBits() - for use when the event bits
			unblock the task. */
			if( xClearOnExit != pdFALSE )
c0007aac:	fc442783          	lw	a5,-60(s0)
c0007ab0:	00078a63          	beqz	a5,c0007ac4 <xEventGroupWaitBits+0x13c>
			{
				uxControlBits |= eventCLEAR_EVENTS_ON_EXIT_BIT;
c0007ab4:	fe842703          	lw	a4,-24(s0)
c0007ab8:	010007b7          	lui	a5,0x1000
c0007abc:	00f767b3          	or	a5,a4,a5
c0007ac0:	fef42423          	sw	a5,-24(s0)
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}

			if( xWaitForAllBits != pdFALSE )
c0007ac4:	fc042783          	lw	a5,-64(s0)
c0007ac8:	00078a63          	beqz	a5,c0007adc <xEventGroupWaitBits+0x154>
			{
				uxControlBits |= eventWAIT_FOR_ALL_BITS;
c0007acc:	fe842703          	lw	a4,-24(s0)
c0007ad0:	040007b7          	lui	a5,0x4000
c0007ad4:	00f767b3          	or	a5,a4,a5
c0007ad8:	fef42423          	sw	a5,-24(s0)
			}

			/* Store the bits that the calling task is waiting for in the
			task's event list item so the kernel knows when a match is
			found.  Then enter the blocked state. */
			vTaskPlaceOnUnorderedEventList( &( pxEventBits->xTasksWaitingForBits ), ( uxBitsToWaitFor | uxControlBits ), xTicksToWait );
c0007adc:	fe442783          	lw	a5,-28(s0)
c0007ae0:	00478693          	addi	a3,a5,4 # 4000004 <_DMEM_LENGTH+0x3800004>
c0007ae4:	fc842703          	lw	a4,-56(s0)
c0007ae8:	fe842783          	lw	a5,-24(s0)
c0007aec:	00f767b3          	or	a5,a4,a5
c0007af0:	fbc42603          	lw	a2,-68(s0)
c0007af4:	00078593          	mv	a1,a5
c0007af8:	00068513          	mv	a0,a3
c0007afc:	c91fc0ef          	jal	ra,c000478c <vTaskPlaceOnUnorderedEventList>

			/* This is obsolete as it will get set after the task unblocks, but
			some compilers mistakenly generate a warning about the variable
			being returned without being set if it is not done. */
			uxReturn = 0;
c0007b00:	fe042623          	sw	zero,-20(s0)

			traceEVENT_GROUP_WAIT_BITS_BLOCK( xEventGroup, uxBitsToWaitFor );
		}
	}
	xAlreadyYielded = xTaskResumeAll();
c0007b04:	c91fb0ef          	jal	ra,c0003794 <xTaskResumeAll>
c0007b08:	fca42a23          	sw	a0,-44(s0)

	if( xTicksToWait != ( TickType_t ) 0 )
c0007b0c:	fbc42783          	lw	a5,-68(s0)
c0007b10:	08078a63          	beqz	a5,c0007ba4 <xEventGroupWaitBits+0x21c>
	{
		if( xAlreadyYielded == pdFALSE )
c0007b14:	fd442783          	lw	a5,-44(s0)
c0007b18:	00079463          	bnez	a5,c0007b20 <xEventGroupWaitBits+0x198>
		{
			portYIELD_WITHIN_API();
c0007b1c:	00000073          	ecall

		/* The task blocked to wait for its required bits to be set - at this
		point either the required bits were set or the block time expired.  If
		the required bits were set they will have been stored in the task's
		event list item, and they should now be retrieved then cleared. */
		uxReturn = uxTaskResetEventItemValue();
c0007b20:	984fe0ef          	jal	ra,c0005ca4 <uxTaskResetEventItemValue>
c0007b24:	fea42623          	sw	a0,-20(s0)

		if( ( uxReturn & eventUNBLOCKED_DUE_TO_BIT_SET ) == ( EventBits_t ) 0 )
c0007b28:	fec42703          	lw	a4,-20(s0)
c0007b2c:	020007b7          	lui	a5,0x2000
c0007b30:	00f777b3          	and	a5,a4,a5
c0007b34:	04079e63          	bnez	a5,c0007b90 <xEventGroupWaitBits+0x208>
		{
			taskENTER_CRITICAL();
c0007b38:	e09fd0ef          	jal	ra,c0005940 <vTaskEnterCritical>
			{
				/* The task timed out, just return the current event bit value. */
				uxReturn = pxEventBits->uxEventBits;
c0007b3c:	fe442783          	lw	a5,-28(s0)
c0007b40:	0007a783          	lw	a5,0(a5) # 2000000 <_DMEM_LENGTH+0x1800000>
c0007b44:	fef42623          	sw	a5,-20(s0)

				/* It is possible that the event bits were updated between this
				task leaving the Blocked state and running again. */
				if( prvTestWaitCondition( uxReturn, uxBitsToWaitFor, xWaitForAllBits ) != pdFALSE )
c0007b48:	fc042603          	lw	a2,-64(s0)
c0007b4c:	fc842583          	lw	a1,-56(s0)
c0007b50:	fec42503          	lw	a0,-20(s0)
c0007b54:	448000ef          	jal	ra,c0007f9c <prvTestWaitCondition>
c0007b58:	00050793          	mv	a5,a0
c0007b5c:	02078463          	beqz	a5,c0007b84 <xEventGroupWaitBits+0x1fc>
				{
					if( xClearOnExit != pdFALSE )
c0007b60:	fc442783          	lw	a5,-60(s0)
c0007b64:	02078063          	beqz	a5,c0007b84 <xEventGroupWaitBits+0x1fc>
					{
						pxEventBits->uxEventBits &= ~uxBitsToWaitFor;
c0007b68:	fe442783          	lw	a5,-28(s0)
c0007b6c:	0007a703          	lw	a4,0(a5)
c0007b70:	fc842783          	lw	a5,-56(s0)
c0007b74:	fff7c793          	not	a5,a5
c0007b78:	00f77733          	and	a4,a4,a5
c0007b7c:	fe442783          	lw	a5,-28(s0)
c0007b80:	00e7a023          	sw	a4,0(a5)
				}
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}
				xTimeoutOccurred = pdTRUE;
c0007b84:	00100793          	li	a5,1
c0007b88:	fef42023          	sw	a5,-32(s0)
			}
			taskEXIT_CRITICAL();
c0007b8c:	e09fd0ef          	jal	ra,c0005994 <vTaskExitCritical>
		{
			/* The task unblocked because the bits were set. */
		}

		/* The task blocked so control bits may have been set. */
		uxReturn &= ~eventEVENT_BITS_CONTROL_BYTES;
c0007b90:	fec42703          	lw	a4,-20(s0)
c0007b94:	010007b7          	lui	a5,0x1000
c0007b98:	fff78793          	addi	a5,a5,-1 # ffffff <_DMEM_LENGTH+0x7fffff>
c0007b9c:	00f777b3          	and	a5,a4,a5
c0007ba0:	fef42623          	sw	a5,-20(s0)
	traceEVENT_GROUP_WAIT_BITS_END( xEventGroup, uxBitsToWaitFor, xTimeoutOccurred );

	/* Prevent compiler warnings when trace macros are not used. */
	( void ) xTimeoutOccurred;

	return uxReturn;
c0007ba4:	fec42783          	lw	a5,-20(s0)
}
c0007ba8:	00078513          	mv	a0,a5
c0007bac:	04c12083          	lw	ra,76(sp)
c0007bb0:	04812403          	lw	s0,72(sp)
c0007bb4:	05010113          	addi	sp,sp,80
c0007bb8:	00008067          	ret

c0007bbc <xEventGroupClearBits>:
/*-----------------------------------------------------------*/

EventBits_t xEventGroupClearBits( EventGroupHandle_t xEventGroup, const EventBits_t uxBitsToClear )
{
c0007bbc:	fd010113          	addi	sp,sp,-48
c0007bc0:	02112623          	sw	ra,44(sp)
c0007bc4:	02812423          	sw	s0,40(sp)
c0007bc8:	03010413          	addi	s0,sp,48
c0007bcc:	fca42e23          	sw	a0,-36(s0)
c0007bd0:	fcb42c23          	sw	a1,-40(s0)
EventGroup_t *pxEventBits = xEventGroup;
c0007bd4:	fdc42783          	lw	a5,-36(s0)
c0007bd8:	fef42623          	sw	a5,-20(s0)
EventBits_t uxReturn;

	/* Check the user is not attempting to clear the bits used by the kernel
	itself. */
	configASSERT( xEventGroup );
c0007bdc:	fdc42783          	lw	a5,-36(s0)
c0007be0:	00079863          	bnez	a5,c0007bf0 <xEventGroupClearBits+0x34>
c0007be4:	30047073          	csrci	mstatus,8
c0007be8:	00100073          	ebreak
c0007bec:	0000006f          	j	c0007bec <xEventGroupClearBits+0x30>
	configASSERT( ( uxBitsToClear & eventEVENT_BITS_CONTROL_BYTES ) == 0 );
c0007bf0:	fd842703          	lw	a4,-40(s0)
c0007bf4:	ff0007b7          	lui	a5,0xff000
c0007bf8:	00f777b3          	and	a5,a4,a5
c0007bfc:	00078863          	beqz	a5,c0007c0c <xEventGroupClearBits+0x50>
c0007c00:	30047073          	csrci	mstatus,8
c0007c04:	00100073          	ebreak
c0007c08:	0000006f          	j	c0007c08 <xEventGroupClearBits+0x4c>

	taskENTER_CRITICAL();
c0007c0c:	d35fd0ef          	jal	ra,c0005940 <vTaskEnterCritical>
	{
		traceEVENT_GROUP_CLEAR_BITS( xEventGroup, uxBitsToClear );

		/* The value returned is the event group value prior to the bits being
		cleared. */
		uxReturn = pxEventBits->uxEventBits;
c0007c10:	fec42783          	lw	a5,-20(s0)
c0007c14:	0007a783          	lw	a5,0(a5) # ff000000 <_end+0x36f7b780>
c0007c18:	fef42423          	sw	a5,-24(s0)

		/* Clear the bits. */
		pxEventBits->uxEventBits &= ~uxBitsToClear;
c0007c1c:	fec42783          	lw	a5,-20(s0)
c0007c20:	0007a703          	lw	a4,0(a5)
c0007c24:	fd842783          	lw	a5,-40(s0)
c0007c28:	fff7c793          	not	a5,a5
c0007c2c:	00f77733          	and	a4,a4,a5
c0007c30:	fec42783          	lw	a5,-20(s0)
c0007c34:	00e7a023          	sw	a4,0(a5)
	}
	taskEXIT_CRITICAL();
c0007c38:	d5dfd0ef          	jal	ra,c0005994 <vTaskExitCritical>

	return uxReturn;
c0007c3c:	fe842783          	lw	a5,-24(s0)
}
c0007c40:	00078513          	mv	a0,a5
c0007c44:	02c12083          	lw	ra,44(sp)
c0007c48:	02812403          	lw	s0,40(sp)
c0007c4c:	03010113          	addi	sp,sp,48
c0007c50:	00008067          	ret

c0007c54 <xEventGroupClearBitsFromISR>:
/*-----------------------------------------------------------*/

#if ( ( configUSE_TRACE_FACILITY == 1 ) && ( INCLUDE_xTimerPendFunctionCall == 1 ) && ( configUSE_TIMERS == 1 ) )

	BaseType_t xEventGroupClearBitsFromISR( EventGroupHandle_t xEventGroup, const EventBits_t uxBitsToClear )
	{
c0007c54:	fd010113          	addi	sp,sp,-48
c0007c58:	02112623          	sw	ra,44(sp)
c0007c5c:	02812423          	sw	s0,40(sp)
c0007c60:	03010413          	addi	s0,sp,48
c0007c64:	fca42e23          	sw	a0,-36(s0)
c0007c68:	fcb42c23          	sw	a1,-40(s0)
		BaseType_t xReturn;

		traceEVENT_GROUP_CLEAR_BITS_FROM_ISR( xEventGroup, uxBitsToClear );
		xReturn = xTimerPendFunctionCallFromISR( vEventGroupClearBitsCallback, ( void * ) xEventGroup, ( uint32_t ) uxBitsToClear, NULL ); /*lint !e9087 Can't avoid cast to void* as a generic callback function not specific to this use case. Callback casts back to original type so safe. */
c0007c6c:	00000693          	li	a3,0
c0007c70:	fd842603          	lw	a2,-40(s0)
c0007c74:	fdc42583          	lw	a1,-36(s0)
c0007c78:	00000517          	auipc	a0,0x0
c0007c7c:	2ec50513          	addi	a0,a0,748 # c0007f64 <vEventGroupClearBitsCallback>
c0007c80:	955ff0ef          	jal	ra,c00075d4 <xTimerPendFunctionCallFromISR>
c0007c84:	fea42623          	sw	a0,-20(s0)

		return xReturn;
c0007c88:	fec42783          	lw	a5,-20(s0)
	}
c0007c8c:	00078513          	mv	a0,a5
c0007c90:	02c12083          	lw	ra,44(sp)
c0007c94:	02812403          	lw	s0,40(sp)
c0007c98:	03010113          	addi	sp,sp,48
c0007c9c:	00008067          	ret

c0007ca0 <xEventGroupGetBitsFromISR>:

#endif
/*-----------------------------------------------------------*/

EventBits_t xEventGroupGetBitsFromISR( EventGroupHandle_t xEventGroup )
{
c0007ca0:	fd010113          	addi	sp,sp,-48
c0007ca4:	02812623          	sw	s0,44(sp)
c0007ca8:	03010413          	addi	s0,sp,48
c0007cac:	fca42e23          	sw	a0,-36(s0)
UBaseType_t uxSavedInterruptStatus;
EventGroup_t const * const pxEventBits = xEventGroup;
c0007cb0:	fdc42783          	lw	a5,-36(s0)
c0007cb4:	fef42623          	sw	a5,-20(s0)
EventBits_t uxReturn;

	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
c0007cb8:	fe042423          	sw	zero,-24(s0)
	{
		uxReturn = pxEventBits->uxEventBits;
c0007cbc:	fec42783          	lw	a5,-20(s0)
c0007cc0:	0007a783          	lw	a5,0(a5)
c0007cc4:	fef42223          	sw	a5,-28(s0)
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return uxReturn;
c0007cc8:	fe442783          	lw	a5,-28(s0)
} /*lint !e818 EventGroupHandle_t is a typedef used in other functions to so can't be pointer to const. */
c0007ccc:	00078513          	mv	a0,a5
c0007cd0:	02c12403          	lw	s0,44(sp)
c0007cd4:	03010113          	addi	sp,sp,48
c0007cd8:	00008067          	ret

c0007cdc <xEventGroupSetBits>:
/*-----------------------------------------------------------*/

EventBits_t xEventGroupSetBits( EventGroupHandle_t xEventGroup, const EventBits_t uxBitsToSet )
{
c0007cdc:	fb010113          	addi	sp,sp,-80
c0007ce0:	04112623          	sw	ra,76(sp)
c0007ce4:	04812423          	sw	s0,72(sp)
c0007ce8:	05010413          	addi	s0,sp,80
c0007cec:	faa42e23          	sw	a0,-68(s0)
c0007cf0:	fab42c23          	sw	a1,-72(s0)
ListItem_t *pxListItem, *pxNext;
ListItem_t const *pxListEnd;
List_t const * pxList;
EventBits_t uxBitsToClear = 0, uxBitsWaitedFor, uxControlBits;
c0007cf4:	fe042423          	sw	zero,-24(s0)
EventGroup_t *pxEventBits = xEventGroup;
c0007cf8:	fbc42783          	lw	a5,-68(s0)
c0007cfc:	fef42023          	sw	a5,-32(s0)
BaseType_t xMatchFound = pdFALSE;
c0007d00:	fe042223          	sw	zero,-28(s0)

	/* Check the user is not attempting to set the bits used by the kernel
	itself. */
	configASSERT( xEventGroup );
c0007d04:	fbc42783          	lw	a5,-68(s0)
c0007d08:	00079863          	bnez	a5,c0007d18 <xEventGroupSetBits+0x3c>
c0007d0c:	30047073          	csrci	mstatus,8
c0007d10:	00100073          	ebreak
c0007d14:	0000006f          	j	c0007d14 <xEventGroupSetBits+0x38>
	configASSERT( ( uxBitsToSet & eventEVENT_BITS_CONTROL_BYTES ) == 0 );
c0007d18:	fb842703          	lw	a4,-72(s0)
c0007d1c:	ff0007b7          	lui	a5,0xff000
c0007d20:	00f777b3          	and	a5,a4,a5
c0007d24:	00078863          	beqz	a5,c0007d34 <xEventGroupSetBits+0x58>
c0007d28:	30047073          	csrci	mstatus,8
c0007d2c:	00100073          	ebreak
c0007d30:	0000006f          	j	c0007d30 <xEventGroupSetBits+0x54>

	pxList = &( pxEventBits->xTasksWaitingForBits );
c0007d34:	fe042783          	lw	a5,-32(s0)
c0007d38:	00478793          	addi	a5,a5,4 # ff000004 <_end+0x36f7b784>
c0007d3c:	fcf42e23          	sw	a5,-36(s0)
	pxListEnd = listGET_END_MARKER( pxList ); /*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
c0007d40:	fdc42783          	lw	a5,-36(s0)
c0007d44:	00878793          	addi	a5,a5,8
c0007d48:	fcf42c23          	sw	a5,-40(s0)
	vTaskSuspendAll();
c0007d4c:	a11fb0ef          	jal	ra,c000375c <vTaskSuspendAll>
	{
		traceEVENT_GROUP_SET_BITS( xEventGroup, uxBitsToSet );

		pxListItem = listGET_HEAD_ENTRY( pxList );
c0007d50:	fdc42783          	lw	a5,-36(s0)
c0007d54:	00c7a783          	lw	a5,12(a5)
c0007d58:	fef42623          	sw	a5,-20(s0)

		/* Set the bits. */
		pxEventBits->uxEventBits |= uxBitsToSet;
c0007d5c:	fe042783          	lw	a5,-32(s0)
c0007d60:	0007a703          	lw	a4,0(a5)
c0007d64:	fb842783          	lw	a5,-72(s0)
c0007d68:	00f76733          	or	a4,a4,a5
c0007d6c:	fe042783          	lw	a5,-32(s0)
c0007d70:	00e7a023          	sw	a4,0(a5)

		/* See if the new bit value should unblock any tasks. */
		while( pxListItem != pxListEnd )
c0007d74:	0e00006f          	j	c0007e54 <xEventGroupSetBits+0x178>
		{
			pxNext = listGET_NEXT( pxListItem );
c0007d78:	fec42783          	lw	a5,-20(s0)
c0007d7c:	0047a783          	lw	a5,4(a5)
c0007d80:	fcf42a23          	sw	a5,-44(s0)
			uxBitsWaitedFor = listGET_LIST_ITEM_VALUE( pxListItem );
c0007d84:	fec42783          	lw	a5,-20(s0)
c0007d88:	0007a783          	lw	a5,0(a5)
c0007d8c:	fcf42823          	sw	a5,-48(s0)
			xMatchFound = pdFALSE;
c0007d90:	fe042223          	sw	zero,-28(s0)

			/* Split the bits waited for from the control bits. */
			uxControlBits = uxBitsWaitedFor & eventEVENT_BITS_CONTROL_BYTES;
c0007d94:	fd042703          	lw	a4,-48(s0)
c0007d98:	ff0007b7          	lui	a5,0xff000
c0007d9c:	00f777b3          	and	a5,a4,a5
c0007da0:	fcf42623          	sw	a5,-52(s0)
			uxBitsWaitedFor &= ~eventEVENT_BITS_CONTROL_BYTES;
c0007da4:	fd042703          	lw	a4,-48(s0)
c0007da8:	010007b7          	lui	a5,0x1000
c0007dac:	fff78793          	addi	a5,a5,-1 # ffffff <_DMEM_LENGTH+0x7fffff>
c0007db0:	00f777b3          	and	a5,a4,a5
c0007db4:	fcf42823          	sw	a5,-48(s0)

			if( ( uxControlBits & eventWAIT_FOR_ALL_BITS ) == ( EventBits_t ) 0 )
c0007db8:	fcc42703          	lw	a4,-52(s0)
c0007dbc:	040007b7          	lui	a5,0x4000
c0007dc0:	00f777b3          	and	a5,a4,a5
c0007dc4:	02079263          	bnez	a5,c0007de8 <xEventGroupSetBits+0x10c>
			{
				/* Just looking for single bit being set. */
				if( ( uxBitsWaitedFor & pxEventBits->uxEventBits ) != ( EventBits_t ) 0 )
c0007dc8:	fe042783          	lw	a5,-32(s0)
c0007dcc:	0007a703          	lw	a4,0(a5) # 4000000 <_DMEM_LENGTH+0x3800000>
c0007dd0:	fd042783          	lw	a5,-48(s0)
c0007dd4:	00f777b3          	and	a5,a4,a5
c0007dd8:	02078863          	beqz	a5,c0007e08 <xEventGroupSetBits+0x12c>
				{
					xMatchFound = pdTRUE;
c0007ddc:	00100793          	li	a5,1
c0007de0:	fef42223          	sw	a5,-28(s0)
c0007de4:	0240006f          	j	c0007e08 <xEventGroupSetBits+0x12c>
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}
			}
			else if( ( uxBitsWaitedFor & pxEventBits->uxEventBits ) == uxBitsWaitedFor )
c0007de8:	fe042783          	lw	a5,-32(s0)
c0007dec:	0007a703          	lw	a4,0(a5)
c0007df0:	fd042783          	lw	a5,-48(s0)
c0007df4:	00f777b3          	and	a5,a4,a5
c0007df8:	fd042703          	lw	a4,-48(s0)
c0007dfc:	00f71663          	bne	a4,a5,c0007e08 <xEventGroupSetBits+0x12c>
			{
				/* All bits are set. */
				xMatchFound = pdTRUE;
c0007e00:	00100793          	li	a5,1
c0007e04:	fef42223          	sw	a5,-28(s0)
			else
			{
				/* Need all bits to be set, but not all the bits were set. */
			}

			if( xMatchFound != pdFALSE )
c0007e08:	fe442783          	lw	a5,-28(s0)
c0007e0c:	04078063          	beqz	a5,c0007e4c <xEventGroupSetBits+0x170>
			{
				/* The bits match.  Should the bits be cleared on exit? */
				if( ( uxControlBits & eventCLEAR_EVENTS_ON_EXIT_BIT ) != ( EventBits_t ) 0 )
c0007e10:	fcc42703          	lw	a4,-52(s0)
c0007e14:	010007b7          	lui	a5,0x1000
c0007e18:	00f777b3          	and	a5,a4,a5
c0007e1c:	00078a63          	beqz	a5,c0007e30 <xEventGroupSetBits+0x154>
				{
					uxBitsToClear |= uxBitsWaitedFor;
c0007e20:	fe842703          	lw	a4,-24(s0)
c0007e24:	fd042783          	lw	a5,-48(s0)
c0007e28:	00f767b3          	or	a5,a4,a5
c0007e2c:	fef42423          	sw	a5,-24(s0)
				/* Store the actual event flag value in the task's event list
				item before removing the task from the event list.  The
				eventUNBLOCKED_DUE_TO_BIT_SET bit is set so the task knows
				that is was unblocked due to its required bits matching, rather
				than because it timed out. */
				vTaskRemoveFromUnorderedEventList( pxListItem, pxEventBits->uxEventBits | eventUNBLOCKED_DUE_TO_BIT_SET );
c0007e30:	fe042783          	lw	a5,-32(s0)
c0007e34:	0007a703          	lw	a4,0(a5) # 1000000 <_DMEM_LENGTH+0x800000>
c0007e38:	020007b7          	lui	a5,0x2000
c0007e3c:	00f767b3          	or	a5,a4,a5
c0007e40:	00078593          	mv	a1,a5
c0007e44:	fec42503          	lw	a0,-20(s0)
c0007e48:	ba1fc0ef          	jal	ra,c00049e8 <vTaskRemoveFromUnorderedEventList>
			}

			/* Move onto the next list item.  Note pxListItem->pxNext is not
			used here as the list item may have been removed from the event list
			and inserted into the ready/pending reading list. */
			pxListItem = pxNext;
c0007e4c:	fd442783          	lw	a5,-44(s0)
c0007e50:	fef42623          	sw	a5,-20(s0)
		while( pxListItem != pxListEnd )
c0007e54:	fec42703          	lw	a4,-20(s0)
c0007e58:	fd842783          	lw	a5,-40(s0)
c0007e5c:	f0f71ee3          	bne	a4,a5,c0007d78 <xEventGroupSetBits+0x9c>
		}

		/* Clear any bits that matched when the eventCLEAR_EVENTS_ON_EXIT_BIT
		bit was set in the control word. */
		pxEventBits->uxEventBits &= ~uxBitsToClear;
c0007e60:	fe042783          	lw	a5,-32(s0)
c0007e64:	0007a703          	lw	a4,0(a5) # 2000000 <_DMEM_LENGTH+0x1800000>
c0007e68:	fe842783          	lw	a5,-24(s0)
c0007e6c:	fff7c793          	not	a5,a5
c0007e70:	00f77733          	and	a4,a4,a5
c0007e74:	fe042783          	lw	a5,-32(s0)
c0007e78:	00e7a023          	sw	a4,0(a5)
	}
	( void ) xTaskResumeAll();
c0007e7c:	919fb0ef          	jal	ra,c0003794 <xTaskResumeAll>

	return pxEventBits->uxEventBits;
c0007e80:	fe042783          	lw	a5,-32(s0)
c0007e84:	0007a783          	lw	a5,0(a5)
}
c0007e88:	00078513          	mv	a0,a5
c0007e8c:	04c12083          	lw	ra,76(sp)
c0007e90:	04812403          	lw	s0,72(sp)
c0007e94:	05010113          	addi	sp,sp,80
c0007e98:	00008067          	ret

c0007e9c <vEventGroupDelete>:
/*-----------------------------------------------------------*/

void vEventGroupDelete( EventGroupHandle_t xEventGroup )
{
c0007e9c:	fd010113          	addi	sp,sp,-48
c0007ea0:	02112623          	sw	ra,44(sp)
c0007ea4:	02812423          	sw	s0,40(sp)
c0007ea8:	03010413          	addi	s0,sp,48
c0007eac:	fca42e23          	sw	a0,-36(s0)
EventGroup_t *pxEventBits = xEventGroup;
c0007eb0:	fdc42783          	lw	a5,-36(s0)
c0007eb4:	fef42623          	sw	a5,-20(s0)
const List_t *pxTasksWaitingForBits = &( pxEventBits->xTasksWaitingForBits );
c0007eb8:	fec42783          	lw	a5,-20(s0)
c0007ebc:	00478793          	addi	a5,a5,4
c0007ec0:	fef42423          	sw	a5,-24(s0)

	vTaskSuspendAll();
c0007ec4:	899fb0ef          	jal	ra,c000375c <vTaskSuspendAll>
	{
		traceEVENT_GROUP_DELETE( xEventGroup );

		while( listCURRENT_LIST_LENGTH( pxTasksWaitingForBits ) > ( UBaseType_t ) 0 )
c0007ec8:	0380006f          	j	c0007f00 <vEventGroupDelete+0x64>
		{
			/* Unblock the task, returning 0 as the event list is being deleted
			and cannot therefore have any bits set. */
			configASSERT( pxTasksWaitingForBits->xListEnd.pxNext != ( const ListItem_t * ) &( pxTasksWaitingForBits->xListEnd ) );
c0007ecc:	fe842783          	lw	a5,-24(s0)
c0007ed0:	00c7a703          	lw	a4,12(a5)
c0007ed4:	fe842783          	lw	a5,-24(s0)
c0007ed8:	00878793          	addi	a5,a5,8
c0007edc:	00f71863          	bne	a4,a5,c0007eec <vEventGroupDelete+0x50>
c0007ee0:	30047073          	csrci	mstatus,8
c0007ee4:	00100073          	ebreak
c0007ee8:	0000006f          	j	c0007ee8 <vEventGroupDelete+0x4c>
			vTaskRemoveFromUnorderedEventList( pxTasksWaitingForBits->xListEnd.pxNext, eventUNBLOCKED_DUE_TO_BIT_SET );
c0007eec:	fe842783          	lw	a5,-24(s0)
c0007ef0:	00c7a783          	lw	a5,12(a5)
c0007ef4:	020005b7          	lui	a1,0x2000
c0007ef8:	00078513          	mv	a0,a5
c0007efc:	aedfc0ef          	jal	ra,c00049e8 <vTaskRemoveFromUnorderedEventList>
		while( listCURRENT_LIST_LENGTH( pxTasksWaitingForBits ) > ( UBaseType_t ) 0 )
c0007f00:	fe842783          	lw	a5,-24(s0)
c0007f04:	0007a783          	lw	a5,0(a5)
c0007f08:	fc0792e3          	bnez	a5,c0007ecc <vEventGroupDelete+0x30>

		#if( ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) && ( configSUPPORT_STATIC_ALLOCATION == 0 ) )
		{
			/* The event group can only have been allocated dynamically - free
			it again. */
			vPortFree( pxEventBits );
c0007f0c:	fec42503          	lw	a0,-20(s0)
c0007f10:	628010ef          	jal	ra,c0009538 <vPortFree>
				mtCOVERAGE_TEST_MARKER();
			}
		}
		#endif /* configSUPPORT_DYNAMIC_ALLOCATION */
	}
	( void ) xTaskResumeAll();
c0007f14:	881fb0ef          	jal	ra,c0003794 <xTaskResumeAll>
}
c0007f18:	00000013          	nop
c0007f1c:	02c12083          	lw	ra,44(sp)
c0007f20:	02812403          	lw	s0,40(sp)
c0007f24:	03010113          	addi	sp,sp,48
c0007f28:	00008067          	ret

c0007f2c <vEventGroupSetBitsCallback>:
/*-----------------------------------------------------------*/

/* For internal use only - execute a 'set bits' command that was pended from
an interrupt. */
void vEventGroupSetBitsCallback( void *pvEventGroup, const uint32_t ulBitsToSet )
{
c0007f2c:	fe010113          	addi	sp,sp,-32
c0007f30:	00112e23          	sw	ra,28(sp)
c0007f34:	00812c23          	sw	s0,24(sp)
c0007f38:	02010413          	addi	s0,sp,32
c0007f3c:	fea42623          	sw	a0,-20(s0)
c0007f40:	feb42423          	sw	a1,-24(s0)
	( void ) xEventGroupSetBits( pvEventGroup, ( EventBits_t ) ulBitsToSet ); /*lint !e9079 Can't avoid cast to void* as a generic timer callback prototype. Callback casts back to original type so safe. */
c0007f44:	fe842583          	lw	a1,-24(s0)
c0007f48:	fec42503          	lw	a0,-20(s0)
c0007f4c:	d91ff0ef          	jal	ra,c0007cdc <xEventGroupSetBits>
}
c0007f50:	00000013          	nop
c0007f54:	01c12083          	lw	ra,28(sp)
c0007f58:	01812403          	lw	s0,24(sp)
c0007f5c:	02010113          	addi	sp,sp,32
c0007f60:	00008067          	ret

c0007f64 <vEventGroupClearBitsCallback>:
/*-----------------------------------------------------------*/

/* For internal use only - execute a 'clear bits' command that was pended from
an interrupt. */
void vEventGroupClearBitsCallback( void *pvEventGroup, const uint32_t ulBitsToClear )
{
c0007f64:	fe010113          	addi	sp,sp,-32
c0007f68:	00112e23          	sw	ra,28(sp)
c0007f6c:	00812c23          	sw	s0,24(sp)
c0007f70:	02010413          	addi	s0,sp,32
c0007f74:	fea42623          	sw	a0,-20(s0)
c0007f78:	feb42423          	sw	a1,-24(s0)
	( void ) xEventGroupClearBits( pvEventGroup, ( EventBits_t ) ulBitsToClear ); /*lint !e9079 Can't avoid cast to void* as a generic timer callback prototype. Callback casts back to original type so safe. */
c0007f7c:	fe842583          	lw	a1,-24(s0)
c0007f80:	fec42503          	lw	a0,-20(s0)
c0007f84:	c39ff0ef          	jal	ra,c0007bbc <xEventGroupClearBits>
}
c0007f88:	00000013          	nop
c0007f8c:	01c12083          	lw	ra,28(sp)
c0007f90:	01812403          	lw	s0,24(sp)
c0007f94:	02010113          	addi	sp,sp,32
c0007f98:	00008067          	ret

c0007f9c <prvTestWaitCondition>:
/*-----------------------------------------------------------*/

static BaseType_t prvTestWaitCondition( const EventBits_t uxCurrentEventBits, const EventBits_t uxBitsToWaitFor, const BaseType_t xWaitForAllBits )
{
c0007f9c:	fd010113          	addi	sp,sp,-48
c0007fa0:	02812623          	sw	s0,44(sp)
c0007fa4:	03010413          	addi	s0,sp,48
c0007fa8:	fca42e23          	sw	a0,-36(s0)
c0007fac:	fcb42c23          	sw	a1,-40(s0)
c0007fb0:	fcc42a23          	sw	a2,-44(s0)
BaseType_t xWaitConditionMet = pdFALSE;
c0007fb4:	fe042623          	sw	zero,-20(s0)

	if( xWaitForAllBits == pdFALSE )
c0007fb8:	fd442783          	lw	a5,-44(s0)
c0007fbc:	02079063          	bnez	a5,c0007fdc <prvTestWaitCondition+0x40>
	{
		/* Task only has to wait for one bit within uxBitsToWaitFor to be
		set.  Is one already set? */
		if( ( uxCurrentEventBits & uxBitsToWaitFor ) != ( EventBits_t ) 0 )
c0007fc0:	fdc42703          	lw	a4,-36(s0)
c0007fc4:	fd842783          	lw	a5,-40(s0)
c0007fc8:	00f777b3          	and	a5,a4,a5
c0007fcc:	02078663          	beqz	a5,c0007ff8 <prvTestWaitCondition+0x5c>
		{
			xWaitConditionMet = pdTRUE;
c0007fd0:	00100793          	li	a5,1
c0007fd4:	fef42623          	sw	a5,-20(s0)
c0007fd8:	0200006f          	j	c0007ff8 <prvTestWaitCondition+0x5c>
	}
	else
	{
		/* Task has to wait for all the bits in uxBitsToWaitFor to be set.
		Are they set already? */
		if( ( uxCurrentEventBits & uxBitsToWaitFor ) == uxBitsToWaitFor )
c0007fdc:	fdc42703          	lw	a4,-36(s0)
c0007fe0:	fd842783          	lw	a5,-40(s0)
c0007fe4:	00f777b3          	and	a5,a4,a5
c0007fe8:	fd842703          	lw	a4,-40(s0)
c0007fec:	00f71663          	bne	a4,a5,c0007ff8 <prvTestWaitCondition+0x5c>
		{
			xWaitConditionMet = pdTRUE;
c0007ff0:	00100793          	li	a5,1
c0007ff4:	fef42623          	sw	a5,-20(s0)
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}

	return xWaitConditionMet;
c0007ff8:	fec42783          	lw	a5,-20(s0)
}
c0007ffc:	00078513          	mv	a0,a5
c0008000:	02c12403          	lw	s0,44(sp)
c0008004:	03010113          	addi	sp,sp,48
c0008008:	00008067          	ret

c000800c <xEventGroupSetBitsFromISR>:
/*-----------------------------------------------------------*/

#if ( ( configUSE_TRACE_FACILITY == 1 ) && ( INCLUDE_xTimerPendFunctionCall == 1 ) && ( configUSE_TIMERS == 1 ) )

	BaseType_t xEventGroupSetBitsFromISR( EventGroupHandle_t xEventGroup, const EventBits_t uxBitsToSet, BaseType_t *pxHigherPriorityTaskWoken )
	{
c000800c:	fd010113          	addi	sp,sp,-48
c0008010:	02112623          	sw	ra,44(sp)
c0008014:	02812423          	sw	s0,40(sp)
c0008018:	03010413          	addi	s0,sp,48
c000801c:	fca42e23          	sw	a0,-36(s0)
c0008020:	fcb42c23          	sw	a1,-40(s0)
c0008024:	fcc42a23          	sw	a2,-44(s0)
	BaseType_t xReturn;

		traceEVENT_GROUP_SET_BITS_FROM_ISR( xEventGroup, uxBitsToSet );
		xReturn = xTimerPendFunctionCallFromISR( vEventGroupSetBitsCallback, ( void * ) xEventGroup, ( uint32_t ) uxBitsToSet, pxHigherPriorityTaskWoken ); /*lint !e9087 Can't avoid cast to void* as a generic callback function not specific to this use case. Callback casts back to original type so safe. */
c0008028:	fd442683          	lw	a3,-44(s0)
c000802c:	fd842603          	lw	a2,-40(s0)
c0008030:	fdc42583          	lw	a1,-36(s0)
c0008034:	00000517          	auipc	a0,0x0
c0008038:	ef850513          	addi	a0,a0,-264 # c0007f2c <vEventGroupSetBitsCallback>
c000803c:	d98ff0ef          	jal	ra,c00075d4 <xTimerPendFunctionCallFromISR>
c0008040:	fea42623          	sw	a0,-20(s0)

		return xReturn;
c0008044:	fec42783          	lw	a5,-20(s0)
	}
c0008048:	00078513          	mv	a0,a5
c000804c:	02c12083          	lw	ra,44(sp)
c0008050:	02812403          	lw	s0,40(sp)
c0008054:	03010113          	addi	sp,sp,48
c0008058:	00008067          	ret

c000805c <uxEventGroupGetNumber>:
/*-----------------------------------------------------------*/

#if (configUSE_TRACE_FACILITY == 1)

	UBaseType_t uxEventGroupGetNumber( void* xEventGroup )
	{
c000805c:	fd010113          	addi	sp,sp,-48
c0008060:	02812623          	sw	s0,44(sp)
c0008064:	03010413          	addi	s0,sp,48
c0008068:	fca42e23          	sw	a0,-36(s0)
	UBaseType_t xReturn;
	EventGroup_t const *pxEventBits = ( EventGroup_t * ) xEventGroup; /*lint !e9087 !e9079 EventGroupHandle_t is a pointer to an EventGroup_t, but EventGroupHandle_t is kept opaque outside of this file for data hiding purposes. */
c000806c:	fdc42783          	lw	a5,-36(s0)
c0008070:	fef42423          	sw	a5,-24(s0)

		if( xEventGroup == NULL )
c0008074:	fdc42783          	lw	a5,-36(s0)
c0008078:	00079663          	bnez	a5,c0008084 <uxEventGroupGetNumber+0x28>
		{
			xReturn = 0;
c000807c:	fe042623          	sw	zero,-20(s0)
c0008080:	0100006f          	j	c0008090 <uxEventGroupGetNumber+0x34>
		}
		else
		{
			xReturn = pxEventBits->uxEventGroupNumber;
c0008084:	fe842783          	lw	a5,-24(s0)
c0008088:	0187a783          	lw	a5,24(a5)
c000808c:	fef42623          	sw	a5,-20(s0)
		}

		return xReturn;
c0008090:	fec42783          	lw	a5,-20(s0)
	}
c0008094:	00078513          	mv	a0,a5
c0008098:	02c12403          	lw	s0,44(sp)
c000809c:	03010113          	addi	sp,sp,48
c00080a0:	00008067          	ret

c00080a4 <vEventGroupSetNumber>:
/*-----------------------------------------------------------*/

#if ( configUSE_TRACE_FACILITY == 1 )

	void vEventGroupSetNumber( void * xEventGroup, UBaseType_t uxEventGroupNumber )
	{
c00080a4:	fe010113          	addi	sp,sp,-32
c00080a8:	00812e23          	sw	s0,28(sp)
c00080ac:	02010413          	addi	s0,sp,32
c00080b0:	fea42623          	sw	a0,-20(s0)
c00080b4:	feb42423          	sw	a1,-24(s0)
		( ( EventGroup_t * ) xEventGroup )->uxEventGroupNumber = uxEventGroupNumber; /*lint !e9087 !e9079 EventGroupHandle_t is a pointer to an EventGroup_t, but EventGroupHandle_t is kept opaque outside of this file for data hiding purposes. */
c00080b8:	fec42783          	lw	a5,-20(s0)
c00080bc:	fe842703          	lw	a4,-24(s0)
c00080c0:	00e7ac23          	sw	a4,24(a5)
	}
c00080c4:	00000013          	nop
c00080c8:	01c12403          	lw	s0,28(sp)
c00080cc:	02010113          	addi	sp,sp,32
c00080d0:	00008067          	ret

c00080d4 <xStreamBufferGenericCreate>:
/*-----------------------------------------------------------*/

#if( configSUPPORT_DYNAMIC_ALLOCATION == 1 )

	StreamBufferHandle_t xStreamBufferGenericCreate( size_t xBufferSizeBytes, size_t xTriggerLevelBytes, BaseType_t xIsMessageBuffer )
	{
c00080d4:	fd010113          	addi	sp,sp,-48
c00080d8:	02112623          	sw	ra,44(sp)
c00080dc:	02812423          	sw	s0,40(sp)
c00080e0:	03010413          	addi	s0,sp,48
c00080e4:	fca42e23          	sw	a0,-36(s0)
c00080e8:	fcb42c23          	sw	a1,-40(s0)
c00080ec:	fcc42a23          	sw	a2,-44(s0)

		/* In case the stream buffer is going to be used as a message buffer
		(that is, it will hold discrete messages with a little meta data that
		says how big the next message is) check the buffer will be large enough
		to hold at least one message. */
		if( xIsMessageBuffer == pdTRUE )
c00080f0:	fd442703          	lw	a4,-44(s0)
c00080f4:	00100793          	li	a5,1
c00080f8:	02f71263          	bne	a4,a5,c000811c <xStreamBufferGenericCreate+0x48>
		{
			/* Is a message buffer but not statically allocated. */
			ucFlags = sbFLAGS_IS_MESSAGE_BUFFER;
c00080fc:	00100793          	li	a5,1
c0008100:	fef407a3          	sb	a5,-17(s0)
			configASSERT( xBufferSizeBytes > sbBYTES_TO_STORE_MESSAGE_LENGTH );
c0008104:	fdc42703          	lw	a4,-36(s0)
c0008108:	00400793          	li	a5,4
c000810c:	02e7e463          	bltu	a5,a4,c0008134 <xStreamBufferGenericCreate+0x60>
c0008110:	30047073          	csrci	mstatus,8
c0008114:	00100073          	ebreak
c0008118:	0000006f          	j	c0008118 <xStreamBufferGenericCreate+0x44>
		}
		else
		{
			/* Not a message buffer and not statically allocated. */
			ucFlags = 0;
c000811c:	fe0407a3          	sb	zero,-17(s0)
			configASSERT( xBufferSizeBytes > 0 );
c0008120:	fdc42783          	lw	a5,-36(s0)
c0008124:	00079863          	bnez	a5,c0008134 <xStreamBufferGenericCreate+0x60>
c0008128:	30047073          	csrci	mstatus,8
c000812c:	00100073          	ebreak
c0008130:	0000006f          	j	c0008130 <xStreamBufferGenericCreate+0x5c>
		}
		configASSERT( xTriggerLevelBytes <= xBufferSizeBytes );
c0008134:	fd842703          	lw	a4,-40(s0)
c0008138:	fdc42783          	lw	a5,-36(s0)
c000813c:	00e7f863          	bgeu	a5,a4,c000814c <xStreamBufferGenericCreate+0x78>
c0008140:	30047073          	csrci	mstatus,8
c0008144:	00100073          	ebreak
c0008148:	0000006f          	j	c0008148 <xStreamBufferGenericCreate+0x74>

		/* A trigger level of 0 would cause a waiting task to unblock even when
		the buffer was empty. */
		if( xTriggerLevelBytes == ( size_t ) 0 )
c000814c:	fd842783          	lw	a5,-40(s0)
c0008150:	00079663          	bnez	a5,c000815c <xStreamBufferGenericCreate+0x88>
		{
			xTriggerLevelBytes = ( size_t ) 1;
c0008154:	00100793          	li	a5,1
c0008158:	fcf42c23          	sw	a5,-40(s0)
		and the buffer follows immediately after.  The requested size is
		incremented so the free space is returned as the user would expect -
		this is a quirk of the implementation that means otherwise the free
		space would be reported as one byte smaller than would be logically
		expected. */
		xBufferSizeBytes++;
c000815c:	fdc42783          	lw	a5,-36(s0)
c0008160:	00178793          	addi	a5,a5,1
c0008164:	fcf42e23          	sw	a5,-36(s0)
		pucAllocatedMemory = ( uint8_t * ) pvPortMalloc( xBufferSizeBytes + sizeof( StreamBuffer_t ) ); /*lint !e9079 malloc() only returns void*. */
c0008168:	fdc42783          	lw	a5,-36(s0)
c000816c:	02478793          	addi	a5,a5,36
c0008170:	00078513          	mv	a0,a5
c0008174:	140010ef          	jal	ra,c00092b4 <pvPortMalloc>
c0008178:	fea42423          	sw	a0,-24(s0)

		if( pucAllocatedMemory != NULL )
c000817c:	fe842783          	lw	a5,-24(s0)
c0008180:	02078263          	beqz	a5,c00081a4 <xStreamBufferGenericCreate+0xd0>
		{
			#pragma GCC diagnostic ignored "-Wcast-align"
			prvInitialiseNewStreamBuffer( ( StreamBuffer_t * ) pucAllocatedMemory, /* Structure at the start of the allocated memory. */ /*lint !e9087 Safe cast as allocated memory is aligned. */ /*lint !e826 Area is not too small and alignment is guaranteed provided malloc() behaves as expected and returns aligned buffer. */
c0008184:	fe842783          	lw	a5,-24(s0)
c0008188:	02478793          	addi	a5,a5,36
c000818c:	fef44703          	lbu	a4,-17(s0)
c0008190:	fd842683          	lw	a3,-40(s0)
c0008194:	fdc42603          	lw	a2,-36(s0)
c0008198:	00078593          	mv	a1,a5
c000819c:	fe842503          	lw	a0,-24(s0)
c00081a0:	7e1000ef          	jal	ra,c0009180 <prvInitialiseNewStreamBuffer>
		else
		{
			traceSTREAM_BUFFER_CREATE_FAILED( xIsMessageBuffer );
		}
		#pragma GCC diagnostic ignored "-Wcast-align"
		return ( StreamBufferHandle_t ) pucAllocatedMemory; /*lint !e9087 !e826 Safe cast as allocated memory is aligned. */
c00081a4:	fe842783          	lw	a5,-24(s0)
	}
c00081a8:	00078513          	mv	a0,a5
c00081ac:	02c12083          	lw	ra,44(sp)
c00081b0:	02812403          	lw	s0,40(sp)
c00081b4:	03010113          	addi	sp,sp,48
c00081b8:	00008067          	ret

c00081bc <vStreamBufferDelete>:

#endif /* ( configSUPPORT_STATIC_ALLOCATION == 1 ) */
/*-----------------------------------------------------------*/

void vStreamBufferDelete( StreamBufferHandle_t xStreamBuffer )
{
c00081bc:	fd010113          	addi	sp,sp,-48
c00081c0:	02112623          	sw	ra,44(sp)
c00081c4:	02812423          	sw	s0,40(sp)
c00081c8:	03010413          	addi	s0,sp,48
c00081cc:	fca42e23          	sw	a0,-36(s0)
StreamBuffer_t * pxStreamBuffer = xStreamBuffer;
c00081d0:	fdc42783          	lw	a5,-36(s0)
c00081d4:	fef42623          	sw	a5,-20(s0)

	configASSERT( pxStreamBuffer );
c00081d8:	fec42783          	lw	a5,-20(s0)
c00081dc:	00079863          	bnez	a5,c00081ec <vStreamBufferDelete+0x30>
c00081e0:	30047073          	csrci	mstatus,8
c00081e4:	00100073          	ebreak
c00081e8:	0000006f          	j	c00081e8 <vStreamBufferDelete+0x2c>

	traceSTREAM_BUFFER_DELETE( xStreamBuffer );

	if( ( pxStreamBuffer->ucFlags & sbFLAGS_IS_STATICALLY_ALLOCATED ) == ( uint8_t ) pdFALSE )
c00081ec:	fec42783          	lw	a5,-20(s0)
c00081f0:	01c7c783          	lbu	a5,28(a5)
c00081f4:	0027f793          	andi	a5,a5,2
c00081f8:	00079863          	bnez	a5,c0008208 <vStreamBufferDelete+0x4c>
	{
		#if( configSUPPORT_DYNAMIC_ALLOCATION == 1 )
		{
			/* Both the structure and the buffer were allocated using a single call
			to pvPortMalloc(), hence only one call to vPortFree() is required. */
			vPortFree( ( void * ) pxStreamBuffer ); /*lint !e9087 Standard free() semantics require void *, plus pxStreamBuffer was allocated by pvPortMalloc(). */
c00081fc:	fec42503          	lw	a0,-20(s0)
c0008200:	338010ef          	jal	ra,c0009538 <vPortFree>
	{
		/* The structure and buffer were not allocated dynamically and cannot be
		freed - just scrub the structure so future use will assert. */
		( void ) memset( pxStreamBuffer, 0x00, sizeof( StreamBuffer_t ) );
	}
}
c0008204:	0140006f          	j	c0008218 <vStreamBufferDelete+0x5c>
		( void ) memset( pxStreamBuffer, 0x00, sizeof( StreamBuffer_t ) );
c0008208:	02400613          	li	a2,36
c000820c:	00000593          	li	a1,0
c0008210:	fec42503          	lw	a0,-20(s0)
c0008214:	275150ef          	jal	ra,c001dc88 <memset>
}
c0008218:	00000013          	nop
c000821c:	02c12083          	lw	ra,44(sp)
c0008220:	02812403          	lw	s0,40(sp)
c0008224:	03010113          	addi	sp,sp,48
c0008228:	00008067          	ret

c000822c <xStreamBufferReset>:
/*-----------------------------------------------------------*/

BaseType_t xStreamBufferReset( StreamBufferHandle_t xStreamBuffer )
{
c000822c:	fd010113          	addi	sp,sp,-48
c0008230:	02112623          	sw	ra,44(sp)
c0008234:	02812423          	sw	s0,40(sp)
c0008238:	03010413          	addi	s0,sp,48
c000823c:	fca42e23          	sw	a0,-36(s0)
StreamBuffer_t * const pxStreamBuffer = xStreamBuffer;
c0008240:	fdc42783          	lw	a5,-36(s0)
c0008244:	fef42423          	sw	a5,-24(s0)
BaseType_t xReturn = pdFAIL;
c0008248:	fe042623          	sw	zero,-20(s0)

#if( configUSE_TRACE_FACILITY == 1 )
	UBaseType_t uxStreamBufferNumber;
#endif

	configASSERT( pxStreamBuffer );
c000824c:	fe842783          	lw	a5,-24(s0)
c0008250:	00079863          	bnez	a5,c0008260 <xStreamBufferReset+0x34>
c0008254:	30047073          	csrci	mstatus,8
c0008258:	00100073          	ebreak
c000825c:	0000006f          	j	c000825c <xStreamBufferReset+0x30>

	#if( configUSE_TRACE_FACILITY == 1 )
	{
		/* Store the stream buffer number so it can be restored after the
		reset. */
		uxStreamBufferNumber = pxStreamBuffer->uxStreamBufferNumber;
c0008260:	fe842783          	lw	a5,-24(s0)
c0008264:	0207a783          	lw	a5,32(a5)
c0008268:	fef42223          	sw	a5,-28(s0)
	}
	#endif

	/* Can only reset a message buffer if there are no tasks blocked on it. */
	taskENTER_CRITICAL();
c000826c:	ed4fd0ef          	jal	ra,c0005940 <vTaskEnterCritical>
	{
		if( pxStreamBuffer->xTaskWaitingToReceive == NULL )
c0008270:	fe842783          	lw	a5,-24(s0)
c0008274:	0107a783          	lw	a5,16(a5)
c0008278:	04079863          	bnez	a5,c00082c8 <xStreamBufferReset+0x9c>
		{
			if( pxStreamBuffer->xTaskWaitingToSend == NULL )
c000827c:	fe842783          	lw	a5,-24(s0)
c0008280:	0147a783          	lw	a5,20(a5)
c0008284:	04079263          	bnez	a5,c00082c8 <xStreamBufferReset+0x9c>
			{
				prvInitialiseNewStreamBuffer( pxStreamBuffer,
c0008288:	fe842783          	lw	a5,-24(s0)
c000828c:	0187a583          	lw	a1,24(a5)
c0008290:	fe842783          	lw	a5,-24(s0)
c0008294:	0087a603          	lw	a2,8(a5)
c0008298:	fe842783          	lw	a5,-24(s0)
c000829c:	00c7a683          	lw	a3,12(a5)
c00082a0:	fe842783          	lw	a5,-24(s0)
c00082a4:	01c7c783          	lbu	a5,28(a5)
c00082a8:	00078713          	mv	a4,a5
c00082ac:	fe842503          	lw	a0,-24(s0)
c00082b0:	6d1000ef          	jal	ra,c0009180 <prvInitialiseNewStreamBuffer>
											  pxStreamBuffer->pucBuffer,
											  pxStreamBuffer->xLength,
											  pxStreamBuffer->xTriggerLevelBytes,
											  pxStreamBuffer->ucFlags );
				xReturn = pdPASS;
c00082b4:	00100793          	li	a5,1
c00082b8:	fef42623          	sw	a5,-20(s0)

				#if( configUSE_TRACE_FACILITY == 1 )
				{
					pxStreamBuffer->uxStreamBufferNumber = uxStreamBufferNumber;
c00082bc:	fe842783          	lw	a5,-24(s0)
c00082c0:	fe442703          	lw	a4,-28(s0)
c00082c4:	02e7a023          	sw	a4,32(a5)

				traceSTREAM_BUFFER_RESET( xStreamBuffer );
			}
		}
	}
	taskEXIT_CRITICAL();
c00082c8:	eccfd0ef          	jal	ra,c0005994 <vTaskExitCritical>

	return xReturn;
c00082cc:	fec42783          	lw	a5,-20(s0)
}
c00082d0:	00078513          	mv	a0,a5
c00082d4:	02c12083          	lw	ra,44(sp)
c00082d8:	02812403          	lw	s0,40(sp)
c00082dc:	03010113          	addi	sp,sp,48
c00082e0:	00008067          	ret

c00082e4 <xStreamBufferSetTriggerLevel>:
/*-----------------------------------------------------------*/

BaseType_t xStreamBufferSetTriggerLevel( StreamBufferHandle_t xStreamBuffer, size_t xTriggerLevel )
{
c00082e4:	fd010113          	addi	sp,sp,-48
c00082e8:	02812623          	sw	s0,44(sp)
c00082ec:	03010413          	addi	s0,sp,48
c00082f0:	fca42e23          	sw	a0,-36(s0)
c00082f4:	fcb42c23          	sw	a1,-40(s0)
StreamBuffer_t * const pxStreamBuffer = xStreamBuffer;
c00082f8:	fdc42783          	lw	a5,-36(s0)
c00082fc:	fef42423          	sw	a5,-24(s0)
BaseType_t xReturn;

	configASSERT( pxStreamBuffer );
c0008300:	fe842783          	lw	a5,-24(s0)
c0008304:	00079863          	bnez	a5,c0008314 <xStreamBufferSetTriggerLevel+0x30>
c0008308:	30047073          	csrci	mstatus,8
c000830c:	00100073          	ebreak
c0008310:	0000006f          	j	c0008310 <xStreamBufferSetTriggerLevel+0x2c>

	/* It is not valid for the trigger level to be 0. */
	if( xTriggerLevel == ( size_t ) 0 )
c0008314:	fd842783          	lw	a5,-40(s0)
c0008318:	00079663          	bnez	a5,c0008324 <xStreamBufferSetTriggerLevel+0x40>
	{
		xTriggerLevel = ( size_t ) 1;
c000831c:	00100793          	li	a5,1
c0008320:	fcf42c23          	sw	a5,-40(s0)
	}

	/* The trigger level is the number of bytes that must be in the stream
	buffer before a task that is waiting for data is unblocked. */
	if( xTriggerLevel <= pxStreamBuffer->xLength )
c0008324:	fe842783          	lw	a5,-24(s0)
c0008328:	0087a783          	lw	a5,8(a5)
c000832c:	fd842703          	lw	a4,-40(s0)
c0008330:	00e7ee63          	bltu	a5,a4,c000834c <xStreamBufferSetTriggerLevel+0x68>
	{
		pxStreamBuffer->xTriggerLevelBytes = xTriggerLevel;
c0008334:	fe842783          	lw	a5,-24(s0)
c0008338:	fd842703          	lw	a4,-40(s0)
c000833c:	00e7a623          	sw	a4,12(a5)
		xReturn = pdPASS;
c0008340:	00100793          	li	a5,1
c0008344:	fef42623          	sw	a5,-20(s0)
c0008348:	0080006f          	j	c0008350 <xStreamBufferSetTriggerLevel+0x6c>
	}
	else
	{
		xReturn = pdFALSE;
c000834c:	fe042623          	sw	zero,-20(s0)
	}

	return xReturn;
c0008350:	fec42783          	lw	a5,-20(s0)
}
c0008354:	00078513          	mv	a0,a5
c0008358:	02c12403          	lw	s0,44(sp)
c000835c:	03010113          	addi	sp,sp,48
c0008360:	00008067          	ret

c0008364 <xStreamBufferSpacesAvailable>:
/*-----------------------------------------------------------*/

size_t xStreamBufferSpacesAvailable( StreamBufferHandle_t xStreamBuffer )
{
c0008364:	fd010113          	addi	sp,sp,-48
c0008368:	02812623          	sw	s0,44(sp)
c000836c:	03010413          	addi	s0,sp,48
c0008370:	fca42e23          	sw	a0,-36(s0)
const StreamBuffer_t * const pxStreamBuffer = xStreamBuffer;
c0008374:	fdc42783          	lw	a5,-36(s0)
c0008378:	fef42423          	sw	a5,-24(s0)
size_t xSpace;

	configASSERT( pxStreamBuffer );
c000837c:	fe842783          	lw	a5,-24(s0)
c0008380:	00079863          	bnez	a5,c0008390 <xStreamBufferSpacesAvailable+0x2c>
c0008384:	30047073          	csrci	mstatus,8
c0008388:	00100073          	ebreak
c000838c:	0000006f          	j	c000838c <xStreamBufferSpacesAvailable+0x28>

	xSpace = pxStreamBuffer->xLength + pxStreamBuffer->xTail;
c0008390:	fe842783          	lw	a5,-24(s0)
c0008394:	0087a703          	lw	a4,8(a5)
c0008398:	fe842783          	lw	a5,-24(s0)
c000839c:	0007a783          	lw	a5,0(a5)
c00083a0:	00f707b3          	add	a5,a4,a5
c00083a4:	fef42623          	sw	a5,-20(s0)
	xSpace -= pxStreamBuffer->xHead;
c00083a8:	fe842783          	lw	a5,-24(s0)
c00083ac:	0047a783          	lw	a5,4(a5)
c00083b0:	fec42703          	lw	a4,-20(s0)
c00083b4:	40f707b3          	sub	a5,a4,a5
c00083b8:	fef42623          	sw	a5,-20(s0)
	xSpace -= ( size_t ) 1;
c00083bc:	fec42783          	lw	a5,-20(s0)
c00083c0:	fff78793          	addi	a5,a5,-1
c00083c4:	fef42623          	sw	a5,-20(s0)

	if( xSpace >= pxStreamBuffer->xLength )
c00083c8:	fe842783          	lw	a5,-24(s0)
c00083cc:	0087a783          	lw	a5,8(a5)
c00083d0:	fec42703          	lw	a4,-20(s0)
c00083d4:	00f76c63          	bltu	a4,a5,c00083ec <xStreamBufferSpacesAvailable+0x88>
	{
		xSpace -= pxStreamBuffer->xLength;
c00083d8:	fe842783          	lw	a5,-24(s0)
c00083dc:	0087a783          	lw	a5,8(a5)
c00083e0:	fec42703          	lw	a4,-20(s0)
c00083e4:	40f707b3          	sub	a5,a4,a5
c00083e8:	fef42623          	sw	a5,-20(s0)
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	return xSpace;
c00083ec:	fec42783          	lw	a5,-20(s0)
}
c00083f0:	00078513          	mv	a0,a5
c00083f4:	02c12403          	lw	s0,44(sp)
c00083f8:	03010113          	addi	sp,sp,48
c00083fc:	00008067          	ret

c0008400 <xStreamBufferBytesAvailable>:
/*-----------------------------------------------------------*/

size_t xStreamBufferBytesAvailable( StreamBufferHandle_t xStreamBuffer )
{
c0008400:	fd010113          	addi	sp,sp,-48
c0008404:	02112623          	sw	ra,44(sp)
c0008408:	02812423          	sw	s0,40(sp)
c000840c:	03010413          	addi	s0,sp,48
c0008410:	fca42e23          	sw	a0,-36(s0)
const StreamBuffer_t * const pxStreamBuffer = xStreamBuffer;
c0008414:	fdc42783          	lw	a5,-36(s0)
c0008418:	fef42623          	sw	a5,-20(s0)
size_t xReturn;

	configASSERT( pxStreamBuffer );
c000841c:	fec42783          	lw	a5,-20(s0)
c0008420:	00079863          	bnez	a5,c0008430 <xStreamBufferBytesAvailable+0x30>
c0008424:	30047073          	csrci	mstatus,8
c0008428:	00100073          	ebreak
c000842c:	0000006f          	j	c000842c <xStreamBufferBytesAvailable+0x2c>

	xReturn = prvBytesInBuffer( pxStreamBuffer );
c0008430:	fec42503          	lw	a0,-20(s0)
c0008434:	4d9000ef          	jal	ra,c000910c <prvBytesInBuffer>
c0008438:	fea42423          	sw	a0,-24(s0)
	return xReturn;
c000843c:	fe842783          	lw	a5,-24(s0)
}
c0008440:	00078513          	mv	a0,a5
c0008444:	02c12083          	lw	ra,44(sp)
c0008448:	02812403          	lw	s0,40(sp)
c000844c:	03010113          	addi	sp,sp,48
c0008450:	00008067          	ret

c0008454 <xStreamBufferSend>:

size_t xStreamBufferSend( StreamBufferHandle_t xStreamBuffer,
						  const void *pvTxData,
						  size_t xDataLengthBytes,
						  TickType_t xTicksToWait )
{
c0008454:	fc010113          	addi	sp,sp,-64
c0008458:	02112e23          	sw	ra,60(sp)
c000845c:	02812c23          	sw	s0,56(sp)
c0008460:	04010413          	addi	s0,sp,64
c0008464:	fca42623          	sw	a0,-52(s0)
c0008468:	fcb42423          	sw	a1,-56(s0)
c000846c:	fcc42223          	sw	a2,-60(s0)
c0008470:	fcd42023          	sw	a3,-64(s0)
StreamBuffer_t * const pxStreamBuffer = xStreamBuffer;
c0008474:	fcc42783          	lw	a5,-52(s0)
c0008478:	fef42223          	sw	a5,-28(s0)
size_t xReturn, xSpace = 0;
c000847c:	fe042623          	sw	zero,-20(s0)
size_t xRequiredSpace = xDataLengthBytes;
c0008480:	fc442783          	lw	a5,-60(s0)
c0008484:	fef42423          	sw	a5,-24(s0)
TimeOut_t xTimeOut;

	configASSERT( pvTxData );
c0008488:	fc842783          	lw	a5,-56(s0)
c000848c:	00079863          	bnez	a5,c000849c <xStreamBufferSend+0x48>
c0008490:	30047073          	csrci	mstatus,8
c0008494:	00100073          	ebreak
c0008498:	0000006f          	j	c0008498 <xStreamBufferSend+0x44>
	configASSERT( pxStreamBuffer );
c000849c:	fe442783          	lw	a5,-28(s0)
c00084a0:	00079863          	bnez	a5,c00084b0 <xStreamBufferSend+0x5c>
c00084a4:	30047073          	csrci	mstatus,8
c00084a8:	00100073          	ebreak
c00084ac:	0000006f          	j	c00084ac <xStreamBufferSend+0x58>

	/* This send function is used to write to both message buffers and stream
	buffers.  If this is a message buffer then the space needed must be
	increased by the amount of bytes needed to store the length of the
	message. */
	if( ( pxStreamBuffer->ucFlags & sbFLAGS_IS_MESSAGE_BUFFER ) != ( uint8_t ) 0 )
c00084b0:	fe442783          	lw	a5,-28(s0)
c00084b4:	01c7c783          	lbu	a5,28(a5)
c00084b8:	0017f793          	andi	a5,a5,1
c00084bc:	02078463          	beqz	a5,c00084e4 <xStreamBufferSend+0x90>
	{
		xRequiredSpace += sbBYTES_TO_STORE_MESSAGE_LENGTH;
c00084c0:	fe842783          	lw	a5,-24(s0)
c00084c4:	00478793          	addi	a5,a5,4
c00084c8:	fef42423          	sw	a5,-24(s0)

		/* Overflow? */
		configASSERT( xRequiredSpace > xDataLengthBytes );
c00084cc:	fe842703          	lw	a4,-24(s0)
c00084d0:	fc442783          	lw	a5,-60(s0)
c00084d4:	00e7e863          	bltu	a5,a4,c00084e4 <xStreamBufferSend+0x90>
c00084d8:	30047073          	csrci	mstatus,8
c00084dc:	00100073          	ebreak
c00084e0:	0000006f          	j	c00084e0 <xStreamBufferSend+0x8c>
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	if( xTicksToWait != ( TickType_t ) 0 )
c00084e4:	fc042783          	lw	a5,-64(s0)
c00084e8:	0a078463          	beqz	a5,c0008590 <xStreamBufferSend+0x13c>
	{
		vTaskSetTimeOutState( &xTimeOut );
c00084ec:	fd840793          	addi	a5,s0,-40
c00084f0:	00078513          	mv	a0,a5
c00084f4:	e18fc0ef          	jal	ra,c0004b0c <vTaskSetTimeOutState>

		do
		{
			/* Wait until the required number of bytes are free in the message
			buffer. */
			taskENTER_CRITICAL();
c00084f8:	c48fd0ef          	jal	ra,c0005940 <vTaskEnterCritical>
			{
				xSpace = xStreamBufferSpacesAvailable( pxStreamBuffer );
c00084fc:	fe442503          	lw	a0,-28(s0)
c0008500:	e65ff0ef          	jal	ra,c0008364 <xStreamBufferSpacesAvailable>
c0008504:	fea42623          	sw	a0,-20(s0)

				if( xSpace < xRequiredSpace )
c0008508:	fec42703          	lw	a4,-20(s0)
c000850c:	fe842783          	lw	a5,-24(s0)
c0008510:	02f77c63          	bgeu	a4,a5,c0008548 <xStreamBufferSend+0xf4>
				{
					/* Clear notification state as going to wait for space. */
					( void ) xTaskNotifyStateClear( NULL );
c0008514:	00000513          	li	a0,0
c0008518:	82cfe0ef          	jal	ra,c0006544 <xTaskNotifyStateClear>

					/* Should only be one writer. */
					configASSERT( pxStreamBuffer->xTaskWaitingToSend == NULL );
c000851c:	fe442783          	lw	a5,-28(s0)
c0008520:	0147a783          	lw	a5,20(a5)
c0008524:	00078863          	beqz	a5,c0008534 <xStreamBufferSend+0xe0>
c0008528:	30047073          	csrci	mstatus,8
c000852c:	00100073          	ebreak
c0008530:	0000006f          	j	c0008530 <xStreamBufferSend+0xdc>
					pxStreamBuffer->xTaskWaitingToSend = xTaskGetCurrentTaskHandle();
c0008534:	e31fc0ef          	jal	ra,c0005364 <xTaskGetCurrentTaskHandle>
c0008538:	00050713          	mv	a4,a0
c000853c:	fe442783          	lw	a5,-28(s0)
c0008540:	00e7aa23          	sw	a4,20(a5)
c0008544:	00c0006f          	j	c0008550 <xStreamBufferSend+0xfc>
				}
				else
				{
					taskEXIT_CRITICAL();
c0008548:	c4cfd0ef          	jal	ra,c0005994 <vTaskExitCritical>
					break;
c000854c:	0440006f          	j	c0008590 <xStreamBufferSend+0x13c>
				}
			}
			taskEXIT_CRITICAL();
c0008550:	c44fd0ef          	jal	ra,c0005994 <vTaskExitCritical>

			traceBLOCKING_ON_STREAM_BUFFER_SEND( xStreamBuffer );
			( void ) xTaskNotifyWait( ( uint32_t ) 0, ( uint32_t ) 0, NULL, xTicksToWait );
c0008554:	fc042783          	lw	a5,-64(s0)
c0008558:	00078693          	mv	a3,a5
c000855c:	00000613          	li	a2,0
c0008560:	00000593          	li	a1,0
c0008564:	00000513          	li	a0,0
c0008568:	8c9fd0ef          	jal	ra,c0005e30 <xTaskNotifyWait>
			pxStreamBuffer->xTaskWaitingToSend = NULL;
c000856c:	fe442783          	lw	a5,-28(s0)
c0008570:	0007aa23          	sw	zero,20(a5)

		} while( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE );
c0008574:	fc040713          	addi	a4,s0,-64
c0008578:	fd840793          	addi	a5,s0,-40
c000857c:	00070593          	mv	a1,a4
c0008580:	00078513          	mv	a0,a5
c0008584:	e3cfc0ef          	jal	ra,c0004bc0 <xTaskCheckForTimeOut>
c0008588:	00050793          	mv	a5,a0
c000858c:	f60786e3          	beqz	a5,c00084f8 <xStreamBufferSend+0xa4>
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	if( xSpace == ( size_t ) 0 )
c0008590:	fec42783          	lw	a5,-20(s0)
c0008594:	00079863          	bnez	a5,c00085a4 <xStreamBufferSend+0x150>
	{
		xSpace = xStreamBufferSpacesAvailable( pxStreamBuffer );
c0008598:	fe442503          	lw	a0,-28(s0)
c000859c:	dc9ff0ef          	jal	ra,c0008364 <xStreamBufferSpacesAvailable>
c00085a0:	fea42623          	sw	a0,-20(s0)
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	xReturn = prvWriteMessageToBuffer( pxStreamBuffer, pvTxData, xDataLengthBytes, xSpace, xRequiredSpace );
c00085a4:	fe842703          	lw	a4,-24(s0)
c00085a8:	fec42683          	lw	a3,-20(s0)
c00085ac:	fc442603          	lw	a2,-60(s0)
c00085b0:	fc842583          	lw	a1,-56(s0)
c00085b4:	fe442503          	lw	a0,-28(s0)
c00085b8:	184000ef          	jal	ra,c000873c <prvWriteMessageToBuffer>
c00085bc:	fea42023          	sw	a0,-32(s0)

	if( xReturn > ( size_t ) 0 )
c00085c0:	fe042783          	lw	a5,-32(s0)
c00085c4:	04078a63          	beqz	a5,c0008618 <xStreamBufferSend+0x1c4>
	{
		traceSTREAM_BUFFER_SEND( xStreamBuffer, xReturn );

		/* Was a task waiting for the data? */
		if( prvBytesInBuffer( pxStreamBuffer ) >= pxStreamBuffer->xTriggerLevelBytes )
c00085c8:	fe442503          	lw	a0,-28(s0)
c00085cc:	341000ef          	jal	ra,c000910c <prvBytesInBuffer>
c00085d0:	00050713          	mv	a4,a0
c00085d4:	fe442783          	lw	a5,-28(s0)
c00085d8:	00c7a783          	lw	a5,12(a5)
c00085dc:	02f76e63          	bltu	a4,a5,c0008618 <xStreamBufferSend+0x1c4>
		{
			sbSEND_COMPLETED( pxStreamBuffer );
c00085e0:	97cfb0ef          	jal	ra,c000375c <vTaskSuspendAll>
c00085e4:	fe442783          	lw	a5,-28(s0)
c00085e8:	0107a783          	lw	a5,16(a5)
c00085ec:	02078463          	beqz	a5,c0008614 <xStreamBufferSend+0x1c0>
c00085f0:	fe442783          	lw	a5,-28(s0)
c00085f4:	0107a783          	lw	a5,16(a5)
c00085f8:	00000693          	li	a3,0
c00085fc:	00000613          	li	a2,0
c0008600:	00000593          	li	a1,0
c0008604:	00078513          	mv	a0,a5
c0008608:	955fd0ef          	jal	ra,c0005f5c <xTaskGenericNotify>
c000860c:	fe442783          	lw	a5,-28(s0)
c0008610:	0007a823          	sw	zero,16(a5)
c0008614:	980fb0ef          	jal	ra,c0003794 <xTaskResumeAll>
	{
		mtCOVERAGE_TEST_MARKER();
		traceSTREAM_BUFFER_SEND_FAILED( xStreamBuffer );
	}

	return xReturn;
c0008618:	fe042783          	lw	a5,-32(s0)
}
c000861c:	00078513          	mv	a0,a5
c0008620:	03c12083          	lw	ra,60(sp)
c0008624:	03812403          	lw	s0,56(sp)
c0008628:	04010113          	addi	sp,sp,64
c000862c:	00008067          	ret

c0008630 <xStreamBufferSendFromISR>:

size_t xStreamBufferSendFromISR( StreamBufferHandle_t xStreamBuffer,
								 const void *pvTxData,
								 size_t xDataLengthBytes,
								 BaseType_t * const pxHigherPriorityTaskWoken )
{
c0008630:	fc010113          	addi	sp,sp,-64
c0008634:	02112e23          	sw	ra,60(sp)
c0008638:	02812c23          	sw	s0,56(sp)
c000863c:	04010413          	addi	s0,sp,64
c0008640:	fca42623          	sw	a0,-52(s0)
c0008644:	fcb42423          	sw	a1,-56(s0)
c0008648:	fcc42223          	sw	a2,-60(s0)
c000864c:	fcd42023          	sw	a3,-64(s0)
StreamBuffer_t * const pxStreamBuffer = xStreamBuffer;
c0008650:	fcc42783          	lw	a5,-52(s0)
c0008654:	fef42423          	sw	a5,-24(s0)
size_t xReturn, xSpace;
size_t xRequiredSpace = xDataLengthBytes;
c0008658:	fc442783          	lw	a5,-60(s0)
c000865c:	fef42623          	sw	a5,-20(s0)

	configASSERT( pvTxData );
c0008660:	fc842783          	lw	a5,-56(s0)
c0008664:	00079863          	bnez	a5,c0008674 <xStreamBufferSendFromISR+0x44>
c0008668:	30047073          	csrci	mstatus,8
c000866c:	00100073          	ebreak
c0008670:	0000006f          	j	c0008670 <xStreamBufferSendFromISR+0x40>
	configASSERT( pxStreamBuffer );
c0008674:	fe842783          	lw	a5,-24(s0)
c0008678:	00079863          	bnez	a5,c0008688 <xStreamBufferSendFromISR+0x58>
c000867c:	30047073          	csrci	mstatus,8
c0008680:	00100073          	ebreak
c0008684:	0000006f          	j	c0008684 <xStreamBufferSendFromISR+0x54>

	/* This send function is used to write to both message buffers and stream
	buffers.  If this is a message buffer then the space needed must be
	increased by the amount of bytes needed to store the length of the
	message. */
	if( ( pxStreamBuffer->ucFlags & sbFLAGS_IS_MESSAGE_BUFFER ) != ( uint8_t ) 0 )
c0008688:	fe842783          	lw	a5,-24(s0)
c000868c:	01c7c783          	lbu	a5,28(a5)
c0008690:	0017f793          	andi	a5,a5,1
c0008694:	00078863          	beqz	a5,c00086a4 <xStreamBufferSendFromISR+0x74>
	{
		xRequiredSpace += sbBYTES_TO_STORE_MESSAGE_LENGTH;
c0008698:	fec42783          	lw	a5,-20(s0)
c000869c:	00478793          	addi	a5,a5,4
c00086a0:	fef42623          	sw	a5,-20(s0)
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	xSpace = xStreamBufferSpacesAvailable( pxStreamBuffer );
c00086a4:	fe842503          	lw	a0,-24(s0)
c00086a8:	cbdff0ef          	jal	ra,c0008364 <xStreamBufferSpacesAvailable>
c00086ac:	fea42223          	sw	a0,-28(s0)
	xReturn = prvWriteMessageToBuffer( pxStreamBuffer, pvTxData, xDataLengthBytes, xSpace, xRequiredSpace );
c00086b0:	fec42703          	lw	a4,-20(s0)
c00086b4:	fe442683          	lw	a3,-28(s0)
c00086b8:	fc442603          	lw	a2,-60(s0)
c00086bc:	fc842583          	lw	a1,-56(s0)
c00086c0:	fe842503          	lw	a0,-24(s0)
c00086c4:	078000ef          	jal	ra,c000873c <prvWriteMessageToBuffer>
c00086c8:	fea42023          	sw	a0,-32(s0)

	if( xReturn > ( size_t ) 0 )
c00086cc:	fe042783          	lw	a5,-32(s0)
c00086d0:	04078a63          	beqz	a5,c0008724 <xStreamBufferSendFromISR+0xf4>
	{
		/* Was a task waiting for the data? */
		if( prvBytesInBuffer( pxStreamBuffer ) >= pxStreamBuffer->xTriggerLevelBytes )
c00086d4:	fe842503          	lw	a0,-24(s0)
c00086d8:	235000ef          	jal	ra,c000910c <prvBytesInBuffer>
c00086dc:	00050713          	mv	a4,a0
c00086e0:	fe842783          	lw	a5,-24(s0)
c00086e4:	00c7a783          	lw	a5,12(a5)
c00086e8:	02f76e63          	bltu	a4,a5,c0008724 <xStreamBufferSendFromISR+0xf4>
		{
			sbSEND_COMPLETE_FROM_ISR( pxStreamBuffer, pxHigherPriorityTaskWoken );
c00086ec:	fc042e23          	sw	zero,-36(s0)
c00086f0:	fe842783          	lw	a5,-24(s0)
c00086f4:	0107a783          	lw	a5,16(a5)
c00086f8:	02078663          	beqz	a5,c0008724 <xStreamBufferSendFromISR+0xf4>
c00086fc:	fe842783          	lw	a5,-24(s0)
c0008700:	0107a783          	lw	a5,16(a5)
c0008704:	fc042703          	lw	a4,-64(s0)
c0008708:	00000693          	li	a3,0
c000870c:	00000613          	li	a2,0
c0008710:	00000593          	li	a1,0
c0008714:	00078513          	mv	a0,a5
c0008718:	a55fd0ef          	jal	ra,c000616c <xTaskGenericNotifyFromISR>
c000871c:	fe842783          	lw	a5,-24(s0)
c0008720:	0007a823          	sw	zero,16(a5)
		mtCOVERAGE_TEST_MARKER();
	}

	traceSTREAM_BUFFER_SEND_FROM_ISR( xStreamBuffer, xReturn );

	return xReturn;
c0008724:	fe042783          	lw	a5,-32(s0)
}
c0008728:	00078513          	mv	a0,a5
c000872c:	03c12083          	lw	ra,60(sp)
c0008730:	03812403          	lw	s0,56(sp)
c0008734:	04010113          	addi	sp,sp,64
c0008738:	00008067          	ret

c000873c <prvWriteMessageToBuffer>:
static size_t prvWriteMessageToBuffer( StreamBuffer_t * const pxStreamBuffer,
									   const void * pvTxData,
									   size_t xDataLengthBytes,
									   size_t xSpace,
									   size_t xRequiredSpace )
{
c000873c:	fc010113          	addi	sp,sp,-64
c0008740:	02112e23          	sw	ra,60(sp)
c0008744:	02812c23          	sw	s0,56(sp)
c0008748:	04010413          	addi	s0,sp,64
c000874c:	fca42e23          	sw	a0,-36(s0)
c0008750:	fcb42c23          	sw	a1,-40(s0)
c0008754:	fcc42a23          	sw	a2,-44(s0)
c0008758:	fcd42823          	sw	a3,-48(s0)
c000875c:	fce42623          	sw	a4,-52(s0)
	BaseType_t xShouldWrite;
	size_t xReturn;

	if( xSpace == ( size_t ) 0 )
c0008760:	fd042783          	lw	a5,-48(s0)
c0008764:	00079663          	bnez	a5,c0008770 <prvWriteMessageToBuffer+0x34>
	{
		/* Doesn't matter if this is a stream buffer or a message buffer, there
		is no space to write. */
		xShouldWrite = pdFALSE;
c0008768:	fe042623          	sw	zero,-20(s0)
c000876c:	0640006f          	j	c00087d0 <prvWriteMessageToBuffer+0x94>
	}
	else if( ( pxStreamBuffer->ucFlags & sbFLAGS_IS_MESSAGE_BUFFER ) == ( uint8_t ) 0 )
c0008770:	fdc42783          	lw	a5,-36(s0)
c0008774:	01c7c783          	lbu	a5,28(a5)
c0008778:	0017f793          	andi	a5,a5,1
c000877c:	02079263          	bnez	a5,c00087a0 <prvWriteMessageToBuffer+0x64>
	{
		/* This is a stream buffer, as opposed to a message buffer, so writing a
		stream of bytes rather than discrete messages.  Write as many bytes as
		possible. */
		xShouldWrite = pdTRUE;
c0008780:	00100793          	li	a5,1
c0008784:	fef42623          	sw	a5,-20(s0)
		xDataLengthBytes = configMIN( xDataLengthBytes, xSpace );
c0008788:	fd442703          	lw	a4,-44(s0)
c000878c:	fd042783          	lw	a5,-48(s0)
c0008790:	00f77463          	bgeu	a4,a5,c0008798 <prvWriteMessageToBuffer+0x5c>
c0008794:	00070793          	mv	a5,a4
c0008798:	fcf42a23          	sw	a5,-44(s0)
c000879c:	0340006f          	j	c00087d0 <prvWriteMessageToBuffer+0x94>
	}
	else if( xSpace >= xRequiredSpace )
c00087a0:	fd042703          	lw	a4,-48(s0)
c00087a4:	fcc42783          	lw	a5,-52(s0)
c00087a8:	02f76263          	bltu	a4,a5,c00087cc <prvWriteMessageToBuffer+0x90>
	{
		/* This is a message buffer, as opposed to a stream buffer, and there
		is enough space to write both the message length and the message itself
		into the buffer.  Start by writing the length of the data, the data
		itself will be written later in this function. */
		xShouldWrite = pdTRUE;
c00087ac:	00100793          	li	a5,1
c00087b0:	fef42623          	sw	a5,-20(s0)
		( void ) prvWriteBytesToBuffer( pxStreamBuffer, ( const uint8_t * ) &( xDataLengthBytes ), sbBYTES_TO_STORE_MESSAGE_LENGTH );
c00087b4:	fd440793          	addi	a5,s0,-44
c00087b8:	00400613          	li	a2,4
c00087bc:	00078593          	mv	a1,a5
c00087c0:	fdc42503          	lw	a0,-36(s0)
c00087c4:	688000ef          	jal	ra,c0008e4c <prvWriteBytesToBuffer>
c00087c8:	0080006f          	j	c00087d0 <prvWriteMessageToBuffer+0x94>
	}
	else
	{
		/* There is space available, but not enough space. */
		xShouldWrite = pdFALSE;
c00087cc:	fe042623          	sw	zero,-20(s0)
	}

	if( xShouldWrite != pdFALSE )
c00087d0:	fec42783          	lw	a5,-20(s0)
c00087d4:	02078063          	beqz	a5,c00087f4 <prvWriteMessageToBuffer+0xb8>
	{
		/* Writes the data itself. */
		xReturn = prvWriteBytesToBuffer( pxStreamBuffer, ( const uint8_t * ) pvTxData, xDataLengthBytes ); /*lint !e9079 Storage buffer is implemented as uint8_t for ease of sizing, alighment and access. */
c00087d8:	fd442783          	lw	a5,-44(s0)
c00087dc:	00078613          	mv	a2,a5
c00087e0:	fd842583          	lw	a1,-40(s0)
c00087e4:	fdc42503          	lw	a0,-36(s0)
c00087e8:	664000ef          	jal	ra,c0008e4c <prvWriteBytesToBuffer>
c00087ec:	fea42423          	sw	a0,-24(s0)
c00087f0:	0080006f          	j	c00087f8 <prvWriteMessageToBuffer+0xbc>
	}
	else
	{
		xReturn = 0;
c00087f4:	fe042423          	sw	zero,-24(s0)
	}

	return xReturn;
c00087f8:	fe842783          	lw	a5,-24(s0)
}
c00087fc:	00078513          	mv	a0,a5
c0008800:	03c12083          	lw	ra,60(sp)
c0008804:	03812403          	lw	s0,56(sp)
c0008808:	04010113          	addi	sp,sp,64
c000880c:	00008067          	ret

c0008810 <xStreamBufferReceive>:

size_t xStreamBufferReceive( StreamBufferHandle_t xStreamBuffer,
							 void *pvRxData,
							 size_t xBufferLengthBytes,
							 TickType_t xTicksToWait )
{
c0008810:	fd010113          	addi	sp,sp,-48
c0008814:	02112623          	sw	ra,44(sp)
c0008818:	02812423          	sw	s0,40(sp)
c000881c:	03010413          	addi	s0,sp,48
c0008820:	fca42e23          	sw	a0,-36(s0)
c0008824:	fcb42c23          	sw	a1,-40(s0)
c0008828:	fcc42a23          	sw	a2,-44(s0)
c000882c:	fcd42823          	sw	a3,-48(s0)
StreamBuffer_t * const pxStreamBuffer = xStreamBuffer;
c0008830:	fdc42783          	lw	a5,-36(s0)
c0008834:	fef42023          	sw	a5,-32(s0)
size_t xReceivedLength = 0, xBytesAvailable, xBytesToStoreMessageLength;
c0008838:	fe042623          	sw	zero,-20(s0)

	configASSERT( pvRxData );
c000883c:	fd842783          	lw	a5,-40(s0)
c0008840:	00079863          	bnez	a5,c0008850 <xStreamBufferReceive+0x40>
c0008844:	30047073          	csrci	mstatus,8
c0008848:	00100073          	ebreak
c000884c:	0000006f          	j	c000884c <xStreamBufferReceive+0x3c>
	configASSERT( pxStreamBuffer );
c0008850:	fe042783          	lw	a5,-32(s0)
c0008854:	00079863          	bnez	a5,c0008864 <xStreamBufferReceive+0x54>
c0008858:	30047073          	csrci	mstatus,8
c000885c:	00100073          	ebreak
c0008860:	0000006f          	j	c0008860 <xStreamBufferReceive+0x50>
	/* This receive function is used by both message buffers, which store
	discrete messages, and stream buffers, which store a continuous stream of
	bytes.  Discrete messages include an additional
	sbBYTES_TO_STORE_MESSAGE_LENGTH bytes that hold the length of the
	message. */
	if( ( pxStreamBuffer->ucFlags & sbFLAGS_IS_MESSAGE_BUFFER ) != ( uint8_t ) 0 )
c0008864:	fe042783          	lw	a5,-32(s0)
c0008868:	01c7c783          	lbu	a5,28(a5)
c000886c:	0017f793          	andi	a5,a5,1
c0008870:	00078863          	beqz	a5,c0008880 <xStreamBufferReceive+0x70>
	{
		xBytesToStoreMessageLength = sbBYTES_TO_STORE_MESSAGE_LENGTH;
c0008874:	00400793          	li	a5,4
c0008878:	fef42223          	sw	a5,-28(s0)
c000887c:	0080006f          	j	c0008884 <xStreamBufferReceive+0x74>
	}
	else
	{
		xBytesToStoreMessageLength = 0;
c0008880:	fe042223          	sw	zero,-28(s0)
	}

	if( xTicksToWait != ( TickType_t ) 0 )
c0008884:	fd042783          	lw	a5,-48(s0)
c0008888:	08078663          	beqz	a5,c0008914 <xStreamBufferReceive+0x104>
	{
		/* Checking if there is data and clearing the notification state must be
		performed atomically. */
		taskENTER_CRITICAL();
c000888c:	8b4fd0ef          	jal	ra,c0005940 <vTaskEnterCritical>
		{
			xBytesAvailable = prvBytesInBuffer( pxStreamBuffer );
c0008890:	fe042503          	lw	a0,-32(s0)
c0008894:	079000ef          	jal	ra,c000910c <prvBytesInBuffer>
c0008898:	fea42423          	sw	a0,-24(s0)
			/* If this function was invoked by a message buffer read then
			xBytesToStoreMessageLength holds the number of bytes used to hold
			the length of the next discrete message.  If this function was
			invoked by a stream buffer read then xBytesToStoreMessageLength will
			be 0. */
			if( xBytesAvailable <= xBytesToStoreMessageLength )
c000889c:	fe842703          	lw	a4,-24(s0)
c00088a0:	fe442783          	lw	a5,-28(s0)
c00088a4:	02e7ea63          	bltu	a5,a4,c00088d8 <xStreamBufferReceive+0xc8>
			{
				/* Clear notification state as going to wait for data. */
				( void ) xTaskNotifyStateClear( NULL );
c00088a8:	00000513          	li	a0,0
c00088ac:	c99fd0ef          	jal	ra,c0006544 <xTaskNotifyStateClear>

				/* Should only be one reader. */
				configASSERT( pxStreamBuffer->xTaskWaitingToReceive == NULL );
c00088b0:	fe042783          	lw	a5,-32(s0)
c00088b4:	0107a783          	lw	a5,16(a5)
c00088b8:	00078863          	beqz	a5,c00088c8 <xStreamBufferReceive+0xb8>
c00088bc:	30047073          	csrci	mstatus,8
c00088c0:	00100073          	ebreak
c00088c4:	0000006f          	j	c00088c4 <xStreamBufferReceive+0xb4>
				pxStreamBuffer->xTaskWaitingToReceive = xTaskGetCurrentTaskHandle();
c00088c8:	a9dfc0ef          	jal	ra,c0005364 <xTaskGetCurrentTaskHandle>
c00088cc:	00050713          	mv	a4,a0
c00088d0:	fe042783          	lw	a5,-32(s0)
c00088d4:	00e7a823          	sw	a4,16(a5)
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
		taskEXIT_CRITICAL();
c00088d8:	8bcfd0ef          	jal	ra,c0005994 <vTaskExitCritical>

		if( xBytesAvailable <= xBytesToStoreMessageLength )
c00088dc:	fe842703          	lw	a4,-24(s0)
c00088e0:	fe442783          	lw	a5,-28(s0)
c00088e4:	02e7ee63          	bltu	a5,a4,c0008920 <xStreamBufferReceive+0x110>
		{
			/* Wait for data to be available. */
			traceBLOCKING_ON_STREAM_BUFFER_RECEIVE( xStreamBuffer );
			( void ) xTaskNotifyWait( ( uint32_t ) 0, ( uint32_t ) 0, NULL, xTicksToWait );
c00088e8:	fd042683          	lw	a3,-48(s0)
c00088ec:	00000613          	li	a2,0
c00088f0:	00000593          	li	a1,0
c00088f4:	00000513          	li	a0,0
c00088f8:	d38fd0ef          	jal	ra,c0005e30 <xTaskNotifyWait>
			pxStreamBuffer->xTaskWaitingToReceive = NULL;
c00088fc:	fe042783          	lw	a5,-32(s0)
c0008900:	0007a823          	sw	zero,16(a5)

			/* Recheck the data available after blocking. */
			xBytesAvailable = prvBytesInBuffer( pxStreamBuffer );
c0008904:	fe042503          	lw	a0,-32(s0)
c0008908:	005000ef          	jal	ra,c000910c <prvBytesInBuffer>
c000890c:	fea42423          	sw	a0,-24(s0)
c0008910:	0100006f          	j	c0008920 <xStreamBufferReceive+0x110>
			mtCOVERAGE_TEST_MARKER();
		}
	}
	else
	{
		xBytesAvailable = prvBytesInBuffer( pxStreamBuffer );
c0008914:	fe042503          	lw	a0,-32(s0)
c0008918:	7f4000ef          	jal	ra,c000910c <prvBytesInBuffer>
c000891c:	fea42423          	sw	a0,-24(s0)
	/* Whether receiving a discrete message (where xBytesToStoreMessageLength
	holds the number of bytes used to store the message length) or a stream of
	bytes (where xBytesToStoreMessageLength is zero), the number of bytes
	available must be greater than xBytesToStoreMessageLength to be able to
	read bytes from the buffer. */
	if( xBytesAvailable > xBytesToStoreMessageLength )
c0008920:	fe842703          	lw	a4,-24(s0)
c0008924:	fe442783          	lw	a5,-28(s0)
c0008928:	06e7f063          	bgeu	a5,a4,c0008988 <xStreamBufferReceive+0x178>
	{
		xReceivedLength = prvReadMessageFromBuffer( pxStreamBuffer, pvRxData, xBufferLengthBytes, xBytesAvailable, xBytesToStoreMessageLength );
c000892c:	fe442703          	lw	a4,-28(s0)
c0008930:	fe842683          	lw	a3,-24(s0)
c0008934:	fd442603          	lw	a2,-44(s0)
c0008938:	fd842583          	lw	a1,-40(s0)
c000893c:	fe042503          	lw	a0,-32(s0)
c0008940:	22c000ef          	jal	ra,c0008b6c <prvReadMessageFromBuffer>
c0008944:	fea42623          	sw	a0,-20(s0)

		/* Was a task waiting for space in the buffer? */
		if( xReceivedLength != ( size_t ) 0 )
c0008948:	fec42783          	lw	a5,-20(s0)
c000894c:	02078e63          	beqz	a5,c0008988 <xStreamBufferReceive+0x178>
		{
			traceSTREAM_BUFFER_RECEIVE( xStreamBuffer, xReceivedLength );
			sbRECEIVE_COMPLETED( pxStreamBuffer );
c0008950:	e0dfa0ef          	jal	ra,c000375c <vTaskSuspendAll>
c0008954:	fe042783          	lw	a5,-32(s0)
c0008958:	0147a783          	lw	a5,20(a5)
c000895c:	02078463          	beqz	a5,c0008984 <xStreamBufferReceive+0x174>
c0008960:	fe042783          	lw	a5,-32(s0)
c0008964:	0147a783          	lw	a5,20(a5)
c0008968:	00000693          	li	a3,0
c000896c:	00000613          	li	a2,0
c0008970:	00000593          	li	a1,0
c0008974:	00078513          	mv	a0,a5
c0008978:	de4fd0ef          	jal	ra,c0005f5c <xTaskGenericNotify>
c000897c:	fe042783          	lw	a5,-32(s0)
c0008980:	0007aa23          	sw	zero,20(a5)
c0008984:	e11fa0ef          	jal	ra,c0003794 <xTaskResumeAll>
	{
		traceSTREAM_BUFFER_RECEIVE_FAILED( xStreamBuffer );
		mtCOVERAGE_TEST_MARKER();
	}

	return xReceivedLength;
c0008988:	fec42783          	lw	a5,-20(s0)
}
c000898c:	00078513          	mv	a0,a5
c0008990:	02c12083          	lw	ra,44(sp)
c0008994:	02812403          	lw	s0,40(sp)
c0008998:	03010113          	addi	sp,sp,48
c000899c:	00008067          	ret

c00089a0 <xStreamBufferNextMessageLengthBytes>:
/*-----------------------------------------------------------*/

size_t xStreamBufferNextMessageLengthBytes( StreamBufferHandle_t xStreamBuffer )
{
c00089a0:	fc010113          	addi	sp,sp,-64
c00089a4:	02112e23          	sw	ra,60(sp)
c00089a8:	02812c23          	sw	s0,56(sp)
c00089ac:	04010413          	addi	s0,sp,64
c00089b0:	fca42623          	sw	a0,-52(s0)
StreamBuffer_t * const pxStreamBuffer = xStreamBuffer;
c00089b4:	fcc42783          	lw	a5,-52(s0)
c00089b8:	fef42423          	sw	a5,-24(s0)
size_t xReturn, xBytesAvailable, xOriginalTail;
configMESSAGE_BUFFER_LENGTH_TYPE xTempReturn;

	configASSERT( pxStreamBuffer );
c00089bc:	fe842783          	lw	a5,-24(s0)
c00089c0:	00079863          	bnez	a5,c00089d0 <xStreamBufferNextMessageLengthBytes+0x30>
c00089c4:	30047073          	csrci	mstatus,8
c00089c8:	00100073          	ebreak
c00089cc:	0000006f          	j	c00089cc <xStreamBufferNextMessageLengthBytes+0x2c>

	/* Ensure the stream buffer is being used as a message buffer. */
	if( ( pxStreamBuffer->ucFlags & sbFLAGS_IS_MESSAGE_BUFFER ) != ( uint8_t ) 0 )
c00089d0:	fe842783          	lw	a5,-24(s0)
c00089d4:	01c7c783          	lbu	a5,28(a5)
c00089d8:	0017f793          	andi	a5,a5,1
c00089dc:	06078a63          	beqz	a5,c0008a50 <xStreamBufferNextMessageLengthBytes+0xb0>
	{
		xBytesAvailable = prvBytesInBuffer( pxStreamBuffer );
c00089e0:	fe842503          	lw	a0,-24(s0)
c00089e4:	728000ef          	jal	ra,c000910c <prvBytesInBuffer>
c00089e8:	fea42223          	sw	a0,-28(s0)
		if( xBytesAvailable > sbBYTES_TO_STORE_MESSAGE_LENGTH )
c00089ec:	fe442703          	lw	a4,-28(s0)
c00089f0:	00400793          	li	a5,4
c00089f4:	04e7f063          	bgeu	a5,a4,c0008a34 <xStreamBufferNextMessageLengthBytes+0x94>
			required to hold the length of the next message, so another message
			is available.  Return its length without removing the length bytes
			from the buffer.  A copy of the tail is stored so the buffer can be
			returned to its prior state as the message is not actually being
			removed from the buffer. */
			xOriginalTail = pxStreamBuffer->xTail;
c00089f8:	fe842783          	lw	a5,-24(s0)
c00089fc:	0007a783          	lw	a5,0(a5)
c0008a00:	fef42023          	sw	a5,-32(s0)
			( void ) prvReadBytesFromBuffer( pxStreamBuffer, ( uint8_t * ) &xTempReturn, sbBYTES_TO_STORE_MESSAGE_LENGTH, xBytesAvailable );
c0008a04:	fdc40793          	addi	a5,s0,-36
c0008a08:	fe442683          	lw	a3,-28(s0)
c0008a0c:	00400613          	li	a2,4
c0008a10:	00078593          	mv	a1,a5
c0008a14:	fe842503          	lw	a0,-24(s0)
c0008a18:	588000ef          	jal	ra,c0008fa0 <prvReadBytesFromBuffer>
			xReturn = ( size_t ) xTempReturn;
c0008a1c:	fdc42783          	lw	a5,-36(s0)
c0008a20:	fef42623          	sw	a5,-20(s0)
			pxStreamBuffer->xTail = xOriginalTail;
c0008a24:	fe842783          	lw	a5,-24(s0)
c0008a28:	fe042703          	lw	a4,-32(s0)
c0008a2c:	00e7a023          	sw	a4,0(a5)
c0008a30:	0240006f          	j	c0008a54 <xStreamBufferNextMessageLengthBytes+0xb4>
		{
			/* The minimum amount of bytes in a message buffer is
			( sbBYTES_TO_STORE_MESSAGE_LENGTH + 1 ), so if xBytesAvailable is
			less than sbBYTES_TO_STORE_MESSAGE_LENGTH the only other valid
			value is 0. */
			configASSERT( xBytesAvailable == 0 );
c0008a34:	fe442783          	lw	a5,-28(s0)
c0008a38:	00078863          	beqz	a5,c0008a48 <xStreamBufferNextMessageLengthBytes+0xa8>
c0008a3c:	30047073          	csrci	mstatus,8
c0008a40:	00100073          	ebreak
c0008a44:	0000006f          	j	c0008a44 <xStreamBufferNextMessageLengthBytes+0xa4>
			xReturn = 0;
c0008a48:	fe042623          	sw	zero,-20(s0)
c0008a4c:	0080006f          	j	c0008a54 <xStreamBufferNextMessageLengthBytes+0xb4>
		}
	}
	else
	{
		xReturn = 0;
c0008a50:	fe042623          	sw	zero,-20(s0)
	}

	return xReturn;
c0008a54:	fec42783          	lw	a5,-20(s0)
}
c0008a58:	00078513          	mv	a0,a5
c0008a5c:	03c12083          	lw	ra,60(sp)
c0008a60:	03812403          	lw	s0,56(sp)
c0008a64:	04010113          	addi	sp,sp,64
c0008a68:	00008067          	ret

c0008a6c <xStreamBufferReceiveFromISR>:

size_t xStreamBufferReceiveFromISR( StreamBufferHandle_t xStreamBuffer,
									void *pvRxData,
									size_t xBufferLengthBytes,
									BaseType_t * const pxHigherPriorityTaskWoken )
{
c0008a6c:	fc010113          	addi	sp,sp,-64
c0008a70:	02112e23          	sw	ra,60(sp)
c0008a74:	02812c23          	sw	s0,56(sp)
c0008a78:	04010413          	addi	s0,sp,64
c0008a7c:	fca42623          	sw	a0,-52(s0)
c0008a80:	fcb42423          	sw	a1,-56(s0)
c0008a84:	fcc42223          	sw	a2,-60(s0)
c0008a88:	fcd42023          	sw	a3,-64(s0)
StreamBuffer_t * const pxStreamBuffer = xStreamBuffer;
c0008a8c:	fcc42783          	lw	a5,-52(s0)
c0008a90:	fef42223          	sw	a5,-28(s0)
size_t xReceivedLength = 0, xBytesAvailable, xBytesToStoreMessageLength;
c0008a94:	fe042623          	sw	zero,-20(s0)

	configASSERT( pvRxData );
c0008a98:	fc842783          	lw	a5,-56(s0)
c0008a9c:	00079863          	bnez	a5,c0008aac <xStreamBufferReceiveFromISR+0x40>
c0008aa0:	30047073          	csrci	mstatus,8
c0008aa4:	00100073          	ebreak
c0008aa8:	0000006f          	j	c0008aa8 <xStreamBufferReceiveFromISR+0x3c>
	configASSERT( pxStreamBuffer );
c0008aac:	fe442783          	lw	a5,-28(s0)
c0008ab0:	00079863          	bnez	a5,c0008ac0 <xStreamBufferReceiveFromISR+0x54>
c0008ab4:	30047073          	csrci	mstatus,8
c0008ab8:	00100073          	ebreak
c0008abc:	0000006f          	j	c0008abc <xStreamBufferReceiveFromISR+0x50>
	/* This receive function is used by both message buffers, which store
	discrete messages, and stream buffers, which store a continuous stream of
	bytes.  Discrete messages include an additional
	sbBYTES_TO_STORE_MESSAGE_LENGTH bytes that hold the length of the
	message. */
	if( ( pxStreamBuffer->ucFlags & sbFLAGS_IS_MESSAGE_BUFFER ) != ( uint8_t ) 0 )
c0008ac0:	fe442783          	lw	a5,-28(s0)
c0008ac4:	01c7c783          	lbu	a5,28(a5)
c0008ac8:	0017f793          	andi	a5,a5,1
c0008acc:	00078863          	beqz	a5,c0008adc <xStreamBufferReceiveFromISR+0x70>
	{
		xBytesToStoreMessageLength = sbBYTES_TO_STORE_MESSAGE_LENGTH;
c0008ad0:	00400793          	li	a5,4
c0008ad4:	fef42423          	sw	a5,-24(s0)
c0008ad8:	0080006f          	j	c0008ae0 <xStreamBufferReceiveFromISR+0x74>
	}
	else
	{
		xBytesToStoreMessageLength = 0;
c0008adc:	fe042423          	sw	zero,-24(s0)
	}

	xBytesAvailable = prvBytesInBuffer( pxStreamBuffer );
c0008ae0:	fe442503          	lw	a0,-28(s0)
c0008ae4:	628000ef          	jal	ra,c000910c <prvBytesInBuffer>
c0008ae8:	fea42023          	sw	a0,-32(s0)
	/* Whether receiving a discrete message (where xBytesToStoreMessageLength
	holds the number of bytes used to store the message length) or a stream of
	bytes (where xBytesToStoreMessageLength is zero), the number of bytes
	available must be greater than xBytesToStoreMessageLength to be able to
	read bytes from the buffer. */
	if( xBytesAvailable > xBytesToStoreMessageLength )
c0008aec:	fe042703          	lw	a4,-32(s0)
c0008af0:	fe842783          	lw	a5,-24(s0)
c0008af4:	06e7f063          	bgeu	a5,a4,c0008b54 <xStreamBufferReceiveFromISR+0xe8>
	{
		xReceivedLength = prvReadMessageFromBuffer( pxStreamBuffer, pvRxData, xBufferLengthBytes, xBytesAvailable, xBytesToStoreMessageLength );
c0008af8:	fe842703          	lw	a4,-24(s0)
c0008afc:	fe042683          	lw	a3,-32(s0)
c0008b00:	fc442603          	lw	a2,-60(s0)
c0008b04:	fc842583          	lw	a1,-56(s0)
c0008b08:	fe442503          	lw	a0,-28(s0)
c0008b0c:	060000ef          	jal	ra,c0008b6c <prvReadMessageFromBuffer>
c0008b10:	fea42623          	sw	a0,-20(s0)

		/* Was a task waiting for space in the buffer? */
		if( xReceivedLength != ( size_t ) 0 )
c0008b14:	fec42783          	lw	a5,-20(s0)
c0008b18:	02078e63          	beqz	a5,c0008b54 <xStreamBufferReceiveFromISR+0xe8>
		{
			sbRECEIVE_COMPLETED_FROM_ISR( pxStreamBuffer, pxHigherPriorityTaskWoken );
c0008b1c:	fc042e23          	sw	zero,-36(s0)
c0008b20:	fe442783          	lw	a5,-28(s0)
c0008b24:	0147a783          	lw	a5,20(a5)
c0008b28:	02078663          	beqz	a5,c0008b54 <xStreamBufferReceiveFromISR+0xe8>
c0008b2c:	fe442783          	lw	a5,-28(s0)
c0008b30:	0147a783          	lw	a5,20(a5)
c0008b34:	fc042703          	lw	a4,-64(s0)
c0008b38:	00000693          	li	a3,0
c0008b3c:	00000613          	li	a2,0
c0008b40:	00000593          	li	a1,0
c0008b44:	00078513          	mv	a0,a5
c0008b48:	e24fd0ef          	jal	ra,c000616c <xTaskGenericNotifyFromISR>
c0008b4c:	fe442783          	lw	a5,-28(s0)
c0008b50:	0007aa23          	sw	zero,20(a5)
		mtCOVERAGE_TEST_MARKER();
	}

	traceSTREAM_BUFFER_RECEIVE_FROM_ISR( xStreamBuffer, xReceivedLength );

	return xReceivedLength;
c0008b54:	fec42783          	lw	a5,-20(s0)
}
c0008b58:	00078513          	mv	a0,a5
c0008b5c:	03c12083          	lw	ra,60(sp)
c0008b60:	03812403          	lw	s0,56(sp)
c0008b64:	04010113          	addi	sp,sp,64
c0008b68:	00008067          	ret

c0008b6c <prvReadMessageFromBuffer>:
static size_t prvReadMessageFromBuffer( StreamBuffer_t *pxStreamBuffer,
										void *pvRxData,
										size_t xBufferLengthBytes,
										size_t xBytesAvailable,
										size_t xBytesToStoreMessageLength )
{
c0008b6c:	fc010113          	addi	sp,sp,-64
c0008b70:	02112e23          	sw	ra,60(sp)
c0008b74:	02812c23          	sw	s0,56(sp)
c0008b78:	04010413          	addi	s0,sp,64
c0008b7c:	fca42e23          	sw	a0,-36(s0)
c0008b80:	fcb42c23          	sw	a1,-40(s0)
c0008b84:	fcc42a23          	sw	a2,-44(s0)
c0008b88:	fcd42823          	sw	a3,-48(s0)
c0008b8c:	fce42623          	sw	a4,-52(s0)
size_t xOriginalTail, xReceivedLength, xNextMessageLength;
configMESSAGE_BUFFER_LENGTH_TYPE xTempNextMessageLength;

	if( xBytesToStoreMessageLength != ( size_t ) 0 )
c0008b90:	fcc42783          	lw	a5,-52(s0)
c0008b94:	06078063          	beqz	a5,c0008bf4 <prvReadMessageFromBuffer+0x88>
	{
		/* A discrete message is being received.  First receive the length
		of the message.  A copy of the tail is stored so the buffer can be
		returned to its prior state if the length of the message is too
		large for the provided buffer. */
		xOriginalTail = pxStreamBuffer->xTail;
c0008b98:	fdc42783          	lw	a5,-36(s0)
c0008b9c:	0007a783          	lw	a5,0(a5)
c0008ba0:	fef42423          	sw	a5,-24(s0)
		( void ) prvReadBytesFromBuffer( pxStreamBuffer, ( uint8_t * ) &xTempNextMessageLength, xBytesToStoreMessageLength, xBytesAvailable );
c0008ba4:	fe040793          	addi	a5,s0,-32
c0008ba8:	fd042683          	lw	a3,-48(s0)
c0008bac:	fcc42603          	lw	a2,-52(s0)
c0008bb0:	00078593          	mv	a1,a5
c0008bb4:	fdc42503          	lw	a0,-36(s0)
c0008bb8:	3e8000ef          	jal	ra,c0008fa0 <prvReadBytesFromBuffer>
		xNextMessageLength = ( size_t ) xTempNextMessageLength;
c0008bbc:	fe042783          	lw	a5,-32(s0)
c0008bc0:	fef42623          	sw	a5,-20(s0)

		/* Reduce the number of bytes available by the number of bytes just
		read out. */
		xBytesAvailable -= xBytesToStoreMessageLength;
c0008bc4:	fd042703          	lw	a4,-48(s0)
c0008bc8:	fcc42783          	lw	a5,-52(s0)
c0008bcc:	40f707b3          	sub	a5,a4,a5
c0008bd0:	fcf42823          	sw	a5,-48(s0)

		/* Check there is enough space in the buffer provided by the
		user. */
		if( xNextMessageLength > xBufferLengthBytes )
c0008bd4:	fec42703          	lw	a4,-20(s0)
c0008bd8:	fd442783          	lw	a5,-44(s0)
c0008bdc:	02e7f063          	bgeu	a5,a4,c0008bfc <prvReadMessageFromBuffer+0x90>
		{
			/* The user has provided insufficient space to read the message
			so return the buffer to its previous state (so the length of
			the message is in the buffer again). */
			pxStreamBuffer->xTail = xOriginalTail;
c0008be0:	fdc42783          	lw	a5,-36(s0)
c0008be4:	fe842703          	lw	a4,-24(s0)
c0008be8:	00e7a023          	sw	a4,0(a5)
			xNextMessageLength = 0;
c0008bec:	fe042623          	sw	zero,-20(s0)
c0008bf0:	00c0006f          	j	c0008bfc <prvReadMessageFromBuffer+0x90>
	}
	else
	{
		/* A stream of bytes is being received (as opposed to a discrete
		message), so read as many bytes as possible. */
		xNextMessageLength = xBufferLengthBytes;
c0008bf4:	fd442783          	lw	a5,-44(s0)
c0008bf8:	fef42623          	sw	a5,-20(s0)
	}

	/* Read the actual data. */
	xReceivedLength = prvReadBytesFromBuffer( pxStreamBuffer, ( uint8_t * ) pvRxData, xNextMessageLength, xBytesAvailable ); /*lint !e9079 Data storage area is implemented as uint8_t array for ease of sizing, indexing and alignment. */
c0008bfc:	fd042683          	lw	a3,-48(s0)
c0008c00:	fec42603          	lw	a2,-20(s0)
c0008c04:	fd842583          	lw	a1,-40(s0)
c0008c08:	fdc42503          	lw	a0,-36(s0)
c0008c0c:	394000ef          	jal	ra,c0008fa0 <prvReadBytesFromBuffer>
c0008c10:	fea42223          	sw	a0,-28(s0)

	return xReceivedLength;
c0008c14:	fe442783          	lw	a5,-28(s0)
}
c0008c18:	00078513          	mv	a0,a5
c0008c1c:	03c12083          	lw	ra,60(sp)
c0008c20:	03812403          	lw	s0,56(sp)
c0008c24:	04010113          	addi	sp,sp,64
c0008c28:	00008067          	ret

c0008c2c <xStreamBufferIsEmpty>:
/*-----------------------------------------------------------*/

BaseType_t xStreamBufferIsEmpty( StreamBufferHandle_t xStreamBuffer )
{
c0008c2c:	fd010113          	addi	sp,sp,-48
c0008c30:	02812623          	sw	s0,44(sp)
c0008c34:	03010413          	addi	s0,sp,48
c0008c38:	fca42e23          	sw	a0,-36(s0)
const StreamBuffer_t * const pxStreamBuffer = xStreamBuffer;
c0008c3c:	fdc42783          	lw	a5,-36(s0)
c0008c40:	fef42423          	sw	a5,-24(s0)
BaseType_t xReturn;
size_t xTail;

	configASSERT( pxStreamBuffer );
c0008c44:	fe842783          	lw	a5,-24(s0)
c0008c48:	00079863          	bnez	a5,c0008c58 <xStreamBufferIsEmpty+0x2c>
c0008c4c:	30047073          	csrci	mstatus,8
c0008c50:	00100073          	ebreak
c0008c54:	0000006f          	j	c0008c54 <xStreamBufferIsEmpty+0x28>

	/* True if no bytes are available. */
	xTail = pxStreamBuffer->xTail;
c0008c58:	fe842783          	lw	a5,-24(s0)
c0008c5c:	0007a783          	lw	a5,0(a5)
c0008c60:	fef42223          	sw	a5,-28(s0)
	if( pxStreamBuffer->xHead == xTail )
c0008c64:	fe842783          	lw	a5,-24(s0)
c0008c68:	0047a783          	lw	a5,4(a5)
c0008c6c:	fe442703          	lw	a4,-28(s0)
c0008c70:	00f71863          	bne	a4,a5,c0008c80 <xStreamBufferIsEmpty+0x54>
	{
		xReturn = pdTRUE;
c0008c74:	00100793          	li	a5,1
c0008c78:	fef42623          	sw	a5,-20(s0)
c0008c7c:	0080006f          	j	c0008c84 <xStreamBufferIsEmpty+0x58>
	}
	else
	{
		xReturn = pdFALSE;
c0008c80:	fe042623          	sw	zero,-20(s0)
	}

	return xReturn;
c0008c84:	fec42783          	lw	a5,-20(s0)
}
c0008c88:	00078513          	mv	a0,a5
c0008c8c:	02c12403          	lw	s0,44(sp)
c0008c90:	03010113          	addi	sp,sp,48
c0008c94:	00008067          	ret

c0008c98 <xStreamBufferIsFull>:
/*-----------------------------------------------------------*/

BaseType_t xStreamBufferIsFull( StreamBufferHandle_t xStreamBuffer )
{
c0008c98:	fd010113          	addi	sp,sp,-48
c0008c9c:	02112623          	sw	ra,44(sp)
c0008ca0:	02812423          	sw	s0,40(sp)
c0008ca4:	03010413          	addi	s0,sp,48
c0008ca8:	fca42e23          	sw	a0,-36(s0)
BaseType_t xReturn;
size_t xBytesToStoreMessageLength;
const StreamBuffer_t * const pxStreamBuffer = xStreamBuffer;
c0008cac:	fdc42783          	lw	a5,-36(s0)
c0008cb0:	fef42223          	sw	a5,-28(s0)

	configASSERT( pxStreamBuffer );
c0008cb4:	fe442783          	lw	a5,-28(s0)
c0008cb8:	00079863          	bnez	a5,c0008cc8 <xStreamBufferIsFull+0x30>
c0008cbc:	30047073          	csrci	mstatus,8
c0008cc0:	00100073          	ebreak
c0008cc4:	0000006f          	j	c0008cc4 <xStreamBufferIsFull+0x2c>

	/* This generic version of the receive function is used by both message
	buffers, which store discrete messages, and stream buffers, which store a
	continuous stream of bytes.  Discrete messages include an additional
	sbBYTES_TO_STORE_MESSAGE_LENGTH bytes that hold the length of the message. */
	if( ( pxStreamBuffer->ucFlags & sbFLAGS_IS_MESSAGE_BUFFER ) != ( uint8_t ) 0 )
c0008cc8:	fe442783          	lw	a5,-28(s0)
c0008ccc:	01c7c783          	lbu	a5,28(a5)
c0008cd0:	0017f793          	andi	a5,a5,1
c0008cd4:	00078863          	beqz	a5,c0008ce4 <xStreamBufferIsFull+0x4c>
	{
		xBytesToStoreMessageLength = sbBYTES_TO_STORE_MESSAGE_LENGTH;
c0008cd8:	00400793          	li	a5,4
c0008cdc:	fef42423          	sw	a5,-24(s0)
c0008ce0:	0080006f          	j	c0008ce8 <xStreamBufferIsFull+0x50>
	}
	else
	{
		xBytesToStoreMessageLength = 0;
c0008ce4:	fe042423          	sw	zero,-24(s0)
	}

	/* True if the available space equals zero. */
	if( xStreamBufferSpacesAvailable( xStreamBuffer ) <= xBytesToStoreMessageLength )
c0008ce8:	fdc42503          	lw	a0,-36(s0)
c0008cec:	e78ff0ef          	jal	ra,c0008364 <xStreamBufferSpacesAvailable>
c0008cf0:	00050713          	mv	a4,a0
c0008cf4:	fe842783          	lw	a5,-24(s0)
c0008cf8:	00e7e863          	bltu	a5,a4,c0008d08 <xStreamBufferIsFull+0x70>
	{
		xReturn = pdTRUE;
c0008cfc:	00100793          	li	a5,1
c0008d00:	fef42623          	sw	a5,-20(s0)
c0008d04:	0080006f          	j	c0008d0c <xStreamBufferIsFull+0x74>
	}
	else
	{
		xReturn = pdFALSE;
c0008d08:	fe042623          	sw	zero,-20(s0)
	}

	return xReturn;
c0008d0c:	fec42783          	lw	a5,-20(s0)
}
c0008d10:	00078513          	mv	a0,a5
c0008d14:	02c12083          	lw	ra,44(sp)
c0008d18:	02812403          	lw	s0,40(sp)
c0008d1c:	03010113          	addi	sp,sp,48
c0008d20:	00008067          	ret

c0008d24 <xStreamBufferSendCompletedFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xStreamBufferSendCompletedFromISR( StreamBufferHandle_t xStreamBuffer, BaseType_t *pxHigherPriorityTaskWoken )
{
c0008d24:	fd010113          	addi	sp,sp,-48
c0008d28:	02112623          	sw	ra,44(sp)
c0008d2c:	02812423          	sw	s0,40(sp)
c0008d30:	03010413          	addi	s0,sp,48
c0008d34:	fca42e23          	sw	a0,-36(s0)
c0008d38:	fcb42c23          	sw	a1,-40(s0)
StreamBuffer_t * const pxStreamBuffer = xStreamBuffer;
c0008d3c:	fdc42783          	lw	a5,-36(s0)
c0008d40:	fef42423          	sw	a5,-24(s0)
BaseType_t xReturn;
UBaseType_t uxSavedInterruptStatus;

	configASSERT( pxStreamBuffer );
c0008d44:	fe842783          	lw	a5,-24(s0)
c0008d48:	00079863          	bnez	a5,c0008d58 <xStreamBufferSendCompletedFromISR+0x34>
c0008d4c:	30047073          	csrci	mstatus,8
c0008d50:	00100073          	ebreak
c0008d54:	0000006f          	j	c0008d54 <xStreamBufferSendCompletedFromISR+0x30>

	uxSavedInterruptStatus = ( UBaseType_t ) portSET_INTERRUPT_MASK_FROM_ISR();
c0008d58:	fe042223          	sw	zero,-28(s0)
	{
		if( ( pxStreamBuffer )->xTaskWaitingToReceive != NULL )
c0008d5c:	fe842783          	lw	a5,-24(s0)
c0008d60:	0107a783          	lw	a5,16(a5)
c0008d64:	02078c63          	beqz	a5,c0008d9c <xStreamBufferSendCompletedFromISR+0x78>
		{
			( void ) xTaskNotifyFromISR( ( pxStreamBuffer )->xTaskWaitingToReceive,
c0008d68:	fe842783          	lw	a5,-24(s0)
c0008d6c:	0107a783          	lw	a5,16(a5)
c0008d70:	fd842703          	lw	a4,-40(s0)
c0008d74:	00000693          	li	a3,0
c0008d78:	00000613          	li	a2,0
c0008d7c:	00000593          	li	a1,0
c0008d80:	00078513          	mv	a0,a5
c0008d84:	be8fd0ef          	jal	ra,c000616c <xTaskGenericNotifyFromISR>
										 ( uint32_t ) 0,
										 eNoAction,
										 pxHigherPriorityTaskWoken );
			( pxStreamBuffer )->xTaskWaitingToReceive = NULL;
c0008d88:	fe842783          	lw	a5,-24(s0)
c0008d8c:	0007a823          	sw	zero,16(a5)
			xReturn = pdTRUE;
c0008d90:	00100793          	li	a5,1
c0008d94:	fef42623          	sw	a5,-20(s0)
c0008d98:	0080006f          	j	c0008da0 <xStreamBufferSendCompletedFromISR+0x7c>
		}
		else
		{
			xReturn = pdFALSE;
c0008d9c:	fe042623          	sw	zero,-20(s0)
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
c0008da0:	fec42783          	lw	a5,-20(s0)
}
c0008da4:	00078513          	mv	a0,a5
c0008da8:	02c12083          	lw	ra,44(sp)
c0008dac:	02812403          	lw	s0,40(sp)
c0008db0:	03010113          	addi	sp,sp,48
c0008db4:	00008067          	ret

c0008db8 <xStreamBufferReceiveCompletedFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xStreamBufferReceiveCompletedFromISR( StreamBufferHandle_t xStreamBuffer, BaseType_t *pxHigherPriorityTaskWoken )
{
c0008db8:	fd010113          	addi	sp,sp,-48
c0008dbc:	02112623          	sw	ra,44(sp)
c0008dc0:	02812423          	sw	s0,40(sp)
c0008dc4:	03010413          	addi	s0,sp,48
c0008dc8:	fca42e23          	sw	a0,-36(s0)
c0008dcc:	fcb42c23          	sw	a1,-40(s0)
StreamBuffer_t * const pxStreamBuffer = xStreamBuffer;
c0008dd0:	fdc42783          	lw	a5,-36(s0)
c0008dd4:	fef42423          	sw	a5,-24(s0)
BaseType_t xReturn;
UBaseType_t uxSavedInterruptStatus;

	configASSERT( pxStreamBuffer );
c0008dd8:	fe842783          	lw	a5,-24(s0)
c0008ddc:	00079863          	bnez	a5,c0008dec <xStreamBufferReceiveCompletedFromISR+0x34>
c0008de0:	30047073          	csrci	mstatus,8
c0008de4:	00100073          	ebreak
c0008de8:	0000006f          	j	c0008de8 <xStreamBufferReceiveCompletedFromISR+0x30>

	uxSavedInterruptStatus = ( UBaseType_t ) portSET_INTERRUPT_MASK_FROM_ISR();
c0008dec:	fe042223          	sw	zero,-28(s0)
	{
		if( ( pxStreamBuffer )->xTaskWaitingToSend != NULL )
c0008df0:	fe842783          	lw	a5,-24(s0)
c0008df4:	0147a783          	lw	a5,20(a5)
c0008df8:	02078c63          	beqz	a5,c0008e30 <xStreamBufferReceiveCompletedFromISR+0x78>
		{
			( void ) xTaskNotifyFromISR( ( pxStreamBuffer )->xTaskWaitingToSend,
c0008dfc:	fe842783          	lw	a5,-24(s0)
c0008e00:	0147a783          	lw	a5,20(a5)
c0008e04:	fd842703          	lw	a4,-40(s0)
c0008e08:	00000693          	li	a3,0
c0008e0c:	00000613          	li	a2,0
c0008e10:	00000593          	li	a1,0
c0008e14:	00078513          	mv	a0,a5
c0008e18:	b54fd0ef          	jal	ra,c000616c <xTaskGenericNotifyFromISR>
										 ( uint32_t ) 0,
										 eNoAction,
										 pxHigherPriorityTaskWoken );
			( pxStreamBuffer )->xTaskWaitingToSend = NULL;
c0008e1c:	fe842783          	lw	a5,-24(s0)
c0008e20:	0007aa23          	sw	zero,20(a5)
			xReturn = pdTRUE;
c0008e24:	00100793          	li	a5,1
c0008e28:	fef42623          	sw	a5,-20(s0)
c0008e2c:	0080006f          	j	c0008e34 <xStreamBufferReceiveCompletedFromISR+0x7c>
		}
		else
		{
			xReturn = pdFALSE;
c0008e30:	fe042623          	sw	zero,-20(s0)
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
c0008e34:	fec42783          	lw	a5,-20(s0)
}
c0008e38:	00078513          	mv	a0,a5
c0008e3c:	02c12083          	lw	ra,44(sp)
c0008e40:	02812403          	lw	s0,40(sp)
c0008e44:	03010113          	addi	sp,sp,48
c0008e48:	00008067          	ret

c0008e4c <prvWriteBytesToBuffer>:
/*-----------------------------------------------------------*/

static size_t prvWriteBytesToBuffer( StreamBuffer_t * const pxStreamBuffer, const uint8_t *pucData, size_t xCount )
{
c0008e4c:	fd010113          	addi	sp,sp,-48
c0008e50:	02112623          	sw	ra,44(sp)
c0008e54:	02812423          	sw	s0,40(sp)
c0008e58:	03010413          	addi	s0,sp,48
c0008e5c:	fca42e23          	sw	a0,-36(s0)
c0008e60:	fcb42c23          	sw	a1,-40(s0)
c0008e64:	fcc42a23          	sw	a2,-44(s0)
size_t xNextHead, xFirstLength;

	configASSERT( xCount > ( size_t ) 0 );
c0008e68:	fd442783          	lw	a5,-44(s0)
c0008e6c:	00079863          	bnez	a5,c0008e7c <prvWriteBytesToBuffer+0x30>
c0008e70:	30047073          	csrci	mstatus,8
c0008e74:	00100073          	ebreak
c0008e78:	0000006f          	j	c0008e78 <prvWriteBytesToBuffer+0x2c>

	xNextHead = pxStreamBuffer->xHead;
c0008e7c:	fdc42783          	lw	a5,-36(s0)
c0008e80:	0047a783          	lw	a5,4(a5)
c0008e84:	fef42623          	sw	a5,-20(s0)

	/* Calculate the number of bytes that can be added in the first write -
	which may be less than the total number of bytes that need to be added if
	the buffer will wrap back to the beginning. */
	xFirstLength = configMIN( pxStreamBuffer->xLength - xNextHead, xCount );
c0008e88:	fdc42783          	lw	a5,-36(s0)
c0008e8c:	0087a703          	lw	a4,8(a5)
c0008e90:	fec42783          	lw	a5,-20(s0)
c0008e94:	40f70733          	sub	a4,a4,a5
c0008e98:	fd442783          	lw	a5,-44(s0)
c0008e9c:	00f77463          	bgeu	a4,a5,c0008ea4 <prvWriteBytesToBuffer+0x58>
c0008ea0:	00070793          	mv	a5,a4
c0008ea4:	fef42423          	sw	a5,-24(s0)

	/* Write as many bytes as can be written in the first write. */
	configASSERT( ( xNextHead + xFirstLength ) <= pxStreamBuffer->xLength );
c0008ea8:	fec42703          	lw	a4,-20(s0)
c0008eac:	fe842783          	lw	a5,-24(s0)
c0008eb0:	00f70733          	add	a4,a4,a5
c0008eb4:	fdc42783          	lw	a5,-36(s0)
c0008eb8:	0087a783          	lw	a5,8(a5)
c0008ebc:	00e7f863          	bgeu	a5,a4,c0008ecc <prvWriteBytesToBuffer+0x80>
c0008ec0:	30047073          	csrci	mstatus,8
c0008ec4:	00100073          	ebreak
c0008ec8:	0000006f          	j	c0008ec8 <prvWriteBytesToBuffer+0x7c>
	( void ) memcpy( ( void* ) ( &( pxStreamBuffer->pucBuffer[ xNextHead ] ) ), ( const void * ) pucData, xFirstLength ); /*lint !e9087 memcpy() requires void *. */
c0008ecc:	fdc42783          	lw	a5,-36(s0)
c0008ed0:	0187a703          	lw	a4,24(a5)
c0008ed4:	fec42783          	lw	a5,-20(s0)
c0008ed8:	00f707b3          	add	a5,a4,a5
c0008edc:	fe842603          	lw	a2,-24(s0)
c0008ee0:	fd842583          	lw	a1,-40(s0)
c0008ee4:	00078513          	mv	a0,a5
c0008ee8:	479140ef          	jal	ra,c001db60 <memcpy>

	/* If the number of bytes written was less than the number that could be
	written in the first write... */
	if( xCount > xFirstLength )
c0008eec:	fd442703          	lw	a4,-44(s0)
c0008ef0:	fe842783          	lw	a5,-24(s0)
c0008ef4:	04e7fa63          	bgeu	a5,a4,c0008f48 <prvWriteBytesToBuffer+0xfc>
	{
		/* ...then write the remaining bytes to the start of the buffer. */
		configASSERT( ( xCount - xFirstLength ) <= pxStreamBuffer->xLength );
c0008ef8:	fd442703          	lw	a4,-44(s0)
c0008efc:	fe842783          	lw	a5,-24(s0)
c0008f00:	40f70733          	sub	a4,a4,a5
c0008f04:	fdc42783          	lw	a5,-36(s0)
c0008f08:	0087a783          	lw	a5,8(a5)
c0008f0c:	00e7f863          	bgeu	a5,a4,c0008f1c <prvWriteBytesToBuffer+0xd0>
c0008f10:	30047073          	csrci	mstatus,8
c0008f14:	00100073          	ebreak
c0008f18:	0000006f          	j	c0008f18 <prvWriteBytesToBuffer+0xcc>
		( void ) memcpy( ( void * ) pxStreamBuffer->pucBuffer, ( const void * ) &( pucData[ xFirstLength ] ), xCount - xFirstLength ); /*lint !e9087 memcpy() requires void *. */
c0008f1c:	fdc42783          	lw	a5,-36(s0)
c0008f20:	0187a683          	lw	a3,24(a5)
c0008f24:	fd842703          	lw	a4,-40(s0)
c0008f28:	fe842783          	lw	a5,-24(s0)
c0008f2c:	00f705b3          	add	a1,a4,a5
c0008f30:	fd442703          	lw	a4,-44(s0)
c0008f34:	fe842783          	lw	a5,-24(s0)
c0008f38:	40f707b3          	sub	a5,a4,a5
c0008f3c:	00078613          	mv	a2,a5
c0008f40:	00068513          	mv	a0,a3
c0008f44:	41d140ef          	jal	ra,c001db60 <memcpy>
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	xNextHead += xCount;
c0008f48:	fec42703          	lw	a4,-20(s0)
c0008f4c:	fd442783          	lw	a5,-44(s0)
c0008f50:	00f707b3          	add	a5,a4,a5
c0008f54:	fef42623          	sw	a5,-20(s0)
	if( xNextHead >= pxStreamBuffer->xLength )
c0008f58:	fdc42783          	lw	a5,-36(s0)
c0008f5c:	0087a783          	lw	a5,8(a5)
c0008f60:	fec42703          	lw	a4,-20(s0)
c0008f64:	00f76c63          	bltu	a4,a5,c0008f7c <prvWriteBytesToBuffer+0x130>
	{
		xNextHead -= pxStreamBuffer->xLength;
c0008f68:	fdc42783          	lw	a5,-36(s0)
c0008f6c:	0087a783          	lw	a5,8(a5)
c0008f70:	fec42703          	lw	a4,-20(s0)
c0008f74:	40f707b3          	sub	a5,a4,a5
c0008f78:	fef42623          	sw	a5,-20(s0)
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	pxStreamBuffer->xHead = xNextHead;
c0008f7c:	fdc42783          	lw	a5,-36(s0)
c0008f80:	fec42703          	lw	a4,-20(s0)
c0008f84:	00e7a223          	sw	a4,4(a5)

	return xCount;
c0008f88:	fd442783          	lw	a5,-44(s0)
}
c0008f8c:	00078513          	mv	a0,a5
c0008f90:	02c12083          	lw	ra,44(sp)
c0008f94:	02812403          	lw	s0,40(sp)
c0008f98:	03010113          	addi	sp,sp,48
c0008f9c:	00008067          	ret

c0008fa0 <prvReadBytesFromBuffer>:
/*-----------------------------------------------------------*/

static size_t prvReadBytesFromBuffer( StreamBuffer_t *pxStreamBuffer, uint8_t *pucData, size_t xMaxCount, size_t xBytesAvailable )
{
c0008fa0:	fd010113          	addi	sp,sp,-48
c0008fa4:	02112623          	sw	ra,44(sp)
c0008fa8:	02812423          	sw	s0,40(sp)
c0008fac:	03010413          	addi	s0,sp,48
c0008fb0:	fca42e23          	sw	a0,-36(s0)
c0008fb4:	fcb42c23          	sw	a1,-40(s0)
c0008fb8:	fcc42a23          	sw	a2,-44(s0)
c0008fbc:	fcd42823          	sw	a3,-48(s0)
size_t xCount, xFirstLength, xNextTail;

	/* Use the minimum of the wanted bytes and the available bytes. */
	xCount = configMIN( xBytesAvailable, xMaxCount );
c0008fc0:	fd042703          	lw	a4,-48(s0)
c0008fc4:	fd442783          	lw	a5,-44(s0)
c0008fc8:	00f77463          	bgeu	a4,a5,c0008fd0 <prvReadBytesFromBuffer+0x30>
c0008fcc:	00070793          	mv	a5,a4
c0008fd0:	fef42423          	sw	a5,-24(s0)

	if( xCount > ( size_t ) 0 )
c0008fd4:	fe842783          	lw	a5,-24(s0)
c0008fd8:	10078e63          	beqz	a5,c00090f4 <prvReadBytesFromBuffer+0x154>
	{
		xNextTail = pxStreamBuffer->xTail;
c0008fdc:	fdc42783          	lw	a5,-36(s0)
c0008fe0:	0007a783          	lw	a5,0(a5)
c0008fe4:	fef42623          	sw	a5,-20(s0)

		/* Calculate the number of bytes that can be read - which may be
		less than the number wanted if the data wraps around to the start of
		the buffer. */
		xFirstLength = configMIN( pxStreamBuffer->xLength - xNextTail, xCount );
c0008fe8:	fdc42783          	lw	a5,-36(s0)
c0008fec:	0087a703          	lw	a4,8(a5)
c0008ff0:	fec42783          	lw	a5,-20(s0)
c0008ff4:	40f70733          	sub	a4,a4,a5
c0008ff8:	fe842783          	lw	a5,-24(s0)
c0008ffc:	00f77463          	bgeu	a4,a5,c0009004 <prvReadBytesFromBuffer+0x64>
c0009000:	00070793          	mv	a5,a4
c0009004:	fef42223          	sw	a5,-28(s0)

		/* Obtain the number of bytes it is possible to obtain in the first
		read.  Asserts check bounds of read and write. */
		configASSERT( xFirstLength <= xMaxCount );
c0009008:	fe442703          	lw	a4,-28(s0)
c000900c:	fd442783          	lw	a5,-44(s0)
c0009010:	00e7f863          	bgeu	a5,a4,c0009020 <prvReadBytesFromBuffer+0x80>
c0009014:	30047073          	csrci	mstatus,8
c0009018:	00100073          	ebreak
c000901c:	0000006f          	j	c000901c <prvReadBytesFromBuffer+0x7c>
		configASSERT( ( xNextTail + xFirstLength ) <= pxStreamBuffer->xLength );
c0009020:	fec42703          	lw	a4,-20(s0)
c0009024:	fe442783          	lw	a5,-28(s0)
c0009028:	00f70733          	add	a4,a4,a5
c000902c:	fdc42783          	lw	a5,-36(s0)
c0009030:	0087a783          	lw	a5,8(a5)
c0009034:	00e7f863          	bgeu	a5,a4,c0009044 <prvReadBytesFromBuffer+0xa4>
c0009038:	30047073          	csrci	mstatus,8
c000903c:	00100073          	ebreak
c0009040:	0000006f          	j	c0009040 <prvReadBytesFromBuffer+0xa0>
		( void ) memcpy( ( void * ) pucData, ( const void * ) &( pxStreamBuffer->pucBuffer[ xNextTail ] ), xFirstLength ); /*lint !e9087 memcpy() requires void *. */
c0009044:	fdc42783          	lw	a5,-36(s0)
c0009048:	0187a703          	lw	a4,24(a5)
c000904c:	fec42783          	lw	a5,-20(s0)
c0009050:	00f707b3          	add	a5,a4,a5
c0009054:	fe442603          	lw	a2,-28(s0)
c0009058:	00078593          	mv	a1,a5
c000905c:	fd842503          	lw	a0,-40(s0)
c0009060:	301140ef          	jal	ra,c001db60 <memcpy>

		/* If the total number of wanted bytes is greater than the number
		that could be read in the first read... */
		if( xCount > xFirstLength )
c0009064:	fe842703          	lw	a4,-24(s0)
c0009068:	fe442783          	lw	a5,-28(s0)
c000906c:	04e7f463          	bgeu	a5,a4,c00090b4 <prvReadBytesFromBuffer+0x114>
		{
			/*...then read the remaining bytes from the start of the buffer. */
			configASSERT( xCount <= xMaxCount );
c0009070:	fe842703          	lw	a4,-24(s0)
c0009074:	fd442783          	lw	a5,-44(s0)
c0009078:	00e7f863          	bgeu	a5,a4,c0009088 <prvReadBytesFromBuffer+0xe8>
c000907c:	30047073          	csrci	mstatus,8
c0009080:	00100073          	ebreak
c0009084:	0000006f          	j	c0009084 <prvReadBytesFromBuffer+0xe4>
			( void ) memcpy( ( void * ) &( pucData[ xFirstLength ] ), ( void * ) ( pxStreamBuffer->pucBuffer ), xCount - xFirstLength ); /*lint !e9087 memcpy() requires void *. */
c0009088:	fd842703          	lw	a4,-40(s0)
c000908c:	fe442783          	lw	a5,-28(s0)
c0009090:	00f706b3          	add	a3,a4,a5
c0009094:	fdc42783          	lw	a5,-36(s0)
c0009098:	0187a583          	lw	a1,24(a5)
c000909c:	fe842703          	lw	a4,-24(s0)
c00090a0:	fe442783          	lw	a5,-28(s0)
c00090a4:	40f707b3          	sub	a5,a4,a5
c00090a8:	00078613          	mv	a2,a5
c00090ac:	00068513          	mv	a0,a3
c00090b0:	2b1140ef          	jal	ra,c001db60 <memcpy>
			mtCOVERAGE_TEST_MARKER();
		}

		/* Move the tail pointer to effectively remove the data read from
		the buffer. */
		xNextTail += xCount;
c00090b4:	fec42703          	lw	a4,-20(s0)
c00090b8:	fe842783          	lw	a5,-24(s0)
c00090bc:	00f707b3          	add	a5,a4,a5
c00090c0:	fef42623          	sw	a5,-20(s0)

		if( xNextTail >= pxStreamBuffer->xLength )
c00090c4:	fdc42783          	lw	a5,-36(s0)
c00090c8:	0087a783          	lw	a5,8(a5)
c00090cc:	fec42703          	lw	a4,-20(s0)
c00090d0:	00f76c63          	bltu	a4,a5,c00090e8 <prvReadBytesFromBuffer+0x148>
		{
			xNextTail -= pxStreamBuffer->xLength;
c00090d4:	fdc42783          	lw	a5,-36(s0)
c00090d8:	0087a783          	lw	a5,8(a5)
c00090dc:	fec42703          	lw	a4,-20(s0)
c00090e0:	40f707b3          	sub	a5,a4,a5
c00090e4:	fef42623          	sw	a5,-20(s0)
		}

		pxStreamBuffer->xTail = xNextTail;
c00090e8:	fdc42783          	lw	a5,-36(s0)
c00090ec:	fec42703          	lw	a4,-20(s0)
c00090f0:	00e7a023          	sw	a4,0(a5)
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	return xCount;
c00090f4:	fe842783          	lw	a5,-24(s0)
}
c00090f8:	00078513          	mv	a0,a5
c00090fc:	02c12083          	lw	ra,44(sp)
c0009100:	02812403          	lw	s0,40(sp)
c0009104:	03010113          	addi	sp,sp,48
c0009108:	00008067          	ret

c000910c <prvBytesInBuffer>:
/*-----------------------------------------------------------*/

static size_t prvBytesInBuffer( const StreamBuffer_t * const pxStreamBuffer )
{
c000910c:	fd010113          	addi	sp,sp,-48
c0009110:	02812623          	sw	s0,44(sp)
c0009114:	03010413          	addi	s0,sp,48
c0009118:	fca42e23          	sw	a0,-36(s0)
/* Returns the distance between xTail and xHead. */
size_t xCount;

	xCount = pxStreamBuffer->xLength + pxStreamBuffer->xHead;
c000911c:	fdc42783          	lw	a5,-36(s0)
c0009120:	0087a703          	lw	a4,8(a5)
c0009124:	fdc42783          	lw	a5,-36(s0)
c0009128:	0047a783          	lw	a5,4(a5)
c000912c:	00f707b3          	add	a5,a4,a5
c0009130:	fef42623          	sw	a5,-20(s0)
	xCount -= pxStreamBuffer->xTail;
c0009134:	fdc42783          	lw	a5,-36(s0)
c0009138:	0007a783          	lw	a5,0(a5)
c000913c:	fec42703          	lw	a4,-20(s0)
c0009140:	40f707b3          	sub	a5,a4,a5
c0009144:	fef42623          	sw	a5,-20(s0)
	if ( xCount >= pxStreamBuffer->xLength )
c0009148:	fdc42783          	lw	a5,-36(s0)
c000914c:	0087a783          	lw	a5,8(a5)
c0009150:	fec42703          	lw	a4,-20(s0)
c0009154:	00f76c63          	bltu	a4,a5,c000916c <prvBytesInBuffer+0x60>
	{
		xCount -= pxStreamBuffer->xLength;
c0009158:	fdc42783          	lw	a5,-36(s0)
c000915c:	0087a783          	lw	a5,8(a5)
c0009160:	fec42703          	lw	a4,-20(s0)
c0009164:	40f707b3          	sub	a5,a4,a5
c0009168:	fef42623          	sw	a5,-20(s0)
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	return xCount;
c000916c:	fec42783          	lw	a5,-20(s0)
}
c0009170:	00078513          	mv	a0,a5
c0009174:	02c12403          	lw	s0,44(sp)
c0009178:	03010113          	addi	sp,sp,48
c000917c:	00008067          	ret

c0009180 <prvInitialiseNewStreamBuffer>:
static void prvInitialiseNewStreamBuffer( StreamBuffer_t * const pxStreamBuffer,
										  uint8_t * const pucBuffer,
										  size_t xBufferSizeBytes,
										  size_t xTriggerLevelBytes,
										  uint8_t ucFlags )
{
c0009180:	fc010113          	addi	sp,sp,-64
c0009184:	02112e23          	sw	ra,60(sp)
c0009188:	02812c23          	sw	s0,56(sp)
c000918c:	04010413          	addi	s0,sp,64
c0009190:	fca42e23          	sw	a0,-36(s0)
c0009194:	fcb42c23          	sw	a1,-40(s0)
c0009198:	fcc42a23          	sw	a2,-44(s0)
c000919c:	fcd42823          	sw	a3,-48(s0)
c00091a0:	00070793          	mv	a5,a4
c00091a4:	fcf407a3          	sb	a5,-49(s0)
	#if( configASSERT_DEFINED == 1 )
	{
		/* The value written just has to be identifiable when looking at the
		memory.  Don't use 0xA5 as that is the stack fill value and could
		result in confusion as to what is actually being observed. */
		const BaseType_t xWriteValue = 0x55;
c00091a8:	05500793          	li	a5,85
c00091ac:	fef42623          	sw	a5,-20(s0)
		configASSERT( memset( pucBuffer, ( int ) xWriteValue, xBufferSizeBytes ) == pucBuffer );
c00091b0:	fd442603          	lw	a2,-44(s0)
c00091b4:	fec42583          	lw	a1,-20(s0)
c00091b8:	fd842503          	lw	a0,-40(s0)
c00091bc:	2cd140ef          	jal	ra,c001dc88 <memset>
c00091c0:	00050713          	mv	a4,a0
c00091c4:	fd842783          	lw	a5,-40(s0)
c00091c8:	00e78863          	beq	a5,a4,c00091d8 <prvInitialiseNewStreamBuffer+0x58>
c00091cc:	30047073          	csrci	mstatus,8
c00091d0:	00100073          	ebreak
c00091d4:	0000006f          	j	c00091d4 <prvInitialiseNewStreamBuffer+0x54>
	} /*lint !e529 !e438 xWriteValue is only used if configASSERT() is defined. */
	#endif

	( void ) memset( ( void * ) pxStreamBuffer, 0x00, sizeof( StreamBuffer_t ) ); /*lint !e9087 memset() requires void *. */
c00091d8:	02400613          	li	a2,36
c00091dc:	00000593          	li	a1,0
c00091e0:	fdc42503          	lw	a0,-36(s0)
c00091e4:	2a5140ef          	jal	ra,c001dc88 <memset>
	pxStreamBuffer->pucBuffer = pucBuffer;
c00091e8:	fdc42783          	lw	a5,-36(s0)
c00091ec:	fd842703          	lw	a4,-40(s0)
c00091f0:	00e7ac23          	sw	a4,24(a5)
	pxStreamBuffer->xLength = xBufferSizeBytes;
c00091f4:	fdc42783          	lw	a5,-36(s0)
c00091f8:	fd442703          	lw	a4,-44(s0)
c00091fc:	00e7a423          	sw	a4,8(a5)
	pxStreamBuffer->xTriggerLevelBytes = xTriggerLevelBytes;
c0009200:	fdc42783          	lw	a5,-36(s0)
c0009204:	fd042703          	lw	a4,-48(s0)
c0009208:	00e7a623          	sw	a4,12(a5)
	pxStreamBuffer->ucFlags = ucFlags;
c000920c:	fdc42783          	lw	a5,-36(s0)
c0009210:	fcf44703          	lbu	a4,-49(s0)
c0009214:	00e78e23          	sb	a4,28(a5)
}
c0009218:	00000013          	nop
c000921c:	03c12083          	lw	ra,60(sp)
c0009220:	03812403          	lw	s0,56(sp)
c0009224:	04010113          	addi	sp,sp,64
c0009228:	00008067          	ret

c000922c <uxStreamBufferGetStreamBufferNumber>:

#if ( configUSE_TRACE_FACILITY == 1 )

	UBaseType_t uxStreamBufferGetStreamBufferNumber( StreamBufferHandle_t xStreamBuffer )
	{
c000922c:	fe010113          	addi	sp,sp,-32
c0009230:	00812e23          	sw	s0,28(sp)
c0009234:	02010413          	addi	s0,sp,32
c0009238:	fea42623          	sw	a0,-20(s0)
		return xStreamBuffer->uxStreamBufferNumber;
c000923c:	fec42783          	lw	a5,-20(s0)
c0009240:	0207a783          	lw	a5,32(a5)
	}
c0009244:	00078513          	mv	a0,a5
c0009248:	01c12403          	lw	s0,28(sp)
c000924c:	02010113          	addi	sp,sp,32
c0009250:	00008067          	ret

c0009254 <vStreamBufferSetStreamBufferNumber>:
/*-----------------------------------------------------------*/

#if ( configUSE_TRACE_FACILITY == 1 )

	void vStreamBufferSetStreamBufferNumber( StreamBufferHandle_t xStreamBuffer, UBaseType_t uxStreamBufferNumber )
	{
c0009254:	fe010113          	addi	sp,sp,-32
c0009258:	00812e23          	sw	s0,28(sp)
c000925c:	02010413          	addi	s0,sp,32
c0009260:	fea42623          	sw	a0,-20(s0)
c0009264:	feb42423          	sw	a1,-24(s0)
		xStreamBuffer->uxStreamBufferNumber = uxStreamBufferNumber;
c0009268:	fec42783          	lw	a5,-20(s0)
c000926c:	fe842703          	lw	a4,-24(s0)
c0009270:	02e7a023          	sw	a4,32(a5)
	}
c0009274:	00000013          	nop
c0009278:	01c12403          	lw	s0,28(sp)
c000927c:	02010113          	addi	sp,sp,32
c0009280:	00008067          	ret

c0009284 <ucStreamBufferGetStreamBufferType>:
/*-----------------------------------------------------------*/

#if ( configUSE_TRACE_FACILITY == 1 )

	uint8_t ucStreamBufferGetStreamBufferType( StreamBufferHandle_t xStreamBuffer )
	{
c0009284:	fe010113          	addi	sp,sp,-32
c0009288:	00812e23          	sw	s0,28(sp)
c000928c:	02010413          	addi	s0,sp,32
c0009290:	fea42623          	sw	a0,-20(s0)
		return ( xStreamBuffer->ucFlags & sbFLAGS_IS_MESSAGE_BUFFER );
c0009294:	fec42783          	lw	a5,-20(s0)
c0009298:	01c7c783          	lbu	a5,28(a5)
c000929c:	0017f793          	andi	a5,a5,1
c00092a0:	0ff7f793          	andi	a5,a5,255
	}
c00092a4:	00078513          	mv	a0,a5
c00092a8:	01c12403          	lw	s0,28(sp)
c00092ac:	02010113          	addi	sp,sp,32
c00092b0:	00008067          	ret

c00092b4 <pvPortMalloc>:
static size_t xBlockAllocatedBit = 0;

/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
c00092b4:	fd010113          	addi	sp,sp,-48
c00092b8:	02112623          	sw	ra,44(sp)
c00092bc:	02812423          	sw	s0,40(sp)
c00092c0:	03010413          	addi	s0,sp,48
c00092c4:	fca42e23          	sw	a0,-36(s0)
BlockLink_t *pxBlock, *pxPreviousBlock, *pxNewBlockLink;
void *pvReturn = NULL;
c00092c8:	fe042223          	sw	zero,-28(s0)

	vTaskSuspendAll();
c00092cc:	c90fa0ef          	jal	ra,c000375c <vTaskSuspendAll>
	{
		/* If this is the first call to malloc then the heap will require
		initialisation to setup the list of free blocks. */
		if( pxEnd == NULL )
c00092d0:	0803a797          	auipc	a5,0x803a
c00092d4:	3bc78793          	addi	a5,a5,956 # c804368c <pxEnd>
c00092d8:	0007a783          	lw	a5,0(a5)
c00092dc:	00079463          	bnez	a5,c00092e4 <pvPortMalloc+0x30>
		{
			prvHeapInit();
c00092e0:	3f4000ef          	jal	ra,c00096d4 <prvHeapInit>

		/* Check the requested block size is not so large that the top bit is
		set.  The top bit of the block size member of the BlockLink_t structure
		is used to determine who owns the block - the application or the
		kernel, so it must be free. */
		if( ( xWantedSize & xBlockAllocatedBit ) == 0 )
c00092e4:	0803a797          	auipc	a5,0x803a
c00092e8:	3bc78793          	addi	a5,a5,956 # c80436a0 <xBlockAllocatedBit>
c00092ec:	0007a703          	lw	a4,0(a5)
c00092f0:	fdc42783          	lw	a5,-36(s0)
c00092f4:	00f777b3          	and	a5,a4,a5
c00092f8:	20079063          	bnez	a5,c00094f8 <pvPortMalloc+0x244>
		{
			/* The wanted size is increased so it can contain a BlockLink_t
			structure in addition to the requested amount of bytes. */
			if( xWantedSize > 0 )
c00092fc:	fdc42783          	lw	a5,-36(s0)
c0009300:	04078463          	beqz	a5,c0009348 <pvPortMalloc+0x94>
			{
				xWantedSize += xHeapStructSize;
c0009304:	01000793          	li	a5,16
c0009308:	fdc42703          	lw	a4,-36(s0)
c000930c:	00f707b3          	add	a5,a4,a5
c0009310:	fcf42e23          	sw	a5,-36(s0)

				/* Ensure that blocks are always aligned to the required number
				of bytes. */
				if( ( xWantedSize & portBYTE_ALIGNMENT_MASK ) != 0x00 )
c0009314:	fdc42783          	lw	a5,-36(s0)
c0009318:	00f7f793          	andi	a5,a5,15
c000931c:	02078663          	beqz	a5,c0009348 <pvPortMalloc+0x94>
				{
					/* Byte alignment required. */
					xWantedSize += ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) );
c0009320:	fdc42783          	lw	a5,-36(s0)
c0009324:	ff07f793          	andi	a5,a5,-16
c0009328:	01078793          	addi	a5,a5,16
c000932c:	fcf42e23          	sw	a5,-36(s0)
					configASSERT( ( xWantedSize & portBYTE_ALIGNMENT_MASK ) == 0 );
c0009330:	fdc42783          	lw	a5,-36(s0)
c0009334:	00f7f793          	andi	a5,a5,15
c0009338:	00078863          	beqz	a5,c0009348 <pvPortMalloc+0x94>
c000933c:	30047073          	csrci	mstatus,8
c0009340:	00100073          	ebreak
c0009344:	0000006f          	j	c0009344 <pvPortMalloc+0x90>
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}

			if( ( xWantedSize > 0 ) && ( xWantedSize <= xFreeBytesRemaining ) )
c0009348:	fdc42783          	lw	a5,-36(s0)
c000934c:	1a078663          	beqz	a5,c00094f8 <pvPortMalloc+0x244>
c0009350:	0803a797          	auipc	a5,0x803a
c0009354:	34078793          	addi	a5,a5,832 # c8043690 <xFreeBytesRemaining>
c0009358:	0007a783          	lw	a5,0(a5)
c000935c:	fdc42703          	lw	a4,-36(s0)
c0009360:	18e7ec63          	bltu	a5,a4,c00094f8 <pvPortMalloc+0x244>
			{
				/* Traverse the list from the start	(lowest address) block until
				one	of adequate size is found. */
				pxPreviousBlock = &xStart;
c0009364:	0803a797          	auipc	a5,0x803a
c0009368:	32078793          	addi	a5,a5,800 # c8043684 <xStart>
c000936c:	fef42423          	sw	a5,-24(s0)
				pxBlock = xStart.pxNextFreeBlock;
c0009370:	0803a797          	auipc	a5,0x803a
c0009374:	31478793          	addi	a5,a5,788 # c8043684 <xStart>
c0009378:	0007a783          	lw	a5,0(a5)
c000937c:	fef42623          	sw	a5,-20(s0)
				while( ( pxBlock->xBlockSize < xWantedSize ) && ( pxBlock->pxNextFreeBlock != NULL ) )
c0009380:	0180006f          	j	c0009398 <pvPortMalloc+0xe4>
				{
					pxPreviousBlock = pxBlock;
c0009384:	fec42783          	lw	a5,-20(s0)
c0009388:	fef42423          	sw	a5,-24(s0)
					pxBlock = pxBlock->pxNextFreeBlock;
c000938c:	fec42783          	lw	a5,-20(s0)
c0009390:	0007a783          	lw	a5,0(a5)
c0009394:	fef42623          	sw	a5,-20(s0)
				while( ( pxBlock->xBlockSize < xWantedSize ) && ( pxBlock->pxNextFreeBlock != NULL ) )
c0009398:	fec42783          	lw	a5,-20(s0)
c000939c:	0047a783          	lw	a5,4(a5)
c00093a0:	fdc42703          	lw	a4,-36(s0)
c00093a4:	00e7f863          	bgeu	a5,a4,c00093b4 <pvPortMalloc+0x100>
c00093a8:	fec42783          	lw	a5,-20(s0)
c00093ac:	0007a783          	lw	a5,0(a5)
c00093b0:	fc079ae3          	bnez	a5,c0009384 <pvPortMalloc+0xd0>
				}

				/* If the end marker was reached then a block of adequate size
				was	not found. */
				if( pxBlock != pxEnd )
c00093b4:	0803a797          	auipc	a5,0x803a
c00093b8:	2d878793          	addi	a5,a5,728 # c804368c <pxEnd>
c00093bc:	0007a783          	lw	a5,0(a5)
c00093c0:	fec42703          	lw	a4,-20(s0)
c00093c4:	12f70a63          	beq	a4,a5,c00094f8 <pvPortMalloc+0x244>
				{
					/* Return the memory space pointed to - jumping over the
					BlockLink_t structure at its start. */
					pvReturn = ( void * ) ( ( ( uint8_t * ) pxPreviousBlock->pxNextFreeBlock ) + xHeapStructSize );
c00093c8:	fe842783          	lw	a5,-24(s0)
c00093cc:	0007a703          	lw	a4,0(a5)
c00093d0:	01000793          	li	a5,16
c00093d4:	00f707b3          	add	a5,a4,a5
c00093d8:	fef42223          	sw	a5,-28(s0)

					/* This block is being returned for use so must be taken out
					of the list of free blocks. */
					pxPreviousBlock->pxNextFreeBlock = pxBlock->pxNextFreeBlock;
c00093dc:	fec42783          	lw	a5,-20(s0)
c00093e0:	0007a703          	lw	a4,0(a5)
c00093e4:	fe842783          	lw	a5,-24(s0)
c00093e8:	00e7a023          	sw	a4,0(a5)

					/* If the block is larger than required it can be split into
					two. */
					if( ( pxBlock->xBlockSize - xWantedSize ) > heapMINIMUM_BLOCK_SIZE )
c00093ec:	fec42783          	lw	a5,-20(s0)
c00093f0:	0047a703          	lw	a4,4(a5)
c00093f4:	fdc42783          	lw	a5,-36(s0)
c00093f8:	40f70733          	sub	a4,a4,a5
c00093fc:	01000793          	li	a5,16
c0009400:	00179793          	slli	a5,a5,0x1
c0009404:	04e7fc63          	bgeu	a5,a4,c000945c <pvPortMalloc+0x1a8>
					{
						/* This block is to be split into two.  Create a new
						block following the number of bytes requested. The void
						cast is used to prevent byte alignment warnings from the
						compiler. */
						pxNewBlockLink = ( void * ) ( ( ( uint8_t * ) pxBlock ) + xWantedSize );
c0009408:	fec42703          	lw	a4,-20(s0)
c000940c:	fdc42783          	lw	a5,-36(s0)
c0009410:	00f707b3          	add	a5,a4,a5
c0009414:	fef42023          	sw	a5,-32(s0)
						configASSERT( ( ( ( size_t ) pxNewBlockLink ) & portBYTE_ALIGNMENT_MASK ) == 0 );
c0009418:	fe042783          	lw	a5,-32(s0)
c000941c:	00f7f793          	andi	a5,a5,15
c0009420:	00078863          	beqz	a5,c0009430 <pvPortMalloc+0x17c>
c0009424:	30047073          	csrci	mstatus,8
c0009428:	00100073          	ebreak
c000942c:	0000006f          	j	c000942c <pvPortMalloc+0x178>

						/* Calculate the sizes of two blocks split from the
						single block. */
						pxNewBlockLink->xBlockSize = pxBlock->xBlockSize - xWantedSize;
c0009430:	fec42783          	lw	a5,-20(s0)
c0009434:	0047a703          	lw	a4,4(a5)
c0009438:	fdc42783          	lw	a5,-36(s0)
c000943c:	40f70733          	sub	a4,a4,a5
c0009440:	fe042783          	lw	a5,-32(s0)
c0009444:	00e7a223          	sw	a4,4(a5)
						pxBlock->xBlockSize = xWantedSize;
c0009448:	fec42783          	lw	a5,-20(s0)
c000944c:	fdc42703          	lw	a4,-36(s0)
c0009450:	00e7a223          	sw	a4,4(a5)

						/* Insert the new block into the list of free blocks. */
						prvInsertBlockIntoFreeList( pxNewBlockLink );
c0009454:	fe042503          	lw	a0,-32(s0)
c0009458:	3d4000ef          	jal	ra,c000982c <prvInsertBlockIntoFreeList>
					else
					{
						mtCOVERAGE_TEST_MARKER();
					}

					xFreeBytesRemaining -= pxBlock->xBlockSize;
c000945c:	0803a797          	auipc	a5,0x803a
c0009460:	23478793          	addi	a5,a5,564 # c8043690 <xFreeBytesRemaining>
c0009464:	0007a703          	lw	a4,0(a5)
c0009468:	fec42783          	lw	a5,-20(s0)
c000946c:	0047a783          	lw	a5,4(a5)
c0009470:	40f70733          	sub	a4,a4,a5
c0009474:	0803a797          	auipc	a5,0x803a
c0009478:	21c78793          	addi	a5,a5,540 # c8043690 <xFreeBytesRemaining>
c000947c:	00e7a023          	sw	a4,0(a5)

					if( xFreeBytesRemaining < xMinimumEverFreeBytesRemaining )
c0009480:	0803a797          	auipc	a5,0x803a
c0009484:	21078793          	addi	a5,a5,528 # c8043690 <xFreeBytesRemaining>
c0009488:	0007a703          	lw	a4,0(a5)
c000948c:	0803a797          	auipc	a5,0x803a
c0009490:	20878793          	addi	a5,a5,520 # c8043694 <xMinimumEverFreeBytesRemaining>
c0009494:	0007a783          	lw	a5,0(a5)
c0009498:	00f77e63          	bgeu	a4,a5,c00094b4 <pvPortMalloc+0x200>
					{
						xMinimumEverFreeBytesRemaining = xFreeBytesRemaining;
c000949c:	0803a797          	auipc	a5,0x803a
c00094a0:	1f478793          	addi	a5,a5,500 # c8043690 <xFreeBytesRemaining>
c00094a4:	0007a703          	lw	a4,0(a5)
c00094a8:	0803a797          	auipc	a5,0x803a
c00094ac:	1ec78793          	addi	a5,a5,492 # c8043694 <xMinimumEverFreeBytesRemaining>
c00094b0:	00e7a023          	sw	a4,0(a5)
						mtCOVERAGE_TEST_MARKER();
					}

					/* The block is being returned - it is allocated and owned
					by the application and has no "next" block. */
					pxBlock->xBlockSize |= xBlockAllocatedBit;
c00094b4:	fec42783          	lw	a5,-20(s0)
c00094b8:	0047a703          	lw	a4,4(a5)
c00094bc:	0803a797          	auipc	a5,0x803a
c00094c0:	1e478793          	addi	a5,a5,484 # c80436a0 <xBlockAllocatedBit>
c00094c4:	0007a783          	lw	a5,0(a5)
c00094c8:	00f76733          	or	a4,a4,a5
c00094cc:	fec42783          	lw	a5,-20(s0)
c00094d0:	00e7a223          	sw	a4,4(a5)
					pxBlock->pxNextFreeBlock = NULL;
c00094d4:	fec42783          	lw	a5,-20(s0)
c00094d8:	0007a023          	sw	zero,0(a5)
					xNumberOfSuccessfulAllocations++;
c00094dc:	0803a797          	auipc	a5,0x803a
c00094e0:	1bc78793          	addi	a5,a5,444 # c8043698 <xNumberOfSuccessfulAllocations>
c00094e4:	0007a783          	lw	a5,0(a5)
c00094e8:	00178713          	addi	a4,a5,1
c00094ec:	0803a797          	auipc	a5,0x803a
c00094f0:	1ac78793          	addi	a5,a5,428 # c8043698 <xNumberOfSuccessfulAllocations>
c00094f4:	00e7a023          	sw	a4,0(a5)
			mtCOVERAGE_TEST_MARKER();
		}

		traceMALLOC( pvReturn, xWantedSize );
	}
	( void ) xTaskResumeAll();
c00094f8:	a9cfa0ef          	jal	ra,c0003794 <xTaskResumeAll>

	#if( configUSE_MALLOC_FAILED_HOOK == 1 )
	{
		if( pvReturn == NULL )
c00094fc:	fe442783          	lw	a5,-28(s0)
c0009500:	00079463          	bnez	a5,c0009508 <pvPortMalloc+0x254>
		{
			extern void vApplicationMallocFailedHook( void );
			vApplicationMallocFailedHook();
c0009504:	67c000ef          	jal	ra,c0009b80 <vApplicationMallocFailedHook>
			mtCOVERAGE_TEST_MARKER();
		}
	}
	#endif

	configASSERT( ( ( ( size_t ) pvReturn ) & ( size_t ) portBYTE_ALIGNMENT_MASK ) == 0 );
c0009508:	fe442783          	lw	a5,-28(s0)
c000950c:	00f7f793          	andi	a5,a5,15
c0009510:	00078863          	beqz	a5,c0009520 <pvPortMalloc+0x26c>
c0009514:	30047073          	csrci	mstatus,8
c0009518:	00100073          	ebreak
c000951c:	0000006f          	j	c000951c <pvPortMalloc+0x268>
	return pvReturn;
c0009520:	fe442783          	lw	a5,-28(s0)
}
c0009524:	00078513          	mv	a0,a5
c0009528:	02c12083          	lw	ra,44(sp)
c000952c:	02812403          	lw	s0,40(sp)
c0009530:	03010113          	addi	sp,sp,48
c0009534:	00008067          	ret

c0009538 <vPortFree>:
/*-----------------------------------------------------------*/

void vPortFree( void *pv )
{
c0009538:	fd010113          	addi	sp,sp,-48
c000953c:	02112623          	sw	ra,44(sp)
c0009540:	02812423          	sw	s0,40(sp)
c0009544:	03010413          	addi	s0,sp,48
c0009548:	fca42e23          	sw	a0,-36(s0)
uint8_t *puc = ( uint8_t * ) pv;
c000954c:	fdc42783          	lw	a5,-36(s0)
c0009550:	fef42623          	sw	a5,-20(s0)
BlockLink_t *pxLink;

	if( pv != NULL )
c0009554:	fdc42783          	lw	a5,-36(s0)
c0009558:	0e078e63          	beqz	a5,c0009654 <vPortFree+0x11c>
	{
		/* The memory being freed will have an BlockLink_t structure immediately
		before it. */
		puc -= xHeapStructSize;
c000955c:	01000793          	li	a5,16
c0009560:	40f007b3          	neg	a5,a5
c0009564:	fec42703          	lw	a4,-20(s0)
c0009568:	00f707b3          	add	a5,a4,a5
c000956c:	fef42623          	sw	a5,-20(s0)

		/* This casting is to keep the compiler from issuing warnings. */
		pxLink = ( void * ) puc;
c0009570:	fec42783          	lw	a5,-20(s0)
c0009574:	fef42423          	sw	a5,-24(s0)

		/* Check the block is actually allocated. */
		configASSERT( ( pxLink->xBlockSize & xBlockAllocatedBit ) != 0 );
c0009578:	fe842783          	lw	a5,-24(s0)
c000957c:	0047a703          	lw	a4,4(a5)
c0009580:	0803a797          	auipc	a5,0x803a
c0009584:	12078793          	addi	a5,a5,288 # c80436a0 <xBlockAllocatedBit>
c0009588:	0007a783          	lw	a5,0(a5)
c000958c:	00f777b3          	and	a5,a4,a5
c0009590:	00079863          	bnez	a5,c00095a0 <vPortFree+0x68>
c0009594:	30047073          	csrci	mstatus,8
c0009598:	00100073          	ebreak
c000959c:	0000006f          	j	c000959c <vPortFree+0x64>
		configASSERT( pxLink->pxNextFreeBlock == NULL );
c00095a0:	fe842783          	lw	a5,-24(s0)
c00095a4:	0007a783          	lw	a5,0(a5)
c00095a8:	00078863          	beqz	a5,c00095b8 <vPortFree+0x80>
c00095ac:	30047073          	csrci	mstatus,8
c00095b0:	00100073          	ebreak
c00095b4:	0000006f          	j	c00095b4 <vPortFree+0x7c>

		if( ( pxLink->xBlockSize & xBlockAllocatedBit ) != 0 )
c00095b8:	fe842783          	lw	a5,-24(s0)
c00095bc:	0047a703          	lw	a4,4(a5)
c00095c0:	0803a797          	auipc	a5,0x803a
c00095c4:	0e078793          	addi	a5,a5,224 # c80436a0 <xBlockAllocatedBit>
c00095c8:	0007a783          	lw	a5,0(a5)
c00095cc:	00f777b3          	and	a5,a4,a5
c00095d0:	08078263          	beqz	a5,c0009654 <vPortFree+0x11c>
		{
			if( pxLink->pxNextFreeBlock == NULL )
c00095d4:	fe842783          	lw	a5,-24(s0)
c00095d8:	0007a783          	lw	a5,0(a5)
c00095dc:	06079c63          	bnez	a5,c0009654 <vPortFree+0x11c>
			{
				/* The block is being returned to the heap - it is no longer
				allocated. */
				pxLink->xBlockSize &= ~xBlockAllocatedBit;
c00095e0:	fe842783          	lw	a5,-24(s0)
c00095e4:	0047a703          	lw	a4,4(a5)
c00095e8:	0803a797          	auipc	a5,0x803a
c00095ec:	0b878793          	addi	a5,a5,184 # c80436a0 <xBlockAllocatedBit>
c00095f0:	0007a783          	lw	a5,0(a5)
c00095f4:	fff7c793          	not	a5,a5
c00095f8:	00f77733          	and	a4,a4,a5
c00095fc:	fe842783          	lw	a5,-24(s0)
c0009600:	00e7a223          	sw	a4,4(a5)

				vTaskSuspendAll();
c0009604:	958fa0ef          	jal	ra,c000375c <vTaskSuspendAll>
				{
					/* Add this block to the list of free blocks. */
					xFreeBytesRemaining += pxLink->xBlockSize;
c0009608:	fe842783          	lw	a5,-24(s0)
c000960c:	0047a703          	lw	a4,4(a5)
c0009610:	0803a797          	auipc	a5,0x803a
c0009614:	08078793          	addi	a5,a5,128 # c8043690 <xFreeBytesRemaining>
c0009618:	0007a783          	lw	a5,0(a5)
c000961c:	00f70733          	add	a4,a4,a5
c0009620:	0803a797          	auipc	a5,0x803a
c0009624:	07078793          	addi	a5,a5,112 # c8043690 <xFreeBytesRemaining>
c0009628:	00e7a023          	sw	a4,0(a5)
					traceFREE( pv, pxLink->xBlockSize );
					prvInsertBlockIntoFreeList( ( ( BlockLink_t * ) pxLink ) );
c000962c:	fe842503          	lw	a0,-24(s0)
c0009630:	1fc000ef          	jal	ra,c000982c <prvInsertBlockIntoFreeList>
					xNumberOfSuccessfulFrees++;
c0009634:	0803a797          	auipc	a5,0x803a
c0009638:	06878793          	addi	a5,a5,104 # c804369c <xNumberOfSuccessfulFrees>
c000963c:	0007a783          	lw	a5,0(a5)
c0009640:	00178713          	addi	a4,a5,1
c0009644:	0803a797          	auipc	a5,0x803a
c0009648:	05878793          	addi	a5,a5,88 # c804369c <xNumberOfSuccessfulFrees>
c000964c:	00e7a023          	sw	a4,0(a5)
				}
				( void ) xTaskResumeAll();
c0009650:	944fa0ef          	jal	ra,c0003794 <xTaskResumeAll>
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
}
c0009654:	00000013          	nop
c0009658:	02c12083          	lw	ra,44(sp)
c000965c:	02812403          	lw	s0,40(sp)
c0009660:	03010113          	addi	sp,sp,48
c0009664:	00008067          	ret

c0009668 <xPortGetFreeHeapSize>:
/*-----------------------------------------------------------*/

size_t xPortGetFreeHeapSize( void )
{
c0009668:	ff010113          	addi	sp,sp,-16
c000966c:	00812623          	sw	s0,12(sp)
c0009670:	01010413          	addi	s0,sp,16
	return xFreeBytesRemaining;
c0009674:	0803a797          	auipc	a5,0x803a
c0009678:	01c78793          	addi	a5,a5,28 # c8043690 <xFreeBytesRemaining>
c000967c:	0007a783          	lw	a5,0(a5)
}
c0009680:	00078513          	mv	a0,a5
c0009684:	00c12403          	lw	s0,12(sp)
c0009688:	01010113          	addi	sp,sp,16
c000968c:	00008067          	ret

c0009690 <xPortGetMinimumEverFreeHeapSize>:
/*-----------------------------------------------------------*/

size_t xPortGetMinimumEverFreeHeapSize( void )
{
c0009690:	ff010113          	addi	sp,sp,-16
c0009694:	00812623          	sw	s0,12(sp)
c0009698:	01010413          	addi	s0,sp,16
	return xMinimumEverFreeBytesRemaining;
c000969c:	0803a797          	auipc	a5,0x803a
c00096a0:	ff878793          	addi	a5,a5,-8 # c8043694 <xMinimumEverFreeBytesRemaining>
c00096a4:	0007a783          	lw	a5,0(a5)
}
c00096a8:	00078513          	mv	a0,a5
c00096ac:	00c12403          	lw	s0,12(sp)
c00096b0:	01010113          	addi	sp,sp,16
c00096b4:	00008067          	ret

c00096b8 <vPortInitialiseBlocks>:
/*-----------------------------------------------------------*/

void vPortInitialiseBlocks( void )
{
c00096b8:	ff010113          	addi	sp,sp,-16
c00096bc:	00812623          	sw	s0,12(sp)
c00096c0:	01010413          	addi	s0,sp,16
	/* This just exists to keep the linker quiet. */
}
c00096c4:	00000013          	nop
c00096c8:	00c12403          	lw	s0,12(sp)
c00096cc:	01010113          	addi	sp,sp,16
c00096d0:	00008067          	ret

c00096d4 <prvHeapInit>:
/*-----------------------------------------------------------*/

static void prvHeapInit( void )
{
c00096d4:	fe010113          	addi	sp,sp,-32
c00096d8:	00812e23          	sw	s0,28(sp)
c00096dc:	02010413          	addi	s0,sp,32
BlockLink_t *pxFirstFreeBlock;
uint8_t *pucAlignedHeap;
size_t uxAddress;
size_t xTotalHeapSize = configTOTAL_HEAP_SIZE;
c00096e0:	000407b7          	lui	a5,0x40
c00096e4:	fef42423          	sw	a5,-24(s0)

	/* Ensure the heap starts on a correctly aligned boundary. */
	uxAddress = ( size_t ) ucHeap;
c00096e8:	07ffa797          	auipc	a5,0x7ffa
c00096ec:	f9c78793          	addi	a5,a5,-100 # c8003684 <ucHeap>
c00096f0:	fef42623          	sw	a5,-20(s0)

	if( ( uxAddress & portBYTE_ALIGNMENT_MASK ) != 0 )
c00096f4:	fec42783          	lw	a5,-20(s0)
c00096f8:	00f7f793          	andi	a5,a5,15
c00096fc:	02078c63          	beqz	a5,c0009734 <prvHeapInit+0x60>
	{
		uxAddress += ( portBYTE_ALIGNMENT - 1 );
c0009700:	fec42783          	lw	a5,-20(s0)
c0009704:	00f78793          	addi	a5,a5,15
c0009708:	fef42623          	sw	a5,-20(s0)
		uxAddress &= ~( ( size_t ) portBYTE_ALIGNMENT_MASK );
c000970c:	fec42783          	lw	a5,-20(s0)
c0009710:	ff07f793          	andi	a5,a5,-16
c0009714:	fef42623          	sw	a5,-20(s0)
		xTotalHeapSize -= uxAddress - ( size_t ) ucHeap;
c0009718:	fe842703          	lw	a4,-24(s0)
c000971c:	fec42783          	lw	a5,-20(s0)
c0009720:	40f70733          	sub	a4,a4,a5
c0009724:	07ffa797          	auipc	a5,0x7ffa
c0009728:	f6078793          	addi	a5,a5,-160 # c8003684 <ucHeap>
c000972c:	00f707b3          	add	a5,a4,a5
c0009730:	fef42423          	sw	a5,-24(s0)
	}

	pucAlignedHeap = ( uint8_t * ) uxAddress;
c0009734:	fec42783          	lw	a5,-20(s0)
c0009738:	fef42223          	sw	a5,-28(s0)

	/* xStart is used to hold a pointer to the first item in the list of free
	blocks.  The void cast is used to prevent compiler warnings. */
	xStart.pxNextFreeBlock = ( void * ) pucAlignedHeap;
c000973c:	0803a797          	auipc	a5,0x803a
c0009740:	f4878793          	addi	a5,a5,-184 # c8043684 <xStart>
c0009744:	fe442703          	lw	a4,-28(s0)
c0009748:	00e7a023          	sw	a4,0(a5)
	xStart.xBlockSize = ( size_t ) 0;
c000974c:	0803a797          	auipc	a5,0x803a
c0009750:	f3878793          	addi	a5,a5,-200 # c8043684 <xStart>
c0009754:	0007a223          	sw	zero,4(a5)

	/* pxEnd is used to mark the end of the list of free blocks and is inserted
	at the end of the heap space. */
	uxAddress = ( ( size_t ) pucAlignedHeap ) + xTotalHeapSize;
c0009758:	fe442783          	lw	a5,-28(s0)
c000975c:	fe842703          	lw	a4,-24(s0)
c0009760:	00f707b3          	add	a5,a4,a5
c0009764:	fef42623          	sw	a5,-20(s0)
	uxAddress -= xHeapStructSize;
c0009768:	01000793          	li	a5,16
c000976c:	fec42703          	lw	a4,-20(s0)
c0009770:	40f707b3          	sub	a5,a4,a5
c0009774:	fef42623          	sw	a5,-20(s0)
	uxAddress &= ~( ( size_t ) portBYTE_ALIGNMENT_MASK );
c0009778:	fec42783          	lw	a5,-20(s0)
c000977c:	ff07f793          	andi	a5,a5,-16
c0009780:	fef42623          	sw	a5,-20(s0)
	pxEnd = ( void * ) uxAddress;
c0009784:	fec42703          	lw	a4,-20(s0)
c0009788:	0803a797          	auipc	a5,0x803a
c000978c:	f0478793          	addi	a5,a5,-252 # c804368c <pxEnd>
c0009790:	00e7a023          	sw	a4,0(a5)
	pxEnd->xBlockSize = 0;
c0009794:	0803a797          	auipc	a5,0x803a
c0009798:	ef878793          	addi	a5,a5,-264 # c804368c <pxEnd>
c000979c:	0007a783          	lw	a5,0(a5)
c00097a0:	0007a223          	sw	zero,4(a5)
	pxEnd->pxNextFreeBlock = NULL;
c00097a4:	0803a797          	auipc	a5,0x803a
c00097a8:	ee878793          	addi	a5,a5,-280 # c804368c <pxEnd>
c00097ac:	0007a783          	lw	a5,0(a5)
c00097b0:	0007a023          	sw	zero,0(a5)

	/* To start with there is a single free block that is sized to take up the
	entire heap space, minus the space taken by pxEnd. */
	pxFirstFreeBlock = ( void * ) pucAlignedHeap;
c00097b4:	fe442783          	lw	a5,-28(s0)
c00097b8:	fef42023          	sw	a5,-32(s0)
	pxFirstFreeBlock->xBlockSize = uxAddress - ( size_t ) pxFirstFreeBlock;
c00097bc:	fe042783          	lw	a5,-32(s0)
c00097c0:	fec42703          	lw	a4,-20(s0)
c00097c4:	40f70733          	sub	a4,a4,a5
c00097c8:	fe042783          	lw	a5,-32(s0)
c00097cc:	00e7a223          	sw	a4,4(a5)
	pxFirstFreeBlock->pxNextFreeBlock = pxEnd;
c00097d0:	0803a797          	auipc	a5,0x803a
c00097d4:	ebc78793          	addi	a5,a5,-324 # c804368c <pxEnd>
c00097d8:	0007a703          	lw	a4,0(a5)
c00097dc:	fe042783          	lw	a5,-32(s0)
c00097e0:	00e7a023          	sw	a4,0(a5)

	/* Only one block exists - and it covers the entire usable heap space. */
	xMinimumEverFreeBytesRemaining = pxFirstFreeBlock->xBlockSize;
c00097e4:	fe042783          	lw	a5,-32(s0)
c00097e8:	0047a703          	lw	a4,4(a5)
c00097ec:	0803a797          	auipc	a5,0x803a
c00097f0:	ea878793          	addi	a5,a5,-344 # c8043694 <xMinimumEverFreeBytesRemaining>
c00097f4:	00e7a023          	sw	a4,0(a5)
	xFreeBytesRemaining = pxFirstFreeBlock->xBlockSize;
c00097f8:	fe042783          	lw	a5,-32(s0)
c00097fc:	0047a703          	lw	a4,4(a5)
c0009800:	0803a797          	auipc	a5,0x803a
c0009804:	e9078793          	addi	a5,a5,-368 # c8043690 <xFreeBytesRemaining>
c0009808:	00e7a023          	sw	a4,0(a5)

	/* Work out the position of the top bit in a size_t variable. */
	xBlockAllocatedBit = ( ( size_t ) 1 ) << ( ( sizeof( size_t ) * heapBITS_PER_BYTE ) - 1 );
c000980c:	0803a797          	auipc	a5,0x803a
c0009810:	e9478793          	addi	a5,a5,-364 # c80436a0 <xBlockAllocatedBit>
c0009814:	80000737          	lui	a4,0x80000
c0009818:	00e7a023          	sw	a4,0(a5)
}
c000981c:	00000013          	nop
c0009820:	01c12403          	lw	s0,28(sp)
c0009824:	02010113          	addi	sp,sp,32
c0009828:	00008067          	ret

c000982c <prvInsertBlockIntoFreeList>:
/*-----------------------------------------------------------*/

static void prvInsertBlockIntoFreeList( BlockLink_t *pxBlockToInsert )
{
c000982c:	fd010113          	addi	sp,sp,-48
c0009830:	02812623          	sw	s0,44(sp)
c0009834:	03010413          	addi	s0,sp,48
c0009838:	fca42e23          	sw	a0,-36(s0)
BlockLink_t *pxIterator;
uint8_t *puc;

	/* Iterate through the list until a block is found that has a higher address
	than the block being inserted. */
	for( pxIterator = &xStart; pxIterator->pxNextFreeBlock < pxBlockToInsert; pxIterator = pxIterator->pxNextFreeBlock )
c000983c:	0803a797          	auipc	a5,0x803a
c0009840:	e4878793          	addi	a5,a5,-440 # c8043684 <xStart>
c0009844:	fef42623          	sw	a5,-20(s0)
c0009848:	0100006f          	j	c0009858 <prvInsertBlockIntoFreeList+0x2c>
c000984c:	fec42783          	lw	a5,-20(s0)
c0009850:	0007a783          	lw	a5,0(a5)
c0009854:	fef42623          	sw	a5,-20(s0)
c0009858:	fec42783          	lw	a5,-20(s0)
c000985c:	0007a783          	lw	a5,0(a5)
c0009860:	fdc42703          	lw	a4,-36(s0)
c0009864:	fee7e4e3          	bltu	a5,a4,c000984c <prvInsertBlockIntoFreeList+0x20>
		/* Nothing to do here, just iterate to the right position. */
	}

	/* Do the block being inserted, and the block it is being inserted after
	make a contiguous block of memory? */
	puc = ( uint8_t * ) pxIterator;
c0009868:	fec42783          	lw	a5,-20(s0)
c000986c:	fef42423          	sw	a5,-24(s0)
	if( ( puc + pxIterator->xBlockSize ) == ( uint8_t * ) pxBlockToInsert )
c0009870:	fec42783          	lw	a5,-20(s0)
c0009874:	0047a783          	lw	a5,4(a5)
c0009878:	fe842703          	lw	a4,-24(s0)
c000987c:	00f707b3          	add	a5,a4,a5
c0009880:	fdc42703          	lw	a4,-36(s0)
c0009884:	02f71463          	bne	a4,a5,c00098ac <prvInsertBlockIntoFreeList+0x80>
	{
		pxIterator->xBlockSize += pxBlockToInsert->xBlockSize;
c0009888:	fec42783          	lw	a5,-20(s0)
c000988c:	0047a703          	lw	a4,4(a5)
c0009890:	fdc42783          	lw	a5,-36(s0)
c0009894:	0047a783          	lw	a5,4(a5)
c0009898:	00f70733          	add	a4,a4,a5
c000989c:	fec42783          	lw	a5,-20(s0)
c00098a0:	00e7a223          	sw	a4,4(a5)
		pxBlockToInsert = pxIterator;
c00098a4:	fec42783          	lw	a5,-20(s0)
c00098a8:	fcf42e23          	sw	a5,-36(s0)
		mtCOVERAGE_TEST_MARKER();
	}

	/* Do the block being inserted, and the block it is being inserted before
	make a contiguous block of memory? */
	puc = ( uint8_t * ) pxBlockToInsert;
c00098ac:	fdc42783          	lw	a5,-36(s0)
c00098b0:	fef42423          	sw	a5,-24(s0)
	if( ( puc + pxBlockToInsert->xBlockSize ) == ( uint8_t * ) pxIterator->pxNextFreeBlock )
c00098b4:	fdc42783          	lw	a5,-36(s0)
c00098b8:	0047a783          	lw	a5,4(a5)
c00098bc:	fe842703          	lw	a4,-24(s0)
c00098c0:	00f70733          	add	a4,a4,a5
c00098c4:	fec42783          	lw	a5,-20(s0)
c00098c8:	0007a783          	lw	a5,0(a5)
c00098cc:	06f71663          	bne	a4,a5,c0009938 <prvInsertBlockIntoFreeList+0x10c>
	{
		if( pxIterator->pxNextFreeBlock != pxEnd )
c00098d0:	fec42783          	lw	a5,-20(s0)
c00098d4:	0007a703          	lw	a4,0(a5)
c00098d8:	0803a797          	auipc	a5,0x803a
c00098dc:	db478793          	addi	a5,a5,-588 # c804368c <pxEnd>
c00098e0:	0007a783          	lw	a5,0(a5)
c00098e4:	02f70e63          	beq	a4,a5,c0009920 <prvInsertBlockIntoFreeList+0xf4>
		{
			/* Form one big block from the two blocks. */
			pxBlockToInsert->xBlockSize += pxIterator->pxNextFreeBlock->xBlockSize;
c00098e8:	fdc42783          	lw	a5,-36(s0)
c00098ec:	0047a703          	lw	a4,4(a5)
c00098f0:	fec42783          	lw	a5,-20(s0)
c00098f4:	0007a783          	lw	a5,0(a5)
c00098f8:	0047a783          	lw	a5,4(a5)
c00098fc:	00f70733          	add	a4,a4,a5
c0009900:	fdc42783          	lw	a5,-36(s0)
c0009904:	00e7a223          	sw	a4,4(a5)
			pxBlockToInsert->pxNextFreeBlock = pxIterator->pxNextFreeBlock->pxNextFreeBlock;
c0009908:	fec42783          	lw	a5,-20(s0)
c000990c:	0007a783          	lw	a5,0(a5)
c0009910:	0007a703          	lw	a4,0(a5)
c0009914:	fdc42783          	lw	a5,-36(s0)
c0009918:	00e7a023          	sw	a4,0(a5)
c000991c:	02c0006f          	j	c0009948 <prvInsertBlockIntoFreeList+0x11c>
		}
		else
		{
			pxBlockToInsert->pxNextFreeBlock = pxEnd;
c0009920:	0803a797          	auipc	a5,0x803a
c0009924:	d6c78793          	addi	a5,a5,-660 # c804368c <pxEnd>
c0009928:	0007a703          	lw	a4,0(a5)
c000992c:	fdc42783          	lw	a5,-36(s0)
c0009930:	00e7a023          	sw	a4,0(a5)
c0009934:	0140006f          	j	c0009948 <prvInsertBlockIntoFreeList+0x11c>
		}
	}
	else
	{
		pxBlockToInsert->pxNextFreeBlock = pxIterator->pxNextFreeBlock;
c0009938:	fec42783          	lw	a5,-20(s0)
c000993c:	0007a703          	lw	a4,0(a5)
c0009940:	fdc42783          	lw	a5,-36(s0)
c0009944:	00e7a023          	sw	a4,0(a5)

	/* If the block being inserted plugged a gab, so was merged with the block
	before and the block after, then it's pxNextFreeBlock pointer will have
	already been set, and should not be set here as that would make it point
	to itself. */
	if( pxIterator != pxBlockToInsert )
c0009948:	fec42703          	lw	a4,-20(s0)
c000994c:	fdc42783          	lw	a5,-36(s0)
c0009950:	00f70863          	beq	a4,a5,c0009960 <prvInsertBlockIntoFreeList+0x134>
	{
		pxIterator->pxNextFreeBlock = pxBlockToInsert;
c0009954:	fec42783          	lw	a5,-20(s0)
c0009958:	fdc42703          	lw	a4,-36(s0)
c000995c:	00e7a023          	sw	a4,0(a5)
	}
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}
}
c0009960:	00000013          	nop
c0009964:	02c12403          	lw	s0,44(sp)
c0009968:	03010113          	addi	sp,sp,48
c000996c:	00008067          	ret

c0009970 <vPortGetHeapStats>:
/*-----------------------------------------------------------*/

void vPortGetHeapStats( HeapStats_t *pxHeapStats )
{
c0009970:	fd010113          	addi	sp,sp,-48
c0009974:	02112623          	sw	ra,44(sp)
c0009978:	02812423          	sw	s0,40(sp)
c000997c:	03010413          	addi	s0,sp,48
c0009980:	fca42e23          	sw	a0,-36(s0)
BlockLink_t *pxBlock;
size_t xBlocks = 0, xMaxSize = 0, xMinSize = portMAX_DELAY; /* portMAX_DELAY used as a portable way of getting the maximum value. */
c0009984:	fe042423          	sw	zero,-24(s0)
c0009988:	fe042223          	sw	zero,-28(s0)
c000998c:	fff00793          	li	a5,-1
c0009990:	fef42023          	sw	a5,-32(s0)

	vTaskSuspendAll();
c0009994:	dc9f90ef          	jal	ra,c000375c <vTaskSuspendAll>
	{
		pxBlock = xStart.pxNextFreeBlock;
c0009998:	0803a797          	auipc	a5,0x803a
c000999c:	cec78793          	addi	a5,a5,-788 # c8043684 <xStart>
c00099a0:	0007a783          	lw	a5,0(a5)
c00099a4:	fef42623          	sw	a5,-20(s0)

		/* pxBlock will be NULL if the heap has not been initialised.  The heap
		is initialised automatically when the first allocation is made. */
		if( pxBlock != NULL )
c00099a8:	fec42783          	lw	a5,-20(s0)
c00099ac:	06078463          	beqz	a5,c0009a14 <vPortGetHeapStats+0xa4>
		{
			do
			{
				/* Increment the number of blocks and record the largest block seen
				so far. */
				xBlocks++;
c00099b0:	fe842783          	lw	a5,-24(s0)
c00099b4:	00178793          	addi	a5,a5,1
c00099b8:	fef42423          	sw	a5,-24(s0)

				if( pxBlock->xBlockSize > xMaxSize )
c00099bc:	fec42783          	lw	a5,-20(s0)
c00099c0:	0047a783          	lw	a5,4(a5)
c00099c4:	fe442703          	lw	a4,-28(s0)
c00099c8:	00f77863          	bgeu	a4,a5,c00099d8 <vPortGetHeapStats+0x68>
				{
					xMaxSize = pxBlock->xBlockSize;
c00099cc:	fec42783          	lw	a5,-20(s0)
c00099d0:	0047a783          	lw	a5,4(a5)
c00099d4:	fef42223          	sw	a5,-28(s0)
				}

				if( pxBlock->xBlockSize < xMinSize )
c00099d8:	fec42783          	lw	a5,-20(s0)
c00099dc:	0047a783          	lw	a5,4(a5)
c00099e0:	fe042703          	lw	a4,-32(s0)
c00099e4:	00e7f863          	bgeu	a5,a4,c00099f4 <vPortGetHeapStats+0x84>
				{
					xMinSize = pxBlock->xBlockSize;
c00099e8:	fec42783          	lw	a5,-20(s0)
c00099ec:	0047a783          	lw	a5,4(a5)
c00099f0:	fef42023          	sw	a5,-32(s0)
				}

				/* Move to the next block in the chain until the last block is
				reached. */
				pxBlock = pxBlock->pxNextFreeBlock;
c00099f4:	fec42783          	lw	a5,-20(s0)
c00099f8:	0007a783          	lw	a5,0(a5)
c00099fc:	fef42623          	sw	a5,-20(s0)
			} while( pxBlock != pxEnd );
c0009a00:	0803a797          	auipc	a5,0x803a
c0009a04:	c8c78793          	addi	a5,a5,-884 # c804368c <pxEnd>
c0009a08:	0007a783          	lw	a5,0(a5)
c0009a0c:	fec42703          	lw	a4,-20(s0)
c0009a10:	faf710e3          	bne	a4,a5,c00099b0 <vPortGetHeapStats+0x40>
		}
	}
	xTaskResumeAll();
c0009a14:	d81f90ef          	jal	ra,c0003794 <xTaskResumeAll>

	pxHeapStats->xSizeOfLargestFreeBlockInBytes = xMaxSize;
c0009a18:	fdc42783          	lw	a5,-36(s0)
c0009a1c:	fe442703          	lw	a4,-28(s0)
c0009a20:	00e7a223          	sw	a4,4(a5)
	pxHeapStats->xSizeOfSmallestFreeBlockInBytes = xMinSize;
c0009a24:	fdc42783          	lw	a5,-36(s0)
c0009a28:	fe042703          	lw	a4,-32(s0)
c0009a2c:	00e7a423          	sw	a4,8(a5)
	pxHeapStats->xNumberOfFreeBlocks = xBlocks;
c0009a30:	fdc42783          	lw	a5,-36(s0)
c0009a34:	fe842703          	lw	a4,-24(s0)
c0009a38:	00e7a623          	sw	a4,12(a5)

	taskENTER_CRITICAL();
c0009a3c:	f05fb0ef          	jal	ra,c0005940 <vTaskEnterCritical>
	{
		pxHeapStats->xAvailableHeapSpaceInBytes = xFreeBytesRemaining;
c0009a40:	0803a797          	auipc	a5,0x803a
c0009a44:	c5078793          	addi	a5,a5,-944 # c8043690 <xFreeBytesRemaining>
c0009a48:	0007a703          	lw	a4,0(a5)
c0009a4c:	fdc42783          	lw	a5,-36(s0)
c0009a50:	00e7a023          	sw	a4,0(a5)
		pxHeapStats->xNumberOfSuccessfulAllocations = xNumberOfSuccessfulAllocations;
c0009a54:	0803a797          	auipc	a5,0x803a
c0009a58:	c4478793          	addi	a5,a5,-956 # c8043698 <xNumberOfSuccessfulAllocations>
c0009a5c:	0007a703          	lw	a4,0(a5)
c0009a60:	fdc42783          	lw	a5,-36(s0)
c0009a64:	00e7aa23          	sw	a4,20(a5)
		pxHeapStats->xNumberOfSuccessfulFrees = xNumberOfSuccessfulFrees;
c0009a68:	0803a797          	auipc	a5,0x803a
c0009a6c:	c3478793          	addi	a5,a5,-972 # c804369c <xNumberOfSuccessfulFrees>
c0009a70:	0007a703          	lw	a4,0(a5)
c0009a74:	fdc42783          	lw	a5,-36(s0)
c0009a78:	00e7ac23          	sw	a4,24(a5)
		pxHeapStats->xMinimumEverFreeBytesRemaining = xMinimumEverFreeBytesRemaining;
c0009a7c:	0803a797          	auipc	a5,0x803a
c0009a80:	c1878793          	addi	a5,a5,-1000 # c8043694 <xMinimumEverFreeBytesRemaining>
c0009a84:	0007a703          	lw	a4,0(a5)
c0009a88:	fdc42783          	lw	a5,-36(s0)
c0009a8c:	00e7a823          	sw	a4,16(a5)
	}
	taskEXIT_CRITICAL();
c0009a90:	f05fb0ef          	jal	ra,c0005994 <vTaskExitCritical>
}
c0009a94:	00000013          	nop
c0009a98:	02c12083          	lw	ra,44(sp)
c0009a9c:	02812403          	lw	s0,40(sp)
c0009aa0:	03010113          	addi	sp,sp,48
c0009aa4:	00008067          	ret

c0009aa8 <get_cycle_count>:

/**
 * Capture the current 64-bit cycle count.
 */
uint64_t get_cycle_count(void)
{
c0009aa8:	fe010113          	addi	sp,sp,-32
c0009aac:	00812e23          	sw	s0,28(sp)
c0009ab0:	02010413          	addi	s0,sp,32
#if __riscv_xlen == 64
	return read_csr(mcycle);
#else
	uint32_t cycle_lo, cycle_hi;
	asm volatile(
c0009ab4:	b8002e73          	csrr	t3,mcycleh
c0009ab8:	b0002ef3          	csrr	t4,mcycle
c0009abc:	b8002373          	csrr	t1,mcycleh
c0009ac0:	fe6e1ae3          	bne	t3,t1,c0009ab4 <get_cycle_count+0xc>
c0009ac4:	ffd42623          	sw	t4,-20(s0)
c0009ac8:	ffc42423          	sw	t3,-24(s0)
		"csrr t1, mcycleh\n\t"
		"bne  %1, t1, %=b"
		: "=r"(cycle_lo), "=r"(cycle_hi)
		: // No inputs.
		: "t1");
	return (((uint64_t)cycle_hi) << 32) | (uint64_t)cycle_lo;
c0009acc:	fe842303          	lw	t1,-24(s0)
c0009ad0:	00030813          	mv	a6,t1
c0009ad4:	00000893          	li	a7,0
c0009ad8:	00081793          	slli	a5,a6,0x0
c0009adc:	00000713          	li	a4,0
c0009ae0:	fec42803          	lw	a6,-20(s0)
c0009ae4:	00080613          	mv	a2,a6
c0009ae8:	00000693          	li	a3,0
c0009aec:	00c76533          	or	a0,a4,a2
c0009af0:	00d7e5b3          	or	a1,a5,a3
c0009af4:	00050713          	mv	a4,a0
c0009af8:	00058793          	mv	a5,a1
#endif
}
c0009afc:	00070513          	mv	a0,a4
c0009b00:	00078593          	mv	a1,a5
c0009b04:	01c12403          	lw	s0,28(sp)
c0009b08:	02010113          	addi	sp,sp,32
c0009b0c:	00008067          	ret

c0009b10 <port_get_current_mtime>:
 * We convert the 64-bit read into usec. The counter overflows in roughly an hour
 * and 20 minutes. Probably not a big issue though.
 * At 50HMz clock rate, 1 us = 50 ticks
 */
uint32_t port_get_current_mtime(void)
{
c0009b10:	ff010113          	addi	sp,sp,-16
c0009b14:	00112623          	sw	ra,12(sp)
c0009b18:	00812423          	sw	s0,8(sp)
c0009b1c:	01010413          	addi	s0,sp,16
	return (uint32_t)(get_cycle_count() / (configCPU_CLOCK_HZ / 1000000));
c0009b20:	f89ff0ef          	jal	ra,c0009aa8 <get_cycle_count>
c0009b24:	00050713          	mv	a4,a0
c0009b28:	00058793          	mv	a5,a1
c0009b2c:	03200613          	li	a2,50
c0009b30:	00000693          	li	a3,0
c0009b34:	00070513          	mv	a0,a4
c0009b38:	00078593          	mv	a1,a5
c0009b3c:	33d230ef          	jal	ra,c002d678 <__udivdi3>
c0009b40:	00050713          	mv	a4,a0
c0009b44:	00058793          	mv	a5,a1
c0009b48:	00070793          	mv	a5,a4
}
c0009b4c:	00078513          	mv	a0,a5
c0009b50:	00c12083          	lw	ra,12(sp)
c0009b54:	00812403          	lw	s0,8(sp)
c0009b58:	01010113          	addi	sp,sp,16
c0009b5c:	00008067          	ret

c0009b60 <main>:

/**
 * Main application entry
 */
int main(void)
{
c0009b60:	ff010113          	addi	sp,sp,-16
c0009b64:	00112623          	sw	ra,12(sp)
c0009b68:	00812423          	sw	s0,8(sp)
c0009b6c:	01010413          	addi	s0,sp,16
	prvSetupHardware();
c0009b70:	280000ef          	jal	ra,c0009df0 <prvSetupHardware>

#if mainDEMO_TYPE == 1
	{
		main_blinky();
c0009b74:	07c000ef          	jal	ra,c0009bf0 <main_blinky>
	line will never be reached.  If the following line does execute, then
	there was insufficient FreeRTOS heap memory available for the Idle and/or
	timer tasks to be created.  See the memory management section on the
	FreeRTOS web site for more details on the FreeRTOS heap
	http://www.freertos.org/a00111.html. */
	vTaskStartScheduler();
c0009b78:	aedf90ef          	jal	ra,c0003664 <vTaskStartScheduler>
	for (;;)
c0009b7c:	0000006f          	j	c0009b7c <main+0x1c>

c0009b80 <vApplicationMallocFailedHook>:
#endif /* configGENERATE_RUN_TIME_STATS */

/*-----------------------------------------------------------*/

void vApplicationMallocFailedHook(void)
{
c0009b80:	ff010113          	addi	sp,sp,-16
c0009b84:	00812623          	sw	s0,12(sp)
c0009b88:	01010413          	addi	s0,sp,16
	demo application.  If heap_1.c or heap_2.c are used, then the size of the
	heap available to pvPortMalloc() is defined by configTOTAL_HEAP_SIZE in
	FreeRTOSConfig.h, and the xPortGetFreeHeapSize() API function can be used
	to query the size of free heap space that remains (although it does not
	provide information on how the remaining heap might be fragmented). */
	taskDISABLE_INTERRUPTS();
c0009b8c:	30047073          	csrci	mstatus,8
	__asm volatile("ebreak");
c0009b90:	00100073          	ebreak
	for (;;)
c0009b94:	0000006f          	j	c0009b94 <vApplicationMallocFailedHook+0x14>

c0009b98 <vApplicationIdleHook>:
		;
}
/*-----------------------------------------------------------*/

void vApplicationIdleHook(void)
{
c0009b98:	ff010113          	addi	sp,sp,-16
c0009b9c:	00812623          	sw	s0,12(sp)
c0009ba0:	01010413          	addi	s0,sp,16
	specified, or call vTaskDelay()).  If the application makes use of the
	vTaskDelete() API function (as this demo application does) then it is also
	important that vApplicationIdleHook() is permitted to return to its calling
	function, because it is the responsibility of the idle task to clean up
	memory allocated by the kernel to any task that has since been deleted. */
}
c0009ba4:	00000013          	nop
c0009ba8:	00c12403          	lw	s0,12(sp)
c0009bac:	01010113          	addi	sp,sp,16
c0009bb0:	00008067          	ret

c0009bb4 <vApplicationStackOverflowHook>:
/*-----------------------------------------------------------*/

void vApplicationStackOverflowHook(TaskHandle_t pxTask, char *pcTaskName)
{
c0009bb4:	fe010113          	addi	sp,sp,-32
c0009bb8:	00812e23          	sw	s0,28(sp)
c0009bbc:	02010413          	addi	s0,sp,32
c0009bc0:	fea42623          	sw	a0,-20(s0)
c0009bc4:	feb42423          	sw	a1,-24(s0)
	(void)pxTask;

	/* Run time stack overflow checking is performed if
	configCHECK_FOR_STACK_OVERFLOW is defined to 1 or 2.  This hook
	function is called if a stack overflow is detected. */
	taskDISABLE_INTERRUPTS();
c0009bc8:	30047073          	csrci	mstatus,8
	__asm volatile("ebreak");
c0009bcc:	00100073          	ebreak
	for (;;)
c0009bd0:	0000006f          	j	c0009bd0 <vApplicationStackOverflowHook+0x1c>

c0009bd4 <vApplicationTickHook>:
		;
}
/*-----------------------------------------------------------*/

void vApplicationTickHook(void)
{
c0009bd4:	ff010113          	addi	sp,sp,-16
c0009bd8:	00812623          	sw	s0,12(sp)
c0009bdc:	01010413          	addi	s0,sp,16
	{
		extern void vFullDemoTickHook(void);
		vFullDemoTickHook();
	}
#endif
}
c0009be0:	00000013          	nop
c0009be4:	00c12403          	lw	s0,12(sp)
c0009be8:	01010113          	addi	sp,sp,16
c0009bec:	00008067          	ret

c0009bf0 <main_blinky>:
static QueueHandle_t xQueue = NULL;

/*-----------------------------------------------------------*/

void main_blinky(void)
{
c0009bf0:	ff010113          	addi	sp,sp,-16
c0009bf4:	00112623          	sw	ra,12(sp)
c0009bf8:	00812423          	sw	s0,8(sp)
c0009bfc:	01010413          	addi	s0,sp,16
	/* Create the queue. */
	xQueue = xQueueCreate(mainQUEUE_LENGTH, sizeof(uint32_t));
c0009c00:	00000613          	li	a2,0
c0009c04:	00400593          	li	a1,4
c0009c08:	00100513          	li	a0,1
c0009c0c:	e65f60ef          	jal	ra,c0000a70 <xQueueGenericCreate>
c0009c10:	00050713          	mv	a4,a0
c0009c14:	0803a797          	auipc	a5,0x803a
c0009c18:	a9078793          	addi	a5,a5,-1392 # c80436a4 <xQueue>
c0009c1c:	00e7a023          	sw	a4,0(a5)
	configASSERT(xQueue != NULL);
c0009c20:	0803a797          	auipc	a5,0x803a
c0009c24:	a8478793          	addi	a5,a5,-1404 # c80436a4 <xQueue>
c0009c28:	0007a783          	lw	a5,0(a5)
c0009c2c:	00079863          	bnez	a5,c0009c3c <main_blinky+0x4c>
c0009c30:	30047073          	csrci	mstatus,8
c0009c34:	00100073          	ebreak
c0009c38:	0000006f          	j	c0009c38 <main_blinky+0x48>

	/* Start the two tasks as described in the comments at the top of this
		file. */
	xTaskCreate(prvQueueReceiveTask,			 /* The function that implements the task. */
c0009c3c:	00000793          	li	a5,0
c0009c40:	00200713          	li	a4,2
c0009c44:	00000693          	li	a3,0
c0009c48:	40000613          	li	a2,1024
c0009c4c:	07ff6597          	auipc	a1,0x7ff6
c0009c50:	44058593          	addi	a1,a1,1088 # c800008c <__rodata_start+0x8c>
c0009c54:	00000517          	auipc	a0,0x0
c0009c58:	10050513          	addi	a0,a0,256 # c0009d54 <prvQueueReceiveTask>
c0009c5c:	9cdf80ef          	jal	ra,c0002628 <xTaskCreate>
				configMINIMAL_STACK_SIZE * 2U,   /* The size of the stack to allocate to the task. */
				NULL,							 /* The parameter passed to the task - not used in this case. */
				mainQUEUE_RECEIVE_TASK_PRIORITY, /* The priority assigned to the task. */
				NULL);							 /* The task handle is not required, so NULL is passed. */

	xTaskCreate(prvQueueSendTask, "TX", configMINIMAL_STACK_SIZE * 2U, NULL, mainQUEUE_SEND_TASK_PRIORITY, NULL);
c0009c60:	00000793          	li	a5,0
c0009c64:	00100713          	li	a4,1
c0009c68:	00000693          	li	a3,0
c0009c6c:	40000613          	li	a2,1024
c0009c70:	07ff6597          	auipc	a1,0x7ff6
c0009c74:	42058593          	addi	a1,a1,1056 # c8000090 <__rodata_start+0x90>
c0009c78:	00000517          	auipc	a0,0x0
c0009c7c:	02050513          	addi	a0,a0,32 # c0009c98 <prvQueueSendTask>
c0009c80:	9a9f80ef          	jal	ra,c0002628 <xTaskCreate>
}
c0009c84:	00000013          	nop
c0009c88:	00c12083          	lw	ra,12(sp)
c0009c8c:	00812403          	lw	s0,8(sp)
c0009c90:	01010113          	addi	sp,sp,16
c0009c94:	00008067          	ret

c0009c98 <prvQueueSendTask>:
/*-----------------------------------------------------------*/

static void prvQueueSendTask(void *pvParameters)
{
c0009c98:	fd010113          	addi	sp,sp,-48
c0009c9c:	02112623          	sw	ra,44(sp)
c0009ca0:	02812423          	sw	s0,40(sp)
c0009ca4:	03010413          	addi	s0,sp,48
c0009ca8:	fca42e23          	sw	a0,-36(s0)
	TickType_t xNextWakeTime;
	const unsigned int ulValueToSend = 100UL;
c0009cac:	06400793          	li	a5,100
c0009cb0:	fef42023          	sw	a5,-32(s0)
	BaseType_t xReturned;

	unsigned int cnt = 0;
c0009cb4:	fe042623          	sw	zero,-20(s0)

	/* Remove compiler warning about unused parameter. */
	(void)pvParameters;

	/* Initialise xNextWakeTime - this only needs to be done once. */
	xNextWakeTime = xTaskGetTickCount();
c0009cb8:	d75f90ef          	jal	ra,c0003a2c <xTaskGetTickCount>
c0009cbc:	00050793          	mv	a5,a0
c0009cc0:	fef42223          	sw	a5,-28(s0)

	for (;;)
	{
		printf("[%u]: Hello from TX\r\n", cnt);
c0009cc4:	fec42583          	lw	a1,-20(s0)
c0009cc8:	07ff6517          	auipc	a0,0x7ff6
c0009ccc:	3cc50513          	addi	a0,a0,972 # c8000094 <__rodata_start+0x94>
c0009cd0:	0d4140ef          	jal	ra,c001dda4 <printf>
		cnt++;
c0009cd4:	fec42783          	lw	a5,-20(s0)
c0009cd8:	00178793          	addi	a5,a5,1
c0009cdc:	fef42623          	sw	a5,-20(s0)

		/* Place this task in the blocked state until it is time to run again. */
		vTaskDelayUntil(&xNextWakeTime, mainQUEUE_SEND_FREQUENCY_MS);
c0009ce0:	fe440793          	addi	a5,s0,-28
c0009ce4:	00100593          	li	a1,1
c0009ce8:	00078513          	mv	a0,a5
c0009cec:	f51f80ef          	jal	ra,c0002c3c <vTaskDelayUntil>

		printf("[%u] TX: awoken\r\n", cnt);
c0009cf0:	fec42583          	lw	a1,-20(s0)
c0009cf4:	07ff6517          	auipc	a0,0x7ff6
c0009cf8:	3b850513          	addi	a0,a0,952 # c80000ac <__rodata_start+0xac>
c0009cfc:	0a8140ef          	jal	ra,c001dda4 <printf>

		/* Send to the queue - causing the queue receive task to unblock and
		toggle the LED.  0 is used as the block time so the sending operation
		will not block - it shouldn't need to block as the queue should always
		be empty at this point in the code. */
		xReturned = xQueueSend(xQueue, &ulValueToSend, 0U);
c0009d00:	0803a797          	auipc	a5,0x803a
c0009d04:	9a478793          	addi	a5,a5,-1628 # c80436a4 <xQueue>
c0009d08:	0007a783          	lw	a5,0(a5)
c0009d0c:	fe040713          	addi	a4,s0,-32
c0009d10:	00000693          	li	a3,0
c0009d14:	00000613          	li	a2,0
c0009d18:	00070593          	mv	a1,a4
c0009d1c:	00078513          	mv	a0,a5
c0009d20:	9d4f70ef          	jal	ra,c0000ef4 <xQueueGenericSend>
c0009d24:	fea42423          	sw	a0,-24(s0)
		configASSERT(xReturned == pdPASS);
c0009d28:	fe842703          	lw	a4,-24(s0)
c0009d2c:	00100793          	li	a5,1
c0009d30:	00f70863          	beq	a4,a5,c0009d40 <prvQueueSendTask+0xa8>
c0009d34:	30047073          	csrci	mstatus,8
c0009d38:	00100073          	ebreak
c0009d3c:	0000006f          	j	c0009d3c <prvQueueSendTask+0xa4>
		printf("[%u] TX: sent\r\n", cnt);
c0009d40:	fec42583          	lw	a1,-20(s0)
c0009d44:	07ff6517          	auipc	a0,0x7ff6
c0009d48:	37c50513          	addi	a0,a0,892 # c80000c0 <__rodata_start+0xc0>
c0009d4c:	058140ef          	jal	ra,c001dda4 <printf>
		printf("[%u]: Hello from TX\r\n", cnt);
c0009d50:	f75ff06f          	j	c0009cc4 <prvQueueSendTask+0x2c>

c0009d54 <prvQueueReceiveTask>:
	}
}
/*-----------------------------------------------------------*/

static void prvQueueReceiveTask(void *pvParameters)
{
c0009d54:	fd010113          	addi	sp,sp,-48
c0009d58:	02112623          	sw	ra,44(sp)
c0009d5c:	02812423          	sw	s0,40(sp)
c0009d60:	03010413          	addi	s0,sp,48
c0009d64:	fca42e23          	sw	a0,-36(s0)
	unsigned int ulReceivedValue;
	const unsigned int ulExpectedValue = 100UL;
c0009d68:	06400793          	li	a5,100
c0009d6c:	fef42423          	sw	a5,-24(s0)

	unsigned int cnt = 0;
c0009d70:	fe042623          	sw	zero,-20(s0)
	/* Remove compiler warning about unused parameter. */
	(void)pvParameters;

	for (;;)
	{
		printf("[%u]: Hello from RX\r\n", cnt);
c0009d74:	fec42583          	lw	a1,-20(s0)
c0009d78:	07ff6517          	auipc	a0,0x7ff6
c0009d7c:	35850513          	addi	a0,a0,856 # c80000d0 <__rodata_start+0xd0>
c0009d80:	024140ef          	jal	ra,c001dda4 <printf>
		cnt++;
c0009d84:	fec42783          	lw	a5,-20(s0)
c0009d88:	00178793          	addi	a5,a5,1
c0009d8c:	fef42623          	sw	a5,-20(s0)

		/* Wait until something arrives in the queue - this task will block
		indefinitely provided INCLUDE_vTaskSuspend is set to 1 in
		FreeRTOSConfig.h. */
		xQueueReceive(xQueue, &ulReceivedValue, portMAX_DELAY);
c0009d90:	0803a797          	auipc	a5,0x803a
c0009d94:	91478793          	addi	a5,a5,-1772 # c80436a4 <xQueue>
c0009d98:	0007a783          	lw	a5,0(a5)
c0009d9c:	fe440713          	addi	a4,s0,-28
c0009da0:	fff00613          	li	a2,-1
c0009da4:	00070593          	mv	a1,a4
c0009da8:	00078513          	mv	a0,a5
c0009dac:	e68f70ef          	jal	ra,c0001414 <xQueueReceive>

		printf("[%u] RX: received value\r\n", cnt);
c0009db0:	fec42583          	lw	a1,-20(s0)
c0009db4:	07ff6517          	auipc	a0,0x7ff6
c0009db8:	33450513          	addi	a0,a0,820 # c80000e8 <__rodata_start+0xe8>
c0009dbc:	7e9130ef          	jal	ra,c001dda4 <printf>

		/*  To get here something must have been received from the queue, but
		is it the expected value?  If it is, toggle the LED. */
		if (ulReceivedValue == ulExpectedValue)
c0009dc0:	fe442783          	lw	a5,-28(s0)
c0009dc4:	fe842703          	lw	a4,-24(s0)
c0009dc8:	00f71c63          	bne	a4,a5,c0009de0 <prvQueueReceiveTask+0x8c>
		{
			printf("Blink !!!\r\n");
c0009dcc:	07ff6517          	auipc	a0,0x7ff6
c0009dd0:	33850513          	addi	a0,a0,824 # c8000104 <__rodata_start+0x104>
c0009dd4:	0ec140ef          	jal	ra,c001dec0 <puts>
			ulReceivedValue = 0U;
c0009dd8:	fe042223          	sw	zero,-28(s0)
c0009ddc:	f99ff06f          	j	c0009d74 <prvQueueReceiveTask+0x20>
		}
		else
		{
			printf("Unexpected value received\r\n");
c0009de0:	07ff6517          	auipc	a0,0x7ff6
c0009de4:	33050513          	addi	a0,a0,816 # c8000110 <__rodata_start+0x110>
c0009de8:	0d8140ef          	jal	ra,c001dec0 <puts>
		printf("[%u]: Hello from RX\r\n", cnt);
c0009dec:	f89ff06f          	j	c0009d74 <prvQueueReceiveTask+0x20>

c0009df0 <prvSetupHardware>:

/**
 *  Prepare haredware to run the demo.
 */
void prvSetupHardware(void)
{
c0009df0:	ff010113          	addi	sp,sp,-16
c0009df4:	00112623          	sw	ra,12(sp)
c0009df8:	00812423          	sw	s0,8(sp)
c0009dfc:	01010413          	addi	s0,sp,16
    // Resets PLIC, threshold 0, nothing enabled
    PLIC_init(&Plic, PLIC_BASE_ADDR, PLIC_NUM_SOURCES, PLIC_NUM_PRIORITIES);
c0009e00:	01000693          	li	a3,16
c0009e04:	01000613          	li	a2,16
c0009e08:	0c0005b7          	lui	a1,0xc000
c0009e0c:	0803a517          	auipc	a0,0x803a
c0009e10:	89c50513          	addi	a0,a0,-1892 # c80436a8 <Plic>
c0009e14:	150000ef          	jal	ra,c0009f64 <PLIC_init>

// Set priorities & initialize peripherals
#if BSP_USE_UART0
    PLIC_set_priority(&Plic, PLIC_SOURCE_UART0, PLIC_PRIORITY_UART0);
c0009e18:	00100613          	li	a2,1
c0009e1c:	00100593          	li	a1,1
c0009e20:	0803a517          	auipc	a0,0x803a
c0009e24:	88850513          	addi	a0,a0,-1912 # c80436a8 <Plic>
c0009e28:	370000ef          	jal	ra,c000a198 <PLIC_set_priority>
    uart0_init();
c0009e2c:	7b8000ef          	jal	ra,c000a5e4 <uart0_init>
#endif

#if BSP_USE_GPIO
    gpio_init();
#endif
}
c0009e30:	00000013          	nop
c0009e34:	00c12083          	lw	ra,12(sp)
c0009e38:	00812403          	lw	s0,8(sp)
c0009e3c:	01010113          	addi	sp,sp,16
c0009e40:	00008067          	ret

c0009e44 <external_interrupt_handler>:
/**
 * Define an external interrupt handler
 * cause = 0x8000000b == Machine external interrupt
 */
void external_interrupt_handler(HANDLER_DATATYPE cause)
{
c0009e44:	fd010113          	addi	sp,sp,-48
c0009e48:	02112623          	sw	ra,44(sp)
c0009e4c:	02812423          	sw	s0,40(sp)
c0009e50:	03010413          	addi	s0,sp,48
c0009e54:	fca42e23          	sw	a0,-36(s0)
    configASSERT(cause == MCAUSE_EXTERNAL_INTERRUPT);
c0009e58:	fdc42703          	lw	a4,-36(s0)
c0009e5c:	800007b7          	lui	a5,0x80000
c0009e60:	00b78793          	addi	a5,a5,11 # 8000000b <_end+0xb7f7b78b>
c0009e64:	00f70863          	beq	a4,a5,c0009e74 <external_interrupt_handler+0x30>
c0009e68:	30047073          	csrci	mstatus,8
c0009e6c:	00100073          	ebreak
c0009e70:	0000006f          	j	c0009e70 <external_interrupt_handler+0x2c>

    plic_source source_id = PLIC_claim_interrupt(&Plic);
c0009e74:	0803a517          	auipc	a0,0x803a
c0009e78:	83450513          	addi	a0,a0,-1996 # c80436a8 <Plic>
c0009e7c:	374000ef          	jal	ra,c000a1f0 <PLIC_claim_interrupt>
c0009e80:	fea42623          	sw	a0,-20(s0)

    if ((source_id >= 1) && (source_id < PLIC_NUM_INTERRUPTS))
c0009e84:	fec42783          	lw	a5,-20(s0)
c0009e88:	04078463          	beqz	a5,c0009ed0 <external_interrupt_handler+0x8c>
c0009e8c:	fec42703          	lw	a4,-20(s0)
c0009e90:	00f00793          	li	a5,15
c0009e94:	02e7ee63          	bltu	a5,a4,c0009ed0 <external_interrupt_handler+0x8c>
    {
        Plic.HandlerTable[source_id].Handler(Plic.HandlerTable[source_id].CallBackRef);
c0009e98:	0803a717          	auipc	a4,0x803a
c0009e9c:	81070713          	addi	a4,a4,-2032 # c80436a8 <Plic>
c0009ea0:	fec42783          	lw	a5,-20(s0)
c0009ea4:	00379793          	slli	a5,a5,0x3
c0009ea8:	00f707b3          	add	a5,a4,a5
c0009eac:	00c7a683          	lw	a3,12(a5)
c0009eb0:	08039717          	auipc	a4,0x8039
c0009eb4:	7f870713          	addi	a4,a4,2040 # c80436a8 <Plic>
c0009eb8:	fec42783          	lw	a5,-20(s0)
c0009ebc:	00379793          	slli	a5,a5,0x3
c0009ec0:	00f707b3          	add	a5,a4,a5
c0009ec4:	0107a783          	lw	a5,16(a5)
c0009ec8:	00078513          	mv	a0,a5
c0009ecc:	000680e7          	jalr	a3
    }

    // clear interrupt
    PLIC_complete_interrupt(&Plic, source_id);
c0009ed0:	fec42583          	lw	a1,-20(s0)
c0009ed4:	08039517          	auipc	a0,0x8039
c0009ed8:	7d450513          	addi	a0,a0,2004 # c80436a8 <Plic>
c0009edc:	354000ef          	jal	ra,c000a230 <PLIC_complete_interrupt>
}
c0009ee0:	00000013          	nop
c0009ee4:	02c12083          	lw	ra,44(sp)
c0009ee8:	02812403          	lw	s0,40(sp)
c0009eec:	03010113          	addi	sp,sp,48
c0009ef0:	00008067          	ret

c0009ef4 <volatile_memzero32>:
// Note that there are no assertions or bounds checking on these
// parameter values.
static void volatile_memzero32(uint32_t *base, unsigned int size);

static void volatile_memzero32(uint32_t *base, unsigned int size)
{
c0009ef4:	fd010113          	addi	sp,sp,-48
c0009ef8:	02812623          	sw	s0,44(sp)
c0009efc:	03010413          	addi	s0,sp,48
c0009f00:	fca42e23          	sw	a0,-36(s0)
c0009f04:	fcb42c23          	sw	a1,-40(s0)
    volatile uint32_t *ptr;
    unsigned int words = (size + sizeof(*ptr) - 1) / sizeof(*ptr);
c0009f08:	fd842783          	lw	a5,-40(s0)
c0009f0c:	00378793          	addi	a5,a5,3
c0009f10:	0027d793          	srli	a5,a5,0x2
c0009f14:	fef42423          	sw	a5,-24(s0)
    for (ptr = base; ptr < (base + words); ptr++)
c0009f18:	fdc42783          	lw	a5,-36(s0)
c0009f1c:	fef42623          	sw	a5,-20(s0)
c0009f20:	0180006f          	j	c0009f38 <volatile_memzero32+0x44>
    {
        *ptr = 0;
c0009f24:	fec42783          	lw	a5,-20(s0)
c0009f28:	0007a023          	sw	zero,0(a5)
    for (ptr = base; ptr < (base + words); ptr++)
c0009f2c:	fec42783          	lw	a5,-20(s0)
c0009f30:	00478793          	addi	a5,a5,4
c0009f34:	fef42623          	sw	a5,-20(s0)
c0009f38:	fe842783          	lw	a5,-24(s0)
c0009f3c:	00279793          	slli	a5,a5,0x2
c0009f40:	fdc42703          	lw	a4,-36(s0)
c0009f44:	00f707b3          	add	a5,a4,a5
c0009f48:	fec42703          	lw	a4,-20(s0)
c0009f4c:	fcf76ce3          	bltu	a4,a5,c0009f24 <volatile_memzero32+0x30>
    }
}
c0009f50:	00000013          	nop
c0009f54:	00000013          	nop
c0009f58:	02c12403          	lw	s0,44(sp)
c0009f5c:	03010113          	addi	sp,sp,48
c0009f60:	00008067          	ret

c0009f64 <PLIC_init>:
void PLIC_init(
    plic_instance_t *this_plic,
    uintptr_t base_addr,
    uint32_t num_sources,
    uint32_t num_priorities)
{
c0009f64:	fd010113          	addi	sp,sp,-48
c0009f68:	02112623          	sw	ra,44(sp)
c0009f6c:	02812423          	sw	s0,40(sp)
c0009f70:	03010413          	addi	s0,sp,48
c0009f74:	fca42e23          	sw	a0,-36(s0)
c0009f78:	fcb42c23          	sw	a1,-40(s0)
c0009f7c:	fcc42a23          	sw	a2,-44(s0)
c0009f80:	fcd42823          	sw	a3,-48(s0)

    this_plic->base_addr = base_addr;
c0009f84:	fdc42783          	lw	a5,-36(s0)
c0009f88:	fd842703          	lw	a4,-40(s0)
c0009f8c:	00e7a023          	sw	a4,0(a5)
    this_plic->num_sources = num_sources;
c0009f90:	fdc42783          	lw	a5,-36(s0)
c0009f94:	fd442703          	lw	a4,-44(s0)
c0009f98:	00e7a223          	sw	a4,4(a5)
    this_plic->num_priorities = num_priorities;
c0009f9c:	fdc42783          	lw	a5,-36(s0)
c0009fa0:	fd042703          	lw	a4,-48(s0)
c0009fa4:	00e7a423          	sw	a4,8(a5)

    // Erase handler table
    for (uint8_t idx = 0; idx < PLIC_NUM_INTERRUPTS; idx++)
c0009fa8:	fe0407a3          	sb	zero,-17(s0)
c0009fac:	0240006f          	j	c0009fd0 <PLIC_init+0x6c>
    {
        this_plic->HandlerTable[idx].Handler = NULL;
c0009fb0:	fef44783          	lbu	a5,-17(s0)
c0009fb4:	fdc42703          	lw	a4,-36(s0)
c0009fb8:	00379793          	slli	a5,a5,0x3
c0009fbc:	00f707b3          	add	a5,a4,a5
c0009fc0:	0007a623          	sw	zero,12(a5)
    for (uint8_t idx = 0; idx < PLIC_NUM_INTERRUPTS; idx++)
c0009fc4:	fef44783          	lbu	a5,-17(s0)
c0009fc8:	00178793          	addi	a5,a5,1
c0009fcc:	fef407a3          	sb	a5,-17(s0)
c0009fd0:	fef44703          	lbu	a4,-17(s0)
c0009fd4:	00f00793          	li	a5,15
c0009fd8:	fce7fce3          	bgeu	a5,a4,c0009fb0 <PLIC_init+0x4c>
    }

    // Disable all interrupts (don't assume that these registers are reset).
    volatile_memzero32((uint32_t *)(this_plic->base_addr +
c0009fdc:	fdc42783          	lw	a5,-36(s0)
c0009fe0:	0007a703          	lw	a4,0(a5)
c0009fe4:	000027b7          	lui	a5,0x2
c0009fe8:	00f707b3          	add	a5,a4,a5
c0009fec:	00078713          	mv	a4,a5
                                    PLIC_ENABLE_OFFSET),
                       (num_sources + 7) / 8);
c0009ff0:	fd442783          	lw	a5,-44(s0)
c0009ff4:	00778793          	addi	a5,a5,7 # 2007 <_STACK_SIZE+0x1007>
c0009ff8:	0037d793          	srli	a5,a5,0x3
    volatile_memzero32((uint32_t *)(this_plic->base_addr +
c0009ffc:	00078593          	mv	a1,a5
c000a000:	00070513          	mv	a0,a4
c000a004:	ef1ff0ef          	jal	ra,c0009ef4 <volatile_memzero32>

    // Set all priorities to 0 (equal priority -- don't assume that these are reset).
    // The 0th entry in the memory map is reserved and so should not be written
    // to, but is also included in num_sources.
    volatile_memzero32((uint32_t *)(this_plic->base_addr +
c000a008:	fdc42783          	lw	a5,-36(s0)
c000a00c:	0007a783          	lw	a5,0(a5)
                                    PLIC_PRIORITY_OFFSET +
c000a010:	00478793          	addi	a5,a5,4
    volatile_memzero32((uint32_t *)(this_plic->base_addr +
c000a014:	00078713          	mv	a4,a5
                                    (1 << PLIC_PRIORITY_SHIFT_PER_SOURCE)),
                       (num_sources - 1) << PLIC_PRIORITY_SHIFT_PER_SOURCE);
c000a018:	fd442783          	lw	a5,-44(s0)
c000a01c:	fff78793          	addi	a5,a5,-1
c000a020:	00279793          	slli	a5,a5,0x2
    volatile_memzero32((uint32_t *)(this_plic->base_addr +
c000a024:	00078593          	mv	a1,a5
c000a028:	00070513          	mv	a0,a4
c000a02c:	ec9ff0ef          	jal	ra,c0009ef4 <volatile_memzero32>

    // Set the threshold to 0.
    volatile plic_threshold *threshold = (plic_threshold *)(this_plic->base_addr +
c000a030:	fdc42783          	lw	a5,-36(s0)
c000a034:	0007a703          	lw	a4,0(a5)
c000a038:	002007b7          	lui	a5,0x200
c000a03c:	00f707b3          	add	a5,a4,a5
c000a040:	fef42423          	sw	a5,-24(s0)
                                                            PLIC_THRESHOLD_OFFSET);

    *threshold = 0;
c000a044:	fe842783          	lw	a5,-24(s0)
c000a048:	0007a023          	sw	zero,0(a5) # 200000 <_HEAP_SIZE+0x1c0000>
}
c000a04c:	00000013          	nop
c000a050:	02c12083          	lw	ra,44(sp)
c000a054:	02812403          	lw	s0,40(sp)
c000a058:	03010113          	addi	sp,sp,48
c000a05c:	00008067          	ret

c000a060 <PLIC_set_threshold>:

void PLIC_set_threshold(plic_instance_t *this_plic,
                        plic_threshold threshold)
{
c000a060:	fd010113          	addi	sp,sp,-48
c000a064:	02812623          	sw	s0,44(sp)
c000a068:	03010413          	addi	s0,sp,48
c000a06c:	fca42e23          	sw	a0,-36(s0)
c000a070:	fcb42c23          	sw	a1,-40(s0)

    volatile plic_threshold *threshold_ptr = (plic_threshold *)(this_plic->base_addr +
c000a074:	fdc42783          	lw	a5,-36(s0)
c000a078:	0007a703          	lw	a4,0(a5)
c000a07c:	002007b7          	lui	a5,0x200
c000a080:	00f707b3          	add	a5,a4,a5
c000a084:	fef42623          	sw	a5,-20(s0)
                                                                PLIC_THRESHOLD_OFFSET);

    *threshold_ptr = threshold;
c000a088:	fec42783          	lw	a5,-20(s0)
c000a08c:	fd842703          	lw	a4,-40(s0)
c000a090:	00e7a023          	sw	a4,0(a5) # 200000 <_HEAP_SIZE+0x1c0000>
}
c000a094:	00000013          	nop
c000a098:	02c12403          	lw	s0,44(sp)
c000a09c:	03010113          	addi	sp,sp,48
c000a0a0:	00008067          	ret

c000a0a4 <PLIC_enable_interrupt>:

void PLIC_enable_interrupt(plic_instance_t *this_plic, plic_source source)
{
c000a0a4:	fd010113          	addi	sp,sp,-48
c000a0a8:	02812623          	sw	s0,44(sp)
c000a0ac:	03010413          	addi	s0,sp,48
c000a0b0:	fca42e23          	sw	a0,-36(s0)
c000a0b4:	fcb42c23          	sw	a1,-40(s0)

    volatile uint32_t *current_ptr = (volatile uint32_t *)(this_plic->base_addr +
c000a0b8:	fdc42783          	lw	a5,-36(s0)
c000a0bc:	0007a703          	lw	a4,0(a5)
                                                           PLIC_ENABLE_OFFSET +
                                                           (source >> 5));
c000a0c0:	fd842783          	lw	a5,-40(s0)
c000a0c4:	0057d793          	srli	a5,a5,0x5
                                                           PLIC_ENABLE_OFFSET +
c000a0c8:	00f70733          	add	a4,a4,a5
c000a0cc:	000027b7          	lui	a5,0x2
c000a0d0:	00f707b3          	add	a5,a4,a5
    volatile uint32_t *current_ptr = (volatile uint32_t *)(this_plic->base_addr +
c000a0d4:	fef42623          	sw	a5,-20(s0)
    uint32_t current = *current_ptr;
c000a0d8:	fec42783          	lw	a5,-20(s0)
c000a0dc:	0007a783          	lw	a5,0(a5) # 2000 <_STACK_SIZE+0x1000>
c000a0e0:	fef42423          	sw	a5,-24(s0)
    current = current | ((uint32_t)1 << (source & 0x1f));
c000a0e4:	fd842783          	lw	a5,-40(s0)
c000a0e8:	01f7f793          	andi	a5,a5,31
c000a0ec:	00100713          	li	a4,1
c000a0f0:	00f717b3          	sll	a5,a4,a5
c000a0f4:	fe842703          	lw	a4,-24(s0)
c000a0f8:	00f767b3          	or	a5,a4,a5
c000a0fc:	fef42423          	sw	a5,-24(s0)
    *current_ptr = current;
c000a100:	fec42783          	lw	a5,-20(s0)
c000a104:	fe842703          	lw	a4,-24(s0)
c000a108:	00e7a023          	sw	a4,0(a5)
}
c000a10c:	00000013          	nop
c000a110:	02c12403          	lw	s0,44(sp)
c000a114:	03010113          	addi	sp,sp,48
c000a118:	00008067          	ret

c000a11c <PLIC_disable_interrupt>:

void PLIC_disable_interrupt(plic_instance_t *this_plic, plic_source source)
{
c000a11c:	fd010113          	addi	sp,sp,-48
c000a120:	02812623          	sw	s0,44(sp)
c000a124:	03010413          	addi	s0,sp,48
c000a128:	fca42e23          	sw	a0,-36(s0)
c000a12c:	fcb42c23          	sw	a1,-40(s0)

    volatile uint32_t *current_ptr = (volatile uint32_t *)(this_plic->base_addr +
c000a130:	fdc42783          	lw	a5,-36(s0)
c000a134:	0007a703          	lw	a4,0(a5)
                                                           PLIC_ENABLE_OFFSET +
                                                           (source >> 5));
c000a138:	fd842783          	lw	a5,-40(s0)
c000a13c:	0057d793          	srli	a5,a5,0x5
                                                           PLIC_ENABLE_OFFSET +
c000a140:	00f70733          	add	a4,a4,a5
c000a144:	000027b7          	lui	a5,0x2
c000a148:	00f707b3          	add	a5,a4,a5
    volatile uint32_t *current_ptr = (volatile uint32_t *)(this_plic->base_addr +
c000a14c:	fef42623          	sw	a5,-20(s0)
    uint32_t current = *current_ptr;
c000a150:	fec42783          	lw	a5,-20(s0)
c000a154:	0007a783          	lw	a5,0(a5) # 2000 <_STACK_SIZE+0x1000>
c000a158:	fef42423          	sw	a5,-24(s0)
    current = current & ~(((uint32_t)1 << (source & 0x1f)));
c000a15c:	fd842783          	lw	a5,-40(s0)
c000a160:	01f7f793          	andi	a5,a5,31
c000a164:	00100713          	li	a4,1
c000a168:	00f717b3          	sll	a5,a4,a5
c000a16c:	fff7c793          	not	a5,a5
c000a170:	fe842703          	lw	a4,-24(s0)
c000a174:	00f777b3          	and	a5,a4,a5
c000a178:	fef42423          	sw	a5,-24(s0)
    *current_ptr = current;
c000a17c:	fec42783          	lw	a5,-20(s0)
c000a180:	fe842703          	lw	a4,-24(s0)
c000a184:	00e7a023          	sw	a4,0(a5)
}
c000a188:	00000013          	nop
c000a18c:	02c12403          	lw	s0,44(sp)
c000a190:	03010113          	addi	sp,sp,48
c000a194:	00008067          	ret

c000a198 <PLIC_set_priority>:

void PLIC_set_priority(plic_instance_t *this_plic, plic_source source, plic_priority priority)
{
c000a198:	fd010113          	addi	sp,sp,-48
c000a19c:	02812623          	sw	s0,44(sp)
c000a1a0:	03010413          	addi	s0,sp,48
c000a1a4:	fca42e23          	sw	a0,-36(s0)
c000a1a8:	fcb42c23          	sw	a1,-40(s0)
c000a1ac:	fcc42a23          	sw	a2,-44(s0)

    if (this_plic->num_priorities > 0)
c000a1b0:	fdc42783          	lw	a5,-36(s0)
c000a1b4:	0087a783          	lw	a5,8(a5)
c000a1b8:	02078463          	beqz	a5,c000a1e0 <PLIC_set_priority+0x48>
    {
        volatile plic_priority *priority_ptr = (volatile plic_priority *)(this_plic->base_addr +
c000a1bc:	fdc42783          	lw	a5,-36(s0)
c000a1c0:	0007a703          	lw	a4,0(a5)
                                                                          PLIC_PRIORITY_OFFSET +
                                                                          (source << PLIC_PRIORITY_SHIFT_PER_SOURCE));
c000a1c4:	fd842783          	lw	a5,-40(s0)
c000a1c8:	00279793          	slli	a5,a5,0x2
                                                                          PLIC_PRIORITY_OFFSET +
c000a1cc:	00f707b3          	add	a5,a4,a5
        volatile plic_priority *priority_ptr = (volatile plic_priority *)(this_plic->base_addr +
c000a1d0:	fef42623          	sw	a5,-20(s0)
        *priority_ptr = priority;
c000a1d4:	fec42783          	lw	a5,-20(s0)
c000a1d8:	fd442703          	lw	a4,-44(s0)
c000a1dc:	00e7a023          	sw	a4,0(a5)
    }
}
c000a1e0:	00000013          	nop
c000a1e4:	02c12403          	lw	s0,44(sp)
c000a1e8:	03010113          	addi	sp,sp,48
c000a1ec:	00008067          	ret

c000a1f0 <PLIC_claim_interrupt>:

plic_source PLIC_claim_interrupt(plic_instance_t *this_plic)
{
c000a1f0:	fd010113          	addi	sp,sp,-48
c000a1f4:	02812623          	sw	s0,44(sp)
c000a1f8:	03010413          	addi	s0,sp,48
c000a1fc:	fca42e23          	sw	a0,-36(s0)

    volatile plic_source *claim_addr = (volatile plic_source *)(this_plic->base_addr +
c000a200:	fdc42783          	lw	a5,-36(s0)
c000a204:	0007a703          	lw	a4,0(a5)
c000a208:	002007b7          	lui	a5,0x200
c000a20c:	00478793          	addi	a5,a5,4 # 200004 <_HEAP_SIZE+0x1c0004>
c000a210:	00f707b3          	add	a5,a4,a5
c000a214:	fef42623          	sw	a5,-20(s0)
                                                                PLIC_CLAIM_OFFSET);

    return *claim_addr;
c000a218:	fec42783          	lw	a5,-20(s0)
c000a21c:	0007a783          	lw	a5,0(a5)
}
c000a220:	00078513          	mv	a0,a5
c000a224:	02c12403          	lw	s0,44(sp)
c000a228:	03010113          	addi	sp,sp,48
c000a22c:	00008067          	ret

c000a230 <PLIC_complete_interrupt>:

void PLIC_complete_interrupt(plic_instance_t *this_plic, plic_source source)
{
c000a230:	fd010113          	addi	sp,sp,-48
c000a234:	02812623          	sw	s0,44(sp)
c000a238:	03010413          	addi	s0,sp,48
c000a23c:	fca42e23          	sw	a0,-36(s0)
c000a240:	fcb42c23          	sw	a1,-40(s0)

    volatile plic_source *claim_addr = (volatile plic_source *)(this_plic->base_addr +
c000a244:	fdc42783          	lw	a5,-36(s0)
c000a248:	0007a703          	lw	a4,0(a5)
c000a24c:	002007b7          	lui	a5,0x200
c000a250:	00478793          	addi	a5,a5,4 # 200004 <_HEAP_SIZE+0x1c0004>
c000a254:	00f707b3          	add	a5,a4,a5
c000a258:	fef42623          	sw	a5,-20(s0)
                                                                PLIC_CLAIM_OFFSET);
    *claim_addr = source;
c000a25c:	fec42783          	lw	a5,-20(s0)
c000a260:	fd842703          	lw	a4,-40(s0)
c000a264:	00e7a023          	sw	a4,0(a5)
}
c000a268:	00000013          	nop
c000a26c:	02c12403          	lw	s0,44(sp)
c000a270:	03010113          	addi	sp,sp,48
c000a274:	00008067          	ret

c000a278 <PLIC_register_interrupt_handler>:

plic_source PLIC_register_interrupt_handler(plic_instance_t *this_plic, plic_source source_id,
                                            plic_interrupt_handler_t handler,
                                            void *CallBackRef)
{
c000a278:	fe010113          	addi	sp,sp,-32
c000a27c:	00112e23          	sw	ra,28(sp)
c000a280:	00812c23          	sw	s0,24(sp)
c000a284:	02010413          	addi	s0,sp,32
c000a288:	fea42623          	sw	a0,-20(s0)
c000a28c:	feb42423          	sw	a1,-24(s0)
c000a290:	fec42223          	sw	a2,-28(s0)
c000a294:	fed42023          	sw	a3,-32(s0)
    if ((source_id >= 1) && (source_id < PLIC_NUM_INTERRUPTS))
c000a298:	fe842783          	lw	a5,-24(s0)
c000a29c:	06078663          	beqz	a5,c000a308 <PLIC_register_interrupt_handler+0x90>
c000a2a0:	fe842703          	lw	a4,-24(s0)
c000a2a4:	00f00793          	li	a5,15
c000a2a8:	06e7e063          	bltu	a5,a4,c000a308 <PLIC_register_interrupt_handler+0x90>
    {
        // check if we have a handle registered
        if (this_plic->HandlerTable[source_id].Handler == NULL)
c000a2ac:	fec42703          	lw	a4,-20(s0)
c000a2b0:	fe842783          	lw	a5,-24(s0)
c000a2b4:	00379793          	slli	a5,a5,0x3
c000a2b8:	00f707b3          	add	a5,a4,a5
c000a2bc:	00c7a783          	lw	a5,12(a5)
c000a2c0:	04079463          	bnez	a5,c000a308 <PLIC_register_interrupt_handler+0x90>
        {
            // register new handler a callback reference
            this_plic->HandlerTable[source_id].Handler = handler;
c000a2c4:	fec42703          	lw	a4,-20(s0)
c000a2c8:	fe842783          	lw	a5,-24(s0)
c000a2cc:	00379793          	slli	a5,a5,0x3
c000a2d0:	00f707b3          	add	a5,a4,a5
c000a2d4:	fe442703          	lw	a4,-28(s0)
c000a2d8:	00e7a623          	sw	a4,12(a5)
            this_plic->HandlerTable[source_id].CallBackRef = CallBackRef;
c000a2dc:	fec42703          	lw	a4,-20(s0)
c000a2e0:	fe842783          	lw	a5,-24(s0)
c000a2e4:	00379793          	slli	a5,a5,0x3
c000a2e8:	00f707b3          	add	a5,a4,a5
c000a2ec:	fe042703          	lw	a4,-32(s0)
c000a2f0:	00e7a823          	sw	a4,16(a5)
            // enable interrupt
            PLIC_enable_interrupt(this_plic, source_id);
c000a2f4:	fe842583          	lw	a1,-24(s0)
c000a2f8:	fec42503          	lw	a0,-20(s0)
c000a2fc:	da9ff0ef          	jal	ra,c000a0a4 <PLIC_enable_interrupt>
            return source_id;
c000a300:	fe842783          	lw	a5,-24(s0)
c000a304:	0080006f          	j	c000a30c <PLIC_register_interrupt_handler+0x94>
        }
    }
    // invalid source_id or the source already has a handler
    return 0;
c000a308:	00000793          	li	a5,0
}
c000a30c:	00078513          	mv	a0,a5
c000a310:	01c12083          	lw	ra,28(sp)
c000a314:	01812403          	lw	s0,24(sp)
c000a318:	02010113          	addi	sp,sp,32
c000a31c:	00008067          	ret

c000a320 <PLIC_unregister_interrupt_handler>:

void PLIC_unregister_interrupt_handler(plic_instance_t *this_plic, plic_source source_id)
{
c000a320:	fe010113          	addi	sp,sp,-32
c000a324:	00112e23          	sw	ra,28(sp)
c000a328:	00812c23          	sw	s0,24(sp)
c000a32c:	02010413          	addi	s0,sp,32
c000a330:	fea42623          	sw	a0,-20(s0)
c000a334:	feb42423          	sw	a1,-24(s0)
    if ((source_id >= 1) && (source_id < PLIC_NUM_INTERRUPTS))
c000a338:	fe842783          	lw	a5,-24(s0)
c000a33c:	02078863          	beqz	a5,c000a36c <PLIC_unregister_interrupt_handler+0x4c>
c000a340:	fe842703          	lw	a4,-24(s0)
c000a344:	00f00793          	li	a5,15
c000a348:	02e7e263          	bltu	a5,a4,c000a36c <PLIC_unregister_interrupt_handler+0x4c>
    {
        PLIC_disable_interrupt(this_plic, source_id);
c000a34c:	fe842583          	lw	a1,-24(s0)
c000a350:	fec42503          	lw	a0,-20(s0)
c000a354:	dc9ff0ef          	jal	ra,c000a11c <PLIC_disable_interrupt>
        this_plic->HandlerTable[source_id].Handler = NULL;
c000a358:	fec42703          	lw	a4,-20(s0)
c000a35c:	fe842783          	lw	a5,-24(s0)
c000a360:	00379793          	slli	a5,a5,0x3
c000a364:	00f707b3          	add	a5,a4,a5
c000a368:	0007a623          	sw	zero,12(a5)
    }
c000a36c:	00000013          	nop
c000a370:	01c12083          	lw	ra,28(sp)
c000a374:	01812403          	lw	s0,24(sp)
c000a378:	02010113          	addi	sp,sp,32
c000a37c:	00008067          	ret

c000a380 <_exit>:
int _isatty(int fd);
int _kill(int pid, int sig);
int _getpid(int n);
void _exit(int n);

void _exit(int n) {
c000a380:	fe010113          	addi	sp,sp,-32
c000a384:	00812e23          	sw	s0,28(sp)
c000a388:	02010413          	addi	s0,sp,32
c000a38c:	fea42623          	sw	a0,-20(s0)
    (void)n;
    configASSERT(0);
c000a390:	30047073          	csrci	mstatus,8
c000a394:	00100073          	ebreak
c000a398:	0000006f          	j	c000a398 <_exit+0x18>

c000a39c <_sbrk>:
}

void *_sbrk(int nbytes)
{
c000a39c:	fe010113          	addi	sp,sp,-32
c000a3a0:	00112e23          	sw	ra,28(sp)
c000a3a4:	00812c23          	sw	s0,24(sp)
c000a3a8:	02010413          	addi	s0,sp,32
c000a3ac:	fea42623          	sw	a0,-20(s0)
    (void)nbytes;
    errno = ENOMEM;
c000a3b0:	7a4130ef          	jal	ra,c001db54 <__errno>
c000a3b4:	00050713          	mv	a4,a0
c000a3b8:	00c00793          	li	a5,12
c000a3bc:	00f72023          	sw	a5,0(a4)
    return (void *)-1;
c000a3c0:	fff00793          	li	a5,-1
}
c000a3c4:	00078513          	mv	a0,a5
c000a3c8:	01c12083          	lw	ra,28(sp)
c000a3cc:	01812403          	lw	s0,24(sp)
c000a3d0:	02010113          	addi	sp,sp,32
c000a3d4:	00008067          	ret

c000a3d8 <_write>:

int _write(int file, char *ptr, int len)
{
c000a3d8:	fe010113          	addi	sp,sp,-32
c000a3dc:	00112e23          	sw	ra,28(sp)
c000a3e0:	00812c23          	sw	s0,24(sp)
c000a3e4:	02010413          	addi	s0,sp,32
c000a3e8:	fea42623          	sw	a0,-20(s0)
c000a3ec:	feb42423          	sw	a1,-24(s0)
c000a3f0:	fec42223          	sw	a2,-28(s0)
    (void)file;
    return uart0_txbuffer(ptr, len);
c000a3f4:	fe442583          	lw	a1,-28(s0)
c000a3f8:	fe842503          	lw	a0,-24(s0)
c000a3fc:	288000ef          	jal	ra,c000a684 <uart0_txbuffer>
c000a400:	00050793          	mv	a5,a0
}
c000a404:	00078513          	mv	a0,a5
c000a408:	01c12083          	lw	ra,28(sp)
c000a40c:	01812403          	lw	s0,24(sp)
c000a410:	02010113          	addi	sp,sp,32
c000a414:	00008067          	ret

c000a418 <_close>:

int _close(int fd)
{
c000a418:	fe010113          	addi	sp,sp,-32
c000a41c:	00112e23          	sw	ra,28(sp)
c000a420:	00812c23          	sw	s0,24(sp)
c000a424:	02010413          	addi	s0,sp,32
c000a428:	fea42623          	sw	a0,-20(s0)
    (void)fd;
    errno = EBADF;
c000a42c:	728130ef          	jal	ra,c001db54 <__errno>
c000a430:	00050713          	mv	a4,a0
c000a434:	00900793          	li	a5,9
c000a438:	00f72023          	sw	a5,0(a4)
    return -1;
c000a43c:	fff00793          	li	a5,-1
}
c000a440:	00078513          	mv	a0,a5
c000a444:	01c12083          	lw	ra,28(sp)
c000a448:	01812403          	lw	s0,24(sp)
c000a44c:	02010113          	addi	sp,sp,32
c000a450:	00008067          	ret

c000a454 <_lseek>:

long _lseek(int fd, long offset, int origin)
{
c000a454:	fe010113          	addi	sp,sp,-32
c000a458:	00112e23          	sw	ra,28(sp)
c000a45c:	00812c23          	sw	s0,24(sp)
c000a460:	02010413          	addi	s0,sp,32
c000a464:	fea42623          	sw	a0,-20(s0)
c000a468:	feb42423          	sw	a1,-24(s0)
c000a46c:	fec42223          	sw	a2,-28(s0)
    (void)fd;
    (void)offset;
    (void)origin;
    errno = EBADF;
c000a470:	6e4130ef          	jal	ra,c001db54 <__errno>
c000a474:	00050713          	mv	a4,a0
c000a478:	00900793          	li	a5,9
c000a47c:	00f72023          	sw	a5,0(a4)
    return -1;
c000a480:	fff00793          	li	a5,-1
}
c000a484:	00078513          	mv	a0,a5
c000a488:	01c12083          	lw	ra,28(sp)
c000a48c:	01812403          	lw	s0,24(sp)
c000a490:	02010113          	addi	sp,sp,32
c000a494:	00008067          	ret

c000a498 <_read>:

int _read(int fd, void *buffer, unsigned int count)
{
c000a498:	fe010113          	addi	sp,sp,-32
c000a49c:	00112e23          	sw	ra,28(sp)
c000a4a0:	00812c23          	sw	s0,24(sp)
c000a4a4:	02010413          	addi	s0,sp,32
c000a4a8:	fea42623          	sw	a0,-20(s0)
c000a4ac:	feb42423          	sw	a1,-24(s0)
c000a4b0:	fec42223          	sw	a2,-28(s0)
    (void)fd;
    (void)buffer;
    (void)count;
    errno = EBADF;
c000a4b4:	6a0130ef          	jal	ra,c001db54 <__errno>
c000a4b8:	00050713          	mv	a4,a0
c000a4bc:	00900793          	li	a5,9
c000a4c0:	00f72023          	sw	a5,0(a4)
    return -1;
c000a4c4:	fff00793          	li	a5,-1
}
c000a4c8:	00078513          	mv	a0,a5
c000a4cc:	01c12083          	lw	ra,28(sp)
c000a4d0:	01812403          	lw	s0,24(sp)
c000a4d4:	02010113          	addi	sp,sp,32
c000a4d8:	00008067          	ret

c000a4dc <_fstat>:

int _fstat(int fd, void *buffer)
{
c000a4dc:	fe010113          	addi	sp,sp,-32
c000a4e0:	00112e23          	sw	ra,28(sp)
c000a4e4:	00812c23          	sw	s0,24(sp)
c000a4e8:	02010413          	addi	s0,sp,32
c000a4ec:	fea42623          	sw	a0,-20(s0)
c000a4f0:	feb42423          	sw	a1,-24(s0)
    (void)fd;
    (void)buffer;
    errno = EBADF;
c000a4f4:	660130ef          	jal	ra,c001db54 <__errno>
c000a4f8:	00050713          	mv	a4,a0
c000a4fc:	00900793          	li	a5,9
c000a500:	00f72023          	sw	a5,0(a4)
    return -1;
c000a504:	fff00793          	li	a5,-1
}
c000a508:	00078513          	mv	a0,a5
c000a50c:	01c12083          	lw	ra,28(sp)
c000a510:	01812403          	lw	s0,24(sp)
c000a514:	02010113          	addi	sp,sp,32
c000a518:	00008067          	ret

c000a51c <_isatty>:

int _isatty(int fd)
{
c000a51c:	fe010113          	addi	sp,sp,-32
c000a520:	00112e23          	sw	ra,28(sp)
c000a524:	00812c23          	sw	s0,24(sp)
c000a528:	02010413          	addi	s0,sp,32
c000a52c:	fea42623          	sw	a0,-20(s0)
    (void)fd;
    errno = EBADF;
c000a530:	624130ef          	jal	ra,c001db54 <__errno>
c000a534:	00050713          	mv	a4,a0
c000a538:	00900793          	li	a5,9
c000a53c:	00f72023          	sw	a5,0(a4)
    return 0;
c000a540:	00000793          	li	a5,0
}
c000a544:	00078513          	mv	a0,a5
c000a548:	01c12083          	lw	ra,28(sp)
c000a54c:	01812403          	lw	s0,24(sp)
c000a550:	02010113          	addi	sp,sp,32
c000a554:	00008067          	ret

c000a558 <_kill>:

int _kill(int pid, int sig)
{
c000a558:	fe010113          	addi	sp,sp,-32
c000a55c:	00112e23          	sw	ra,28(sp)
c000a560:	00812c23          	sw	s0,24(sp)
c000a564:	02010413          	addi	s0,sp,32
c000a568:	fea42623          	sw	a0,-20(s0)
c000a56c:	feb42423          	sw	a1,-24(s0)
    (void)pid;
    (void)sig;
    errno = EBADF;
c000a570:	5e4130ef          	jal	ra,c001db54 <__errno>
c000a574:	00050713          	mv	a4,a0
c000a578:	00900793          	li	a5,9
c000a57c:	00f72023          	sw	a5,0(a4)
    return -1;
c000a580:	fff00793          	li	a5,-1
}
c000a584:	00078513          	mv	a0,a5
c000a588:	01c12083          	lw	ra,28(sp)
c000a58c:	01812403          	lw	s0,24(sp)
c000a590:	02010113          	addi	sp,sp,32
c000a594:	00008067          	ret

c000a598 <_getpid>:

int _getpid(int n)
{
c000a598:	fe010113          	addi	sp,sp,-32
c000a59c:	00812e23          	sw	s0,28(sp)
c000a5a0:	02010413          	addi	s0,sp,32
c000a5a4:	fea42623          	sw	a0,-20(s0)
    (void)n;
    return 1;
c000a5a8:	00100793          	li	a5,1
}
c000a5ac:	00078513          	mv	a0,a5
c000a5b0:	01c12403          	lw	s0,28(sp)
c000a5b4:	02010113          	addi	sp,sp,32
c000a5b8:	00008067          	ret

c000a5bc <Xil_In32>:
*
* @return	The 32 bit Value read from the specified input address.
*
******************************************************************************/
static INLINE u32 Xil_In32(UINTPTR Addr)
{
c000a5bc:	fe010113          	addi	sp,sp,-32
c000a5c0:	00812e23          	sw	s0,28(sp)
c000a5c4:	02010413          	addi	s0,sp,32
c000a5c8:	fea42623          	sw	a0,-20(s0)
	return *(volatile u32 *) Addr;
c000a5cc:	fec42783          	lw	a5,-20(s0)
c000a5d0:	0007a783          	lw	a5,0(a5)
}
c000a5d4:	00078513          	mv	a0,a5
c000a5d8:	01c12403          	lw	s0,28(sp)
c000a5dc:	02010113          	addi	sp,sp,32
c000a5e0:	00008067          	ret

c000a5e4 <uart0_init>:
#if BSP_USE_UART0
/**
 * Initialize UART 0 peripheral
 */
void uart0_init(void)
{
c000a5e4:	ff010113          	addi	sp,sp,-16
c000a5e8:	00112623          	sw	ra,12(sp)
c000a5ec:	00812423          	sw	s0,8(sp)
c000a5f0:	01010413          	addi	s0,sp,16
    uart_init(&Uart0, XPAR_UARTNS550_0_DEVICE_ID, PLIC_SOURCE_UART0);
c000a5f4:	00100613          	li	a2,1
c000a5f8:	00000593          	li	a1,0
c000a5fc:	08039517          	auipc	a0,0x8039
c000a600:	13850513          	addi	a0,a0,312 # c8043734 <Uart0>
c000a604:	198000ef          	jal	ra,c000a79c <uart_init>
}
c000a608:	00000013          	nop
c000a60c:	00c12083          	lw	ra,12(sp)
c000a610:	00812403          	lw	s0,8(sp)
c000a614:	01010113          	addi	sp,sp,16
c000a618:	00008067          	ret

c000a61c <uart0_rxready>:

/**
 * Return 1 if UART0 has at leas 1 byte in the RX FIFO
 */
bool uart0_rxready(void)
{
c000a61c:	ff010113          	addi	sp,sp,-16
c000a620:	00112623          	sw	ra,12(sp)
c000a624:	00812423          	sw	s0,8(sp)
c000a628:	01010413          	addi	s0,sp,16
    return uart_rxready(&Uart0);
c000a62c:	08039517          	auipc	a0,0x8039
c000a630:	10850513          	addi	a0,a0,264 # c8043734 <Uart0>
c000a634:	11c000ef          	jal	ra,c000a750 <uart_rxready>
c000a638:	00050793          	mv	a5,a0
}
c000a63c:	00078513          	mv	a0,a5
c000a640:	00c12083          	lw	ra,12(sp)
c000a644:	00812403          	lw	s0,8(sp)
c000a648:	01010113          	addi	sp,sp,16
c000a64c:	00008067          	ret

c000a650 <uart0_rxchar>:

/**
 * Receive a single byte. Polling mode, waits until finished
 */
char uart0_rxchar(void)
{
c000a650:	ff010113          	addi	sp,sp,-16
c000a654:	00112623          	sw	ra,12(sp)
c000a658:	00812423          	sw	s0,8(sp)
c000a65c:	01010413          	addi	s0,sp,16
    return (char)uart_rxchar(&Uart0);
c000a660:	08039517          	auipc	a0,0x8039
c000a664:	0d450513          	addi	a0,a0,212 # c8043734 <Uart0>
c000a668:	254000ef          	jal	ra,c000a8bc <uart_rxchar>
c000a66c:	00050793          	mv	a5,a0
}
c000a670:	00078513          	mv	a0,a5
c000a674:	00c12083          	lw	ra,12(sp)
c000a678:	00812403          	lw	s0,8(sp)
c000a67c:	01010113          	addi	sp,sp,16
c000a680:	00008067          	ret

c000a684 <uart0_txbuffer>:
 * Transmit a buffer. Waits indefinitely for a UART TX mutex,
 * returns number of transferred bytes or -1 in case of an error.
 * Synchronous API.
 */
int uart0_txbuffer(char *ptr, int len)
{
c000a684:	fe010113          	addi	sp,sp,-32
c000a688:	00112e23          	sw	ra,28(sp)
c000a68c:	00812c23          	sw	s0,24(sp)
c000a690:	02010413          	addi	s0,sp,32
c000a694:	fea42623          	sw	a0,-20(s0)
c000a698:	feb42423          	sw	a1,-24(s0)
    return uart_txbuffer(&Uart0, (uint8_t *)ptr, len);
c000a69c:	fe842603          	lw	a2,-24(s0)
c000a6a0:	fec42583          	lw	a1,-20(s0)
c000a6a4:	08039517          	auipc	a0,0x8039
c000a6a8:	09050513          	addi	a0,a0,144 # c8043734 <Uart0>
c000a6ac:	298000ef          	jal	ra,c000a944 <uart_txbuffer>
c000a6b0:	00050793          	mv	a5,a0
}
c000a6b4:	00078513          	mv	a0,a5
c000a6b8:	01c12083          	lw	ra,28(sp)
c000a6bc:	01812403          	lw	s0,24(sp)
c000a6c0:	02010113          	addi	sp,sp,32
c000a6c4:	00008067          	ret

c000a6c8 <uart0_txchar>:

/**
 * Transmit a single byte. Polling mode, waits until finished
 */
char uart0_txchar(char c)
{
c000a6c8:	fe010113          	addi	sp,sp,-32
c000a6cc:	00112e23          	sw	ra,28(sp)
c000a6d0:	00812c23          	sw	s0,24(sp)
c000a6d4:	02010413          	addi	s0,sp,32
c000a6d8:	00050793          	mv	a5,a0
c000a6dc:	fef407a3          	sb	a5,-17(s0)
    return (char)uart_txchar(&Uart0, (uint8_t)c);
c000a6e0:	fef44783          	lbu	a5,-17(s0)
c000a6e4:	00078593          	mv	a1,a5
c000a6e8:	08039517          	auipc	a0,0x8039
c000a6ec:	04c50513          	addi	a0,a0,76 # c8043734 <Uart0>
c000a6f0:	208000ef          	jal	ra,c000a8f8 <uart_txchar>
c000a6f4:	00050793          	mv	a5,a0
}
c000a6f8:	00078513          	mv	a0,a5
c000a6fc:	01c12083          	lw	ra,28(sp)
c000a700:	01812403          	lw	s0,24(sp)
c000a704:	02010113          	addi	sp,sp,32
c000a708:	00008067          	ret

c000a70c <uart0_rxbuffer>:

int uart0_rxbuffer(char *ptr, int len)
{
c000a70c:	fe010113          	addi	sp,sp,-32
c000a710:	00112e23          	sw	ra,28(sp)
c000a714:	00812c23          	sw	s0,24(sp)
c000a718:	02010413          	addi	s0,sp,32
c000a71c:	fea42623          	sw	a0,-20(s0)
c000a720:	feb42423          	sw	a1,-24(s0)
    return uart_rxbuffer(&Uart0, (uint8_t *)ptr, len);
c000a724:	fe842603          	lw	a2,-24(s0)
c000a728:	fec42583          	lw	a1,-20(s0)
c000a72c:	08039517          	auipc	a0,0x8039
c000a730:	00850513          	addi	a0,a0,8 # c8043734 <Uart0>
c000a734:	338000ef          	jal	ra,c000aa6c <uart_rxbuffer>
c000a738:	00050793          	mv	a5,a0
}
c000a73c:	00078513          	mv	a0,a5
c000a740:	01c12083          	lw	ra,28(sp)
c000a744:	01812403          	lw	s0,24(sp)
c000a748:	02010113          	addi	sp,sp,32
c000a74c:	00008067          	ret

c000a750 <uart_rxready>:

/*****************************************************************************/
/* Driver specific defintions */

static bool uart_rxready(struct UartDriver *Uart)
{
c000a750:	fe010113          	addi	sp,sp,-32
c000a754:	00112e23          	sw	ra,28(sp)
c000a758:	00812c23          	sw	s0,24(sp)
c000a75c:	02010413          	addi	s0,sp,32
c000a760:	fea42623          	sw	a0,-20(s0)
    return (bool)XUartNs550_IsReceiveData(Uart->Device.BaseAddress);
c000a764:	fec42783          	lw	a5,-20(s0)
c000a768:	0147a783          	lw	a5,20(a5)
c000a76c:	01478793          	addi	a5,a5,20
c000a770:	00078513          	mv	a0,a5
c000a774:	e49ff0ef          	jal	ra,c000a5bc <Xil_In32>
c000a778:	00050793          	mv	a5,a0
c000a77c:	0017f793          	andi	a5,a5,1
c000a780:	00f037b3          	snez	a5,a5
c000a784:	0ff7f793          	andi	a5,a5,255
}
c000a788:	00078513          	mv	a0,a5
c000a78c:	01c12083          	lw	ra,28(sp)
c000a790:	01812403          	lw	s0,24(sp)
c000a794:	02010113          	addi	sp,sp,32
c000a798:	00008067          	ret

c000a79c <uart_init>:

/**
 * Initialize UART peripheral
 */
static void uart_init(struct UartDriver *Uart, uint8_t device_id, uint8_t plic_source_id)
{
c000a79c:	fd010113          	addi	sp,sp,-48
c000a7a0:	02112623          	sw	ra,44(sp)
c000a7a4:	02812423          	sw	s0,40(sp)
c000a7a8:	03010413          	addi	s0,sp,48
c000a7ac:	fca42e23          	sw	a0,-36(s0)
c000a7b0:	00058793          	mv	a5,a1
c000a7b4:	00060713          	mv	a4,a2
c000a7b8:	fcf40da3          	sb	a5,-37(s0)
c000a7bc:	00070793          	mv	a5,a4
c000a7c0:	fcf40d23          	sb	a5,-38(s0)
    // Initialize struct
    Uart->tx_mutex = xSemaphoreCreateMutex();
c000a7c4:	00100513          	li	a0,1
c000a7c8:	c3cf60ef          	jal	ra,c0000c04 <xQueueCreateMutex>
c000a7cc:	00050713          	mv	a4,a0
c000a7d0:	fdc42783          	lw	a5,-36(s0)
c000a7d4:	06e7a023          	sw	a4,96(a5)
    Uart->rx_mutex = xSemaphoreCreateMutex();
c000a7d8:	00100513          	li	a0,1
c000a7dc:	c28f60ef          	jal	ra,c0000c04 <xQueueCreateMutex>
c000a7e0:	00050713          	mv	a4,a0
c000a7e4:	fdc42783          	lw	a5,-36(s0)
c000a7e8:	06e7a223          	sw	a4,100(a5)
    switch (device_id)
c000a7ec:	fdb44783          	lbu	a5,-37(s0)
c000a7f0:	06079263          	bnez	a5,c000a854 <uart_init+0xb8>
    {
#if BSP_USE_UART0
    case 0:
        Uart->Device = UartNs550_0;
c000a7f4:	fdc42703          	lw	a4,-36(s0)
c000a7f8:	08039797          	auipc	a5,0x8039
c000a7fc:	fac78793          	addi	a5,a5,-84 # c80437a4 <UartNs550_0>
c000a800:	00078693          	mv	a3,a5
c000a804:	04800793          	li	a5,72
c000a808:	00078613          	mv	a2,a5
c000a80c:	00068593          	mv	a1,a3
c000a810:	00070513          	mv	a0,a4
c000a814:	34c130ef          	jal	ra,c001db60 <memcpy>
        break;
c000a818:	00000013          	nop
        // Trigger a fault: unsupported device ID
        configASSERT(0);
        break;
    };

    Uart->tx_task = NULL;
c000a81c:	fdc42783          	lw	a5,-36(s0)
c000a820:	0607a423          	sw	zero,104(a5)
    Uart->rx_task = NULL;
c000a824:	fdc42783          	lw	a5,-36(s0)
c000a828:	0607a623          	sw	zero,108(a5)

    /* Initialize the UartNs550 driver so that it's ready to use */
    configASSERT(XUartNs550_Initialize(&Uart->Device, device_id) == XST_SUCCESS);
c000a82c:	fdc42783          	lw	a5,-36(s0)
c000a830:	fdb44703          	lbu	a4,-37(s0)
c000a834:	01071713          	slli	a4,a4,0x10
c000a838:	01075713          	srli	a4,a4,0x10
c000a83c:	00070593          	mv	a1,a4
c000a840:	00078513          	mv	a0,a5
c000a844:	6b4010ef          	jal	ra,c000bef8 <XUartNs550_Initialize>
c000a848:	00050793          	mv	a5,a0
c000a84c:	02078063          	beqz	a5,c000a86c <uart_init+0xd0>
c000a850:	0100006f          	j	c000a860 <uart_init+0xc4>
        configASSERT(0);
c000a854:	30047073          	csrci	mstatus,8
c000a858:	00100073          	ebreak
c000a85c:	0000006f          	j	c000a85c <uart_init+0xc0>
    configASSERT(XUartNs550_Initialize(&Uart->Device, device_id) == XST_SUCCESS);
c000a860:	30047073          	csrci	mstatus,8
c000a864:	00100073          	ebreak
c000a868:	0000006f          	j	c000a868 <uart_init+0xcc>

    /* Perform a self-test to ensure that the hardware was built correctly */
    configASSERT(XUartNs550_SelfTest(&Uart->Device) == XST_SUCCESS);
c000a86c:	fdc42783          	lw	a5,-36(s0)
c000a870:	00078513          	mv	a0,a5
c000a874:	790010ef          	jal	ra,c000c004 <XUartNs550_SelfTest>
c000a878:	00050793          	mv	a5,a0
c000a87c:	00078863          	beqz	a5,c000a88c <uart_init+0xf0>
c000a880:	30047073          	csrci	mstatus,8
c000a884:	00100073          	ebreak
c000a888:	0000006f          	j	c000a888 <uart_init+0xec>

#if XPAR_UART_USE_POLLING_MODE
    (void)plic_source_id;
    uint16_t Options = XUN_OPTION_FIFOS_ENABLE | XUN_FIFO_TX_RESET | XUN_FIFO_RX_RESET;
c000a88c:	04600793          	li	a5,70
c000a890:	fef41723          	sh	a5,-18(s0)

    /* Enable interrupts, and enable FIFOs */
    uint16_t Options = XUN_OPTION_DATA_INTR |
                       XUN_OPTION_FIFOS_ENABLE | XUN_FIFO_TX_RESET | XUN_FIFO_RX_RESET;
#endif /* XPAR_UART_USE_POLLING_MODE */
    XUartNs550_SetOptions(&Uart->Device, Options);
c000a894:	fdc42783          	lw	a5,-36(s0)
c000a898:	fee45703          	lhu	a4,-18(s0)
c000a89c:	00070593          	mv	a1,a4
c000a8a0:	00078513          	mv	a0,a5
c000a8a4:	62d010ef          	jal	ra,c000c6d0 <XUartNs550_SetOptions>
}
c000a8a8:	00000013          	nop
c000a8ac:	02c12083          	lw	ra,44(sp)
c000a8b0:	02812403          	lw	s0,40(sp)
c000a8b4:	03010113          	addi	sp,sp,48
c000a8b8:	00008067          	ret

c000a8bc <uart_rxchar>:
/**
 * Receive a single byte from UART peripheral. Polling mode,
 * waits until finished.
 */
static uint8_t uart_rxchar(struct UartDriver *Uart)
{
c000a8bc:	fe010113          	addi	sp,sp,-32
c000a8c0:	00112e23          	sw	ra,28(sp)
c000a8c4:	00812c23          	sw	s0,24(sp)
c000a8c8:	02010413          	addi	s0,sp,32
c000a8cc:	fea42623          	sw	a0,-20(s0)
#if XPAR_UART_USE_POLLING_MODE
    return XUartNs550_RecvByte(Uart->Device.BaseAddress);
c000a8d0:	fec42783          	lw	a5,-20(s0)
c000a8d4:	0147a783          	lw	a5,20(a5)
c000a8d8:	00078513          	mv	a0,a5
c000a8dc:	525020ef          	jal	ra,c000d600 <XUartNs550_RecvByte>
c000a8e0:	00050793          	mv	a5,a0
#else
    uint8_t buf = 0;
    uart_rxbuffer(Uart, &buf, 1);
    return buf;
#endif
}
c000a8e4:	00078513          	mv	a0,a5
c000a8e8:	01c12083          	lw	ra,28(sp)
c000a8ec:	01812403          	lw	s0,24(sp)
c000a8f0:	02010113          	addi	sp,sp,32
c000a8f4:	00008067          	ret

c000a8f8 <uart_txchar>:
/**
 * Transmit a single byte from UART peripheral. Polling mode,
 * waits until finished.
 */
static uint8_t uart_txchar(struct UartDriver *Uart, uint8_t c)
{
c000a8f8:	fe010113          	addi	sp,sp,-32
c000a8fc:	00112e23          	sw	ra,28(sp)
c000a900:	00812c23          	sw	s0,24(sp)
c000a904:	02010413          	addi	s0,sp,32
c000a908:	fea42623          	sw	a0,-20(s0)
c000a90c:	00058793          	mv	a5,a1
c000a910:	fef405a3          	sb	a5,-21(s0)
#if XPAR_UART_USE_POLLING_MODE
    XUartNs550_SendByte(Uart->Device.BaseAddress, c);
c000a914:	fec42783          	lw	a5,-20(s0)
c000a918:	0147a783          	lw	a5,20(a5)
c000a91c:	feb44703          	lbu	a4,-21(s0)
c000a920:	00070593          	mv	a1,a4
c000a924:	00078513          	mv	a0,a5
c000a928:	479020ef          	jal	ra,c000d5a0 <XUartNs550_SendByte>
    return c;
c000a92c:	feb44783          	lbu	a5,-21(s0)
#else
    return uart_txchar(Uart, c);
#endif
}
c000a930:	00078513          	mv	a0,a5
c000a934:	01c12083          	lw	ra,28(sp)
c000a938:	01812403          	lw	s0,24(sp)
c000a93c:	02010113          	addi	sp,sp,32
c000a940:	00008067          	ret

c000a944 <uart_txbuffer>:
/**
 * Transmit a buffer. Synchronous API.
 * Returns number of transmitted bytes or -1 in case of a timeout.
 */
static int uart_txbuffer(struct UartDriver *Uart, uint8_t *ptr, int len)
{
c000a944:	fd010113          	addi	sp,sp,-48
c000a948:	02112623          	sw	ra,44(sp)
c000a94c:	02812423          	sw	s0,40(sp)
c000a950:	03010413          	addi	s0,sp,48
c000a954:	fca42e23          	sw	a0,-36(s0)
c000a958:	fcb42c23          	sw	a1,-40(s0)
c000a95c:	fcc42a23          	sw	a2,-44(s0)
    static int returnval;
    configASSERT(Uart->tx_mutex != NULL);
c000a960:	fdc42783          	lw	a5,-36(s0)
c000a964:	0607a783          	lw	a5,96(a5)
c000a968:	00079863          	bnez	a5,c000a978 <uart_txbuffer+0x34>
c000a96c:	30047073          	csrci	mstatus,8
c000a970:	00100073          	ebreak
c000a974:	0000006f          	j	c000a974 <uart_txbuffer+0x30>
    /* First acquire mutex */
    configASSERT(xSemaphoreTake(Uart->tx_mutex, portMAX_DELAY) == pdTRUE);
c000a978:	fdc42783          	lw	a5,-36(s0)
c000a97c:	0607a783          	lw	a5,96(a5)
c000a980:	fff00593          	li	a1,-1
c000a984:	00078513          	mv	a0,a5
c000a988:	cb5f60ef          	jal	ra,c000163c <xQueueSemaphoreTake>
c000a98c:	00050713          	mv	a4,a0
c000a990:	00100793          	li	a5,1
c000a994:	00f70863          	beq	a4,a5,c000a9a4 <uart_txbuffer+0x60>
c000a998:	30047073          	csrci	mstatus,8
c000a99c:	00100073          	ebreak
c000a9a0:	0000006f          	j	c000a9a0 <uart_txbuffer+0x5c>

#if XPAR_UART_USE_POLLING_MODE
    int idx = 0;
c000a9a4:	fe042623          	sw	zero,-20(s0)
    int remaining = len;
c000a9a8:	fd442783          	lw	a5,-44(s0)
c000a9ac:	fef42423          	sw	a5,-24(s0)
    int sent = 0;
c000a9b0:	fe042223          	sw	zero,-28(s0)
    while (remaining > 0) {
c000a9b4:	0640006f          	j	c000aa18 <uart_txbuffer+0xd4>
        sent = XUartNs550_Send(&Uart->Device, &ptr[idx], remaining);
c000a9b8:	fdc42683          	lw	a3,-36(s0)
c000a9bc:	fec42783          	lw	a5,-20(s0)
c000a9c0:	fd842703          	lw	a4,-40(s0)
c000a9c4:	00f707b3          	add	a5,a4,a5
c000a9c8:	fe842703          	lw	a4,-24(s0)
c000a9cc:	00070613          	mv	a2,a4
c000a9d0:	00078593          	mv	a1,a5
c000a9d4:	00068513          	mv	a0,a3
c000a9d8:	259000ef          	jal	ra,c000b430 <XUartNs550_Send>
c000a9dc:	00050793          	mv	a5,a0
c000a9e0:	fef42223          	sw	a5,-28(s0)
        configASSERT(sent >= 0);
c000a9e4:	fe442783          	lw	a5,-28(s0)
c000a9e8:	0007d863          	bgez	a5,c000a9f8 <uart_txbuffer+0xb4>
c000a9ec:	30047073          	csrci	mstatus,8
c000a9f0:	00100073          	ebreak
c000a9f4:	0000006f          	j	c000a9f4 <uart_txbuffer+0xb0>
        remaining -= sent;
c000a9f8:	fe842703          	lw	a4,-24(s0)
c000a9fc:	fe442783          	lw	a5,-28(s0)
c000aa00:	40f707b3          	sub	a5,a4,a5
c000aa04:	fef42423          	sw	a5,-24(s0)
        idx += sent;
c000aa08:	fec42703          	lw	a4,-20(s0)
c000aa0c:	fe442783          	lw	a5,-28(s0)
c000aa10:	00f707b3          	add	a5,a4,a5
c000aa14:	fef42623          	sw	a5,-20(s0)
    while (remaining > 0) {
c000aa18:	fe842783          	lw	a5,-24(s0)
c000aa1c:	f8f04ee3          	bgtz	a5,c000a9b8 <uart_txbuffer+0x74>
    }
    returnval = idx;
c000aa20:	08039797          	auipc	a5,0x8039
c000aa24:	dcc78793          	addi	a5,a5,-564 # c80437ec <returnval.1>
c000aa28:	fec42703          	lw	a4,-20(s0)
c000aa2c:	00e7a023          	sw	a4,0(a5)
        /* timeout occured */
        returnval = -1;
    }
#endif /* XPAR_UART_USE_POLLING_MODE */
    /* Release mutex and return */
    xSemaphoreGive(Uart->tx_mutex);
c000aa30:	fdc42783          	lw	a5,-36(s0)
c000aa34:	0607a783          	lw	a5,96(a5)
c000aa38:	00000693          	li	a3,0
c000aa3c:	00000613          	li	a2,0
c000aa40:	00000593          	li	a1,0
c000aa44:	00078513          	mv	a0,a5
c000aa48:	cacf60ef          	jal	ra,c0000ef4 <xQueueGenericSend>
    return returnval;
c000aa4c:	08039797          	auipc	a5,0x8039
c000aa50:	da078793          	addi	a5,a5,-608 # c80437ec <returnval.1>
c000aa54:	0007a783          	lw	a5,0(a5)
}
c000aa58:	00078513          	mv	a0,a5
c000aa5c:	02c12083          	lw	ra,44(sp)
c000aa60:	02812403          	lw	s0,40(sp)
c000aa64:	03010113          	addi	sp,sp,48
c000aa68:	00008067          	ret

c000aa6c <uart_rxbuffer>:
 * Receive a buffer of data. Asynchronous API - can return 0 if no data are
 * available, and less than `len` data. The UART device can hold max 16 bytes
 * in the internal FIFO, hence returnval will never be more than 16
 */
static int uart_rxbuffer(struct UartDriver *Uart, uint8_t *ptr, int len)
{
c000aa6c:	fe010113          	addi	sp,sp,-32
c000aa70:	00112e23          	sw	ra,28(sp)
c000aa74:	00812c23          	sw	s0,24(sp)
c000aa78:	02010413          	addi	s0,sp,32
c000aa7c:	fea42623          	sw	a0,-20(s0)
c000aa80:	feb42423          	sw	a1,-24(s0)
c000aa84:	fec42223          	sw	a2,-28(s0)
    static int returnval;
    /* First acquire mutex */
    configASSERT(Uart->rx_mutex != NULL);
c000aa88:	fec42783          	lw	a5,-20(s0)
c000aa8c:	0647a783          	lw	a5,100(a5)
c000aa90:	00079863          	bnez	a5,c000aaa0 <uart_rxbuffer+0x34>
c000aa94:	30047073          	csrci	mstatus,8
c000aa98:	00100073          	ebreak
c000aa9c:	0000006f          	j	c000aa9c <uart_rxbuffer+0x30>
    configASSERT(xSemaphoreTake(Uart->rx_mutex, portMAX_DELAY) == pdTRUE);
c000aaa0:	fec42783          	lw	a5,-20(s0)
c000aaa4:	0647a783          	lw	a5,100(a5)
c000aaa8:	fff00593          	li	a1,-1
c000aaac:	00078513          	mv	a0,a5
c000aab0:	b8df60ef          	jal	ra,c000163c <xQueueSemaphoreTake>
c000aab4:	00050713          	mv	a4,a0
c000aab8:	00100793          	li	a5,1
c000aabc:	00f70863          	beq	a4,a5,c000aacc <uart_rxbuffer+0x60>
c000aac0:	30047073          	csrci	mstatus,8
c000aac4:	00100073          	ebreak
c000aac8:	0000006f          	j	c000aac8 <uart_rxbuffer+0x5c>

#if XPAR_UART_USE_POLLING_MODE
    returnval = XUartNs550_Recv(&Uart->Device, ptr, len);;
c000aacc:	fec42783          	lw	a5,-20(s0)
c000aad0:	fe442703          	lw	a4,-28(s0)
c000aad4:	00070613          	mv	a2,a4
c000aad8:	fe842583          	lw	a1,-24(s0)
c000aadc:	00078513          	mv	a0,a5
c000aae0:	2f5000ef          	jal	ra,c000b5d4 <XUartNs550_Recv>
c000aae4:	00050793          	mv	a5,a0
c000aae8:	00078713          	mv	a4,a5
c000aaec:	08039797          	auipc	a5,0x8039
c000aaf0:	d0478793          	addi	a5,a5,-764 # c80437f0 <returnval.0>
c000aaf4:	00e7a023          	sw	a4,0(a5)
        /* timeout occured */
        returnval = -1;
    }
#endif /* XPAR_UART_USE_POLLING_MODE */
    /* Release mutex and return */
    xSemaphoreGive(Uart->rx_mutex);
c000aaf8:	fec42783          	lw	a5,-20(s0)
c000aafc:	0647a783          	lw	a5,100(a5)
c000ab00:	00000693          	li	a3,0
c000ab04:	00000613          	li	a2,0
c000ab08:	00000593          	li	a1,0
c000ab0c:	00078513          	mv	a0,a5
c000ab10:	be4f60ef          	jal	ra,c0000ef4 <xQueueGenericSend>
    return returnval;
c000ab14:	08039797          	auipc	a5,0x8039
c000ab18:	cdc78793          	addi	a5,a5,-804 # c80437f0 <returnval.0>
c000ab1c:	0007a783          	lw	a5,0(a5)
}
c000ab20:	00078513          	mv	a0,a5
c000ab24:	01c12083          	lw	ra,28(sp)
c000ab28:	01812403          	lw	s0,24(sp)
c000ab2c:	02010113          	addi	sp,sp,32
c000ab30:	00008067          	ret

c000ab34 <iic_init>:

/**
 * Initialize IIC peripheral. 
 */
__attribute__((unused)) static void iic_init(struct IicDriver *Iic, uint8_t device_id, uint8_t plic_source_id)
{
c000ab34:	fe010113          	addi	sp,sp,-32
c000ab38:	00112e23          	sw	ra,28(sp)
c000ab3c:	00812c23          	sw	s0,24(sp)
c000ab40:	02010413          	addi	s0,sp,32
c000ab44:	fea42623          	sw	a0,-20(s0)
c000ab48:	00058793          	mv	a5,a1
c000ab4c:	00060713          	mv	a4,a2
c000ab50:	fef405a3          	sb	a5,-21(s0)
c000ab54:	00070793          	mv	a5,a4
c000ab58:	fef40523          	sb	a5,-22(s0)
    // Initialize struct
    Iic->mutex = xSemaphoreCreateMutex();
c000ab5c:	00100513          	li	a0,1
c000ab60:	8a4f60ef          	jal	ra,c0000c04 <xQueueCreateMutex>
c000ab64:	00050713          	mv	a4,a0
c000ab68:	fec42783          	lw	a5,-20(s0)
c000ab6c:	06e7a623          	sw	a4,108(a5)
        Iic->Device = XIic1;
        break;
#endif
    default:
        // Trigger a fault: unsupported device ID
        configASSERT(0);
c000ab70:	30047073          	csrci	mstatus,8
c000ab74:	00100073          	ebreak
c000ab78:	0000006f          	j	c000ab78 <iic_init+0x44>

c000ab7c <iic_transmit>:
 * @param addr is the address of the slave device
 * @param tx_data is the data buffer
 * @param tx_len is the length of tx_data (and the number of bytes to be sent)
 */
int iic_transmit(struct IicDriver *Iic, uint8_t addr, uint8_t *tx_data, uint8_t tx_len)
{
c000ab7c:	fd010113          	addi	sp,sp,-48
c000ab80:	02112623          	sw	ra,44(sp)
c000ab84:	02812423          	sw	s0,40(sp)
c000ab88:	03010413          	addi	s0,sp,48
c000ab8c:	fca42e23          	sw	a0,-36(s0)
c000ab90:	00058793          	mv	a5,a1
c000ab94:	fcc42a23          	sw	a2,-44(s0)
c000ab98:	00068713          	mv	a4,a3
c000ab9c:	fcf40da3          	sb	a5,-37(s0)
c000aba0:	00070793          	mv	a5,a4
c000aba4:	fcf40d23          	sb	a5,-38(s0)
    int returnval;
    configASSERT(Iic->mutex != NULL);
c000aba8:	fdc42783          	lw	a5,-36(s0)
c000abac:	06c7a783          	lw	a5,108(a5)
c000abb0:	00079863          	bnez	a5,c000abc0 <iic_transmit+0x44>
c000abb4:	30047073          	csrci	mstatus,8
c000abb8:	00100073          	ebreak
c000abbc:	0000006f          	j	c000abbc <iic_transmit+0x40>
    configASSERT(xSemaphoreTake(Iic->mutex, portMAX_DELAY) == pdTRUE);
c000abc0:	fdc42783          	lw	a5,-36(s0)
c000abc4:	06c7a783          	lw	a5,108(a5)
c000abc8:	fff00593          	li	a1,-1
c000abcc:	00078513          	mv	a0,a5
c000abd0:	a6df60ef          	jal	ra,c000163c <xQueueSemaphoreTake>
c000abd4:	00050713          	mv	a4,a0
c000abd8:	00100793          	li	a5,1
c000abdc:	00f70863          	beq	a4,a5,c000abec <iic_transmit+0x70>
c000abe0:	30047073          	csrci	mstatus,8
c000abe4:	00100073          	ebreak
c000abe8:	0000006f          	j	c000abe8 <iic_transmit+0x6c>
    configASSERT(XIic_SetAddress(&Iic->Device, XII_ADDR_TO_SEND_TYPE, addr) == XST_SUCCESS);
c000abec:	fdc42783          	lw	a5,-36(s0)
c000abf0:	fdb44703          	lbu	a4,-37(s0)
c000abf4:	00070613          	mv	a2,a4
c000abf8:	00100593          	li	a1,1
c000abfc:	00078513          	mv	a0,a5
c000ac00:	7b50b0ef          	jal	ra,c0016bb4 <XIic_SetAddress>
c000ac04:	00050793          	mv	a5,a0
c000ac08:	00078863          	beqz	a5,c000ac18 <iic_transmit+0x9c>
c000ac0c:	30047073          	csrci	mstatus,8
c000ac10:	00100073          	ebreak
c000ac14:	0000006f          	j	c000ac14 <iic_transmit+0x98>

    Iic->task_handle = xTaskGetCurrentTaskHandle();
c000ac18:	f4cfa0ef          	jal	ra,c0005364 <xTaskGetCurrentTaskHandle>
c000ac1c:	00050713          	mv	a4,a0
c000ac20:	fdc42783          	lw	a5,-36(s0)
c000ac24:	06e7a823          	sw	a4,112(a5)
    Iic->trans_len = tx_len;
c000ac28:	fda44703          	lbu	a4,-38(s0)
c000ac2c:	fdc42783          	lw	a5,-36(s0)
c000ac30:	06e7a423          	sw	a4,104(a5)

    // TODO: handle XST_IIC_BUS_BUSY (it should never happen, we have only one master)
    configASSERT(XIic_MasterSend(&Iic->Device, tx_data, (int)tx_len) == XST_SUCCESS);
c000ac34:	fdc42783          	lw	a5,-36(s0)
c000ac38:	fda44703          	lbu	a4,-38(s0)
c000ac3c:	00070613          	mv	a2,a4
c000ac40:	fd442583          	lw	a1,-44(s0)
c000ac44:	00078513          	mv	a0,a5
c000ac48:	2b10d0ef          	jal	ra,c00186f8 <XIic_MasterSend>
c000ac4c:	00050793          	mv	a5,a0
c000ac50:	00078863          	beqz	a5,c000ac60 <iic_transmit+0xe4>
c000ac54:	30047073          	csrci	mstatus,8
c000ac58:	00100073          	ebreak
c000ac5c:	0000006f          	j	c000ac5c <iic_transmit+0xe0>

    /* wait for notification */
    if (xTaskNotifyWait(0, 0, NULL, pdMS_TO_TICKS(IIC_TRANSACTION_DELAY_MS)))
c000ac60:	1f400693          	li	a3,500
c000ac64:	00000613          	li	a2,0
c000ac68:	00000593          	li	a1,0
c000ac6c:	00000513          	li	a0,0
c000ac70:	9c0fb0ef          	jal	ra,c0005e30 <xTaskNotifyWait>
c000ac74:	00050793          	mv	a5,a0
c000ac78:	06078063          	beqz	a5,c000acd8 <iic_transmit+0x15c>
    {
        /* Check Error value */
        if (Iic->Errors != 0)
c000ac7c:	fdc42783          	lw	a5,-36(s0)
c000ac80:	0647a783          	lw	a5,100(a5)
c000ac84:	04078263          	beqz	a5,c000acc8 <iic_transmit+0x14c>
        {
            // an error occured
            configASSERT(Iic->Errors == XII_SLAVE_NO_ACK_EVENT); // TODO: remove?
c000ac88:	fdc42783          	lw	a5,-36(s0)
c000ac8c:	0647a703          	lw	a4,100(a5)
c000ac90:	00400793          	li	a5,4
c000ac94:	00f70863          	beq	a4,a5,c000aca4 <iic_transmit+0x128>
c000ac98:	30047073          	csrci	mstatus,8
c000ac9c:	00100073          	ebreak
c000aca0:	0000006f          	j	c000aca0 <iic_transmit+0x124>
            printf("Error occured: %i\n", Iic->Errors);
c000aca4:	fdc42783          	lw	a5,-36(s0)
c000aca8:	0647a783          	lw	a5,100(a5)
c000acac:	00078593          	mv	a1,a5
c000acb0:	07ff5517          	auipc	a0,0x7ff5
c000acb4:	47c50513          	addi	a0,a0,1148 # c800012c <__rodata_start+0x12c>
c000acb8:	0ec130ef          	jal	ra,c001dda4 <printf>
            returnval = -1;
c000acbc:	fff00793          	li	a5,-1
c000acc0:	fef42623          	sw	a5,-20(s0)
c000acc4:	01c0006f          	j	c000ace0 <iic_transmit+0x164>
        }
        else
        {
            /* Transaction succesfull, return number of transmitted bytes */
            returnval = Iic->trans_len;
c000acc8:	fdc42783          	lw	a5,-36(s0)
c000accc:	0687a783          	lw	a5,104(a5)
c000acd0:	fef42623          	sw	a5,-20(s0)
c000acd4:	00c0006f          	j	c000ace0 <iic_transmit+0x164>
        }
    }
    else
    {
        /* timeout occured */
        returnval = -1;
c000acd8:	fff00793          	li	a5,-1
c000acdc:	fef42623          	sw	a5,-20(s0)
    }

    /* Release mutex and return */
    xSemaphoreGive(Iic->mutex);
c000ace0:	fdc42783          	lw	a5,-36(s0)
c000ace4:	06c7a783          	lw	a5,108(a5)
c000ace8:	00000693          	li	a3,0
c000acec:	00000613          	li	a2,0
c000acf0:	00000593          	li	a1,0
c000acf4:	00078513          	mv	a0,a5
c000acf8:	9fcf60ef          	jal	ra,c0000ef4 <xQueueGenericSend>
    return returnval;
c000acfc:	fec42783          	lw	a5,-20(s0)
}
c000ad00:	00078513          	mv	a0,a5
c000ad04:	02c12083          	lw	ra,44(sp)
c000ad08:	02812403          	lw	s0,40(sp)
c000ad0c:	03010113          	addi	sp,sp,48
c000ad10:	00008067          	ret

c000ad14 <iic_receive>:
 * @param addr is the address of the slave device
 * @param tx_data is the data buffer
 * @param tx_len is the length of rx_data (and the number of bytes to be received)
 */
int iic_receive(struct IicDriver *Iic, uint8_t addr, uint8_t *rx_data, uint8_t rx_len)
{
c000ad14:	fd010113          	addi	sp,sp,-48
c000ad18:	02112623          	sw	ra,44(sp)
c000ad1c:	02812423          	sw	s0,40(sp)
c000ad20:	03010413          	addi	s0,sp,48
c000ad24:	fca42e23          	sw	a0,-36(s0)
c000ad28:	00058793          	mv	a5,a1
c000ad2c:	fcc42a23          	sw	a2,-44(s0)
c000ad30:	00068713          	mv	a4,a3
c000ad34:	fcf40da3          	sb	a5,-37(s0)
c000ad38:	00070793          	mv	a5,a4
c000ad3c:	fcf40d23          	sb	a5,-38(s0)
    int returnval;
    configASSERT(Iic->mutex != NULL);
c000ad40:	fdc42783          	lw	a5,-36(s0)
c000ad44:	06c7a783          	lw	a5,108(a5)
c000ad48:	00079863          	bnez	a5,c000ad58 <iic_receive+0x44>
c000ad4c:	30047073          	csrci	mstatus,8
c000ad50:	00100073          	ebreak
c000ad54:	0000006f          	j	c000ad54 <iic_receive+0x40>
    configASSERT(xSemaphoreTake(Iic->mutex, portMAX_DELAY) == pdTRUE);
c000ad58:	fdc42783          	lw	a5,-36(s0)
c000ad5c:	06c7a783          	lw	a5,108(a5)
c000ad60:	fff00593          	li	a1,-1
c000ad64:	00078513          	mv	a0,a5
c000ad68:	8d5f60ef          	jal	ra,c000163c <xQueueSemaphoreTake>
c000ad6c:	00050713          	mv	a4,a0
c000ad70:	00100793          	li	a5,1
c000ad74:	00f70863          	beq	a4,a5,c000ad84 <iic_receive+0x70>
c000ad78:	30047073          	csrci	mstatus,8
c000ad7c:	00100073          	ebreak
c000ad80:	0000006f          	j	c000ad80 <iic_receive+0x6c>
    configASSERT(XIic_SetAddress(&Iic->Device, XII_ADDR_TO_SEND_TYPE, addr) == XST_SUCCESS);
c000ad84:	fdc42783          	lw	a5,-36(s0)
c000ad88:	fdb44703          	lbu	a4,-37(s0)
c000ad8c:	00070613          	mv	a2,a4
c000ad90:	00100593          	li	a1,1
c000ad94:	00078513          	mv	a0,a5
c000ad98:	61d0b0ef          	jal	ra,c0016bb4 <XIic_SetAddress>
c000ad9c:	00050793          	mv	a5,a0
c000ada0:	00078863          	beqz	a5,c000adb0 <iic_receive+0x9c>
c000ada4:	30047073          	csrci	mstatus,8
c000ada8:	00100073          	ebreak
c000adac:	0000006f          	j	c000adac <iic_receive+0x98>

    Iic->task_handle = xTaskGetCurrentTaskHandle();
c000adb0:	db4fa0ef          	jal	ra,c0005364 <xTaskGetCurrentTaskHandle>
c000adb4:	00050713          	mv	a4,a0
c000adb8:	fdc42783          	lw	a5,-36(s0)
c000adbc:	06e7a823          	sw	a4,112(a5)
    Iic->trans_len = rx_len;
c000adc0:	fda44703          	lbu	a4,-38(s0)
c000adc4:	fdc42783          	lw	a5,-36(s0)
c000adc8:	06e7a423          	sw	a4,104(a5)

    // TODO: handle XST_IIC_BUS_BUSY (it should never happen, we have only one master)
    configASSERT(XIic_MasterRecv(&Iic->Device, rx_data, (int)rx_len) == XST_SUCCESS);
c000adcc:	fdc42783          	lw	a5,-36(s0)
c000add0:	fda44703          	lbu	a4,-38(s0)
c000add4:	00070613          	mv	a2,a4
c000add8:	fd442583          	lw	a1,-44(s0)
c000addc:	00078513          	mv	a0,a5
c000ade0:	4910d0ef          	jal	ra,c0018a70 <XIic_MasterRecv>
c000ade4:	00050793          	mv	a5,a0
c000ade8:	00078863          	beqz	a5,c000adf8 <iic_receive+0xe4>
c000adec:	30047073          	csrci	mstatus,8
c000adf0:	00100073          	ebreak
c000adf4:	0000006f          	j	c000adf4 <iic_receive+0xe0>

    /* wait for notification */
    if (xTaskNotifyWait(0, 0, NULL, pdMS_TO_TICKS(IIC_TRANSACTION_DELAY_MS)))
c000adf8:	1f400693          	li	a3,500
c000adfc:	00000613          	li	a2,0
c000ae00:	00000593          	li	a1,0
c000ae04:	00000513          	li	a0,0
c000ae08:	828fb0ef          	jal	ra,c0005e30 <xTaskNotifyWait>
c000ae0c:	00050793          	mv	a5,a0
c000ae10:	06078063          	beqz	a5,c000ae70 <iic_receive+0x15c>
    {
        /* Check Error value */
        if (Iic->Errors != 0)
c000ae14:	fdc42783          	lw	a5,-36(s0)
c000ae18:	0647a783          	lw	a5,100(a5)
c000ae1c:	04078263          	beqz	a5,c000ae60 <iic_receive+0x14c>
        {
            // an error occured
            configASSERT(Iic->Errors == XII_SLAVE_NO_ACK_EVENT); // TODO: remove?
c000ae20:	fdc42783          	lw	a5,-36(s0)
c000ae24:	0647a703          	lw	a4,100(a5)
c000ae28:	00400793          	li	a5,4
c000ae2c:	00f70863          	beq	a4,a5,c000ae3c <iic_receive+0x128>
c000ae30:	30047073          	csrci	mstatus,8
c000ae34:	00100073          	ebreak
c000ae38:	0000006f          	j	c000ae38 <iic_receive+0x124>
            printf("Error occured: %i\n", Iic->Errors);
c000ae3c:	fdc42783          	lw	a5,-36(s0)
c000ae40:	0647a783          	lw	a5,100(a5)
c000ae44:	00078593          	mv	a1,a5
c000ae48:	07ff5517          	auipc	a0,0x7ff5
c000ae4c:	2e450513          	addi	a0,a0,740 # c800012c <__rodata_start+0x12c>
c000ae50:	755120ef          	jal	ra,c001dda4 <printf>
            returnval = -1;
c000ae54:	fff00793          	li	a5,-1
c000ae58:	fef42623          	sw	a5,-20(s0)
c000ae5c:	01c0006f          	j	c000ae78 <iic_receive+0x164>
        }
        else
        {
            /* Transaction succesfull, return number of transmitted bytes */
            returnval = Iic->trans_len;
c000ae60:	fdc42783          	lw	a5,-36(s0)
c000ae64:	0687a783          	lw	a5,104(a5)
c000ae68:	fef42623          	sw	a5,-20(s0)
c000ae6c:	00c0006f          	j	c000ae78 <iic_receive+0x164>
        }
    }
    else
    {
        /* timeout occured */
        returnval = -1;
c000ae70:	fff00793          	li	a5,-1
c000ae74:	fef42623          	sw	a5,-20(s0)
    }

    /* Release mutex and return */
    xSemaphoreGive(Iic->mutex);
c000ae78:	fdc42783          	lw	a5,-36(s0)
c000ae7c:	06c7a783          	lw	a5,108(a5)
c000ae80:	00000693          	li	a3,0
c000ae84:	00000613          	li	a2,0
c000ae88:	00000593          	li	a1,0
c000ae8c:	00078513          	mv	a0,a5
c000ae90:	864f60ef          	jal	ra,c0000ef4 <xQueueGenericSend>
    return returnval;
c000ae94:	fec42783          	lw	a5,-20(s0)
}
c000ae98:	00078513          	mv	a0,a5
c000ae9c:	02c12083          	lw	ra,44(sp)
c000aea0:	02812403          	lw	s0,40(sp)
c000aea4:	03010113          	addi	sp,sp,48
c000aea8:	00008067          	ret

c000aeac <RecvHandler>:
*
* @notes	None.
*
****************************************************************************/
static void RecvHandler(void *CallbackRef, int ByteCount)
{
c000aeac:	fd010113          	addi	sp,sp,-48
c000aeb0:	02112623          	sw	ra,44(sp)
c000aeb4:	02812423          	sw	s0,40(sp)
c000aeb8:	03010413          	addi	s0,sp,48
c000aebc:	fca42e23          	sw	a0,-36(s0)
c000aec0:	fcb42c23          	sw	a1,-40(s0)
    struct IicDriver *Iic = (struct IicDriver *)CallbackRef;
c000aec4:	fdc42783          	lw	a5,-36(s0)
c000aec8:	fef42623          	sw	a5,-20(s0)

    if (ByteCount != 0)
c000aecc:	fd842783          	lw	a5,-40(s0)
c000aed0:	02079c63          	bnez	a5,c000af08 <RecvHandler+0x5c>
    {
        // do nothing untill we receive all the bytes
        return;
    }

    configASSERT(Iic->task_handle != NULL);
c000aed4:	fec42783          	lw	a5,-20(s0)
c000aed8:	0707a783          	lw	a5,112(a5)
c000aedc:	00079863          	bnez	a5,c000aeec <RecvHandler+0x40>
c000aee0:	30047073          	csrci	mstatus,8
c000aee4:	00100073          	ebreak
c000aee8:	0000006f          	j	c000aee8 <RecvHandler+0x3c>
    static BaseType_t askForContextSwitch = pdFALSE;
    vTaskNotifyGiveFromISR(Iic->task_handle, &askForContextSwitch);
c000aeec:	fec42783          	lw	a5,-20(s0)
c000aef0:	0707a783          	lw	a5,112(a5)
c000aef4:	08039597          	auipc	a1,0x8039
c000aef8:	90058593          	addi	a1,a1,-1792 # c80437f4 <askForContextSwitch.2>
c000aefc:	00078513          	mv	a0,a5
c000af00:	cc8fb0ef          	jal	ra,c00063c8 <vTaskNotifyGiveFromISR>
c000af04:	0080006f          	j	c000af0c <RecvHandler+0x60>
        return;
c000af08:	00000013          	nop
}
c000af0c:	02c12083          	lw	ra,44(sp)
c000af10:	02812403          	lw	s0,40(sp)
c000af14:	03010113          	addi	sp,sp,48
c000af18:	00008067          	ret

c000af1c <SendHandler>:
*
* @note		None.
*
****************************************************************************/
static void SendHandler(void *CallbackRef, int Status)
{
c000af1c:	fd010113          	addi	sp,sp,-48
c000af20:	02112623          	sw	ra,44(sp)
c000af24:	02812423          	sw	s0,40(sp)
c000af28:	03010413          	addi	s0,sp,48
c000af2c:	fca42e23          	sw	a0,-36(s0)
c000af30:	fcb42c23          	sw	a1,-40(s0)
    struct IicDriver *Iic = (struct IicDriver *)CallbackRef;
c000af34:	fdc42783          	lw	a5,-36(s0)
c000af38:	fef42623          	sw	a5,-20(s0)
    // TODO: not much to do here?
    configASSERT(Status == 0);
c000af3c:	fd842783          	lw	a5,-40(s0)
c000af40:	00078863          	beqz	a5,c000af50 <SendHandler+0x34>
c000af44:	30047073          	csrci	mstatus,8
c000af48:	00100073          	ebreak
c000af4c:	0000006f          	j	c000af4c <SendHandler+0x30>

    // Notify the task
    configASSERT(Iic->task_handle != NULL);
c000af50:	fec42783          	lw	a5,-20(s0)
c000af54:	0707a783          	lw	a5,112(a5)
c000af58:	00079863          	bnez	a5,c000af68 <SendHandler+0x4c>
c000af5c:	30047073          	csrci	mstatus,8
c000af60:	00100073          	ebreak
c000af64:	0000006f          	j	c000af64 <SendHandler+0x48>
    static BaseType_t askForContextSwitch = pdFALSE;
    vTaskNotifyGiveFromISR(Iic->task_handle, &askForContextSwitch);
c000af68:	fec42783          	lw	a5,-20(s0)
c000af6c:	0707a783          	lw	a5,112(a5)
c000af70:	08039597          	auipc	a1,0x8039
c000af74:	88858593          	addi	a1,a1,-1912 # c80437f8 <askForContextSwitch.1>
c000af78:	00078513          	mv	a0,a5
c000af7c:	c4cfb0ef          	jal	ra,c00063c8 <vTaskNotifyGiveFromISR>
}
c000af80:	00000013          	nop
c000af84:	02c12083          	lw	ra,44(sp)
c000af88:	02812403          	lw	s0,40(sp)
c000af8c:	03010113          	addi	sp,sp,48
c000af90:	00008067          	ret

c000af94 <StatusHandler>:
*
* @notes	None.
*
****************************************************************************/
static void StatusHandler(void *CallbackRef, int Status)
{
c000af94:	fd010113          	addi	sp,sp,-48
c000af98:	02112623          	sw	ra,44(sp)
c000af9c:	02812423          	sw	s0,40(sp)
c000afa0:	03010413          	addi	s0,sp,48
c000afa4:	fca42e23          	sw	a0,-36(s0)
c000afa8:	fcb42c23          	sw	a1,-40(s0)
    struct IicDriver *Iic = (struct IicDriver *)CallbackRef;
c000afac:	fdc42783          	lw	a5,-36(s0)
c000afb0:	fef42623          	sw	a5,-20(s0)
    Iic->TotalErrorCount++;
c000afb4:	fec42783          	lw	a5,-20(s0)
c000afb8:	0607a783          	lw	a5,96(a5)
c000afbc:	00178713          	addi	a4,a5,1
c000afc0:	fec42783          	lw	a5,-20(s0)
c000afc4:	06e7a023          	sw	a4,96(a5)
    Iic->Errors = Status;
c000afc8:	fec42783          	lw	a5,-20(s0)
c000afcc:	fd842703          	lw	a4,-40(s0)
c000afd0:	06e7a223          	sw	a4,100(a5)

    // An error occured, notify the task
    configASSERT(Iic->task_handle != NULL);
c000afd4:	fec42783          	lw	a5,-20(s0)
c000afd8:	0707a783          	lw	a5,112(a5)
c000afdc:	00079863          	bnez	a5,c000afec <StatusHandler+0x58>
c000afe0:	30047073          	csrci	mstatus,8
c000afe4:	00100073          	ebreak
c000afe8:	0000006f          	j	c000afe8 <StatusHandler+0x54>
    static BaseType_t askForContextSwitch = pdFALSE;
    vTaskNotifyGiveFromISR(Iic->task_handle, &askForContextSwitch);
c000afec:	fec42783          	lw	a5,-20(s0)
c000aff0:	0707a783          	lw	a5,112(a5)
c000aff4:	08039597          	auipc	a1,0x8039
c000aff8:	80858593          	addi	a1,a1,-2040 # c80437fc <askForContextSwitch.0>
c000affc:	00078513          	mv	a0,a5
c000b000:	bc8fb0ef          	jal	ra,c00063c8 <vTaskNotifyGiveFromISR>
}
c000b004:	00000013          	nop
c000b008:	02c12083          	lw	ra,44(sp)
c000b00c:	02812403          	lw	s0,40(sp)
c000b010:	03010113          	addi	sp,sp,48
c000b014:	00008067          	ret

c000b018 <spi_init>:
#endif /* BSP_USE_SPI1 */

/*****************************************************************************/

__attribute__((unused)) static void spi_init(struct SpiDriver *Spi, uint8_t device_id, uint8_t plic_source_id)
{
c000b018:	fe010113          	addi	sp,sp,-32
c000b01c:	00112e23          	sw	ra,28(sp)
c000b020:	00812c23          	sw	s0,24(sp)
c000b024:	02010413          	addi	s0,sp,32
c000b028:	fea42623          	sw	a0,-20(s0)
c000b02c:	00058793          	mv	a5,a1
c000b030:	00060713          	mv	a4,a2
c000b034:	fef405a3          	sb	a5,-21(s0)
c000b038:	00070793          	mv	a5,a4
c000b03c:	fef40523          	sb	a5,-22(s0)
    // Initialize struct
    Spi->mutex = xSemaphoreCreateMutex();
c000b040:	00100513          	li	a0,1
c000b044:	bc1f50ef          	jal	ra,c0000c04 <xQueueCreateMutex>
c000b048:	00050713          	mv	a4,a0
c000b04c:	fec42783          	lw	a5,-20(s0)
c000b050:	06e7a423          	sw	a4,104(a5)
        Spi->Device = XSpi1;
        break;
#endif
    default:
        // Trigger a fault: unsupported device ID
        configASSERT(0);
c000b054:	30047073          	csrci	mstatus,8
c000b058:	00100073          	ebreak
c000b05c:	0000006f          	j	c000b05c <spi_init+0x44>

c000b060 <spi_transfer>:
    (void) SpiStatusHandler;
#endif
}

__attribute__((unused)) static int spi_transfer(struct SpiDriver *Spi, uint8_t slave_id, uint8_t *tx_buf, uint8_t *rx_buf, uint8_t len)
{
c000b060:	fd010113          	addi	sp,sp,-48
c000b064:	02112623          	sw	ra,44(sp)
c000b068:	02812423          	sw	s0,40(sp)
c000b06c:	03010413          	addi	s0,sp,48
c000b070:	fca42e23          	sw	a0,-36(s0)
c000b074:	00058793          	mv	a5,a1
c000b078:	fcc42a23          	sw	a2,-44(s0)
c000b07c:	fcd42823          	sw	a3,-48(s0)
c000b080:	fcf40da3          	sb	a5,-37(s0)
c000b084:	00070793          	mv	a5,a4
c000b088:	fcf40d23          	sb	a5,-38(s0)
    int returnval;
    configASSERT(Spi->mutex != NULL);
c000b08c:	fdc42783          	lw	a5,-36(s0)
c000b090:	0687a783          	lw	a5,104(a5)
c000b094:	00079863          	bnez	a5,c000b0a4 <spi_transfer+0x44>
c000b098:	30047073          	csrci	mstatus,8
c000b09c:	00100073          	ebreak
c000b0a0:	0000006f          	j	c000b0a0 <spi_transfer+0x40>
    configASSERT(xSemaphoreTake(Spi->mutex, portMAX_DELAY) == pdTRUE);
c000b0a4:	fdc42783          	lw	a5,-36(s0)
c000b0a8:	0687a783          	lw	a5,104(a5)
c000b0ac:	fff00593          	li	a1,-1
c000b0b0:	00078513          	mv	a0,a5
c000b0b4:	d88f60ef          	jal	ra,c000163c <xQueueSemaphoreTake>
c000b0b8:	00050713          	mv	a4,a0
c000b0bc:	00100793          	li	a5,1
c000b0c0:	00f70863          	beq	a4,a5,c000b0d0 <spi_transfer+0x70>
c000b0c4:	30047073          	csrci	mstatus,8
c000b0c8:	00100073          	ebreak
c000b0cc:	0000006f          	j	c000b0cc <spi_transfer+0x6c>

    /* Select the slave*/
    configASSERT(XSpi_SetSlaveSelect(&Spi->Device, slave_id) == XST_SUCCESS);
c000b0d0:	fdc42783          	lw	a5,-36(s0)
c000b0d4:	fdb44703          	lbu	a4,-37(s0)
c000b0d8:	00070593          	mv	a1,a4
c000b0dc:	00078513          	mv	a0,a5
c000b0e0:	7fd0f0ef          	jal	ra,c001b0dc <XSpi_SetSlaveSelect>
c000b0e4:	00050793          	mv	a5,a0
c000b0e8:	00078863          	beqz	a5,c000b0f8 <spi_transfer+0x98>
c000b0ec:	30047073          	csrci	mstatus,8
c000b0f0:	00100073          	ebreak
c000b0f4:	0000006f          	j	c000b0f4 <spi_transfer+0x94>

    /* Get task handle */
    Spi->task_handle = xTaskGetCurrentTaskHandle();
c000b0f8:	a6cfa0ef          	jal	ra,c0005364 <xTaskGetCurrentTaskHandle>
c000b0fc:	00050713          	mv	a4,a0
c000b100:	fdc42783          	lw	a5,-36(s0)
c000b104:	06e7a623          	sw	a4,108(a5)
    // TODO: handle BUSY and other states
    //int val = XSpi_Transfer(&Spi->Device, tx_buf, rx_buf, len);
    //printf("spi val: %i\r\n", val);

    /* Initialize transfer */
    configASSERT(XSpi_Transfer(&Spi->Device, tx_buf, rx_buf, len) == XST_SUCCESS);
c000b108:	fdc42783          	lw	a5,-36(s0)
c000b10c:	fda44703          	lbu	a4,-38(s0)
c000b110:	00070693          	mv	a3,a4
c000b114:	fd042603          	lw	a2,-48(s0)
c000b118:	fd442583          	lw	a1,-44(s0)
c000b11c:	00078513          	mv	a0,a5
c000b120:	7f40f0ef          	jal	ra,c001a914 <XSpi_Transfer>
c000b124:	00050793          	mv	a5,a0
c000b128:	00078863          	beqz	a5,c000b138 <spi_transfer+0xd8>
c000b12c:	30047073          	csrci	mstatus,8
c000b130:	00100073          	ebreak
c000b134:	0000006f          	j	c000b134 <spi_transfer+0xd4>

    /* wait for notification */
    if (xTaskNotifyWait(0, 0, NULL, pdMS_TO_TICKS(SPI_TRANSACTION_DELAY_MS)))
c000b138:	1f400693          	li	a3,500
c000b13c:	00000613          	li	a2,0
c000b140:	00000593          	li	a1,0
c000b144:	00000513          	li	a0,0
c000b148:	ce9fa0ef          	jal	ra,c0005e30 <xTaskNotifyWait>
c000b14c:	00050793          	mv	a5,a0
c000b150:	02078663          	beqz	a5,c000b17c <spi_transfer+0x11c>
    {
        /* Check Error value */
        if (Spi->Errors != 0)
c000b154:	fdc42783          	lw	a5,-36(s0)
c000b158:	0647a783          	lw	a5,100(a5)
c000b15c:	00078863          	beqz	a5,c000b16c <spi_transfer+0x10c>
        {
            // an error occured
            returnval = -1;
c000b160:	fff00793          	li	a5,-1
c000b164:	fef42623          	sw	a5,-20(s0)
c000b168:	01c0006f          	j	c000b184 <spi_transfer+0x124>
        }
        else
        {
            /* Transaction succesfull, return number of transmitted bytes */
            returnval = Spi->TotalTransactiondCount;
c000b16c:	fdc42783          	lw	a5,-36(s0)
c000b170:	05c7a783          	lw	a5,92(a5)
c000b174:	fef42623          	sw	a5,-20(s0)
c000b178:	00c0006f          	j	c000b184 <spi_transfer+0x124>
        }
    }
    else
    {
        /* timeout occured */
        returnval = -1;
c000b17c:	fff00793          	li	a5,-1
c000b180:	fef42623          	sw	a5,-20(s0)
    }

    /* Deselect slave */
    configASSERT(XSpi_SetSlaveSelect(&Spi->Device, 0) == XST_SUCCESS);
c000b184:	fdc42783          	lw	a5,-36(s0)
c000b188:	00000593          	li	a1,0
c000b18c:	00078513          	mv	a0,a5
c000b190:	74d0f0ef          	jal	ra,c001b0dc <XSpi_SetSlaveSelect>
c000b194:	00050793          	mv	a5,a0
c000b198:	00078863          	beqz	a5,c000b1a8 <spi_transfer+0x148>
c000b19c:	30047073          	csrci	mstatus,8
c000b1a0:	00100073          	ebreak
c000b1a4:	0000006f          	j	c000b1a4 <spi_transfer+0x144>

    /* Release mutex and return */
    xSemaphoreGive(Spi->mutex);
c000b1a8:	fdc42783          	lw	a5,-36(s0)
c000b1ac:	0687a783          	lw	a5,104(a5)
c000b1b0:	00000693          	li	a3,0
c000b1b4:	00000613          	li	a2,0
c000b1b8:	00000593          	li	a1,0
c000b1bc:	00078513          	mv	a0,a5
c000b1c0:	d35f50ef          	jal	ra,c0000ef4 <xQueueGenericSend>
    return returnval;
c000b1c4:	fec42783          	lw	a5,-20(s0)
}
c000b1c8:	00078513          	mv	a0,a5
c000b1cc:	02c12083          	lw	ra,44(sp)
c000b1d0:	02812403          	lw	s0,40(sp)
c000b1d4:	03010113          	addi	sp,sp,48
c000b1d8:	00008067          	ret

c000b1dc <SpiStatusHandler>:
*
* @note		None.
*
******************************************************************************/
static void SpiStatusHandler(void *CallBackRef, int StatusEvent, int ByteCount)
{
c000b1dc:	fd010113          	addi	sp,sp,-48
c000b1e0:	02112623          	sw	ra,44(sp)
c000b1e4:	02812423          	sw	s0,40(sp)
c000b1e8:	03010413          	addi	s0,sp,48
c000b1ec:	fca42e23          	sw	a0,-36(s0)
c000b1f0:	fcb42c23          	sw	a1,-40(s0)
c000b1f4:	fcc42a23          	sw	a2,-44(s0)
    struct SpiDriver *Spi = (struct SpiDriver *)CallBackRef;
c000b1f8:	fdc42783          	lw	a5,-36(s0)
c000b1fc:	fef42623          	sw	a5,-20(s0)

    /* If event was not transfer done, track it as an error */
    if (StatusEvent != XST_SPI_TRANSFER_DONE)
c000b200:	fd842703          	lw	a4,-40(s0)
c000b204:	48000793          	li	a5,1152
c000b208:	02f70463          	beq	a4,a5,c000b230 <SpiStatusHandler+0x54>
    {
        Spi->Errors = StatusEvent;
c000b20c:	fec42783          	lw	a5,-20(s0)
c000b210:	fd842703          	lw	a4,-40(s0)
c000b214:	06e7a223          	sw	a4,100(a5)
        Spi->TotalErrorCount++;
c000b218:	fec42783          	lw	a5,-20(s0)
c000b21c:	0607a783          	lw	a5,96(a5)
c000b220:	00178713          	addi	a4,a5,1
c000b224:	fec42783          	lw	a5,-20(s0)
c000b228:	06e7a023          	sw	a4,96(a5)
c000b22c:	0180006f          	j	c000b244 <SpiStatusHandler+0x68>
    }
    else
    {
        /* All OK */
        Spi->TotalTransactiondCount = ByteCount;
c000b230:	fec42783          	lw	a5,-20(s0)
c000b234:	fd442703          	lw	a4,-44(s0)
c000b238:	04e7ae23          	sw	a4,92(a5)
        Spi->Errors = 0;
c000b23c:	fec42783          	lw	a5,-20(s0)
c000b240:	0607a223          	sw	zero,100(a5)
    }

    configASSERT(Spi->task_handle != NULL);
c000b244:	fec42783          	lw	a5,-20(s0)
c000b248:	06c7a783          	lw	a5,108(a5)
c000b24c:	00079863          	bnez	a5,c000b25c <SpiStatusHandler+0x80>
c000b250:	30047073          	csrci	mstatus,8
c000b254:	00100073          	ebreak
c000b258:	0000006f          	j	c000b258 <SpiStatusHandler+0x7c>
    static BaseType_t askForContextSwitch = pdFALSE;
    vTaskNotifyGiveFromISR(Spi->task_handle, &askForContextSwitch);
c000b25c:	fec42783          	lw	a5,-20(s0)
c000b260:	06c7a783          	lw	a5,108(a5)
c000b264:	08038597          	auipc	a1,0x8038
c000b268:	59c58593          	addi	a1,a1,1436 # c8043800 <askForContextSwitch.0>
c000b26c:	00078513          	mv	a0,a5
c000b270:	958fb0ef          	jal	ra,c00063c8 <vTaskNotifyGiveFromISR>
c000b274:	00000013          	nop
c000b278:	02c12083          	lw	ra,44(sp)
c000b27c:	02812403          	lw	s0,40(sp)
c000b280:	03010113          	addi	sp,sp,48
c000b284:	00008067          	ret

c000b288 <Xil_In32>:
{
c000b288:	fe010113          	addi	sp,sp,-32
c000b28c:	00812e23          	sw	s0,28(sp)
c000b290:	02010413          	addi	s0,sp,32
c000b294:	fea42623          	sw	a0,-20(s0)
	return *(volatile u32 *) Addr;
c000b298:	fec42783          	lw	a5,-20(s0)
c000b29c:	0007a783          	lw	a5,0(a5)
}
c000b2a0:	00078513          	mv	a0,a5
c000b2a4:	01c12403          	lw	s0,28(sp)
c000b2a8:	02010113          	addi	sp,sp,32
c000b2ac:	00008067          	ret

c000b2b0 <Xil_Out32>:
*
* @return	None.
*
******************************************************************************/
static INLINE void Xil_Out32(UINTPTR Addr, u32 Value)
{
c000b2b0:	fd010113          	addi	sp,sp,-48
c000b2b4:	02812623          	sw	s0,44(sp)
c000b2b8:	03010413          	addi	s0,sp,48
c000b2bc:	fca42e23          	sw	a0,-36(s0)
c000b2c0:	fcb42c23          	sw	a1,-40(s0)
#ifndef ENABLE_SAFETY
	volatile u32 *LocalAddr = (volatile u32 *)Addr;
c000b2c4:	fdc42783          	lw	a5,-36(s0)
c000b2c8:	fef42623          	sw	a5,-20(s0)
	*LocalAddr = Value;
c000b2cc:	fec42783          	lw	a5,-20(s0)
c000b2d0:	fd842703          	lw	a4,-40(s0)
c000b2d4:	00e7a023          	sw	a4,0(a5)
#else
	XStl_RegUpdate(Addr, Value);
#endif
}
c000b2d8:	00000013          	nop
c000b2dc:	02c12403          	lw	s0,44(sp)
c000b2e0:	03010113          	addi	sp,sp,48
c000b2e4:	00008067          	ret

c000b2e8 <XUartNs550_CfgInitialize>:
*
*****************************************************************************/
int XUartNs550_CfgInitialize(XUartNs550 *InstancePtr,
					XUartNs550_Config *Config,
					UINTPTR EffectiveAddr)
{
c000b2e8:	fd010113          	addi	sp,sp,-48
c000b2ec:	02112623          	sw	ra,44(sp)
c000b2f0:	02812423          	sw	s0,40(sp)
c000b2f4:	03010413          	addi	s0,sp,48
c000b2f8:	fca42e23          	sw	a0,-36(s0)
c000b2fc:	fcb42c23          	sw	a1,-40(s0)
c000b300:	fcc42a23          	sw	a2,-44(s0)
	u32 BaudRate;

	/*
	 * Assert validates the input arguments
	 */
	Xil_AssertNonvoid(InstancePtr != NULL);
c000b304:	fdc42783          	lw	a5,-36(s0)
c000b308:	08078a63          	beqz	a5,c000b39c <XUartNs550_CfgInitialize+0xb4>
c000b30c:	07ff7797          	auipc	a5,0x7ff7
c000b310:	60878793          	addi	a5,a5,1544 # c8002914 <Xil_AssertStatus>
c000b314:	0007a023          	sw	zero,0(a5)

	/*
	 * Setup the data that is from the configuration information
	 */
	InstancePtr->BaseAddress = EffectiveAddr;
c000b318:	fdc42783          	lw	a5,-36(s0)
c000b31c:	fd442703          	lw	a4,-44(s0)
c000b320:	00e7aa23          	sw	a4,20(a5)
	InstancePtr->InputClockHz = Config->InputClockHz;
c000b324:	fd842783          	lw	a5,-40(s0)
c000b328:	0087a703          	lw	a4,8(a5)
c000b32c:	fdc42783          	lw	a5,-36(s0)
c000b330:	00e7ac23          	sw	a4,24(a5)

	/*
	 * Initialize the instance data to some default values and setup
	 * a default handler
	 */
	InstancePtr->Handler = XUartNs550_StubHandler;
c000b334:	fdc42783          	lw	a5,-36(s0)
c000b338:	00001717          	auipc	a4,0x1
c000b33c:	ae870713          	addi	a4,a4,-1304 # c000be20 <XUartNs550_StubHandler>
c000b340:	04e7a023          	sw	a4,64(a5)

	InstancePtr->SendBuffer.NextBytePtr = NULL;
c000b344:	fdc42783          	lw	a5,-36(s0)
c000b348:	0207a423          	sw	zero,40(a5)
	InstancePtr->SendBuffer.RemainingBytes = 0;
c000b34c:	fdc42783          	lw	a5,-36(s0)
c000b350:	0207a823          	sw	zero,48(a5)
	InstancePtr->SendBuffer.RequestedBytes = 0;
c000b354:	fdc42783          	lw	a5,-36(s0)
c000b358:	0207a623          	sw	zero,44(a5)

	InstancePtr->ReceiveBuffer.NextBytePtr = NULL;
c000b35c:	fdc42783          	lw	a5,-36(s0)
c000b360:	0207aa23          	sw	zero,52(a5)
	InstancePtr->ReceiveBuffer.RemainingBytes = 0;
c000b364:	fdc42783          	lw	a5,-36(s0)
c000b368:	0207ae23          	sw	zero,60(a5)
	InstancePtr->ReceiveBuffer.RequestedBytes = 0;
c000b36c:	fdc42783          	lw	a5,-36(s0)
c000b370:	0207ac23          	sw	zero,56(a5)

	/*
	 * Indicate the instance is now ready to use, initialized without error
	 */
	InstancePtr->IsReady = XIL_COMPONENT_IS_READY;
c000b374:	fdc42783          	lw	a5,-36(s0)
c000b378:	11111737          	lui	a4,0x11111
c000b37c:	11170713          	addi	a4,a4,273 # 11111111 <_DMEM_LENGTH+0x10911111>
c000b380:	00e7ae23          	sw	a4,28(a5)

	/*
	 * Set the default Baud rate here, can be changed prior to
	 * starting the device
	 */
	BaudRate = Config->DefaultBaudRate;
c000b384:	fd842783          	lw	a5,-40(s0)
c000b388:	00c7a783          	lw	a5,12(a5)
c000b38c:	fef42623          	sw	a5,-20(s0)
	if (! BaudRate) {
c000b390:	fec42783          	lw	a5,-20(s0)
c000b394:	02079e63          	bnez	a5,c000b3d0 <XUartNs550_CfgInitialize+0xe8>
c000b398:	02c0006f          	j	c000b3c4 <XUartNs550_CfgInitialize+0xdc>
	Xil_AssertNonvoid(InstancePtr != NULL);
c000b39c:	09200593          	li	a1,146
c000b3a0:	07ff5517          	auipc	a0,0x7ff5
c000b3a4:	da050513          	addi	a0,a0,-608 # c8000140 <__rodata_start+0x140>
c000b3a8:	714120ef          	jal	ra,c001dabc <Xil_Assert>
c000b3ac:	07ff7797          	auipc	a5,0x7ff7
c000b3b0:	56878793          	addi	a5,a5,1384 # c8002914 <Xil_AssertStatus>
c000b3b4:	00100713          	li	a4,1
c000b3b8:	00e7a023          	sw	a4,0(a5)
c000b3bc:	00000793          	li	a5,0
c000b3c0:	05c0006f          	j	c000b41c <XUartNs550_CfgInitialize+0x134>
		BaudRate = 19200;
c000b3c4:	000057b7          	lui	a5,0x5
c000b3c8:	b0078793          	addi	a5,a5,-1280 # 4b00 <_STACK_SIZE+0x3b00>
c000b3cc:	fef42623          	sw	a5,-20(s0)
	}

	Status = XUartNs550_SetBaudRate(InstancePtr, BaudRate);
c000b3d0:	fec42583          	lw	a1,-20(s0)
c000b3d4:	fdc42503          	lw	a0,-36(s0)
c000b3d8:	02d000ef          	jal	ra,c000bc04 <XUartNs550_SetBaudRate>
c000b3dc:	fea42423          	sw	a0,-24(s0)
	if (Status != XST_SUCCESS) {
c000b3e0:	fe842783          	lw	a5,-24(s0)
c000b3e4:	00078a63          	beqz	a5,c000b3f8 <XUartNs550_CfgInitialize+0x110>
		InstancePtr->IsReady = 0;
c000b3e8:	fdc42783          	lw	a5,-36(s0)
c000b3ec:	0007ae23          	sw	zero,28(a5)
		return Status;
c000b3f0:	fe842783          	lw	a5,-24(s0)
c000b3f4:	0280006f          	j	c000b41c <XUartNs550_CfgInitialize+0x134>

	/*
	 * Set up the default format for the data, 8 bit data, 1 stop bit,
	 * no parity
	 */
	XUartNs550_SetLineControlReg(InstancePtr->BaseAddress,
c000b3f8:	fdc42783          	lw	a5,-36(s0)
c000b3fc:	0147a783          	lw	a5,20(a5)
c000b400:	00c78793          	addi	a5,a5,12
c000b404:	00300593          	li	a1,3
c000b408:	00078513          	mv	a0,a5
c000b40c:	ea5ff0ef          	jal	ra,c000b2b0 <Xil_Out32>
	//XUartNs550_WriteReg(InstancePtr->BaseAddress, XUN_FCR_OFFSET,
	//			XUN_FIFO_ENABLE | XUN_FIFO_RX_TRIG_MSB);
	/*
	 * Clear the statistics for this driver
	 */
	XUartNs550_ClearStats(InstancePtr);
c000b410:	fdc42503          	lw	a0,-36(s0)
c000b414:	7a9000ef          	jal	ra,c000c3bc <XUartNs550_ClearStats>

	return XST_SUCCESS;
c000b418:	00000793          	li	a5,0
}
c000b41c:	00078513          	mv	a0,a5
c000b420:	02c12083          	lw	ra,44(sp)
c000b424:	02812403          	lw	s0,40(sp)
c000b428:	03010113          	addi	sp,sp,48
c000b42c:	00008067          	ret

c000b430 <XUartNs550_Send>:
* environment and if XUartNs550_SetOptions() if called from a handler.
*
*****************************************************************************/
unsigned int XUartNs550_Send(XUartNs550 *InstancePtr, u8 *BufferPtr,
					unsigned int NumBytes)
{
c000b430:	fd010113          	addi	sp,sp,-48
c000b434:	02112623          	sw	ra,44(sp)
c000b438:	02812423          	sw	s0,40(sp)
c000b43c:	03010413          	addi	s0,sp,48
c000b440:	fca42e23          	sw	a0,-36(s0)
c000b444:	fcb42c23          	sw	a1,-40(s0)
c000b448:	fcc42a23          	sw	a2,-44(s0)
	u32 IerRegister;

	/*
	 * Assert validates the input arguments
	 */
	Xil_AssertNonvoid(InstancePtr != NULL);
c000b44c:	fdc42783          	lw	a5,-36(s0)
c000b450:	00078e63          	beqz	a5,c000b46c <XUartNs550_Send+0x3c>
c000b454:	07ff7797          	auipc	a5,0x7ff7
c000b458:	4c078793          	addi	a5,a5,1216 # c8002914 <Xil_AssertStatus>
c000b45c:	0007a023          	sw	zero,0(a5)
	Xil_AssertNonvoid(BufferPtr != NULL);
c000b460:	fd842783          	lw	a5,-40(s0)
c000b464:	04078a63          	beqz	a5,c000b4b8 <XUartNs550_Send+0x88>
c000b468:	02c0006f          	j	c000b494 <XUartNs550_Send+0x64>
	Xil_AssertNonvoid(InstancePtr != NULL);
c000b46c:	10400593          	li	a1,260
c000b470:	07ff5517          	auipc	a0,0x7ff5
c000b474:	cd050513          	addi	a0,a0,-816 # c8000140 <__rodata_start+0x140>
c000b478:	644120ef          	jal	ra,c001dabc <Xil_Assert>
c000b47c:	07ff7797          	auipc	a5,0x7ff7
c000b480:	49878793          	addi	a5,a5,1176 # c8002914 <Xil_AssertStatus>
c000b484:	00100713          	li	a4,1
c000b488:	00e7a023          	sw	a4,0(a5)
c000b48c:	00000793          	li	a5,0
c000b490:	1300006f          	j	c000b5c0 <XUartNs550_Send+0x190>
	Xil_AssertNonvoid(BufferPtr != NULL);
c000b494:	07ff7797          	auipc	a5,0x7ff7
c000b498:	48078793          	addi	a5,a5,1152 # c8002914 <Xil_AssertStatus>
c000b49c:	0007a023          	sw	zero,0(a5)
	Xil_AssertNonvoid(InstancePtr->IsReady == XIL_COMPONENT_IS_READY);
c000b4a0:	fdc42783          	lw	a5,-36(s0)
c000b4a4:	01c7a703          	lw	a4,28(a5)
c000b4a8:	111117b7          	lui	a5,0x11111
c000b4ac:	11178793          	addi	a5,a5,273 # 11111111 <_DMEM_LENGTH+0x10911111>
c000b4b0:	04f71463          	bne	a4,a5,c000b4f8 <XUartNs550_Send+0xc8>
c000b4b4:	02c0006f          	j	c000b4e0 <XUartNs550_Send+0xb0>
	Xil_AssertNonvoid(BufferPtr != NULL);
c000b4b8:	10500593          	li	a1,261
c000b4bc:	07ff5517          	auipc	a0,0x7ff5
c000b4c0:	c8450513          	addi	a0,a0,-892 # c8000140 <__rodata_start+0x140>
c000b4c4:	5f8120ef          	jal	ra,c001dabc <Xil_Assert>
c000b4c8:	07ff7797          	auipc	a5,0x7ff7
c000b4cc:	44c78793          	addi	a5,a5,1100 # c8002914 <Xil_AssertStatus>
c000b4d0:	00100713          	li	a4,1
c000b4d4:	00e7a023          	sw	a4,0(a5)
c000b4d8:	00000793          	li	a5,0
c000b4dc:	0e40006f          	j	c000b5c0 <XUartNs550_Send+0x190>
	Xil_AssertNonvoid(InstancePtr->IsReady == XIL_COMPONENT_IS_READY);
c000b4e0:	07ff7797          	auipc	a5,0x7ff7
c000b4e4:	43478793          	addi	a5,a5,1076 # c8002914 <Xil_AssertStatus>
c000b4e8:	0007a023          	sw	zero,0(a5)
	Xil_AssertNonvoid(((signed)NumBytes) >= 0);
c000b4ec:	fd442783          	lw	a5,-44(s0)
c000b4f0:	0a07c663          	bltz	a5,c000b59c <XUartNs550_Send+0x16c>
c000b4f4:	02c0006f          	j	c000b520 <XUartNs550_Send+0xf0>
	Xil_AssertNonvoid(InstancePtr->IsReady == XIL_COMPONENT_IS_READY);
c000b4f8:	10600593          	li	a1,262
c000b4fc:	07ff5517          	auipc	a0,0x7ff5
c000b500:	c4450513          	addi	a0,a0,-956 # c8000140 <__rodata_start+0x140>
c000b504:	5b8120ef          	jal	ra,c001dabc <Xil_Assert>
c000b508:	07ff7797          	auipc	a5,0x7ff7
c000b50c:	40c78793          	addi	a5,a5,1036 # c8002914 <Xil_AssertStatus>
c000b510:	00100713          	li	a4,1
c000b514:	00e7a023          	sw	a4,0(a5)
c000b518:	00000793          	li	a5,0
c000b51c:	0a40006f          	j	c000b5c0 <XUartNs550_Send+0x190>
	Xil_AssertNonvoid(((signed)NumBytes) >= 0);
c000b520:	07ff7797          	auipc	a5,0x7ff7
c000b524:	3f478793          	addi	a5,a5,1012 # c8002914 <Xil_AssertStatus>
c000b528:	0007a023          	sw	zero,0(a5)
	 * Enter a critical region by disabling the UART transmit interrupts to
	 * allow this call to stop a previous operation that may be interrupt
	 * driven, only stop the transmit interrupt since this critical region
	 * is not really exited in the normal manner
	 */
	IerRegister = XUartNs550_ReadReg(InstancePtr->BaseAddress,
c000b52c:	fdc42783          	lw	a5,-36(s0)
c000b530:	0147a783          	lw	a5,20(a5)
c000b534:	00478793          	addi	a5,a5,4
c000b538:	00078513          	mv	a0,a5
c000b53c:	d4dff0ef          	jal	ra,c000b288 <Xil_In32>
c000b540:	fea42623          	sw	a0,-20(s0)
						XUN_IER_OFFSET);
	XUartNs550_WriteReg(InstancePtr->BaseAddress, XUN_IER_OFFSET,
c000b544:	fdc42783          	lw	a5,-36(s0)
c000b548:	0147a783          	lw	a5,20(a5)
c000b54c:	00478713          	addi	a4,a5,4
c000b550:	fec42783          	lw	a5,-20(s0)
c000b554:	ffd7f793          	andi	a5,a5,-3
c000b558:	00078593          	mv	a1,a5
c000b55c:	00070513          	mv	a0,a4
c000b560:	d51ff0ef          	jal	ra,c000b2b0 <Xil_Out32>

	/*
	 * Setup the specified buffer to be sent by setting the instance
	 * variables so it can be sent with polled or interrupt mode
	 */
	InstancePtr->SendBuffer.RequestedBytes = NumBytes;
c000b564:	fdc42783          	lw	a5,-36(s0)
c000b568:	fd442703          	lw	a4,-44(s0)
c000b56c:	02e7a623          	sw	a4,44(a5)
	InstancePtr->SendBuffer.RemainingBytes = NumBytes;
c000b570:	fdc42783          	lw	a5,-36(s0)
c000b574:	fd442703          	lw	a4,-44(s0)
c000b578:	02e7a823          	sw	a4,48(a5)
	InstancePtr->SendBuffer.NextBytePtr = BufferPtr;
c000b57c:	fdc42783          	lw	a5,-36(s0)
c000b580:	fd842703          	lw	a4,-40(s0)
c000b584:	02e7a423          	sw	a4,40(a5)

	/*
	 * Send the buffer using the UART and return the number of bytes sent
	 */

	BytesSent = XUartNs550_SendBuffer(InstancePtr);
c000b588:	fdc42503          	lw	a0,-36(s0)
c000b58c:	1fc000ef          	jal	ra,c000b788 <XUartNs550_SendBuffer>
c000b590:	fea42423          	sw	a0,-24(s0)
	 * the transmit interrupts work.  The other function called enables the
	 * tranmit interrupt such that this function can't restore a value to
	 * the interrupt enable register and does not need to exit the critical
	 * region
	 */
	return BytesSent;
c000b594:	fe842783          	lw	a5,-24(s0)
c000b598:	0280006f          	j	c000b5c0 <XUartNs550_Send+0x190>
	Xil_AssertNonvoid(((signed)NumBytes) >= 0);
c000b59c:	10700593          	li	a1,263
c000b5a0:	07ff5517          	auipc	a0,0x7ff5
c000b5a4:	ba050513          	addi	a0,a0,-1120 # c8000140 <__rodata_start+0x140>
c000b5a8:	514120ef          	jal	ra,c001dabc <Xil_Assert>
c000b5ac:	07ff7797          	auipc	a5,0x7ff7
c000b5b0:	36878793          	addi	a5,a5,872 # c8002914 <Xil_AssertStatus>
c000b5b4:	00100713          	li	a4,1
c000b5b8:	00e7a023          	sw	a4,0(a5)
c000b5bc:	00000793          	li	a5,0
}
c000b5c0:	00078513          	mv	a0,a5
c000b5c4:	02c12083          	lw	ra,44(sp)
c000b5c8:	02812403          	lw	s0,40(sp)
c000b5cc:	03010113          	addi	sp,sp,48
c000b5d0:	00008067          	ret

c000b5d4 <XUartNs550_Recv>:
* a value of zero to stop an operation that is already in progress.
*
*****************************************************************************/
unsigned int XUartNs550_Recv(XUartNs550 *InstancePtr, u8 *BufferPtr,
				unsigned int NumBytes)
{
c000b5d4:	fd010113          	addi	sp,sp,-48
c000b5d8:	02112623          	sw	ra,44(sp)
c000b5dc:	02812423          	sw	s0,40(sp)
c000b5e0:	03010413          	addi	s0,sp,48
c000b5e4:	fca42e23          	sw	a0,-36(s0)
c000b5e8:	fcb42c23          	sw	a1,-40(s0)
c000b5ec:	fcc42a23          	sw	a2,-44(s0)
	u32 IerRegister;

	/*
	 * Assert validates the input arguments
	 */
	Xil_AssertNonvoid(InstancePtr != NULL);
c000b5f0:	fdc42783          	lw	a5,-36(s0)
c000b5f4:	00078e63          	beqz	a5,c000b610 <XUartNs550_Recv+0x3c>
c000b5f8:	07ff7797          	auipc	a5,0x7ff7
c000b5fc:	31c78793          	addi	a5,a5,796 # c8002914 <Xil_AssertStatus>
c000b600:	0007a023          	sw	zero,0(a5)
	Xil_AssertNonvoid(BufferPtr != NULL);
c000b604:	fd842783          	lw	a5,-40(s0)
c000b608:	04078a63          	beqz	a5,c000b65c <XUartNs550_Recv+0x88>
c000b60c:	02c0006f          	j	c000b638 <XUartNs550_Recv+0x64>
	Xil_AssertNonvoid(InstancePtr != NULL);
c000b610:	15600593          	li	a1,342
c000b614:	07ff5517          	auipc	a0,0x7ff5
c000b618:	b2c50513          	addi	a0,a0,-1236 # c8000140 <__rodata_start+0x140>
c000b61c:	4a0120ef          	jal	ra,c001dabc <Xil_Assert>
c000b620:	07ff7797          	auipc	a5,0x7ff7
c000b624:	2f478793          	addi	a5,a5,756 # c8002914 <Xil_AssertStatus>
c000b628:	00100713          	li	a4,1
c000b62c:	00e7a023          	sw	a4,0(a5)
c000b630:	00000793          	li	a5,0
c000b634:	1400006f          	j	c000b774 <XUartNs550_Recv+0x1a0>
	Xil_AssertNonvoid(BufferPtr != NULL);
c000b638:	07ff7797          	auipc	a5,0x7ff7
c000b63c:	2dc78793          	addi	a5,a5,732 # c8002914 <Xil_AssertStatus>
c000b640:	0007a023          	sw	zero,0(a5)
	Xil_AssertNonvoid(InstancePtr->IsReady == XIL_COMPONENT_IS_READY);
c000b644:	fdc42783          	lw	a5,-36(s0)
c000b648:	01c7a703          	lw	a4,28(a5)
c000b64c:	111117b7          	lui	a5,0x11111
c000b650:	11178793          	addi	a5,a5,273 # 11111111 <_DMEM_LENGTH+0x10911111>
c000b654:	04f71463          	bne	a4,a5,c000b69c <XUartNs550_Recv+0xc8>
c000b658:	02c0006f          	j	c000b684 <XUartNs550_Recv+0xb0>
	Xil_AssertNonvoid(BufferPtr != NULL);
c000b65c:	15700593          	li	a1,343
c000b660:	07ff5517          	auipc	a0,0x7ff5
c000b664:	ae050513          	addi	a0,a0,-1312 # c8000140 <__rodata_start+0x140>
c000b668:	454120ef          	jal	ra,c001dabc <Xil_Assert>
c000b66c:	07ff7797          	auipc	a5,0x7ff7
c000b670:	2a878793          	addi	a5,a5,680 # c8002914 <Xil_AssertStatus>
c000b674:	00100713          	li	a4,1
c000b678:	00e7a023          	sw	a4,0(a5)
c000b67c:	00000793          	li	a5,0
c000b680:	0f40006f          	j	c000b774 <XUartNs550_Recv+0x1a0>
	Xil_AssertNonvoid(InstancePtr->IsReady == XIL_COMPONENT_IS_READY);
c000b684:	07ff7797          	auipc	a5,0x7ff7
c000b688:	29078793          	addi	a5,a5,656 # c8002914 <Xil_AssertStatus>
c000b68c:	0007a023          	sw	zero,0(a5)
	Xil_AssertNonvoid(((signed)NumBytes) >= 0);
c000b690:	fd442783          	lw	a5,-44(s0)
c000b694:	0a07ce63          	bltz	a5,c000b750 <XUartNs550_Recv+0x17c>
c000b698:	02c0006f          	j	c000b6c4 <XUartNs550_Recv+0xf0>
	Xil_AssertNonvoid(InstancePtr->IsReady == XIL_COMPONENT_IS_READY);
c000b69c:	15800593          	li	a1,344
c000b6a0:	07ff5517          	auipc	a0,0x7ff5
c000b6a4:	aa050513          	addi	a0,a0,-1376 # c8000140 <__rodata_start+0x140>
c000b6a8:	414120ef          	jal	ra,c001dabc <Xil_Assert>
c000b6ac:	07ff7797          	auipc	a5,0x7ff7
c000b6b0:	26878793          	addi	a5,a5,616 # c8002914 <Xil_AssertStatus>
c000b6b4:	00100713          	li	a4,1
c000b6b8:	00e7a023          	sw	a4,0(a5)
c000b6bc:	00000793          	li	a5,0
c000b6c0:	0b40006f          	j	c000b774 <XUartNs550_Recv+0x1a0>
	Xil_AssertNonvoid(((signed)NumBytes) >= 0);
c000b6c4:	07ff7797          	auipc	a5,0x7ff7
c000b6c8:	25078793          	addi	a5,a5,592 # c8002914 <Xil_AssertStatus>
c000b6cc:	0007a023          	sw	zero,0(a5)

	/*
	 * Enter a critical region by disabling all the UART interrupts to allow
	 * this call to stop a previous operation that may be interrupt driven
	 */
	IerRegister = XUartNs550_ReadReg(InstancePtr->BaseAddress,
c000b6d0:	fdc42783          	lw	a5,-36(s0)
c000b6d4:	0147a783          	lw	a5,20(a5)
c000b6d8:	00478793          	addi	a5,a5,4
c000b6dc:	00078513          	mv	a0,a5
c000b6e0:	ba9ff0ef          	jal	ra,c000b288 <Xil_In32>
c000b6e4:	fea42623          	sw	a0,-20(s0)
						XUN_IER_OFFSET);
	XUartNs550_WriteReg(InstancePtr->BaseAddress, XUN_IER_OFFSET, 0);
c000b6e8:	fdc42783          	lw	a5,-36(s0)
c000b6ec:	0147a783          	lw	a5,20(a5)
c000b6f0:	00478793          	addi	a5,a5,4
c000b6f4:	00000593          	li	a1,0
c000b6f8:	00078513          	mv	a0,a5
c000b6fc:	bb5ff0ef          	jal	ra,c000b2b0 <Xil_Out32>

	/*
	 * Setup the specified buffer to be received by setting the instance
	 * variables so it can be received with polled or interrupt mode
	 */
	InstancePtr->ReceiveBuffer.RequestedBytes = NumBytes;
c000b700:	fdc42783          	lw	a5,-36(s0)
c000b704:	fd442703          	lw	a4,-44(s0)
c000b708:	02e7ac23          	sw	a4,56(a5)
	InstancePtr->ReceiveBuffer.RemainingBytes = NumBytes;
c000b70c:	fdc42783          	lw	a5,-36(s0)
c000b710:	fd442703          	lw	a4,-44(s0)
c000b714:	02e7ae23          	sw	a4,60(a5)
	InstancePtr->ReceiveBuffer.NextBytePtr = BufferPtr;
c000b718:	fdc42783          	lw	a5,-36(s0)
c000b71c:	fd842703          	lw	a4,-40(s0)
c000b720:	02e7aa23          	sw	a4,52(a5)

	/*
	 * Receive the data from the UART and return the number of bytes
	 * received
	 */
	ReceivedCount = XUartNs550_ReceiveBuffer(InstancePtr);
c000b724:	fdc42503          	lw	a0,-36(s0)
c000b728:	220000ef          	jal	ra,c000b948 <XUartNs550_ReceiveBuffer>
c000b72c:	fea42423          	sw	a0,-24(s0)

	/*
	 * Restore the interrupt enable register to it's previous value such
	 * that the critical region is exited
	 */
	XUartNs550_WriteReg(InstancePtr->BaseAddress, XUN_IER_OFFSET,
c000b730:	fdc42783          	lw	a5,-36(s0)
c000b734:	0147a783          	lw	a5,20(a5)
c000b738:	00478793          	addi	a5,a5,4
c000b73c:	fec42583          	lw	a1,-20(s0)
c000b740:	00078513          	mv	a0,a5
c000b744:	b6dff0ef          	jal	ra,c000b2b0 <Xil_Out32>
				IerRegister);

	return ReceivedCount;
c000b748:	fe842783          	lw	a5,-24(s0)
c000b74c:	0280006f          	j	c000b774 <XUartNs550_Recv+0x1a0>
	Xil_AssertNonvoid(((signed)NumBytes) >= 0);
c000b750:	15900593          	li	a1,345
c000b754:	07ff5517          	auipc	a0,0x7ff5
c000b758:	9ec50513          	addi	a0,a0,-1556 # c8000140 <__rodata_start+0x140>
c000b75c:	360120ef          	jal	ra,c001dabc <Xil_Assert>
c000b760:	07ff7797          	auipc	a5,0x7ff7
c000b764:	1b478793          	addi	a5,a5,436 # c8002914 <Xil_AssertStatus>
c000b768:	00100713          	li	a4,1
c000b76c:	00e7a023          	sw	a4,0(a5)
c000b770:	00000793          	li	a5,0
}
c000b774:	00078513          	mv	a0,a5
c000b778:	02c12083          	lw	ra,44(sp)
c000b77c:	02812403          	lw	s0,40(sp)
c000b780:	03010113          	addi	sp,sp,48
c000b784:	00008067          	ret

c000b788 <XUartNs550_SendBuffer>:
*
* @note		None.
*
*****************************************************************************/
unsigned int XUartNs550_SendBuffer(XUartNs550 *InstancePtr)
{
c000b788:	fc010113          	addi	sp,sp,-64
c000b78c:	02112e23          	sw	ra,60(sp)
c000b790:	02812c23          	sw	s0,56(sp)
c000b794:	04010413          	addi	s0,sp,64
c000b798:	fca42623          	sw	a0,-52(s0)
	unsigned int SentCount = 0;
c000b79c:	fe042623          	sw	zero,-20(s0)
	unsigned int BytesToSend = 0;   /* default to not send anything */
c000b7a0:	fe042423          	sw	zero,-24(s0)

	/*
	 * Read the line status register to determine if the transmitter is
	 * empty
	 */
	LsrRegister = XUartNs550_GetLineStatusReg(InstancePtr->BaseAddress);
c000b7a4:	fcc42783          	lw	a5,-52(s0)
c000b7a8:	0147a783          	lw	a5,20(a5)
c000b7ac:	01478793          	addi	a5,a5,20
c000b7b0:	00078513          	mv	a0,a5
c000b7b4:	ad5ff0ef          	jal	ra,c000b288 <Xil_In32>
c000b7b8:	fea42023          	sw	a0,-32(s0)

	/*
	 * If the transmitter is not empty then don't send any data, the empty
	 * room in the FIFO is not available
	 */
	if (LsrRegister & XUN_LSR_TX_BUFFER_EMPTY) {
c000b7bc:	fe042783          	lw	a5,-32(s0)
c000b7c0:	0207f793          	andi	a5,a5,32
c000b7c4:	0c078863          	beqz	a5,c000b894 <XUartNs550_SendBuffer+0x10c>
		/*
		 * Read the interrupt ID register to determine if FIFOs
		 * are enabled
		 */
		IirRegister = XUartNs550_ReadReg(InstancePtr->BaseAddress,
c000b7c8:	fcc42783          	lw	a5,-52(s0)
c000b7cc:	0147a783          	lw	a5,20(a5)
c000b7d0:	00878793          	addi	a5,a5,8
c000b7d4:	00078513          	mv	a0,a5
c000b7d8:	ab1ff0ef          	jal	ra,c000b288 <Xil_In32>
c000b7dc:	fca42e23          	sw	a0,-36(s0)

		/*
		 * When there are FIFOs, send up to the FIFO size. When there
		 * are no FIFOs, only send 1 byte of data
		 */
		if (IirRegister & XUN_INT_ID_FIFOS_ENABLED) {
c000b7e0:	fdc42783          	lw	a5,-36(s0)
c000b7e4:	0c07f793          	andi	a5,a5,192
c000b7e8:	04078863          	beqz	a5,c000b838 <XUartNs550_SendBuffer+0xb0>
			/*
			 * Determine how many bytes can be sent depending on if
			 * the transmitter is empty, a FIFO size of N is really
			 * N - 1 plus the transmitter register
			 */
			if (LsrRegister & XUN_LSR_TX_EMPTY) {
c000b7ec:	fe042783          	lw	a5,-32(s0)
c000b7f0:	0407f793          	andi	a5,a5,64
c000b7f4:	00078863          	beqz	a5,c000b804 <XUartNs550_SendBuffer+0x7c>
				FifoSize = XUN_FIFO_SIZE;
c000b7f8:	01000793          	li	a5,16
c000b7fc:	fef42223          	sw	a5,-28(s0)
c000b800:	00c0006f          	j	c000b80c <XUartNs550_SendBuffer+0x84>
			} else {
				FifoSize = XUN_FIFO_SIZE - 1;
c000b804:	00f00793          	li	a5,15
c000b808:	fef42223          	sw	a5,-28(s0)
			/*
			 * FIFOs are enabled, if the number of bytes to send
			 * is less than the size of the FIFO, then send all
			 * bytes, otherwise fill the FIFO
			 */
			if (InstancePtr->SendBuffer.RemainingBytes < FifoSize) {
c000b80c:	fcc42783          	lw	a5,-52(s0)
c000b810:	0307a783          	lw	a5,48(a5)
c000b814:	fe442703          	lw	a4,-28(s0)
c000b818:	00e7fa63          	bgeu	a5,a4,c000b82c <XUartNs550_SendBuffer+0xa4>
				BytesToSend =
c000b81c:	fcc42783          	lw	a5,-52(s0)
c000b820:	0307a783          	lw	a5,48(a5)
c000b824:	fef42423          	sw	a5,-24(s0)
c000b828:	0240006f          	j	c000b84c <XUartNs550_SendBuffer+0xc4>
					InstancePtr->SendBuffer.RemainingBytes;
			} else {
				BytesToSend = FifoSize;
c000b82c:	fe442783          	lw	a5,-28(s0)
c000b830:	fef42423          	sw	a5,-24(s0)
c000b834:	0180006f          	j	c000b84c <XUartNs550_SendBuffer+0xc4>
			}
		} else if (InstancePtr->SendBuffer.RemainingBytes > 0) {
c000b838:	fcc42783          	lw	a5,-52(s0)
c000b83c:	0307a783          	lw	a5,48(a5)
c000b840:	00078663          	beqz	a5,c000b84c <XUartNs550_SendBuffer+0xc4>
			 * Without FIFOs, we can only send 1 byte. We needed to
			 * check for non-zero remaining bytes in case this
			 * routine was called only to kick the transmitter and
			 * enable the UART interrupt
			 */
			BytesToSend = 1;
c000b844:	00100793          	li	a5,1
c000b848:	fef42423          	sw	a5,-24(s0)

		/*
		 * Fill the FIFO if it's present or the transmitter only from
		 * the the buffer that was specified
		 */
		for (SentCount = 0; SentCount < BytesToSend; SentCount++) {
c000b84c:	fe042623          	sw	zero,-20(s0)
c000b850:	0380006f          	j	c000b888 <XUartNs550_SendBuffer+0x100>
			XUartNs550_WriteReg(InstancePtr->BaseAddress,
c000b854:	fcc42783          	lw	a5,-52(s0)
c000b858:	0147a683          	lw	a3,20(a5)
c000b85c:	fcc42783          	lw	a5,-52(s0)
c000b860:	0287a703          	lw	a4,40(a5)
c000b864:	fec42783          	lw	a5,-20(s0)
c000b868:	00f707b3          	add	a5,a4,a5
c000b86c:	0007c783          	lbu	a5,0(a5)
c000b870:	00078593          	mv	a1,a5
c000b874:	00068513          	mv	a0,a3
c000b878:	a39ff0ef          	jal	ra,c000b2b0 <Xil_Out32>
		for (SentCount = 0; SentCount < BytesToSend; SentCount++) {
c000b87c:	fec42783          	lw	a5,-20(s0)
c000b880:	00178793          	addi	a5,a5,1
c000b884:	fef42623          	sw	a5,-20(s0)
c000b888:	fec42703          	lw	a4,-20(s0)
c000b88c:	fe842783          	lw	a5,-24(s0)
c000b890:	fcf762e3          	bltu	a4,a5,c000b854 <XUartNs550_SendBuffer+0xcc>
		}
	}
	/*
	 * Update the buffer to reflect the bytes that were sent from it
	 */
	InstancePtr->SendBuffer.NextBytePtr += SentCount;
c000b894:	fcc42783          	lw	a5,-52(s0)
c000b898:	0287a703          	lw	a4,40(a5)
c000b89c:	fec42783          	lw	a5,-20(s0)
c000b8a0:	00f70733          	add	a4,a4,a5
c000b8a4:	fcc42783          	lw	a5,-52(s0)
c000b8a8:	02e7a423          	sw	a4,40(a5)
	InstancePtr->SendBuffer.RemainingBytes -= SentCount;
c000b8ac:	fcc42783          	lw	a5,-52(s0)
c000b8b0:	0307a703          	lw	a4,48(a5)
c000b8b4:	fec42783          	lw	a5,-20(s0)
c000b8b8:	40f70733          	sub	a4,a4,a5
c000b8bc:	fcc42783          	lw	a5,-52(s0)
c000b8c0:	02e7a823          	sw	a4,48(a5)

	/*
	 * Increment associated counters
	 */
	 InstancePtr->Stats.CharactersTransmitted += SentCount;
c000b8c4:	fcc42783          	lw	a5,-52(s0)
c000b8c8:	0087d703          	lhu	a4,8(a5)
c000b8cc:	fec42783          	lw	a5,-20(s0)
c000b8d0:	01079793          	slli	a5,a5,0x10
c000b8d4:	0107d793          	srli	a5,a5,0x10
c000b8d8:	00f707b3          	add	a5,a4,a5
c000b8dc:	01079713          	slli	a4,a5,0x10
c000b8e0:	01075713          	srli	a4,a4,0x10
c000b8e4:	fcc42783          	lw	a5,-52(s0)
c000b8e8:	00e79423          	sh	a4,8(a5)
	/*
	 * If interrupts are enabled as indicated by the receive interrupt, then
	 * enable the transmit interrupt, it is not enabled continuously because
	 * it causes an interrupt whenever the FIFO is empty
	 */
	IerRegister = XUartNs550_ReadReg(InstancePtr->BaseAddress,
c000b8ec:	fcc42783          	lw	a5,-52(s0)
c000b8f0:	0147a783          	lw	a5,20(a5)
c000b8f4:	00478793          	addi	a5,a5,4
c000b8f8:	00078513          	mv	a0,a5
c000b8fc:	98dff0ef          	jal	ra,c000b288 <Xil_In32>
c000b900:	fca42c23          	sw	a0,-40(s0)
						XUN_IER_OFFSET);
	if (IerRegister & XUN_IER_RX_DATA) {
c000b904:	fd842783          	lw	a5,-40(s0)
c000b908:	0017f793          	andi	a5,a5,1
c000b90c:	02078263          	beqz	a5,c000b930 <XUartNs550_SendBuffer+0x1a8>
		XUartNs550_WriteReg(InstancePtr->BaseAddress, XUN_IER_OFFSET,
c000b910:	fcc42783          	lw	a5,-52(s0)
c000b914:	0147a783          	lw	a5,20(a5)
c000b918:	00478713          	addi	a4,a5,4
c000b91c:	fd842783          	lw	a5,-40(s0)
c000b920:	0027e793          	ori	a5,a5,2
c000b924:	00078593          	mv	a1,a5
c000b928:	00070513          	mv	a0,a4
c000b92c:	985ff0ef          	jal	ra,c000b2b0 <Xil_Out32>
	}
	/*
	 * Return the number of bytes that were sent, althought they really were
	 * only put into the FIFO, not completely sent yet
	 */
	return SentCount;
c000b930:	fec42783          	lw	a5,-20(s0)
}
c000b934:	00078513          	mv	a0,a5
c000b938:	03c12083          	lw	ra,60(sp)
c000b93c:	03812403          	lw	s0,56(sp)
c000b940:	04010113          	addi	sp,sp,64
c000b944:	00008067          	ret

c000b948 <XUartNs550_ReceiveBuffer>:
*
* @note		None.
*
*****************************************************************************/
unsigned int XUartNs550_ReceiveBuffer(XUartNs550 *InstancePtr)
{
c000b948:	fd010113          	addi	sp,sp,-48
c000b94c:	02112623          	sw	ra,44(sp)
c000b950:	02812423          	sw	s0,40(sp)
c000b954:	03010413          	addi	s0,sp,48
c000b958:	fca42e23          	sw	a0,-36(s0)
	u32 LsrRegister;
	unsigned int ReceivedCount = 0;
c000b95c:	fe042623          	sw	zero,-20(s0)

	/*
	 * Loop until there is not more data buffered by the UART or the
	 * specified number of bytes is received
	 */
	while (ReceivedCount < InstancePtr->ReceiveBuffer.RemainingBytes) {
c000b960:	21c0006f          	j	c000bb7c <XUartNs550_ReceiveBuffer+0x234>
		/*
		 * Read the Line Status Register to determine if there is any
		 * data in the receiver/FIFO
		 */
		LsrRegister =
			XUartNs550_GetLineStatusReg(InstancePtr->BaseAddress);
c000b964:	fdc42783          	lw	a5,-36(s0)
c000b968:	0147a783          	lw	a5,20(a5)
c000b96c:	01478793          	addi	a5,a5,20
c000b970:	00078513          	mv	a0,a5
c000b974:	915ff0ef          	jal	ra,c000b288 <Xil_In32>
c000b978:	fea42423          	sw	a0,-24(s0)
		/*
		 * If there is a break condition then a zero data byte was put
		 * into the receiver, just read it and dump it and update the
		 * stats
		 */
		if (LsrRegister & XUN_LSR_BREAK_INT) {
c000b97c:	fe842783          	lw	a5,-24(s0)
c000b980:	0107f793          	andi	a5,a5,16
c000b984:	0e078463          	beqz	a5,c000ba6c <XUartNs550_ReceiveBuffer+0x124>
			(void)XUartNs550_ReadReg(InstancePtr->BaseAddress,
c000b988:	fdc42783          	lw	a5,-36(s0)
c000b98c:	0147a783          	lw	a5,20(a5)
c000b990:	00078513          	mv	a0,a5
c000b994:	8f5ff0ef          	jal	ra,c000b288 <Xil_In32>
							XUN_RBR_OFFSET);
			XUartNs550_UpdateStats(InstancePtr, (u8)LsrRegister);
c000b998:	fdc42783          	lw	a5,-36(s0)
c000b99c:	0247c703          	lbu	a4,36(a5)
c000b9a0:	fe842783          	lw	a5,-24(s0)
c000b9a4:	0ff7f793          	andi	a5,a5,255
c000b9a8:	00f767b3          	or	a5,a4,a5
c000b9ac:	0ff7f713          	andi	a4,a5,255
c000b9b0:	fdc42783          	lw	a5,-36(s0)
c000b9b4:	02e78223          	sb	a4,36(a5)
c000b9b8:	fe842783          	lw	a5,-24(s0)
c000b9bc:	0ff7f793          	andi	a5,a5,255
c000b9c0:	0027f793          	andi	a5,a5,2
c000b9c4:	02078063          	beqz	a5,c000b9e4 <XUartNs550_ReceiveBuffer+0x9c>
c000b9c8:	fdc42783          	lw	a5,-36(s0)
c000b9cc:	00c7d783          	lhu	a5,12(a5)
c000b9d0:	00178793          	addi	a5,a5,1
c000b9d4:	01079713          	slli	a4,a5,0x10
c000b9d8:	01075713          	srli	a4,a4,0x10
c000b9dc:	fdc42783          	lw	a5,-36(s0)
c000b9e0:	00e79623          	sh	a4,12(a5)
c000b9e4:	fe842783          	lw	a5,-24(s0)
c000b9e8:	0ff7f793          	andi	a5,a5,255
c000b9ec:	0047f793          	andi	a5,a5,4
c000b9f0:	02078063          	beqz	a5,c000ba10 <XUartNs550_ReceiveBuffer+0xc8>
c000b9f4:	fdc42783          	lw	a5,-36(s0)
c000b9f8:	00e7d783          	lhu	a5,14(a5)
c000b9fc:	00178793          	addi	a5,a5,1
c000ba00:	01079713          	slli	a4,a5,0x10
c000ba04:	01075713          	srli	a4,a4,0x10
c000ba08:	fdc42783          	lw	a5,-36(s0)
c000ba0c:	00e79723          	sh	a4,14(a5)
c000ba10:	fe842783          	lw	a5,-24(s0)
c000ba14:	0ff7f793          	andi	a5,a5,255
c000ba18:	0087f793          	andi	a5,a5,8
c000ba1c:	02078063          	beqz	a5,c000ba3c <XUartNs550_ReceiveBuffer+0xf4>
c000ba20:	fdc42783          	lw	a5,-36(s0)
c000ba24:	0107d783          	lhu	a5,16(a5)
c000ba28:	00178793          	addi	a5,a5,1
c000ba2c:	01079713          	slli	a4,a5,0x10
c000ba30:	01075713          	srli	a4,a4,0x10
c000ba34:	fdc42783          	lw	a5,-36(s0)
c000ba38:	00e79823          	sh	a4,16(a5)
c000ba3c:	fe842783          	lw	a5,-24(s0)
c000ba40:	0ff7f793          	andi	a5,a5,255
c000ba44:	0107f793          	andi	a5,a5,16
c000ba48:	12078a63          	beqz	a5,c000bb7c <XUartNs550_ReceiveBuffer+0x234>
c000ba4c:	fdc42783          	lw	a5,-36(s0)
c000ba50:	0127d783          	lhu	a5,18(a5)
c000ba54:	00178793          	addi	a5,a5,1
c000ba58:	01079713          	slli	a4,a5,0x10
c000ba5c:	01075713          	srli	a4,a4,0x10
c000ba60:	fdc42783          	lw	a5,-36(s0)
c000ba64:	00e79923          	sh	a4,18(a5)
c000ba68:	1140006f          	j	c000bb7c <XUartNs550_ReceiveBuffer+0x234>
		/*
		 * If there is data ready to be removed, then put the next byte
		 * received into the specified buffer and update the stats to
		 * reflect any receive errors for the byte
		 */
		else if (LsrRegister & XUN_LSR_DATA_READY) {
c000ba6c:	fe842783          	lw	a5,-24(s0)
c000ba70:	0017f793          	andi	a5,a5,1
c000ba74:	10078e63          	beqz	a5,c000bb90 <XUartNs550_ReceiveBuffer+0x248>
			InstancePtr->ReceiveBuffer.NextBytePtr[ReceivedCount++] =
			XUartNs550_ReadReg(InstancePtr->BaseAddress,
c000ba78:	fdc42783          	lw	a5,-36(s0)
c000ba7c:	0147a783          	lw	a5,20(a5)
c000ba80:	00078513          	mv	a0,a5
c000ba84:	805ff0ef          	jal	ra,c000b288 <Xil_In32>
c000ba88:	00050613          	mv	a2,a0
			InstancePtr->ReceiveBuffer.NextBytePtr[ReceivedCount++] =
c000ba8c:	fdc42783          	lw	a5,-36(s0)
c000ba90:	0347a703          	lw	a4,52(a5)
c000ba94:	fec42783          	lw	a5,-20(s0)
c000ba98:	00178693          	addi	a3,a5,1
c000ba9c:	fed42623          	sw	a3,-20(s0)
c000baa0:	00f707b3          	add	a5,a4,a5
c000baa4:	0ff67713          	andi	a4,a2,255
c000baa8:	00e78023          	sb	a4,0(a5)
						XUN_RBR_OFFSET);

			XUartNs550_UpdateStats(InstancePtr, (u8)LsrRegister);
c000baac:	fdc42783          	lw	a5,-36(s0)
c000bab0:	0247c703          	lbu	a4,36(a5)
c000bab4:	fe842783          	lw	a5,-24(s0)
c000bab8:	0ff7f793          	andi	a5,a5,255
c000babc:	00f767b3          	or	a5,a4,a5
c000bac0:	0ff7f713          	andi	a4,a5,255
c000bac4:	fdc42783          	lw	a5,-36(s0)
c000bac8:	02e78223          	sb	a4,36(a5)
c000bacc:	fe842783          	lw	a5,-24(s0)
c000bad0:	0ff7f793          	andi	a5,a5,255
c000bad4:	0027f793          	andi	a5,a5,2
c000bad8:	02078063          	beqz	a5,c000baf8 <XUartNs550_ReceiveBuffer+0x1b0>
c000badc:	fdc42783          	lw	a5,-36(s0)
c000bae0:	00c7d783          	lhu	a5,12(a5)
c000bae4:	00178793          	addi	a5,a5,1
c000bae8:	01079713          	slli	a4,a5,0x10
c000baec:	01075713          	srli	a4,a4,0x10
c000baf0:	fdc42783          	lw	a5,-36(s0)
c000baf4:	00e79623          	sh	a4,12(a5)
c000baf8:	fe842783          	lw	a5,-24(s0)
c000bafc:	0ff7f793          	andi	a5,a5,255
c000bb00:	0047f793          	andi	a5,a5,4
c000bb04:	02078063          	beqz	a5,c000bb24 <XUartNs550_ReceiveBuffer+0x1dc>
c000bb08:	fdc42783          	lw	a5,-36(s0)
c000bb0c:	00e7d783          	lhu	a5,14(a5)
c000bb10:	00178793          	addi	a5,a5,1
c000bb14:	01079713          	slli	a4,a5,0x10
c000bb18:	01075713          	srli	a4,a4,0x10
c000bb1c:	fdc42783          	lw	a5,-36(s0)
c000bb20:	00e79723          	sh	a4,14(a5)
c000bb24:	fe842783          	lw	a5,-24(s0)
c000bb28:	0ff7f793          	andi	a5,a5,255
c000bb2c:	0087f793          	andi	a5,a5,8
c000bb30:	02078063          	beqz	a5,c000bb50 <XUartNs550_ReceiveBuffer+0x208>
c000bb34:	fdc42783          	lw	a5,-36(s0)
c000bb38:	0107d783          	lhu	a5,16(a5)
c000bb3c:	00178793          	addi	a5,a5,1
c000bb40:	01079713          	slli	a4,a5,0x10
c000bb44:	01075713          	srli	a4,a4,0x10
c000bb48:	fdc42783          	lw	a5,-36(s0)
c000bb4c:	00e79823          	sh	a4,16(a5)
c000bb50:	fe842783          	lw	a5,-24(s0)
c000bb54:	0ff7f793          	andi	a5,a5,255
c000bb58:	0107f793          	andi	a5,a5,16
c000bb5c:	02078063          	beqz	a5,c000bb7c <XUartNs550_ReceiveBuffer+0x234>
c000bb60:	fdc42783          	lw	a5,-36(s0)
c000bb64:	0127d783          	lhu	a5,18(a5)
c000bb68:	00178793          	addi	a5,a5,1
c000bb6c:	01079713          	slli	a4,a5,0x10
c000bb70:	01075713          	srli	a4,a4,0x10
c000bb74:	fdc42783          	lw	a5,-36(s0)
c000bb78:	00e79923          	sh	a4,18(a5)
	while (ReceivedCount < InstancePtr->ReceiveBuffer.RemainingBytes) {
c000bb7c:	fdc42783          	lw	a5,-36(s0)
c000bb80:	03c7a783          	lw	a5,60(a5)
c000bb84:	fec42703          	lw	a4,-20(s0)
c000bb88:	dcf76ee3          	bltu	a4,a5,c000b964 <XUartNs550_ReceiveBuffer+0x1c>
c000bb8c:	0080006f          	j	c000bb94 <XUartNs550_ReceiveBuffer+0x24c>
		/*
		 * There's no more data buffered, so exit such that this
		 * function does not block waiting for data
		 */
		else {
			break;
c000bb90:	00000013          	nop

	/*
	 * Update the receive buffer to reflect the number of bytes that was
	 * received
	 */
	InstancePtr->ReceiveBuffer.NextBytePtr += ReceivedCount;
c000bb94:	fdc42783          	lw	a5,-36(s0)
c000bb98:	0347a703          	lw	a4,52(a5)
c000bb9c:	fec42783          	lw	a5,-20(s0)
c000bba0:	00f70733          	add	a4,a4,a5
c000bba4:	fdc42783          	lw	a5,-36(s0)
c000bba8:	02e7aa23          	sw	a4,52(a5)
	InstancePtr->ReceiveBuffer.RemainingBytes -= ReceivedCount;
c000bbac:	fdc42783          	lw	a5,-36(s0)
c000bbb0:	03c7a703          	lw	a4,60(a5)
c000bbb4:	fec42783          	lw	a5,-20(s0)
c000bbb8:	40f70733          	sub	a4,a4,a5
c000bbbc:	fdc42783          	lw	a5,-36(s0)
c000bbc0:	02e7ae23          	sw	a4,60(a5)

	/*
	 * Increment associated counters in the statistics
	 */
	InstancePtr->Stats.CharactersReceived += ReceivedCount;
c000bbc4:	fdc42783          	lw	a5,-36(s0)
c000bbc8:	00a7d703          	lhu	a4,10(a5)
c000bbcc:	fec42783          	lw	a5,-20(s0)
c000bbd0:	01079793          	slli	a5,a5,0x10
c000bbd4:	0107d793          	srli	a5,a5,0x10
c000bbd8:	00f707b3          	add	a5,a4,a5
c000bbdc:	01079713          	slli	a4,a5,0x10
c000bbe0:	01075713          	srli	a4,a4,0x10
c000bbe4:	fdc42783          	lw	a5,-36(s0)
c000bbe8:	00e79523          	sh	a4,10(a5)

	return ReceivedCount;
c000bbec:	fec42783          	lw	a5,-20(s0)
}
c000bbf0:	00078513          	mv	a0,a5
c000bbf4:	02c12083          	lw	ra,44(sp)
c000bbf8:	02812403          	lw	s0,40(sp)
c000bbfc:	03010113          	addi	sp,sp,48
c000bc00:	00008067          	ret

c000bc04 <XUartNs550_SetBaudRate>:
*
* @note		None.
*
*****************************************************************************/
int XUartNs550_SetBaudRate(XUartNs550 *InstancePtr, u32 BaudRate)
{
c000bc04:	fc010113          	addi	sp,sp,-64
c000bc08:	02112e23          	sw	ra,60(sp)
c000bc0c:	02812c23          	sw	s0,56(sp)
c000bc10:	04010413          	addi	s0,sp,64
c000bc14:	fca42623          	sw	a0,-52(s0)
c000bc18:	fcb42423          	sw	a1,-56(s0)
	u32 PercentError;

	/*
	 * Assert validates the input arguments
	 */
	Xil_AssertNonvoid(InstancePtr != NULL);
c000bc1c:	fcc42783          	lw	a5,-52(s0)
c000bc20:	02078463          	beqz	a5,c000bc48 <XUartNs550_SetBaudRate+0x44>
c000bc24:	07ff7797          	auipc	a5,0x7ff7
c000bc28:	cf078793          	addi	a5,a5,-784 # c8002914 <Xil_AssertStatus>
c000bc2c:	0007a023          	sw	zero,0(a5)
	Xil_AssertNonvoid(InstancePtr->IsReady == XIL_COMPONENT_IS_READY);
c000bc30:	fcc42783          	lw	a5,-52(s0)
c000bc34:	01c7a703          	lw	a4,28(a5)
c000bc38:	111117b7          	lui	a5,0x11111
c000bc3c:	11178793          	addi	a5,a5,273 # 11111111 <_DMEM_LENGTH+0x10911111>
c000bc40:	08f71663          	bne	a4,a5,c000bccc <XUartNs550_SetBaudRate+0xc8>
c000bc44:	02c0006f          	j	c000bc70 <XUartNs550_SetBaudRate+0x6c>
	Xil_AssertNonvoid(InstancePtr != NULL);
c000bc48:	28500593          	li	a1,645
c000bc4c:	07ff4517          	auipc	a0,0x7ff4
c000bc50:	4f450513          	addi	a0,a0,1268 # c8000140 <__rodata_start+0x140>
c000bc54:	669110ef          	jal	ra,c001dabc <Xil_Assert>
c000bc58:	07ff7797          	auipc	a5,0x7ff7
c000bc5c:	cbc78793          	addi	a5,a5,-836 # c8002914 <Xil_AssertStatus>
c000bc60:	00100713          	li	a4,1
c000bc64:	00e7a023          	sw	a4,0(a5)
c000bc68:	00000793          	li	a5,0
c000bc6c:	1a00006f          	j	c000be0c <XUartNs550_SetBaudRate+0x208>
	Xil_AssertNonvoid(InstancePtr->IsReady == XIL_COMPONENT_IS_READY);
c000bc70:	07ff7797          	auipc	a5,0x7ff7
c000bc74:	ca478793          	addi	a5,a5,-860 # c8002914 <Xil_AssertStatus>
c000bc78:	0007a023          	sw	zero,0(a5)
	/*
	 * Determine what the divisor should be to get the specified baud
	 * rater based upon the input clock frequency and a baud clock prescaler
	 * of 16
	 */
	Divisor = ((InstancePtr->InputClockHz +((BaudRate * 16UL)/2)) /
c000bc7c:	fcc42783          	lw	a5,-52(s0)
c000bc80:	0187a703          	lw	a4,24(a5)
c000bc84:	fc842783          	lw	a5,-56(s0)
c000bc88:	00479793          	slli	a5,a5,0x4
c000bc8c:	0017d793          	srli	a5,a5,0x1
c000bc90:	00f70733          	add	a4,a4,a5
			(BaudRate * 16UL));
c000bc94:	fc842783          	lw	a5,-56(s0)
c000bc98:	00479793          	slli	a5,a5,0x4
	Divisor = ((InstancePtr->InputClockHz +((BaudRate * 16UL)/2)) /
c000bc9c:	02f757b3          	divu	a5,a4,a5
c000bca0:	fef42423          	sw	a5,-24(s0)
	/*
	 * check for too much error between the baud rate that will be generated
	 * using the divisor and the expected baud rate, integer division also
	 * truncates always positive
	 */
	TargetRate = Divisor * BaudRate * 16UL;
c000bca4:	fe842703          	lw	a4,-24(s0)
c000bca8:	fc842783          	lw	a5,-56(s0)
c000bcac:	02f707b3          	mul	a5,a4,a5
c000bcb0:	00479793          	slli	a5,a5,0x4
c000bcb4:	fef42223          	sw	a5,-28(s0)
	if (TargetRate < InstancePtr->InputClockHz) {
c000bcb8:	fcc42783          	lw	a5,-52(s0)
c000bcbc:	0187a783          	lw	a5,24(a5)
c000bcc0:	fe442703          	lw	a4,-28(s0)
c000bcc4:	04f77463          	bgeu	a4,a5,c000bd0c <XUartNs550_SetBaudRate+0x108>
c000bcc8:	02c0006f          	j	c000bcf4 <XUartNs550_SetBaudRate+0xf0>
	Xil_AssertNonvoid(InstancePtr->IsReady == XIL_COMPONENT_IS_READY);
c000bccc:	28600593          	li	a1,646
c000bcd0:	07ff4517          	auipc	a0,0x7ff4
c000bcd4:	47050513          	addi	a0,a0,1136 # c8000140 <__rodata_start+0x140>
c000bcd8:	5e5110ef          	jal	ra,c001dabc <Xil_Assert>
c000bcdc:	07ff7797          	auipc	a5,0x7ff7
c000bce0:	c3878793          	addi	a5,a5,-968 # c8002914 <Xil_AssertStatus>
c000bce4:	00100713          	li	a4,1
c000bce8:	00e7a023          	sw	a4,0(a5)
c000bcec:	00000793          	li	a5,0
c000bcf0:	11c0006f          	j	c000be0c <XUartNs550_SetBaudRate+0x208>
		Error = InstancePtr->InputClockHz - TargetRate;
c000bcf4:	fcc42783          	lw	a5,-52(s0)
c000bcf8:	0187a703          	lw	a4,24(a5)
c000bcfc:	fe442783          	lw	a5,-28(s0)
c000bd00:	40f707b3          	sub	a5,a4,a5
c000bd04:	fef42623          	sw	a5,-20(s0)
c000bd08:	0180006f          	j	c000bd20 <XUartNs550_SetBaudRate+0x11c>
	} else {
		Error = TargetRate - InstancePtr->InputClockHz;
c000bd0c:	fcc42783          	lw	a5,-52(s0)
c000bd10:	0187a783          	lw	a5,24(a5)
c000bd14:	fe442703          	lw	a4,-28(s0)
c000bd18:	40f707b3          	sub	a5,a4,a5
c000bd1c:	fef42623          	sw	a5,-20(s0)
	/*
	 * Error has total error now compute the percentage multiplied by 100 to
	 * avoid floating point calculations, should be less than 3% as per
	 * RS-232 spec
	 */
	PercentError = (Error * 100UL) / InstancePtr->InputClockHz;
c000bd20:	fec42703          	lw	a4,-20(s0)
c000bd24:	06400793          	li	a5,100
c000bd28:	02f70733          	mul	a4,a4,a5
c000bd2c:	fcc42783          	lw	a5,-52(s0)
c000bd30:	0187a783          	lw	a5,24(a5)
c000bd34:	02f757b3          	divu	a5,a4,a5
c000bd38:	fef42023          	sw	a5,-32(s0)
	if (PercentError > XUN_MAX_BAUD_ERROR_RATE) {
c000bd3c:	fe042703          	lw	a4,-32(s0)
c000bd40:	00300793          	li	a5,3
c000bd44:	00e7f663          	bgeu	a5,a4,c000bd50 <XUartNs550_SetBaudRate+0x14c>
		return XST_UART_BAUD_ERROR;
c000bd48:	41f00793          	li	a5,1055
c000bd4c:	0c00006f          	j	c000be0c <XUartNs550_SetBaudRate+0x208>

	/*
	 * Get the least significant and most significant bytes of the divisor
	 * so they can be written to 2 byte registers
	 */
	BaudLSB = Divisor & XUN_DIVISOR_BYTE_MASK;
c000bd50:	fe842783          	lw	a5,-24(s0)
c000bd54:	0ff7f793          	andi	a5,a5,255
c000bd58:	fcf42e23          	sw	a5,-36(s0)
	BaudMSB = (Divisor >> 8) & XUN_DIVISOR_BYTE_MASK;
c000bd5c:	fe842783          	lw	a5,-24(s0)
c000bd60:	0087d793          	srli	a5,a5,0x8
c000bd64:	0ff7f793          	andi	a5,a5,255
c000bd68:	fcf42c23          	sw	a5,-40(s0)

	/*
	 * Save the baud rate in the instance so that the get baud rate function
	 * won't have to calculate it from the divisor
	 */
	InstancePtr->BaudRate = BaudRate;
c000bd6c:	fcc42783          	lw	a5,-52(s0)
c000bd70:	fc842703          	lw	a4,-56(s0)
c000bd74:	02e7a023          	sw	a4,32(a5)

	/*
	 * Get the line control register contents and set the divisor latch
	 * access bit so the baud rate can be set
	 */
	LcrRegister = XUartNs550_GetLineControlReg(InstancePtr->BaseAddress);
c000bd78:	fcc42783          	lw	a5,-52(s0)
c000bd7c:	0147a783          	lw	a5,20(a5)
c000bd80:	00c78793          	addi	a5,a5,12
c000bd84:	00078513          	mv	a0,a5
c000bd88:	d00ff0ef          	jal	ra,c000b288 <Xil_In32>
c000bd8c:	fca42a23          	sw	a0,-44(s0)
	XUartNs550_SetLineControlReg(InstancePtr->BaseAddress ,
c000bd90:	fcc42783          	lw	a5,-52(s0)
c000bd94:	0147a783          	lw	a5,20(a5)
c000bd98:	00c78713          	addi	a4,a5,12
c000bd9c:	fd442783          	lw	a5,-44(s0)
c000bda0:	0807e793          	ori	a5,a5,128
c000bda4:	00078593          	mv	a1,a5
c000bda8:	00070513          	mv	a0,a4
c000bdac:	d04ff0ef          	jal	ra,c000b2b0 <Xil_Out32>
	/*
	 * Set the baud Divisors to set rate, the initial write of 0xFF is
	 * to keep the divisor from being 0 which is not recommended as per
	 * the NS16550D spec sheet
	 */
	XUartNs550_WriteReg(InstancePtr->BaseAddress, XUN_DRLS_OFFSET, 0xFF);
c000bdb0:	fcc42783          	lw	a5,-52(s0)
c000bdb4:	0147a783          	lw	a5,20(a5)
c000bdb8:	0ff00593          	li	a1,255
c000bdbc:	00078513          	mv	a0,a5
c000bdc0:	cf0ff0ef          	jal	ra,c000b2b0 <Xil_Out32>
	XUartNs550_WriteReg(InstancePtr->BaseAddress, XUN_DRLM_OFFSET,
c000bdc4:	fcc42783          	lw	a5,-52(s0)
c000bdc8:	0147a783          	lw	a5,20(a5)
c000bdcc:	00478793          	addi	a5,a5,4
c000bdd0:	fd842583          	lw	a1,-40(s0)
c000bdd4:	00078513          	mv	a0,a5
c000bdd8:	cd8ff0ef          	jal	ra,c000b2b0 <Xil_Out32>
				BaudMSB);
	XUartNs550_WriteReg(InstancePtr->BaseAddress, XUN_DRLS_OFFSET,
c000bddc:	fcc42783          	lw	a5,-52(s0)
c000bde0:	0147a783          	lw	a5,20(a5)
c000bde4:	fdc42583          	lw	a1,-36(s0)
c000bde8:	00078513          	mv	a0,a5
c000bdec:	cc4ff0ef          	jal	ra,c000b2b0 <Xil_Out32>

	/*
	 * Clear the Divisor latch access bit, DLAB to allow nornal
	 * operation and write to the line control register
	 */
	XUartNs550_SetLineControlReg(InstancePtr->BaseAddress, LcrRegister);
c000bdf0:	fcc42783          	lw	a5,-52(s0)
c000bdf4:	0147a783          	lw	a5,20(a5)
c000bdf8:	00c78793          	addi	a5,a5,12
c000bdfc:	fd442583          	lw	a1,-44(s0)
c000be00:	00078513          	mv	a0,a5
c000be04:	cacff0ef          	jal	ra,c000b2b0 <Xil_Out32>

	return XST_SUCCESS;
c000be08:	00000793          	li	a5,0
}
c000be0c:	00078513          	mv	a0,a5
c000be10:	03c12083          	lw	ra,60(sp)
c000be14:	03812403          	lw	s0,56(sp)
c000be18:	04010113          	addi	sp,sp,64
c000be1c:	00008067          	ret

c000be20 <XUartNs550_StubHandler>:
* @note		None.
*
*****************************************************************************/
static void XUartNs550_StubHandler(void *CallBackRef, u32 Event,
					unsigned int ByteCount)
{
c000be20:	fe010113          	addi	sp,sp,-32
c000be24:	00112e23          	sw	ra,28(sp)
c000be28:	00812c23          	sw	s0,24(sp)
c000be2c:	02010413          	addi	s0,sp,32
c000be30:	fea42623          	sw	a0,-20(s0)
c000be34:	feb42423          	sw	a1,-24(s0)
c000be38:	fec42223          	sw	a2,-28(s0)
	(void) ByteCount;

	/*
	 * Assert occurs always since this is a stub and should never be called
	 */
	Xil_AssertVoidAlways();
c000be3c:	2ea00593          	li	a1,746
c000be40:	07ff4517          	auipc	a0,0x7ff4
c000be44:	30050513          	addi	a0,a0,768 # c8000140 <__rodata_start+0x140>
c000be48:	475110ef          	jal	ra,c001dabc <Xil_Assert>
c000be4c:	07ff7797          	auipc	a5,0x7ff7
c000be50:	ac878793          	addi	a5,a5,-1336 # c8002914 <Xil_AssertStatus>
c000be54:	00100713          	li	a4,1
c000be58:	00e7a023          	sw	a4,0(a5)
c000be5c:	00000013          	nop
}
c000be60:	01c12083          	lw	ra,28(sp)
c000be64:	01812403          	lw	s0,24(sp)
c000be68:	02010113          	addi	sp,sp,32
c000be6c:	00008067          	ret

c000be70 <XUartNs550_LookupConfig>:
*
* @note		None.
*
******************************************************************************/
XUartNs550_Config *XUartNs550_LookupConfig(u16 DeviceId)
{
c000be70:	fd010113          	addi	sp,sp,-48
c000be74:	02812623          	sw	s0,44(sp)
c000be78:	03010413          	addi	s0,sp,48
c000be7c:	00050793          	mv	a5,a0
c000be80:	fcf41f23          	sh	a5,-34(s0)
	XUartNs550_Config *CfgPtr = NULL;
c000be84:	fe042623          	sw	zero,-20(s0)
	u32 Index;

	for (Index=0; Index < XPAR_XUARTNS550_NUM_INSTANCES; Index++) {
c000be88:	fe042423          	sw	zero,-24(s0)
c000be8c:	04c0006f          	j	c000bed8 <XUartNs550_LookupConfig+0x68>
		if (XUartNs550_ConfigTable[Index].DeviceId == DeviceId) {
c000be90:	07ff7717          	auipc	a4,0x7ff7
c000be94:	b0870713          	addi	a4,a4,-1272 # c8002998 <XUartNs550_ConfigTable>
c000be98:	fe842783          	lw	a5,-24(s0)
c000be9c:	00479793          	slli	a5,a5,0x4
c000bea0:	00f707b3          	add	a5,a4,a5
c000bea4:	0007d783          	lhu	a5,0(a5)
c000bea8:	fde45703          	lhu	a4,-34(s0)
c000beac:	02f71063          	bne	a4,a5,c000becc <XUartNs550_LookupConfig+0x5c>
			CfgPtr = &XUartNs550_ConfigTable[Index];
c000beb0:	fe842783          	lw	a5,-24(s0)
c000beb4:	00479713          	slli	a4,a5,0x4
c000beb8:	07ff7797          	auipc	a5,0x7ff7
c000bebc:	ae078793          	addi	a5,a5,-1312 # c8002998 <XUartNs550_ConfigTable>
c000bec0:	00f707b3          	add	a5,a4,a5
c000bec4:	fef42623          	sw	a5,-20(s0)
			break;
c000bec8:	01c0006f          	j	c000bee4 <XUartNs550_LookupConfig+0x74>
	for (Index=0; Index < XPAR_XUARTNS550_NUM_INSTANCES; Index++) {
c000becc:	fe842783          	lw	a5,-24(s0)
c000bed0:	00178793          	addi	a5,a5,1
c000bed4:	fef42423          	sw	a5,-24(s0)
c000bed8:	fe842703          	lw	a4,-24(s0)
c000bedc:	00100793          	li	a5,1
c000bee0:	fae7f8e3          	bgeu	a5,a4,c000be90 <XUartNs550_LookupConfig+0x20>
		}
	}

	return CfgPtr;
c000bee4:	fec42783          	lw	a5,-20(s0)
}
c000bee8:	00078513          	mv	a0,a5
c000beec:	02c12403          	lw	s0,44(sp)
c000bef0:	03010113          	addi	sp,sp,48
c000bef4:	00008067          	ret

c000bef8 <XUartNs550_Initialize>:
*
* @note		None.
*
*****************************************************************************/
int XUartNs550_Initialize(XUartNs550 *InstancePtr, u16 DeviceId)
{
c000bef8:	fd010113          	addi	sp,sp,-48
c000befc:	02112623          	sw	ra,44(sp)
c000bf00:	02812423          	sw	s0,40(sp)
c000bf04:	03010413          	addi	s0,sp,48
c000bf08:	fca42e23          	sw	a0,-36(s0)
c000bf0c:	00058793          	mv	a5,a1
c000bf10:	fcf41d23          	sh	a5,-38(s0)
	XUartNs550_Config *ConfigPtr;

	/*
	 * Assert validates the input arguments
	 */
	Xil_AssertNonvoid(InstancePtr != NULL);
c000bf14:	fdc42783          	lw	a5,-36(s0)
c000bf18:	02078663          	beqz	a5,c000bf44 <XUartNs550_Initialize+0x4c>
c000bf1c:	07ff7797          	auipc	a5,0x7ff7
c000bf20:	9f878793          	addi	a5,a5,-1544 # c8002914 <Xil_AssertStatus>
c000bf24:	0007a023          	sw	zero,0(a5)

	/*
	 * Lookup the device configuration in the temporary CROM table. Use this
	 * configuration info down below when initializing this component
	 */
	ConfigPtr = XUartNs550_LookupConfig(DeviceId);
c000bf28:	fda45783          	lhu	a5,-38(s0)
c000bf2c:	00078513          	mv	a0,a5
c000bf30:	f41ff0ef          	jal	ra,c000be70 <XUartNs550_LookupConfig>
c000bf34:	fea42623          	sw	a0,-20(s0)
	if (ConfigPtr == (XUartNs550_Config *)NULL) {
c000bf38:	fec42783          	lw	a5,-20(s0)
c000bf3c:	02079c63          	bnez	a5,c000bf74 <XUartNs550_Initialize+0x7c>
c000bf40:	02c0006f          	j	c000bf6c <XUartNs550_Initialize+0x74>
	Xil_AssertNonvoid(InstancePtr != NULL);
c000bf44:	08900593          	li	a1,137
c000bf48:	07ff4517          	auipc	a0,0x7ff4
c000bf4c:	21c50513          	addi	a0,a0,540 # c8000164 <__rodata_start+0x164>
c000bf50:	36d110ef          	jal	ra,c001dabc <Xil_Assert>
c000bf54:	07ff7797          	auipc	a5,0x7ff7
c000bf58:	9c078793          	addi	a5,a5,-1600 # c8002914 <Xil_AssertStatus>
c000bf5c:	00100713          	li	a4,1
c000bf60:	00e7a023          	sw	a4,0(a5)
c000bf64:	00000793          	li	a5,0
c000bf68:	0280006f          	j	c000bf90 <XUartNs550_Initialize+0x98>
		return XST_DEVICE_NOT_FOUND;
c000bf6c:	00200793          	li	a5,2
c000bf70:	0200006f          	j	c000bf90 <XUartNs550_Initialize+0x98>
	}

	return XUartNs550_CfgInitialize(InstancePtr, ConfigPtr,
c000bf74:	fec42783          	lw	a5,-20(s0)
c000bf78:	0047a783          	lw	a5,4(a5)
c000bf7c:	00078613          	mv	a2,a5
c000bf80:	fec42583          	lw	a1,-20(s0)
c000bf84:	fdc42503          	lw	a0,-36(s0)
c000bf88:	b60ff0ef          	jal	ra,c000b2e8 <XUartNs550_CfgInitialize>
c000bf8c:	00050793          	mv	a5,a0
					ConfigPtr->BaseAddress);
}
c000bf90:	00078513          	mv	a0,a5
c000bf94:	02c12083          	lw	ra,44(sp)
c000bf98:	02812403          	lw	s0,40(sp)
c000bf9c:	03010113          	addi	sp,sp,48
c000bfa0:	00008067          	ret

c000bfa4 <Xil_In32>:
{
c000bfa4:	fe010113          	addi	sp,sp,-32
c000bfa8:	00812e23          	sw	s0,28(sp)
c000bfac:	02010413          	addi	s0,sp,32
c000bfb0:	fea42623          	sw	a0,-20(s0)
	return *(volatile u32 *) Addr;
c000bfb4:	fec42783          	lw	a5,-20(s0)
c000bfb8:	0007a783          	lw	a5,0(a5)
}
c000bfbc:	00078513          	mv	a0,a5
c000bfc0:	01c12403          	lw	s0,28(sp)
c000bfc4:	02010113          	addi	sp,sp,32
c000bfc8:	00008067          	ret

c000bfcc <Xil_Out32>:
{
c000bfcc:	fd010113          	addi	sp,sp,-48
c000bfd0:	02812623          	sw	s0,44(sp)
c000bfd4:	03010413          	addi	s0,sp,48
c000bfd8:	fca42e23          	sw	a0,-36(s0)
c000bfdc:	fcb42c23          	sw	a1,-40(s0)
	volatile u32 *LocalAddr = (volatile u32 *)Addr;
c000bfe0:	fdc42783          	lw	a5,-36(s0)
c000bfe4:	fef42623          	sw	a5,-20(s0)
	*LocalAddr = Value;
c000bfe8:	fec42783          	lw	a5,-20(s0)
c000bfec:	fd842703          	lw	a4,-40(s0)
c000bff0:	00e7a023          	sw	a4,0(a5)
}
c000bff4:	00000013          	nop
c000bff8:	02c12403          	lw	s0,44(sp)
c000bffc:	03010113          	addi	sp,sp,48
c000c000:	00008067          	ret

c000c004 <XUartNs550_SelfTest>:
* @note 	This function can hang if the hardware is not functioning
*		properly.
*
******************************************************************************/
int XUartNs550_SelfTest(XUartNs550 *InstancePtr)
{
c000c004:	fc010113          	addi	sp,sp,-64
c000c008:	02112e23          	sw	ra,60(sp)
c000c00c:	02812c23          	sw	s0,56(sp)
c000c010:	04010413          	addi	s0,sp,64
c000c014:	fca42623          	sw	a0,-52(s0)
	int Status = XST_SUCCESS;
c000c018:	fe042623          	sw	zero,-20(s0)
	u32 Index;

	/*
	 * Assert validates the input arguments
	 */
	Xil_AssertNonvoid(InstancePtr != NULL);
c000c01c:	fcc42783          	lw	a5,-52(s0)
c000c020:	02078463          	beqz	a5,c000c048 <XUartNs550_SelfTest+0x44>
c000c024:	07ff7797          	auipc	a5,0x7ff7
c000c028:	8f078793          	addi	a5,a5,-1808 # c8002914 <Xil_AssertStatus>
c000c02c:	0007a023          	sw	zero,0(a5)
	Xil_AssertNonvoid(InstancePtr->IsReady == XIL_COMPONENT_IS_READY);
c000c030:	fcc42783          	lw	a5,-52(s0)
c000c034:	01c7a703          	lw	a4,28(a5)
c000c038:	111117b7          	lui	a5,0x11111
c000c03c:	11178793          	addi	a5,a5,273 # 11111111 <_DMEM_LENGTH+0x10911111>
c000c040:	0af71663          	bne	a4,a5,c000c0ec <XUartNs550_SelfTest+0xe8>
c000c044:	02c0006f          	j	c000c070 <XUartNs550_SelfTest+0x6c>
	Xil_AssertNonvoid(InstancePtr != NULL);
c000c048:	07100593          	li	a1,113
c000c04c:	07ff4517          	auipc	a0,0x7ff4
c000c050:	14050513          	addi	a0,a0,320 # c800018c <__rodata_start+0x18c>
c000c054:	269110ef          	jal	ra,c001dabc <Xil_Assert>
c000c058:	07ff7797          	auipc	a5,0x7ff7
c000c05c:	8bc78793          	addi	a5,a5,-1860 # c8002914 <Xil_AssertStatus>
c000c060:	00100713          	li	a4,1
c000c064:	00e7a023          	sw	a4,0(a5)
c000c068:	00000793          	li	a5,0
c000c06c:	1b40006f          	j	c000c220 <XUartNs550_SelfTest+0x21c>
	Xil_AssertNonvoid(InstancePtr->IsReady == XIL_COMPONENT_IS_READY);
c000c070:	07ff7797          	auipc	a5,0x7ff7
c000c074:	8a478793          	addi	a5,a5,-1884 # c8002914 <Xil_AssertStatus>
c000c078:	0007a023          	sw	zero,0(a5)

	/*
	 * Setup for polling by disabling all interrupts in the interrupt enable
	 * register
	 */
	IerRegister = XUartNs550_ReadReg(InstancePtr->BaseAddress,
c000c07c:	fcc42783          	lw	a5,-52(s0)
c000c080:	0147a783          	lw	a5,20(a5)
c000c084:	00478793          	addi	a5,a5,4
c000c088:	00078513          	mv	a0,a5
c000c08c:	f19ff0ef          	jal	ra,c000bfa4 <Xil_In32>
c000c090:	fea42223          	sw	a0,-28(s0)
						XUN_IER_OFFSET);
	XUartNs550_WriteReg(InstancePtr->BaseAddress, XUN_IER_OFFSET, 0);
c000c094:	fcc42783          	lw	a5,-52(s0)
c000c098:	0147a783          	lw	a5,20(a5)
c000c09c:	00478793          	addi	a5,a5,4
c000c0a0:	00000593          	li	a1,0
c000c0a4:	00078513          	mv	a0,a5
c000c0a8:	f25ff0ef          	jal	ra,c000bfcc <Xil_Out32>

	/*
	 * Setup for loopback by enabling the loopback in the modem control
	 * register
	 */
	McrRegister = XUartNs550_ReadReg(InstancePtr->BaseAddress,
c000c0ac:	fcc42783          	lw	a5,-52(s0)
c000c0b0:	0147a783          	lw	a5,20(a5)
c000c0b4:	01078793          	addi	a5,a5,16
c000c0b8:	00078513          	mv	a0,a5
c000c0bc:	ee9ff0ef          	jal	ra,c000bfa4 <Xil_In32>
c000c0c0:	fea42023          	sw	a0,-32(s0)
						XUN_MCR_OFFSET);
	XUartNs550_WriteReg(InstancePtr->BaseAddress, XUN_MCR_OFFSET,
c000c0c4:	fcc42783          	lw	a5,-52(s0)
c000c0c8:	0147a783          	lw	a5,20(a5)
c000c0cc:	01078713          	addi	a4,a5,16
c000c0d0:	fe042783          	lw	a5,-32(s0)
c000c0d4:	0107e793          	ori	a5,a5,16
c000c0d8:	00078593          	mv	a1,a5
c000c0dc:	00070513          	mv	a0,a4
c000c0e0:	eedff0ef          	jal	ra,c000bfcc <Xil_Out32>

	/*
	 * Send a number of bytes and receive them, one at a time so this
	 * test will work for 450 and 550
	 */
	for (Index = 0; Index < XUN_TOTAL_BYTES; Index++) {
c000c0e4:	fe042423          	sw	zero,-24(s0)
c000c0e8:	09c0006f          	j	c000c184 <XUartNs550_SelfTest+0x180>
	Xil_AssertNonvoid(InstancePtr->IsReady == XIL_COMPONENT_IS_READY);
c000c0ec:	07200593          	li	a1,114
c000c0f0:	07ff4517          	auipc	a0,0x7ff4
c000c0f4:	09c50513          	addi	a0,a0,156 # c800018c <__rodata_start+0x18c>
c000c0f8:	1c5110ef          	jal	ra,c001dabc <Xil_Assert>
c000c0fc:	07ff7797          	auipc	a5,0x7ff7
c000c100:	81878793          	addi	a5,a5,-2024 # c8002914 <Xil_AssertStatus>
c000c104:	00100713          	li	a4,1
c000c108:	00e7a023          	sw	a4,0(a5)
c000c10c:	00000793          	li	a5,0
c000c110:	1100006f          	j	c000c220 <XUartNs550_SelfTest+0x21c>
		/*
		 * Send out the byte and if it was not sent then the failure
		 * will be caught in the compare at the end
		 */
		XUartNs550_Send(InstancePtr, &TestString[Index], 1);
c000c114:	fe842703          	lw	a4,-24(s0)
c000c118:	07ff7797          	auipc	a5,0x7ff7
c000c11c:	8a078793          	addi	a5,a5,-1888 # c80029b8 <TestString>
c000c120:	00f707b3          	add	a5,a4,a5
c000c124:	00100613          	li	a2,1
c000c128:	00078593          	mv	a1,a5
c000c12c:	fcc42503          	lw	a0,-52(s0)
c000c130:	b00ff0ef          	jal	ra,c000b430 <XUartNs550_Send>
		 * Wait til the byte is received such that it should be waiting
		 * in the receiver. This can hang if the HW is broken
		 */
		do {
			LsrRegister =
			XUartNs550_GetLineStatusReg(InstancePtr->BaseAddress);
c000c134:	fcc42783          	lw	a5,-52(s0)
c000c138:	0147a783          	lw	a5,20(a5)
c000c13c:	01478793          	addi	a5,a5,20
c000c140:	00078513          	mv	a0,a5
c000c144:	e61ff0ef          	jal	ra,c000bfa4 <Xil_In32>
c000c148:	fca42e23          	sw	a0,-36(s0)
		}
		while ((LsrRegister & XUN_LSR_DATA_READY) == 0);
c000c14c:	fdc42783          	lw	a5,-36(s0)
c000c150:	0017f793          	andi	a5,a5,1
c000c154:	fe0780e3          	beqz	a5,c000c134 <XUartNs550_SelfTest+0x130>
		/*
		 * Receive the byte that should have been received because of
		 * the loopback, if it wasn't received then it will be caught
		 * in the compare at the end
		 */
		XUartNs550_Recv(InstancePtr, &ReturnString[Index], 1);
c000c158:	fe842703          	lw	a4,-24(s0)
c000c15c:	08037797          	auipc	a5,0x8037
c000c160:	6a878793          	addi	a5,a5,1704 # c8043804 <ReturnString>
c000c164:	00f707b3          	add	a5,a4,a5
c000c168:	00100613          	li	a2,1
c000c16c:	00078593          	mv	a1,a5
c000c170:	fcc42503          	lw	a0,-52(s0)
c000c174:	c60ff0ef          	jal	ra,c000b5d4 <XUartNs550_Recv>
	for (Index = 0; Index < XUN_TOTAL_BYTES; Index++) {
c000c178:	fe842783          	lw	a5,-24(s0)
c000c17c:	00178793          	addi	a5,a5,1
c000c180:	fef42423          	sw	a5,-24(s0)
c000c184:	fe842703          	lw	a4,-24(s0)
c000c188:	01f00793          	li	a5,31
c000c18c:	f8e7f4e3          	bgeu	a5,a4,c000c114 <XUartNs550_SelfTest+0x110>
	}

	/*
	 * Clear the stats since they are corrupted by the test
	 */
	XUartNs550_ClearStats(InstancePtr);
c000c190:	fcc42503          	lw	a0,-52(s0)
c000c194:	228000ef          	jal	ra,c000c3bc <XUartNs550_ClearStats>

	/*
	 * Compare the bytes received to the bytes sent to verify the exact data
	 * was received
	 */
	for (Index = 0; Index < XUN_TOTAL_BYTES; Index++) {
c000c198:	fe042423          	sw	zero,-24(s0)
c000c19c:	0440006f          	j	c000c1e0 <XUartNs550_SelfTest+0x1dc>
		if (TestString[Index] != ReturnString[Index]) {
c000c1a0:	07ff7717          	auipc	a4,0x7ff7
c000c1a4:	81870713          	addi	a4,a4,-2024 # c80029b8 <TestString>
c000c1a8:	fe842783          	lw	a5,-24(s0)
c000c1ac:	00f707b3          	add	a5,a4,a5
c000c1b0:	0007c703          	lbu	a4,0(a5)
c000c1b4:	08037697          	auipc	a3,0x8037
c000c1b8:	65068693          	addi	a3,a3,1616 # c8043804 <ReturnString>
c000c1bc:	fe842783          	lw	a5,-24(s0)
c000c1c0:	00f687b3          	add	a5,a3,a5
c000c1c4:	0007c783          	lbu	a5,0(a5)
c000c1c8:	00f70663          	beq	a4,a5,c000c1d4 <XUartNs550_SelfTest+0x1d0>
			Status = XST_UART_TEST_FAIL;
c000c1cc:	41e00793          	li	a5,1054
c000c1d0:	fef42623          	sw	a5,-20(s0)
	for (Index = 0; Index < XUN_TOTAL_BYTES; Index++) {
c000c1d4:	fe842783          	lw	a5,-24(s0)
c000c1d8:	00178793          	addi	a5,a5,1
c000c1dc:	fef42423          	sw	a5,-24(s0)
c000c1e0:	fe842703          	lw	a4,-24(s0)
c000c1e4:	01f00793          	li	a5,31
c000c1e8:	fae7fce3          	bgeu	a5,a4,c000c1a0 <XUartNs550_SelfTest+0x19c>

	/*
	 * Restore the registers which were altered to put into polling and
	 * loopback modes so that this test is not destructive
	 */
	XUartNs550_WriteReg(InstancePtr->BaseAddress, XUN_IER_OFFSET,
c000c1ec:	fcc42783          	lw	a5,-52(s0)
c000c1f0:	0147a783          	lw	a5,20(a5)
c000c1f4:	00478793          	addi	a5,a5,4
c000c1f8:	fe442583          	lw	a1,-28(s0)
c000c1fc:	00078513          	mv	a0,a5
c000c200:	dcdff0ef          	jal	ra,c000bfcc <Xil_Out32>
				IerRegister);
	XUartNs550_WriteReg(InstancePtr->BaseAddress, XUN_MCR_OFFSET,
c000c204:	fcc42783          	lw	a5,-52(s0)
c000c208:	0147a783          	lw	a5,20(a5)
c000c20c:	01078793          	addi	a5,a5,16
c000c210:	fe042583          	lw	a1,-32(s0)
c000c214:	00078513          	mv	a0,a5
c000c218:	db5ff0ef          	jal	ra,c000bfcc <Xil_Out32>
				McrRegister);

	return Status;
c000c21c:	fec42783          	lw	a5,-20(s0)
}
c000c220:	00078513          	mv	a0,a5
c000c224:	03c12083          	lw	ra,60(sp)
c000c228:	03812403          	lw	s0,56(sp)
c000c22c:	04010113          	addi	sp,sp,64
c000c230:	00008067          	ret

c000c234 <XUartNs550_GetStats>:
*
* @note		None.
*
*****************************************************************************/
void XUartNs550_GetStats(XUartNs550 *InstancePtr, XUartNs550Stats *StatsPtr)
{
c000c234:	fe010113          	addi	sp,sp,-32
c000c238:	00112e23          	sw	ra,28(sp)
c000c23c:	00812c23          	sw	s0,24(sp)
c000c240:	02010413          	addi	s0,sp,32
c000c244:	fea42623          	sw	a0,-20(s0)
c000c248:	feb42423          	sw	a1,-24(s0)
	/*
	 * Assert validates the input arguments
	 */
	Xil_AssertVoid(InstancePtr != NULL);
c000c24c:	fec42783          	lw	a5,-20(s0)
c000c250:	00078e63          	beqz	a5,c000c26c <XUartNs550_GetStats+0x38>
c000c254:	07ff6797          	auipc	a5,0x7ff6
c000c258:	6c078793          	addi	a5,a5,1728 # c8002914 <Xil_AssertStatus>
c000c25c:	0007a023          	sw	zero,0(a5)
	Xil_AssertVoid(StatsPtr != NULL);
c000c260:	fe842783          	lw	a5,-24(s0)
c000c264:	04078863          	beqz	a5,c000c2b4 <XUartNs550_GetStats+0x80>
c000c268:	0280006f          	j	c000c290 <XUartNs550_GetStats+0x5c>
	Xil_AssertVoid(InstancePtr != NULL);
c000c26c:	05800593          	li	a1,88
c000c270:	07ff4517          	auipc	a0,0x7ff4
c000c274:	f4850513          	addi	a0,a0,-184 # c80001b8 <__rodata_start+0x1b8>
c000c278:	045110ef          	jal	ra,c001dabc <Xil_Assert>
c000c27c:	07ff6797          	auipc	a5,0x7ff6
c000c280:	69878793          	addi	a5,a5,1688 # c8002914 <Xil_AssertStatus>
c000c284:	00100713          	li	a4,1
c000c288:	00e7a023          	sw	a4,0(a5)
c000c28c:	1200006f          	j	c000c3ac <XUartNs550_GetStats+0x178>
	Xil_AssertVoid(StatsPtr != NULL);
c000c290:	07ff6797          	auipc	a5,0x7ff6
c000c294:	68478793          	addi	a5,a5,1668 # c8002914 <Xil_AssertStatus>
c000c298:	0007a023          	sw	zero,0(a5)
	Xil_AssertVoid(InstancePtr->IsReady == XIL_COMPONENT_IS_READY);
c000c29c:	fec42783          	lw	a5,-20(s0)
c000c2a0:	01c7a703          	lw	a4,28(a5)
c000c2a4:	111117b7          	lui	a5,0x11111
c000c2a8:	11178793          	addi	a5,a5,273 # 11111111 <_DMEM_LENGTH+0x10911111>
c000c2ac:	0cf71e63          	bne	a4,a5,c000c388 <XUartNs550_GetStats+0x154>
c000c2b0:	0280006f          	j	c000c2d8 <XUartNs550_GetStats+0xa4>
	Xil_AssertVoid(StatsPtr != NULL);
c000c2b4:	05900593          	li	a1,89
c000c2b8:	07ff4517          	auipc	a0,0x7ff4
c000c2bc:	f0050513          	addi	a0,a0,-256 # c80001b8 <__rodata_start+0x1b8>
c000c2c0:	7fc110ef          	jal	ra,c001dabc <Xil_Assert>
c000c2c4:	07ff6797          	auipc	a5,0x7ff6
c000c2c8:	65078793          	addi	a5,a5,1616 # c8002914 <Xil_AssertStatus>
c000c2cc:	00100713          	li	a4,1
c000c2d0:	00e7a023          	sw	a4,0(a5)
c000c2d4:	0d80006f          	j	c000c3ac <XUartNs550_GetStats+0x178>
	Xil_AssertVoid(InstancePtr->IsReady == XIL_COMPONENT_IS_READY);
c000c2d8:	07ff6797          	auipc	a5,0x7ff6
c000c2dc:	63c78793          	addi	a5,a5,1596 # c8002914 <Xil_AssertStatus>
c000c2e0:	0007a023          	sw	zero,0(a5)

	StatsPtr->TransmitInterrupts = InstancePtr->Stats.TransmitInterrupts;
c000c2e4:	fec42783          	lw	a5,-20(s0)
c000c2e8:	0007d703          	lhu	a4,0(a5)
c000c2ec:	fe842783          	lw	a5,-24(s0)
c000c2f0:	00e79023          	sh	a4,0(a5)
	StatsPtr->ReceiveInterrupts = InstancePtr->Stats.ReceiveInterrupts;
c000c2f4:	fec42783          	lw	a5,-20(s0)
c000c2f8:	0027d703          	lhu	a4,2(a5)
c000c2fc:	fe842783          	lw	a5,-24(s0)
c000c300:	00e79123          	sh	a4,2(a5)
	StatsPtr->StatusInterrupts = InstancePtr->Stats.StatusInterrupts;
c000c304:	fec42783          	lw	a5,-20(s0)
c000c308:	0047d703          	lhu	a4,4(a5)
c000c30c:	fe842783          	lw	a5,-24(s0)
c000c310:	00e79223          	sh	a4,4(a5)
	StatsPtr->ModemInterrupts = InstancePtr->Stats.ModemInterrupts;
c000c314:	fec42783          	lw	a5,-20(s0)
c000c318:	0067d703          	lhu	a4,6(a5)
c000c31c:	fe842783          	lw	a5,-24(s0)
c000c320:	00e79323          	sh	a4,6(a5)
	StatsPtr->CharactersTransmitted =
				InstancePtr->Stats.CharactersTransmitted;
c000c324:	fec42783          	lw	a5,-20(s0)
c000c328:	0087d703          	lhu	a4,8(a5)
	StatsPtr->CharactersTransmitted =
c000c32c:	fe842783          	lw	a5,-24(s0)
c000c330:	00e79423          	sh	a4,8(a5)
	StatsPtr->CharactersReceived = InstancePtr->Stats.CharactersReceived;
c000c334:	fec42783          	lw	a5,-20(s0)
c000c338:	00a7d703          	lhu	a4,10(a5)
c000c33c:	fe842783          	lw	a5,-24(s0)
c000c340:	00e79523          	sh	a4,10(a5)
	StatsPtr->ReceiveOverrunErrors =
				InstancePtr->Stats.ReceiveOverrunErrors;
c000c344:	fec42783          	lw	a5,-20(s0)
c000c348:	00c7d703          	lhu	a4,12(a5)
	StatsPtr->ReceiveOverrunErrors =
c000c34c:	fe842783          	lw	a5,-24(s0)
c000c350:	00e79623          	sh	a4,12(a5)
	StatsPtr->ReceiveFramingErrors =
				InstancePtr->Stats.ReceiveFramingErrors;
c000c354:	fec42783          	lw	a5,-20(s0)
c000c358:	0107d703          	lhu	a4,16(a5)
	StatsPtr->ReceiveFramingErrors =
c000c35c:	fe842783          	lw	a5,-24(s0)
c000c360:	00e79823          	sh	a4,16(a5)
	StatsPtr->ReceiveParityErrors = InstancePtr->Stats.ReceiveParityErrors;
c000c364:	fec42783          	lw	a5,-20(s0)
c000c368:	00e7d703          	lhu	a4,14(a5)
c000c36c:	fe842783          	lw	a5,-24(s0)
c000c370:	00e79723          	sh	a4,14(a5)
	StatsPtr->ReceiveBreakDetected =
				InstancePtr->Stats.ReceiveBreakDetected;
c000c374:	fec42783          	lw	a5,-20(s0)
c000c378:	0127d703          	lhu	a4,18(a5)
	StatsPtr->ReceiveBreakDetected =
c000c37c:	fe842783          	lw	a5,-24(s0)
c000c380:	00e79923          	sh	a4,18(a5)
c000c384:	0280006f          	j	c000c3ac <XUartNs550_GetStats+0x178>
	Xil_AssertVoid(InstancePtr->IsReady == XIL_COMPONENT_IS_READY);
c000c388:	05a00593          	li	a1,90
c000c38c:	07ff4517          	auipc	a0,0x7ff4
c000c390:	e2c50513          	addi	a0,a0,-468 # c80001b8 <__rodata_start+0x1b8>
c000c394:	728110ef          	jal	ra,c001dabc <Xil_Assert>
c000c398:	07ff6797          	auipc	a5,0x7ff6
c000c39c:	57c78793          	addi	a5,a5,1404 # c8002914 <Xil_AssertStatus>
c000c3a0:	00100713          	li	a4,1
c000c3a4:	00e7a023          	sw	a4,0(a5)
c000c3a8:	00000013          	nop
}
c000c3ac:	01c12083          	lw	ra,28(sp)
c000c3b0:	01812403          	lw	s0,24(sp)
c000c3b4:	02010113          	addi	sp,sp,32
c000c3b8:	00008067          	ret

c000c3bc <XUartNs550_ClearStats>:
*
* @note		None.
*
*****************************************************************************/
void XUartNs550_ClearStats(XUartNs550 *InstancePtr)
{
c000c3bc:	fe010113          	addi	sp,sp,-32
c000c3c0:	00112e23          	sw	ra,28(sp)
c000c3c4:	00812c23          	sw	s0,24(sp)
c000c3c8:	02010413          	addi	s0,sp,32
c000c3cc:	fea42623          	sw	a0,-20(s0)
	/*
	 * Assert validates the input arguments
	 */
	Xil_AssertVoid(InstancePtr != NULL);
c000c3d0:	fec42783          	lw	a5,-20(s0)
c000c3d4:	02078463          	beqz	a5,c000c3fc <XUartNs550_ClearStats+0x40>
c000c3d8:	07ff6797          	auipc	a5,0x7ff6
c000c3dc:	53c78793          	addi	a5,a5,1340 # c8002914 <Xil_AssertStatus>
c000c3e0:	0007a023          	sw	zero,0(a5)
	Xil_AssertVoid(InstancePtr->IsReady == XIL_COMPONENT_IS_READY);
c000c3e4:	fec42783          	lw	a5,-20(s0)
c000c3e8:	01c7a703          	lw	a4,28(a5)
c000c3ec:	111117b7          	lui	a5,0x11111
c000c3f0:	11178793          	addi	a5,a5,273 # 11111111 <_DMEM_LENGTH+0x10911111>
c000c3f4:	08f71663          	bne	a4,a5,c000c480 <XUartNs550_ClearStats+0xc4>
c000c3f8:	0280006f          	j	c000c420 <XUartNs550_ClearStats+0x64>
	Xil_AssertVoid(InstancePtr != NULL);
c000c3fc:	07d00593          	li	a1,125
c000c400:	07ff4517          	auipc	a0,0x7ff4
c000c404:	db850513          	addi	a0,a0,-584 # c80001b8 <__rodata_start+0x1b8>
c000c408:	6b4110ef          	jal	ra,c001dabc <Xil_Assert>
c000c40c:	07ff6797          	auipc	a5,0x7ff6
c000c410:	50878793          	addi	a5,a5,1288 # c8002914 <Xil_AssertStatus>
c000c414:	00100713          	li	a4,1
c000c418:	00e7a023          	sw	a4,0(a5)
c000c41c:	0880006f          	j	c000c4a4 <XUartNs550_ClearStats+0xe8>
	Xil_AssertVoid(InstancePtr->IsReady == XIL_COMPONENT_IS_READY);
c000c420:	07ff6797          	auipc	a5,0x7ff6
c000c424:	4f478793          	addi	a5,a5,1268 # c8002914 <Xil_AssertStatus>
c000c428:	0007a023          	sw	zero,0(a5)

	InstancePtr->Stats.TransmitInterrupts = 0;
c000c42c:	fec42783          	lw	a5,-20(s0)
c000c430:	00079023          	sh	zero,0(a5)
	InstancePtr->Stats.ReceiveInterrupts = 0;
c000c434:	fec42783          	lw	a5,-20(s0)
c000c438:	00079123          	sh	zero,2(a5)
	InstancePtr->Stats.StatusInterrupts = 0;
c000c43c:	fec42783          	lw	a5,-20(s0)
c000c440:	00079223          	sh	zero,4(a5)
	InstancePtr->Stats.ModemInterrupts = 0;
c000c444:	fec42783          	lw	a5,-20(s0)
c000c448:	00079323          	sh	zero,6(a5)
	InstancePtr->Stats.CharactersTransmitted = 0;
c000c44c:	fec42783          	lw	a5,-20(s0)
c000c450:	00079423          	sh	zero,8(a5)
	InstancePtr->Stats.CharactersReceived = 0;
c000c454:	fec42783          	lw	a5,-20(s0)
c000c458:	00079523          	sh	zero,10(a5)
	InstancePtr->Stats.ReceiveOverrunErrors = 0;
c000c45c:	fec42783          	lw	a5,-20(s0)
c000c460:	00079623          	sh	zero,12(a5)
	InstancePtr->Stats.ReceiveFramingErrors = 0;
c000c464:	fec42783          	lw	a5,-20(s0)
c000c468:	00079823          	sh	zero,16(a5)
	InstancePtr->Stats.ReceiveParityErrors = 0;
c000c46c:	fec42783          	lw	a5,-20(s0)
c000c470:	00079723          	sh	zero,14(a5)
	InstancePtr->Stats.ReceiveBreakDetected = 0;
c000c474:	fec42783          	lw	a5,-20(s0)
c000c478:	00079923          	sh	zero,18(a5)
c000c47c:	0280006f          	j	c000c4a4 <XUartNs550_ClearStats+0xe8>
	Xil_AssertVoid(InstancePtr->IsReady == XIL_COMPONENT_IS_READY);
c000c480:	07e00593          	li	a1,126
c000c484:	07ff4517          	auipc	a0,0x7ff4
c000c488:	d3450513          	addi	a0,a0,-716 # c80001b8 <__rodata_start+0x1b8>
c000c48c:	630110ef          	jal	ra,c001dabc <Xil_Assert>
c000c490:	07ff6797          	auipc	a5,0x7ff6
c000c494:	48478793          	addi	a5,a5,1156 # c8002914 <Xil_AssertStatus>
c000c498:	00100713          	li	a4,1
c000c49c:	00e7a023          	sw	a4,0(a5)
c000c4a0:	00000013          	nop
}
c000c4a4:	01c12083          	lw	ra,28(sp)
c000c4a8:	01812403          	lw	s0,24(sp)
c000c4ac:	02010113          	addi	sp,sp,32
c000c4b0:	00008067          	ret

c000c4b4 <Xil_In32>:
{
c000c4b4:	fe010113          	addi	sp,sp,-32
c000c4b8:	00812e23          	sw	s0,28(sp)
c000c4bc:	02010413          	addi	s0,sp,32
c000c4c0:	fea42623          	sw	a0,-20(s0)
	return *(volatile u32 *) Addr;
c000c4c4:	fec42783          	lw	a5,-20(s0)
c000c4c8:	0007a783          	lw	a5,0(a5)
}
c000c4cc:	00078513          	mv	a0,a5
c000c4d0:	01c12403          	lw	s0,28(sp)
c000c4d4:	02010113          	addi	sp,sp,32
c000c4d8:	00008067          	ret

c000c4dc <Xil_Out32>:
{
c000c4dc:	fd010113          	addi	sp,sp,-48
c000c4e0:	02812623          	sw	s0,44(sp)
c000c4e4:	03010413          	addi	s0,sp,48
c000c4e8:	fca42e23          	sw	a0,-36(s0)
c000c4ec:	fcb42c23          	sw	a1,-40(s0)
	volatile u32 *LocalAddr = (volatile u32 *)Addr;
c000c4f0:	fdc42783          	lw	a5,-36(s0)
c000c4f4:	fef42623          	sw	a5,-20(s0)
	*LocalAddr = Value;
c000c4f8:	fec42783          	lw	a5,-20(s0)
c000c4fc:	fd842703          	lw	a4,-40(s0)
c000c500:	00e7a023          	sw	a4,0(a5)
}
c000c504:	00000013          	nop
c000c508:	02c12403          	lw	s0,44(sp)
c000c50c:	03010113          	addi	sp,sp,48
c000c510:	00008067          	ret

c000c514 <XUartNs550_GetOptions>:
*
* @note		None.
*
*****************************************************************************/
u16 XUartNs550_GetOptions(XUartNs550 *InstancePtr)
{
c000c514:	fd010113          	addi	sp,sp,-48
c000c518:	02112623          	sw	ra,44(sp)
c000c51c:	02812423          	sw	s0,40(sp)
c000c520:	03010413          	addi	s0,sp,48
c000c524:	fca42e23          	sw	a0,-36(s0)
	u16 Options = 0;
c000c528:	fe041723          	sh	zero,-18(s0)
	u32 Index;

	/*
	 * Assert validates the input arguments
	 */
	Xil_AssertNonvoid(InstancePtr != NULL);
c000c52c:	fdc42783          	lw	a5,-36(s0)
c000c530:	02078463          	beqz	a5,c000c558 <XUartNs550_GetOptions+0x44>
c000c534:	07ff6797          	auipc	a5,0x7ff6
c000c538:	3e078793          	addi	a5,a5,992 # c8002914 <Xil_AssertStatus>
c000c53c:	0007a023          	sw	zero,0(a5)
	Xil_AssertNonvoid(InstancePtr->IsReady == XIL_COMPONENT_IS_READY);
c000c540:	fdc42783          	lw	a5,-36(s0)
c000c544:	01c7a703          	lw	a4,28(a5)
c000c548:	111117b7          	lui	a5,0x11111
c000c54c:	11178793          	addi	a5,a5,273 # 11111111 <_DMEM_LENGTH+0x10911111>
c000c550:	04f71263          	bne	a4,a5,c000c594 <XUartNs550_GetOptions+0x80>
c000c554:	02c0006f          	j	c000c580 <XUartNs550_GetOptions+0x6c>
	Xil_AssertNonvoid(InstancePtr != NULL);
c000c558:	08400593          	li	a1,132
c000c55c:	07ff4517          	auipc	a0,0x7ff4
c000c560:	c8450513          	addi	a0,a0,-892 # c80001e0 <__rodata_start+0x1e0>
c000c564:	558110ef          	jal	ra,c001dabc <Xil_Assert>
c000c568:	07ff6797          	auipc	a5,0x7ff6
c000c56c:	3ac78793          	addi	a5,a5,940 # c8002914 <Xil_AssertStatus>
c000c570:	00100713          	li	a4,1
c000c574:	00e7a023          	sw	a4,0(a5)
c000c578:	00000793          	li	a5,0
c000c57c:	1400006f          	j	c000c6bc <XUartNs550_GetOptions+0x1a8>
	Xil_AssertNonvoid(InstancePtr->IsReady == XIL_COMPONENT_IS_READY);
c000c580:	07ff6797          	auipc	a5,0x7ff6
c000c584:	39478793          	addi	a5,a5,916 # c8002914 <Xil_AssertStatus>
c000c588:	0007a023          	sw	zero,0(a5)

	/*
	 * Loop thru the options table to map the physical options in the
	 * registers of the UART to the logical options to be returned
	 */
	for (Index = 0; Index < XUN_NUM_OPTIONS; Index++) {
c000c58c:	fe042223          	sw	zero,-28(s0)
c000c590:	11c0006f          	j	c000c6ac <XUartNs550_GetOptions+0x198>
	Xil_AssertNonvoid(InstancePtr->IsReady == XIL_COMPONENT_IS_READY);
c000c594:	08500593          	li	a1,133
c000c598:	07ff4517          	auipc	a0,0x7ff4
c000c59c:	c4850513          	addi	a0,a0,-952 # c80001e0 <__rodata_start+0x1e0>
c000c5a0:	51c110ef          	jal	ra,c001dabc <Xil_Assert>
c000c5a4:	07ff6797          	auipc	a5,0x7ff6
c000c5a8:	37078793          	addi	a5,a5,880 # c8002914 <Xil_AssertStatus>
c000c5ac:	00100713          	li	a4,1
c000c5b0:	00e7a023          	sw	a4,0(a5)
c000c5b4:	00000793          	li	a5,0
c000c5b8:	1040006f          	j	c000c6bc <XUartNs550_GetOptions+0x1a8>
		/*
		 * If the FIFO control register is being read, the make sure to
		 * setup the line control register so it can be read
		 */
		if (OptionsTable[Index].RegisterOffset == XUN_FCR_OFFSET) {
c000c5bc:	07ff6697          	auipc	a3,0x7ff6
c000c5c0:	42068693          	addi	a3,a3,1056 # c80029dc <OptionsTable>
c000c5c4:	fe442703          	lw	a4,-28(s0)
c000c5c8:	00070793          	mv	a5,a4
c000c5cc:	00179793          	slli	a5,a5,0x1
c000c5d0:	00e787b3          	add	a5,a5,a4
c000c5d4:	00179793          	slli	a5,a5,0x1
c000c5d8:	00f687b3          	add	a5,a3,a5
c000c5dc:	0027d703          	lhu	a4,2(a5)
c000c5e0:	00800793          	li	a5,8
c000c5e4:	00f71e63          	bne	a4,a5,c000c600 <XUartNs550_GetOptions+0xec>
			Register = ReadFcrRegister(InstancePtr->BaseAddress);
c000c5e8:	fdc42783          	lw	a5,-36(s0)
c000c5ec:	0147a783          	lw	a5,20(a5)
c000c5f0:	00078513          	mv	a0,a5
c000c5f4:	704000ef          	jal	ra,c000ccf8 <ReadFcrRegister>
c000c5f8:	fea42423          	sw	a0,-24(s0)
c000c5fc:	0400006f          	j	c000c63c <XUartNs550_GetOptions+0x128>
		} else {
			Register = XUartNs550_ReadReg(InstancePtr->BaseAddress,
c000c600:	fdc42783          	lw	a5,-36(s0)
c000c604:	0147a683          	lw	a3,20(a5)
c000c608:	07ff6617          	auipc	a2,0x7ff6
c000c60c:	3d460613          	addi	a2,a2,980 # c80029dc <OptionsTable>
c000c610:	fe442703          	lw	a4,-28(s0)
c000c614:	00070793          	mv	a5,a4
c000c618:	00179793          	slli	a5,a5,0x1
c000c61c:	00e787b3          	add	a5,a5,a4
c000c620:	00179793          	slli	a5,a5,0x1
c000c624:	00f607b3          	add	a5,a2,a5
c000c628:	0027d783          	lhu	a5,2(a5)
c000c62c:	00f687b3          	add	a5,a3,a5
c000c630:	00078513          	mv	a0,a5
c000c634:	e81ff0ef          	jal	ra,c000c4b4 <Xil_In32>
c000c638:	fea42423          	sw	a0,-24(s0)
		 * If the bit in the register which correlates to the option
		 * is set, then set the corresponding bit in the options,
		 * ignoring any bits which are zero since the options variable
		 * is initialized to zero
		 */
		if (Register & OptionsTable[Index].Mask) {
c000c63c:	07ff6697          	auipc	a3,0x7ff6
c000c640:	3a068693          	addi	a3,a3,928 # c80029dc <OptionsTable>
c000c644:	fe442703          	lw	a4,-28(s0)
c000c648:	00070793          	mv	a5,a4
c000c64c:	00179793          	slli	a5,a5,0x1
c000c650:	00e787b3          	add	a5,a5,a4
c000c654:	00179793          	slli	a5,a5,0x1
c000c658:	00f687b3          	add	a5,a3,a5
c000c65c:	0047c783          	lbu	a5,4(a5)
c000c660:	00078713          	mv	a4,a5
c000c664:	fe842783          	lw	a5,-24(s0)
c000c668:	00f777b3          	and	a5,a4,a5
c000c66c:	02078a63          	beqz	a5,c000c6a0 <XUartNs550_GetOptions+0x18c>
			Options |= OptionsTable[Index].Option;
c000c670:	07ff6697          	auipc	a3,0x7ff6
c000c674:	36c68693          	addi	a3,a3,876 # c80029dc <OptionsTable>
c000c678:	fe442703          	lw	a4,-28(s0)
c000c67c:	00070793          	mv	a5,a4
c000c680:	00179793          	slli	a5,a5,0x1
c000c684:	00e787b3          	add	a5,a5,a4
c000c688:	00179793          	slli	a5,a5,0x1
c000c68c:	00f687b3          	add	a5,a3,a5
c000c690:	0007d703          	lhu	a4,0(a5)
c000c694:	fee45783          	lhu	a5,-18(s0)
c000c698:	00f767b3          	or	a5,a4,a5
c000c69c:	fef41723          	sh	a5,-18(s0)
	for (Index = 0; Index < XUN_NUM_OPTIONS; Index++) {
c000c6a0:	fe442783          	lw	a5,-28(s0)
c000c6a4:	00178793          	addi	a5,a5,1
c000c6a8:	fef42223          	sw	a5,-28(s0)
c000c6ac:	fe442703          	lw	a4,-28(s0)
c000c6b0:	00b00793          	li	a5,11
c000c6b4:	f0e7f4e3          	bgeu	a5,a4,c000c5bc <XUartNs550_GetOptions+0xa8>
		}
	}

	return Options;
c000c6b8:	fee45783          	lhu	a5,-18(s0)
}
c000c6bc:	00078513          	mv	a0,a5
c000c6c0:	02c12083          	lw	ra,44(sp)
c000c6c4:	02812403          	lw	s0,40(sp)
c000c6c8:	03010113          	addi	sp,sp,48
c000c6cc:	00008067          	ret

c000c6d0 <XUartNs550_SetOptions>:
*
* @note		None.
*
*****************************************************************************/
int XUartNs550_SetOptions(XUartNs550 *InstancePtr, u16 Options)
{
c000c6d0:	fd010113          	addi	sp,sp,-48
c000c6d4:	02112623          	sw	ra,44(sp)
c000c6d8:	02812423          	sw	s0,40(sp)
c000c6dc:	03010413          	addi	s0,sp,48
c000c6e0:	fca42e23          	sw	a0,-36(s0)
c000c6e4:	00058793          	mv	a5,a1
c000c6e8:	fcf41d23          	sh	a5,-38(s0)
	u32 Register;

	/*
	 * Assert validates the input arguments
	 */
	Xil_AssertNonvoid(InstancePtr != NULL);
c000c6ec:	fdc42783          	lw	a5,-36(s0)
c000c6f0:	02078463          	beqz	a5,c000c718 <XUartNs550_SetOptions+0x48>
c000c6f4:	07ff6797          	auipc	a5,0x7ff6
c000c6f8:	22078793          	addi	a5,a5,544 # c8002914 <Xil_AssertStatus>
c000c6fc:	0007a023          	sw	zero,0(a5)
	Xil_AssertNonvoid(InstancePtr->IsReady == XIL_COMPONENT_IS_READY);
c000c700:	fdc42783          	lw	a5,-36(s0)
c000c704:	01c7a703          	lw	a4,28(a5)
c000c708:	111117b7          	lui	a5,0x11111
c000c70c:	11178793          	addi	a5,a5,273 # 11111111 <_DMEM_LENGTH+0x10911111>
c000c710:	04f71263          	bne	a4,a5,c000c754 <XUartNs550_SetOptions+0x84>
c000c714:	02c0006f          	j	c000c740 <XUartNs550_SetOptions+0x70>
	Xil_AssertNonvoid(InstancePtr != NULL);
c000c718:	0c500593          	li	a1,197
c000c71c:	07ff4517          	auipc	a0,0x7ff4
c000c720:	ac450513          	addi	a0,a0,-1340 # c80001e0 <__rodata_start+0x1e0>
c000c724:	398110ef          	jal	ra,c001dabc <Xil_Assert>
c000c728:	07ff6797          	auipc	a5,0x7ff6
c000c72c:	1ec78793          	addi	a5,a5,492 # c8002914 <Xil_AssertStatus>
c000c730:	00100713          	li	a4,1
c000c734:	00e7a023          	sw	a4,0(a5)
c000c738:	00000793          	li	a5,0
c000c73c:	1c00006f          	j	c000c8fc <XUartNs550_SetOptions+0x22c>
	Xil_AssertNonvoid(InstancePtr->IsReady == XIL_COMPONENT_IS_READY);
c000c740:	07ff6797          	auipc	a5,0x7ff6
c000c744:	1d478793          	addi	a5,a5,468 # c8002914 <Xil_AssertStatus>
c000c748:	0007a023          	sw	zero,0(a5)

	/*
	 * Loop thru the options table to map the logical options to the
	 * physical options in the registers of the UART
	 */
	for (Index = 0; Index < XUN_NUM_OPTIONS; Index++) {
c000c74c:	fe042623          	sw	zero,-20(s0)
c000c750:	19c0006f          	j	c000c8ec <XUartNs550_SetOptions+0x21c>
	Xil_AssertNonvoid(InstancePtr->IsReady == XIL_COMPONENT_IS_READY);
c000c754:	0c600593          	li	a1,198
c000c758:	07ff4517          	auipc	a0,0x7ff4
c000c75c:	a8850513          	addi	a0,a0,-1400 # c80001e0 <__rodata_start+0x1e0>
c000c760:	35c110ef          	jal	ra,c001dabc <Xil_Assert>
c000c764:	07ff6797          	auipc	a5,0x7ff6
c000c768:	1b078793          	addi	a5,a5,432 # c8002914 <Xil_AssertStatus>
c000c76c:	00100713          	li	a4,1
c000c770:	00e7a023          	sw	a4,0(a5)
c000c774:	00000793          	li	a5,0
c000c778:	1840006f          	j	c000c8fc <XUartNs550_SetOptions+0x22c>

		/*
		 * If the FIFO control register is being read, this is a
		 * special case that requires special register processing
		 */
		if (OptionsTable[Index].RegisterOffset == XUN_FCR_OFFSET) {
c000c77c:	07ff6697          	auipc	a3,0x7ff6
c000c780:	26068693          	addi	a3,a3,608 # c80029dc <OptionsTable>
c000c784:	fec42703          	lw	a4,-20(s0)
c000c788:	00070793          	mv	a5,a4
c000c78c:	00179793          	slli	a5,a5,0x1
c000c790:	00e787b3          	add	a5,a5,a4
c000c794:	00179793          	slli	a5,a5,0x1
c000c798:	00f687b3          	add	a5,a3,a5
c000c79c:	0027d703          	lhu	a4,2(a5)
c000c7a0:	00800793          	li	a5,8
c000c7a4:	00f71e63          	bne	a4,a5,c000c7c0 <XUartNs550_SetOptions+0xf0>
			Register = ReadFcrRegister(InstancePtr->BaseAddress);
c000c7a8:	fdc42783          	lw	a5,-36(s0)
c000c7ac:	0147a783          	lw	a5,20(a5)
c000c7b0:	00078513          	mv	a0,a5
c000c7b4:	544000ef          	jal	ra,c000ccf8 <ReadFcrRegister>
c000c7b8:	fea42423          	sw	a0,-24(s0)
c000c7bc:	0400006f          	j	c000c7fc <XUartNs550_SetOptions+0x12c>
			/*
			 * Read the register which contains option so that the
			 * register can be changed without destoying any other
			 * bits of the register
			 */
			Register = XUartNs550_ReadReg(InstancePtr->BaseAddress,
c000c7c0:	fdc42783          	lw	a5,-36(s0)
c000c7c4:	0147a683          	lw	a3,20(a5)
c000c7c8:	07ff6617          	auipc	a2,0x7ff6
c000c7cc:	21460613          	addi	a2,a2,532 # c80029dc <OptionsTable>
c000c7d0:	fec42703          	lw	a4,-20(s0)
c000c7d4:	00070793          	mv	a5,a4
c000c7d8:	00179793          	slli	a5,a5,0x1
c000c7dc:	00e787b3          	add	a5,a5,a4
c000c7e0:	00179793          	slli	a5,a5,0x1
c000c7e4:	00f607b3          	add	a5,a2,a5
c000c7e8:	0027d783          	lhu	a5,2(a5)
c000c7ec:	00f687b3          	add	a5,a3,a5
c000c7f0:	00078513          	mv	a0,a5
c000c7f4:	cc1ff0ef          	jal	ra,c000c4b4 <Xil_In32>
c000c7f8:	fea42423          	sw	a0,-24(s0)
		/*
		 * If the option is set in the input, then set the
		 * corresponding bit in the specified register, otherwise
		 * clear the bit in the register
		 */
		if (Options & OptionsTable[Index].Option) {
c000c7fc:	07ff6697          	auipc	a3,0x7ff6
c000c800:	1e068693          	addi	a3,a3,480 # c80029dc <OptionsTable>
c000c804:	fec42703          	lw	a4,-20(s0)
c000c808:	00070793          	mv	a5,a4
c000c80c:	00179793          	slli	a5,a5,0x1
c000c810:	00e787b3          	add	a5,a5,a4
c000c814:	00179793          	slli	a5,a5,0x1
c000c818:	00f687b3          	add	a5,a3,a5
c000c81c:	0007d703          	lhu	a4,0(a5)
c000c820:	fda45783          	lhu	a5,-38(s0)
c000c824:	00f777b3          	and	a5,a4,a5
c000c828:	01079793          	slli	a5,a5,0x10
c000c82c:	0107d793          	srli	a5,a5,0x10
c000c830:	02078e63          	beqz	a5,c000c86c <XUartNs550_SetOptions+0x19c>
			Register |= OptionsTable[Index].Mask;
c000c834:	07ff6697          	auipc	a3,0x7ff6
c000c838:	1a868693          	addi	a3,a3,424 # c80029dc <OptionsTable>
c000c83c:	fec42703          	lw	a4,-20(s0)
c000c840:	00070793          	mv	a5,a4
c000c844:	00179793          	slli	a5,a5,0x1
c000c848:	00e787b3          	add	a5,a5,a4
c000c84c:	00179793          	slli	a5,a5,0x1
c000c850:	00f687b3          	add	a5,a3,a5
c000c854:	0047c783          	lbu	a5,4(a5)
c000c858:	00078713          	mv	a4,a5
c000c85c:	fe842783          	lw	a5,-24(s0)
c000c860:	00e7e7b3          	or	a5,a5,a4
c000c864:	fef42423          	sw	a5,-24(s0)
c000c868:	03c0006f          	j	c000c8a4 <XUartNs550_SetOptions+0x1d4>
		} else {
			Register &= ~OptionsTable[Index].Mask;
c000c86c:	07ff6697          	auipc	a3,0x7ff6
c000c870:	17068693          	addi	a3,a3,368 # c80029dc <OptionsTable>
c000c874:	fec42703          	lw	a4,-20(s0)
c000c878:	00070793          	mv	a5,a4
c000c87c:	00179793          	slli	a5,a5,0x1
c000c880:	00e787b3          	add	a5,a5,a4
c000c884:	00179793          	slli	a5,a5,0x1
c000c888:	00f687b3          	add	a5,a3,a5
c000c88c:	0047c783          	lbu	a5,4(a5)
c000c890:	fff7c793          	not	a5,a5
c000c894:	00078713          	mv	a4,a5
c000c898:	fe842783          	lw	a5,-24(s0)
c000c89c:	00e7f7b3          	and	a5,a5,a4
c000c8a0:	fef42423          	sw	a5,-24(s0)
		}

		/*
		 * Write the new value to the register to set the option
		 */
		XUartNs550_WriteReg(InstancePtr->BaseAddress,
c000c8a4:	fdc42783          	lw	a5,-36(s0)
c000c8a8:	0147a683          	lw	a3,20(a5)
c000c8ac:	07ff6617          	auipc	a2,0x7ff6
c000c8b0:	13060613          	addi	a2,a2,304 # c80029dc <OptionsTable>
c000c8b4:	fec42703          	lw	a4,-20(s0)
c000c8b8:	00070793          	mv	a5,a4
c000c8bc:	00179793          	slli	a5,a5,0x1
c000c8c0:	00e787b3          	add	a5,a5,a4
c000c8c4:	00179793          	slli	a5,a5,0x1
c000c8c8:	00f607b3          	add	a5,a2,a5
c000c8cc:	0027d783          	lhu	a5,2(a5)
c000c8d0:	00f687b3          	add	a5,a3,a5
c000c8d4:	fe842583          	lw	a1,-24(s0)
c000c8d8:	00078513          	mv	a0,a5
c000c8dc:	c01ff0ef          	jal	ra,c000c4dc <Xil_Out32>
	for (Index = 0; Index < XUN_NUM_OPTIONS; Index++) {
c000c8e0:	fec42783          	lw	a5,-20(s0)
c000c8e4:	00178793          	addi	a5,a5,1
c000c8e8:	fef42623          	sw	a5,-20(s0)
c000c8ec:	fec42703          	lw	a4,-20(s0)
c000c8f0:	00b00793          	li	a5,11
c000c8f4:	e8e7f4e3          	bgeu	a5,a4,c000c77c <XUartNs550_SetOptions+0xac>
				 OptionsTable[Index].RegisterOffset, Register);
	}

	/* To be done, add error checks for enabling/resetting FIFOs */

	return XST_SUCCESS;
c000c8f8:	00000793          	li	a5,0
}
c000c8fc:	00078513          	mv	a0,a5
c000c900:	02c12083          	lw	ra,44(sp)
c000c904:	02812403          	lw	s0,40(sp)
c000c908:	03010113          	addi	sp,sp,48
c000c90c:	00008067          	ret

c000c910 <XUartNs550_GetFifoThreshold>:
*
* @note		None.
*
*****************************************************************************/
u8 XUartNs550_GetFifoThreshold(XUartNs550 *InstancePtr)
{
c000c910:	fd010113          	addi	sp,sp,-48
c000c914:	02112623          	sw	ra,44(sp)
c000c918:	02812423          	sw	s0,40(sp)
c000c91c:	03010413          	addi	s0,sp,48
c000c920:	fca42e23          	sw	a0,-36(s0)
	u32 FcrRegister;

	/*
	 * Assert validates the input arguments
	 */
	Xil_AssertNonvoid(InstancePtr != NULL);
c000c924:	fdc42783          	lw	a5,-36(s0)
c000c928:	02078463          	beqz	a5,c000c950 <XUartNs550_GetFifoThreshold+0x40>
c000c92c:	07ff6797          	auipc	a5,0x7ff6
c000c930:	fe878793          	addi	a5,a5,-24 # c8002914 <Xil_AssertStatus>
c000c934:	0007a023          	sw	zero,0(a5)
	Xil_AssertNonvoid(InstancePtr->IsReady == XIL_COMPONENT_IS_READY);
c000c938:	fdc42783          	lw	a5,-36(s0)
c000c93c:	01c7a703          	lw	a4,28(a5)
c000c940:	111117b7          	lui	a5,0x11111
c000c944:	11178793          	addi	a5,a5,273 # 11111111 <_DMEM_LENGTH+0x10911111>
c000c948:	06f71263          	bne	a4,a5,c000c9ac <XUartNs550_GetFifoThreshold+0x9c>
c000c94c:	02c0006f          	j	c000c978 <XUartNs550_GetFifoThreshold+0x68>
	Xil_AssertNonvoid(InstancePtr != NULL);
c000c950:	10c00593          	li	a1,268
c000c954:	07ff4517          	auipc	a0,0x7ff4
c000c958:	88c50513          	addi	a0,a0,-1908 # c80001e0 <__rodata_start+0x1e0>
c000c95c:	160110ef          	jal	ra,c001dabc <Xil_Assert>
c000c960:	07ff6797          	auipc	a5,0x7ff6
c000c964:	fb478793          	addi	a5,a5,-76 # c8002914 <Xil_AssertStatus>
c000c968:	00100713          	li	a4,1
c000c96c:	00e7a023          	sw	a4,0(a5)
c000c970:	00000793          	li	a5,0
c000c974:	05c0006f          	j	c000c9d0 <XUartNs550_GetFifoThreshold+0xc0>
	Xil_AssertNonvoid(InstancePtr->IsReady == XIL_COMPONENT_IS_READY);
c000c978:	07ff6797          	auipc	a5,0x7ff6
c000c97c:	f9c78793          	addi	a5,a5,-100 # c8002914 <Xil_AssertStatus>
c000c980:	0007a023          	sw	zero,0(a5)

	/*
	 * Read the value of the FIFO control register so that the threshold
	 * can be retrieved, this read takes special register processing
	 */
	FcrRegister = ReadFcrRegister(InstancePtr->BaseAddress);
c000c984:	fdc42783          	lw	a5,-36(s0)
c000c988:	0147a783          	lw	a5,20(a5)
c000c98c:	00078513          	mv	a0,a5
c000c990:	368000ef          	jal	ra,c000ccf8 <ReadFcrRegister>
c000c994:	fea42623          	sw	a0,-20(s0)

	/*
	 * Return only the trigger level from the register value
	 */
	return (u8)(FcrRegister & XUN_FIFO_RX_TRIGGER);
c000c998:	fec42783          	lw	a5,-20(s0)
c000c99c:	0ff7f793          	andi	a5,a5,255
c000c9a0:	fc07f793          	andi	a5,a5,-64
c000c9a4:	0ff7f793          	andi	a5,a5,255
c000c9a8:	0280006f          	j	c000c9d0 <XUartNs550_GetFifoThreshold+0xc0>
	Xil_AssertNonvoid(InstancePtr->IsReady == XIL_COMPONENT_IS_READY);
c000c9ac:	10d00593          	li	a1,269
c000c9b0:	07ff4517          	auipc	a0,0x7ff4
c000c9b4:	83050513          	addi	a0,a0,-2000 # c80001e0 <__rodata_start+0x1e0>
c000c9b8:	104110ef          	jal	ra,c001dabc <Xil_Assert>
c000c9bc:	07ff6797          	auipc	a5,0x7ff6
c000c9c0:	f5878793          	addi	a5,a5,-168 # c8002914 <Xil_AssertStatus>
c000c9c4:	00100713          	li	a4,1
c000c9c8:	00e7a023          	sw	a4,0(a5)
c000c9cc:	00000793          	li	a5,0
}
c000c9d0:	00078513          	mv	a0,a5
c000c9d4:	02c12083          	lw	ra,44(sp)
c000c9d8:	02812403          	lw	s0,40(sp)
c000c9dc:	03010113          	addi	sp,sp,48
c000c9e0:	00008067          	ret

c000c9e4 <XUartNs550_SetFifoThreshold>:
*
* @note		None.
*
*****************************************************************************/
int XUartNs550_SetFifoThreshold(XUartNs550 *InstancePtr, u8 TriggerLevel)
{
c000c9e4:	fd010113          	addi	sp,sp,-48
c000c9e8:	02112623          	sw	ra,44(sp)
c000c9ec:	02812423          	sw	s0,40(sp)
c000c9f0:	03010413          	addi	s0,sp,48
c000c9f4:	fca42e23          	sw	a0,-36(s0)
c000c9f8:	00058793          	mv	a5,a1
c000c9fc:	fcf40da3          	sb	a5,-37(s0)
	u32 FcrRegister;

	/*
	 * Assert validates the input arguments
	 */
	Xil_AssertNonvoid(InstancePtr != NULL);
c000ca00:	fdc42783          	lw	a5,-36(s0)
c000ca04:	02078063          	beqz	a5,c000ca24 <XUartNs550_SetFifoThreshold+0x40>
c000ca08:	07ff6797          	auipc	a5,0x7ff6
c000ca0c:	f0c78793          	addi	a5,a5,-244 # c8002914 <Xil_AssertStatus>
c000ca10:	0007a023          	sw	zero,0(a5)
	Xil_AssertNonvoid((TriggerLevel == XUN_FIFO_TRIGGER_14) ||
c000ca14:	fdb44703          	lbu	a4,-37(s0)
c000ca18:	0c000793          	li	a5,192
c000ca1c:	04f70863          	beq	a4,a5,c000ca6c <XUartNs550_SetFifoThreshold+0x88>
c000ca20:	02c0006f          	j	c000ca4c <XUartNs550_SetFifoThreshold+0x68>
	Xil_AssertNonvoid(InstancePtr != NULL);
c000ca24:	13800593          	li	a1,312
c000ca28:	07ff3517          	auipc	a0,0x7ff3
c000ca2c:	7b850513          	addi	a0,a0,1976 # c80001e0 <__rodata_start+0x1e0>
c000ca30:	08c110ef          	jal	ra,c001dabc <Xil_Assert>
c000ca34:	07ff6797          	auipc	a5,0x7ff6
c000ca38:	ee078793          	addi	a5,a5,-288 # c8002914 <Xil_AssertStatus>
c000ca3c:	00100713          	li	a4,1
c000ca40:	00e7a023          	sw	a4,0(a5)
c000ca44:	00000793          	li	a5,0
c000ca48:	1080006f          	j	c000cb50 <XUartNs550_SetFifoThreshold+0x16c>
	Xil_AssertNonvoid((TriggerLevel == XUN_FIFO_TRIGGER_14) ||
c000ca4c:	fdb44703          	lbu	a4,-37(s0)
c000ca50:	08000793          	li	a5,128
c000ca54:	00f70c63          	beq	a4,a5,c000ca6c <XUartNs550_SetFifoThreshold+0x88>
c000ca58:	fdb44703          	lbu	a4,-37(s0)
c000ca5c:	04000793          	li	a5,64
c000ca60:	00f70663          	beq	a4,a5,c000ca6c <XUartNs550_SetFifoThreshold+0x88>
c000ca64:	fdb44783          	lbu	a5,-37(s0)
c000ca68:	02079463          	bnez	a5,c000ca90 <XUartNs550_SetFifoThreshold+0xac>
c000ca6c:	07ff6797          	auipc	a5,0x7ff6
c000ca70:	ea878793          	addi	a5,a5,-344 # c8002914 <Xil_AssertStatus>
c000ca74:	0007a023          	sw	zero,0(a5)
			(TriggerLevel == XUN_FIFO_TRIGGER_08) ||
			(TriggerLevel == XUN_FIFO_TRIGGER_04) ||
			(TriggerLevel == XUN_FIFO_TRIGGER_01));
	Xil_AssertNonvoid(InstancePtr->IsReady == XIL_COMPONENT_IS_READY);
c000ca78:	fdc42783          	lw	a5,-36(s0)
c000ca7c:	01c7a703          	lw	a4,28(a5)
c000ca80:	111117b7          	lui	a5,0x11111
c000ca84:	11178793          	addi	a5,a5,273 # 11111111 <_DMEM_LENGTH+0x10911111>
c000ca88:	02f70863          	beq	a4,a5,c000cab8 <XUartNs550_SetFifoThreshold+0xd4>
c000ca8c:	05c0006f          	j	c000cae8 <XUartNs550_SetFifoThreshold+0x104>
	Xil_AssertNonvoid((TriggerLevel == XUN_FIFO_TRIGGER_14) ||
c000ca90:	13900593          	li	a1,313
c000ca94:	07ff3517          	auipc	a0,0x7ff3
c000ca98:	74c50513          	addi	a0,a0,1868 # c80001e0 <__rodata_start+0x1e0>
c000ca9c:	020110ef          	jal	ra,c001dabc <Xil_Assert>
c000caa0:	07ff6797          	auipc	a5,0x7ff6
c000caa4:	e7478793          	addi	a5,a5,-396 # c8002914 <Xil_AssertStatus>
c000caa8:	00100713          	li	a4,1
c000caac:	00e7a023          	sw	a4,0(a5)
c000cab0:	00000793          	li	a5,0
c000cab4:	09c0006f          	j	c000cb50 <XUartNs550_SetFifoThreshold+0x16c>
	Xil_AssertNonvoid(InstancePtr->IsReady == XIL_COMPONENT_IS_READY);
c000cab8:	07ff6797          	auipc	a5,0x7ff6
c000cabc:	e5c78793          	addi	a5,a5,-420 # c8002914 <Xil_AssertStatus>
c000cac0:	0007a023          	sw	zero,0(a5)

	/*
	 * Read the value of the FIFO control register, this read takes special
	 * register processing
	 */
	FcrRegister = ReadFcrRegister(InstancePtr->BaseAddress);
c000cac4:	fdc42783          	lw	a5,-36(s0)
c000cac8:	0147a783          	lw	a5,20(a5)
c000cacc:	00078513          	mv	a0,a5
c000cad0:	228000ef          	jal	ra,c000ccf8 <ReadFcrRegister>
c000cad4:	fea42623          	sw	a0,-20(s0)

	/*
	 * If the FIFO control register indicates that FIFOs are disabled, then
	 * either they are just disabled or it has no FIFOs, return an error
	 */
	if ((FcrRegister & XUN_FIFO_ENABLE) == 0) {
c000cad8:	fec42783          	lw	a5,-20(s0)
c000cadc:	0017f793          	andi	a5,a5,1
c000cae0:	02079c63          	bnez	a5,c000cb18 <XUartNs550_SetFifoThreshold+0x134>
c000cae4:	02c0006f          	j	c000cb10 <XUartNs550_SetFifoThreshold+0x12c>
	Xil_AssertNonvoid(InstancePtr->IsReady == XIL_COMPONENT_IS_READY);
c000cae8:	13d00593          	li	a1,317
c000caec:	07ff3517          	auipc	a0,0x7ff3
c000caf0:	6f450513          	addi	a0,a0,1780 # c80001e0 <__rodata_start+0x1e0>
c000caf4:	7c9100ef          	jal	ra,c001dabc <Xil_Assert>
c000caf8:	07ff6797          	auipc	a5,0x7ff6
c000cafc:	e1c78793          	addi	a5,a5,-484 # c8002914 <Xil_AssertStatus>
c000cb00:	00100713          	li	a4,1
c000cb04:	00e7a023          	sw	a4,0(a5)
c000cb08:	00000793          	li	a5,0
c000cb0c:	0440006f          	j	c000cb50 <XUartNs550_SetFifoThreshold+0x16c>
		return XST_UART_CONFIG_ERROR;
c000cb10:	41d00793          	li	a5,1053
c000cb14:	03c0006f          	j	c000cb50 <XUartNs550_SetFifoThreshold+0x16c>

	/*
	 * Set the receive FIFO trigger level by clearing out the old level in
	 * the FIFO control register and writing in the new level
	 */
	FcrRegister &= ~XUN_FIFO_RX_TRIGGER;
c000cb18:	fec42783          	lw	a5,-20(s0)
c000cb1c:	f3f7f793          	andi	a5,a5,-193
c000cb20:	fef42623          	sw	a5,-20(s0)
	FcrRegister |= (u32) TriggerLevel;
c000cb24:	fdb44783          	lbu	a5,-37(s0)
c000cb28:	fec42703          	lw	a4,-20(s0)
c000cb2c:	00f767b3          	or	a5,a4,a5
c000cb30:	fef42623          	sw	a5,-20(s0)

	/*
	 * Write the new value for the FIFO control register to it such that the
	 * threshold is changed, writing to it is normal unlike reading from it
	 */
	XUartNs550_WriteReg(InstancePtr->BaseAddress,
c000cb34:	fdc42783          	lw	a5,-36(s0)
c000cb38:	0147a783          	lw	a5,20(a5)
c000cb3c:	00878793          	addi	a5,a5,8
c000cb40:	fec42583          	lw	a1,-20(s0)
c000cb44:	00078513          	mv	a0,a5
c000cb48:	995ff0ef          	jal	ra,c000c4dc <Xil_Out32>
				XUN_FCR_OFFSET, FcrRegister);

	return XST_SUCCESS;
c000cb4c:	00000793          	li	a5,0
}
c000cb50:	00078513          	mv	a0,a5
c000cb54:	02c12083          	lw	ra,44(sp)
c000cb58:	02812403          	lw	s0,40(sp)
c000cb5c:	03010113          	addi	sp,sp,48
c000cb60:	00008067          	ret

c000cb64 <XUartNs550_GetLastErrors>:
*
* @note		None.
*
*****************************************************************************/
u8 XUartNs550_GetLastErrors(XUartNs550 *InstancePtr)
{
c000cb64:	fd010113          	addi	sp,sp,-48
c000cb68:	02112623          	sw	ra,44(sp)
c000cb6c:	02812423          	sw	s0,40(sp)
c000cb70:	03010413          	addi	s0,sp,48
c000cb74:	fca42e23          	sw	a0,-36(s0)
	u8 Temp = InstancePtr->LastErrors;
c000cb78:	fdc42783          	lw	a5,-36(s0)
c000cb7c:	0247c783          	lbu	a5,36(a5)
c000cb80:	fef407a3          	sb	a5,-17(s0)

	/*
	 * Assert validates the input arguments
	 */
	Xil_AssertNonvoid(InstancePtr != NULL);
c000cb84:	fdc42783          	lw	a5,-36(s0)
c000cb88:	02078463          	beqz	a5,c000cbb0 <XUartNs550_GetLastErrors+0x4c>
c000cb8c:	07ff6797          	auipc	a5,0x7ff6
c000cb90:	d8878793          	addi	a5,a5,-632 # c8002914 <Xil_AssertStatus>
c000cb94:	0007a023          	sw	zero,0(a5)

	/*
	 * Clear the last errors and return the previous value
	 */
	InstancePtr->LastErrors = 0;
c000cb98:	fdc42783          	lw	a5,-36(s0)
c000cb9c:	02078223          	sb	zero,36(a5)
	 * Only return the bits that are reported errors which include
	 * receive overrun, framing, parity and break detection, the last errors
	 * variable holds an accumulation of the line status register bits which
	 * have been set
	 */
	return Temp & XUN_LSR_ERROR_BREAK;
c000cba0:	fef44783          	lbu	a5,-17(s0)
c000cba4:	01e7f793          	andi	a5,a5,30
c000cba8:	0ff7f793          	andi	a5,a5,255
c000cbac:	0280006f          	j	c000cbd4 <XUartNs550_GetLastErrors+0x70>
	Xil_AssertNonvoid(InstancePtr != NULL);
c000cbb0:	17e00593          	li	a1,382
c000cbb4:	07ff3517          	auipc	a0,0x7ff3
c000cbb8:	62c50513          	addi	a0,a0,1580 # c80001e0 <__rodata_start+0x1e0>
c000cbbc:	701100ef          	jal	ra,c001dabc <Xil_Assert>
c000cbc0:	07ff6797          	auipc	a5,0x7ff6
c000cbc4:	d5478793          	addi	a5,a5,-684 # c8002914 <Xil_AssertStatus>
c000cbc8:	00100713          	li	a4,1
c000cbcc:	00e7a023          	sw	a4,0(a5)
c000cbd0:	00000793          	li	a5,0
}
c000cbd4:	00078513          	mv	a0,a5
c000cbd8:	02c12083          	lw	ra,44(sp)
c000cbdc:	02812403          	lw	s0,40(sp)
c000cbe0:	03010113          	addi	sp,sp,48
c000cbe4:	00008067          	ret

c000cbe8 <XUartNs550_GetModemStatus>:
* The bit masks used for the modem status are the exact bits of the modem
* status register with no abstraction.
*
*****************************************************************************/
u8 XUartNs550_GetModemStatus(XUartNs550 *InstancePtr)
{
c000cbe8:	fd010113          	addi	sp,sp,-48
c000cbec:	02112623          	sw	ra,44(sp)
c000cbf0:	02812423          	sw	s0,40(sp)
c000cbf4:	03010413          	addi	s0,sp,48
c000cbf8:	fca42e23          	sw	a0,-36(s0)
	u32 ModemStatusRegister;

	/*
	 * Assert validates the input arguments
	 */
	Xil_AssertNonvoid(InstancePtr != NULL);
c000cbfc:	fdc42783          	lw	a5,-36(s0)
c000cc00:	02078a63          	beqz	a5,c000cc34 <XUartNs550_GetModemStatus+0x4c>
c000cc04:	07ff6797          	auipc	a5,0x7ff6
c000cc08:	d1078793          	addi	a5,a5,-752 # c8002914 <Xil_AssertStatus>
c000cc0c:	0007a023          	sw	zero,0(a5)

	/*
	 * Read the modem status register to return
	 */
	ModemStatusRegister = XUartNs550_ReadReg(InstancePtr->BaseAddress,
c000cc10:	fdc42783          	lw	a5,-36(s0)
c000cc14:	0147a783          	lw	a5,20(a5)
c000cc18:	01878793          	addi	a5,a5,24
c000cc1c:	00078513          	mv	a0,a5
c000cc20:	895ff0ef          	jal	ra,c000c4b4 <Xil_In32>
c000cc24:	fea42623          	sw	a0,-20(s0)
					XUN_MSR_OFFSET);
	return (u8) ModemStatusRegister;
c000cc28:	fec42783          	lw	a5,-20(s0)
c000cc2c:	0ff7f793          	andi	a5,a5,255
c000cc30:	0280006f          	j	c000cc58 <XUartNs550_GetModemStatus+0x70>
	Xil_AssertNonvoid(InstancePtr != NULL);
c000cc34:	1a900593          	li	a1,425
c000cc38:	07ff3517          	auipc	a0,0x7ff3
c000cc3c:	5a850513          	addi	a0,a0,1448 # c80001e0 <__rodata_start+0x1e0>
c000cc40:	67d100ef          	jal	ra,c001dabc <Xil_Assert>
c000cc44:	07ff6797          	auipc	a5,0x7ff6
c000cc48:	cd078793          	addi	a5,a5,-816 # c8002914 <Xil_AssertStatus>
c000cc4c:	00100713          	li	a4,1
c000cc50:	00e7a023          	sw	a4,0(a5)
c000cc54:	00000793          	li	a5,0
}
c000cc58:	00078513          	mv	a0,a5
c000cc5c:	02c12083          	lw	ra,44(sp)
c000cc60:	02812403          	lw	s0,40(sp)
c000cc64:	03010113          	addi	sp,sp,48
c000cc68:	00008067          	ret

c000cc6c <XUartNs550_IsSending>:
*
* @note		None.
*
*****************************************************************************/
int XUartNs550_IsSending(XUartNs550 *InstancePtr)
{
c000cc6c:	fd010113          	addi	sp,sp,-48
c000cc70:	02112623          	sw	ra,44(sp)
c000cc74:	02812423          	sw	s0,40(sp)
c000cc78:	03010413          	addi	s0,sp,48
c000cc7c:	fca42e23          	sw	a0,-36(s0)
	u32 LsrRegister;

	/*
	 * Assert validates the input arguments
	 */
	Xil_AssertNonvoid(InstancePtr != NULL);
c000cc80:	fdc42783          	lw	a5,-36(s0)
c000cc84:	02078e63          	beqz	a5,c000ccc0 <XUartNs550_IsSending+0x54>
c000cc88:	07ff6797          	auipc	a5,0x7ff6
c000cc8c:	c8c78793          	addi	a5,a5,-884 # c8002914 <Xil_AssertStatus>
c000cc90:	0007a023          	sw	zero,0(a5)

	/*
	 * Read the line status register to determine if the transmitter is
	 * empty
	 */
	LsrRegister = XUartNs550_GetLineStatusReg(InstancePtr->BaseAddress);
c000cc94:	fdc42783          	lw	a5,-36(s0)
c000cc98:	0147a783          	lw	a5,20(a5)
c000cc9c:	01478793          	addi	a5,a5,20
c000cca0:	00078513          	mv	a0,a5
c000cca4:	811ff0ef          	jal	ra,c000c4b4 <Xil_In32>
c000cca8:	fea42623          	sw	a0,-20(s0)

	/*
	 * If the transmitter is not empty then indicate that the UART is still
	 * sending some data
	 */
	return ((LsrRegister & XUN_LSR_TX_EMPTY) == 0);
c000ccac:	fec42783          	lw	a5,-20(s0)
c000ccb0:	0407f793          	andi	a5,a5,64
c000ccb4:	0017b793          	seqz	a5,a5
c000ccb8:	0ff7f793          	andi	a5,a5,255
c000ccbc:	0280006f          	j	c000cce4 <XUartNs550_IsSending+0x78>
	Xil_AssertNonvoid(InstancePtr != NULL);
c000ccc0:	1c700593          	li	a1,455
c000ccc4:	07ff3517          	auipc	a0,0x7ff3
c000ccc8:	51c50513          	addi	a0,a0,1308 # c80001e0 <__rodata_start+0x1e0>
c000cccc:	5f1100ef          	jal	ra,c001dabc <Xil_Assert>
c000ccd0:	07ff6797          	auipc	a5,0x7ff6
c000ccd4:	c4478793          	addi	a5,a5,-956 # c8002914 <Xil_AssertStatus>
c000ccd8:	00100713          	li	a4,1
c000ccdc:	00e7a023          	sw	a4,0(a5)
c000cce0:	00000793          	li	a5,0
}
c000cce4:	00078513          	mv	a0,a5
c000cce8:	02c12083          	lw	ra,44(sp)
c000ccec:	02812403          	lw	s0,40(sp)
c000ccf0:	03010113          	addi	sp,sp,48
c000ccf4:	00008067          	ret

c000ccf8 <ReadFcrRegister>:
*
* @note		None.
*
*****************************************************************************/
static u32 ReadFcrRegister(UINTPTR BaseAddress)
{
c000ccf8:	fd010113          	addi	sp,sp,-48
c000ccfc:	02112623          	sw	ra,44(sp)
c000cd00:	02812423          	sw	s0,40(sp)
c000cd04:	03010413          	addi	s0,sp,48
c000cd08:	fca42e23          	sw	a0,-36(s0)
	/*
	 * Enter a critical section here by disabling Uart interrupts.  We do
	 * not want to receive an interrupt while we have the FCR latched since
	 * the interrupt handler may want to read the IIR
	 */
	IerRegister = XUartNs550_ReadReg(BaseAddress, XUN_IER_OFFSET);
c000cd0c:	fdc42783          	lw	a5,-36(s0)
c000cd10:	00478793          	addi	a5,a5,4
c000cd14:	00078513          	mv	a0,a5
c000cd18:	f9cff0ef          	jal	ra,c000c4b4 <Xil_In32>
c000cd1c:	fea42623          	sw	a0,-20(s0)
	XUartNs550_WriteReg(BaseAddress, XUN_IER_OFFSET, 0);
c000cd20:	fdc42783          	lw	a5,-36(s0)
c000cd24:	00478793          	addi	a5,a5,4
c000cd28:	00000593          	li	a1,0
c000cd2c:	00078513          	mv	a0,a5
c000cd30:	facff0ef          	jal	ra,c000c4dc <Xil_Out32>
	/*
	 * Get the line control register contents and set the divisor latch
	 * access bit so the FIFO control register can be read, this can't
	 * be done with a true 16550, but is a feature in the Xilinx device
	 */
	LcrRegister = XUartNs550_GetLineControlReg(BaseAddress);
c000cd34:	fdc42783          	lw	a5,-36(s0)
c000cd38:	00c78793          	addi	a5,a5,12
c000cd3c:	00078513          	mv	a0,a5
c000cd40:	f74ff0ef          	jal	ra,c000c4b4 <Xil_In32>
c000cd44:	fea42423          	sw	a0,-24(s0)
	XUartNs550_SetLineControlReg(BaseAddress, LcrRegister | XUN_LCR_DLAB);
c000cd48:	fdc42783          	lw	a5,-36(s0)
c000cd4c:	00c78713          	addi	a4,a5,12
c000cd50:	fe842783          	lw	a5,-24(s0)
c000cd54:	0807e793          	ori	a5,a5,128
c000cd58:	00078593          	mv	a1,a5
c000cd5c:	00070513          	mv	a0,a4
c000cd60:	f7cff0ef          	jal	ra,c000c4dc <Xil_Out32>

	/*
	 * Read the FIFO control register so it can be returned
	 */
	FcrRegister = XUartNs550_ReadReg(BaseAddress, XUN_FCR_OFFSET);
c000cd64:	fdc42783          	lw	a5,-36(s0)
c000cd68:	00878793          	addi	a5,a5,8
c000cd6c:	00078513          	mv	a0,a5
c000cd70:	f44ff0ef          	jal	ra,c000c4b4 <Xil_In32>
c000cd74:	fea42223          	sw	a0,-28(s0)

	/*
	 * Restore the line control register to it's original contents such
	 * that the DLAB bit is no longer set and return the register
	 */
	XUartNs550_SetLineControlReg(BaseAddress, LcrRegister);
c000cd78:	fdc42783          	lw	a5,-36(s0)
c000cd7c:	00c78793          	addi	a5,a5,12
c000cd80:	fe842583          	lw	a1,-24(s0)
c000cd84:	00078513          	mv	a0,a5
c000cd88:	f54ff0ef          	jal	ra,c000c4dc <Xil_Out32>

	/*
	 * Exit the critical section by restoring the IER
	 */
	XUartNs550_WriteReg(BaseAddress, XUN_IER_OFFSET, IerRegister);
c000cd8c:	fdc42783          	lw	a5,-36(s0)
c000cd90:	00478793          	addi	a5,a5,4
c000cd94:	fec42583          	lw	a1,-20(s0)
c000cd98:	00078513          	mv	a0,a5
c000cd9c:	f40ff0ef          	jal	ra,c000c4dc <Xil_Out32>

	return FcrRegister;
c000cda0:	fe442783          	lw	a5,-28(s0)
}
c000cda4:	00078513          	mv	a0,a5
c000cda8:	02c12083          	lw	ra,44(sp)
c000cdac:	02812403          	lw	s0,40(sp)
c000cdb0:	03010113          	addi	sp,sp,48
c000cdb4:	00008067          	ret

c000cdb8 <Xil_In32>:
{
c000cdb8:	fe010113          	addi	sp,sp,-32
c000cdbc:	00812e23          	sw	s0,28(sp)
c000cdc0:	02010413          	addi	s0,sp,32
c000cdc4:	fea42623          	sw	a0,-20(s0)
	return *(volatile u32 *) Addr;
c000cdc8:	fec42783          	lw	a5,-20(s0)
c000cdcc:	0007a783          	lw	a5,0(a5)
}
c000cdd0:	00078513          	mv	a0,a5
c000cdd4:	01c12403          	lw	s0,28(sp)
c000cdd8:	02010113          	addi	sp,sp,32
c000cddc:	00008067          	ret

c000cde0 <Xil_Out32>:
{
c000cde0:	fd010113          	addi	sp,sp,-48
c000cde4:	02812623          	sw	s0,44(sp)
c000cde8:	03010413          	addi	s0,sp,48
c000cdec:	fca42e23          	sw	a0,-36(s0)
c000cdf0:	fcb42c23          	sw	a1,-40(s0)
	volatile u32 *LocalAddr = (volatile u32 *)Addr;
c000cdf4:	fdc42783          	lw	a5,-36(s0)
c000cdf8:	fef42623          	sw	a5,-20(s0)
	*LocalAddr = Value;
c000cdfc:	fec42783          	lw	a5,-20(s0)
c000ce00:	fd842703          	lw	a4,-40(s0)
c000ce04:	00e7a023          	sw	a4,0(a5)
}
c000ce08:	00000013          	nop
c000ce0c:	02c12403          	lw	s0,44(sp)
c000ce10:	03010113          	addi	sp,sp,48
c000ce14:	00008067          	ret

c000ce18 <XUartNs550_SetHandler>:
* is (nor should it)
*
*****************************************************************************/
void XUartNs550_SetHandler(XUartNs550 *InstancePtr,
				XUartNs550_Handler FuncPtr, void *CallBackRef)
{
c000ce18:	fe010113          	addi	sp,sp,-32
c000ce1c:	00112e23          	sw	ra,28(sp)
c000ce20:	00812c23          	sw	s0,24(sp)
c000ce24:	02010413          	addi	s0,sp,32
c000ce28:	fea42623          	sw	a0,-20(s0)
c000ce2c:	feb42423          	sw	a1,-24(s0)
c000ce30:	fec42223          	sw	a2,-28(s0)
	/*
	 * Assert validates the input arguments
	 * CallBackRef not checked, no way to know what is valid
	 */

	Xil_AssertVoid(InstancePtr != NULL);
c000ce34:	fec42783          	lw	a5,-20(s0)
c000ce38:	00078e63          	beqz	a5,c000ce54 <XUartNs550_SetHandler+0x3c>
c000ce3c:	07ff6797          	auipc	a5,0x7ff6
c000ce40:	ad878793          	addi	a5,a5,-1320 # c8002914 <Xil_AssertStatus>
c000ce44:	0007a023          	sw	zero,0(a5)
	Xil_AssertVoid(FuncPtr != NULL);
c000ce48:	fe842783          	lw	a5,-24(s0)
c000ce4c:	04078863          	beqz	a5,c000ce9c <XUartNs550_SetHandler+0x84>
c000ce50:	0280006f          	j	c000ce78 <XUartNs550_SetHandler+0x60>
	Xil_AssertVoid(InstancePtr != NULL);
c000ce54:	08700593          	li	a1,135
c000ce58:	07ff3517          	auipc	a0,0x7ff3
c000ce5c:	3b450513          	addi	a0,a0,948 # c800020c <__rodata_start+0x20c>
c000ce60:	45d100ef          	jal	ra,c001dabc <Xil_Assert>
c000ce64:	07ff6797          	auipc	a5,0x7ff6
c000ce68:	ab078793          	addi	a5,a5,-1360 # c8002914 <Xil_AssertStatus>
c000ce6c:	00100713          	li	a4,1
c000ce70:	00e7a023          	sw	a4,0(a5)
c000ce74:	0980006f          	j	c000cf0c <XUartNs550_SetHandler+0xf4>
	Xil_AssertVoid(FuncPtr != NULL);
c000ce78:	07ff6797          	auipc	a5,0x7ff6
c000ce7c:	a9c78793          	addi	a5,a5,-1380 # c8002914 <Xil_AssertStatus>
c000ce80:	0007a023          	sw	zero,0(a5)
	Xil_AssertVoid(InstancePtr->IsReady == XIL_COMPONENT_IS_READY);
c000ce84:	fec42783          	lw	a5,-20(s0)
c000ce88:	01c7a703          	lw	a4,28(a5)
c000ce8c:	111117b7          	lui	a5,0x11111
c000ce90:	11178793          	addi	a5,a5,273 # 11111111 <_DMEM_LENGTH+0x10911111>
c000ce94:	04f71a63          	bne	a4,a5,c000cee8 <XUartNs550_SetHandler+0xd0>
c000ce98:	0280006f          	j	c000cec0 <XUartNs550_SetHandler+0xa8>
	Xil_AssertVoid(FuncPtr != NULL);
c000ce9c:	08800593          	li	a1,136
c000cea0:	07ff3517          	auipc	a0,0x7ff3
c000cea4:	36c50513          	addi	a0,a0,876 # c800020c <__rodata_start+0x20c>
c000cea8:	415100ef          	jal	ra,c001dabc <Xil_Assert>
c000ceac:	07ff6797          	auipc	a5,0x7ff6
c000ceb0:	a6878793          	addi	a5,a5,-1432 # c8002914 <Xil_AssertStatus>
c000ceb4:	00100713          	li	a4,1
c000ceb8:	00e7a023          	sw	a4,0(a5)
c000cebc:	0500006f          	j	c000cf0c <XUartNs550_SetHandler+0xf4>
	Xil_AssertVoid(InstancePtr->IsReady == XIL_COMPONENT_IS_READY);
c000cec0:	07ff6797          	auipc	a5,0x7ff6
c000cec4:	a5478793          	addi	a5,a5,-1452 # c8002914 <Xil_AssertStatus>
c000cec8:	0007a023          	sw	zero,0(a5)

	InstancePtr->Handler = FuncPtr;
c000cecc:	fec42783          	lw	a5,-20(s0)
c000ced0:	fe842703          	lw	a4,-24(s0)
c000ced4:	04e7a023          	sw	a4,64(a5)
	InstancePtr->CallBackRef = CallBackRef;
c000ced8:	fec42783          	lw	a5,-20(s0)
c000cedc:	fe442703          	lw	a4,-28(s0)
c000cee0:	04e7a223          	sw	a4,68(a5)
c000cee4:	0280006f          	j	c000cf0c <XUartNs550_SetHandler+0xf4>
	Xil_AssertVoid(InstancePtr->IsReady == XIL_COMPONENT_IS_READY);
c000cee8:	08900593          	li	a1,137
c000ceec:	07ff3517          	auipc	a0,0x7ff3
c000cef0:	32050513          	addi	a0,a0,800 # c800020c <__rodata_start+0x20c>
c000cef4:	3c9100ef          	jal	ra,c001dabc <Xil_Assert>
c000cef8:	07ff6797          	auipc	a5,0x7ff6
c000cefc:	a1c78793          	addi	a5,a5,-1508 # c8002914 <Xil_AssertStatus>
c000cf00:	00100713          	li	a4,1
c000cf04:	00e7a023          	sw	a4,0(a5)
c000cf08:	00000013          	nop
}
c000cf0c:	01c12083          	lw	ra,28(sp)
c000cf10:	01812403          	lw	s0,24(sp)
c000cf14:	02010113          	addi	sp,sp,32
c000cf18:	00008067          	ret

c000cf1c <XUartNs550_InterruptHandler>:
*
* @note		None.
*
******************************************************************************/
void XUartNs550_InterruptHandler(XUartNs550 *InstancePtr)
{
c000cf1c:	fd010113          	addi	sp,sp,-48
c000cf20:	02112623          	sw	ra,44(sp)
c000cf24:	02812423          	sw	s0,40(sp)
c000cf28:	03010413          	addi	s0,sp,48
c000cf2c:	fca42e23          	sw	a0,-36(s0)
	u8 IsrStatus;

	Xil_AssertVoid(InstancePtr != NULL);
c000cf30:	fdc42783          	lw	a5,-36(s0)
c000cf34:	04078a63          	beqz	a5,c000cf88 <XUartNs550_InterruptHandler+0x6c>
c000cf38:	07ff6797          	auipc	a5,0x7ff6
c000cf3c:	9dc78793          	addi	a5,a5,-1572 # c8002914 <Xil_AssertStatus>
c000cf40:	0007a023          	sw	zero,0(a5)

	/*
	 * Read the interrupt ID register to determine which, only one,
	 * interrupt is active
	 */
	IsrStatus = (u8)XUartNs550_ReadReg(InstancePtr->BaseAddress,
c000cf44:	fdc42783          	lw	a5,-36(s0)
c000cf48:	0147a783          	lw	a5,20(a5)
c000cf4c:	00878793          	addi	a5,a5,8
c000cf50:	00078513          	mv	a0,a5
c000cf54:	e65ff0ef          	jal	ra,c000cdb8 <Xil_In32>
c000cf58:	00050793          	mv	a5,a0
					XUN_IIR_OFFSET) &
c000cf5c:	0ff7f793          	andi	a5,a5,255
	IsrStatus = (u8)XUartNs550_ReadReg(InstancePtr->BaseAddress,
c000cf60:	00f7f793          	andi	a5,a5,15
c000cf64:	fef407a3          	sb	a5,-17(s0)

	/*
	 * Make sure the handler table has a handler defined for the interrupt
	 * that is active, and then call the handler
	 */
	Xil_AssertVoid(HandlerTable[IsrStatus] != NULL);
c000cf68:	fef44783          	lbu	a5,-17(s0)
c000cf6c:	07ff6717          	auipc	a4,0x7ff6
c000cf70:	ab870713          	addi	a4,a4,-1352 # c8002a24 <HandlerTable>
c000cf74:	00279793          	slli	a5,a5,0x2
c000cf78:	00f707b3          	add	a5,a4,a5
c000cf7c:	0007a783          	lw	a5,0(a5)
c000cf80:	04078e63          	beqz	a5,c000cfdc <XUartNs550_InterruptHandler+0xc0>
c000cf84:	0280006f          	j	c000cfac <XUartNs550_InterruptHandler+0x90>
	Xil_AssertVoid(InstancePtr != NULL);
c000cf88:	0a400593          	li	a1,164
c000cf8c:	07ff3517          	auipc	a0,0x7ff3
c000cf90:	28050513          	addi	a0,a0,640 # c800020c <__rodata_start+0x20c>
c000cf94:	329100ef          	jal	ra,c001dabc <Xil_Assert>
c000cf98:	07ff6797          	auipc	a5,0x7ff6
c000cf9c:	97c78793          	addi	a5,a5,-1668 # c8002914 <Xil_AssertStatus>
c000cfa0:	00100713          	li	a4,1
c000cfa4:	00e7a023          	sw	a4,0(a5)
c000cfa8:	0580006f          	j	c000d000 <XUartNs550_InterruptHandler+0xe4>
	Xil_AssertVoid(HandlerTable[IsrStatus] != NULL);
c000cfac:	07ff6797          	auipc	a5,0x7ff6
c000cfb0:	96878793          	addi	a5,a5,-1688 # c8002914 <Xil_AssertStatus>
c000cfb4:	0007a023          	sw	zero,0(a5)

	HandlerTable[IsrStatus](InstancePtr);
c000cfb8:	fef44783          	lbu	a5,-17(s0)
c000cfbc:	07ff6717          	auipc	a4,0x7ff6
c000cfc0:	a6870713          	addi	a4,a4,-1432 # c8002a24 <HandlerTable>
c000cfc4:	00279793          	slli	a5,a5,0x2
c000cfc8:	00f707b3          	add	a5,a4,a5
c000cfcc:	0007a783          	lw	a5,0(a5)
c000cfd0:	fdc42503          	lw	a0,-36(s0)
c000cfd4:	000780e7          	jalr	a5
c000cfd8:	0280006f          	j	c000d000 <XUartNs550_InterruptHandler+0xe4>
	Xil_AssertVoid(HandlerTable[IsrStatus] != NULL);
c000cfdc:	0b200593          	li	a1,178
c000cfe0:	07ff3517          	auipc	a0,0x7ff3
c000cfe4:	22c50513          	addi	a0,a0,556 # c800020c <__rodata_start+0x20c>
c000cfe8:	2d5100ef          	jal	ra,c001dabc <Xil_Assert>
c000cfec:	07ff6797          	auipc	a5,0x7ff6
c000cff0:	92878793          	addi	a5,a5,-1752 # c8002914 <Xil_AssertStatus>
c000cff4:	00100713          	li	a4,1
c000cff8:	00e7a023          	sw	a4,0(a5)
c000cffc:	00000013          	nop
}
c000d000:	02c12083          	lw	ra,44(sp)
c000d004:	02812403          	lw	s0,40(sp)
c000d008:	03010113          	addi	sp,sp,48
c000d00c:	00008067          	ret

c000d010 <NoInterruptHandler>:
* The LsrRegister is volatile to ensure that optimization will not cause the
* statement to be optimized away.
*
*****************************************************************************/
static void NoInterruptHandler(XUartNs550 *InstancePtr)
{
c000d010:	fd010113          	addi	sp,sp,-48
c000d014:	02112623          	sw	ra,44(sp)
c000d018:	02812423          	sw	s0,40(sp)
c000d01c:	03010413          	addi	s0,sp,48
c000d020:	fca42e23          	sw	a0,-36(s0)
	volatile u32 LsrRegister;

	/*
	 * Reading the ID register clears the currently asserted interrupts
	 */
	LsrRegister = XUartNs550_GetLineStatusReg(InstancePtr->BaseAddress);
c000d024:	fdc42783          	lw	a5,-36(s0)
c000d028:	0147a783          	lw	a5,20(a5)
c000d02c:	01478793          	addi	a5,a5,20
c000d030:	00078513          	mv	a0,a5
c000d034:	d85ff0ef          	jal	ra,c000cdb8 <Xil_In32>
c000d038:	00050793          	mv	a5,a0
c000d03c:	fef42623          	sw	a5,-20(s0)

	/*
	 * Update the stats to reflect any errors that might be read
	 */
	XUartNs550_UpdateStats(InstancePtr, (u8)LsrRegister);
c000d040:	fec42783          	lw	a5,-20(s0)
c000d044:	0ff7f713          	andi	a4,a5,255
c000d048:	fdc42783          	lw	a5,-36(s0)
c000d04c:	0247c783          	lbu	a5,36(a5)
c000d050:	00f767b3          	or	a5,a4,a5
c000d054:	0ff7f713          	andi	a4,a5,255
c000d058:	fdc42783          	lw	a5,-36(s0)
c000d05c:	02e78223          	sb	a4,36(a5)
c000d060:	fec42783          	lw	a5,-20(s0)
c000d064:	0ff7f793          	andi	a5,a5,255
c000d068:	0027f793          	andi	a5,a5,2
c000d06c:	02078063          	beqz	a5,c000d08c <NoInterruptHandler+0x7c>
c000d070:	fdc42783          	lw	a5,-36(s0)
c000d074:	00c7d783          	lhu	a5,12(a5)
c000d078:	00178793          	addi	a5,a5,1
c000d07c:	01079713          	slli	a4,a5,0x10
c000d080:	01075713          	srli	a4,a4,0x10
c000d084:	fdc42783          	lw	a5,-36(s0)
c000d088:	00e79623          	sh	a4,12(a5)
c000d08c:	fec42783          	lw	a5,-20(s0)
c000d090:	0ff7f793          	andi	a5,a5,255
c000d094:	0047f793          	andi	a5,a5,4
c000d098:	02078063          	beqz	a5,c000d0b8 <NoInterruptHandler+0xa8>
c000d09c:	fdc42783          	lw	a5,-36(s0)
c000d0a0:	00e7d783          	lhu	a5,14(a5)
c000d0a4:	00178793          	addi	a5,a5,1
c000d0a8:	01079713          	slli	a4,a5,0x10
c000d0ac:	01075713          	srli	a4,a4,0x10
c000d0b0:	fdc42783          	lw	a5,-36(s0)
c000d0b4:	00e79723          	sh	a4,14(a5)
c000d0b8:	fec42783          	lw	a5,-20(s0)
c000d0bc:	0ff7f793          	andi	a5,a5,255
c000d0c0:	0087f793          	andi	a5,a5,8
c000d0c4:	02078063          	beqz	a5,c000d0e4 <NoInterruptHandler+0xd4>
c000d0c8:	fdc42783          	lw	a5,-36(s0)
c000d0cc:	0107d783          	lhu	a5,16(a5)
c000d0d0:	00178793          	addi	a5,a5,1
c000d0d4:	01079713          	slli	a4,a5,0x10
c000d0d8:	01075713          	srli	a4,a4,0x10
c000d0dc:	fdc42783          	lw	a5,-36(s0)
c000d0e0:	00e79823          	sh	a4,16(a5)
c000d0e4:	fec42783          	lw	a5,-20(s0)
c000d0e8:	0ff7f793          	andi	a5,a5,255
c000d0ec:	0107f793          	andi	a5,a5,16
c000d0f0:	02078063          	beqz	a5,c000d110 <NoInterruptHandler+0x100>
c000d0f4:	fdc42783          	lw	a5,-36(s0)
c000d0f8:	0127d783          	lhu	a5,18(a5)
c000d0fc:	00178793          	addi	a5,a5,1
c000d100:	01079713          	slli	a4,a5,0x10
c000d104:	01075713          	srli	a4,a4,0x10
c000d108:	fdc42783          	lw	a5,-36(s0)
c000d10c:	00e79923          	sh	a4,18(a5)
}
c000d110:	00000013          	nop
c000d114:	02c12083          	lw	ra,44(sp)
c000d118:	02812403          	lw	s0,40(sp)
c000d11c:	03010113          	addi	sp,sp,48
c000d120:	00008067          	ret

c000d124 <ReceiveStatusHandler>:
* this probably means data is being received that contains errors and the
* the user may need to clear the receive FIFOs to dump the data.
*
*****************************************************************************/
static void ReceiveStatusHandler(XUartNs550 *InstancePtr)
{
c000d124:	fd010113          	addi	sp,sp,-48
c000d128:	02112623          	sw	ra,44(sp)
c000d12c:	02812423          	sw	s0,40(sp)
c000d130:	03010413          	addi	s0,sp,48
c000d134:	fca42e23          	sw	a0,-36(s0)

	/*
	 * If there are bytes still to be received in the specified buffer
	 * go ahead and receive them
	 */
	if (InstancePtr->ReceiveBuffer.RemainingBytes != 0) {
c000d138:	fdc42783          	lw	a5,-36(s0)
c000d13c:	03c7a783          	lw	a5,60(a5)
c000d140:	00078863          	beqz	a5,c000d150 <ReceiveStatusHandler+0x2c>
		XUartNs550_ReceiveBuffer(InstancePtr);
c000d144:	fdc42503          	lw	a0,-36(s0)
c000d148:	801fe0ef          	jal	ra,c000b948 <XUartNs550_ReceiveBuffer>
c000d14c:	0ec0006f          	j	c000d238 <ReceiveStatusHandler+0x114>
		 * Reading the ID register clears the currently asserted
		 * interrupts and this must be done since there was no data
		 * to receive, update the status for the status read
		 */
		LsrRegister =
			XUartNs550_GetLineStatusReg(InstancePtr->BaseAddress);
c000d150:	fdc42783          	lw	a5,-36(s0)
c000d154:	0147a783          	lw	a5,20(a5)
c000d158:	01478793          	addi	a5,a5,20
c000d15c:	00078513          	mv	a0,a5
c000d160:	c59ff0ef          	jal	ra,c000cdb8 <Xil_In32>
c000d164:	fea42623          	sw	a0,-20(s0)
		XUartNs550_UpdateStats(InstancePtr, (u8)LsrRegister);
c000d168:	fdc42783          	lw	a5,-36(s0)
c000d16c:	0247c703          	lbu	a4,36(a5)
c000d170:	fec42783          	lw	a5,-20(s0)
c000d174:	0ff7f793          	andi	a5,a5,255
c000d178:	00f767b3          	or	a5,a4,a5
c000d17c:	0ff7f713          	andi	a4,a5,255
c000d180:	fdc42783          	lw	a5,-36(s0)
c000d184:	02e78223          	sb	a4,36(a5)
c000d188:	fec42783          	lw	a5,-20(s0)
c000d18c:	0ff7f793          	andi	a5,a5,255
c000d190:	0027f793          	andi	a5,a5,2
c000d194:	02078063          	beqz	a5,c000d1b4 <ReceiveStatusHandler+0x90>
c000d198:	fdc42783          	lw	a5,-36(s0)
c000d19c:	00c7d783          	lhu	a5,12(a5)
c000d1a0:	00178793          	addi	a5,a5,1
c000d1a4:	01079713          	slli	a4,a5,0x10
c000d1a8:	01075713          	srli	a4,a4,0x10
c000d1ac:	fdc42783          	lw	a5,-36(s0)
c000d1b0:	00e79623          	sh	a4,12(a5)
c000d1b4:	fec42783          	lw	a5,-20(s0)
c000d1b8:	0ff7f793          	andi	a5,a5,255
c000d1bc:	0047f793          	andi	a5,a5,4
c000d1c0:	02078063          	beqz	a5,c000d1e0 <ReceiveStatusHandler+0xbc>
c000d1c4:	fdc42783          	lw	a5,-36(s0)
c000d1c8:	00e7d783          	lhu	a5,14(a5)
c000d1cc:	00178793          	addi	a5,a5,1
c000d1d0:	01079713          	slli	a4,a5,0x10
c000d1d4:	01075713          	srli	a4,a4,0x10
c000d1d8:	fdc42783          	lw	a5,-36(s0)
c000d1dc:	00e79723          	sh	a4,14(a5)
c000d1e0:	fec42783          	lw	a5,-20(s0)
c000d1e4:	0ff7f793          	andi	a5,a5,255
c000d1e8:	0087f793          	andi	a5,a5,8
c000d1ec:	02078063          	beqz	a5,c000d20c <ReceiveStatusHandler+0xe8>
c000d1f0:	fdc42783          	lw	a5,-36(s0)
c000d1f4:	0107d783          	lhu	a5,16(a5)
c000d1f8:	00178793          	addi	a5,a5,1
c000d1fc:	01079713          	slli	a4,a5,0x10
c000d200:	01075713          	srli	a4,a4,0x10
c000d204:	fdc42783          	lw	a5,-36(s0)
c000d208:	00e79823          	sh	a4,16(a5)
c000d20c:	fec42783          	lw	a5,-20(s0)
c000d210:	0ff7f793          	andi	a5,a5,255
c000d214:	0107f793          	andi	a5,a5,16
c000d218:	02078063          	beqz	a5,c000d238 <ReceiveStatusHandler+0x114>
c000d21c:	fdc42783          	lw	a5,-36(s0)
c000d220:	0127d783          	lhu	a5,18(a5)
c000d224:	00178793          	addi	a5,a5,1
c000d228:	01079713          	slli	a4,a5,0x10
c000d22c:	01075713          	srli	a4,a4,0x10
c000d230:	fdc42783          	lw	a5,-36(s0)
c000d234:	00e79923          	sh	a4,18(a5)
	/*
	 * Call the application handler to indicate that there is a receive
	 * error or a break interrupt, if the application cares about the
	 * error it call a function to get the last errors
	 */
	InstancePtr->Handler(InstancePtr->CallBackRef, XUN_EVENT_RECV_ERROR,
c000d238:	fdc42783          	lw	a5,-36(s0)
c000d23c:	0407a803          	lw	a6,64(a5)
c000d240:	fdc42783          	lw	a5,-36(s0)
c000d244:	0447a683          	lw	a3,68(a5)
				InstancePtr->ReceiveBuffer.RequestedBytes -
c000d248:	fdc42783          	lw	a5,-36(s0)
c000d24c:	0387a703          	lw	a4,56(a5)
				InstancePtr->ReceiveBuffer.RemainingBytes);
c000d250:	fdc42783          	lw	a5,-36(s0)
c000d254:	03c7a783          	lw	a5,60(a5)
	InstancePtr->Handler(InstancePtr->CallBackRef, XUN_EVENT_RECV_ERROR,
c000d258:	40f707b3          	sub	a5,a4,a5
c000d25c:	00078613          	mv	a2,a5
c000d260:	00400593          	li	a1,4
c000d264:	00068513          	mv	a0,a3
c000d268:	000800e7          	jalr	a6

	/*
	 * Update the receive stats to reflect the receive interrupt
	 */
	InstancePtr->Stats.StatusInterrupts++;
c000d26c:	fdc42783          	lw	a5,-36(s0)
c000d270:	0047d783          	lhu	a5,4(a5)
c000d274:	00178793          	addi	a5,a5,1
c000d278:	01079713          	slli	a4,a5,0x10
c000d27c:	01075713          	srli	a4,a4,0x10
c000d280:	fdc42783          	lw	a5,-36(s0)
c000d284:	00e79223          	sh	a4,4(a5)
}
c000d288:	00000013          	nop
c000d28c:	02c12083          	lw	ra,44(sp)
c000d290:	02812403          	lw	s0,40(sp)
c000d294:	03010113          	addi	sp,sp,48
c000d298:	00008067          	ret

c000d29c <ReceiveTimeoutHandler>:
*
* @note		None.
*
*****************************************************************************/
static void ReceiveTimeoutHandler(XUartNs550 *InstancePtr)
{
c000d29c:	fd010113          	addi	sp,sp,-48
c000d2a0:	02112623          	sw	ra,44(sp)
c000d2a4:	02812423          	sw	s0,40(sp)
c000d2a8:	03010413          	addi	s0,sp,48
c000d2ac:	fca42e23          	sw	a0,-36(s0)

	/*
	 * If there are bytes still to be received in the specified buffer
	 * go ahead and receive them
	 */
	if (InstancePtr->ReceiveBuffer.RemainingBytes != 0) {
c000d2b0:	fdc42783          	lw	a5,-36(s0)
c000d2b4:	03c7a783          	lw	a5,60(a5)
c000d2b8:	00078663          	beqz	a5,c000d2c4 <ReceiveTimeoutHandler+0x28>
		XUartNs550_ReceiveBuffer(InstancePtr);
c000d2bc:	fdc42503          	lw	a0,-36(s0)
c000d2c0:	e88fe0ef          	jal	ra,c000b948 <XUartNs550_ReceiveBuffer>
	 * not a receive timeout but the end of the buffer reached, a timeout
	 * normally occurs if # of bytes is not divisible by FIFO threshold,
	 * don't rely on previous test of remaining bytes since receive function
	 * updates it
	 */
	if (InstancePtr->ReceiveBuffer.RemainingBytes != 0) {
c000d2c4:	fdc42783          	lw	a5,-36(s0)
c000d2c8:	03c7a783          	lw	a5,60(a5)
c000d2cc:	00078863          	beqz	a5,c000d2dc <ReceiveTimeoutHandler+0x40>
		Event = XUN_EVENT_RECV_TIMEOUT;
c000d2d0:	00200793          	li	a5,2
c000d2d4:	fef42623          	sw	a5,-20(s0)
c000d2d8:	00c0006f          	j	c000d2e4 <ReceiveTimeoutHandler+0x48>
	} else {
		Event = XUN_EVENT_RECV_DATA;
c000d2dc:	00100793          	li	a5,1
c000d2e0:	fef42623          	sw	a5,-20(s0)

	/*
	 * Call the application handler to indicate that there is a receive
	 * timeout or data event
	 */
	InstancePtr->Handler(InstancePtr->CallBackRef, Event,
c000d2e4:	fdc42783          	lw	a5,-36(s0)
c000d2e8:	0407a803          	lw	a6,64(a5)
c000d2ec:	fdc42783          	lw	a5,-36(s0)
c000d2f0:	0447a683          	lw	a3,68(a5)
			 InstancePtr->ReceiveBuffer.RequestedBytes -
c000d2f4:	fdc42783          	lw	a5,-36(s0)
c000d2f8:	0387a703          	lw	a4,56(a5)
			 InstancePtr->ReceiveBuffer.RemainingBytes);
c000d2fc:	fdc42783          	lw	a5,-36(s0)
c000d300:	03c7a783          	lw	a5,60(a5)
	InstancePtr->Handler(InstancePtr->CallBackRef, Event,
c000d304:	40f707b3          	sub	a5,a4,a5
c000d308:	00078613          	mv	a2,a5
c000d30c:	fec42583          	lw	a1,-20(s0)
c000d310:	00068513          	mv	a0,a3
c000d314:	000800e7          	jalr	a6

	/*
	 * Update the receive stats to reflect the receive interrupt
	 */
	InstancePtr->Stats.ReceiveInterrupts++;
c000d318:	fdc42783          	lw	a5,-36(s0)
c000d31c:	0027d783          	lhu	a5,2(a5)
c000d320:	00178793          	addi	a5,a5,1
c000d324:	01079713          	slli	a4,a5,0x10
c000d328:	01075713          	srli	a4,a4,0x10
c000d32c:	fdc42783          	lw	a5,-36(s0)
c000d330:	00e79123          	sh	a4,2(a5)
}
c000d334:	00000013          	nop
c000d338:	02c12083          	lw	ra,44(sp)
c000d33c:	02812403          	lw	s0,40(sp)
c000d340:	03010113          	addi	sp,sp,48
c000d344:	00008067          	ret

c000d348 <ReceiveDataHandler>:
*
* @note		None.
*
*****************************************************************************/
static void ReceiveDataHandler(XUartNs550 *InstancePtr)
{
c000d348:	fd010113          	addi	sp,sp,-48
c000d34c:	02112623          	sw	ra,44(sp)
c000d350:	02812423          	sw	s0,40(sp)
c000d354:	03010413          	addi	s0,sp,48
c000d358:	fca42e23          	sw	a0,-36(s0)

	/*
	 * If there are bytes still to be received in the specified buffer
	 * go ahead and receive them
	 */
	if (InstancePtr->ReceiveBuffer.RemainingBytes != 0) {
c000d35c:	fdc42783          	lw	a5,-36(s0)
c000d360:	03c7a783          	lw	a5,60(a5)
c000d364:	00078663          	beqz	a5,c000d370 <ReceiveDataHandler+0x28>
		XUartNs550_ReceiveBuffer(InstancePtr);
c000d368:	fdc42503          	lw	a0,-36(s0)
c000d36c:	ddcfe0ef          	jal	ra,c000b948 <XUartNs550_ReceiveBuffer>
	}


	if (InstancePtr->ReceiveBuffer.RemainingBytes != 0) {
c000d370:	fdc42783          	lw	a5,-36(s0)
c000d374:	03c7a783          	lw	a5,60(a5)
c000d378:	00078863          	beqz	a5,c000d388 <ReceiveDataHandler+0x40>
		 * If there are more bytes to receive then indicate that this is
		 * a Receive Timeout.
		 * This happens in the case the number of bytes received equal
		 * to the FIFO threshold as the Timeout Interrupt is masked
		 */
		Event = XUN_EVENT_RECV_TIMEOUT;
c000d37c:	00200793          	li	a5,2
c000d380:	fef42623          	sw	a5,-20(s0)
c000d384:	00c0006f          	j	c000d390 <ReceiveDataHandler+0x48>

		/*
		 * If the last byte of a message was received then call the
		 * application handler
		 */
		Event = XUN_EVENT_RECV_DATA;
c000d388:	00100793          	li	a5,1
c000d38c:	fef42623          	sw	a5,-20(s0)

	/*
	 * Call the application handler to indicate that there is a receive
	 * timeout or data event
	 */
	InstancePtr->Handler(InstancePtr->CallBackRef, Event,
c000d390:	fdc42783          	lw	a5,-36(s0)
c000d394:	0407a803          	lw	a6,64(a5)
c000d398:	fdc42783          	lw	a5,-36(s0)
c000d39c:	0447a683          	lw	a3,68(a5)
			 InstancePtr->ReceiveBuffer.RequestedBytes -
c000d3a0:	fdc42783          	lw	a5,-36(s0)
c000d3a4:	0387a703          	lw	a4,56(a5)
			 InstancePtr->ReceiveBuffer.RemainingBytes);
c000d3a8:	fdc42783          	lw	a5,-36(s0)
c000d3ac:	03c7a783          	lw	a5,60(a5)
	InstancePtr->Handler(InstancePtr->CallBackRef, Event,
c000d3b0:	40f707b3          	sub	a5,a4,a5
c000d3b4:	00078613          	mv	a2,a5
c000d3b8:	fec42583          	lw	a1,-20(s0)
c000d3bc:	00068513          	mv	a0,a3
c000d3c0:	000800e7          	jalr	a6


	/*
	 * Update the receive stats to reflect the receive interrupt
	 */
	InstancePtr->Stats.ReceiveInterrupts++;
c000d3c4:	fdc42783          	lw	a5,-36(s0)
c000d3c8:	0027d783          	lhu	a5,2(a5)
c000d3cc:	00178793          	addi	a5,a5,1
c000d3d0:	01079713          	slli	a4,a5,0x10
c000d3d4:	01075713          	srli	a4,a4,0x10
c000d3d8:	fdc42783          	lw	a5,-36(s0)
c000d3dc:	00e79123          	sh	a4,2(a5)
}
c000d3e0:	00000013          	nop
c000d3e4:	02c12083          	lw	ra,44(sp)
c000d3e8:	02812403          	lw	s0,40(sp)
c000d3ec:	03010113          	addi	sp,sp,48
c000d3f0:	00008067          	ret

c000d3f4 <SendDataHandler>:
*
* @note		None.
*
*****************************************************************************/
static void SendDataHandler(XUartNs550 *InstancePtr)
{
c000d3f4:	fd010113          	addi	sp,sp,-48
c000d3f8:	02112623          	sw	ra,44(sp)
c000d3fc:	02812423          	sw	s0,40(sp)
c000d400:	03010413          	addi	s0,sp,48
c000d404:	fca42e23          	sw	a0,-36(s0)
	/*
	 * If there are not bytes to be sent from the specified buffer then
	 * disable the transmit interrupt so it will stop interrupting as it
	 * interrupts any time the FIFO is empty
	 */
	if (InstancePtr->SendBuffer.RemainingBytes == 0) {
c000d408:	fdc42783          	lw	a5,-36(s0)
c000d40c:	0307a783          	lw	a5,48(a5)
c000d410:	06079a63          	bnez	a5,c000d484 <SendDataHandler+0x90>
		IerRegister = XUartNs550_ReadReg(InstancePtr->BaseAddress,
c000d414:	fdc42783          	lw	a5,-36(s0)
c000d418:	0147a783          	lw	a5,20(a5)
c000d41c:	00478793          	addi	a5,a5,4
c000d420:	00078513          	mv	a0,a5
c000d424:	995ff0ef          	jal	ra,c000cdb8 <Xil_In32>
c000d428:	fea42623          	sw	a0,-20(s0)
							XUN_IER_OFFSET);
		XUartNs550_WriteReg(InstancePtr->BaseAddress, XUN_IER_OFFSET,
c000d42c:	fdc42783          	lw	a5,-36(s0)
c000d430:	0147a783          	lw	a5,20(a5)
c000d434:	00478713          	addi	a4,a5,4
c000d438:	fec42783          	lw	a5,-20(s0)
c000d43c:	ffd7f793          	andi	a5,a5,-3
c000d440:	00078593          	mv	a1,a5
c000d444:	00070513          	mv	a0,a4
c000d448:	999ff0ef          	jal	ra,c000cde0 <Xil_Out32>

		/*
		 * Call the application handler to indicate the data
		 * has been sent
		 */
		InstancePtr->Handler(InstancePtr->CallBackRef,
c000d44c:	fdc42783          	lw	a5,-36(s0)
c000d450:	0407a803          	lw	a6,64(a5)
c000d454:	fdc42783          	lw	a5,-36(s0)
c000d458:	0447a683          	lw	a3,68(a5)
				XUN_EVENT_SENT_DATA,
				InstancePtr->SendBuffer.RequestedBytes -
c000d45c:	fdc42783          	lw	a5,-36(s0)
c000d460:	02c7a703          	lw	a4,44(a5)
				InstancePtr->SendBuffer.RemainingBytes);
c000d464:	fdc42783          	lw	a5,-36(s0)
c000d468:	0307a783          	lw	a5,48(a5)
		InstancePtr->Handler(InstancePtr->CallBackRef,
c000d46c:	40f707b3          	sub	a5,a4,a5
c000d470:	00078613          	mv	a2,a5
c000d474:	00300593          	li	a1,3
c000d478:	00068513          	mv	a0,a3
c000d47c:	000800e7          	jalr	a6
c000d480:	00c0006f          	j	c000d48c <SendDataHandler+0x98>
	/*
	 * Otherwise there is still more data to send in the specified buffer
	 * so go ahead and send it
	 */
	else {
		XUartNs550_SendBuffer(InstancePtr);
c000d484:	fdc42503          	lw	a0,-36(s0)
c000d488:	b00fe0ef          	jal	ra,c000b788 <XUartNs550_SendBuffer>
	}

	/*
	 * Update the transmit stats to reflect the transmit interrupt
	 */
	InstancePtr->Stats.TransmitInterrupts++;
c000d48c:	fdc42783          	lw	a5,-36(s0)
c000d490:	0007d783          	lhu	a5,0(a5)
c000d494:	00178793          	addi	a5,a5,1
c000d498:	01079713          	slli	a4,a5,0x10
c000d49c:	01075713          	srli	a4,a4,0x10
c000d4a0:	fdc42783          	lw	a5,-36(s0)
c000d4a4:	00e79023          	sh	a4,0(a5)
}
c000d4a8:	00000013          	nop
c000d4ac:	02c12083          	lw	ra,44(sp)
c000d4b0:	02812403          	lw	s0,40(sp)
c000d4b4:	03010113          	addi	sp,sp,48
c000d4b8:	00008067          	ret

c000d4bc <ModemHandler>:
*
* @note		None.
*
*****************************************************************************/
static void ModemHandler(XUartNs550 *InstancePtr)
{
c000d4bc:	fd010113          	addi	sp,sp,-48
c000d4c0:	02112623          	sw	ra,44(sp)
c000d4c4:	02812423          	sw	s0,40(sp)
c000d4c8:	03010413          	addi	s0,sp,48
c000d4cc:	fca42e23          	sw	a0,-36(s0)

	/*
	 * Read the modem status register so that the interrupt is acknowledged
	 * and so that it can be passed to the callback handler with the event
	 */
	MsrRegister = XUartNs550_ReadReg(InstancePtr->BaseAddress,
c000d4d0:	fdc42783          	lw	a5,-36(s0)
c000d4d4:	0147a783          	lw	a5,20(a5)
c000d4d8:	01878793          	addi	a5,a5,24
c000d4dc:	00078513          	mv	a0,a5
c000d4e0:	8d9ff0ef          	jal	ra,c000cdb8 <Xil_In32>
c000d4e4:	fea42623          	sw	a0,-20(s0)

	/*
	 * Call the application handler to indicate the modem status changed,
	 * passing the modem status and the event data in the call
	 */
	InstancePtr->Handler(InstancePtr->CallBackRef, XUN_EVENT_MODEM,
c000d4e8:	fdc42783          	lw	a5,-36(s0)
c000d4ec:	0407a683          	lw	a3,64(a5)
c000d4f0:	fdc42783          	lw	a5,-36(s0)
c000d4f4:	0447a783          	lw	a5,68(a5)
						 (u8) MsrRegister);
c000d4f8:	fec42703          	lw	a4,-20(s0)
c000d4fc:	0ff77713          	andi	a4,a4,255
	InstancePtr->Handler(InstancePtr->CallBackRef, XUN_EVENT_MODEM,
c000d500:	00070613          	mv	a2,a4
c000d504:	00500593          	li	a1,5
c000d508:	00078513          	mv	a0,a5
c000d50c:	000680e7          	jalr	a3

	/*
	 * Update the modem stats to reflect the modem interrupt
	 */
	InstancePtr->Stats.ModemInterrupts++;
c000d510:	fdc42783          	lw	a5,-36(s0)
c000d514:	0067d783          	lhu	a5,6(a5)
c000d518:	00178793          	addi	a5,a5,1
c000d51c:	01079713          	slli	a4,a5,0x10
c000d520:	01075713          	srli	a4,a4,0x10
c000d524:	fdc42783          	lw	a5,-36(s0)
c000d528:	00e79323          	sh	a4,6(a5)
}
c000d52c:	00000013          	nop
c000d530:	02c12083          	lw	ra,44(sp)
c000d534:	02812403          	lw	s0,40(sp)
c000d538:	03010113          	addi	sp,sp,48
c000d53c:	00008067          	ret

c000d540 <Xil_In32>:
{
c000d540:	fe010113          	addi	sp,sp,-32
c000d544:	00812e23          	sw	s0,28(sp)
c000d548:	02010413          	addi	s0,sp,32
c000d54c:	fea42623          	sw	a0,-20(s0)
	return *(volatile u32 *) Addr;
c000d550:	fec42783          	lw	a5,-20(s0)
c000d554:	0007a783          	lw	a5,0(a5)
}
c000d558:	00078513          	mv	a0,a5
c000d55c:	01c12403          	lw	s0,28(sp)
c000d560:	02010113          	addi	sp,sp,32
c000d564:	00008067          	ret

c000d568 <Xil_Out32>:
{
c000d568:	fd010113          	addi	sp,sp,-48
c000d56c:	02812623          	sw	s0,44(sp)
c000d570:	03010413          	addi	s0,sp,48
c000d574:	fca42e23          	sw	a0,-36(s0)
c000d578:	fcb42c23          	sw	a1,-40(s0)
	volatile u32 *LocalAddr = (volatile u32 *)Addr;
c000d57c:	fdc42783          	lw	a5,-36(s0)
c000d580:	fef42623          	sw	a5,-20(s0)
	*LocalAddr = Value;
c000d584:	fec42783          	lw	a5,-20(s0)
c000d588:	fd842703          	lw	a4,-40(s0)
c000d58c:	00e7a023          	sw	a4,0(a5)
}
c000d590:	00000013          	nop
c000d594:	02c12403          	lw	s0,44(sp)
c000d598:	03010113          	addi	sp,sp,48
c000d59c:	00008067          	ret

c000d5a0 <XUartNs550_SendByte>:
*
* @note		None.
*
*****************************************************************************/
void XUartNs550_SendByte(UINTPTR BaseAddress, u8 Data)
{
c000d5a0:	fe010113          	addi	sp,sp,-32
c000d5a4:	00112e23          	sw	ra,28(sp)
c000d5a8:	00812c23          	sw	s0,24(sp)
c000d5ac:	02010413          	addi	s0,sp,32
c000d5b0:	fea42623          	sw	a0,-20(s0)
c000d5b4:	00058793          	mv	a5,a1
c000d5b8:	fef405a3          	sb	a5,-21(s0)
	/*
	 * Wait til we know that the byte can be sent, the 550 does not have any
	 * way to tell how much room is in the FIFO such that we must wait for
	 * it to be empty
	 */
	while (!XUartNs550_IsTransmitEmpty(BaseAddress));
c000d5bc:	00000013          	nop
c000d5c0:	fec42783          	lw	a5,-20(s0)
c000d5c4:	01478793          	addi	a5,a5,20
c000d5c8:	00078513          	mv	a0,a5
c000d5cc:	f75ff0ef          	jal	ra,c000d540 <Xil_In32>
c000d5d0:	00050793          	mv	a5,a0
c000d5d4:	0207f793          	andi	a5,a5,32
c000d5d8:	fe0784e3          	beqz	a5,c000d5c0 <XUartNs550_SendByte+0x20>

	/*
	 * Write the data byte to the UART to be transmitted
	 */
	XUartNs550_WriteReg(BaseAddress, XUN_THR_OFFSET, (u32)Data);
c000d5dc:	feb44783          	lbu	a5,-21(s0)
c000d5e0:	00078593          	mv	a1,a5
c000d5e4:	fec42503          	lw	a0,-20(s0)
c000d5e8:	f81ff0ef          	jal	ra,c000d568 <Xil_Out32>
}
c000d5ec:	00000013          	nop
c000d5f0:	01c12083          	lw	ra,28(sp)
c000d5f4:	01812403          	lw	s0,24(sp)
c000d5f8:	02010113          	addi	sp,sp,32
c000d5fc:	00008067          	ret

c000d600 <XUartNs550_RecvByte>:
*
* @note		None.
*
*****************************************************************************/
u8 XUartNs550_RecvByte(UINTPTR BaseAddress)
{
c000d600:	fe010113          	addi	sp,sp,-32
c000d604:	00112e23          	sw	ra,28(sp)
c000d608:	00812c23          	sw	s0,24(sp)
c000d60c:	02010413          	addi	s0,sp,32
c000d610:	fea42623          	sw	a0,-20(s0)
	/*
	 * Wait for there to be data received
	 */
	while (!XUartNs550_IsReceiveData(BaseAddress));
c000d614:	00000013          	nop
c000d618:	fec42783          	lw	a5,-20(s0)
c000d61c:	01478793          	addi	a5,a5,20
c000d620:	00078513          	mv	a0,a5
c000d624:	f1dff0ef          	jal	ra,c000d540 <Xil_In32>
c000d628:	00050793          	mv	a5,a0
c000d62c:	0017f793          	andi	a5,a5,1
c000d630:	fe0784e3          	beqz	a5,c000d618 <XUartNs550_RecvByte+0x18>

	/*
	 * Return the next data byte the UART received
	 */
	return (u8) XUartNs550_ReadReg(BaseAddress, XUN_RBR_OFFSET);
c000d634:	fec42503          	lw	a0,-20(s0)
c000d638:	f09ff0ef          	jal	ra,c000d540 <Xil_In32>
c000d63c:	00050793          	mv	a5,a0
c000d640:	0ff7f793          	andi	a5,a5,255
}
c000d644:	00078513          	mv	a0,a5
c000d648:	01c12083          	lw	ra,28(sp)
c000d64c:	01812403          	lw	s0,24(sp)
c000d650:	02010113          	addi	sp,sp,32
c000d654:	00008067          	ret

c000d658 <XUartNs550_SetBaud>:
*
* @note		None.
*
*****************************************************************************/
void XUartNs550_SetBaud(UINTPTR BaseAddress, u32 InputClockHz, u32 BaudRate)
{
c000d658:	fd010113          	addi	sp,sp,-48
c000d65c:	02112623          	sw	ra,44(sp)
c000d660:	02812423          	sw	s0,40(sp)
c000d664:	03010413          	addi	s0,sp,48
c000d668:	fca42e23          	sw	a0,-36(s0)
c000d66c:	fcb42c23          	sw	a1,-40(s0)
c000d670:	fcc42a23          	sw	a2,-44(s0)
	/*
	 * Determine what the divisor should be to get the specified baud
	 * rater based upon the input clock frequency and a baud clock prescaler
	 * of 16
	 */
	Divisor = ((InputClockHz +((BaudRate * 16UL)/2)) /
c000d674:	fd442783          	lw	a5,-44(s0)
c000d678:	00479793          	slli	a5,a5,0x4
c000d67c:	0017d713          	srli	a4,a5,0x1
c000d680:	fd842783          	lw	a5,-40(s0)
c000d684:	00f70733          	add	a4,a4,a5
			(BaudRate * 16UL));
c000d688:	fd442783          	lw	a5,-44(s0)
c000d68c:	00479793          	slli	a5,a5,0x4
	Divisor = ((InputClockHz +((BaudRate * 16UL)/2)) /
c000d690:	02f757b3          	divu	a5,a4,a5
c000d694:	fef42623          	sw	a5,-20(s0)
	/*
	 * Get the least significant and most significant bytes of the divisor
	 * so they can be written to 2 byte registers
	 */
	BaudLSB = Divisor & XUN_DIVISOR_BYTE_MASK;
c000d698:	fec42783          	lw	a5,-20(s0)
c000d69c:	0ff7f793          	andi	a5,a5,255
c000d6a0:	fef42423          	sw	a5,-24(s0)
	BaudMSB = (Divisor >> 8) & XUN_DIVISOR_BYTE_MASK;
c000d6a4:	fec42783          	lw	a5,-20(s0)
c000d6a8:	0087d793          	srli	a5,a5,0x8
c000d6ac:	0ff7f793          	andi	a5,a5,255
c000d6b0:	fef42223          	sw	a5,-28(s0)

	/*
	 * Get the line control register contents and set the divisor latch
	 * access bit so the baud rate can be set
	 */
	LcrRegister = XUartNs550_GetLineControlReg(BaseAddress);
c000d6b4:	fdc42783          	lw	a5,-36(s0)
c000d6b8:	00c78793          	addi	a5,a5,12
c000d6bc:	00078513          	mv	a0,a5
c000d6c0:	e81ff0ef          	jal	ra,c000d540 <Xil_In32>
c000d6c4:	fea42023          	sw	a0,-32(s0)
	XUartNs550_SetLineControlReg(BaseAddress,
c000d6c8:	fdc42783          	lw	a5,-36(s0)
c000d6cc:	00c78713          	addi	a4,a5,12
c000d6d0:	fe042783          	lw	a5,-32(s0)
c000d6d4:	0807e793          	ori	a5,a5,128
c000d6d8:	00078593          	mv	a1,a5
c000d6dc:	00070513          	mv	a0,a4
c000d6e0:	e89ff0ef          	jal	ra,c000d568 <Xil_Out32>
	/*
	 * Set the baud Divisors to set rate, the initial write of 0xFF is to
	 * keep the divisor from being 0 which is not recommended as per the
	 * NS16550D spec sheet
	 */
	XUartNs550_WriteReg(BaseAddress, XUN_DRLS_OFFSET, 0xFF);
c000d6e4:	0ff00593          	li	a1,255
c000d6e8:	fdc42503          	lw	a0,-36(s0)
c000d6ec:	e7dff0ef          	jal	ra,c000d568 <Xil_Out32>
	XUartNs550_WriteReg(BaseAddress, XUN_DRLM_OFFSET, BaudMSB);
c000d6f0:	fdc42783          	lw	a5,-36(s0)
c000d6f4:	00478793          	addi	a5,a5,4
c000d6f8:	fe442583          	lw	a1,-28(s0)
c000d6fc:	00078513          	mv	a0,a5
c000d700:	e69ff0ef          	jal	ra,c000d568 <Xil_Out32>
	XUartNs550_WriteReg(BaseAddress, XUN_DRLS_OFFSET, BaudLSB);
c000d704:	fe842583          	lw	a1,-24(s0)
c000d708:	fdc42503          	lw	a0,-36(s0)
c000d70c:	e5dff0ef          	jal	ra,c000d568 <Xil_Out32>

	/*
	 * Clear the Divisor latch access bit, DLAB to allow nornal
	 * operation and write to the line control register
	 */
	XUartNs550_SetLineControlReg(BaseAddress, LcrRegister);
c000d710:	fdc42783          	lw	a5,-36(s0)
c000d714:	00c78793          	addi	a5,a5,12
c000d718:	fe042583          	lw	a1,-32(s0)
c000d71c:	00078513          	mv	a0,a5
c000d720:	e49ff0ef          	jal	ra,c000d568 <Xil_Out32>
}
c000d724:	00000013          	nop
c000d728:	02c12083          	lw	ra,44(sp)
c000d72c:	02812403          	lw	s0,40(sp)
c000d730:	03010113          	addi	sp,sp,48
c000d734:	00008067          	ret

c000d738 <XAxiDma_BdSetLength>:
 *
 * @note	This function can be used only when DMA is in SG mode
 *
 *****************************************************************************/
int XAxiDma_BdSetLength(XAxiDma_Bd *BdPtr, u32 LenBytes, u32 LengthMask)
{
c000d738:	fe010113          	addi	sp,sp,-32
c000d73c:	00112e23          	sw	ra,28(sp)
c000d740:	00812c23          	sw	s0,24(sp)
c000d744:	02010413          	addi	s0,sp,32
c000d748:	fea42623          	sw	a0,-20(s0)
c000d74c:	feb42423          	sw	a1,-24(s0)
c000d750:	fec42223          	sw	a2,-28(s0)
	if (LenBytes <= 0 || (LenBytes > LengthMask)) {
c000d754:	fe842783          	lw	a5,-24(s0)
c000d758:	00078863          	beqz	a5,c000d768 <XAxiDma_BdSetLength+0x30>
c000d75c:	fe842703          	lw	a4,-24(s0)
c000d760:	fe442783          	lw	a5,-28(s0)
c000d764:	02e7f063          	bgeu	a5,a4,c000d784 <XAxiDma_BdSetLength+0x4c>

		printf("invalid length %d\n",
c000d768:	fe842783          	lw	a5,-24(s0)
c000d76c:	00078593          	mv	a1,a5
c000d770:	07ff3517          	auipc	a0,0x7ff3
c000d774:	ac450513          	addi	a0,a0,-1340 # c8000234 <__rodata_start+0x234>
c000d778:	62c100ef          	jal	ra,c001dda4 <printf>
		    (int)LenBytes);

		return XST_INVALID_PARAM;
c000d77c:	00f00793          	li	a5,15
c000d780:	0380006f          	j	c000d7b8 <XAxiDma_BdSetLength+0x80>
	}

	XAxiDma_BdWrite((BdPtr), XAXIDMA_BD_CTRL_LEN_OFFSET,
c000d784:	fec42783          	lw	a5,-20(s0)
c000d788:	01878793          	addi	a5,a5,24
c000d78c:	0007a703          	lw	a4,0(a5)
c000d790:	fe442783          	lw	a5,-28(s0)
c000d794:	fff7c793          	not	a5,a5
c000d798:	00f77733          	and	a4,a4,a5
c000d79c:	fec42783          	lw	a5,-20(s0)
c000d7a0:	01878793          	addi	a5,a5,24
c000d7a4:	00078693          	mv	a3,a5
c000d7a8:	fe842783          	lw	a5,-24(s0)
c000d7ac:	00f767b3          	or	a5,a4,a5
c000d7b0:	00f6a023          	sw	a5,0(a3)
		((XAxiDma_BdRead((BdPtr), XAXIDMA_BD_CTRL_LEN_OFFSET) & \
		~LengthMask)) | LenBytes);

	return XST_SUCCESS;
c000d7b4:	00000793          	li	a5,0
}
c000d7b8:	00078513          	mv	a0,a5
c000d7bc:	01c12083          	lw	ra,28(sp)
c000d7c0:	01812403          	lw	s0,24(sp)
c000d7c4:	02010113          	addi	sp,sp,32
c000d7c8:	00008067          	ret

c000d7cc <XAxiDma_BdSetBufAddr>:
 *
 * @note	This function can be used only when DMA is in SG mode
 *
 *****************************************************************************/
u32 XAxiDma_BdSetBufAddr(XAxiDma_Bd* BdPtr, UINTPTR Addr)
{
c000d7cc:	fd010113          	addi	sp,sp,-48
c000d7d0:	02112623          	sw	ra,44(sp)
c000d7d4:	02812423          	sw	s0,40(sp)
c000d7d8:	03010413          	addi	s0,sp,48
c000d7dc:	fca42e23          	sw	a0,-36(s0)
c000d7e0:	fcb42c23          	sw	a1,-40(s0)
	u32 HasDRE;
	u8 WordLen;

	HasDRE = XAxiDma_BdRead(BdPtr, XAXIDMA_BD_HAS_DRE_OFFSET);
c000d7e4:	fdc42783          	lw	a5,-36(s0)
c000d7e8:	03c78793          	addi	a5,a5,60
c000d7ec:	0007a783          	lw	a5,0(a5)
c000d7f0:	fef42623          	sw	a5,-20(s0)
	WordLen = HasDRE & XAXIDMA_BD_WORDLEN_MASK;
c000d7f4:	fec42783          	lw	a5,-20(s0)
c000d7f8:	fef405a3          	sb	a5,-21(s0)

	if (Addr & (WordLen - 1)) {
c000d7fc:	feb44783          	lbu	a5,-21(s0)
c000d800:	fff78793          	addi	a5,a5,-1
c000d804:	00078713          	mv	a4,a5
c000d808:	fd842783          	lw	a5,-40(s0)
c000d80c:	00f777b3          	and	a5,a4,a5
c000d810:	04078c63          	beqz	a5,c000d868 <XAxiDma_BdSetBufAddr+0x9c>
		if ((HasDRE & XAXIDMA_BD_HAS_DRE_MASK) == 0) {
c000d814:	fec42703          	lw	a4,-20(s0)
c000d818:	000017b7          	lui	a5,0x1
c000d81c:	f0078793          	addi	a5,a5,-256 # f00 <_STACK_SIZE-0x100>
c000d820:	00f777b3          	and	a5,a4,a5
c000d824:	04079263          	bnez	a5,c000d868 <XAxiDma_BdSetBufAddr+0x9c>
			printf("Error set buf addr %x with %x and %x,"
			" %x\r\n",(unsigned int)Addr, (unsigned int)HasDRE, (unsigned int)(WordLen - 1),
c000d828:	feb44783          	lbu	a5,-21(s0)
c000d82c:	fff78793          	addi	a5,a5,-1
			printf("Error set buf addr %x with %x and %x,"
c000d830:	00078693          	mv	a3,a5
			(unsigned int)Addr & (WordLen - 1));
c000d834:	feb44783          	lbu	a5,-21(s0)
c000d838:	fff78793          	addi	a5,a5,-1
c000d83c:	00078713          	mv	a4,a5
			printf("Error set buf addr %x with %x and %x,"
c000d840:	fd842783          	lw	a5,-40(s0)
c000d844:	00f777b3          	and	a5,a4,a5
c000d848:	00078713          	mv	a4,a5
c000d84c:	fec42603          	lw	a2,-20(s0)
c000d850:	fd842583          	lw	a1,-40(s0)
c000d854:	07ff3517          	auipc	a0,0x7ff3
c000d858:	9f450513          	addi	a0,a0,-1548 # c8000248 <__rodata_start+0x248>
c000d85c:	548100ef          	jal	ra,c001dda4 <printf>

			return XST_INVALID_PARAM;
c000d860:	00f00793          	li	a5,15
c000d864:	01c0006f          	j	c000d880 <XAxiDma_BdSetBufAddr+0xb4>
	}

#if defined(__aarch64__) || defined(__arch64__)
	XAxiDma_BdWrite64(BdPtr, XAXIDMA_BD_BUFA_OFFSET, Addr);
#else
	XAxiDma_BdWrite(BdPtr, XAXIDMA_BD_BUFA_OFFSET, Addr);
c000d868:	fdc42783          	lw	a5,-36(s0)
c000d86c:	00878793          	addi	a5,a5,8
c000d870:	00078713          	mv	a4,a5
c000d874:	fd842783          	lw	a5,-40(s0)
c000d878:	00f72023          	sw	a5,0(a4)
#endif

	return XST_SUCCESS;
c000d87c:	00000793          	li	a5,0
}
c000d880:	00078513          	mv	a0,a5
c000d884:	02c12083          	lw	ra,44(sp)
c000d888:	02812403          	lw	s0,40(sp)
c000d88c:	03010113          	addi	sp,sp,48
c000d890:	00008067          	ret

c000d894 <XAxiDma_BdSetBufAddrMicroMode>:
 *
 * @note	This function can be used only when DMA is in SG mode
 *
 *****************************************************************************/
u32 XAxiDma_BdSetBufAddrMicroMode(XAxiDma_Bd* BdPtr, UINTPTR Addr)
{
c000d894:	fe010113          	addi	sp,sp,-32
c000d898:	00112e23          	sw	ra,28(sp)
c000d89c:	00812c23          	sw	s0,24(sp)
c000d8a0:	02010413          	addi	s0,sp,32
c000d8a4:	fea42623          	sw	a0,-20(s0)
c000d8a8:	feb42423          	sw	a1,-24(s0)
	if (Addr & XAXIDMA_MICROMODE_MIN_BUF_ALIGN) {
c000d8ac:	fe842703          	lw	a4,-24(s0)
c000d8b0:	000017b7          	lui	a5,0x1
c000d8b4:	fff78793          	addi	a5,a5,-1 # fff <_STACK_SIZE-0x1>
c000d8b8:	00f777b3          	and	a5,a4,a5
c000d8bc:	02078c63          	beqz	a5,c000d8f4 <XAxiDma_BdSetBufAddrMicroMode+0x60>
			printf("Error set buf addr %x and %x,"
c000d8c0:	fe842703          	lw	a4,-24(s0)
c000d8c4:	000017b7          	lui	a5,0x1
c000d8c8:	fff78793          	addi	a5,a5,-1 # fff <_STACK_SIZE-0x1>
c000d8cc:	00f777b3          	and	a5,a4,a5
c000d8d0:	00078693          	mv	a3,a5
c000d8d4:	000017b7          	lui	a5,0x1
c000d8d8:	fff78613          	addi	a2,a5,-1 # fff <_STACK_SIZE-0x1>
c000d8dc:	fe842583          	lw	a1,-24(s0)
c000d8e0:	07ff3517          	auipc	a0,0x7ff3
c000d8e4:	99450513          	addi	a0,a0,-1644 # c8000274 <__rodata_start+0x274>
c000d8e8:	4bc100ef          	jal	ra,c001dda4 <printf>
			" %x\r\n", (unsigned int)Addr, (unsigned int)XAXIDMA_MICROMODE_MIN_BUF_ALIGN,
			(unsigned int)(Addr & XAXIDMA_MICROMODE_MIN_BUF_ALIGN));

			return XST_INVALID_PARAM;
c000d8ec:	00f00793          	li	a5,15
c000d8f0:	01c0006f          	j	c000d90c <XAxiDma_BdSetBufAddrMicroMode+0x78>
	}

#if defined(__aarch64__) || defined(__arch64__)
	XAxiDma_BdWrite64(BdPtr, XAXIDMA_BD_BUFA_OFFSET, Addr);
#else
	XAxiDma_BdWrite(BdPtr, XAXIDMA_BD_BUFA_OFFSET, Addr);
c000d8f4:	fec42783          	lw	a5,-20(s0)
c000d8f8:	00878793          	addi	a5,a5,8
c000d8fc:	00078713          	mv	a4,a5
c000d900:	fe842783          	lw	a5,-24(s0)
c000d904:	00f72023          	sw	a5,0(a4)
#endif

	return XST_SUCCESS;
c000d908:	00000793          	li	a5,0
}
c000d90c:	00078513          	mv	a0,a5
c000d910:	01c12083          	lw	ra,28(sp)
c000d914:	01812403          	lw	s0,24(sp)
c000d918:	02010113          	addi	sp,sp,32
c000d91c:	00008067          	ret

c000d920 <XAxiDma_BdSetAppWord>:
 *		the hardware to stall.
 *		This function can be used only when DMA is in SG mode
 *
 *****************************************************************************/
int XAxiDma_BdSetAppWord(XAxiDma_Bd* BdPtr, int Offset, u32 Word)
{
c000d920:	fe010113          	addi	sp,sp,-32
c000d924:	00112e23          	sw	ra,28(sp)
c000d928:	00812c23          	sw	s0,24(sp)
c000d92c:	02010413          	addi	s0,sp,32
c000d930:	fea42623          	sw	a0,-20(s0)
c000d934:	feb42423          	sw	a1,-24(s0)
c000d938:	fec42223          	sw	a2,-28(s0)
	if (XAxiDma_BdRead(BdPtr, XAXIDMA_BD_HAS_STSCNTRL_OFFSET) == 0) {
c000d93c:	fec42783          	lw	a5,-20(s0)
c000d940:	03878793          	addi	a5,a5,56
c000d944:	0007a783          	lw	a5,0(a5)
c000d948:	00079c63          	bnez	a5,c000d960 <XAxiDma_BdSetAppWord+0x40>

		printf("BdRingSetAppWord: no sts cntrl"
c000d94c:	07ff3517          	auipc	a0,0x7ff3
c000d950:	94c50513          	addi	a0,a0,-1716 # c8000298 <__rodata_start+0x298>
c000d954:	56c100ef          	jal	ra,c001dec0 <puts>
			"stream in hardware build, cannot set app word\r\n");

		return XST_INVALID_PARAM;
c000d958:	00f00793          	li	a5,15
c000d95c:	0580006f          	j	c000d9b4 <XAxiDma_BdSetAppWord+0x94>
	}

	if ((Offset < 0) || (Offset > XAXIDMA_LAST_APPWORD)) {
c000d960:	fe842783          	lw	a5,-24(s0)
c000d964:	0007c863          	bltz	a5,c000d974 <XAxiDma_BdSetAppWord+0x54>
c000d968:	fe842703          	lw	a4,-24(s0)
c000d96c:	00400793          	li	a5,4
c000d970:	00e7de63          	bge	a5,a4,c000d98c <XAxiDma_BdSetAppWord+0x6c>

		printf("BdRingSetAppWord: invalid"
c000d974:	fe842583          	lw	a1,-24(s0)
c000d978:	07ff3517          	auipc	a0,0x7ff3
c000d97c:	97050513          	addi	a0,a0,-1680 # c80002e8 <__rodata_start+0x2e8>
c000d980:	424100ef          	jal	ra,c001dda4 <printf>
			"offset %d",Offset);

		return XST_INVALID_PARAM;
c000d984:	00f00793          	li	a5,15
c000d988:	02c0006f          	j	c000d9b4 <XAxiDma_BdSetAppWord+0x94>
	}

	XAxiDma_BdWrite(BdPtr, XAXIDMA_BD_USR0_OFFSET + Offset * 4, Word);
c000d98c:	fe842783          	lw	a5,-24(s0)
c000d990:	00878793          	addi	a5,a5,8
c000d994:	00279793          	slli	a5,a5,0x2
c000d998:	00078713          	mv	a4,a5
c000d99c:	fec42783          	lw	a5,-20(s0)
c000d9a0:	00f707b3          	add	a5,a4,a5
c000d9a4:	00078713          	mv	a4,a5
c000d9a8:	fe442783          	lw	a5,-28(s0)
c000d9ac:	00f72023          	sw	a5,0(a4)

	return XST_SUCCESS;
c000d9b0:	00000793          	li	a5,0
}
c000d9b4:	00078513          	mv	a0,a5
c000d9b8:	01c12083          	lw	ra,28(sp)
c000d9bc:	01812403          	lw	s0,24(sp)
c000d9c0:	02010113          	addi	sp,sp,32
c000d9c4:	00008067          	ret

c000d9c8 <XAxiDma_BdGetAppWord>:
 *
 * @note	This function can be used only when DMA is in SG mode
 *
 *****************************************************************************/
u32 XAxiDma_BdGetAppWord(XAxiDma_Bd* BdPtr, int Offset, int *Valid)
{
c000d9c8:	fe010113          	addi	sp,sp,-32
c000d9cc:	00112e23          	sw	ra,28(sp)
c000d9d0:	00812c23          	sw	s0,24(sp)
c000d9d4:	02010413          	addi	s0,sp,32
c000d9d8:	fea42623          	sw	a0,-20(s0)
c000d9dc:	feb42423          	sw	a1,-24(s0)
c000d9e0:	fec42223          	sw	a2,-28(s0)
	*Valid = 0;
c000d9e4:	fe442783          	lw	a5,-28(s0)
c000d9e8:	0007a023          	sw	zero,0(a5)

	if (XAxiDma_BdRead(BdPtr, XAXIDMA_BD_HAS_STSCNTRL_OFFSET) == 0) {
c000d9ec:	fec42783          	lw	a5,-20(s0)
c000d9f0:	03878793          	addi	a5,a5,56
c000d9f4:	0007a783          	lw	a5,0(a5)
c000d9f8:	00079c63          	bnez	a5,c000da10 <XAxiDma_BdGetAppWord+0x48>

		printf("BdRingGetAppWord: no sts cntrl "
c000d9fc:	07ff3517          	auipc	a0,0x7ff3
c000da00:	91050513          	addi	a0,a0,-1776 # c800030c <__rodata_start+0x30c>
c000da04:	4bc100ef          	jal	ra,c001dec0 <puts>
			"stream in hardware build, no app word available\r\n");

		return (u32)0;
c000da08:	00000793          	li	a5,0
c000da0c:	0580006f          	j	c000da64 <XAxiDma_BdGetAppWord+0x9c>
	}

	if((Offset < 0) || (Offset > XAXIDMA_LAST_APPWORD)) {
c000da10:	fe842783          	lw	a5,-24(s0)
c000da14:	0007c863          	bltz	a5,c000da24 <XAxiDma_BdGetAppWord+0x5c>
c000da18:	fe842703          	lw	a4,-24(s0)
c000da1c:	00400793          	li	a5,4
c000da20:	00e7de63          	bge	a5,a4,c000da3c <XAxiDma_BdGetAppWord+0x74>

		printf("BdRingGetAppWord: invalid"
c000da24:	fe842583          	lw	a1,-24(s0)
c000da28:	07ff3517          	auipc	a0,0x7ff3
c000da2c:	93450513          	addi	a0,a0,-1740 # c800035c <__rodata_start+0x35c>
c000da30:	374100ef          	jal	ra,c001dda4 <printf>
			" offset %d", Offset);

		return (u32)0;
c000da34:	00000793          	li	a5,0
c000da38:	02c0006f          	j	c000da64 <XAxiDma_BdGetAppWord+0x9c>
	}

	*Valid = 1;
c000da3c:	fe442783          	lw	a5,-28(s0)
c000da40:	00100713          	li	a4,1
c000da44:	00e7a023          	sw	a4,0(a5)

	return XAxiDma_BdRead(BdPtr, XAXIDMA_BD_USR0_OFFSET + Offset * 4);
c000da48:	fe842783          	lw	a5,-24(s0)
c000da4c:	00878793          	addi	a5,a5,8
c000da50:	00279793          	slli	a5,a5,0x2
c000da54:	00078713          	mv	a4,a5
c000da58:	fec42783          	lw	a5,-20(s0)
c000da5c:	00f707b3          	add	a5,a4,a5
c000da60:	0007a783          	lw	a5,0(a5)
}
c000da64:	00078513          	mv	a0,a5
c000da68:	01c12083          	lw	ra,28(sp)
c000da6c:	01812403          	lw	s0,24(sp)
c000da70:	02010113          	addi	sp,sp,32
c000da74:	00008067          	ret

c000da78 <XAxiDma_BdSetCtrl>:
 *
 * @note	This function can be used only when DMA is in SG mode
 *
 *****************************************************************************/
void XAxiDma_BdSetCtrl(XAxiDma_Bd* BdPtr, u32 Data)
{
c000da78:	fd010113          	addi	sp,sp,-48
c000da7c:	02812623          	sw	s0,44(sp)
c000da80:	03010413          	addi	s0,sp,48
c000da84:	fca42e23          	sw	a0,-36(s0)
c000da88:	fcb42c23          	sw	a1,-40(s0)
	u32 RegValue = XAxiDma_BdRead(BdPtr, XAXIDMA_BD_CTRL_LEN_OFFSET);
c000da8c:	fdc42783          	lw	a5,-36(s0)
c000da90:	01878793          	addi	a5,a5,24
c000da94:	0007a783          	lw	a5,0(a5)
c000da98:	fef42623          	sw	a5,-20(s0)

	RegValue &= ~XAXIDMA_BD_CTRL_ALL_MASK;
c000da9c:	fec42703          	lw	a4,-20(s0)
c000daa0:	f40007b7          	lui	a5,0xf4000
c000daa4:	fff78793          	addi	a5,a5,-1 # f3ffffff <_end+0x2bf7b77f>
c000daa8:	00f777b3          	and	a5,a4,a5
c000daac:	fef42623          	sw	a5,-20(s0)

	RegValue |= (Data & XAXIDMA_BD_CTRL_ALL_MASK);
c000dab0:	fd842703          	lw	a4,-40(s0)
c000dab4:	0c0007b7          	lui	a5,0xc000
c000dab8:	00f777b3          	and	a5,a4,a5
c000dabc:	fec42703          	lw	a4,-20(s0)
c000dac0:	00f767b3          	or	a5,a4,a5
c000dac4:	fef42623          	sw	a5,-20(s0)

	XAxiDma_BdWrite((BdPtr), XAXIDMA_BD_CTRL_LEN_OFFSET, RegValue);
c000dac8:	fdc42783          	lw	a5,-36(s0)
c000dacc:	01878793          	addi	a5,a5,24 # c000018 <_DMEM_LENGTH+0xb800018>
c000dad0:	00078713          	mv	a4,a5
c000dad4:	fec42783          	lw	a5,-20(s0)
c000dad8:	00f72023          	sw	a5,0(a4)

	return;
c000dadc:	00000013          	nop
}
c000dae0:	02c12403          	lw	s0,44(sp)
c000dae4:	03010113          	addi	sp,sp,48
c000dae8:	00008067          	ret

c000daec <XAxiDma_DumpBd>:
 *
 * @note	This function can be used only when DMA is in SG mode
 *
 *****************************************************************************/
void XAxiDma_DumpBd(XAxiDma_Bd* BdPtr)
{
c000daec:	fe010113          	addi	sp,sp,-32
c000daf0:	00112e23          	sw	ra,28(sp)
c000daf4:	00812c23          	sw	s0,24(sp)
c000daf8:	02010413          	addi	s0,sp,32
c000dafc:	fea42623          	sw	a0,-20(s0)

	printf("Dump BD %x:\r\n", (unsigned int)(UINTPTR)BdPtr);
c000db00:	fec42783          	lw	a5,-20(s0)
c000db04:	00078593          	mv	a1,a5
c000db08:	07ff3517          	auipc	a0,0x7ff3
c000db0c:	87850513          	addi	a0,a0,-1928 # c8000380 <__rodata_start+0x380>
c000db10:	294100ef          	jal	ra,c001dda4 <printf>
	printf("\tNext Bd Ptr: %x\r\n",
c000db14:	fec42783          	lw	a5,-20(s0)
c000db18:	0007a783          	lw	a5,0(a5)
c000db1c:	00078593          	mv	a1,a5
c000db20:	07ff3517          	auipc	a0,0x7ff3
c000db24:	87050513          	addi	a0,a0,-1936 # c8000390 <__rodata_start+0x390>
c000db28:	27c100ef          	jal	ra,c001dda4 <printf>
	    (unsigned int)XAxiDma_BdRead(BdPtr, XAXIDMA_BD_NDESC_OFFSET));
	printf("\tBuff addr: %x\r\n",
	    (unsigned int)XAxiDma_BdRead(BdPtr, XAXIDMA_BD_BUFA_OFFSET));
c000db2c:	fec42783          	lw	a5,-20(s0)
c000db30:	00878793          	addi	a5,a5,8
	printf("\tBuff addr: %x\r\n",
c000db34:	0007a783          	lw	a5,0(a5)
c000db38:	00078593          	mv	a1,a5
c000db3c:	07ff3517          	auipc	a0,0x7ff3
c000db40:	86850513          	addi	a0,a0,-1944 # c80003a4 <__rodata_start+0x3a4>
c000db44:	260100ef          	jal	ra,c001dda4 <printf>
	printf("\tMCDMA Fields: %x\r\n",
	    (unsigned int)XAxiDma_BdRead(BdPtr, XAXIDMA_BD_MCCTL_OFFSET));
c000db48:	fec42783          	lw	a5,-20(s0)
c000db4c:	01078793          	addi	a5,a5,16
	printf("\tMCDMA Fields: %x\r\n",
c000db50:	0007a783          	lw	a5,0(a5)
c000db54:	00078593          	mv	a1,a5
c000db58:	07ff3517          	auipc	a0,0x7ff3
c000db5c:	86050513          	addi	a0,a0,-1952 # c80003b8 <__rodata_start+0x3b8>
c000db60:	244100ef          	jal	ra,c001dda4 <printf>
	printf("\tVSIZE_STRIDE: %x\r\n",
	    (unsigned int)XAxiDma_BdRead(BdPtr,
c000db64:	fec42783          	lw	a5,-20(s0)
c000db68:	01478793          	addi	a5,a5,20
	printf("\tVSIZE_STRIDE: %x\r\n",
c000db6c:	0007a783          	lw	a5,0(a5)
c000db70:	00078593          	mv	a1,a5
c000db74:	07ff3517          	auipc	a0,0x7ff3
c000db78:	85850513          	addi	a0,a0,-1960 # c80003cc <__rodata_start+0x3cc>
c000db7c:	228100ef          	jal	ra,c001dda4 <printf>
					XAXIDMA_BD_STRIDE_VSIZE_OFFSET));
	printf("\tContrl len: %x\r\n",
	    (unsigned int)XAxiDma_BdRead(BdPtr, XAXIDMA_BD_CTRL_LEN_OFFSET));
c000db80:	fec42783          	lw	a5,-20(s0)
c000db84:	01878793          	addi	a5,a5,24
	printf("\tContrl len: %x\r\n",
c000db88:	0007a783          	lw	a5,0(a5)
c000db8c:	00078593          	mv	a1,a5
c000db90:	07ff3517          	auipc	a0,0x7ff3
c000db94:	85050513          	addi	a0,a0,-1968 # c80003e0 <__rodata_start+0x3e0>
c000db98:	20c100ef          	jal	ra,c001dda4 <printf>
	printf("\tStatus: %x\r\n",
	    (unsigned int)XAxiDma_BdRead(BdPtr, XAXIDMA_BD_STS_OFFSET));
c000db9c:	fec42783          	lw	a5,-20(s0)
c000dba0:	01c78793          	addi	a5,a5,28
	printf("\tStatus: %x\r\n",
c000dba4:	0007a783          	lw	a5,0(a5)
c000dba8:	00078593          	mv	a1,a5
c000dbac:	07ff3517          	auipc	a0,0x7ff3
c000dbb0:	84850513          	addi	a0,a0,-1976 # c80003f4 <__rodata_start+0x3f4>
c000dbb4:	1f0100ef          	jal	ra,c001dda4 <printf>

	printf("\tAPP 0: %x\r\n",
	    (unsigned int)XAxiDma_BdRead(BdPtr, XAXIDMA_BD_USR0_OFFSET));
c000dbb8:	fec42783          	lw	a5,-20(s0)
c000dbbc:	02078793          	addi	a5,a5,32
	printf("\tAPP 0: %x\r\n",
c000dbc0:	0007a783          	lw	a5,0(a5)
c000dbc4:	00078593          	mv	a1,a5
c000dbc8:	07ff3517          	auipc	a0,0x7ff3
c000dbcc:	83c50513          	addi	a0,a0,-1988 # c8000404 <__rodata_start+0x404>
c000dbd0:	1d4100ef          	jal	ra,c001dda4 <printf>
	printf("\tAPP 1: %x\r\n",
	    (unsigned int)XAxiDma_BdRead(BdPtr, XAXIDMA_BD_USR1_OFFSET));
c000dbd4:	fec42783          	lw	a5,-20(s0)
c000dbd8:	02478793          	addi	a5,a5,36
	printf("\tAPP 1: %x\r\n",
c000dbdc:	0007a783          	lw	a5,0(a5)
c000dbe0:	00078593          	mv	a1,a5
c000dbe4:	07ff3517          	auipc	a0,0x7ff3
c000dbe8:	83050513          	addi	a0,a0,-2000 # c8000414 <__rodata_start+0x414>
c000dbec:	1b8100ef          	jal	ra,c001dda4 <printf>
	printf("\tAPP 2: %x\r\n",
	    (unsigned int)XAxiDma_BdRead(BdPtr, XAXIDMA_BD_USR2_OFFSET));
c000dbf0:	fec42783          	lw	a5,-20(s0)
c000dbf4:	02878793          	addi	a5,a5,40
	printf("\tAPP 2: %x\r\n",
c000dbf8:	0007a783          	lw	a5,0(a5)
c000dbfc:	00078593          	mv	a1,a5
c000dc00:	07ff3517          	auipc	a0,0x7ff3
c000dc04:	82450513          	addi	a0,a0,-2012 # c8000424 <__rodata_start+0x424>
c000dc08:	19c100ef          	jal	ra,c001dda4 <printf>
	printf("\tAPP 3: %x\r\n",
	    (unsigned int)XAxiDma_BdRead(BdPtr, XAXIDMA_BD_USR3_OFFSET));
c000dc0c:	fec42783          	lw	a5,-20(s0)
c000dc10:	02c78793          	addi	a5,a5,44
	printf("\tAPP 3: %x\r\n",
c000dc14:	0007a783          	lw	a5,0(a5)
c000dc18:	00078593          	mv	a1,a5
c000dc1c:	07ff3517          	auipc	a0,0x7ff3
c000dc20:	81850513          	addi	a0,a0,-2024 # c8000434 <__rodata_start+0x434>
c000dc24:	180100ef          	jal	ra,c001dda4 <printf>
	printf("\tAPP 4: %x\r\n",
	    (unsigned int)XAxiDma_BdRead(BdPtr, XAXIDMA_BD_USR4_OFFSET));
c000dc28:	fec42783          	lw	a5,-20(s0)
c000dc2c:	03078793          	addi	a5,a5,48
	printf("\tAPP 4: %x\r\n",
c000dc30:	0007a783          	lw	a5,0(a5)
c000dc34:	00078593          	mv	a1,a5
c000dc38:	07ff3517          	auipc	a0,0x7ff3
c000dc3c:	80c50513          	addi	a0,a0,-2036 # c8000444 <__rodata_start+0x444>
c000dc40:	164100ef          	jal	ra,c001dda4 <printf>

	printf("\tSW ID: %x\r\n",
	    (unsigned int)XAxiDma_BdRead(BdPtr, XAXIDMA_BD_ID_OFFSET));
c000dc44:	fec42783          	lw	a5,-20(s0)
c000dc48:	03478793          	addi	a5,a5,52
	printf("\tSW ID: %x\r\n",
c000dc4c:	0007a783          	lw	a5,0(a5)
c000dc50:	00078593          	mv	a1,a5
c000dc54:	07ff3517          	auipc	a0,0x7ff3
c000dc58:	80050513          	addi	a0,a0,-2048 # c8000454 <__rodata_start+0x454>
c000dc5c:	148100ef          	jal	ra,c001dda4 <printf>
	printf("\tStsCtrl: %x\r\n",
	    (unsigned int)XAxiDma_BdRead(BdPtr,
c000dc60:	fec42783          	lw	a5,-20(s0)
c000dc64:	03878793          	addi	a5,a5,56
	printf("\tStsCtrl: %x\r\n",
c000dc68:	0007a783          	lw	a5,0(a5)
c000dc6c:	00078593          	mv	a1,a5
c000dc70:	07ff2517          	auipc	a0,0x7ff2
c000dc74:	7f450513          	addi	a0,a0,2036 # c8000464 <__rodata_start+0x464>
c000dc78:	12c100ef          	jal	ra,c001dda4 <printf>
	           XAXIDMA_BD_HAS_STSCNTRL_OFFSET));
	printf("\tDRE: %x\r\n",
	    (unsigned int)XAxiDma_BdRead(BdPtr, XAXIDMA_BD_HAS_DRE_OFFSET));
c000dc7c:	fec42783          	lw	a5,-20(s0)
c000dc80:	03c78793          	addi	a5,a5,60
	printf("\tDRE: %x\r\n",
c000dc84:	0007a783          	lw	a5,0(a5)
c000dc88:	00078593          	mv	a1,a5
c000dc8c:	07ff2517          	auipc	a0,0x7ff2
c000dc90:	7e850513          	addi	a0,a0,2024 # c8000474 <__rodata_start+0x474>
c000dc94:	110100ef          	jal	ra,c001dda4 <printf>

	printf("\r\n");
c000dc98:	07ff2517          	auipc	a0,0x7ff2
c000dc9c:	7e850513          	addi	a0,a0,2024 # c8000480 <__rodata_start+0x480>
c000dca0:	220100ef          	jal	ra,c001dec0 <puts>
}
c000dca4:	00000013          	nop
c000dca8:	01c12083          	lw	ra,28(sp)
c000dcac:	01812403          	lw	s0,24(sp)
c000dcb0:	02010113          	addi	sp,sp,32
c000dcb4:	00008067          	ret

c000dcb8 <Xil_In32>:
{
c000dcb8:	fe010113          	addi	sp,sp,-32
c000dcbc:	00812e23          	sw	s0,28(sp)
c000dcc0:	02010413          	addi	s0,sp,32
c000dcc4:	fea42623          	sw	a0,-20(s0)
	return *(volatile u32 *) Addr;
c000dcc8:	fec42783          	lw	a5,-20(s0)
c000dccc:	0007a783          	lw	a5,0(a5)
}
c000dcd0:	00078513          	mv	a0,a5
c000dcd4:	01c12403          	lw	s0,28(sp)
c000dcd8:	02010113          	addi	sp,sp,32
c000dcdc:	00008067          	ret

c000dce0 <Xil_Out32>:
{
c000dce0:	fd010113          	addi	sp,sp,-48
c000dce4:	02812623          	sw	s0,44(sp)
c000dce8:	03010413          	addi	s0,sp,48
c000dcec:	fca42e23          	sw	a0,-36(s0)
c000dcf0:	fcb42c23          	sw	a1,-40(s0)
	volatile u32 *LocalAddr = (volatile u32 *)Addr;
c000dcf4:	fdc42783          	lw	a5,-36(s0)
c000dcf8:	fef42623          	sw	a5,-20(s0)
	*LocalAddr = Value;
c000dcfc:	fec42783          	lw	a5,-20(s0)
c000dd00:	fd842703          	lw	a4,-40(s0)
c000dd04:	00e7a023          	sw	a4,0(a5)
}
c000dd08:	00000013          	nop
c000dd0c:	02c12403          	lw	s0,44(sp)
c000dd10:	03010113          	addi	sp,sp,48
c000dd14:	00008067          	ret

c000dd18 <XAxiDma_UpdateBdRingCDesc>:
 *
 * @note	This function can be used only when DMA is in SG mode
 *
 *****************************************************************************/
int XAxiDma_UpdateBdRingCDesc(XAxiDma_BdRing* RingPtr)
{
c000dd18:	fd010113          	addi	sp,sp,-48
c000dd1c:	02112623          	sw	ra,44(sp)
c000dd20:	02812423          	sw	s0,40(sp)
c000dd24:	03010413          	addi	s0,sp,48
c000dd28:	fca42e23          	sw	a0,-36(s0)
	UINTPTR RegBase;
	UINTPTR BdPtr;
	int RingIndex = RingPtr->RingIndex;
c000dd2c:	fdc42783          	lw	a5,-36(s0)
c000dd30:	0647a783          	lw	a5,100(a5)
c000dd34:	fef42423          	sw	a5,-24(s0)

	/* BD list has yet to be created for this channel */
	if (RingPtr->AllCnt == 0) {
c000dd38:	fdc42783          	lw	a5,-36(s0)
c000dd3c:	0607a783          	lw	a5,96(a5)
c000dd40:	00079c63          	bnez	a5,c000dd58 <XAxiDma_UpdateBdRingCDesc+0x40>

		printf("BdRingStart: no bds\r\n");
c000dd44:	07ff2517          	auipc	a0,0x7ff2
c000dd48:	74050513          	addi	a0,a0,1856 # c8000484 <__rodata_start+0x484>
c000dd4c:	174100ef          	jal	ra,c001dec0 <puts>

		return XST_DMA_SG_NO_LIST;
c000dd50:	20b00793          	li	a5,523
c000dd54:	3680006f          	j	c000e0bc <XAxiDma_UpdateBdRingCDesc+0x3a4>
	}

	/* Do nothing if already started */
	if (RingPtr->RunState == AXIDMA_CHANNEL_NOT_HALTED) {
c000dd58:	fdc42783          	lw	a5,-36(s0)
c000dd5c:	0087a703          	lw	a4,8(a5)
c000dd60:	00100793          	li	a5,1
c000dd64:	00f71663          	bne	a4,a5,c000dd70 <XAxiDma_UpdateBdRingCDesc+0x58>
		/* Need to update tail pointer if needed (Engine is not
		 * transferring)
		 */
		return XST_SUCCESS;
c000dd68:	00000793          	li	a5,0
c000dd6c:	3500006f          	j	c000e0bc <XAxiDma_UpdateBdRingCDesc+0x3a4>
	}

	if (!XAxiDma_BdRingHwIsStarted(RingPtr)) {
c000dd70:	fdc42783          	lw	a5,-36(s0)
c000dd74:	0007a783          	lw	a5,0(a5)
c000dd78:	00478793          	addi	a5,a5,4
c000dd7c:	00078513          	mv	a0,a5
c000dd80:	f39ff0ef          	jal	ra,c000dcb8 <Xil_In32>
c000dd84:	00050793          	mv	a5,a0
c000dd88:	0017f793          	andi	a5,a5,1
c000dd8c:	32078663          	beqz	a5,c000e0b8 <XAxiDma_UpdateBdRingCDesc+0x3a0>
		/* If hardware is not running, then we need to put a valid current
		 * BD pointer to the current BD register before start the hardware
		 */
		RegBase = RingPtr->ChanBase;
c000dd90:	fdc42783          	lw	a5,-36(s0)
c000dd94:	0007a783          	lw	a5,0(a5)
c000dd98:	fef42223          	sw	a5,-28(s0)

		/* Put a valid BD pointer in the current BD pointer register
		 * So, the hardware is ready to go when tail BD pointer is updated
		 */
		BdPtr = (UINTPTR)(void *)(RingPtr->BdaRestart);
c000dd9c:	fdc42783          	lw	a5,-36(s0)
c000dda0:	0487a783          	lw	a5,72(a5)
c000dda4:	fef42623          	sw	a5,-20(s0)

		if (!XAxiDma_BdHwCompleted(BdPtr)) {
c000dda8:	fec42783          	lw	a5,-20(s0)
c000ddac:	01c78793          	addi	a5,a5,28
c000ddb0:	0007a783          	lw	a5,0(a5)
c000ddb4:	2e07c663          	bltz	a5,c000e0a0 <XAxiDma_UpdateBdRingCDesc+0x388>
			if (RingPtr->IsRxChannel) {
c000ddb8:	fdc42783          	lw	a5,-36(s0)
c000ddbc:	0047a783          	lw	a5,4(a5)
c000ddc0:	0e078063          	beqz	a5,c000dea0 <XAxiDma_UpdateBdRingCDesc+0x188>
				if (!RingIndex) {
c000ddc4:	fe842783          	lw	a5,-24(s0)
c000ddc8:	04079e63          	bnez	a5,c000de24 <XAxiDma_UpdateBdRingCDesc+0x10c>
					XAxiDma_WriteReg(RegBase,
c000ddcc:	fe442783          	lw	a5,-28(s0)
c000ddd0:	00878693          	addi	a3,a5,8
c000ddd4:	fdc42783          	lw	a5,-36(s0)
c000ddd8:	0207a703          	lw	a4,32(a5)
c000dddc:	fdc42783          	lw	a5,-36(s0)
c000dde0:	0247a783          	lw	a5,36(a5)
c000dde4:	40f70733          	sub	a4,a4,a5
c000dde8:	fec42783          	lw	a5,-20(s0)
c000ddec:	00f707b3          	add	a5,a4,a5
c000ddf0:	fc07f793          	andi	a5,a5,-64
c000ddf4:	00078593          	mv	a1,a5
c000ddf8:	00068513          	mv	a0,a3
c000ddfc:	ee5ff0ef          	jal	ra,c000dce0 <Xil_Out32>
							 XAXIDMA_CDESC_OFFSET,
							 (XAXIDMA_VIRT_TO_PHYS(BdPtr) & XAXIDMA_DESC_LSB_MASK));
					if (RingPtr->Addr_ext)
c000de00:	fdc42783          	lw	a5,-36(s0)
c000de04:	0187a783          	lw	a5,24(a5)
c000de08:	2a078863          	beqz	a5,c000e0b8 <XAxiDma_UpdateBdRingCDesc+0x3a0>
						XAxiDma_WriteReg(RegBase,
c000de0c:	fe442783          	lw	a5,-28(s0)
c000de10:	00c78793          	addi	a5,a5,12
c000de14:	00000593          	li	a1,0
c000de18:	00078513          	mv	a0,a5
c000de1c:	ec5ff0ef          	jal	ra,c000dce0 <Xil_Out32>
c000de20:	2980006f          	j	c000e0b8 <XAxiDma_UpdateBdRingCDesc+0x3a0>
								 XAXIDMA_CDESC_MSB_OFFSET,
								 UPPER_32_BITS(XAXIDMA_VIRT_TO_PHYS(BdPtr)));
				}
				else {
					XAxiDma_WriteReg(RegBase,
c000de24:	fe842783          	lw	a5,-24(s0)
c000de28:	00178793          	addi	a5,a5,1
c000de2c:	00579793          	slli	a5,a5,0x5
c000de30:	00078713          	mv	a4,a5
c000de34:	fe442783          	lw	a5,-28(s0)
c000de38:	00f706b3          	add	a3,a4,a5
c000de3c:	fdc42783          	lw	a5,-36(s0)
c000de40:	0207a703          	lw	a4,32(a5)
c000de44:	fdc42783          	lw	a5,-36(s0)
c000de48:	0247a783          	lw	a5,36(a5)
c000de4c:	40f70733          	sub	a4,a4,a5
c000de50:	fec42783          	lw	a5,-20(s0)
c000de54:	00f707b3          	add	a5,a4,a5
c000de58:	fc07f793          	andi	a5,a5,-64
c000de5c:	00078593          	mv	a1,a5
c000de60:	00068513          	mv	a0,a3
c000de64:	e7dff0ef          	jal	ra,c000dce0 <Xil_Out32>
					(XAXIDMA_RX_CDESC0_OFFSET +
					(RingIndex - 1) * XAXIDMA_RX_NDESC_OFFSET),
					(XAXIDMA_VIRT_TO_PHYS(BdPtr) & XAXIDMA_DESC_LSB_MASK));
					if (RingPtr->Addr_ext)
c000de68:	fdc42783          	lw	a5,-36(s0)
c000de6c:	0187a783          	lw	a5,24(a5)
c000de70:	24078463          	beqz	a5,c000e0b8 <XAxiDma_UpdateBdRingCDesc+0x3a0>
						XAxiDma_WriteReg(RegBase,
c000de74:	fe842783          	lw	a5,-24(s0)
c000de78:	fff78793          	addi	a5,a5,-1
c000de7c:	00579793          	slli	a5,a5,0x5
c000de80:	00078713          	mv	a4,a5
c000de84:	fe442783          	lw	a5,-28(s0)
c000de88:	00f707b3          	add	a5,a4,a5
c000de8c:	04478793          	addi	a5,a5,68
c000de90:	00000593          	li	a1,0
c000de94:	00078513          	mv	a0,a5
c000de98:	e49ff0ef          	jal	ra,c000dce0 <Xil_Out32>
c000de9c:	21c0006f          	j	c000e0b8 <XAxiDma_UpdateBdRingCDesc+0x3a0>
								 (RingIndex - 1) * XAXIDMA_RX_NDESC_OFFSET),
								 UPPER_32_BITS(XAXIDMA_VIRT_TO_PHYS(BdPtr)));
				}
			}
			else {
				XAxiDma_WriteReg(RegBase,
c000dea0:	fe442783          	lw	a5,-28(s0)
c000dea4:	00878693          	addi	a3,a5,8
c000dea8:	fdc42783          	lw	a5,-36(s0)
c000deac:	0207a703          	lw	a4,32(a5)
c000deb0:	fdc42783          	lw	a5,-36(s0)
c000deb4:	0247a783          	lw	a5,36(a5)
c000deb8:	40f70733          	sub	a4,a4,a5
c000debc:	fec42783          	lw	a5,-20(s0)
c000dec0:	00f707b3          	add	a5,a4,a5
c000dec4:	fc07f793          	andi	a5,a5,-64
c000dec8:	00078593          	mv	a1,a5
c000decc:	00068513          	mv	a0,a3
c000ded0:	e11ff0ef          	jal	ra,c000dce0 <Xil_Out32>
						 XAXIDMA_CDESC_OFFSET,
						 (XAXIDMA_VIRT_TO_PHYS(BdPtr) & XAXIDMA_DESC_LSB_MASK));
				if (RingPtr->Addr_ext)
c000ded4:	fdc42783          	lw	a5,-36(s0)
c000ded8:	0187a783          	lw	a5,24(a5)
c000dedc:	1c078e63          	beqz	a5,c000e0b8 <XAxiDma_UpdateBdRingCDesc+0x3a0>
					XAxiDma_WriteReg(RegBase, XAXIDMA_CDESC_MSB_OFFSET,
c000dee0:	fe442783          	lw	a5,-28(s0)
c000dee4:	00c78793          	addi	a5,a5,12
c000dee8:	00000593          	li	a1,0
c000deec:	00078513          	mv	a0,a5
c000def0:	df1ff0ef          	jal	ra,c000dce0 <Xil_Out32>
c000def4:	1c40006f          	j	c000e0b8 <XAxiDma_UpdateBdRingCDesc+0x3a0>
		}
		else {
			/* Look for an uncompleted BD
			*/
			while (XAxiDma_BdHwCompleted(BdPtr)) {
				BdPtr = XAxiDma_BdRingNext(RingPtr, BdPtr);
c000def8:	fdc42783          	lw	a5,-36(s0)
c000defc:	0287a783          	lw	a5,40(a5)
c000df00:	fec42703          	lw	a4,-20(s0)
c000df04:	00f76863          	bltu	a4,a5,c000df14 <XAxiDma_UpdateBdRingCDesc+0x1fc>
c000df08:	fdc42783          	lw	a5,-36(s0)
c000df0c:	0247a783          	lw	a5,36(a5)
c000df10:	0140006f          	j	c000df24 <XAxiDma_UpdateBdRingCDesc+0x20c>
c000df14:	fdc42783          	lw	a5,-36(s0)
c000df18:	0307a703          	lw	a4,48(a5)
c000df1c:	fec42783          	lw	a5,-20(s0)
c000df20:	00f707b3          	add	a5,a4,a5
c000df24:	fef42623          	sw	a5,-20(s0)

				if ((UINTPTR)BdPtr == (UINTPTR) RingPtr->BdaRestart) {
c000df28:	fdc42783          	lw	a5,-36(s0)
c000df2c:	0487a783          	lw	a5,72(a5)
c000df30:	00078713          	mv	a4,a5
c000df34:	fec42783          	lw	a5,-20(s0)
c000df38:	00e79c63          	bne	a5,a4,c000df50 <XAxiDma_UpdateBdRingCDesc+0x238>
					printf(
c000df3c:	07ff2517          	auipc	a0,0x7ff2
c000df40:	56050513          	addi	a0,a0,1376 # c800049c <__rodata_start+0x49c>
c000df44:	77d0f0ef          	jal	ra,c001dec0 <puts>
					"StartBdRingHw: Cannot find valid cdesc\r\n");

					return XST_DMA_ERROR;
c000df48:	00900793          	li	a5,9
c000df4c:	1700006f          	j	c000e0bc <XAxiDma_UpdateBdRingCDesc+0x3a4>
				}

				if (!XAxiDma_BdHwCompleted(BdPtr)) {
c000df50:	fec42783          	lw	a5,-20(s0)
c000df54:	01c78793          	addi	a5,a5,28
c000df58:	0007a783          	lw	a5,0(a5)
c000df5c:	1407c263          	bltz	a5,c000e0a0 <XAxiDma_UpdateBdRingCDesc+0x388>
					if (RingPtr->IsRxChannel) {
c000df60:	fdc42783          	lw	a5,-36(s0)
c000df64:	0047a783          	lw	a5,4(a5)
c000df68:	0e078063          	beqz	a5,c000e048 <XAxiDma_UpdateBdRingCDesc+0x330>
						if (!RingIndex) {
c000df6c:	fe842783          	lw	a5,-24(s0)
c000df70:	04079e63          	bnez	a5,c000dfcc <XAxiDma_UpdateBdRingCDesc+0x2b4>
							XAxiDma_WriteReg(RegBase,
c000df74:	fe442783          	lw	a5,-28(s0)
c000df78:	00878693          	addi	a3,a5,8
c000df7c:	fdc42783          	lw	a5,-36(s0)
c000df80:	0207a703          	lw	a4,32(a5)
c000df84:	fdc42783          	lw	a5,-36(s0)
c000df88:	0247a783          	lw	a5,36(a5)
c000df8c:	40f70733          	sub	a4,a4,a5
c000df90:	fec42783          	lw	a5,-20(s0)
c000df94:	00f707b3          	add	a5,a4,a5
c000df98:	fc07f793          	andi	a5,a5,-64
c000df9c:	00078593          	mv	a1,a5
c000dfa0:	00068513          	mv	a0,a3
c000dfa4:	d3dff0ef          	jal	ra,c000dce0 <Xil_Out32>
								XAXIDMA_CDESC_OFFSET,
								(XAXIDMA_VIRT_TO_PHYS(BdPtr) & XAXIDMA_DESC_LSB_MASK));
							if (RingPtr->Addr_ext)
c000dfa8:	fdc42783          	lw	a5,-36(s0)
c000dfac:	0187a783          	lw	a5,24(a5)
c000dfb0:	10078263          	beqz	a5,c000e0b4 <XAxiDma_UpdateBdRingCDesc+0x39c>
								XAxiDma_WriteReg(RegBase, XAXIDMA_CDESC_MSB_OFFSET,
c000dfb4:	fe442783          	lw	a5,-28(s0)
c000dfb8:	00c78793          	addi	a5,a5,12
c000dfbc:	00000593          	li	a1,0
c000dfc0:	00078513          	mv	a0,a5
c000dfc4:	d1dff0ef          	jal	ra,c000dce0 <Xil_Out32>
								(XAXIDMA_VIRT_TO_PHYS(BdPtr) & XAXIDMA_DESC_LSB_MASK));
						if (RingPtr->Addr_ext)
							XAxiDma_WriteReg(RegBase, XAXIDMA_CDESC_MSB_OFFSET,
									 UPPER_32_BITS(XAXIDMA_VIRT_TO_PHYS(BdPtr)));
					}
					break;
c000dfc8:	0ec0006f          	j	c000e0b4 <XAxiDma_UpdateBdRingCDesc+0x39c>
							XAxiDma_WriteReg(RegBase,
c000dfcc:	fe842783          	lw	a5,-24(s0)
c000dfd0:	00178793          	addi	a5,a5,1
c000dfd4:	00579793          	slli	a5,a5,0x5
c000dfd8:	00078713          	mv	a4,a5
c000dfdc:	fe442783          	lw	a5,-28(s0)
c000dfe0:	00f706b3          	add	a3,a4,a5
c000dfe4:	fdc42783          	lw	a5,-36(s0)
c000dfe8:	0207a703          	lw	a4,32(a5)
c000dfec:	fdc42783          	lw	a5,-36(s0)
c000dff0:	0247a783          	lw	a5,36(a5)
c000dff4:	40f70733          	sub	a4,a4,a5
c000dff8:	fec42783          	lw	a5,-20(s0)
c000dffc:	00f707b3          	add	a5,a4,a5
c000e000:	fc07f793          	andi	a5,a5,-64
c000e004:	00078593          	mv	a1,a5
c000e008:	00068513          	mv	a0,a3
c000e00c:	cd5ff0ef          	jal	ra,c000dce0 <Xil_Out32>
							if (RingPtr->Addr_ext)
c000e010:	fdc42783          	lw	a5,-36(s0)
c000e014:	0187a783          	lw	a5,24(a5)
c000e018:	08078e63          	beqz	a5,c000e0b4 <XAxiDma_UpdateBdRingCDesc+0x39c>
								XAxiDma_WriteReg(RegBase,
c000e01c:	fe842783          	lw	a5,-24(s0)
c000e020:	fff78793          	addi	a5,a5,-1
c000e024:	00579793          	slli	a5,a5,0x5
c000e028:	00078713          	mv	a4,a5
c000e02c:	fe442783          	lw	a5,-28(s0)
c000e030:	00f707b3          	add	a5,a4,a5
c000e034:	04478793          	addi	a5,a5,68
c000e038:	00000593          	li	a1,0
c000e03c:	00078513          	mv	a0,a5
c000e040:	ca1ff0ef          	jal	ra,c000dce0 <Xil_Out32>
					break;
c000e044:	0700006f          	j	c000e0b4 <XAxiDma_UpdateBdRingCDesc+0x39c>
						XAxiDma_WriteReg(RegBase,
c000e048:	fe442783          	lw	a5,-28(s0)
c000e04c:	00878693          	addi	a3,a5,8
c000e050:	fdc42783          	lw	a5,-36(s0)
c000e054:	0207a703          	lw	a4,32(a5)
c000e058:	fdc42783          	lw	a5,-36(s0)
c000e05c:	0247a783          	lw	a5,36(a5)
c000e060:	40f70733          	sub	a4,a4,a5
c000e064:	fec42783          	lw	a5,-20(s0)
c000e068:	00f707b3          	add	a5,a4,a5
c000e06c:	fc07f793          	andi	a5,a5,-64
c000e070:	00078593          	mv	a1,a5
c000e074:	00068513          	mv	a0,a3
c000e078:	c69ff0ef          	jal	ra,c000dce0 <Xil_Out32>
						if (RingPtr->Addr_ext)
c000e07c:	fdc42783          	lw	a5,-36(s0)
c000e080:	0187a783          	lw	a5,24(a5)
c000e084:	02078863          	beqz	a5,c000e0b4 <XAxiDma_UpdateBdRingCDesc+0x39c>
							XAxiDma_WriteReg(RegBase, XAXIDMA_CDESC_MSB_OFFSET,
c000e088:	fe442783          	lw	a5,-28(s0)
c000e08c:	00c78793          	addi	a5,a5,12
c000e090:	00000593          	li	a1,0
c000e094:	00078513          	mv	a0,a5
c000e098:	c49ff0ef          	jal	ra,c000dce0 <Xil_Out32>
					break;
c000e09c:	0180006f          	j	c000e0b4 <XAxiDma_UpdateBdRingCDesc+0x39c>
			while (XAxiDma_BdHwCompleted(BdPtr)) {
c000e0a0:	fec42783          	lw	a5,-20(s0)
c000e0a4:	01c78793          	addi	a5,a5,28
c000e0a8:	0007a783          	lw	a5,0(a5)
c000e0ac:	e407c6e3          	bltz	a5,c000def8 <XAxiDma_UpdateBdRingCDesc+0x1e0>
c000e0b0:	0080006f          	j	c000e0b8 <XAxiDma_UpdateBdRingCDesc+0x3a0>
					break;
c000e0b4:	00000013          	nop
			}
		}

	}

	return XST_SUCCESS;
c000e0b8:	00000793          	li	a5,0
}
c000e0bc:	00078513          	mv	a0,a5
c000e0c0:	02c12083          	lw	ra,44(sp)
c000e0c4:	02812403          	lw	s0,40(sp)
c000e0c8:	03010113          	addi	sp,sp,48
c000e0cc:	00008067          	ret

c000e0d0 <XAxiDma_BdRingCreate>:
 * @note	This function can be used only when DMA is in SG mode
 *
 *****************************************************************************/
u32 XAxiDma_BdRingCreate(XAxiDma_BdRing *RingPtr, UINTPTR PhysAddr,
			UINTPTR VirtAddr, u32 Alignment, int BdCount)
{
c000e0d0:	fc010113          	addi	sp,sp,-64
c000e0d4:	02112e23          	sw	ra,60(sp)
c000e0d8:	02812c23          	sw	s0,56(sp)
c000e0dc:	04010413          	addi	s0,sp,64
c000e0e0:	fca42e23          	sw	a0,-36(s0)
c000e0e4:	fcb42c23          	sw	a1,-40(s0)
c000e0e8:	fcc42a23          	sw	a2,-44(s0)
c000e0ec:	fcd42823          	sw	a3,-48(s0)
c000e0f0:	fce42623          	sw	a4,-52(s0)
	int i;
	UINTPTR BdVirtAddr;
	UINTPTR BdPhysAddr;

	if (BdCount <= 0) {
c000e0f4:	fcc42783          	lw	a5,-52(s0)
c000e0f8:	00f04e63          	bgtz	a5,c000e114 <XAxiDma_BdRingCreate+0x44>

		printf("BdRingCreate: non-positive BD"
c000e0fc:	fcc42583          	lw	a1,-52(s0)
c000e100:	07ff2517          	auipc	a0,0x7ff2
c000e104:	3c450513          	addi	a0,a0,964 # c80004c4 <__rodata_start+0x4c4>
c000e108:	49d0f0ef          	jal	ra,c001dda4 <printf>
				" number %d\r\n", BdCount);

		return XST_INVALID_PARAM;
c000e10c:	00f00793          	li	a5,15
c000e110:	32c0006f          	j	c000e43c <XAxiDma_BdRingCreate+0x36c>

	/* In case there is a failure prior to creating list, make sure the
	 * following attributes are 0 to prevent calls to other SG functions
	 * from doing anything
	 */
	RingPtr->AllCnt = 0;
c000e114:	fdc42783          	lw	a5,-36(s0)
c000e118:	0607a023          	sw	zero,96(a5)
	RingPtr->FreeCnt = 0;
c000e11c:	fdc42783          	lw	a5,-36(s0)
c000e120:	0407a823          	sw	zero,80(a5)
	RingPtr->HwCnt = 0;
c000e124:	fdc42783          	lw	a5,-36(s0)
c000e128:	0407ac23          	sw	zero,88(a5)
	RingPtr->PreCnt = 0;
c000e12c:	fdc42783          	lw	a5,-36(s0)
c000e130:	0407aa23          	sw	zero,84(a5)
	RingPtr->PostCnt = 0;
c000e134:	fdc42783          	lw	a5,-36(s0)
c000e138:	0407ae23          	sw	zero,92(a5)
	RingPtr->Cyclic = 0;
c000e13c:	fdc42783          	lw	a5,-36(s0)
c000e140:	0607a423          	sw	zero,104(a5)

	/* Make sure Alignment parameter meets minimum requirements */
	if (Alignment < XAXIDMA_BD_MINIMUM_ALIGNMENT) {
c000e144:	fd042703          	lw	a4,-48(s0)
c000e148:	03f00793          	li	a5,63
c000e14c:	02e7e263          	bltu	a5,a4,c000e170 <XAxiDma_BdRingCreate+0xa0>

		printf("BdRingCreate: alignment too "
c000e150:	fd042783          	lw	a5,-48(s0)
c000e154:	04000613          	li	a2,64
c000e158:	00078593          	mv	a1,a5
c000e15c:	07ff2517          	auipc	a0,0x7ff2
c000e160:	39450513          	addi	a0,a0,916 # c80004f0 <__rodata_start+0x4f0>
c000e164:	4410f0ef          	jal	ra,c001dda4 <printf>
		"small %d, need to be at least %d\r\n", (int)Alignment,
			XAXIDMA_BD_MINIMUM_ALIGNMENT);

		return XST_INVALID_PARAM;
c000e168:	00f00793          	li	a5,15
c000e16c:	2d00006f          	j	c000e43c <XAxiDma_BdRingCreate+0x36c>
	}

	/* Make sure Alignment is a power of 2 */
	if ((Alignment - 1) & Alignment) {
c000e170:	fd042783          	lw	a5,-48(s0)
c000e174:	fff78713          	addi	a4,a5,-1
c000e178:	fd042783          	lw	a5,-48(s0)
c000e17c:	00f777b3          	and	a5,a4,a5
c000e180:	02078063          	beqz	a5,c000e1a0 <XAxiDma_BdRingCreate+0xd0>

		printf("BdRingCreate: alignment not"
c000e184:	fd042783          	lw	a5,-48(s0)
c000e188:	00078593          	mv	a1,a5
c000e18c:	07ff2517          	auipc	a0,0x7ff2
c000e190:	3a450513          	addi	a0,a0,932 # c8000530 <__rodata_start+0x530>
c000e194:	4110f0ef          	jal	ra,c001dda4 <printf>
				" valid %d\r\n", (int)Alignment);

		return XST_INVALID_PARAM;
c000e198:	00f00793          	li	a5,15
c000e19c:	2a00006f          	j	c000e43c <XAxiDma_BdRingCreate+0x36c>
	}

	/* Make sure PhysAddr and VirtAddr are on same Alignment */
	if ((PhysAddr % Alignment) || (VirtAddr % Alignment)) {
c000e1a0:	fd842703          	lw	a4,-40(s0)
c000e1a4:	fd042783          	lw	a5,-48(s0)
c000e1a8:	02f777b3          	remu	a5,a4,a5
c000e1ac:	00079a63          	bnez	a5,c000e1c0 <XAxiDma_BdRingCreate+0xf0>
c000e1b0:	fd442703          	lw	a4,-44(s0)
c000e1b4:	fd042783          	lw	a5,-48(s0)
c000e1b8:	02f777b3          	remu	a5,a4,a5
c000e1bc:	02078063          	beqz	a5,c000e1dc <XAxiDma_BdRingCreate+0x10c>

		printf("BdRingCreate: Physical address"
c000e1c0:	fd442603          	lw	a2,-44(s0)
c000e1c4:	fd842583          	lw	a1,-40(s0)
c000e1c8:	07ff2517          	auipc	a0,0x7ff2
c000e1cc:	39050513          	addi	a0,a0,912 # c8000558 <__rodata_start+0x558>
c000e1d0:	3d50f0ef          	jal	ra,c001dda4 <printf>
		" %x and virtual address %x have different alignment\r\n",
			(unsigned int)PhysAddr, (unsigned int)VirtAddr);

		return XST_INVALID_PARAM;
c000e1d4:	00f00793          	li	a5,15
c000e1d8:	2640006f          	j	c000e43c <XAxiDma_BdRingCreate+0x36c>
	}

	/* Compute how many bytes will be between the start of adjacent BDs */
	RingPtr->Separation =
		(sizeof(XAxiDma_Bd) + (Alignment - 1)) & ~(Alignment - 1);
c000e1dc:	fd042783          	lw	a5,-48(s0)
c000e1e0:	03f78713          	addi	a4,a5,63
c000e1e4:	fd042783          	lw	a5,-48(s0)
c000e1e8:	40f007b3          	neg	a5,a5
c000e1ec:	00f77733          	and	a4,a4,a5
	RingPtr->Separation =
c000e1f0:	fdc42783          	lw	a5,-36(s0)
c000e1f4:	02e7a823          	sw	a4,48(a5)

	/* Must make sure the ring doesn't span address 0x00000000. If it does,
	 * then the next/prev BD traversal macros will fail.
	 */
	if (VirtAddr > (VirtAddr + (RingPtr->Separation * BdCount) - 1)) {
c000e1f8:	fdc42783          	lw	a5,-36(s0)
c000e1fc:	0307a703          	lw	a4,48(a5)
c000e200:	fcc42783          	lw	a5,-52(s0)
c000e204:	02f70733          	mul	a4,a4,a5
c000e208:	fd442783          	lw	a5,-44(s0)
c000e20c:	00f707b3          	add	a5,a4,a5
c000e210:	fff78793          	addi	a5,a5,-1
c000e214:	fd442703          	lw	a4,-44(s0)
c000e218:	00e7fc63          	bgeu	a5,a4,c000e230 <XAxiDma_BdRingCreate+0x160>

		printf("BdRingCreate: BD space cross "
c000e21c:	07ff2517          	auipc	a0,0x7ff2
c000e220:	39050513          	addi	a0,a0,912 # c80005ac <__rodata_start+0x5ac>
c000e224:	49d0f0ef          	jal	ra,c001dec0 <puts>
			"0x0\r\n");

		return XST_DMA_SG_LIST_ERROR;
c000e228:	20e00793          	li	a5,526
c000e22c:	2100006f          	j	c000e43c <XAxiDma_BdRingCreate+0x36c>
	 *  - Clear the entire space
	 *  - Setup each BD's next pointer with the physical address of the
	 *    next BD
	 *  - Put hardware information in each BD
	 */
	memset((void *) VirtAddr, 0, (RingPtr->Separation * BdCount));
c000e230:	fd442683          	lw	a3,-44(s0)
c000e234:	fdc42783          	lw	a5,-36(s0)
c000e238:	0307a703          	lw	a4,48(a5)
c000e23c:	fcc42783          	lw	a5,-52(s0)
c000e240:	02f707b3          	mul	a5,a4,a5
c000e244:	00078613          	mv	a2,a5
c000e248:	00000593          	li	a1,0
c000e24c:	00068513          	mv	a0,a3
c000e250:	2390f0ef          	jal	ra,c001dc88 <memset>

	BdVirtAddr = VirtAddr;
c000e254:	fd442783          	lw	a5,-44(s0)
c000e258:	fef42423          	sw	a5,-24(s0)
	BdPhysAddr = PhysAddr + RingPtr->Separation;
c000e25c:	fdc42783          	lw	a5,-36(s0)
c000e260:	0307a783          	lw	a5,48(a5)
c000e264:	fd842703          	lw	a4,-40(s0)
c000e268:	00f707b3          	add	a5,a4,a5
c000e26c:	fef42223          	sw	a5,-28(s0)
	for (i = 1; i < BdCount; i++) {
c000e270:	00100793          	li	a5,1
c000e274:	fef42623          	sw	a5,-20(s0)
c000e278:	0900006f          	j	c000e308 <XAxiDma_BdRingCreate+0x238>
		XAxiDma_BdWrite(BdVirtAddr, XAXIDMA_BD_NDESC_OFFSET,
c000e27c:	fe842783          	lw	a5,-24(s0)
c000e280:	fe442703          	lw	a4,-28(s0)
c000e284:	fc077713          	andi	a4,a4,-64
c000e288:	00e7a023          	sw	a4,0(a5)
				(BdPhysAddr & XAXIDMA_DESC_LSB_MASK));
		XAxiDma_BdWrite(BdVirtAddr, XAXIDMA_BD_NDESC_MSB_OFFSET,
c000e28c:	fe842783          	lw	a5,-24(s0)
c000e290:	00478793          	addi	a5,a5,4
c000e294:	0007a023          	sw	zero,0(a5)
				UPPER_32_BITS(BdPhysAddr));

		/* Put hardware information in the BDs
		 */
		XAxiDma_BdWrite(BdVirtAddr, XAXIDMA_BD_HAS_STSCNTRL_OFFSET,
c000e298:	fdc42783          	lw	a5,-36(s0)
c000e29c:	00c7a703          	lw	a4,12(a5)
c000e2a0:	fe842783          	lw	a5,-24(s0)
c000e2a4:	03878793          	addi	a5,a5,56
c000e2a8:	00e7a023          	sw	a4,0(a5)
				(u32)RingPtr->HasStsCntrlStrm);

		XAxiDma_BdWrite(BdVirtAddr, XAXIDMA_BD_HAS_DRE_OFFSET,
c000e2ac:	fdc42783          	lw	a5,-36(s0)
c000e2b0:	0107a783          	lw	a5,16(a5)
c000e2b4:	00879793          	slli	a5,a5,0x8
c000e2b8:	fdc42703          	lw	a4,-36(s0)
c000e2bc:	01472703          	lw	a4,20(a4)
c000e2c0:	00070693          	mv	a3,a4
c000e2c4:	fe842703          	lw	a4,-24(s0)
c000e2c8:	03c70713          	addi	a4,a4,60
c000e2cc:	00d7e7b3          	or	a5,a5,a3
c000e2d0:	00f72023          	sw	a5,0(a4)
		    (((u32)(RingPtr->HasDRE)) << XAXIDMA_BD_HAS_DRE_SHIFT) |
		    RingPtr->DataWidth);

		XAXIDMA_CACHE_FLUSH(BdVirtAddr);
		BdVirtAddr += RingPtr->Separation;
c000e2d4:	fdc42783          	lw	a5,-36(s0)
c000e2d8:	0307a783          	lw	a5,48(a5)
c000e2dc:	fe842703          	lw	a4,-24(s0)
c000e2e0:	00f707b3          	add	a5,a4,a5
c000e2e4:	fef42423          	sw	a5,-24(s0)
		BdPhysAddr += RingPtr->Separation;
c000e2e8:	fdc42783          	lw	a5,-36(s0)
c000e2ec:	0307a783          	lw	a5,48(a5)
c000e2f0:	fe442703          	lw	a4,-28(s0)
c000e2f4:	00f707b3          	add	a5,a4,a5
c000e2f8:	fef42223          	sw	a5,-28(s0)
	for (i = 1; i < BdCount; i++) {
c000e2fc:	fec42783          	lw	a5,-20(s0)
c000e300:	00178793          	addi	a5,a5,1
c000e304:	fef42623          	sw	a5,-20(s0)
c000e308:	fec42703          	lw	a4,-20(s0)
c000e30c:	fcc42783          	lw	a5,-52(s0)
c000e310:	f6f746e3          	blt	a4,a5,c000e27c <XAxiDma_BdRingCreate+0x1ac>
	}

	/* At the end of the ring, link the last BD back to the top */
	XAxiDma_BdWrite(BdVirtAddr, XAXIDMA_BD_NDESC_OFFSET,
c000e314:	fe842783          	lw	a5,-24(s0)
c000e318:	fd842703          	lw	a4,-40(s0)
c000e31c:	fc077713          	andi	a4,a4,-64
c000e320:	00e7a023          	sw	a4,0(a5)
			(PhysAddr & XAXIDMA_DESC_LSB_MASK));
	XAxiDma_BdWrite(BdVirtAddr, XAXIDMA_BD_NDESC_MSB_OFFSET,
c000e324:	fe842783          	lw	a5,-24(s0)
c000e328:	00478793          	addi	a5,a5,4
c000e32c:	0007a023          	sw	zero,0(a5)
			UPPER_32_BITS(PhysAddr));


	/* Setup the last BD's hardware information */
	XAxiDma_BdWrite(BdVirtAddr, XAXIDMA_BD_HAS_STSCNTRL_OFFSET,
c000e330:	fdc42783          	lw	a5,-36(s0)
c000e334:	00c7a703          	lw	a4,12(a5)
c000e338:	fe842783          	lw	a5,-24(s0)
c000e33c:	03878793          	addi	a5,a5,56
c000e340:	00e7a023          	sw	a4,0(a5)
		(u32)RingPtr->HasStsCntrlStrm);

	XAxiDma_BdWrite(BdVirtAddr, XAXIDMA_BD_HAS_DRE_OFFSET,
c000e344:	fdc42783          	lw	a5,-36(s0)
c000e348:	0107a783          	lw	a5,16(a5)
c000e34c:	00879793          	slli	a5,a5,0x8
c000e350:	fdc42703          	lw	a4,-36(s0)
c000e354:	01472703          	lw	a4,20(a4)
c000e358:	00070693          	mv	a3,a4
c000e35c:	fe842703          	lw	a4,-24(s0)
c000e360:	03c70713          	addi	a4,a4,60
c000e364:	00d7e7b3          	or	a5,a5,a3
c000e368:	00f72023          	sw	a5,0(a4)
	    (((u32)(RingPtr->HasDRE)) << XAXIDMA_BD_HAS_DRE_SHIFT) |
	    RingPtr->DataWidth);

	/* Setup and initialize pointers and counters */
	RingPtr->RunState = AXIDMA_CHANNEL_HALTED;
c000e36c:	fdc42783          	lw	a5,-36(s0)
c000e370:	00200713          	li	a4,2
c000e374:	00e7a423          	sw	a4,8(a5)
	RingPtr->FirstBdAddr = VirtAddr;
c000e378:	fdc42783          	lw	a5,-36(s0)
c000e37c:	fd442703          	lw	a4,-44(s0)
c000e380:	02e7a223          	sw	a4,36(a5)
	RingPtr->FirstBdPhysAddr = PhysAddr;
c000e384:	fdc42783          	lw	a5,-36(s0)
c000e388:	fd842703          	lw	a4,-40(s0)
c000e38c:	02e7a023          	sw	a4,32(a5)
	RingPtr->LastBdAddr = BdVirtAddr;
c000e390:	fdc42783          	lw	a5,-36(s0)
c000e394:	fe842703          	lw	a4,-24(s0)
c000e398:	02e7a423          	sw	a4,40(a5)
	RingPtr->Length = RingPtr->LastBdAddr - RingPtr->FirstBdAddr +
c000e39c:	fdc42783          	lw	a5,-36(s0)
c000e3a0:	0287a703          	lw	a4,40(a5)
c000e3a4:	fdc42783          	lw	a5,-36(s0)
c000e3a8:	0247a783          	lw	a5,36(a5)
c000e3ac:	40f70733          	sub	a4,a4,a5
		RingPtr->Separation;
c000e3b0:	fdc42783          	lw	a5,-36(s0)
c000e3b4:	0307a783          	lw	a5,48(a5)
	RingPtr->Length = RingPtr->LastBdAddr - RingPtr->FirstBdAddr +
c000e3b8:	00f70733          	add	a4,a4,a5
c000e3bc:	fdc42783          	lw	a5,-36(s0)
c000e3c0:	02e7a623          	sw	a4,44(a5)
	RingPtr->AllCnt = BdCount;
c000e3c4:	fdc42783          	lw	a5,-36(s0)
c000e3c8:	fcc42703          	lw	a4,-52(s0)
c000e3cc:	06e7a023          	sw	a4,96(a5)
	RingPtr->FreeCnt = BdCount;
c000e3d0:	fdc42783          	lw	a5,-36(s0)
c000e3d4:	fcc42703          	lw	a4,-52(s0)
c000e3d8:	04e7a823          	sw	a4,80(a5)
	RingPtr->FreeHead = (XAxiDma_Bd *) VirtAddr;
c000e3dc:	fd442703          	lw	a4,-44(s0)
c000e3e0:	fdc42783          	lw	a5,-36(s0)
c000e3e4:	02e7aa23          	sw	a4,52(a5)
	RingPtr->PreHead = (XAxiDma_Bd *) VirtAddr;
c000e3e8:	fd442703          	lw	a4,-44(s0)
c000e3ec:	fdc42783          	lw	a5,-36(s0)
c000e3f0:	02e7ac23          	sw	a4,56(a5)
	RingPtr->HwHead = (XAxiDma_Bd *) VirtAddr;
c000e3f4:	fd442703          	lw	a4,-44(s0)
c000e3f8:	fdc42783          	lw	a5,-36(s0)
c000e3fc:	02e7ae23          	sw	a4,60(a5)
	RingPtr->HwTail = (XAxiDma_Bd *) VirtAddr;
c000e400:	fd442703          	lw	a4,-44(s0)
c000e404:	fdc42783          	lw	a5,-36(s0)
c000e408:	04e7a023          	sw	a4,64(a5)
	RingPtr->PostHead = (XAxiDma_Bd *) VirtAddr;
c000e40c:	fd442703          	lw	a4,-44(s0)
c000e410:	fdc42783          	lw	a5,-36(s0)
c000e414:	04e7a223          	sw	a4,68(a5)
	RingPtr->BdaRestart = (XAxiDma_Bd *) VirtAddr;
c000e418:	fd442703          	lw	a4,-44(s0)
c000e41c:	fdc42783          	lw	a5,-36(s0)
c000e420:	04e7a423          	sw	a4,72(a5)
	RingPtr->CyclicBd = (XAxiDma_Bd *) pvPortMalloc(sizeof(XAxiDma_Bd));
c000e424:	04000513          	li	a0,64
c000e428:	e8dfa0ef          	jal	ra,c00092b4 <pvPortMalloc>
c000e42c:	00050713          	mv	a4,a0
c000e430:	fdc42783          	lw	a5,-36(s0)
c000e434:	04e7a623          	sw	a4,76(a5)

	return XST_SUCCESS;
c000e438:	00000793          	li	a5,0
}
c000e43c:	00078513          	mv	a0,a5
c000e440:	03c12083          	lw	ra,60(sp)
c000e444:	03812403          	lw	s0,56(sp)
c000e448:	04010113          	addi	sp,sp,64
c000e44c:	00008067          	ret

c000e450 <XAxiDma_BdRingClone>:
 *
 * @note	This function can be used only when DMA is in SG mode
 *
 *****************************************************************************/
int XAxiDma_BdRingClone(XAxiDma_BdRing * RingPtr, XAxiDma_Bd * SrcBdPtr)
{
c000e450:	f9010113          	addi	sp,sp,-112
c000e454:	06112623          	sw	ra,108(sp)
c000e458:	06812423          	sw	s0,104(sp)
c000e45c:	07010413          	addi	s0,sp,112
c000e460:	f8a42e23          	sw	a0,-100(s0)
c000e464:	f8b42c23          	sw	a1,-104(s0)
	UINTPTR CurBd;
	u32 Save;
	XAxiDma_Bd TmpBd;

	/* Can't do this function if there isn't a ring */
	if (RingPtr->AllCnt == 0) {
c000e468:	f9c42783          	lw	a5,-100(s0)
c000e46c:	0607a783          	lw	a5,96(a5)
c000e470:	00079c63          	bnez	a5,c000e488 <XAxiDma_BdRingClone+0x38>

		printf("BdRingClone: no bds\r\n");
c000e474:	07ff2517          	auipc	a0,0x7ff2
c000e478:	15c50513          	addi	a0,a0,348 # c80005d0 <__rodata_start+0x5d0>
c000e47c:	2450f0ef          	jal	ra,c001dec0 <puts>

		return XST_DMA_SG_NO_LIST;
c000e480:	20b00793          	li	a5,523
c000e484:	1200006f          	j	c000e5a4 <XAxiDma_BdRingClone+0x154>
	}

	/* Can't do this function with the channel running */
	if (RingPtr->RunState == AXIDMA_CHANNEL_NOT_HALTED) {
c000e488:	f9c42783          	lw	a5,-100(s0)
c000e48c:	0087a703          	lw	a4,8(a5)
c000e490:	00100793          	li	a5,1
c000e494:	00f71c63          	bne	a4,a5,c000e4ac <XAxiDma_BdRingClone+0x5c>

		printf("BdRingClone: bd ring started "
c000e498:	07ff2517          	auipc	a0,0x7ff2
c000e49c:	15050513          	addi	a0,a0,336 # c80005e8 <__rodata_start+0x5e8>
c000e4a0:	2210f0ef          	jal	ra,c001dec0 <puts>
			"already, cannot do\r\n");

		return XST_DEVICE_IS_STARTED;
c000e4a4:	00500793          	li	a5,5
c000e4a8:	0fc0006f          	j	c000e5a4 <XAxiDma_BdRingClone+0x154>
	}

	/* Can't do this function with some of the BDs in use */
	if (RingPtr->FreeCnt != RingPtr->AllCnt) {
c000e4ac:	f9c42783          	lw	a5,-100(s0)
c000e4b0:	0507a703          	lw	a4,80(a5)
c000e4b4:	f9c42783          	lw	a5,-100(s0)
c000e4b8:	0607a783          	lw	a5,96(a5)
c000e4bc:	02f70863          	beq	a4,a5,c000e4ec <XAxiDma_BdRingClone+0x9c>

		printf("BdRingClone: some bds already "
c000e4c0:	f9c42783          	lw	a5,-100(s0)
c000e4c4:	0507a703          	lw	a4,80(a5)
c000e4c8:	f9c42783          	lw	a5,-100(s0)
c000e4cc:	0607a783          	lw	a5,96(a5)
c000e4d0:	00078613          	mv	a2,a5
c000e4d4:	00070593          	mv	a1,a4
c000e4d8:	07ff2517          	auipc	a0,0x7ff2
c000e4dc:	14450513          	addi	a0,a0,324 # c800061c <__rodata_start+0x61c>
c000e4e0:	0c50f0ef          	jal	ra,c001dda4 <printf>
			"in use %d/%d\r\n",RingPtr->FreeCnt, RingPtr->AllCnt);

		return XST_DMA_SG_LIST_ERROR;
c000e4e4:	20e00793          	li	a5,526
c000e4e8:	0bc0006f          	j	c000e5a4 <XAxiDma_BdRingClone+0x154>
	}

	/* Make a copy of the template then modify it by clearing
	 * the complete bit in status/control field
	 */
	memcpy(&TmpBd, SrcBdPtr, sizeof(XAxiDma_Bd));
c000e4ec:	fa440793          	addi	a5,s0,-92
c000e4f0:	04000613          	li	a2,64
c000e4f4:	f9842583          	lw	a1,-104(s0)
c000e4f8:	00078513          	mv	a0,a5
c000e4fc:	6640f0ef          	jal	ra,c001db60 <memcpy>

	Save = XAxiDma_BdRead(&TmpBd, XAXIDMA_BD_STS_OFFSET);
c000e500:	fa440793          	addi	a5,s0,-92
c000e504:	01c78793          	addi	a5,a5,28
c000e508:	0007a783          	lw	a5,0(a5)
c000e50c:	fef42223          	sw	a5,-28(s0)
	Save &= ~XAXIDMA_BD_STS_COMPLETE_MASK;
c000e510:	fe442703          	lw	a4,-28(s0)
c000e514:	800007b7          	lui	a5,0x80000
c000e518:	fff7c793          	not	a5,a5
c000e51c:	00f777b3          	and	a5,a4,a5
c000e520:	fef42223          	sw	a5,-28(s0)
	XAxiDma_BdWrite(&TmpBd, XAXIDMA_BD_STS_OFFSET, Save);
c000e524:	fa440793          	addi	a5,s0,-92
c000e528:	01c78793          	addi	a5,a5,28 # 8000001c <_end+0xb7f7b79c>
c000e52c:	00078713          	mv	a4,a5
c000e530:	fe442783          	lw	a5,-28(s0)
c000e534:	00f72023          	sw	a5,0(a4)

	for (i = 0, CurBd = RingPtr->FirstBdAddr;
c000e538:	fe042623          	sw	zero,-20(s0)
c000e53c:	f9c42783          	lw	a5,-100(s0)
c000e540:	0247a783          	lw	a5,36(a5)
c000e544:	fef42423          	sw	a5,-24(s0)
c000e548:	0480006f          	j	c000e590 <XAxiDma_BdRingClone+0x140>
	     i < RingPtr->AllCnt; i++, CurBd += RingPtr->Separation) {

		memcpy((void *)((UINTPTR)CurBd + XAXIDMA_BD_START_CLEAR),
c000e54c:	fe842783          	lw	a5,-24(s0)
c000e550:	00878793          	addi	a5,a5,8
c000e554:	00078713          	mv	a4,a5
		    (void *)((UINTPTR)(&TmpBd) + XAXIDMA_BD_START_CLEAR),
c000e558:	fa440793          	addi	a5,s0,-92
c000e55c:	00878793          	addi	a5,a5,8
		memcpy((void *)((UINTPTR)CurBd + XAXIDMA_BD_START_CLEAR),
c000e560:	03000613          	li	a2,48
c000e564:	00078593          	mv	a1,a5
c000e568:	00070513          	mv	a0,a4
c000e56c:	5f40f0ef          	jal	ra,c001db60 <memcpy>
	     i < RingPtr->AllCnt; i++, CurBd += RingPtr->Separation) {
c000e570:	fec42783          	lw	a5,-20(s0)
c000e574:	00178793          	addi	a5,a5,1
c000e578:	fef42623          	sw	a5,-20(s0)
c000e57c:	f9c42783          	lw	a5,-100(s0)
c000e580:	0307a783          	lw	a5,48(a5)
c000e584:	fe842703          	lw	a4,-24(s0)
c000e588:	00f707b3          	add	a5,a4,a5
c000e58c:	fef42423          	sw	a5,-24(s0)
c000e590:	f9c42783          	lw	a5,-100(s0)
c000e594:	0607a783          	lw	a5,96(a5)
	for (i = 0, CurBd = RingPtr->FirstBdAddr;
c000e598:	fec42703          	lw	a4,-20(s0)
c000e59c:	faf748e3          	blt	a4,a5,c000e54c <XAxiDma_BdRingClone+0xfc>
		    XAXIDMA_BD_BYTES_TO_CLEAR);

		XAXIDMA_CACHE_FLUSH(CurBd);
	}

	return XST_SUCCESS;
c000e5a0:	00000793          	li	a5,0
}
c000e5a4:	00078513          	mv	a0,a5
c000e5a8:	06c12083          	lw	ra,108(sp)
c000e5ac:	06812403          	lw	s0,104(sp)
c000e5b0:	07010113          	addi	sp,sp,112
c000e5b4:	00008067          	ret

c000e5b8 <XAxiDma_StartBdRingHw>:
 *
 * @note	This function can be used only when DMA is in SG mode
 *
 *****************************************************************************/
int XAxiDma_StartBdRingHw(XAxiDma_BdRing * RingPtr)
{
c000e5b8:	fd010113          	addi	sp,sp,-48
c000e5bc:	02112623          	sw	ra,44(sp)
c000e5c0:	02812423          	sw	s0,40(sp)
c000e5c4:	03010413          	addi	s0,sp,48
c000e5c8:	fca42e23          	sw	a0,-36(s0)
	UINTPTR RegBase;
	int RingIndex = RingPtr->RingIndex;
c000e5cc:	fdc42783          	lw	a5,-36(s0)
c000e5d0:	0647a783          	lw	a5,100(a5)
c000e5d4:	fef42623          	sw	a5,-20(s0)

	if (!XAxiDma_BdRingHwIsStarted(RingPtr)) {
c000e5d8:	fdc42783          	lw	a5,-36(s0)
c000e5dc:	0007a783          	lw	a5,0(a5)
c000e5e0:	00478793          	addi	a5,a5,4
c000e5e4:	00078513          	mv	a0,a5
c000e5e8:	ed0ff0ef          	jal	ra,c000dcb8 <Xil_In32>
c000e5ec:	00050793          	mv	a5,a0
c000e5f0:	0017f793          	andi	a5,a5,1
c000e5f4:	02078663          	beqz	a5,c000e620 <XAxiDma_StartBdRingHw+0x68>
		/* Start the hardware
		*/
		RegBase = RingPtr->ChanBase;
c000e5f8:	fdc42783          	lw	a5,-36(s0)
c000e5fc:	0007a783          	lw	a5,0(a5)
c000e600:	fef42423          	sw	a5,-24(s0)
		XAxiDma_WriteReg(RegBase, XAXIDMA_CR_OFFSET,
c000e604:	fe842503          	lw	a0,-24(s0)
c000e608:	eb0ff0ef          	jal	ra,c000dcb8 <Xil_In32>
c000e60c:	00050793          	mv	a5,a0
c000e610:	0017e793          	ori	a5,a5,1
c000e614:	00078593          	mv	a1,a5
c000e618:	fe842503          	lw	a0,-24(s0)
c000e61c:	ec4ff0ef          	jal	ra,c000dce0 <Xil_Out32>
			XAxiDma_ReadReg(RegBase, XAXIDMA_CR_OFFSET)
			| XAXIDMA_CR_RUNSTOP_MASK);
	}

	if (XAxiDma_BdRingHwIsStarted(RingPtr)) {
c000e620:	fdc42783          	lw	a5,-36(s0)
c000e624:	0007a783          	lw	a5,0(a5)
c000e628:	00478793          	addi	a5,a5,4
c000e62c:	00078513          	mv	a0,a5
c000e630:	e88ff0ef          	jal	ra,c000dcb8 <Xil_In32>
c000e634:	00050793          	mv	a5,a0
c000e638:	0017f793          	andi	a5,a5,1
c000e63c:	20079a63          	bnez	a5,c000e850 <XAxiDma_StartBdRingHw+0x298>
		/* Note as started */
		RingPtr->RunState = AXIDMA_CHANNEL_NOT_HALTED;
c000e640:	fdc42783          	lw	a5,-36(s0)
c000e644:	00100713          	li	a4,1
c000e648:	00e7a423          	sw	a4,8(a5)

		/* If there are unprocessed BDs then we want the channel to begin
		 * processing right away
		 */
		if (RingPtr->HwCnt > 0) {
c000e64c:	fdc42783          	lw	a5,-36(s0)
c000e650:	0587a783          	lw	a5,88(a5)
c000e654:	1ef05a63          	blez	a5,c000e848 <XAxiDma_StartBdRingHw+0x290>

			XAXIDMA_CACHE_INVALIDATE(RingPtr->HwTail);
			if (RingPtr->Cyclic) {
c000e658:	fdc42783          	lw	a5,-36(s0)
c000e65c:	0687a783          	lw	a5,104(a5)
c000e660:	06078663          	beqz	a5,c000e6cc <XAxiDma_StartBdRingHw+0x114>
				XAxiDma_WriteReg(RingPtr->ChanBase,
c000e664:	fdc42783          	lw	a5,-36(s0)
c000e668:	0007a783          	lw	a5,0(a5)
c000e66c:	01078693          	addi	a3,a5,16
c000e670:	fdc42783          	lw	a5,-36(s0)
c000e674:	04c7a783          	lw	a5,76(a5)
c000e678:	00078613          	mv	a2,a5
c000e67c:	fdc42783          	lw	a5,-36(s0)
c000e680:	0207a703          	lw	a4,32(a5)
c000e684:	fdc42783          	lw	a5,-36(s0)
c000e688:	0247a783          	lw	a5,36(a5)
c000e68c:	40f707b3          	sub	a5,a4,a5
c000e690:	00f607b3          	add	a5,a2,a5
c000e694:	00078593          	mv	a1,a5
c000e698:	00068513          	mv	a0,a3
c000e69c:	e44ff0ef          	jal	ra,c000dce0 <Xil_Out32>
						 XAXIDMA_TDESC_OFFSET,
						 (u32)XAXIDMA_VIRT_TO_PHYS(RingPtr->CyclicBd));
				if (RingPtr->Addr_ext)
c000e6a0:	fdc42783          	lw	a5,-36(s0)
c000e6a4:	0187a783          	lw	a5,24(a5)
c000e6a8:	00078e63          	beqz	a5,c000e6c4 <XAxiDma_StartBdRingHw+0x10c>
					XAxiDma_WriteReg(RingPtr->ChanBase,
c000e6ac:	fdc42783          	lw	a5,-36(s0)
c000e6b0:	0007a783          	lw	a5,0(a5)
c000e6b4:	01478793          	addi	a5,a5,20
c000e6b8:	00000593          	li	a1,0
c000e6bc:	00078513          	mv	a0,a5
c000e6c0:	e20ff0ef          	jal	ra,c000dce0 <Xil_Out32>
							 XAXIDMA_TDESC_MSB_OFFSET,
							 UPPER_32_BITS(XAXIDMA_VIRT_TO_PHYS(RingPtr->CyclicBd)));
				return XST_SUCCESS;
c000e6c4:	00000793          	li	a5,0
c000e6c8:	18c0006f          	j	c000e854 <XAxiDma_StartBdRingHw+0x29c>
			}

			if ((XAxiDma_BdRead(RingPtr->HwTail,
c000e6cc:	fdc42783          	lw	a5,-36(s0)
c000e6d0:	0407a783          	lw	a5,64(a5)
c000e6d4:	01c78793          	addi	a5,a5,28
c000e6d8:	0007a783          	lw	a5,0(a5)
c000e6dc:	1607c663          	bltz	a5,c000e848 <XAxiDma_StartBdRingHw+0x290>
				    XAXIDMA_BD_STS_OFFSET) &
				XAXIDMA_BD_STS_COMPLETE_MASK) == 0) {
				if (RingPtr->IsRxChannel) {
c000e6e0:	fdc42783          	lw	a5,-36(s0)
c000e6e4:	0047a783          	lw	a5,4(a5)
c000e6e8:	0e078e63          	beqz	a5,c000e7e4 <XAxiDma_StartBdRingHw+0x22c>
					if (!RingIndex) {
c000e6ec:	fec42783          	lw	a5,-20(s0)
c000e6f0:	06079663          	bnez	a5,c000e75c <XAxiDma_StartBdRingHw+0x1a4>
						XAxiDma_WriteReg(RingPtr->ChanBase,
c000e6f4:	fdc42783          	lw	a5,-36(s0)
c000e6f8:	0007a783          	lw	a5,0(a5)
c000e6fc:	01078693          	addi	a3,a5,16
c000e700:	fdc42783          	lw	a5,-36(s0)
c000e704:	0407a783          	lw	a5,64(a5)
c000e708:	00078613          	mv	a2,a5
c000e70c:	fdc42783          	lw	a5,-36(s0)
c000e710:	0207a703          	lw	a4,32(a5)
c000e714:	fdc42783          	lw	a5,-36(s0)
c000e718:	0247a783          	lw	a5,36(a5)
c000e71c:	40f707b3          	sub	a5,a4,a5
c000e720:	00f607b3          	add	a5,a2,a5
c000e724:	fc07f793          	andi	a5,a5,-64
c000e728:	00078593          	mv	a1,a5
c000e72c:	00068513          	mv	a0,a3
c000e730:	db0ff0ef          	jal	ra,c000dce0 <Xil_Out32>
							XAXIDMA_TDESC_OFFSET, (XAXIDMA_VIRT_TO_PHYS(RingPtr->HwTail) & XAXIDMA_DESC_LSB_MASK));
						if (RingPtr->Addr_ext)
c000e734:	fdc42783          	lw	a5,-36(s0)
c000e738:	0187a783          	lw	a5,24(a5)
c000e73c:	10078663          	beqz	a5,c000e848 <XAxiDma_StartBdRingHw+0x290>
							XAxiDma_WriteReg(RingPtr->ChanBase, XAXIDMA_TDESC_MSB_OFFSET,
c000e740:	fdc42783          	lw	a5,-36(s0)
c000e744:	0007a783          	lw	a5,0(a5)
c000e748:	01478793          	addi	a5,a5,20
c000e74c:	00000593          	li	a1,0
c000e750:	00078513          	mv	a0,a5
c000e754:	d8cff0ef          	jal	ra,c000dce0 <Xil_Out32>
c000e758:	0f00006f          	j	c000e848 <XAxiDma_StartBdRingHw+0x290>
								 UPPER_32_BITS(XAXIDMA_VIRT_TO_PHYS(RingPtr->HwTail)));
					}
					else {
						XAxiDma_WriteReg(RingPtr->ChanBase,
c000e75c:	fdc42783          	lw	a5,-36(s0)
c000e760:	0007a783          	lw	a5,0(a5)
c000e764:	fec42703          	lw	a4,-20(s0)
c000e768:	fff70713          	addi	a4,a4,-1
c000e76c:	00571713          	slli	a4,a4,0x5
c000e770:	00e787b3          	add	a5,a5,a4
c000e774:	04878693          	addi	a3,a5,72
c000e778:	fdc42783          	lw	a5,-36(s0)
c000e77c:	0407a783          	lw	a5,64(a5)
c000e780:	00078613          	mv	a2,a5
c000e784:	fdc42783          	lw	a5,-36(s0)
c000e788:	0207a703          	lw	a4,32(a5)
c000e78c:	fdc42783          	lw	a5,-36(s0)
c000e790:	0247a783          	lw	a5,36(a5)
c000e794:	40f707b3          	sub	a5,a4,a5
c000e798:	00f607b3          	add	a5,a2,a5
c000e79c:	fc07f793          	andi	a5,a5,-64
c000e7a0:	00078593          	mv	a1,a5
c000e7a4:	00068513          	mv	a0,a3
c000e7a8:	d38ff0ef          	jal	ra,c000dce0 <Xil_Out32>
							(XAXIDMA_RX_TDESC0_OFFSET +
							(RingIndex - 1) * XAXIDMA_RX_NDESC_OFFSET),
							(XAXIDMA_VIRT_TO_PHYS(RingPtr->HwTail) & XAXIDMA_DESC_LSB_MASK ));
						if (RingPtr->Addr_ext)
c000e7ac:	fdc42783          	lw	a5,-36(s0)
c000e7b0:	0187a783          	lw	a5,24(a5)
c000e7b4:	08078a63          	beqz	a5,c000e848 <XAxiDma_StartBdRingHw+0x290>
							XAxiDma_WriteReg(RingPtr->ChanBase,
c000e7b8:	fdc42783          	lw	a5,-36(s0)
c000e7bc:	0007a783          	lw	a5,0(a5)
c000e7c0:	fec42703          	lw	a4,-20(s0)
c000e7c4:	fff70713          	addi	a4,a4,-1
c000e7c8:	00571713          	slli	a4,a4,0x5
c000e7cc:	00e787b3          	add	a5,a5,a4
c000e7d0:	04c78793          	addi	a5,a5,76
c000e7d4:	00000593          	li	a1,0
c000e7d8:	00078513          	mv	a0,a5
c000e7dc:	d04ff0ef          	jal	ra,c000dce0 <Xil_Out32>
c000e7e0:	0680006f          	j	c000e848 <XAxiDma_StartBdRingHw+0x290>
								(RingIndex - 1) * XAXIDMA_RX_NDESC_OFFSET),
								UPPER_32_BITS(XAXIDMA_VIRT_TO_PHYS(RingPtr->HwTail)));
					}
				}
				else {
					XAxiDma_WriteReg(RingPtr->ChanBase,
c000e7e4:	fdc42783          	lw	a5,-36(s0)
c000e7e8:	0007a783          	lw	a5,0(a5)
c000e7ec:	01078693          	addi	a3,a5,16
c000e7f0:	fdc42783          	lw	a5,-36(s0)
c000e7f4:	0407a783          	lw	a5,64(a5)
c000e7f8:	00078613          	mv	a2,a5
c000e7fc:	fdc42783          	lw	a5,-36(s0)
c000e800:	0207a703          	lw	a4,32(a5)
c000e804:	fdc42783          	lw	a5,-36(s0)
c000e808:	0247a783          	lw	a5,36(a5)
c000e80c:	40f707b3          	sub	a5,a4,a5
c000e810:	00f607b3          	add	a5,a2,a5
c000e814:	fc07f793          	andi	a5,a5,-64
c000e818:	00078593          	mv	a1,a5
c000e81c:	00068513          	mv	a0,a3
c000e820:	cc0ff0ef          	jal	ra,c000dce0 <Xil_Out32>
							XAXIDMA_TDESC_OFFSET, (XAXIDMA_VIRT_TO_PHYS(RingPtr->HwTail) & XAXIDMA_DESC_LSB_MASK));
					if (RingPtr->Addr_ext)
c000e824:	fdc42783          	lw	a5,-36(s0)
c000e828:	0187a783          	lw	a5,24(a5)
c000e82c:	00078e63          	beqz	a5,c000e848 <XAxiDma_StartBdRingHw+0x290>
						XAxiDma_WriteReg(RingPtr->ChanBase, XAXIDMA_TDESC_MSB_OFFSET,
c000e830:	fdc42783          	lw	a5,-36(s0)
c000e834:	0007a783          	lw	a5,0(a5)
c000e838:	01478793          	addi	a5,a5,20
c000e83c:	00000593          	li	a1,0
c000e840:	00078513          	mv	a0,a5
c000e844:	c9cff0ef          	jal	ra,c000dce0 <Xil_Out32>
								 UPPER_32_BITS(XAXIDMA_VIRT_TO_PHYS(RingPtr->HwTail)));
				}
			}
		}

		return XST_SUCCESS;
c000e848:	00000793          	li	a5,0
c000e84c:	0080006f          	j	c000e854 <XAxiDma_StartBdRingHw+0x29c>
	}

	return XST_DMA_ERROR;
c000e850:	00900793          	li	a5,9
}
c000e854:	00078513          	mv	a0,a5
c000e858:	02c12083          	lw	ra,44(sp)
c000e85c:	02812403          	lw	s0,40(sp)
c000e860:	03010113          	addi	sp,sp,48
c000e864:	00008067          	ret

c000e868 <XAxiDma_BdRingStart>:
 *
 * @note	This function can be used only when DMA is in SG mode
 *
 *****************************************************************************/
int XAxiDma_BdRingStart(XAxiDma_BdRing * RingPtr)
{
c000e868:	fd010113          	addi	sp,sp,-48
c000e86c:	02112623          	sw	ra,44(sp)
c000e870:	02812423          	sw	s0,40(sp)
c000e874:	03010413          	addi	s0,sp,48
c000e878:	fca42e23          	sw	a0,-36(s0)
	int Status;

	Status = XAxiDma_UpdateBdRingCDesc(RingPtr);
c000e87c:	fdc42503          	lw	a0,-36(s0)
c000e880:	c98ff0ef          	jal	ra,c000dd18 <XAxiDma_UpdateBdRingCDesc>
c000e884:	fea42623          	sw	a0,-20(s0)
	if (Status != XST_SUCCESS) {
c000e888:	fec42783          	lw	a5,-20(s0)
c000e88c:	00078c63          	beqz	a5,c000e8a4 <XAxiDma_BdRingStart+0x3c>
		 printf("BdRingStart: "
c000e890:	07ff2517          	auipc	a0,0x7ff2
c000e894:	dbc50513          	addi	a0,a0,-580 # c800064c <__rodata_start+0x64c>
c000e898:	50c0f0ef          	jal	ra,c001dda4 <printf>
			"Updating Current Descriptor Failed\n\r");
		return Status;
c000e89c:	fec42783          	lw	a5,-20(s0)
c000e8a0:	0300006f          	j	c000e8d0 <XAxiDma_BdRingStart+0x68>
	}

	Status = XAxiDma_StartBdRingHw(RingPtr);
c000e8a4:	fdc42503          	lw	a0,-36(s0)
c000e8a8:	d11ff0ef          	jal	ra,c000e5b8 <XAxiDma_StartBdRingHw>
c000e8ac:	fea42623          	sw	a0,-20(s0)
	if (Status != XST_SUCCESS) {
c000e8b0:	fec42783          	lw	a5,-20(s0)
c000e8b4:	00078c63          	beqz	a5,c000e8cc <XAxiDma_BdRingStart+0x64>
		 printf("BdRingStart: "
c000e8b8:	07ff2517          	auipc	a0,0x7ff2
c000e8bc:	dc850513          	addi	a0,a0,-568 # c8000680 <__rodata_start+0x680>
c000e8c0:	4e40f0ef          	jal	ra,c001dda4 <printf>
			"Starting Hardware Failed\n\r");
		return Status;
c000e8c4:	fec42783          	lw	a5,-20(s0)
c000e8c8:	0080006f          	j	c000e8d0 <XAxiDma_BdRingStart+0x68>
	}

	return XST_SUCCESS;
c000e8cc:	00000793          	li	a5,0
}
c000e8d0:	00078513          	mv	a0,a5
c000e8d4:	02c12083          	lw	ra,44(sp)
c000e8d8:	02812403          	lw	s0,40(sp)
c000e8dc:	03010113          	addi	sp,sp,48
c000e8e0:	00008067          	ret

c000e8e4 <XAxiDma_BdRingSetCoalesce>:
 *
 * @note	This function can be used only when DMA is in SG mode
 *
 *****************************************************************************/
int XAxiDma_BdRingSetCoalesce(XAxiDma_BdRing *RingPtr, u32 Counter, u32 Timer)
{
c000e8e4:	fd010113          	addi	sp,sp,-48
c000e8e8:	02112623          	sw	ra,44(sp)
c000e8ec:	02812423          	sw	s0,40(sp)
c000e8f0:	03010413          	addi	s0,sp,48
c000e8f4:	fca42e23          	sw	a0,-36(s0)
c000e8f8:	fcb42c23          	sw	a1,-40(s0)
c000e8fc:	fcc42a23          	sw	a2,-44(s0)
	u32 Cr;

	Cr = XAxiDma_ReadReg(RingPtr->ChanBase, XAXIDMA_CR_OFFSET);
c000e900:	fdc42783          	lw	a5,-36(s0)
c000e904:	0007a783          	lw	a5,0(a5)
c000e908:	00078513          	mv	a0,a5
c000e90c:	bacff0ef          	jal	ra,c000dcb8 <Xil_In32>
c000e910:	fea42623          	sw	a0,-20(s0)

	if (Counter != XAXIDMA_NO_CHANGE) {
c000e914:	fd842703          	lw	a4,-40(s0)
c000e918:	fff00793          	li	a5,-1
c000e91c:	04f70a63          	beq	a4,a5,c000e970 <XAxiDma_BdRingSetCoalesce+0x8c>
		if ((Counter == 0) || (Counter > 0xFF)) {
c000e920:	fd842783          	lw	a5,-40(s0)
c000e924:	00078863          	beqz	a5,c000e934 <XAxiDma_BdRingSetCoalesce+0x50>
c000e928:	fd842703          	lw	a4,-40(s0)
c000e92c:	0ff00793          	li	a5,255
c000e930:	02e7f063          	bgeu	a5,a4,c000e950 <XAxiDma_BdRingSetCoalesce+0x6c>

			printf("BdRingSetCoalesce: "
c000e934:	fd842783          	lw	a5,-40(s0)
c000e938:	00078593          	mv	a1,a5
c000e93c:	07ff2517          	auipc	a0,0x7ff2
c000e940:	d6c50513          	addi	a0,a0,-660 # c80006a8 <__rodata_start+0x6a8>
c000e944:	4600f0ef          	jal	ra,c001dda4 <printf>
			"invalid  coalescing threshold %d", (int)Counter);
			return XST_FAILURE;
c000e948:	00100793          	li	a5,1
c000e94c:	0900006f          	j	c000e9dc <XAxiDma_BdRingSetCoalesce+0xf8>
		}

		Cr = (Cr & ~XAXIDMA_COALESCE_MASK) |
c000e950:	fec42703          	lw	a4,-20(s0)
c000e954:	ff0107b7          	lui	a5,0xff010
c000e958:	fff78793          	addi	a5,a5,-1 # ff00ffff <_end+0x36f8b77f>
c000e95c:	00f77733          	and	a4,a4,a5
			(Counter << XAXIDMA_COALESCE_SHIFT);
c000e960:	fd842783          	lw	a5,-40(s0)
c000e964:	01079793          	slli	a5,a5,0x10
		Cr = (Cr & ~XAXIDMA_COALESCE_MASK) |
c000e968:	00f767b3          	or	a5,a4,a5
c000e96c:	fef42623          	sw	a5,-20(s0)
	}

	if (Timer != XAXIDMA_NO_CHANGE) {
c000e970:	fd442703          	lw	a4,-44(s0)
c000e974:	fff00793          	li	a5,-1
c000e978:	04f70663          	beq	a4,a5,c000e9c4 <XAxiDma_BdRingSetCoalesce+0xe0>
		if (Timer > 0xFF) {
c000e97c:	fd442703          	lw	a4,-44(s0)
c000e980:	0ff00793          	li	a5,255
c000e984:	02e7f063          	bgeu	a5,a4,c000e9a4 <XAxiDma_BdRingSetCoalesce+0xc0>

			printf("BdRingSetCoalesce: "
c000e988:	fd442783          	lw	a5,-44(s0)
c000e98c:	00078593          	mv	a1,a5
c000e990:	07ff2517          	auipc	a0,0x7ff2
c000e994:	d4c50513          	addi	a0,a0,-692 # c80006dc <__rodata_start+0x6dc>
c000e998:	40c0f0ef          	jal	ra,c001dda4 <printf>
			"invalid  delay counter %d", (int)Timer);

			return XST_FAILURE;
c000e99c:	00100793          	li	a5,1
c000e9a0:	03c0006f          	j	c000e9dc <XAxiDma_BdRingSetCoalesce+0xf8>
		}

		Cr = (Cr & ~XAXIDMA_DELAY_MASK) |
c000e9a4:	fec42703          	lw	a4,-20(s0)
c000e9a8:	010007b7          	lui	a5,0x1000
c000e9ac:	fff78793          	addi	a5,a5,-1 # ffffff <_DMEM_LENGTH+0x7fffff>
c000e9b0:	00f77733          	and	a4,a4,a5
			(Timer << XAXIDMA_DELAY_SHIFT);
c000e9b4:	fd442783          	lw	a5,-44(s0)
c000e9b8:	01879793          	slli	a5,a5,0x18
		Cr = (Cr & ~XAXIDMA_DELAY_MASK) |
c000e9bc:	00f767b3          	or	a5,a4,a5
c000e9c0:	fef42623          	sw	a5,-20(s0)
	}

	XAxiDma_WriteReg(RingPtr->ChanBase, XAXIDMA_CR_OFFSET, Cr);
c000e9c4:	fdc42783          	lw	a5,-36(s0)
c000e9c8:	0007a783          	lw	a5,0(a5)
c000e9cc:	fec42583          	lw	a1,-20(s0)
c000e9d0:	00078513          	mv	a0,a5
c000e9d4:	b0cff0ef          	jal	ra,c000dce0 <Xil_Out32>

	return XST_SUCCESS;
c000e9d8:	00000793          	li	a5,0
}
c000e9dc:	00078513          	mv	a0,a5
c000e9e0:	02c12083          	lw	ra,44(sp)
c000e9e4:	02812403          	lw	s0,40(sp)
c000e9e8:	03010113          	addi	sp,sp,48
c000e9ec:	00008067          	ret

c000e9f0 <XAxiDma_BdRingGetCoalesce>:
 * @note	This function can be used only when DMA is in SG mode
 *
 *****************************************************************************/
void XAxiDma_BdRingGetCoalesce(XAxiDma_BdRing * RingPtr,
			      u32 *CounterPtr, u32 *TimerPtr)
{
c000e9f0:	fd010113          	addi	sp,sp,-48
c000e9f4:	02112623          	sw	ra,44(sp)
c000e9f8:	02812423          	sw	s0,40(sp)
c000e9fc:	03010413          	addi	s0,sp,48
c000ea00:	fca42e23          	sw	a0,-36(s0)
c000ea04:	fcb42c23          	sw	a1,-40(s0)
c000ea08:	fcc42a23          	sw	a2,-44(s0)
	u32 Cr;

	Cr = XAxiDma_ReadReg(RingPtr->ChanBase, XAXIDMA_CR_OFFSET);
c000ea0c:	fdc42783          	lw	a5,-36(s0)
c000ea10:	0007a783          	lw	a5,0(a5)
c000ea14:	00078513          	mv	a0,a5
c000ea18:	aa0ff0ef          	jal	ra,c000dcb8 <Xil_In32>
c000ea1c:	fea42623          	sw	a0,-20(s0)

	*CounterPtr = ((Cr & XAXIDMA_COALESCE_MASK) >> XAXIDMA_COALESCE_SHIFT);
c000ea20:	fec42783          	lw	a5,-20(s0)
c000ea24:	0107d793          	srli	a5,a5,0x10
c000ea28:	0ff7f713          	andi	a4,a5,255
c000ea2c:	fd842783          	lw	a5,-40(s0)
c000ea30:	00e7a023          	sw	a4,0(a5)
	*TimerPtr = ((Cr & XAXIDMA_DELAY_MASK) >> XAXIDMA_DELAY_SHIFT);
c000ea34:	fec42783          	lw	a5,-20(s0)
c000ea38:	0187d713          	srli	a4,a5,0x18
c000ea3c:	fd442783          	lw	a5,-44(s0)
c000ea40:	00e7a023          	sw	a4,0(a5)
}
c000ea44:	00000013          	nop
c000ea48:	02c12083          	lw	ra,44(sp)
c000ea4c:	02812403          	lw	s0,40(sp)
c000ea50:	03010113          	addi	sp,sp,48
c000ea54:	00008067          	ret

c000ea58 <XAxiDma_BdRingAlloc>:
 *		This function can be used only when DMA is in SG mode
 *
 *****************************************************************************/
int XAxiDma_BdRingAlloc(XAxiDma_BdRing * RingPtr, int NumBd,
	XAxiDma_Bd ** BdSetPtr)
{
c000ea58:	fd010113          	addi	sp,sp,-48
c000ea5c:	02112623          	sw	ra,44(sp)
c000ea60:	02812423          	sw	s0,40(sp)
c000ea64:	03010413          	addi	s0,sp,48
c000ea68:	fca42e23          	sw	a0,-36(s0)
c000ea6c:	fcb42c23          	sw	a1,-40(s0)
c000ea70:	fcc42a23          	sw	a2,-44(s0)
	if (NumBd <= 0) {
c000ea74:	fd842783          	lw	a5,-40(s0)
c000ea78:	00f04e63          	bgtz	a5,c000ea94 <XAxiDma_BdRingAlloc+0x3c>

		printf("BdRingAlloc: negative BD "
c000ea7c:	fd842583          	lw	a1,-40(s0)
c000ea80:	07ff2517          	auipc	a0,0x7ff2
c000ea84:	c8c50513          	addi	a0,a0,-884 # c800070c <__rodata_start+0x70c>
c000ea88:	31c0f0ef          	jal	ra,c001dda4 <printf>
				"number %d\r\n", NumBd);

		return XST_INVALID_PARAM;
c000ea8c:	00f00793          	li	a5,15
c000ea90:	0e80006f          	j	c000eb78 <XAxiDma_BdRingAlloc+0x120>
	}

	/* Enough free BDs available for the request? */
	if (RingPtr->FreeCnt < NumBd) {
c000ea94:	fdc42783          	lw	a5,-36(s0)
c000ea98:	0507a783          	lw	a5,80(a5)
c000ea9c:	fd842703          	lw	a4,-40(s0)
c000eaa0:	02e7d463          	bge	a5,a4,c000eac8 <XAxiDma_BdRingAlloc+0x70>
		printf(
c000eaa4:	fdc42783          	lw	a5,-36(s0)
c000eaa8:	0507a783          	lw	a5,80(a5)
c000eaac:	00078613          	mv	a2,a5
c000eab0:	fd842583          	lw	a1,-40(s0)
c000eab4:	07ff2517          	auipc	a0,0x7ff2
c000eab8:	c8050513          	addi	a0,a0,-896 # c8000734 <__rodata_start+0x734>
c000eabc:	2e80f0ef          	jal	ra,c001dda4 <printf>
		"Not enough BDs to alloc %d/%d\r\n", NumBd, RingPtr->FreeCnt);

		return XST_FAILURE;
c000eac0:	00100793          	li	a5,1
c000eac4:	0b40006f          	j	c000eb78 <XAxiDma_BdRingAlloc+0x120>
	}

	/* Set the return argument and move FreeHead forward */
	*BdSetPtr = RingPtr->FreeHead;
c000eac8:	fdc42783          	lw	a5,-36(s0)
c000eacc:	0347a703          	lw	a4,52(a5)
c000ead0:	fd442783          	lw	a5,-44(s0)
c000ead4:	00e7a023          	sw	a4,0(a5)
	XAXIDMA_RING_SEEKAHEAD(RingPtr, RingPtr->FreeHead, NumBd);
c000ead8:	fdc42783          	lw	a5,-36(s0)
c000eadc:	0347a783          	lw	a5,52(a5)
c000eae0:	fef42623          	sw	a5,-20(s0)
c000eae4:	fdc42783          	lw	a5,-36(s0)
c000eae8:	0307a703          	lw	a4,48(a5)
c000eaec:	fd842783          	lw	a5,-40(s0)
c000eaf0:	02f707b3          	mul	a5,a4,a5
c000eaf4:	fec42703          	lw	a4,-20(s0)
c000eaf8:	00f707b3          	add	a5,a4,a5
c000eafc:	fef42623          	sw	a5,-20(s0)
c000eb00:	fdc42783          	lw	a5,-36(s0)
c000eb04:	0287a783          	lw	a5,40(a5)
c000eb08:	fec42703          	lw	a4,-20(s0)
c000eb0c:	00e7ec63          	bltu	a5,a4,c000eb24 <XAxiDma_BdRingAlloc+0xcc>
c000eb10:	fdc42783          	lw	a5,-36(s0)
c000eb14:	0347a783          	lw	a5,52(a5)
c000eb18:	00078713          	mv	a4,a5
c000eb1c:	fec42783          	lw	a5,-20(s0)
c000eb20:	00e7fc63          	bgeu	a5,a4,c000eb38 <XAxiDma_BdRingAlloc+0xe0>
c000eb24:	fdc42783          	lw	a5,-36(s0)
c000eb28:	02c7a783          	lw	a5,44(a5)
c000eb2c:	fec42703          	lw	a4,-20(s0)
c000eb30:	40f707b3          	sub	a5,a4,a5
c000eb34:	fef42623          	sw	a5,-20(s0)
c000eb38:	fec42703          	lw	a4,-20(s0)
c000eb3c:	fdc42783          	lw	a5,-36(s0)
c000eb40:	02e7aa23          	sw	a4,52(a5)
	RingPtr->FreeCnt -= NumBd;
c000eb44:	fdc42783          	lw	a5,-36(s0)
c000eb48:	0507a703          	lw	a4,80(a5)
c000eb4c:	fd842783          	lw	a5,-40(s0)
c000eb50:	40f70733          	sub	a4,a4,a5
c000eb54:	fdc42783          	lw	a5,-36(s0)
c000eb58:	04e7a823          	sw	a4,80(a5)
	RingPtr->PreCnt += NumBd;
c000eb5c:	fdc42783          	lw	a5,-36(s0)
c000eb60:	0547a703          	lw	a4,84(a5)
c000eb64:	fd842783          	lw	a5,-40(s0)
c000eb68:	00f70733          	add	a4,a4,a5
c000eb6c:	fdc42783          	lw	a5,-36(s0)
c000eb70:	04e7aa23          	sw	a4,84(a5)

	return XST_SUCCESS;
c000eb74:	00000793          	li	a5,0
}
c000eb78:	00078513          	mv	a0,a5
c000eb7c:	02c12083          	lw	ra,44(sp)
c000eb80:	02812403          	lw	s0,40(sp)
c000eb84:	03010113          	addi	sp,sp,48
c000eb88:	00008067          	ret

c000eb8c <XAxiDma_BdRingUnAlloc>:
 *		This function can be used only when DMA is in SG mode
 *
 *****************************************************************************/
int XAxiDma_BdRingUnAlloc(XAxiDma_BdRing * RingPtr, int NumBd,
	XAxiDma_Bd * BdSetPtr)
{
c000eb8c:	fd010113          	addi	sp,sp,-48
c000eb90:	02112623          	sw	ra,44(sp)
c000eb94:	02812423          	sw	s0,40(sp)
c000eb98:	03010413          	addi	s0,sp,48
c000eb9c:	fca42e23          	sw	a0,-36(s0)
c000eba0:	fcb42c23          	sw	a1,-40(s0)
c000eba4:	fcc42a23          	sw	a2,-44(s0)
	XAxiDma_Bd *TmpBd;

	if (NumBd <= 0) {
c000eba8:	fd842783          	lw	a5,-40(s0)
c000ebac:	00f04e63          	bgtz	a5,c000ebc8 <XAxiDma_BdRingUnAlloc+0x3c>

		printf("BdRingUnAlloc: negative BD"
c000ebb0:	fd842583          	lw	a1,-40(s0)
c000ebb4:	07ff2517          	auipc	a0,0x7ff2
c000ebb8:	ba050513          	addi	a0,a0,-1120 # c8000754 <__rodata_start+0x754>
c000ebbc:	1e80f0ef          	jal	ra,c001dda4 <printf>
		" number %d\r\n", NumBd);

		return XST_INVALID_PARAM;
c000ebc0:	00f00793          	li	a5,15
c000ebc4:	1600006f          	j	c000ed24 <XAxiDma_BdRingUnAlloc+0x198>
	}

	/* Enough BDs in the preprocessing state for the request? */
	if (RingPtr->PreCnt < NumBd) {
c000ebc8:	fdc42783          	lw	a5,-36(s0)
c000ebcc:	0547a783          	lw	a5,84(a5)
c000ebd0:	fd842703          	lw	a4,-40(s0)
c000ebd4:	02e7d463          	bge	a5,a4,c000ebfc <XAxiDma_BdRingUnAlloc+0x70>
		printf(
c000ebd8:	fdc42783          	lw	a5,-36(s0)
c000ebdc:	0547a783          	lw	a5,84(a5)
c000ebe0:	fd842603          	lw	a2,-40(s0)
c000ebe4:	00078593          	mv	a1,a5
c000ebe8:	07ff2517          	auipc	a0,0x7ff2
c000ebec:	b9450513          	addi	a0,a0,-1132 # c800077c <__rodata_start+0x77c>
c000ebf0:	1b40f0ef          	jal	ra,c001dda4 <printf>
		"Pre-allocated BDs less than requested %d/%d\r\n",
		RingPtr->PreCnt, NumBd);

		return XST_FAILURE;
c000ebf4:	00100793          	li	a5,1
c000ebf8:	12c0006f          	j	c000ed24 <XAxiDma_BdRingUnAlloc+0x198>
	}

	/* The last BD in the BD set must has the FreeHead as its next BD.
	 * Otherwise, this is not a valid operation.
	 */
	TmpBd = BdSetPtr;
c000ebfc:	fd442783          	lw	a5,-44(s0)
c000ec00:	fef42223          	sw	a5,-28(s0)
	XAXIDMA_RING_SEEKAHEAD(RingPtr, TmpBd, NumBd);
c000ec04:	fe442783          	lw	a5,-28(s0)
c000ec08:	fef42623          	sw	a5,-20(s0)
c000ec0c:	fdc42783          	lw	a5,-36(s0)
c000ec10:	0307a703          	lw	a4,48(a5)
c000ec14:	fd842783          	lw	a5,-40(s0)
c000ec18:	02f707b3          	mul	a5,a4,a5
c000ec1c:	fec42703          	lw	a4,-20(s0)
c000ec20:	00f707b3          	add	a5,a4,a5
c000ec24:	fef42623          	sw	a5,-20(s0)
c000ec28:	fdc42783          	lw	a5,-36(s0)
c000ec2c:	0287a783          	lw	a5,40(a5)
c000ec30:	fec42703          	lw	a4,-20(s0)
c000ec34:	00e7e863          	bltu	a5,a4,c000ec44 <XAxiDma_BdRingUnAlloc+0xb8>
c000ec38:	fe442783          	lw	a5,-28(s0)
c000ec3c:	fec42703          	lw	a4,-20(s0)
c000ec40:	00f77c63          	bgeu	a4,a5,c000ec58 <XAxiDma_BdRingUnAlloc+0xcc>
c000ec44:	fdc42783          	lw	a5,-36(s0)
c000ec48:	02c7a783          	lw	a5,44(a5)
c000ec4c:	fec42703          	lw	a4,-20(s0)
c000ec50:	40f707b3          	sub	a5,a4,a5
c000ec54:	fef42623          	sw	a5,-20(s0)
c000ec58:	fec42783          	lw	a5,-20(s0)
c000ec5c:	fef42223          	sw	a5,-28(s0)

	if (TmpBd != RingPtr->FreeHead) {
c000ec60:	fdc42783          	lw	a5,-36(s0)
c000ec64:	0347a783          	lw	a5,52(a5)
c000ec68:	fe442703          	lw	a4,-28(s0)
c000ec6c:	00f70c63          	beq	a4,a5,c000ec84 <XAxiDma_BdRingUnAlloc+0xf8>
		printf(
c000ec70:	07ff2517          	auipc	a0,0x7ff2
c000ec74:	b3c50513          	addi	a0,a0,-1220 # c80007ac <__rodata_start+0x7ac>
c000ec78:	2480f0ef          	jal	ra,c001dec0 <puts>
		    "Unalloc does not go back to free head\r\n");

		return XST_FAILURE;
c000ec7c:	00100793          	li	a5,1
c000ec80:	0a40006f          	j	c000ed24 <XAxiDma_BdRingUnAlloc+0x198>
	}

	/* Set the return argument and move FreeHead backward */
	XAXIDMA_RING_SEEKBACK(RingPtr, RingPtr->FreeHead, NumBd);
c000ec84:	fdc42783          	lw	a5,-36(s0)
c000ec88:	0347a783          	lw	a5,52(a5)
c000ec8c:	fef42423          	sw	a5,-24(s0)
c000ec90:	fdc42783          	lw	a5,-36(s0)
c000ec94:	0307a703          	lw	a4,48(a5)
c000ec98:	fd842783          	lw	a5,-40(s0)
c000ec9c:	02f707b3          	mul	a5,a4,a5
c000eca0:	fe842703          	lw	a4,-24(s0)
c000eca4:	40f707b3          	sub	a5,a4,a5
c000eca8:	fef42423          	sw	a5,-24(s0)
c000ecac:	fdc42783          	lw	a5,-36(s0)
c000ecb0:	0247a783          	lw	a5,36(a5)
c000ecb4:	fe842703          	lw	a4,-24(s0)
c000ecb8:	00f76c63          	bltu	a4,a5,c000ecd0 <XAxiDma_BdRingUnAlloc+0x144>
c000ecbc:	fdc42783          	lw	a5,-36(s0)
c000ecc0:	0347a783          	lw	a5,52(a5)
c000ecc4:	00078713          	mv	a4,a5
c000ecc8:	fe842783          	lw	a5,-24(s0)
c000eccc:	00f77c63          	bgeu	a4,a5,c000ece4 <XAxiDma_BdRingUnAlloc+0x158>
c000ecd0:	fdc42783          	lw	a5,-36(s0)
c000ecd4:	02c7a783          	lw	a5,44(a5)
c000ecd8:	fe842703          	lw	a4,-24(s0)
c000ecdc:	00f707b3          	add	a5,a4,a5
c000ece0:	fef42423          	sw	a5,-24(s0)
c000ece4:	fe842703          	lw	a4,-24(s0)
c000ece8:	fdc42783          	lw	a5,-36(s0)
c000ecec:	02e7aa23          	sw	a4,52(a5)
	RingPtr->FreeCnt += NumBd;
c000ecf0:	fdc42783          	lw	a5,-36(s0)
c000ecf4:	0507a703          	lw	a4,80(a5)
c000ecf8:	fd842783          	lw	a5,-40(s0)
c000ecfc:	00f70733          	add	a4,a4,a5
c000ed00:	fdc42783          	lw	a5,-36(s0)
c000ed04:	04e7a823          	sw	a4,80(a5)
	RingPtr->PreCnt -= NumBd;
c000ed08:	fdc42783          	lw	a5,-36(s0)
c000ed0c:	0547a703          	lw	a4,84(a5)
c000ed10:	fd842783          	lw	a5,-40(s0)
c000ed14:	40f70733          	sub	a4,a4,a5
c000ed18:	fdc42783          	lw	a5,-36(s0)
c000ed1c:	04e7aa23          	sw	a4,84(a5)

	return XST_SUCCESS;
c000ed20:	00000793          	li	a5,0
}
c000ed24:	00078513          	mv	a0,a5
c000ed28:	02c12083          	lw	ra,44(sp)
c000ed2c:	02812403          	lw	s0,40(sp)
c000ed30:	03010113          	addi	sp,sp,48
c000ed34:	00008067          	ret

c000ed38 <XAxiDma_BdRingToHw>:
 *		This function can be used only when DMA is in SG mode
 *
 *****************************************************************************/
int XAxiDma_BdRingToHw(XAxiDma_BdRing * RingPtr, int NumBd,
	XAxiDma_Bd * BdSetPtr)
{
c000ed38:	fc010113          	addi	sp,sp,-64
c000ed3c:	02112e23          	sw	ra,60(sp)
c000ed40:	02812c23          	sw	s0,56(sp)
c000ed44:	04010413          	addi	s0,sp,64
c000ed48:	fca42623          	sw	a0,-52(s0)
c000ed4c:	fcb42423          	sw	a1,-56(s0)
c000ed50:	fcc42223          	sw	a2,-60(s0)
	XAxiDma_Bd *CurBdPtr;
	int i;
	u32 BdCr;
	u32 BdSts;
	int RingIndex = RingPtr->RingIndex;
c000ed54:	fcc42783          	lw	a5,-52(s0)
c000ed58:	0647a783          	lw	a5,100(a5)
c000ed5c:	fcf42c23          	sw	a5,-40(s0)

	if (NumBd < 0) {
c000ed60:	fc842783          	lw	a5,-56(s0)
c000ed64:	0007de63          	bgez	a5,c000ed80 <XAxiDma_BdRingToHw+0x48>

		printf("BdRingToHw: negative BD number "
c000ed68:	fc842583          	lw	a1,-56(s0)
c000ed6c:	07ff2517          	auipc	a0,0x7ff2
c000ed70:	a6850513          	addi	a0,a0,-1432 # c80007d4 <__rodata_start+0x7d4>
c000ed74:	0300f0ef          	jal	ra,c001dda4 <printf>
			"%d\r\n", NumBd);

		return XST_INVALID_PARAM;
c000ed78:	00f00793          	li	a5,15
c000ed7c:	49c0006f          	j	c000f218 <XAxiDma_BdRingToHw+0x4e0>
	}

	/* If the commit set is empty, do nothing */
	if (NumBd == 0) {
c000ed80:	fc842783          	lw	a5,-56(s0)
c000ed84:	00079663          	bnez	a5,c000ed90 <XAxiDma_BdRingToHw+0x58>
		return XST_SUCCESS;
c000ed88:	00000793          	li	a5,0
c000ed8c:	48c0006f          	j	c000f218 <XAxiDma_BdRingToHw+0x4e0>
	}

	/* Make sure we are in sync with XAxiDma_BdRingAlloc() */
	if ((RingPtr->PreCnt < NumBd) || (RingPtr->PreHead != BdSetPtr)) {
c000ed90:	fcc42783          	lw	a5,-52(s0)
c000ed94:	0547a783          	lw	a5,84(a5)
c000ed98:	fc842703          	lw	a4,-56(s0)
c000ed9c:	00e7ca63          	blt	a5,a4,c000edb0 <XAxiDma_BdRingToHw+0x78>
c000eda0:	fcc42783          	lw	a5,-52(s0)
c000eda4:	0387a783          	lw	a5,56(a5)
c000eda8:	fc442703          	lw	a4,-60(s0)
c000edac:	00f70c63          	beq	a4,a5,c000edc4 <XAxiDma_BdRingToHw+0x8c>

		printf("Bd ring has problems\r\n");
c000edb0:	07ff2517          	auipc	a0,0x7ff2
c000edb4:	a4850513          	addi	a0,a0,-1464 # c80007f8 <__rodata_start+0x7f8>
c000edb8:	1080f0ef          	jal	ra,c001dec0 <puts>
		return XST_DMA_SG_LIST_ERROR;
c000edbc:	20e00793          	li	a5,526
c000edc0:	4580006f          	j	c000f218 <XAxiDma_BdRingToHw+0x4e0>
	}

	CurBdPtr = BdSetPtr;
c000edc4:	fc442783          	lw	a5,-60(s0)
c000edc8:	fef42623          	sw	a5,-20(s0)
	BdCr = XAxiDma_BdGetCtrl(CurBdPtr);
c000edcc:	fec42783          	lw	a5,-20(s0)
c000edd0:	01878793          	addi	a5,a5,24
c000edd4:	0007a703          	lw	a4,0(a5)
c000edd8:	0c0007b7          	lui	a5,0xc000
c000eddc:	00f777b3          	and	a5,a4,a5
c000ede0:	fef42223          	sw	a5,-28(s0)
	BdSts = XAxiDma_BdGetSts(CurBdPtr);
c000ede4:	fec42783          	lw	a5,-20(s0)
c000ede8:	01c78793          	addi	a5,a5,28 # c00001c <_DMEM_LENGTH+0xb80001c>
c000edec:	0007a703          	lw	a4,0(a5)
c000edf0:	fc0007b7          	lui	a5,0xfc000
c000edf4:	00f777b3          	and	a5,a4,a5
c000edf8:	fef42023          	sw	a5,-32(s0)

	/* In case of Tx channel, the first BD should have been marked
	 * as start-of-frame
	 */
	if (!(RingPtr->IsRxChannel) && !(BdCr & XAXIDMA_BD_CTRL_TXSOF_MASK)) {
c000edfc:	fcc42783          	lw	a5,-52(s0)
c000ee00:	0047a783          	lw	a5,4(a5) # fc000004 <_end+0x33f7b784>
c000ee04:	02079463          	bnez	a5,c000ee2c <XAxiDma_BdRingToHw+0xf4>
c000ee08:	fe442703          	lw	a4,-28(s0)
c000ee0c:	080007b7          	lui	a5,0x8000
c000ee10:	00f777b3          	and	a5,a4,a5
c000ee14:	00079c63          	bnez	a5,c000ee2c <XAxiDma_BdRingToHw+0xf4>

		printf("Tx first BD does not have "
c000ee18:	07ff2517          	auipc	a0,0x7ff2
c000ee1c:	9f850513          	addi	a0,a0,-1544 # c8000810 <__rodata_start+0x810>
c000ee20:	0a00f0ef          	jal	ra,c001dec0 <puts>
								"SOF\r\n");

		return XST_FAILURE;
c000ee24:	00100793          	li	a5,1
c000ee28:	3f00006f          	j	c000f218 <XAxiDma_BdRingToHw+0x4e0>
	}

	/* Clear the completed status bit
	 */
	for (i = 0; i < NumBd - 1; i++) {
c000ee2c:	fe042423          	sw	zero,-24(s0)
c000ee30:	0b80006f          	j	c000eee8 <XAxiDma_BdRingToHw+0x1b0>
		//u32 len = XAxiDma_BdGetLength(CurBdPtr,
		//		RingPtr->MaxTransferLen);
		//printf("XAxiDma_BdRingToHw: Bd len = %lu\r\n", len);

		/* Make sure the length value in the BD is non-zero. */
		if (XAxiDma_BdGetLength(CurBdPtr,
c000ee34:	fec42783          	lw	a5,-20(s0)
c000ee38:	01878793          	addi	a5,a5,24 # 8000018 <_DMEM_LENGTH+0x7800018>
c000ee3c:	0007a703          	lw	a4,0(a5)
c000ee40:	fcc42783          	lw	a5,-52(s0)
c000ee44:	01c7a783          	lw	a5,28(a5)
c000ee48:	00f777b3          	and	a5,a4,a5
c000ee4c:	00079c63          	bnez	a5,c000ee64 <XAxiDma_BdRingToHw+0x12c>
				RingPtr->MaxTransferLen) == 0) {

			printf("0 length bd\r\n");
c000ee50:	07ff2517          	auipc	a0,0x7ff2
c000ee54:	9e050513          	addi	a0,a0,-1568 # c8000830 <__rodata_start+0x830>
c000ee58:	0680f0ef          	jal	ra,c001dec0 <puts>

			return XST_FAILURE;
c000ee5c:	00100793          	li	a5,1
c000ee60:	3b80006f          	j	c000f218 <XAxiDma_BdRingToHw+0x4e0>
		}

		BdSts &=  ~XAXIDMA_BD_STS_COMPLETE_MASK;
c000ee64:	fe042703          	lw	a4,-32(s0)
c000ee68:	800007b7          	lui	a5,0x80000
c000ee6c:	fff7c793          	not	a5,a5
c000ee70:	00f777b3          	and	a5,a4,a5
c000ee74:	fef42023          	sw	a5,-32(s0)
		XAxiDma_BdWrite(CurBdPtr, XAXIDMA_BD_STS_OFFSET, BdSts);
c000ee78:	fec42783          	lw	a5,-20(s0)
c000ee7c:	01c78793          	addi	a5,a5,28 # 8000001c <_end+0xb7f7b79c>
c000ee80:	00078713          	mv	a4,a5
c000ee84:	fe042783          	lw	a5,-32(s0)
c000ee88:	00f72023          	sw	a5,0(a4)

		/* Flush the current BD so DMA core could see the updates */
		XAXIDMA_CACHE_FLUSH(CurBdPtr);

		CurBdPtr = (XAxiDma_Bd *)((void *)XAxiDma_BdRingNext(RingPtr, CurBdPtr));
c000ee8c:	fcc42783          	lw	a5,-52(s0)
c000ee90:	0287a703          	lw	a4,40(a5)
c000ee94:	fec42783          	lw	a5,-20(s0)
c000ee98:	00e7e863          	bltu	a5,a4,c000eea8 <XAxiDma_BdRingToHw+0x170>
c000ee9c:	fcc42783          	lw	a5,-52(s0)
c000eea0:	0247a783          	lw	a5,36(a5)
c000eea4:	0140006f          	j	c000eeb8 <XAxiDma_BdRingToHw+0x180>
c000eea8:	fcc42783          	lw	a5,-52(s0)
c000eeac:	0307a703          	lw	a4,48(a5)
c000eeb0:	fec42783          	lw	a5,-20(s0)
c000eeb4:	00f707b3          	add	a5,a4,a5
c000eeb8:	fef42623          	sw	a5,-20(s0)
		BdCr = XAxiDma_BdRead(CurBdPtr, XAXIDMA_BD_CTRL_LEN_OFFSET);
c000eebc:	fec42783          	lw	a5,-20(s0)
c000eec0:	01878793          	addi	a5,a5,24
c000eec4:	0007a783          	lw	a5,0(a5)
c000eec8:	fef42223          	sw	a5,-28(s0)
		BdSts = XAxiDma_BdRead(CurBdPtr, XAXIDMA_BD_STS_OFFSET);
c000eecc:	fec42783          	lw	a5,-20(s0)
c000eed0:	01c78793          	addi	a5,a5,28
c000eed4:	0007a783          	lw	a5,0(a5)
c000eed8:	fef42023          	sw	a5,-32(s0)
	for (i = 0; i < NumBd - 1; i++) {
c000eedc:	fe842783          	lw	a5,-24(s0)
c000eee0:	00178793          	addi	a5,a5,1
c000eee4:	fef42423          	sw	a5,-24(s0)
c000eee8:	fc842783          	lw	a5,-56(s0)
c000eeec:	fff78793          	addi	a5,a5,-1
c000eef0:	fe842703          	lw	a4,-24(s0)
c000eef4:	f4f740e3          	blt	a4,a5,c000ee34 <XAxiDma_BdRingToHw+0xfc>
	}

	/* In case of Tx channel, the last BD should have EOF bit set */
	if (!(RingPtr->IsRxChannel) && !(BdCr & XAXIDMA_BD_CTRL_TXEOF_MASK)) {
c000eef8:	fcc42783          	lw	a5,-52(s0)
c000eefc:	0047a783          	lw	a5,4(a5)
c000ef00:	02079463          	bnez	a5,c000ef28 <XAxiDma_BdRingToHw+0x1f0>
c000ef04:	fe442703          	lw	a4,-28(s0)
c000ef08:	040007b7          	lui	a5,0x4000
c000ef0c:	00f777b3          	and	a5,a4,a5
c000ef10:	00079c63          	bnez	a5,c000ef28 <XAxiDma_BdRingToHw+0x1f0>

		printf("Tx last BD does not have "
c000ef14:	07ff2517          	auipc	a0,0x7ff2
c000ef18:	92c50513          	addi	a0,a0,-1748 # c8000840 <__rodata_start+0x840>
c000ef1c:	7a50e0ef          	jal	ra,c001dec0 <puts>
								"EOF\r\n");

		return XST_FAILURE;
c000ef20:	00100793          	li	a5,1
c000ef24:	2f40006f          	j	c000f218 <XAxiDma_BdRingToHw+0x4e0>

	/* Make sure the length value in the last BD is non-zero. */
	//u32 len = XAxiDma_BdGetLength(CurBdPtr,
	//			RingPtr->MaxTransferLen);
	//printf("XAxiDma_BdRingToHw: last Bd len = %u\r\n", len);
	if (XAxiDma_BdGetLength(CurBdPtr,
c000ef28:	fec42783          	lw	a5,-20(s0)
c000ef2c:	01878793          	addi	a5,a5,24 # 4000018 <_DMEM_LENGTH+0x3800018>
c000ef30:	0007a703          	lw	a4,0(a5)
c000ef34:	fcc42783          	lw	a5,-52(s0)
c000ef38:	01c7a783          	lw	a5,28(a5)
c000ef3c:	00f777b3          	and	a5,a4,a5
c000ef40:	00079c63          	bnez	a5,c000ef58 <XAxiDma_BdRingToHw+0x220>
			RingPtr->MaxTransferLen) == 0) {

		printf("0 length bd\r\n");
c000ef44:	07ff2517          	auipc	a0,0x7ff2
c000ef48:	8ec50513          	addi	a0,a0,-1812 # c8000830 <__rodata_start+0x830>
c000ef4c:	7750e0ef          	jal	ra,c001dec0 <puts>

		return XST_FAILURE;
c000ef50:	00100793          	li	a5,1
c000ef54:	2c40006f          	j	c000f218 <XAxiDma_BdRingToHw+0x4e0>
	}

	/* The last BD should also have the completed status bit cleared
	 */
	BdSts &= ~XAXIDMA_BD_STS_COMPLETE_MASK;
c000ef58:	fe042703          	lw	a4,-32(s0)
c000ef5c:	800007b7          	lui	a5,0x80000
c000ef60:	fff7c793          	not	a5,a5
c000ef64:	00f777b3          	and	a5,a4,a5
c000ef68:	fef42023          	sw	a5,-32(s0)
	XAxiDma_BdWrite(CurBdPtr, XAXIDMA_BD_STS_OFFSET, BdSts);
c000ef6c:	fec42783          	lw	a5,-20(s0)
c000ef70:	01c78793          	addi	a5,a5,28 # 8000001c <_end+0xb7f7b79c>
c000ef74:	00078713          	mv	a4,a5
c000ef78:	fe042783          	lw	a5,-32(s0)
c000ef7c:	00f72023          	sw	a5,0(a4)
	DATA_SYNC;

	/* This set has completed pre-processing, adjust ring pointers and
	 * counters
	 */
	XAXIDMA_RING_SEEKAHEAD(RingPtr, RingPtr->PreHead, NumBd);
c000ef80:	fcc42783          	lw	a5,-52(s0)
c000ef84:	0387a783          	lw	a5,56(a5)
c000ef88:	fcf42e23          	sw	a5,-36(s0)
c000ef8c:	fcc42783          	lw	a5,-52(s0)
c000ef90:	0307a703          	lw	a4,48(a5)
c000ef94:	fc842783          	lw	a5,-56(s0)
c000ef98:	02f707b3          	mul	a5,a4,a5
c000ef9c:	fdc42703          	lw	a4,-36(s0)
c000efa0:	00f707b3          	add	a5,a4,a5
c000efa4:	fcf42e23          	sw	a5,-36(s0)
c000efa8:	fcc42783          	lw	a5,-52(s0)
c000efac:	0287a783          	lw	a5,40(a5)
c000efb0:	fdc42703          	lw	a4,-36(s0)
c000efb4:	00e7ec63          	bltu	a5,a4,c000efcc <XAxiDma_BdRingToHw+0x294>
c000efb8:	fcc42783          	lw	a5,-52(s0)
c000efbc:	0387a783          	lw	a5,56(a5)
c000efc0:	00078713          	mv	a4,a5
c000efc4:	fdc42783          	lw	a5,-36(s0)
c000efc8:	00e7fc63          	bgeu	a5,a4,c000efe0 <XAxiDma_BdRingToHw+0x2a8>
c000efcc:	fcc42783          	lw	a5,-52(s0)
c000efd0:	02c7a783          	lw	a5,44(a5)
c000efd4:	fdc42703          	lw	a4,-36(s0)
c000efd8:	40f707b3          	sub	a5,a4,a5
c000efdc:	fcf42e23          	sw	a5,-36(s0)
c000efe0:	fdc42703          	lw	a4,-36(s0)
c000efe4:	fcc42783          	lw	a5,-52(s0)
c000efe8:	02e7ac23          	sw	a4,56(a5)
	RingPtr->PreCnt -= NumBd;
c000efec:	fcc42783          	lw	a5,-52(s0)
c000eff0:	0547a703          	lw	a4,84(a5)
c000eff4:	fc842783          	lw	a5,-56(s0)
c000eff8:	40f70733          	sub	a4,a4,a5
c000effc:	fcc42783          	lw	a5,-52(s0)
c000f000:	04e7aa23          	sw	a4,84(a5)
	RingPtr->HwTail = CurBdPtr;
c000f004:	fcc42783          	lw	a5,-52(s0)
c000f008:	fec42703          	lw	a4,-20(s0)
c000f00c:	04e7a023          	sw	a4,64(a5)
	RingPtr->HwCnt += NumBd;
c000f010:	fcc42783          	lw	a5,-52(s0)
c000f014:	0587a703          	lw	a4,88(a5)
c000f018:	fc842783          	lw	a5,-56(s0)
c000f01c:	00f70733          	add	a4,a4,a5
c000f020:	fcc42783          	lw	a5,-52(s0)
c000f024:	04e7ac23          	sw	a4,88(a5)

	/* If it is running, signal the engine to begin processing */
	if (RingPtr->RunState == AXIDMA_CHANNEL_NOT_HALTED) {
c000f028:	fcc42783          	lw	a5,-52(s0)
c000f02c:	0087a703          	lw	a4,8(a5)
c000f030:	00100793          	li	a5,1
c000f034:	1ef71063          	bne	a4,a5,c000f214 <XAxiDma_BdRingToHw+0x4dc>
			if (RingPtr->Cyclic) {
c000f038:	fcc42783          	lw	a5,-52(s0)
c000f03c:	0687a783          	lw	a5,104(a5)
c000f040:	06078663          	beqz	a5,c000f0ac <XAxiDma_BdRingToHw+0x374>
				XAxiDma_WriteReg(RingPtr->ChanBase,
c000f044:	fcc42783          	lw	a5,-52(s0)
c000f048:	0007a783          	lw	a5,0(a5)
c000f04c:	01078693          	addi	a3,a5,16
c000f050:	fcc42783          	lw	a5,-52(s0)
c000f054:	04c7a783          	lw	a5,76(a5)
c000f058:	00078613          	mv	a2,a5
c000f05c:	fcc42783          	lw	a5,-52(s0)
c000f060:	0207a703          	lw	a4,32(a5)
c000f064:	fcc42783          	lw	a5,-52(s0)
c000f068:	0247a783          	lw	a5,36(a5)
c000f06c:	40f707b3          	sub	a5,a4,a5
c000f070:	00f607b3          	add	a5,a2,a5
c000f074:	00078593          	mv	a1,a5
c000f078:	00068513          	mv	a0,a3
c000f07c:	c65fe0ef          	jal	ra,c000dce0 <Xil_Out32>
						 XAXIDMA_TDESC_OFFSET,
						 (u32)XAXIDMA_VIRT_TO_PHYS(RingPtr->CyclicBd));
				if (RingPtr->Addr_ext)
c000f080:	fcc42783          	lw	a5,-52(s0)
c000f084:	0187a783          	lw	a5,24(a5)
c000f088:	00078e63          	beqz	a5,c000f0a4 <XAxiDma_BdRingToHw+0x36c>
					XAxiDma_WriteReg(RingPtr->ChanBase,
c000f08c:	fcc42783          	lw	a5,-52(s0)
c000f090:	0007a783          	lw	a5,0(a5)
c000f094:	01478793          	addi	a5,a5,20
c000f098:	00000593          	li	a1,0
c000f09c:	00078513          	mv	a0,a5
c000f0a0:	c41fe0ef          	jal	ra,c000dce0 <Xil_Out32>
							 XAXIDMA_TDESC_MSB_OFFSET,
							 UPPER_32_BITS(XAXIDMA_VIRT_TO_PHYS(RingPtr->CyclicBd)));
				return XST_SUCCESS;
c000f0a4:	00000793          	li	a5,0
c000f0a8:	1700006f          	j	c000f218 <XAxiDma_BdRingToHw+0x4e0>
			}

			if (RingPtr->IsRxChannel) {
c000f0ac:	fcc42783          	lw	a5,-52(s0)
c000f0b0:	0047a783          	lw	a5,4(a5)
c000f0b4:	0e078e63          	beqz	a5,c000f1b0 <XAxiDma_BdRingToHw+0x478>
				if (!RingIndex) {
c000f0b8:	fd842783          	lw	a5,-40(s0)
c000f0bc:	06079663          	bnez	a5,c000f128 <XAxiDma_BdRingToHw+0x3f0>
					XAxiDma_WriteReg(RingPtr->ChanBase,
c000f0c0:	fcc42783          	lw	a5,-52(s0)
c000f0c4:	0007a783          	lw	a5,0(a5)
c000f0c8:	01078693          	addi	a3,a5,16
c000f0cc:	fcc42783          	lw	a5,-52(s0)
c000f0d0:	0407a783          	lw	a5,64(a5)
c000f0d4:	00078613          	mv	a2,a5
c000f0d8:	fcc42783          	lw	a5,-52(s0)
c000f0dc:	0207a703          	lw	a4,32(a5)
c000f0e0:	fcc42783          	lw	a5,-52(s0)
c000f0e4:	0247a783          	lw	a5,36(a5)
c000f0e8:	40f707b3          	sub	a5,a4,a5
c000f0ec:	00f607b3          	add	a5,a2,a5
c000f0f0:	fc07f793          	andi	a5,a5,-64
c000f0f4:	00078593          	mv	a1,a5
c000f0f8:	00068513          	mv	a0,a3
c000f0fc:	be5fe0ef          	jal	ra,c000dce0 <Xil_Out32>
							XAXIDMA_TDESC_OFFSET, (XAXIDMA_VIRT_TO_PHYS(RingPtr->HwTail) & XAXIDMA_DESC_LSB_MASK));
					if (RingPtr->Addr_ext)
c000f100:	fcc42783          	lw	a5,-52(s0)
c000f104:	0187a783          	lw	a5,24(a5)
c000f108:	10078663          	beqz	a5,c000f214 <XAxiDma_BdRingToHw+0x4dc>
						XAxiDma_WriteReg(RingPtr->ChanBase, XAXIDMA_TDESC_MSB_OFFSET,
c000f10c:	fcc42783          	lw	a5,-52(s0)
c000f110:	0007a783          	lw	a5,0(a5)
c000f114:	01478793          	addi	a5,a5,20
c000f118:	00000593          	li	a1,0
c000f11c:	00078513          	mv	a0,a5
c000f120:	bc1fe0ef          	jal	ra,c000dce0 <Xil_Out32>
c000f124:	0f00006f          	j	c000f214 <XAxiDma_BdRingToHw+0x4dc>
								 UPPER_32_BITS(XAXIDMA_VIRT_TO_PHYS(RingPtr->HwTail)));
				}
				else {
					XAxiDma_WriteReg(RingPtr->ChanBase,
c000f128:	fcc42783          	lw	a5,-52(s0)
c000f12c:	0007a783          	lw	a5,0(a5)
c000f130:	fd842703          	lw	a4,-40(s0)
c000f134:	fff70713          	addi	a4,a4,-1
c000f138:	00571713          	slli	a4,a4,0x5
c000f13c:	00e787b3          	add	a5,a5,a4
c000f140:	04878693          	addi	a3,a5,72
c000f144:	fcc42783          	lw	a5,-52(s0)
c000f148:	0407a783          	lw	a5,64(a5)
c000f14c:	00078613          	mv	a2,a5
c000f150:	fcc42783          	lw	a5,-52(s0)
c000f154:	0207a703          	lw	a4,32(a5)
c000f158:	fcc42783          	lw	a5,-52(s0)
c000f15c:	0247a783          	lw	a5,36(a5)
c000f160:	40f707b3          	sub	a5,a4,a5
c000f164:	00f607b3          	add	a5,a2,a5
c000f168:	fc07f793          	andi	a5,a5,-64
c000f16c:	00078593          	mv	a1,a5
c000f170:	00068513          	mv	a0,a3
c000f174:	b6dfe0ef          	jal	ra,c000dce0 <Xil_Out32>
						(XAXIDMA_RX_TDESC0_OFFSET +
						(RingIndex - 1) * XAXIDMA_RX_NDESC_OFFSET),
						(XAXIDMA_VIRT_TO_PHYS(RingPtr->HwTail) & XAXIDMA_DESC_LSB_MASK ));
					if (RingPtr->Addr_ext)
c000f178:	fcc42783          	lw	a5,-52(s0)
c000f17c:	0187a783          	lw	a5,24(a5)
c000f180:	08078a63          	beqz	a5,c000f214 <XAxiDma_BdRingToHw+0x4dc>
						XAxiDma_WriteReg(RingPtr->ChanBase,
c000f184:	fcc42783          	lw	a5,-52(s0)
c000f188:	0007a783          	lw	a5,0(a5)
c000f18c:	fd842703          	lw	a4,-40(s0)
c000f190:	fff70713          	addi	a4,a4,-1
c000f194:	00571713          	slli	a4,a4,0x5
c000f198:	00e787b3          	add	a5,a5,a4
c000f19c:	04c78793          	addi	a5,a5,76
c000f1a0:	00000593          	li	a1,0
c000f1a4:	00078513          	mv	a0,a5
c000f1a8:	b39fe0ef          	jal	ra,c000dce0 <Xil_Out32>
c000f1ac:	0680006f          	j	c000f214 <XAxiDma_BdRingToHw+0x4dc>
							(RingIndex - 1) * XAXIDMA_RX_NDESC_OFFSET),
							UPPER_32_BITS(XAXIDMA_VIRT_TO_PHYS(RingPtr->HwTail)));
				}
			}
			else {
				XAxiDma_WriteReg(RingPtr->ChanBase,
c000f1b0:	fcc42783          	lw	a5,-52(s0)
c000f1b4:	0007a783          	lw	a5,0(a5)
c000f1b8:	01078693          	addi	a3,a5,16
c000f1bc:	fcc42783          	lw	a5,-52(s0)
c000f1c0:	0407a783          	lw	a5,64(a5)
c000f1c4:	00078613          	mv	a2,a5
c000f1c8:	fcc42783          	lw	a5,-52(s0)
c000f1cc:	0207a703          	lw	a4,32(a5)
c000f1d0:	fcc42783          	lw	a5,-52(s0)
c000f1d4:	0247a783          	lw	a5,36(a5)
c000f1d8:	40f707b3          	sub	a5,a4,a5
c000f1dc:	00f607b3          	add	a5,a2,a5
c000f1e0:	fc07f793          	andi	a5,a5,-64
c000f1e4:	00078593          	mv	a1,a5
c000f1e8:	00068513          	mv	a0,a3
c000f1ec:	af5fe0ef          	jal	ra,c000dce0 <Xil_Out32>
							XAXIDMA_TDESC_OFFSET, (XAXIDMA_VIRT_TO_PHYS(RingPtr->HwTail) & XAXIDMA_DESC_LSB_MASK));
				if (RingPtr->Addr_ext)
c000f1f0:	fcc42783          	lw	a5,-52(s0)
c000f1f4:	0187a783          	lw	a5,24(a5)
c000f1f8:	00078e63          	beqz	a5,c000f214 <XAxiDma_BdRingToHw+0x4dc>
					XAxiDma_WriteReg(RingPtr->ChanBase, XAXIDMA_TDESC_MSB_OFFSET,
c000f1fc:	fcc42783          	lw	a5,-52(s0)
c000f200:	0007a783          	lw	a5,0(a5)
c000f204:	01478793          	addi	a5,a5,20
c000f208:	00000593          	li	a1,0
c000f20c:	00078513          	mv	a0,a5
c000f210:	ad1fe0ef          	jal	ra,c000dce0 <Xil_Out32>
								UPPER_32_BITS(XAXIDMA_VIRT_TO_PHYS(RingPtr->HwTail)));
			}
	}

	return XST_SUCCESS;
c000f214:	00000793          	li	a5,0
}
c000f218:	00078513          	mv	a0,a5
c000f21c:	03c12083          	lw	ra,60(sp)
c000f220:	03812403          	lw	s0,56(sp)
c000f224:	04010113          	addi	sp,sp,64
c000f228:	00008067          	ret

c000f22c <XAxiDma_BdRingFromHw>:
 *		This function can be used only when DMA is in SG mode
 *
 *****************************************************************************/
int XAxiDma_BdRingFromHw(XAxiDma_BdRing * RingPtr, int BdLimit,
			     XAxiDma_Bd ** BdSetPtr)
{
c000f22c:	fc010113          	addi	sp,sp,-64
c000f230:	02812e23          	sw	s0,60(sp)
c000f234:	04010413          	addi	s0,sp,64
c000f238:	fca42623          	sw	a0,-52(s0)
c000f23c:	fcb42423          	sw	a1,-56(s0)
c000f240:	fcc42223          	sw	a2,-60(s0)
	int BdCount;
	int BdPartialCount;
	u32 BdSts;
	u32 BdCr;

	CurBdPtr = RingPtr->HwHead;
c000f244:	fcc42783          	lw	a5,-52(s0)
c000f248:	03c7a783          	lw	a5,60(a5)
c000f24c:	fef42623          	sw	a5,-20(s0)
	BdCount = 0;
c000f250:	fe042423          	sw	zero,-24(s0)
	BdPartialCount = 0;
c000f254:	fe042223          	sw	zero,-28(s0)
	BdSts = 0;
c000f258:	fc042e23          	sw	zero,-36(s0)
	BdCr = 0;
c000f25c:	fc042c23          	sw	zero,-40(s0)

	/* If no BDs in work group, then there's nothing to search */
	if (RingPtr->HwCnt == 0) {
c000f260:	fcc42783          	lw	a5,-52(s0)
c000f264:	0587a783          	lw	a5,88(a5)
c000f268:	00079a63          	bnez	a5,c000f27c <XAxiDma_BdRingFromHw+0x50>
		*BdSetPtr = (XAxiDma_Bd *)NULL;
c000f26c:	fc442783          	lw	a5,-60(s0)
c000f270:	0007a023          	sw	zero,0(a5)

		return 0;
c000f274:	00000793          	li	a5,0
c000f278:	2180006f          	j	c000f490 <XAxiDma_BdRingFromHw+0x264>
	}

	if (BdLimit > RingPtr->HwCnt) {
c000f27c:	fcc42783          	lw	a5,-52(s0)
c000f280:	0587a783          	lw	a5,88(a5)
c000f284:	fc842703          	lw	a4,-56(s0)
c000f288:	10e7d463          	bge	a5,a4,c000f390 <XAxiDma_BdRingFromHw+0x164>
		BdLimit = RingPtr->HwCnt;
c000f28c:	fcc42783          	lw	a5,-52(s0)
c000f290:	0587a783          	lw	a5,88(a5)
c000f294:	fcf42423          	sw	a5,-56(s0)
	 *    BD.
	 *  - RingPtr->HwTail is reached
	 *  - The number of requested BDs has been processed
	 */

	while (BdCount < BdLimit) {
c000f298:	0f80006f          	j	c000f390 <XAxiDma_BdRingFromHw+0x164>
		/* Read the status */
		XAXIDMA_CACHE_INVALIDATE(CurBdPtr);
		BdSts = XAxiDma_BdRead(CurBdPtr, XAXIDMA_BD_STS_OFFSET);
c000f29c:	fec42783          	lw	a5,-20(s0)
c000f2a0:	01c78793          	addi	a5,a5,28
c000f2a4:	0007a783          	lw	a5,0(a5)
c000f2a8:	fcf42e23          	sw	a5,-36(s0)
		BdCr = XAxiDma_BdRead(CurBdPtr, XAXIDMA_BD_CTRL_LEN_OFFSET);
c000f2ac:	fec42783          	lw	a5,-20(s0)
c000f2b0:	01878793          	addi	a5,a5,24
c000f2b4:	0007a783          	lw	a5,0(a5)
c000f2b8:	fcf42c23          	sw	a5,-40(s0)

		/* If the hardware still hasn't processed this BD then we are
		 * done
		 */
		if (!(BdSts & XAXIDMA_BD_STS_COMPLETE_MASK)) {
c000f2bc:	fdc42783          	lw	a5,-36(s0)
c000f2c0:	0e07d063          	bgez	a5,c000f3a0 <XAxiDma_BdRingFromHw+0x174>
			break;
		}

		BdCount++;
c000f2c4:	fe842783          	lw	a5,-24(s0)
c000f2c8:	00178793          	addi	a5,a5,1
c000f2cc:	fef42423          	sw	a5,-24(s0)
		 * Keep a count of these partial packet BDs.
		 *
		 * For tx BDs, EOF bit is in the control word
		 * For rx BDs, EOF bit is in the status word
		 */
		if (((!(RingPtr->IsRxChannel) &&
c000f2d0:	fcc42783          	lw	a5,-52(s0)
c000f2d4:	0047a783          	lw	a5,4(a5)
c000f2d8:	00079a63          	bnez	a5,c000f2ec <XAxiDma_BdRingFromHw+0xc0>
		(BdCr & XAXIDMA_BD_CTRL_TXEOF_MASK)) ||
c000f2dc:	fd842703          	lw	a4,-40(s0)
c000f2e0:	040007b7          	lui	a5,0x4000
c000f2e4:	00f777b3          	and	a5,a4,a5
		if (((!(RingPtr->IsRxChannel) &&
c000f2e8:	02079063          	bnez	a5,c000f308 <XAxiDma_BdRingFromHw+0xdc>
		((RingPtr->IsRxChannel) && (BdSts &
c000f2ec:	fcc42783          	lw	a5,-52(s0)
c000f2f0:	0047a783          	lw	a5,4(a5) # 4000004 <_DMEM_LENGTH+0x3800004>
		(BdCr & XAXIDMA_BD_CTRL_TXEOF_MASK)) ||
c000f2f4:	00078e63          	beqz	a5,c000f310 <XAxiDma_BdRingFromHw+0xe4>
		((RingPtr->IsRxChannel) && (BdSts &
c000f2f8:	fdc42703          	lw	a4,-36(s0)
c000f2fc:	040007b7          	lui	a5,0x4000
c000f300:	00f777b3          	and	a5,a4,a5
c000f304:	00078663          	beqz	a5,c000f310 <XAxiDma_BdRingFromHw+0xe4>
			XAXIDMA_BD_STS_RXEOF_MASK)))) {

			BdPartialCount = 0;
c000f308:	fe042223          	sw	zero,-28(s0)
c000f30c:	0100006f          	j	c000f31c <XAxiDma_BdRingFromHw+0xf0>
		}
		else {
			BdPartialCount++;
c000f310:	fe442783          	lw	a5,-28(s0)
c000f314:	00178793          	addi	a5,a5,1 # 4000001 <_DMEM_LENGTH+0x3800001>
c000f318:	fef42223          	sw	a5,-28(s0)
		}

		if (RingPtr->Cyclic) {
c000f31c:	fcc42783          	lw	a5,-52(s0)
c000f320:	0687a783          	lw	a5,104(a5)
c000f324:	02078663          	beqz	a5,c000f350 <XAxiDma_BdRingFromHw+0x124>
			BdSts = BdSts & ~XAXIDMA_BD_STS_COMPLETE_MASK;
c000f328:	fdc42703          	lw	a4,-36(s0)
c000f32c:	800007b7          	lui	a5,0x80000
c000f330:	fff7c793          	not	a5,a5
c000f334:	00f777b3          	and	a5,a4,a5
c000f338:	fcf42e23          	sw	a5,-36(s0)
			XAxiDma_BdWrite(CurBdPtr, XAXIDMA_BD_STS_OFFSET, BdSts);
c000f33c:	fec42783          	lw	a5,-20(s0)
c000f340:	01c78793          	addi	a5,a5,28 # 8000001c <_end+0xb7f7b79c>
c000f344:	00078713          	mv	a4,a5
c000f348:	fdc42783          	lw	a5,-36(s0)
c000f34c:	00f72023          	sw	a5,0(a4)
			XAXIDMA_CACHE_FLUSH(CurBdPtr);
		}

		/* Reached the end of the work group */
		if (CurBdPtr == RingPtr->HwTail) {
c000f350:	fcc42783          	lw	a5,-52(s0)
c000f354:	0407a783          	lw	a5,64(a5)
c000f358:	fec42703          	lw	a4,-20(s0)
c000f35c:	04f70663          	beq	a4,a5,c000f3a8 <XAxiDma_BdRingFromHw+0x17c>
			break;
		}

		/* Move on to the next BD in work group */
		CurBdPtr = (XAxiDma_Bd *)((void *)XAxiDma_BdRingNext(RingPtr, CurBdPtr));
c000f360:	fcc42783          	lw	a5,-52(s0)
c000f364:	0287a703          	lw	a4,40(a5)
c000f368:	fec42783          	lw	a5,-20(s0)
c000f36c:	00e7e863          	bltu	a5,a4,c000f37c <XAxiDma_BdRingFromHw+0x150>
c000f370:	fcc42783          	lw	a5,-52(s0)
c000f374:	0247a783          	lw	a5,36(a5)
c000f378:	0140006f          	j	c000f38c <XAxiDma_BdRingFromHw+0x160>
c000f37c:	fcc42783          	lw	a5,-52(s0)
c000f380:	0307a703          	lw	a4,48(a5)
c000f384:	fec42783          	lw	a5,-20(s0)
c000f388:	00f707b3          	add	a5,a4,a5
c000f38c:	fef42623          	sw	a5,-20(s0)
	while (BdCount < BdLimit) {
c000f390:	fe842703          	lw	a4,-24(s0)
c000f394:	fc842783          	lw	a5,-56(s0)
c000f398:	f0f742e3          	blt	a4,a5,c000f29c <XAxiDma_BdRingFromHw+0x70>
c000f39c:	0100006f          	j	c000f3ac <XAxiDma_BdRingFromHw+0x180>
			break;
c000f3a0:	00000013          	nop
c000f3a4:	0080006f          	j	c000f3ac <XAxiDma_BdRingFromHw+0x180>
			break;
c000f3a8:	00000013          	nop
	}

	/* Subtract off any partial packet BDs found */
	BdCount -= BdPartialCount;
c000f3ac:	fe842703          	lw	a4,-24(s0)
c000f3b0:	fe442783          	lw	a5,-28(s0)
c000f3b4:	40f707b3          	sub	a5,a4,a5
c000f3b8:	fef42423          	sw	a5,-24(s0)

	/* If BdCount is non-zero then BDs were found to return. Set return
	 * parameters, update pointers and counters, return success
	 */
	if (BdCount) {
c000f3bc:	fe842783          	lw	a5,-24(s0)
c000f3c0:	0c078263          	beqz	a5,c000f484 <XAxiDma_BdRingFromHw+0x258>
		*BdSetPtr = RingPtr->HwHead;
c000f3c4:	fcc42783          	lw	a5,-52(s0)
c000f3c8:	03c7a703          	lw	a4,60(a5)
c000f3cc:	fc442783          	lw	a5,-60(s0)
c000f3d0:	00e7a023          	sw	a4,0(a5)
		if (!RingPtr->Cyclic) {
c000f3d4:	fcc42783          	lw	a5,-52(s0)
c000f3d8:	0687a783          	lw	a5,104(a5)
c000f3dc:	02079a63          	bnez	a5,c000f410 <XAxiDma_BdRingFromHw+0x1e4>
			RingPtr->HwCnt -= BdCount;
c000f3e0:	fcc42783          	lw	a5,-52(s0)
c000f3e4:	0587a703          	lw	a4,88(a5)
c000f3e8:	fe842783          	lw	a5,-24(s0)
c000f3ec:	40f70733          	sub	a4,a4,a5
c000f3f0:	fcc42783          	lw	a5,-52(s0)
c000f3f4:	04e7ac23          	sw	a4,88(a5)
			RingPtr->PostCnt += BdCount;
c000f3f8:	fcc42783          	lw	a5,-52(s0)
c000f3fc:	05c7a703          	lw	a4,92(a5)
c000f400:	fe842783          	lw	a5,-24(s0)
c000f404:	00f70733          	add	a4,a4,a5
c000f408:	fcc42783          	lw	a5,-52(s0)
c000f40c:	04e7ae23          	sw	a4,92(a5)
		}
		XAXIDMA_RING_SEEKAHEAD(RingPtr, RingPtr->HwHead, BdCount);
c000f410:	fcc42783          	lw	a5,-52(s0)
c000f414:	03c7a783          	lw	a5,60(a5)
c000f418:	fef42023          	sw	a5,-32(s0)
c000f41c:	fcc42783          	lw	a5,-52(s0)
c000f420:	0307a703          	lw	a4,48(a5)
c000f424:	fe842783          	lw	a5,-24(s0)
c000f428:	02f707b3          	mul	a5,a4,a5
c000f42c:	fe042703          	lw	a4,-32(s0)
c000f430:	00f707b3          	add	a5,a4,a5
c000f434:	fef42023          	sw	a5,-32(s0)
c000f438:	fcc42783          	lw	a5,-52(s0)
c000f43c:	0287a783          	lw	a5,40(a5)
c000f440:	fe042703          	lw	a4,-32(s0)
c000f444:	00e7ec63          	bltu	a5,a4,c000f45c <XAxiDma_BdRingFromHw+0x230>
c000f448:	fcc42783          	lw	a5,-52(s0)
c000f44c:	03c7a783          	lw	a5,60(a5)
c000f450:	00078713          	mv	a4,a5
c000f454:	fe042783          	lw	a5,-32(s0)
c000f458:	00e7fc63          	bgeu	a5,a4,c000f470 <XAxiDma_BdRingFromHw+0x244>
c000f45c:	fcc42783          	lw	a5,-52(s0)
c000f460:	02c7a783          	lw	a5,44(a5)
c000f464:	fe042703          	lw	a4,-32(s0)
c000f468:	40f707b3          	sub	a5,a4,a5
c000f46c:	fef42023          	sw	a5,-32(s0)
c000f470:	fe042703          	lw	a4,-32(s0)
c000f474:	fcc42783          	lw	a5,-52(s0)
c000f478:	02e7ae23          	sw	a4,60(a5)

		return BdCount;
c000f47c:	fe842783          	lw	a5,-24(s0)
c000f480:	0100006f          	j	c000f490 <XAxiDma_BdRingFromHw+0x264>
	}
	else {
		*BdSetPtr = (XAxiDma_Bd *)NULL;
c000f484:	fc442783          	lw	a5,-60(s0)
c000f488:	0007a023          	sw	zero,0(a5)

		return 0;
c000f48c:	00000793          	li	a5,0
	}
}
c000f490:	00078513          	mv	a0,a5
c000f494:	03c12403          	lw	s0,60(sp)
c000f498:	04010113          	addi	sp,sp,64
c000f49c:	00008067          	ret

c000f4a0 <XAxiDma_BdRingFree>:
 *		This function can be used only when DMA is in SG mode
 *
 *****************************************************************************/
int XAxiDma_BdRingFree(XAxiDma_BdRing * RingPtr, int NumBd,
		      XAxiDma_Bd * BdSetPtr)
{
c000f4a0:	fd010113          	addi	sp,sp,-48
c000f4a4:	02112623          	sw	ra,44(sp)
c000f4a8:	02812423          	sw	s0,40(sp)
c000f4ac:	03010413          	addi	s0,sp,48
c000f4b0:	fca42e23          	sw	a0,-36(s0)
c000f4b4:	fcb42c23          	sw	a1,-40(s0)
c000f4b8:	fcc42a23          	sw	a2,-44(s0)
	if (NumBd < 0) {
c000f4bc:	fd842783          	lw	a5,-40(s0)
c000f4c0:	0007de63          	bgez	a5,c000f4dc <XAxiDma_BdRingFree+0x3c>

		printf(
c000f4c4:	fd842583          	lw	a1,-40(s0)
c000f4c8:	07ff1517          	auipc	a0,0x7ff1
c000f4cc:	39850513          	addi	a0,a0,920 # c8000860 <__rodata_start+0x860>
c000f4d0:	0d50e0ef          	jal	ra,c001dda4 <printf>
		    "BdRingFree: negative BDs %d\r\n", NumBd);

		return XST_INVALID_PARAM;
c000f4d4:	00f00793          	li	a5,15
c000f4d8:	1080006f          	j	c000f5e0 <XAxiDma_BdRingFree+0x140>
	}

	/* If the BD Set to free is empty, do nothing
	 */
	if (NumBd == 0) {
c000f4dc:	fd842783          	lw	a5,-40(s0)
c000f4e0:	00079663          	bnez	a5,c000f4ec <XAxiDma_BdRingFree+0x4c>
		return XST_SUCCESS;
c000f4e4:	00000793          	li	a5,0
c000f4e8:	0f80006f          	j	c000f5e0 <XAxiDma_BdRingFree+0x140>
	}

	/* Make sure we are in sync with XAxiDma_BdRingFromHw() */
	if ((RingPtr->PostCnt < NumBd) || (RingPtr->PostHead != BdSetPtr)) {
c000f4ec:	fdc42783          	lw	a5,-36(s0)
c000f4f0:	05c7a783          	lw	a5,92(a5)
c000f4f4:	fd842703          	lw	a4,-40(s0)
c000f4f8:	00e7ca63          	blt	a5,a4,c000f50c <XAxiDma_BdRingFree+0x6c>
c000f4fc:	fdc42783          	lw	a5,-36(s0)
c000f500:	0447a783          	lw	a5,68(a5)
c000f504:	fd442703          	lw	a4,-44(s0)
c000f508:	02f70c63          	beq	a4,a5,c000f540 <XAxiDma_BdRingFree+0xa0>

		printf("BdRingFree: Error free BDs: "
c000f50c:	fdc42783          	lw	a5,-36(s0)
c000f510:	05c7a583          	lw	a1,92(a5)
		"post count %d to free %d, PostHead %x to free ptr %x\r\n",
			RingPtr->PostCnt, NumBd,
			(unsigned int)(UINTPTR)RingPtr->PostHead,
c000f514:	fdc42783          	lw	a5,-36(s0)
c000f518:	0447a783          	lw	a5,68(a5)
		printf("BdRingFree: Error free BDs: "
c000f51c:	00078693          	mv	a3,a5
c000f520:	fd442783          	lw	a5,-44(s0)
c000f524:	00078713          	mv	a4,a5
c000f528:	fd842603          	lw	a2,-40(s0)
c000f52c:	07ff1517          	auipc	a0,0x7ff1
c000f530:	35450513          	addi	a0,a0,852 # c8000880 <__rodata_start+0x880>
c000f534:	0710e0ef          	jal	ra,c001dda4 <printf>
			(unsigned int)(UINTPTR)BdSetPtr);

		return XST_DMA_SG_LIST_ERROR;
c000f538:	20e00793          	li	a5,526
c000f53c:	0a40006f          	j	c000f5e0 <XAxiDma_BdRingFree+0x140>
	}

	/* Update pointers and counters */
	RingPtr->FreeCnt += NumBd;
c000f540:	fdc42783          	lw	a5,-36(s0)
c000f544:	0507a703          	lw	a4,80(a5)
c000f548:	fd842783          	lw	a5,-40(s0)
c000f54c:	00f70733          	add	a4,a4,a5
c000f550:	fdc42783          	lw	a5,-36(s0)
c000f554:	04e7a823          	sw	a4,80(a5)
	RingPtr->PostCnt -= NumBd;
c000f558:	fdc42783          	lw	a5,-36(s0)
c000f55c:	05c7a703          	lw	a4,92(a5)
c000f560:	fd842783          	lw	a5,-40(s0)
c000f564:	40f70733          	sub	a4,a4,a5
c000f568:	fdc42783          	lw	a5,-36(s0)
c000f56c:	04e7ae23          	sw	a4,92(a5)
	XAXIDMA_RING_SEEKAHEAD(RingPtr, RingPtr->PostHead, NumBd);
c000f570:	fdc42783          	lw	a5,-36(s0)
c000f574:	0447a783          	lw	a5,68(a5)
c000f578:	fef42623          	sw	a5,-20(s0)
c000f57c:	fdc42783          	lw	a5,-36(s0)
c000f580:	0307a703          	lw	a4,48(a5)
c000f584:	fd842783          	lw	a5,-40(s0)
c000f588:	02f707b3          	mul	a5,a4,a5
c000f58c:	fec42703          	lw	a4,-20(s0)
c000f590:	00f707b3          	add	a5,a4,a5
c000f594:	fef42623          	sw	a5,-20(s0)
c000f598:	fdc42783          	lw	a5,-36(s0)
c000f59c:	0287a783          	lw	a5,40(a5)
c000f5a0:	fec42703          	lw	a4,-20(s0)
c000f5a4:	00e7ec63          	bltu	a5,a4,c000f5bc <XAxiDma_BdRingFree+0x11c>
c000f5a8:	fdc42783          	lw	a5,-36(s0)
c000f5ac:	0447a783          	lw	a5,68(a5)
c000f5b0:	00078713          	mv	a4,a5
c000f5b4:	fec42783          	lw	a5,-20(s0)
c000f5b8:	00e7fc63          	bgeu	a5,a4,c000f5d0 <XAxiDma_BdRingFree+0x130>
c000f5bc:	fdc42783          	lw	a5,-36(s0)
c000f5c0:	02c7a783          	lw	a5,44(a5)
c000f5c4:	fec42703          	lw	a4,-20(s0)
c000f5c8:	40f707b3          	sub	a5,a4,a5
c000f5cc:	fef42623          	sw	a5,-20(s0)
c000f5d0:	fec42703          	lw	a4,-20(s0)
c000f5d4:	fdc42783          	lw	a5,-36(s0)
c000f5d8:	04e7a223          	sw	a4,68(a5)

	return XST_SUCCESS;
c000f5dc:	00000793          	li	a5,0
}
c000f5e0:	00078513          	mv	a0,a5
c000f5e4:	02c12083          	lw	ra,44(sp)
c000f5e8:	02812403          	lw	s0,40(sp)
c000f5ec:	03010113          	addi	sp,sp,48
c000f5f0:	00008067          	ret

c000f5f4 <XAxiDma_BdRingCheck>:
 *
 * @note	This function can be used only when DMA is in SG mode
 *
 *****************************************************************************/
int XAxiDma_BdRingCheck(XAxiDma_BdRing * RingPtr)
{
c000f5f4:	fd010113          	addi	sp,sp,-48
c000f5f8:	02112623          	sw	ra,44(sp)
c000f5fc:	02812423          	sw	s0,40(sp)
c000f600:	03010413          	addi	s0,sp,48
c000f604:	fca42e23          	sw	a0,-36(s0)
	u32 AddrV;
	u32 AddrP;
	int i;

	/* Is the list created */
	if (RingPtr->AllCnt == 0) {
c000f608:	fdc42783          	lw	a5,-36(s0)
c000f60c:	0607a783          	lw	a5,96(a5)
c000f610:	00079c63          	bnez	a5,c000f628 <XAxiDma_BdRingCheck+0x34>

		printf("BdRingCheck: no BDs\r\n");
c000f614:	07ff1517          	auipc	a0,0x7ff1
c000f618:	2c050513          	addi	a0,a0,704 # c80008d4 <__rodata_start+0x8d4>
c000f61c:	0a50e0ef          	jal	ra,c001dec0 <puts>

		return XST_DMA_SG_NO_LIST;
c000f620:	20b00793          	li	a5,523
c000f624:	35c0006f          	j	c000f980 <XAxiDma_BdRingCheck+0x38c>
	}

	/* Can't check if channel is running */
	if (RingPtr->RunState == AXIDMA_CHANNEL_NOT_HALTED) {
c000f628:	fdc42783          	lw	a5,-36(s0)
c000f62c:	0087a703          	lw	a4,8(a5)
c000f630:	00100793          	li	a5,1
c000f634:	00f71c63          	bne	a4,a5,c000f64c <XAxiDma_BdRingCheck+0x58>

		printf("BdRingCheck: Bd ring is "
c000f638:	07ff1517          	auipc	a0,0x7ff1
c000f63c:	2b450513          	addi	a0,a0,692 # c80008ec <__rodata_start+0x8ec>
c000f640:	0810e0ef          	jal	ra,c001dec0 <puts>
		"running, cannot check it\r\n");

		return XST_IS_STARTED;
c000f644:	01700793          	li	a5,23
c000f648:	3380006f          	j	c000f980 <XAxiDma_BdRingCheck+0x38c>
	}

	/* RunState doesn't make sense */
	else if (RingPtr->RunState != AXIDMA_CHANNEL_HALTED) {
c000f64c:	fdc42783          	lw	a5,-36(s0)
c000f650:	0087a703          	lw	a4,8(a5)
c000f654:	00200793          	li	a5,2
c000f658:	02f70263          	beq	a4,a5,c000f67c <XAxiDma_BdRingCheck+0x88>

		printf("BdRingCheck: unknown BD ring "
c000f65c:	fdc42783          	lw	a5,-36(s0)
c000f660:	0087a783          	lw	a5,8(a5)
c000f664:	00078593          	mv	a1,a5
c000f668:	07ff1517          	auipc	a0,0x7ff1
c000f66c:	2b850513          	addi	a0,a0,696 # c8000920 <__rodata_start+0x920>
c000f670:	7340e0ef          	jal	ra,c001dda4 <printf>
			"state %d ", RingPtr->RunState);

		return XST_DMA_SG_LIST_ERROR;
c000f674:	20e00793          	li	a5,526
c000f678:	3080006f          	j	c000f980 <XAxiDma_BdRingCheck+0x38c>
	}

	/* Verify internal pointers point to correct memory space */
	AddrV = (UINTPTR) RingPtr->FreeHead;
c000f67c:	fdc42783          	lw	a5,-36(s0)
c000f680:	0347a783          	lw	a5,52(a5)
c000f684:	fef42623          	sw	a5,-20(s0)
	if ((AddrV < RingPtr->FirstBdAddr) || (AddrV > RingPtr->LastBdAddr)) {
c000f688:	fdc42783          	lw	a5,-36(s0)
c000f68c:	0247a783          	lw	a5,36(a5)
c000f690:	fec42703          	lw	a4,-20(s0)
c000f694:	00f76a63          	bltu	a4,a5,c000f6a8 <XAxiDma_BdRingCheck+0xb4>
c000f698:	fdc42783          	lw	a5,-36(s0)
c000f69c:	0287a783          	lw	a5,40(a5)
c000f6a0:	fec42703          	lw	a4,-20(s0)
c000f6a4:	02e7fa63          	bgeu	a5,a4,c000f6d8 <XAxiDma_BdRingCheck+0xe4>

		printf("BdRingCheck: FreeHead wrong "
		"%x, should be in range of %x/%x\r\n",
		    (unsigned int)AddrV,
		    (unsigned int)RingPtr->FirstBdAddr,
c000f6a8:	fdc42783          	lw	a5,-36(s0)
c000f6ac:	0247a703          	lw	a4,36(a5)
			(unsigned int)RingPtr->LastBdAddr);
c000f6b0:	fdc42783          	lw	a5,-36(s0)
c000f6b4:	0287a783          	lw	a5,40(a5)
		printf("BdRingCheck: FreeHead wrong "
c000f6b8:	00078693          	mv	a3,a5
c000f6bc:	00070613          	mv	a2,a4
c000f6c0:	fec42583          	lw	a1,-20(s0)
c000f6c4:	07ff1517          	auipc	a0,0x7ff1
c000f6c8:	28450513          	addi	a0,a0,644 # c8000948 <__rodata_start+0x948>
c000f6cc:	6d80e0ef          	jal	ra,c001dda4 <printf>

		return XST_DMA_SG_LIST_ERROR;
c000f6d0:	20e00793          	li	a5,526
c000f6d4:	2ac0006f          	j	c000f980 <XAxiDma_BdRingCheck+0x38c>
	}

	AddrV = (UINTPTR) RingPtr->PreHead;
c000f6d8:	fdc42783          	lw	a5,-36(s0)
c000f6dc:	0387a783          	lw	a5,56(a5)
c000f6e0:	fef42623          	sw	a5,-20(s0)
	if ((AddrV < RingPtr->FirstBdAddr) || (AddrV > RingPtr->LastBdAddr)) {
c000f6e4:	fdc42783          	lw	a5,-36(s0)
c000f6e8:	0247a783          	lw	a5,36(a5)
c000f6ec:	fec42703          	lw	a4,-20(s0)
c000f6f0:	00f76a63          	bltu	a4,a5,c000f704 <XAxiDma_BdRingCheck+0x110>
c000f6f4:	fdc42783          	lw	a5,-36(s0)
c000f6f8:	0287a783          	lw	a5,40(a5)
c000f6fc:	fec42703          	lw	a4,-20(s0)
c000f700:	02e7fa63          	bgeu	a5,a4,c000f734 <XAxiDma_BdRingCheck+0x140>

		printf("BdRingCheck: PreHead wrong %x, "
			"should be in range of %x/%x\r\n",
		    (unsigned int)AddrV,
		    (unsigned int)RingPtr->FirstBdAddr,
c000f704:	fdc42783          	lw	a5,-36(s0)
c000f708:	0247a703          	lw	a4,36(a5)
			(unsigned int)RingPtr->LastBdAddr);
c000f70c:	fdc42783          	lw	a5,-36(s0)
c000f710:	0287a783          	lw	a5,40(a5)
		printf("BdRingCheck: PreHead wrong %x, "
c000f714:	00078693          	mv	a3,a5
c000f718:	00070613          	mv	a2,a4
c000f71c:	fec42583          	lw	a1,-20(s0)
c000f720:	07ff1517          	auipc	a0,0x7ff1
c000f724:	26850513          	addi	a0,a0,616 # c8000988 <__rodata_start+0x988>
c000f728:	67c0e0ef          	jal	ra,c001dda4 <printf>

		return XST_DMA_SG_LIST_ERROR;
c000f72c:	20e00793          	li	a5,526
c000f730:	2500006f          	j	c000f980 <XAxiDma_BdRingCheck+0x38c>
	}

	AddrV = (UINTPTR) RingPtr->HwHead;
c000f734:	fdc42783          	lw	a5,-36(s0)
c000f738:	03c7a783          	lw	a5,60(a5)
c000f73c:	fef42623          	sw	a5,-20(s0)
	if ((AddrV < RingPtr->FirstBdAddr) || (AddrV > RingPtr->LastBdAddr)) {
c000f740:	fdc42783          	lw	a5,-36(s0)
c000f744:	0247a783          	lw	a5,36(a5)
c000f748:	fec42703          	lw	a4,-20(s0)
c000f74c:	00f76a63          	bltu	a4,a5,c000f760 <XAxiDma_BdRingCheck+0x16c>
c000f750:	fdc42783          	lw	a5,-36(s0)
c000f754:	0287a783          	lw	a5,40(a5)
c000f758:	fec42703          	lw	a4,-20(s0)
c000f75c:	02e7fa63          	bgeu	a5,a4,c000f790 <XAxiDma_BdRingCheck+0x19c>

		printf("BdRingCheck: HwHead wrong %x, "
			"should be in range of %x/%x\r\n",
		    (unsigned int)AddrV,
		    (unsigned int)RingPtr->FirstBdAddr,
c000f760:	fdc42783          	lw	a5,-36(s0)
c000f764:	0247a703          	lw	a4,36(a5)
			(unsigned int)RingPtr->LastBdAddr);
c000f768:	fdc42783          	lw	a5,-36(s0)
c000f76c:	0287a783          	lw	a5,40(a5)
		printf("BdRingCheck: HwHead wrong %x, "
c000f770:	00078693          	mv	a3,a5
c000f774:	00070613          	mv	a2,a4
c000f778:	fec42583          	lw	a1,-20(s0)
c000f77c:	07ff1517          	auipc	a0,0x7ff1
c000f780:	24c50513          	addi	a0,a0,588 # c80009c8 <__rodata_start+0x9c8>
c000f784:	6200e0ef          	jal	ra,c001dda4 <printf>

		return XST_DMA_SG_LIST_ERROR;
c000f788:	20e00793          	li	a5,526
c000f78c:	1f40006f          	j	c000f980 <XAxiDma_BdRingCheck+0x38c>
	}

	AddrV = (UINTPTR) RingPtr->HwTail;
c000f790:	fdc42783          	lw	a5,-36(s0)
c000f794:	0407a783          	lw	a5,64(a5)
c000f798:	fef42623          	sw	a5,-20(s0)
	if ((AddrV < RingPtr->FirstBdAddr) || (AddrV > RingPtr->LastBdAddr)) {
c000f79c:	fdc42783          	lw	a5,-36(s0)
c000f7a0:	0247a783          	lw	a5,36(a5)
c000f7a4:	fec42703          	lw	a4,-20(s0)
c000f7a8:	00f76a63          	bltu	a4,a5,c000f7bc <XAxiDma_BdRingCheck+0x1c8>
c000f7ac:	fdc42783          	lw	a5,-36(s0)
c000f7b0:	0287a783          	lw	a5,40(a5)
c000f7b4:	fec42703          	lw	a4,-20(s0)
c000f7b8:	02e7fa63          	bgeu	a5,a4,c000f7ec <XAxiDma_BdRingCheck+0x1f8>

		printf("BdRingCheck: HwTail wrong %x, "
			"should be in range of %x/%x\r\n",
		    (unsigned int)AddrV,
		    (unsigned int)RingPtr->FirstBdAddr,
c000f7bc:	fdc42783          	lw	a5,-36(s0)
c000f7c0:	0247a703          	lw	a4,36(a5)
			(unsigned int)RingPtr->LastBdAddr);
c000f7c4:	fdc42783          	lw	a5,-36(s0)
c000f7c8:	0287a783          	lw	a5,40(a5)
		printf("BdRingCheck: HwTail wrong %x, "
c000f7cc:	00078693          	mv	a3,a5
c000f7d0:	00070613          	mv	a2,a4
c000f7d4:	fec42583          	lw	a1,-20(s0)
c000f7d8:	07ff1517          	auipc	a0,0x7ff1
c000f7dc:	22c50513          	addi	a0,a0,556 # c8000a04 <__rodata_start+0xa04>
c000f7e0:	5c40e0ef          	jal	ra,c001dda4 <printf>

		return XST_DMA_SG_LIST_ERROR;
c000f7e4:	20e00793          	li	a5,526
c000f7e8:	1980006f          	j	c000f980 <XAxiDma_BdRingCheck+0x38c>
	}

	AddrV = (UINTPTR) RingPtr->PostHead;
c000f7ec:	fdc42783          	lw	a5,-36(s0)
c000f7f0:	0447a783          	lw	a5,68(a5)
c000f7f4:	fef42623          	sw	a5,-20(s0)
	if ((AddrV < RingPtr->FirstBdAddr) || (AddrV > RingPtr->LastBdAddr)) {
c000f7f8:	fdc42783          	lw	a5,-36(s0)
c000f7fc:	0247a783          	lw	a5,36(a5)
c000f800:	fec42703          	lw	a4,-20(s0)
c000f804:	00f76a63          	bltu	a4,a5,c000f818 <XAxiDma_BdRingCheck+0x224>
c000f808:	fdc42783          	lw	a5,-36(s0)
c000f80c:	0287a783          	lw	a5,40(a5)
c000f810:	fec42703          	lw	a4,-20(s0)
c000f814:	02e7fa63          	bgeu	a5,a4,c000f848 <XAxiDma_BdRingCheck+0x254>

		printf("BdRingCheck: PostHead wrong "
		"%x, should be in range of %x/%x\r\n",
		    (unsigned int)AddrV,
		    (unsigned int)RingPtr->FirstBdAddr,
c000f818:	fdc42783          	lw	a5,-36(s0)
c000f81c:	0247a703          	lw	a4,36(a5)
			(unsigned int)RingPtr->LastBdAddr);
c000f820:	fdc42783          	lw	a5,-36(s0)
c000f824:	0287a783          	lw	a5,40(a5)
		printf("BdRingCheck: PostHead wrong "
c000f828:	00078693          	mv	a3,a5
c000f82c:	00070613          	mv	a2,a4
c000f830:	fec42583          	lw	a1,-20(s0)
c000f834:	07ff1517          	auipc	a0,0x7ff1
c000f838:	20c50513          	addi	a0,a0,524 # c8000a40 <__rodata_start+0xa40>
c000f83c:	5680e0ef          	jal	ra,c001dda4 <printf>

		return XST_DMA_SG_LIST_ERROR;
c000f840:	20e00793          	li	a5,526
c000f844:	13c0006f          	j	c000f980 <XAxiDma_BdRingCheck+0x38c>
	}

	/* Verify internal counters add up */
	if ((RingPtr->HwCnt + RingPtr->PreCnt + RingPtr->FreeCnt +
c000f848:	fdc42783          	lw	a5,-36(s0)
c000f84c:	0587a703          	lw	a4,88(a5)
c000f850:	fdc42783          	lw	a5,-36(s0)
c000f854:	0547a783          	lw	a5,84(a5)
c000f858:	00f70733          	add	a4,a4,a5
c000f85c:	fdc42783          	lw	a5,-36(s0)
c000f860:	0507a783          	lw	a5,80(a5)
c000f864:	00f70733          	add	a4,a4,a5
	     RingPtr->PostCnt) != RingPtr->AllCnt) {
c000f868:	fdc42783          	lw	a5,-36(s0)
c000f86c:	05c7a783          	lw	a5,92(a5)
	if ((RingPtr->HwCnt + RingPtr->PreCnt + RingPtr->FreeCnt +
c000f870:	00f70733          	add	a4,a4,a5
	     RingPtr->PostCnt) != RingPtr->AllCnt) {
c000f874:	fdc42783          	lw	a5,-36(s0)
c000f878:	0607a783          	lw	a5,96(a5)
	if ((RingPtr->HwCnt + RingPtr->PreCnt + RingPtr->FreeCnt +
c000f87c:	00f70c63          	beq	a4,a5,c000f894 <XAxiDma_BdRingCheck+0x2a0>

		printf("BdRingCheck: internal counter "
c000f880:	07ff1517          	auipc	a0,0x7ff1
c000f884:	20050513          	addi	a0,a0,512 # c8000a80 <__rodata_start+0xa80>
c000f888:	6380e0ef          	jal	ra,c001dec0 <puts>
			"error\r\n");

		return XST_DMA_SG_LIST_ERROR;
c000f88c:	20e00793          	li	a5,526
c000f890:	0f00006f          	j	c000f980 <XAxiDma_BdRingCheck+0x38c>
	}

	/* Verify BDs are linked correctly */
	AddrV = RingPtr->FirstBdAddr;
c000f894:	fdc42783          	lw	a5,-36(s0)
c000f898:	0247a783          	lw	a5,36(a5)
c000f89c:	fef42623          	sw	a5,-20(s0)
	AddrP = RingPtr->FirstBdPhysAddr + RingPtr->Separation;
c000f8a0:	fdc42783          	lw	a5,-36(s0)
c000f8a4:	0207a703          	lw	a4,32(a5)
c000f8a8:	fdc42783          	lw	a5,-36(s0)
c000f8ac:	0307a783          	lw	a5,48(a5)
c000f8b0:	00f707b3          	add	a5,a4,a5
c000f8b4:	fef42423          	sw	a5,-24(s0)
	for (i = 1; i < RingPtr->AllCnt; i++) {
c000f8b8:	00100793          	li	a5,1
c000f8bc:	fef42223          	sw	a5,-28(s0)
c000f8c0:	06c0006f          	j	c000f92c <XAxiDma_BdRingCheck+0x338>
		XAXIDMA_CACHE_INVALIDATE(AddrV);
		/* Check next pointer for this BD. It should equal to the
		 * physical address of next BD
		 */
		if (XAxiDma_BdRead(AddrV, XAXIDMA_BD_NDESC_OFFSET) != AddrP) {
c000f8c4:	fec42783          	lw	a5,-20(s0)
c000f8c8:	0007a783          	lw	a5,0(a5)
c000f8cc:	fe842703          	lw	a4,-24(s0)
c000f8d0:	02f70463          	beq	a4,a5,c000f8f8 <XAxiDma_BdRingCheck+0x304>

			printf("BdRingCheck: Next Bd "
			"ptr %x wrong, expect %x\r\n",
				(unsigned int)XAxiDma_BdRead(AddrV,
c000f8d4:	fec42783          	lw	a5,-20(s0)
			printf("BdRingCheck: Next Bd "
c000f8d8:	0007a783          	lw	a5,0(a5)
c000f8dc:	fe842603          	lw	a2,-24(s0)
c000f8e0:	00078593          	mv	a1,a5
c000f8e4:	07ff1517          	auipc	a0,0x7ff1
c000f8e8:	1c450513          	addi	a0,a0,452 # c8000aa8 <__rodata_start+0xaa8>
c000f8ec:	4b80e0ef          	jal	ra,c001dda4 <printf>
			        XAXIDMA_BD_NDESC_OFFSET),
				(unsigned int)AddrP);

			return XST_DMA_SG_LIST_ERROR;
c000f8f0:	20e00793          	li	a5,526
c000f8f4:	08c0006f          	j	c000f980 <XAxiDma_BdRingCheck+0x38c>
		}

		/* Move on to next BD */
		AddrV += RingPtr->Separation;
c000f8f8:	fdc42783          	lw	a5,-36(s0)
c000f8fc:	0307a783          	lw	a5,48(a5)
c000f900:	fec42703          	lw	a4,-20(s0)
c000f904:	00f707b3          	add	a5,a4,a5
c000f908:	fef42623          	sw	a5,-20(s0)
		AddrP += RingPtr->Separation;
c000f90c:	fdc42783          	lw	a5,-36(s0)
c000f910:	0307a783          	lw	a5,48(a5)
c000f914:	fe842703          	lw	a4,-24(s0)
c000f918:	00f707b3          	add	a5,a4,a5
c000f91c:	fef42423          	sw	a5,-24(s0)
	for (i = 1; i < RingPtr->AllCnt; i++) {
c000f920:	fe442783          	lw	a5,-28(s0)
c000f924:	00178793          	addi	a5,a5,1
c000f928:	fef42223          	sw	a5,-28(s0)
c000f92c:	fdc42783          	lw	a5,-36(s0)
c000f930:	0607a783          	lw	a5,96(a5)
c000f934:	fe442703          	lw	a4,-28(s0)
c000f938:	f8f746e3          	blt	a4,a5,c000f8c4 <XAxiDma_BdRingCheck+0x2d0>
	}

	XAXIDMA_CACHE_INVALIDATE(AddrV);
	/* Last BD should point back to the beginning of ring */
	if (XAxiDma_BdRead(AddrV, XAXIDMA_BD_NDESC_OFFSET) !=
c000f93c:	fec42783          	lw	a5,-20(s0)
c000f940:	0007a703          	lw	a4,0(a5)
	    RingPtr->FirstBdPhysAddr) {
c000f944:	fdc42783          	lw	a5,-36(s0)
c000f948:	0207a783          	lw	a5,32(a5)
	if (XAxiDma_BdRead(AddrV, XAXIDMA_BD_NDESC_OFFSET) !=
c000f94c:	02f70863          	beq	a4,a5,c000f97c <XAxiDma_BdRingCheck+0x388>

		printf("BdRingCheck: last Bd Next BD "
		"ptr %x wrong, expect %x\r\n",
			(unsigned int)XAxiDma_BdRead(AddrV,
c000f950:	fec42783          	lw	a5,-20(s0)
		printf("BdRingCheck: last Bd Next BD "
c000f954:	0007a703          	lw	a4,0(a5)
		          XAXIDMA_BD_NDESC_OFFSET),
			(unsigned int)RingPtr->FirstBdPhysAddr);
c000f958:	fdc42783          	lw	a5,-36(s0)
c000f95c:	0207a783          	lw	a5,32(a5)
		printf("BdRingCheck: last Bd Next BD "
c000f960:	00078613          	mv	a2,a5
c000f964:	00070593          	mv	a1,a4
c000f968:	07ff1517          	auipc	a0,0x7ff1
c000f96c:	17050513          	addi	a0,a0,368 # c8000ad8 <__rodata_start+0xad8>
c000f970:	4340e0ef          	jal	ra,c001dda4 <printf>

		return XST_DMA_SG_LIST_ERROR;
c000f974:	20e00793          	li	a5,526
c000f978:	0080006f          	j	c000f980 <XAxiDma_BdRingCheck+0x38c>
	}

	/* No problems found */
	return XST_SUCCESS;
c000f97c:	00000793          	li	a5,0
}
c000f980:	00078513          	mv	a0,a5
c000f984:	02c12083          	lw	ra,44(sp)
c000f988:	02812403          	lw	s0,40(sp)
c000f98c:	03010113          	addi	sp,sp,48
c000f990:	00008067          	ret

c000f994 <XAxiDma_BdRingDumpRegs>:
 * @return	None
 *
 * @note	This function can be used only when DMA is in SG mode
 *
 *****************************************************************************/
void XAxiDma_BdRingDumpRegs(XAxiDma_BdRing *RingPtr) {
c000f994:	fd010113          	addi	sp,sp,-48
c000f998:	02112623          	sw	ra,44(sp)
c000f99c:	02812423          	sw	s0,40(sp)
c000f9a0:	03010413          	addi	s0,sp,48
c000f9a4:	fca42e23          	sw	a0,-36(s0)
	UINTPTR RegBase = RingPtr->ChanBase;
c000f9a8:	fdc42783          	lw	a5,-36(s0)
c000f9ac:	0007a783          	lw	a5,0(a5)
c000f9b0:	fef42623          	sw	a5,-20(s0)
	int RingIndex = RingPtr->RingIndex;
c000f9b4:	fdc42783          	lw	a5,-36(s0)
c000f9b8:	0647a783          	lw	a5,100(a5)
c000f9bc:	fef42423          	sw	a5,-24(s0)

	printf("Dump registers %p:\r\n", (void *)RegBase);
c000f9c0:	fec42783          	lw	a5,-20(s0)
c000f9c4:	00078593          	mv	a1,a5
c000f9c8:	07ff1517          	auipc	a0,0x7ff1
c000f9cc:	14850513          	addi	a0,a0,328 # c8000b10 <__rodata_start+0xb10>
c000f9d0:	3d40e0ef          	jal	ra,c001dda4 <printf>
	printf("Control REG: %08x\r\n",
		(unsigned int)XAxiDma_ReadReg(RegBase, XAXIDMA_CR_OFFSET));
c000f9d4:	fec42503          	lw	a0,-20(s0)
c000f9d8:	ae0fe0ef          	jal	ra,c000dcb8 <Xil_In32>
c000f9dc:	00050793          	mv	a5,a0
	printf("Control REG: %08x\r\n",
c000f9e0:	00078593          	mv	a1,a5
c000f9e4:	07ff1517          	auipc	a0,0x7ff1
c000f9e8:	14450513          	addi	a0,a0,324 # c8000b28 <__rodata_start+0xb28>
c000f9ec:	3b80e0ef          	jal	ra,c001dda4 <printf>
	printf("Status REG: %08x\r\n",
		(unsigned int)XAxiDma_ReadReg(RegBase, XAXIDMA_SR_OFFSET));
c000f9f0:	fec42783          	lw	a5,-20(s0)
c000f9f4:	00478793          	addi	a5,a5,4
c000f9f8:	00078513          	mv	a0,a5
c000f9fc:	abcfe0ef          	jal	ra,c000dcb8 <Xil_In32>
c000fa00:	00050793          	mv	a5,a0
	printf("Status REG: %08x\r\n",
c000fa04:	00078593          	mv	a1,a5
c000fa08:	07ff1517          	auipc	a0,0x7ff1
c000fa0c:	13450513          	addi	a0,a0,308 # c8000b3c <__rodata_start+0xb3c>
c000fa10:	3940e0ef          	jal	ra,c001dda4 <printf>

	if (RingIndex) {
c000fa14:	fe842783          	lw	a5,-24(s0)
c000fa18:	06078a63          	beqz	a5,c000fa8c <XAxiDma_BdRingDumpRegs+0xf8>
	printf("Cur BD REG: %08x\r\n",
		(unsigned int)XAxiDma_ReadReg(RegBase,
c000fa1c:	fe842783          	lw	a5,-24(s0)
c000fa20:	00178793          	addi	a5,a5,1
c000fa24:	00579793          	slli	a5,a5,0x5
c000fa28:	00078713          	mv	a4,a5
c000fa2c:	fec42783          	lw	a5,-20(s0)
c000fa30:	00f707b3          	add	a5,a4,a5
c000fa34:	00078513          	mv	a0,a5
c000fa38:	a80fe0ef          	jal	ra,c000dcb8 <Xil_In32>
c000fa3c:	00050793          	mv	a5,a0
	printf("Cur BD REG: %08x\r\n",
c000fa40:	00078593          	mv	a1,a5
c000fa44:	07ff1517          	auipc	a0,0x7ff1
c000fa48:	10c50513          	addi	a0,a0,268 # c8000b50 <__rodata_start+0xb50>
c000fa4c:	3580e0ef          	jal	ra,c001dda4 <printf>
		XAXIDMA_RX_CDESC0_OFFSET + ((RingIndex - 1) *
		XAXIDMA_RX_NDESC_OFFSET)));
	printf("Tail BD REG: %08x\r\n",
		(unsigned int)XAxiDma_ReadReg(RegBase,
c000fa50:	fe842783          	lw	a5,-24(s0)
c000fa54:	fff78793          	addi	a5,a5,-1
c000fa58:	00579793          	slli	a5,a5,0x5
c000fa5c:	00078713          	mv	a4,a5
c000fa60:	fec42783          	lw	a5,-20(s0)
c000fa64:	00f707b3          	add	a5,a4,a5
c000fa68:	04878793          	addi	a5,a5,72
c000fa6c:	00078513          	mv	a0,a5
c000fa70:	a48fe0ef          	jal	ra,c000dcb8 <Xil_In32>
c000fa74:	00050793          	mv	a5,a0
	printf("Tail BD REG: %08x\r\n",
c000fa78:	00078593          	mv	a1,a5
c000fa7c:	07ff1517          	auipc	a0,0x7ff1
c000fa80:	0e850513          	addi	a0,a0,232 # c8000b64 <__rodata_start+0xb64>
c000fa84:	3200e0ef          	jal	ra,c001dda4 <printf>
c000fa88:	04c0006f          	j	c000fad4 <XAxiDma_BdRingDumpRegs+0x140>
		XAXIDMA_RX_TDESC0_OFFSET + ((RingIndex - 1) *
		XAXIDMA_RX_NDESC_OFFSET)));
	}
	else {
	printf("Cur BD REG: %08x\r\n",
		(unsigned int)XAxiDma_ReadReg(RegBase, XAXIDMA_CDESC_OFFSET));
c000fa8c:	fec42783          	lw	a5,-20(s0)
c000fa90:	00878793          	addi	a5,a5,8
c000fa94:	00078513          	mv	a0,a5
c000fa98:	a20fe0ef          	jal	ra,c000dcb8 <Xil_In32>
c000fa9c:	00050793          	mv	a5,a0
	printf("Cur BD REG: %08x\r\n",
c000faa0:	00078593          	mv	a1,a5
c000faa4:	07ff1517          	auipc	a0,0x7ff1
c000faa8:	0ac50513          	addi	a0,a0,172 # c8000b50 <__rodata_start+0xb50>
c000faac:	2f80e0ef          	jal	ra,c001dda4 <printf>
	printf("Tail BD REG: %08x\r\n",
		(unsigned int)XAxiDma_ReadReg(RegBase, XAXIDMA_TDESC_OFFSET));
c000fab0:	fec42783          	lw	a5,-20(s0)
c000fab4:	01078793          	addi	a5,a5,16
c000fab8:	00078513          	mv	a0,a5
c000fabc:	9fcfe0ef          	jal	ra,c000dcb8 <Xil_In32>
c000fac0:	00050793          	mv	a5,a0
	printf("Tail BD REG: %08x\r\n",
c000fac4:	00078593          	mv	a1,a5
c000fac8:	07ff1517          	auipc	a0,0x7ff1
c000facc:	09c50513          	addi	a0,a0,156 # c8000b64 <__rodata_start+0xb64>
c000fad0:	2d40e0ef          	jal	ra,c001dda4 <printf>
	}

	printf("\r\n");
c000fad4:	07ff1517          	auipc	a0,0x7ff1
c000fad8:	0a450513          	addi	a0,a0,164 # c8000b78 <__rodata_start+0xb78>
c000fadc:	3e40e0ef          	jal	ra,c001dec0 <puts>
}
c000fae0:	00000013          	nop
c000fae4:	02c12083          	lw	ra,44(sp)
c000fae8:	02812403          	lw	s0,40(sp)
c000faec:	03010113          	addi	sp,sp,48
c000faf0:	00008067          	ret

c000faf4 <Xil_In32>:
{
c000faf4:	fe010113          	addi	sp,sp,-32
c000faf8:	00812e23          	sw	s0,28(sp)
c000fafc:	02010413          	addi	s0,sp,32
c000fb00:	fea42623          	sw	a0,-20(s0)
	return *(volatile u32 *) Addr;
c000fb04:	fec42783          	lw	a5,-20(s0)
c000fb08:	0007a783          	lw	a5,0(a5)
}
c000fb0c:	00078513          	mv	a0,a5
c000fb10:	01c12403          	lw	s0,28(sp)
c000fb14:	02010113          	addi	sp,sp,32
c000fb18:	00008067          	ret

c000fb1c <Xil_Out32>:
{
c000fb1c:	fd010113          	addi	sp,sp,-48
c000fb20:	02812623          	sw	s0,44(sp)
c000fb24:	03010413          	addi	s0,sp,48
c000fb28:	fca42e23          	sw	a0,-36(s0)
c000fb2c:	fcb42c23          	sw	a1,-40(s0)
	volatile u32 *LocalAddr = (volatile u32 *)Addr;
c000fb30:	fdc42783          	lw	a5,-36(s0)
c000fb34:	fef42623          	sw	a5,-20(s0)
	*LocalAddr = Value;
c000fb38:	fec42783          	lw	a5,-20(s0)
c000fb3c:	fd842703          	lw	a4,-40(s0)
c000fb40:	00e7a023          	sw	a4,0(a5)
}
c000fb44:	00000013          	nop
c000fb48:	02c12403          	lw	s0,44(sp)
c000fb4c:	03010113          	addi	sp,sp,48
c000fb50:	00008067          	ret

c000fb54 <XAxiDma_CfgInitialize>:
 *
 * @note	We assume the hardware building tool will check and error out
 *		for a hardware build that has no transfer channels.
 *****************************************************************************/
int XAxiDma_CfgInitialize(XAxiDma * InstancePtr, XAxiDma_Config *Config)
{
c000fb54:	fd010113          	addi	sp,sp,-48
c000fb58:	02112623          	sw	ra,44(sp)
c000fb5c:	02812423          	sw	s0,40(sp)
c000fb60:	03010413          	addi	s0,sp,48
c000fb64:	fca42e23          	sw	a0,-36(s0)
c000fb68:	fcb42c23          	sw	a1,-40(s0)
	UINTPTR BaseAddr;
	int TimeOut;
	int Index;
	u32 MaxTransferLen;

	InstancePtr->Initialized = 0;
c000fb6c:	fdc42783          	lw	a5,-36(s0)
c000fb70:	0007a623          	sw	zero,12(a5)

	if(!Config) {
c000fb74:	fd842783          	lw	a5,-40(s0)
c000fb78:	00079663          	bnez	a5,c000fb84 <XAxiDma_CfgInitialize+0x30>
		return XST_INVALID_PARAM;
c000fb7c:	00f00793          	li	a5,15
c000fb80:	4540006f          	j	c000ffd4 <XAxiDma_CfgInitialize+0x480>
	}

	BaseAddr = Config->BaseAddr;
c000fb84:	fd842783          	lw	a5,-40(s0)
c000fb88:	0047a783          	lw	a5,4(a5)
c000fb8c:	fef42023          	sw	a5,-32(s0)

	/* Setup the instance */
	memset(InstancePtr, 0, sizeof(XAxiDma));
c000fb90:	75000613          	li	a2,1872
c000fb94:	00000593          	li	a1,0
c000fb98:	fdc42503          	lw	a0,-36(s0)
c000fb9c:	0ec0e0ef          	jal	ra,c001dc88 <memset>
	InstancePtr->RegBase = BaseAddr;
c000fba0:	fdc42783          	lw	a5,-36(s0)
c000fba4:	fe042703          	lw	a4,-32(s0)
c000fba8:	00e7a023          	sw	a4,0(a5)

	/* Get hardware setting information from the configuration structure
	 */
	InstancePtr->HasMm2S = Config->HasMm2S;
c000fbac:	fd842783          	lw	a5,-40(s0)
c000fbb0:	00c7a703          	lw	a4,12(a5)
c000fbb4:	fdc42783          	lw	a5,-36(s0)
c000fbb8:	00e7a223          	sw	a4,4(a5)
	InstancePtr->HasS2Mm = Config->HasS2Mm;
c000fbbc:	fd842783          	lw	a5,-40(s0)
c000fbc0:	0187a703          	lw	a4,24(a5)
c000fbc4:	fdc42783          	lw	a5,-36(s0)
c000fbc8:	00e7a423          	sw	a4,8(a5)

	InstancePtr->HasSg = Config->HasSg;
c000fbcc:	fd842783          	lw	a5,-40(s0)
c000fbd0:	0247a703          	lw	a4,36(a5)
c000fbd4:	fdc42783          	lw	a5,-36(s0)
c000fbd8:	00e7a823          	sw	a4,16(a5)

	InstancePtr->MicroDmaMode = Config->MicroDmaMode;
c000fbdc:	fd842783          	lw	a5,-40(s0)
c000fbe0:	0387a703          	lw	a4,56(a5)
c000fbe4:	fdc42783          	lw	a5,-36(s0)
c000fbe8:	74e7a423          	sw	a4,1864(a5)
	InstancePtr->AddrWidth = Config->AddrWidth;
c000fbec:	fd842783          	lw	a5,-40(s0)
c000fbf0:	03c7a703          	lw	a4,60(a5)
c000fbf4:	fdc42783          	lw	a5,-36(s0)
c000fbf8:	74e7a623          	sw	a4,1868(a5)

	/* Get the number of channels */
	InstancePtr->TxNumChannels = Config->Mm2sNumChannels;
c000fbfc:	fd842783          	lw	a5,-40(s0)
c000fc00:	0287a703          	lw	a4,40(a5)
c000fc04:	fdc42783          	lw	a5,-36(s0)
c000fc08:	74e7a023          	sw	a4,1856(a5)
	InstancePtr->RxNumChannels = Config->S2MmNumChannels;
c000fc0c:	fd842783          	lw	a5,-40(s0)
c000fc10:	02c7a703          	lw	a4,44(a5)
c000fc14:	fdc42783          	lw	a5,-36(s0)
c000fc18:	74e7a223          	sw	a4,1860(a5)

	/* This condition is for IP version < 6.00a */
	if (!InstancePtr->TxNumChannels)
c000fc1c:	fdc42783          	lw	a5,-36(s0)
c000fc20:	7407a783          	lw	a5,1856(a5)
c000fc24:	00079863          	bnez	a5,c000fc34 <XAxiDma_CfgInitialize+0xe0>
		InstancePtr->TxNumChannels = 1;
c000fc28:	fdc42783          	lw	a5,-36(s0)
c000fc2c:	00100713          	li	a4,1
c000fc30:	74e7a023          	sw	a4,1856(a5)
	if (!InstancePtr->RxNumChannels)
c000fc34:	fdc42783          	lw	a5,-36(s0)
c000fc38:	7447a783          	lw	a5,1860(a5)
c000fc3c:	00079863          	bnez	a5,c000fc4c <XAxiDma_CfgInitialize+0xf8>
		InstancePtr->RxNumChannels = 1;
c000fc40:	fdc42783          	lw	a5,-36(s0)
c000fc44:	00100713          	li	a4,1
c000fc48:	74e7a223          	sw	a4,1860(a5)

	if ((InstancePtr->RxNumChannels > 1) ||
c000fc4c:	fdc42783          	lw	a5,-36(s0)
c000fc50:	7447a703          	lw	a4,1860(a5)
c000fc54:	00100793          	li	a5,1
c000fc58:	00e7ca63          	blt	a5,a4,c000fc6c <XAxiDma_CfgInitialize+0x118>
		(InstancePtr->TxNumChannels > 1)) {
c000fc5c:	fdc42783          	lw	a5,-36(s0)
c000fc60:	7407a703          	lw	a4,1856(a5)
	if ((InstancePtr->RxNumChannels > 1) ||
c000fc64:	00100793          	li	a5,1
c000fc68:	00e7da63          	bge	a5,a4,c000fc7c <XAxiDma_CfgInitialize+0x128>
		MaxTransferLen =
c000fc6c:	000107b7          	lui	a5,0x10
c000fc70:	fff78793          	addi	a5,a5,-1 # ffff <_STACK_SIZE+0xefff>
c000fc74:	fef42223          	sw	a5,-28(s0)
c000fc78:	01c0006f          	j	c000fc94 <XAxiDma_CfgInitialize+0x140>
			XAXIDMA_MCHAN_MAX_TRANSFER_LEN;
	}
	else {
		MaxTransferLen = (1U << Config->SgLengthWidth) - 1;
c000fc7c:	fd842783          	lw	a5,-40(s0)
c000fc80:	0407a783          	lw	a5,64(a5)
c000fc84:	00100713          	li	a4,1
c000fc88:	00f717b3          	sll	a5,a4,a5
c000fc8c:	fff78793          	addi	a5,a5,-1
c000fc90:	fef42223          	sw	a5,-28(s0)
	}

	/* Initialize the ring structures */
	InstancePtr->TxBdRing.RunState = AXIDMA_CHANNEL_HALTED;
c000fc94:	fdc42783          	lw	a5,-36(s0)
c000fc98:	00200713          	li	a4,2
c000fc9c:	00e7ae23          	sw	a4,28(a5)
	InstancePtr->TxBdRing.IsRxChannel = 0;
c000fca0:	fdc42783          	lw	a5,-36(s0)
c000fca4:	0007ac23          	sw	zero,24(a5)
	if (!InstancePtr->MicroDmaMode) {
c000fca8:	fdc42783          	lw	a5,-36(s0)
c000fcac:	7487a783          	lw	a5,1864(a5)
c000fcb0:	00079a63          	bnez	a5,c000fcc4 <XAxiDma_CfgInitialize+0x170>
		InstancePtr->TxBdRing.MaxTransferLen = MaxTransferLen;
c000fcb4:	fdc42783          	lw	a5,-36(s0)
c000fcb8:	fe442703          	lw	a4,-28(s0)
c000fcbc:	02e7a823          	sw	a4,48(a5)
c000fcc0:	0380006f          	j	c000fcf8 <XAxiDma_CfgInitialize+0x1a4>
	else {
		/* In MicroDMA mode, Maximum length that can be transferred
		 * is '(Memory Data Width / 4) * Burst Size'
		 */
		InstancePtr->TxBdRing.MaxTransferLen =
				((Config->Mm2SDataWidth / 4) *
c000fcc4:	fd842783          	lw	a5,-40(s0)
c000fcc8:	0147a783          	lw	a5,20(a5)
c000fccc:	41f7d713          	srai	a4,a5,0x1f
c000fcd0:	00377713          	andi	a4,a4,3
c000fcd4:	00f707b3          	add	a5,a4,a5
c000fcd8:	4027d793          	srai	a5,a5,0x2
c000fcdc:	00078713          	mv	a4,a5
				 Config->Mm2SBurstSize);
c000fce0:	fd842783          	lw	a5,-40(s0)
c000fce4:	0307a783          	lw	a5,48(a5)
				((Config->Mm2SDataWidth / 4) *
c000fce8:	02f707b3          	mul	a5,a4,a5
c000fcec:	00078713          	mv	a4,a5
		InstancePtr->TxBdRing.MaxTransferLen =
c000fcf0:	fdc42783          	lw	a5,-36(s0)
c000fcf4:	02e7a823          	sw	a4,48(a5)
	}
	InstancePtr->TxBdRing.RingIndex = 0;
c000fcf8:	fdc42783          	lw	a5,-36(s0)
c000fcfc:	0607ac23          	sw	zero,120(a5)

	for (Index = 0; Index < InstancePtr->RxNumChannels; Index++) {
c000fd00:	fe042423          	sw	zero,-24(s0)
c000fd04:	0640006f          	j	c000fd68 <XAxiDma_CfgInitialize+0x214>
		InstancePtr->RxBdRing[Index].RunState
						 = AXIDMA_CHANNEL_HALTED;
c000fd08:	fdc42703          	lw	a4,-36(s0)
c000fd0c:	fe842683          	lw	a3,-24(s0)
c000fd10:	06c00793          	li	a5,108
c000fd14:	02f687b3          	mul	a5,a3,a5
c000fd18:	00f707b3          	add	a5,a4,a5
c000fd1c:	00200713          	li	a4,2
c000fd20:	08e7a423          	sw	a4,136(a5)
		InstancePtr->RxBdRing[Index].IsRxChannel = 1;
c000fd24:	fdc42703          	lw	a4,-36(s0)
c000fd28:	fe842683          	lw	a3,-24(s0)
c000fd2c:	06c00793          	li	a5,108
c000fd30:	02f687b3          	mul	a5,a3,a5
c000fd34:	00f707b3          	add	a5,a4,a5
c000fd38:	00100713          	li	a4,1
c000fd3c:	08e7a223          	sw	a4,132(a5)
		InstancePtr->RxBdRing[Index].RingIndex = Index;
c000fd40:	fdc42703          	lw	a4,-36(s0)
c000fd44:	fe842683          	lw	a3,-24(s0)
c000fd48:	06c00793          	li	a5,108
c000fd4c:	02f687b3          	mul	a5,a3,a5
c000fd50:	00f707b3          	add	a5,a4,a5
c000fd54:	fe842703          	lw	a4,-24(s0)
c000fd58:	0ee7a223          	sw	a4,228(a5)
	for (Index = 0; Index < InstancePtr->RxNumChannels; Index++) {
c000fd5c:	fe842783          	lw	a5,-24(s0)
c000fd60:	00178793          	addi	a5,a5,1
c000fd64:	fef42423          	sw	a5,-24(s0)
c000fd68:	fdc42783          	lw	a5,-36(s0)
c000fd6c:	7447a783          	lw	a5,1860(a5)
c000fd70:	fe842703          	lw	a4,-24(s0)
c000fd74:	f8f74ae3          	blt	a4,a5,c000fd08 <XAxiDma_CfgInitialize+0x1b4>
	}

	if (InstancePtr->HasMm2S) {
c000fd78:	fdc42783          	lw	a5,-36(s0)
c000fd7c:	0047a783          	lw	a5,4(a5)
c000fd80:	06078863          	beqz	a5,c000fdf0 <XAxiDma_CfgInitialize+0x29c>
		InstancePtr->TxBdRing.ChanBase =
c000fd84:	fdc42783          	lw	a5,-36(s0)
c000fd88:	fe042703          	lw	a4,-32(s0)
c000fd8c:	00e7aa23          	sw	a4,20(a5)
				BaseAddr + XAXIDMA_TX_OFFSET;
		InstancePtr->TxBdRing.HasStsCntrlStrm =
					Config->HasStsCntrlStrm;
c000fd90:	fd842783          	lw	a5,-40(s0)
c000fd94:	0087a703          	lw	a4,8(a5)
		InstancePtr->TxBdRing.HasStsCntrlStrm =
c000fd98:	fdc42783          	lw	a5,-36(s0)
c000fd9c:	02e7a023          	sw	a4,32(a5)
		if (InstancePtr->AddrWidth > 32)
c000fda0:	fdc42783          	lw	a5,-36(s0)
c000fda4:	74c7a703          	lw	a4,1868(a5)
c000fda8:	02000793          	li	a5,32
c000fdac:	00e7da63          	bge	a5,a4,c000fdc0 <XAxiDma_CfgInitialize+0x26c>
			InstancePtr->TxBdRing.Addr_ext = 1;
c000fdb0:	fdc42783          	lw	a5,-36(s0)
c000fdb4:	00100713          	li	a4,1
c000fdb8:	02e7a623          	sw	a4,44(a5)
c000fdbc:	00c0006f          	j	c000fdc8 <XAxiDma_CfgInitialize+0x274>
		else
			InstancePtr->TxBdRing.Addr_ext = 0;
c000fdc0:	fdc42783          	lw	a5,-36(s0)
c000fdc4:	0207a623          	sw	zero,44(a5)

		InstancePtr->TxBdRing.HasDRE = Config->HasMm2SDRE;
c000fdc8:	fd842783          	lw	a5,-40(s0)
c000fdcc:	0107a703          	lw	a4,16(a5)
c000fdd0:	fdc42783          	lw	a5,-36(s0)
c000fdd4:	02e7a223          	sw	a4,36(a5)
		InstancePtr->TxBdRing.DataWidth =
			((unsigned int)Config->Mm2SDataWidth >> 3);
c000fdd8:	fd842783          	lw	a5,-40(s0)
c000fddc:	0147a783          	lw	a5,20(a5)
c000fde0:	0037d793          	srli	a5,a5,0x3
c000fde4:	00078713          	mv	a4,a5
		InstancePtr->TxBdRing.DataWidth =
c000fde8:	fdc42783          	lw	a5,-36(s0)
c000fdec:	02e7a423          	sw	a4,40(a5)
	}

	if (InstancePtr->HasS2Mm) {
c000fdf0:	fdc42783          	lw	a5,-36(s0)
c000fdf4:	0087a783          	lw	a5,8(a5)
c000fdf8:	16078463          	beqz	a5,c000ff60 <XAxiDma_CfgInitialize+0x40c>
		for (Index = 0;
c000fdfc:	fe042423          	sw	zero,-24(s0)
c000fe00:	1500006f          	j	c000ff50 <XAxiDma_CfgInitialize+0x3fc>
			Index < InstancePtr->RxNumChannels; Index++) {
			InstancePtr->RxBdRing[Index].ChanBase =
					BaseAddr + XAXIDMA_RX_OFFSET;
c000fe04:	fe042783          	lw	a5,-32(s0)
c000fe08:	03078713          	addi	a4,a5,48
			InstancePtr->RxBdRing[Index].ChanBase =
c000fe0c:	fdc42683          	lw	a3,-36(s0)
c000fe10:	fe842603          	lw	a2,-24(s0)
c000fe14:	06c00793          	li	a5,108
c000fe18:	02f607b3          	mul	a5,a2,a5
c000fe1c:	00f687b3          	add	a5,a3,a5
c000fe20:	08e7a023          	sw	a4,128(a5)
			InstancePtr->RxBdRing[Index].HasStsCntrlStrm =
					Config->HasStsCntrlStrm;
c000fe24:	fd842783          	lw	a5,-40(s0)
c000fe28:	0087a703          	lw	a4,8(a5)
			InstancePtr->RxBdRing[Index].HasStsCntrlStrm =
c000fe2c:	fdc42683          	lw	a3,-36(s0)
c000fe30:	fe842603          	lw	a2,-24(s0)
c000fe34:	06c00793          	li	a5,108
c000fe38:	02f607b3          	mul	a5,a2,a5
c000fe3c:	00f687b3          	add	a5,a3,a5
c000fe40:	08e7a623          	sw	a4,140(a5)
			InstancePtr->RxBdRing[Index].HasDRE =
					Config->HasS2MmDRE;
c000fe44:	fd842783          	lw	a5,-40(s0)
c000fe48:	01c7a703          	lw	a4,28(a5)
			InstancePtr->RxBdRing[Index].HasDRE =
c000fe4c:	fdc42683          	lw	a3,-36(s0)
c000fe50:	fe842603          	lw	a2,-24(s0)
c000fe54:	06c00793          	li	a5,108
c000fe58:	02f607b3          	mul	a5,a2,a5
c000fe5c:	00f687b3          	add	a5,a3,a5
c000fe60:	08e7a823          	sw	a4,144(a5)
			InstancePtr->RxBdRing[Index].DataWidth =
			((unsigned int)Config->S2MmDataWidth >> 3);
c000fe64:	fd842783          	lw	a5,-40(s0)
c000fe68:	0207a783          	lw	a5,32(a5)
c000fe6c:	0037d793          	srli	a5,a5,0x3
c000fe70:	00078613          	mv	a2,a5
			InstancePtr->RxBdRing[Index].DataWidth =
c000fe74:	fdc42703          	lw	a4,-36(s0)
c000fe78:	fe842683          	lw	a3,-24(s0)
c000fe7c:	06c00793          	li	a5,108
c000fe80:	02f687b3          	mul	a5,a3,a5
c000fe84:	00f707b3          	add	a5,a4,a5
c000fe88:	08c7aa23          	sw	a2,148(a5)

			if (!InstancePtr->MicroDmaMode) {
c000fe8c:	fdc42783          	lw	a5,-36(s0)
c000fe90:	7487a783          	lw	a5,1864(a5)
c000fe94:	02079263          	bnez	a5,c000feb8 <XAxiDma_CfgInitialize+0x364>
				InstancePtr->RxBdRing[Index].MaxTransferLen =
c000fe98:	fdc42703          	lw	a4,-36(s0)
c000fe9c:	fe842683          	lw	a3,-24(s0)
c000fea0:	06c00793          	li	a5,108
c000fea4:	02f687b3          	mul	a5,a3,a5
c000fea8:	00f707b3          	add	a5,a4,a5
c000feac:	fe442703          	lw	a4,-28(s0)
c000feb0:	08e7ae23          	sw	a4,156(a5)
c000feb4:	0480006f          	j	c000fefc <XAxiDma_CfgInitialize+0x3a8>
			else {
			/* In MicroDMA mode, Maximum length that can be transferred
			 * is '(Memory Data Width / 4) * Burst Size'
			 */
				InstancePtr->RxBdRing[Index].MaxTransferLen =
						((Config->S2MmDataWidth / 4) *
c000feb8:	fd842783          	lw	a5,-40(s0)
c000febc:	0207a783          	lw	a5,32(a5)
c000fec0:	41f7d713          	srai	a4,a5,0x1f
c000fec4:	00377713          	andi	a4,a4,3
c000fec8:	00f707b3          	add	a5,a4,a5
c000fecc:	4027d793          	srai	a5,a5,0x2
c000fed0:	00078713          	mv	a4,a5
						Config->S2MmBurstSize);
c000fed4:	fd842783          	lw	a5,-40(s0)
c000fed8:	0347a783          	lw	a5,52(a5)
						((Config->S2MmDataWidth / 4) *
c000fedc:	02f707b3          	mul	a5,a4,a5
c000fee0:	00078613          	mv	a2,a5
				InstancePtr->RxBdRing[Index].MaxTransferLen =
c000fee4:	fdc42703          	lw	a4,-36(s0)
c000fee8:	fe842683          	lw	a3,-24(s0)
c000feec:	06c00793          	li	a5,108
c000fef0:	02f687b3          	mul	a5,a3,a5
c000fef4:	00f707b3          	add	a5,a4,a5
c000fef8:	08c7ae23          	sw	a2,156(a5)
			}
			if (InstancePtr->AddrWidth > 32)
c000fefc:	fdc42783          	lw	a5,-36(s0)
c000ff00:	74c7a703          	lw	a4,1868(a5)
c000ff04:	02000793          	li	a5,32
c000ff08:	02e7d263          	bge	a5,a4,c000ff2c <XAxiDma_CfgInitialize+0x3d8>
				InstancePtr->RxBdRing[Index].Addr_ext = 1;
c000ff0c:	fdc42703          	lw	a4,-36(s0)
c000ff10:	fe842683          	lw	a3,-24(s0)
c000ff14:	06c00793          	li	a5,108
c000ff18:	02f687b3          	mul	a5,a3,a5
c000ff1c:	00f707b3          	add	a5,a4,a5
c000ff20:	00100713          	li	a4,1
c000ff24:	08e7ac23          	sw	a4,152(a5)
c000ff28:	01c0006f          	j	c000ff44 <XAxiDma_CfgInitialize+0x3f0>
			else
				InstancePtr->RxBdRing[Index].Addr_ext = 0;
c000ff2c:	fdc42703          	lw	a4,-36(s0)
c000ff30:	fe842683          	lw	a3,-24(s0)
c000ff34:	06c00793          	li	a5,108
c000ff38:	02f687b3          	mul	a5,a3,a5
c000ff3c:	00f707b3          	add	a5,a4,a5
c000ff40:	0807ac23          	sw	zero,152(a5)
			Index < InstancePtr->RxNumChannels; Index++) {
c000ff44:	fe842783          	lw	a5,-24(s0)
c000ff48:	00178793          	addi	a5,a5,1
c000ff4c:	fef42423          	sw	a5,-24(s0)
c000ff50:	fdc42783          	lw	a5,-36(s0)
c000ff54:	7447a783          	lw	a5,1860(a5)
		for (Index = 0;
c000ff58:	fe842703          	lw	a4,-24(s0)
c000ff5c:	eaf744e3          	blt	a4,a5,c000fe04 <XAxiDma_CfgInitialize+0x2b0>
		}
	}

	/* Reset the engine so the hardware starts from a known state
	 */
	XAxiDma_Reset(InstancePtr);
c000ff60:	fdc42503          	lw	a0,-36(s0)
c000ff64:	084000ef          	jal	ra,c000ffe8 <XAxiDma_Reset>

	/* At the initialization time, hardware should finish reset quickly
	 */
	TimeOut = XAXIDMA_RESET_TIMEOUT;
c000ff68:	1f400793          	li	a5,500
c000ff6c:	fef42623          	sw	a5,-20(s0)

	while (TimeOut) {
c000ff70:	0200006f          	j	c000ff90 <XAxiDma_CfgInitialize+0x43c>

		if(XAxiDma_ResetIsDone(InstancePtr)) {
c000ff74:	fdc42503          	lw	a0,-36(s0)
c000ff78:	2f4000ef          	jal	ra,c001026c <XAxiDma_ResetIsDone>
c000ff7c:	00050793          	mv	a5,a0
c000ff80:	00079e63          	bnez	a5,c000ff9c <XAxiDma_CfgInitialize+0x448>
			break;
		}

		TimeOut -= 1;
c000ff84:	fec42783          	lw	a5,-20(s0)
c000ff88:	fff78793          	addi	a5,a5,-1
c000ff8c:	fef42623          	sw	a5,-20(s0)
	while (TimeOut) {
c000ff90:	fec42783          	lw	a5,-20(s0)
c000ff94:	fe0790e3          	bnez	a5,c000ff74 <XAxiDma_CfgInitialize+0x420>
c000ff98:	0080006f          	j	c000ffa0 <XAxiDma_CfgInitialize+0x44c>
			break;
c000ff9c:	00000013          	nop

	}

	if (!TimeOut) {
c000ffa0:	fec42783          	lw	a5,-20(s0)
c000ffa4:	02079063          	bnez	a5,c000ffc4 <XAxiDma_CfgInitialize+0x470>
		printf("Failed reset in"
c000ffa8:	07ff1517          	auipc	a0,0x7ff1
c000ffac:	bd450513          	addi	a0,a0,-1068 # c8000b7c <__rodata_start+0xb7c>
c000ffb0:	7110d0ef          	jal	ra,c001dec0 <puts>
							"initialize\r\n");

		/* Need system hard reset to recover
		 */
		InstancePtr->Initialized = 0;
c000ffb4:	fdc42783          	lw	a5,-36(s0)
c000ffb8:	0007a623          	sw	zero,12(a5)
		return XST_DMA_ERROR;
c000ffbc:	00900793          	li	a5,9
c000ffc0:	0140006f          	j	c000ffd4 <XAxiDma_CfgInitialize+0x480>
	}

	/* Initialization is successful
	 */
	InstancePtr->Initialized = 1;
c000ffc4:	fdc42783          	lw	a5,-36(s0)
c000ffc8:	00100713          	li	a4,1
c000ffcc:	00e7a623          	sw	a4,12(a5)

	return XST_SUCCESS;
c000ffd0:	00000793          	li	a5,0
}
c000ffd4:	00078513          	mv	a0,a5
c000ffd8:	02c12083          	lw	ra,44(sp)
c000ffdc:	02812403          	lw	s0,40(sp)
c000ffe0:	03010113          	addi	sp,sp,48
c000ffe4:	00008067          	ret

c000ffe8 <XAxiDma_Reset>:
*		- All interrupts are disabled.
*		- Engine is halted
*
******************************************************************************/
void XAxiDma_Reset(XAxiDma * InstancePtr)
{
c000ffe8:	fd010113          	addi	sp,sp,-48
c000ffec:	02112623          	sw	ra,44(sp)
c000fff0:	02812423          	sw	s0,40(sp)
c000fff4:	03010413          	addi	s0,sp,48
c000fff8:	fca42e23          	sw	a0,-36(s0)
	UINTPTR RegBase;
	XAxiDma_BdRing *TxRingPtr;
	XAxiDma_BdRing *RxRingPtr;
	int RingIndex;

	if (InstancePtr->HasMm2S) {
c000fffc:	fdc42783          	lw	a5,-36(s0)
c0010000:	0047a783          	lw	a5,4(a5)
c0010004:	18078a63          	beqz	a5,c0010198 <XAxiDma_Reset+0x1b0>
		TxRingPtr = XAxiDma_GetTxRing(InstancePtr);
c0010008:	fdc42783          	lw	a5,-36(s0)
c001000c:	01478793          	addi	a5,a5,20
c0010010:	fef42223          	sw	a5,-28(s0)

		/* Save the locations of current BDs both rings are working on
		 * before the reset so later we can resume the rings smoothly.
		 */
		if(XAxiDma_HasSg(InstancePtr)){
c0010014:	fdc42783          	lw	a5,-36(s0)
c0010018:	0107a783          	lw	a5,16(a5)
c001001c:	16078e63          	beqz	a5,c0010198 <XAxiDma_Reset+0x1b0>
			XAxiDma_BdRingSnapShotCurrBd(TxRingPtr);
c0010020:	fe442783          	lw	a5,-28(s0)
c0010024:	0047a783          	lw	a5,4(a5)
c0010028:	02079663          	bnez	a5,c0010054 <XAxiDma_Reset+0x6c>
c001002c:	fe442783          	lw	a5,-28(s0)
c0010030:	0007a783          	lw	a5,0(a5)
c0010034:	00878793          	addi	a5,a5,8
c0010038:	00078513          	mv	a0,a5
c001003c:	ab9ff0ef          	jal	ra,c000faf4 <Xil_In32>
c0010040:	00050793          	mv	a5,a0
c0010044:	00078713          	mv	a4,a5
c0010048:	fe442783          	lw	a5,-28(s0)
c001004c:	04e7a423          	sw	a4,72(a5)
c0010050:	06c0006f          	j	c00100bc <XAxiDma_Reset+0xd4>
c0010054:	fe442783          	lw	a5,-28(s0)
c0010058:	0647a783          	lw	a5,100(a5)
c001005c:	02079663          	bnez	a5,c0010088 <XAxiDma_Reset+0xa0>
c0010060:	fe442783          	lw	a5,-28(s0)
c0010064:	0007a783          	lw	a5,0(a5)
c0010068:	00878793          	addi	a5,a5,8
c001006c:	00078513          	mv	a0,a5
c0010070:	a85ff0ef          	jal	ra,c000faf4 <Xil_In32>
c0010074:	00050793          	mv	a5,a0
c0010078:	00078713          	mv	a4,a5
c001007c:	fe442783          	lw	a5,-28(s0)
c0010080:	04e7a423          	sw	a4,72(a5)
c0010084:	0380006f          	j	c00100bc <XAxiDma_Reset+0xd4>
c0010088:	fe442783          	lw	a5,-28(s0)
c001008c:	0007a783          	lw	a5,0(a5)
c0010090:	fe442703          	lw	a4,-28(s0)
c0010094:	06472703          	lw	a4,100(a4)
c0010098:	00170713          	addi	a4,a4,1
c001009c:	00571713          	slli	a4,a4,0x5
c00100a0:	00e787b3          	add	a5,a5,a4
c00100a4:	00078513          	mv	a0,a5
c00100a8:	a4dff0ef          	jal	ra,c000faf4 <Xil_In32>
c00100ac:	00050793          	mv	a5,a0
c00100b0:	00078713          	mv	a4,a5
c00100b4:	fe442783          	lw	a5,-28(s0)
c00100b8:	04e7a423          	sw	a4,72(a5)

			for (RingIndex = 0; RingIndex < InstancePtr->RxNumChannels;
c00100bc:	fe042423          	sw	zero,-24(s0)
c00100c0:	0c80006f          	j	c0010188 <XAxiDma_Reset+0x1a0>
							RingIndex++) {
				RxRingPtr = XAxiDma_GetRxIndexRing(InstancePtr,
c00100c4:	fe842703          	lw	a4,-24(s0)
c00100c8:	06c00793          	li	a5,108
c00100cc:	02f707b3          	mul	a5,a4,a5
c00100d0:	08078793          	addi	a5,a5,128
c00100d4:	fdc42703          	lw	a4,-36(s0)
c00100d8:	00f707b3          	add	a5,a4,a5
c00100dc:	fef42023          	sw	a5,-32(s0)
							RingIndex);
				XAxiDma_BdRingSnapShotCurrBd(RxRingPtr);
c00100e0:	fe042783          	lw	a5,-32(s0)
c00100e4:	0047a783          	lw	a5,4(a5)
c00100e8:	02079663          	bnez	a5,c0010114 <XAxiDma_Reset+0x12c>
c00100ec:	fe042783          	lw	a5,-32(s0)
c00100f0:	0007a783          	lw	a5,0(a5)
c00100f4:	00878793          	addi	a5,a5,8
c00100f8:	00078513          	mv	a0,a5
c00100fc:	9f9ff0ef          	jal	ra,c000faf4 <Xil_In32>
c0010100:	00050793          	mv	a5,a0
c0010104:	00078713          	mv	a4,a5
c0010108:	fe042783          	lw	a5,-32(s0)
c001010c:	04e7a423          	sw	a4,72(a5)
c0010110:	06c0006f          	j	c001017c <XAxiDma_Reset+0x194>
c0010114:	fe042783          	lw	a5,-32(s0)
c0010118:	0647a783          	lw	a5,100(a5)
c001011c:	02079663          	bnez	a5,c0010148 <XAxiDma_Reset+0x160>
c0010120:	fe042783          	lw	a5,-32(s0)
c0010124:	0007a783          	lw	a5,0(a5)
c0010128:	00878793          	addi	a5,a5,8
c001012c:	00078513          	mv	a0,a5
c0010130:	9c5ff0ef          	jal	ra,c000faf4 <Xil_In32>
c0010134:	00050793          	mv	a5,a0
c0010138:	00078713          	mv	a4,a5
c001013c:	fe042783          	lw	a5,-32(s0)
c0010140:	04e7a423          	sw	a4,72(a5)
c0010144:	0380006f          	j	c001017c <XAxiDma_Reset+0x194>
c0010148:	fe042783          	lw	a5,-32(s0)
c001014c:	0007a783          	lw	a5,0(a5)
c0010150:	fe042703          	lw	a4,-32(s0)
c0010154:	06472703          	lw	a4,100(a4)
c0010158:	00170713          	addi	a4,a4,1
c001015c:	00571713          	slli	a4,a4,0x5
c0010160:	00e787b3          	add	a5,a5,a4
c0010164:	00078513          	mv	a0,a5
c0010168:	98dff0ef          	jal	ra,c000faf4 <Xil_In32>
c001016c:	00050793          	mv	a5,a0
c0010170:	00078713          	mv	a4,a5
c0010174:	fe042783          	lw	a5,-32(s0)
c0010178:	04e7a423          	sw	a4,72(a5)
							RingIndex++) {
c001017c:	fe842783          	lw	a5,-24(s0)
c0010180:	00178793          	addi	a5,a5,1
c0010184:	fef42423          	sw	a5,-24(s0)
			for (RingIndex = 0; RingIndex < InstancePtr->RxNumChannels;
c0010188:	fdc42783          	lw	a5,-36(s0)
c001018c:	7447a783          	lw	a5,1860(a5)
c0010190:	fe842703          	lw	a4,-24(s0)
c0010194:	f2f748e3          	blt	a4,a5,c00100c4 <XAxiDma_Reset+0xdc>
		}
	}

	/* Reset
	 */
	if (InstancePtr->HasMm2S) {
c0010198:	fdc42783          	lw	a5,-36(s0)
c001019c:	0047a783          	lw	a5,4(a5)
c00101a0:	00078a63          	beqz	a5,c00101b4 <XAxiDma_Reset+0x1cc>
		RegBase = InstancePtr->RegBase + XAXIDMA_TX_OFFSET;
c00101a4:	fdc42783          	lw	a5,-36(s0)
c00101a8:	0007a783          	lw	a5,0(a5)
c00101ac:	fef42623          	sw	a5,-20(s0)
c00101b0:	0140006f          	j	c00101c4 <XAxiDma_Reset+0x1dc>
	}
	else {
		RegBase = InstancePtr->RegBase + XAXIDMA_RX_OFFSET;
c00101b4:	fdc42783          	lw	a5,-36(s0)
c00101b8:	0007a783          	lw	a5,0(a5)
c00101bc:	03078793          	addi	a5,a5,48
c00101c0:	fef42623          	sw	a5,-20(s0)
	}

	XAxiDma_WriteReg(RegBase, XAXIDMA_CR_OFFSET, XAXIDMA_CR_RESET_MASK);
c00101c4:	00400593          	li	a1,4
c00101c8:	fec42503          	lw	a0,-20(s0)
c00101cc:	951ff0ef          	jal	ra,c000fb1c <Xil_Out32>

	/* Set TX/RX Channel state */
	if (InstancePtr->HasMm2S) {
c00101d0:	fdc42783          	lw	a5,-36(s0)
c00101d4:	0047a783          	lw	a5,4(a5)
c00101d8:	00078e63          	beqz	a5,c00101f4 <XAxiDma_Reset+0x20c>
		TxRingPtr = XAxiDma_GetTxRing(InstancePtr);
c00101dc:	fdc42783          	lw	a5,-36(s0)
c00101e0:	01478793          	addi	a5,a5,20
c00101e4:	fef42223          	sw	a5,-28(s0)

		TxRingPtr->RunState = AXIDMA_CHANNEL_HALTED;
c00101e8:	fe442783          	lw	a5,-28(s0)
c00101ec:	00200713          	li	a4,2
c00101f0:	00e7a423          	sw	a4,8(a5)
	}

	if (InstancePtr->HasS2Mm) {
c00101f4:	fdc42783          	lw	a5,-36(s0)
c00101f8:	0087a783          	lw	a5,8(a5)
c00101fc:	04078e63          	beqz	a5,c0010258 <XAxiDma_Reset+0x270>
		for (RingIndex = 0; RingIndex < InstancePtr->RxNumChannels;
c0010200:	fe042423          	sw	zero,-24(s0)
c0010204:	0440006f          	j	c0010248 <XAxiDma_Reset+0x260>
						RingIndex++) {
			RxRingPtr = XAxiDma_GetRxIndexRing(InstancePtr, RingIndex);
c0010208:	fe842703          	lw	a4,-24(s0)
c001020c:	06c00793          	li	a5,108
c0010210:	02f707b3          	mul	a5,a4,a5
c0010214:	08078793          	addi	a5,a5,128
c0010218:	fdc42703          	lw	a4,-36(s0)
c001021c:	00f707b3          	add	a5,a4,a5
c0010220:	fef42023          	sw	a5,-32(s0)
			if (InstancePtr->HasS2Mm) {
c0010224:	fdc42783          	lw	a5,-36(s0)
c0010228:	0087a783          	lw	a5,8(a5)
c001022c:	00078863          	beqz	a5,c001023c <XAxiDma_Reset+0x254>
				RxRingPtr->RunState = AXIDMA_CHANNEL_HALTED;
c0010230:	fe042783          	lw	a5,-32(s0)
c0010234:	00200713          	li	a4,2
c0010238:	00e7a423          	sw	a4,8(a5)
						RingIndex++) {
c001023c:	fe842783          	lw	a5,-24(s0)
c0010240:	00178793          	addi	a5,a5,1
c0010244:	fef42423          	sw	a5,-24(s0)
		for (RingIndex = 0; RingIndex < InstancePtr->RxNumChannels;
c0010248:	fdc42783          	lw	a5,-36(s0)
c001024c:	7447a783          	lw	a5,1860(a5)
c0010250:	fe842703          	lw	a4,-24(s0)
c0010254:	faf74ae3          	blt	a4,a5,c0010208 <XAxiDma_Reset+0x220>
			}
		}
	}
}
c0010258:	00000013          	nop
c001025c:	02c12083          	lw	ra,44(sp)
c0010260:	02812403          	lw	s0,40(sp)
c0010264:	03010113          	addi	sp,sp,48
c0010268:	00008067          	ret

c001026c <XAxiDma_ResetIsDone>:
*
* @note		None
*
******************************************************************************/
int XAxiDma_ResetIsDone(XAxiDma * InstancePtr)
{
c001026c:	fd010113          	addi	sp,sp,-48
c0010270:	02112623          	sw	ra,44(sp)
c0010274:	02812423          	sw	s0,40(sp)
c0010278:	03010413          	addi	s0,sp,48
c001027c:	fca42e23          	sw	a0,-36(s0)
	u32 RegisterValue;
	XAxiDma_BdRing *TxRingPtr;
	XAxiDma_BdRing *RxRingPtr;

	TxRingPtr = XAxiDma_GetTxRing(InstancePtr);
c0010280:	fdc42783          	lw	a5,-36(s0)
c0010284:	01478793          	addi	a5,a5,20
c0010288:	fef42623          	sw	a5,-20(s0)
	RxRingPtr = XAxiDma_GetRxRing(InstancePtr);
c001028c:	fdc42783          	lw	a5,-36(s0)
c0010290:	08078793          	addi	a5,a5,128
c0010294:	fef42423          	sw	a5,-24(s0)

	/* Check transmit channel
	 */
	if (InstancePtr->HasMm2S) {
c0010298:	fdc42783          	lw	a5,-36(s0)
c001029c:	0047a783          	lw	a5,4(a5)
c00102a0:	02078663          	beqz	a5,c00102cc <XAxiDma_ResetIsDone+0x60>
		RegisterValue = XAxiDma_ReadReg(TxRingPtr->ChanBase,
c00102a4:	fec42783          	lw	a5,-20(s0)
c00102a8:	0007a783          	lw	a5,0(a5)
c00102ac:	00078513          	mv	a0,a5
c00102b0:	845ff0ef          	jal	ra,c000faf4 <Xil_In32>
c00102b4:	fea42223          	sw	a0,-28(s0)
			XAXIDMA_CR_OFFSET);

		/* Reset is done when the reset bit is low
		 */
		if(RegisterValue & XAXIDMA_CR_RESET_MASK) {
c00102b8:	fe442783          	lw	a5,-28(s0)
c00102bc:	0047f793          	andi	a5,a5,4
c00102c0:	00078663          	beqz	a5,c00102cc <XAxiDma_ResetIsDone+0x60>

			return 0;
c00102c4:	00000793          	li	a5,0
c00102c8:	03c0006f          	j	c0010304 <XAxiDma_ResetIsDone+0x98>
		}
	}

	/* Check receive channel
	 */
	if (InstancePtr->HasS2Mm) {
c00102cc:	fdc42783          	lw	a5,-36(s0)
c00102d0:	0087a783          	lw	a5,8(a5)
c00102d4:	02078663          	beqz	a5,c0010300 <XAxiDma_ResetIsDone+0x94>
		RegisterValue = XAxiDma_ReadReg(RxRingPtr->ChanBase,
c00102d8:	fe842783          	lw	a5,-24(s0)
c00102dc:	0007a783          	lw	a5,0(a5)
c00102e0:	00078513          	mv	a0,a5
c00102e4:	811ff0ef          	jal	ra,c000faf4 <Xil_In32>
c00102e8:	fea42223          	sw	a0,-28(s0)
				XAXIDMA_CR_OFFSET);

		/* Reset is done when the reset bit is low
		 */
		if(RegisterValue & XAXIDMA_CR_RESET_MASK) {
c00102ec:	fe442783          	lw	a5,-28(s0)
c00102f0:	0047f793          	andi	a5,a5,4
c00102f4:	00078663          	beqz	a5,c0010300 <XAxiDma_ResetIsDone+0x94>

			return 0;
c00102f8:	00000793          	li	a5,0
c00102fc:	0080006f          	j	c0010304 <XAxiDma_ResetIsDone+0x98>
		}
	}

	return 1;
c0010300:	00100793          	li	a5,1
}
c0010304:	00078513          	mv	a0,a5
c0010308:	02c12083          	lw	ra,44(sp)
c001030c:	02812403          	lw	s0,40(sp)
c0010310:	03010113          	addi	sp,sp,48
c0010314:	00008067          	ret

c0010318 <XAxiDma_Start>:
*
* @note		None
*
*****************************************************************************/
static int XAxiDma_Start(XAxiDma * InstancePtr)
{
c0010318:	fd010113          	addi	sp,sp,-48
c001031c:	02112623          	sw	ra,44(sp)
c0010320:	02812423          	sw	s0,40(sp)
c0010324:	02912223          	sw	s1,36(sp)
c0010328:	03010413          	addi	s0,sp,48
c001032c:	fca42e23          	sw	a0,-36(s0)
	int Status;

	if (!InstancePtr->Initialized) {
c0010330:	fdc42783          	lw	a5,-36(s0)
c0010334:	00c7a783          	lw	a5,12(a5)
c0010338:	02079263          	bnez	a5,c001035c <XAxiDma_Start+0x44>

		printf("Start: Driver not initialized "
c001033c:	fdc42783          	lw	a5,-36(s0)
c0010340:	00c7a783          	lw	a5,12(a5)
c0010344:	00078593          	mv	a1,a5
c0010348:	07ff1517          	auipc	a0,0x7ff1
c001034c:	85050513          	addi	a0,a0,-1968 # c8000b98 <__rodata_start+0xb98>
c0010350:	2550d0ef          	jal	ra,c001dda4 <printf>
				"%d\r\n", InstancePtr->Initialized);

		return XST_NOT_SGDMA;
c0010354:	01000793          	li	a5,16
c0010358:	1780006f          	j	c00104d0 <XAxiDma_Start+0x1b8>
	}

	if (InstancePtr->HasMm2S) {
c001035c:	fdc42783          	lw	a5,-36(s0)
c0010360:	0047a783          	lw	a5,4(a5)
c0010364:	08078863          	beqz	a5,c00103f4 <XAxiDma_Start+0xdc>
		XAxiDma_BdRing *TxRingPtr;
		TxRingPtr = XAxiDma_GetTxRing(InstancePtr);
c0010368:	fdc42783          	lw	a5,-36(s0)
c001036c:	01478793          	addi	a5,a5,20
c0010370:	fef42423          	sw	a5,-24(s0)

		if (TxRingPtr->RunState == AXIDMA_CHANNEL_HALTED) {
c0010374:	fe842783          	lw	a5,-24(s0)
c0010378:	0087a703          	lw	a4,8(a5)
c001037c:	00200793          	li	a5,2
c0010380:	06f71a63          	bne	a4,a5,c00103f4 <XAxiDma_Start+0xdc>

			/* Start the channel
			 */
			if(XAxiDma_HasSg(InstancePtr)) {
c0010384:	fdc42783          	lw	a5,-36(s0)
c0010388:	0107a783          	lw	a5,16(a5)
c001038c:	02078863          	beqz	a5,c00103bc <XAxiDma_Start+0xa4>
				Status = XAxiDma_BdRingStart(TxRingPtr);
c0010390:	fe842503          	lw	a0,-24(s0)
c0010394:	cd4fe0ef          	jal	ra,c000e868 <XAxiDma_BdRingStart>
c0010398:	fea42223          	sw	a0,-28(s0)
				if (Status != XST_SUCCESS) {
c001039c:	fe442783          	lw	a5,-28(s0)
c00103a0:	04078463          	beqz	a5,c00103e8 <XAxiDma_Start+0xd0>
					printf(
c00103a4:	fe442583          	lw	a1,-28(s0)
c00103a8:	07ff1517          	auipc	a0,0x7ff1
c00103ac:	81450513          	addi	a0,a0,-2028 # c8000bbc <__rodata_start+0xbbc>
c00103b0:	1f50d0ef          	jal	ra,c001dda4 <printf>
					"Start hw tx channel failed %d\r\n",
								Status);

					return XST_DMA_ERROR;
c00103b4:	00900793          	li	a5,9
c00103b8:	1180006f          	j	c00104d0 <XAxiDma_Start+0x1b8>
				}
			}
			else {
				XAxiDma_WriteReg(TxRingPtr->ChanBase,
c00103bc:	fe842783          	lw	a5,-24(s0)
c00103c0:	0007a483          	lw	s1,0(a5)
c00103c4:	fe842783          	lw	a5,-24(s0)
c00103c8:	0007a783          	lw	a5,0(a5)
c00103cc:	00078513          	mv	a0,a5
c00103d0:	f24ff0ef          	jal	ra,c000faf4 <Xil_In32>
c00103d4:	00050793          	mv	a5,a0
c00103d8:	0017e793          	ori	a5,a5,1
c00103dc:	00078593          	mv	a1,a5
c00103e0:	00048513          	mv	a0,s1
c00103e4:	f38ff0ef          	jal	ra,c000fb1c <Xil_Out32>
					XAXIDMA_CR_OFFSET,
					XAxiDma_ReadReg(TxRingPtr->ChanBase,
					XAXIDMA_CR_OFFSET)
					| XAXIDMA_CR_RUNSTOP_MASK);
			}
			TxRingPtr->RunState = AXIDMA_CHANNEL_NOT_HALTED;
c00103e8:	fe842783          	lw	a5,-24(s0)
c00103ec:	00100713          	li	a4,1
c00103f0:	00e7a423          	sw	a4,8(a5)
		}
	}

	if (InstancePtr->HasS2Mm) {
c00103f4:	fdc42783          	lw	a5,-36(s0)
c00103f8:	0087a783          	lw	a5,8(a5)
c00103fc:	0c078863          	beqz	a5,c00104cc <XAxiDma_Start+0x1b4>
		int RingIndex = 0;
c0010400:	fe042623          	sw	zero,-20(s0)

		for (RingIndex = 0; RingIndex < InstancePtr->RxNumChannels;
c0010404:	fe042623          	sw	zero,-20(s0)
c0010408:	0b40006f          	j	c00104bc <XAxiDma_Start+0x1a4>
						RingIndex++) {
			XAxiDma_BdRing *RxRingPtr;
			RxRingPtr = XAxiDma_GetRxIndexRing(InstancePtr,
c001040c:	fec42703          	lw	a4,-20(s0)
c0010410:	06c00793          	li	a5,108
c0010414:	02f707b3          	mul	a5,a4,a5
c0010418:	08078793          	addi	a5,a5,128
c001041c:	fdc42703          	lw	a4,-36(s0)
c0010420:	00f707b3          	add	a5,a4,a5
c0010424:	fef42023          	sw	a5,-32(s0)
							 RingIndex);

			if (RxRingPtr->RunState != AXIDMA_CHANNEL_HALTED) {
c0010428:	fe042783          	lw	a5,-32(s0)
c001042c:	0087a703          	lw	a4,8(a5)
c0010430:	00200793          	li	a5,2
c0010434:	00f70663          	beq	a4,a5,c0010440 <XAxiDma_Start+0x128>
				return XST_SUCCESS;
c0010438:	00000793          	li	a5,0
c001043c:	0940006f          	j	c00104d0 <XAxiDma_Start+0x1b8>
			}

			/* Start the channel
			 */
			if(XAxiDma_HasSg(InstancePtr)) {
c0010440:	fdc42783          	lw	a5,-36(s0)
c0010444:	0107a783          	lw	a5,16(a5)
c0010448:	02078863          	beqz	a5,c0010478 <XAxiDma_Start+0x160>
				Status = XAxiDma_BdRingStart(RxRingPtr);
c001044c:	fe042503          	lw	a0,-32(s0)
c0010450:	c18fe0ef          	jal	ra,c000e868 <XAxiDma_BdRingStart>
c0010454:	fea42223          	sw	a0,-28(s0)
				if (Status != XST_SUCCESS) {
c0010458:	fe442783          	lw	a5,-28(s0)
c001045c:	04078463          	beqz	a5,c00104a4 <XAxiDma_Start+0x18c>
					printf(
c0010460:	fe442583          	lw	a1,-28(s0)
c0010464:	07ff0517          	auipc	a0,0x7ff0
c0010468:	75850513          	addi	a0,a0,1880 # c8000bbc <__rodata_start+0xbbc>
c001046c:	1390d0ef          	jal	ra,c001dda4 <printf>
					"Start hw tx channel failed %d\r\n",
								Status);

					return XST_DMA_ERROR;
c0010470:	00900793          	li	a5,9
c0010474:	05c0006f          	j	c00104d0 <XAxiDma_Start+0x1b8>
				}
			}
			else {
				XAxiDma_WriteReg(RxRingPtr->ChanBase,
c0010478:	fe042783          	lw	a5,-32(s0)
c001047c:	0007a483          	lw	s1,0(a5)
c0010480:	fe042783          	lw	a5,-32(s0)
c0010484:	0007a783          	lw	a5,0(a5)
c0010488:	00078513          	mv	a0,a5
c001048c:	e68ff0ef          	jal	ra,c000faf4 <Xil_In32>
c0010490:	00050793          	mv	a5,a0
c0010494:	0017e793          	ori	a5,a5,1
c0010498:	00078593          	mv	a1,a5
c001049c:	00048513          	mv	a0,s1
c00104a0:	e7cff0ef          	jal	ra,c000fb1c <Xil_Out32>
					XAxiDma_ReadReg(RxRingPtr->ChanBase,
					XAXIDMA_CR_OFFSET) |
					XAXIDMA_CR_RUNSTOP_MASK);
			}

			RxRingPtr->RunState = AXIDMA_CHANNEL_NOT_HALTED;
c00104a4:	fe042783          	lw	a5,-32(s0)
c00104a8:	00100713          	li	a4,1
c00104ac:	00e7a423          	sw	a4,8(a5)
						RingIndex++) {
c00104b0:	fec42783          	lw	a5,-20(s0)
c00104b4:	00178793          	addi	a5,a5,1
c00104b8:	fef42623          	sw	a5,-20(s0)
		for (RingIndex = 0; RingIndex < InstancePtr->RxNumChannels;
c00104bc:	fdc42783          	lw	a5,-36(s0)
c00104c0:	7447a783          	lw	a5,1860(a5)
c00104c4:	fec42703          	lw	a4,-20(s0)
c00104c8:	f4f742e3          	blt	a4,a5,c001040c <XAxiDma_Start+0xf4>
		}
	}

	return XST_SUCCESS;
c00104cc:	00000793          	li	a5,0
}
c00104d0:	00078513          	mv	a0,a5
c00104d4:	02c12083          	lw	ra,44(sp)
c00104d8:	02812403          	lw	s0,40(sp)
c00104dc:	02412483          	lw	s1,36(sp)
c00104e0:	03010113          	addi	sp,sp,48
c00104e4:	00008067          	ret

c00104e8 <XAxiDma_Pause>:
*
* @note		None
*
*****************************************************************************/
int XAxiDma_Pause(XAxiDma * InstancePtr)
{
c00104e8:	fd010113          	addi	sp,sp,-48
c00104ec:	02112623          	sw	ra,44(sp)
c00104f0:	02812423          	sw	s0,40(sp)
c00104f4:	02912223          	sw	s1,36(sp)
c00104f8:	03010413          	addi	s0,sp,48
c00104fc:	fca42e23          	sw	a0,-36(s0)

	if (!InstancePtr->Initialized) {
c0010500:	fdc42783          	lw	a5,-36(s0)
c0010504:	00c7a783          	lw	a5,12(a5)
c0010508:	02079263          	bnez	a5,c001052c <XAxiDma_Pause+0x44>

		printf("Pause: Driver not initialized"
c001050c:	fdc42783          	lw	a5,-36(s0)
c0010510:	00c7a783          	lw	a5,12(a5)
c0010514:	00078593          	mv	a1,a5
c0010518:	07ff0517          	auipc	a0,0x7ff0
c001051c:	6c450513          	addi	a0,a0,1732 # c8000bdc <__rodata_start+0xbdc>
c0010520:	0850d0ef          	jal	ra,c001dda4 <printf>
					" %d\r\n",InstancePtr->Initialized);

		return XST_NOT_SGDMA;
c0010524:	01000793          	li	a5,16
c0010528:	0f80006f          	j	c0010620 <XAxiDma_Pause+0x138>
	}

	if (InstancePtr->HasMm2S) {
c001052c:	fdc42783          	lw	a5,-36(s0)
c0010530:	0047a783          	lw	a5,4(a5)
c0010534:	04078a63          	beqz	a5,c0010588 <XAxiDma_Pause+0xa0>
		XAxiDma_BdRing *TxRingPtr;
		TxRingPtr = XAxiDma_GetTxRing(InstancePtr);
c0010538:	fdc42783          	lw	a5,-36(s0)
c001053c:	01478793          	addi	a5,a5,20
c0010540:	fef42423          	sw	a5,-24(s0)

		/* If channel is halted, then we do not need to do anything
		 */
		if(!XAxiDma_HasSg(InstancePtr)) {
c0010544:	fdc42783          	lw	a5,-36(s0)
c0010548:	0107a783          	lw	a5,16(a5)
c001054c:	02079863          	bnez	a5,c001057c <XAxiDma_Pause+0x94>
			XAxiDma_WriteReg(TxRingPtr->ChanBase,
c0010550:	fe842783          	lw	a5,-24(s0)
c0010554:	0007a483          	lw	s1,0(a5)
c0010558:	fe842783          	lw	a5,-24(s0)
c001055c:	0007a783          	lw	a5,0(a5)
c0010560:	00078513          	mv	a0,a5
c0010564:	d90ff0ef          	jal	ra,c000faf4 <Xil_In32>
c0010568:	00050793          	mv	a5,a0
c001056c:	ffe7f793          	andi	a5,a5,-2
c0010570:	00078593          	mv	a1,a5
c0010574:	00048513          	mv	a0,s1
c0010578:	da4ff0ef          	jal	ra,c000fb1c <Xil_Out32>
				XAxiDma_ReadReg(TxRingPtr->ChanBase,
				XAXIDMA_CR_OFFSET)
				& ~XAXIDMA_CR_RUNSTOP_MASK);
		}

		TxRingPtr->RunState = AXIDMA_CHANNEL_HALTED;
c001057c:	fe842783          	lw	a5,-24(s0)
c0010580:	00200713          	li	a4,2
c0010584:	00e7a423          	sw	a4,8(a5)
	}

	if (InstancePtr->HasS2Mm) {
c0010588:	fdc42783          	lw	a5,-36(s0)
c001058c:	0087a783          	lw	a5,8(a5)
c0010590:	08078663          	beqz	a5,c001061c <XAxiDma_Pause+0x134>
		int RingIndex = 0;
c0010594:	fe042623          	sw	zero,-20(s0)
		for (RingIndex = 0; RingIndex < InstancePtr->RxNumChannels;
c0010598:	fe042623          	sw	zero,-20(s0)
c001059c:	0700006f          	j	c001060c <XAxiDma_Pause+0x124>
				RingIndex++) {
			XAxiDma_BdRing *RxRingPtr;
			RxRingPtr = XAxiDma_GetRxIndexRing(InstancePtr, RingIndex);
c00105a0:	fec42703          	lw	a4,-20(s0)
c00105a4:	06c00793          	li	a5,108
c00105a8:	02f707b3          	mul	a5,a4,a5
c00105ac:	08078793          	addi	a5,a5,128
c00105b0:	fdc42703          	lw	a4,-36(s0)
c00105b4:	00f707b3          	add	a5,a4,a5
c00105b8:	fef42223          	sw	a5,-28(s0)

			/* If channel is halted, then we do not need to do anything
			 */

			if(!XAxiDma_HasSg(InstancePtr) && !RingIndex) {
c00105bc:	fdc42783          	lw	a5,-36(s0)
c00105c0:	0107a783          	lw	a5,16(a5)
c00105c4:	02079863          	bnez	a5,c00105f4 <XAxiDma_Pause+0x10c>
				XAxiDma_WriteReg(RxRingPtr->ChanBase,
c00105c8:	fe442783          	lw	a5,-28(s0)
c00105cc:	0007a483          	lw	s1,0(a5)
c00105d0:	fe442783          	lw	a5,-28(s0)
c00105d4:	0007a783          	lw	a5,0(a5)
c00105d8:	00078513          	mv	a0,a5
c00105dc:	d18ff0ef          	jal	ra,c000faf4 <Xil_In32>
c00105e0:	00050793          	mv	a5,a0
c00105e4:	ffe7f793          	andi	a5,a5,-2
c00105e8:	00078593          	mv	a1,a5
c00105ec:	00048513          	mv	a0,s1
c00105f0:	d2cff0ef          	jal	ra,c000fb1c <Xil_Out32>
					XAxiDma_ReadReg(RxRingPtr->ChanBase,
					XAXIDMA_CR_OFFSET)
					& ~XAXIDMA_CR_RUNSTOP_MASK);
			}

			RxRingPtr->RunState = AXIDMA_CHANNEL_HALTED;
c00105f4:	fe442783          	lw	a5,-28(s0)
c00105f8:	00200713          	li	a4,2
c00105fc:	00e7a423          	sw	a4,8(a5)
				RingIndex++) {
c0010600:	fec42783          	lw	a5,-20(s0)
c0010604:	00178793          	addi	a5,a5,1
c0010608:	fef42623          	sw	a5,-20(s0)
		for (RingIndex = 0; RingIndex < InstancePtr->RxNumChannels;
c001060c:	fdc42783          	lw	a5,-36(s0)
c0010610:	7447a783          	lw	a5,1860(a5)
c0010614:	fec42703          	lw	a4,-20(s0)
c0010618:	f8f744e3          	blt	a4,a5,c00105a0 <XAxiDma_Pause+0xb8>
		}
	}

	return XST_SUCCESS;
c001061c:	00000793          	li	a5,0

}
c0010620:	00078513          	mv	a0,a5
c0010624:	02c12083          	lw	ra,44(sp)
c0010628:	02812403          	lw	s0,40(sp)
c001062c:	02412483          	lw	s1,36(sp)
c0010630:	03010113          	addi	sp,sp,48
c0010634:	00008067          	ret

c0010638 <XAxiDma_Resume>:
*
* @note		None
*
*****************************************************************************/
int XAxiDma_Resume(XAxiDma * InstancePtr)
{
c0010638:	fd010113          	addi	sp,sp,-48
c001063c:	02112623          	sw	ra,44(sp)
c0010640:	02812423          	sw	s0,40(sp)
c0010644:	03010413          	addi	s0,sp,48
c0010648:	fca42e23          	sw	a0,-36(s0)
	int Status;

	if (!InstancePtr->Initialized) {
c001064c:	fdc42783          	lw	a5,-36(s0)
c0010650:	00c7a783          	lw	a5,12(a5)
c0010654:	02079263          	bnez	a5,c0010678 <XAxiDma_Resume+0x40>

		printf("Resume: Driver not initialized"
c0010658:	fdc42783          	lw	a5,-36(s0)
c001065c:	00c7a783          	lw	a5,12(a5)
c0010660:	00078593          	mv	a1,a5
c0010664:	07ff0517          	auipc	a0,0x7ff0
c0010668:	59c50513          	addi	a0,a0,1436 # c8000c00 <__rodata_start+0xc00>
c001066c:	7380d0ef          	jal	ra,c001dda4 <printf>
		" %d\r\n",InstancePtr->Initialized);

		return XST_NOT_SGDMA;
c0010670:	01000793          	li	a5,16
c0010674:	1340006f          	j	c00107a8 <XAxiDma_Resume+0x170>
	}

	/* If the DMA engine is not running, start it. Start may fail.
	 */
	if (!XAxiDma_Started(InstancePtr)) {
c0010678:	fdc42503          	lw	a0,-36(s0)
c001067c:	140000ef          	jal	ra,c00107bc <XAxiDma_Started>
c0010680:	00050793          	mv	a5,a0
c0010684:	02079863          	bnez	a5,c00106b4 <XAxiDma_Resume+0x7c>
		Status = XAxiDma_Start(InstancePtr);
c0010688:	fdc42503          	lw	a0,-36(s0)
c001068c:	c8dff0ef          	jal	ra,c0010318 <XAxiDma_Start>
c0010690:	fea42423          	sw	a0,-24(s0)

		if (Status != XST_SUCCESS) {
c0010694:	fe842783          	lw	a5,-24(s0)
c0010698:	00078e63          	beqz	a5,c00106b4 <XAxiDma_Resume+0x7c>
			printf("Resume: failed to start"
c001069c:	fe842583          	lw	a1,-24(s0)
c00106a0:	07ff0517          	auipc	a0,0x7ff0
c00106a4:	58450513          	addi	a0,a0,1412 # c8000c24 <__rodata_start+0xc24>
c00106a8:	6fc0d0ef          	jal	ra,c001dda4 <printf>
				" engine %d\r\n", Status);

			return Status;
c00106ac:	fe842783          	lw	a5,-24(s0)
c00106b0:	0f80006f          	j	c00107a8 <XAxiDma_Resume+0x170>
		}
	}

	/* Mark the state to be not halted
	 */
	if (InstancePtr->HasMm2S) {
c00106b4:	fdc42783          	lw	a5,-36(s0)
c00106b8:	0047a783          	lw	a5,4(a5)
c00106bc:	04078a63          	beqz	a5,c0010710 <XAxiDma_Resume+0xd8>
		XAxiDma_BdRing *TxRingPtr;
		TxRingPtr = XAxiDma_GetTxRing(InstancePtr);
c00106c0:	fdc42783          	lw	a5,-36(s0)
c00106c4:	01478793          	addi	a5,a5,20
c00106c8:	fef42223          	sw	a5,-28(s0)

		if(XAxiDma_HasSg(InstancePtr)) {
c00106cc:	fdc42783          	lw	a5,-36(s0)
c00106d0:	0107a783          	lw	a5,16(a5)
c00106d4:	02078863          	beqz	a5,c0010704 <XAxiDma_Resume+0xcc>
			Status = XAxiDma_BdRingStart(TxRingPtr);
c00106d8:	fe442503          	lw	a0,-28(s0)
c00106dc:	98cfe0ef          	jal	ra,c000e868 <XAxiDma_BdRingStart>
c00106e0:	fea42423          	sw	a0,-24(s0)
			if (Status != XST_SUCCESS) {
c00106e4:	fe842783          	lw	a5,-24(s0)
c00106e8:	00078e63          	beqz	a5,c0010704 <XAxiDma_Resume+0xcc>
				printf("Resume: failed"
c00106ec:	fe842583          	lw	a1,-24(s0)
c00106f0:	07ff0517          	auipc	a0,0x7ff0
c00106f4:	55850513          	addi	a0,a0,1368 # c8000c48 <__rodata_start+0xc48>
c00106f8:	6ac0d0ef          	jal	ra,c001dda4 <printf>
				" to start tx ring %d\r\n", Status);

				return XST_DMA_ERROR;
c00106fc:	00900793          	li	a5,9
c0010700:	0a80006f          	j	c00107a8 <XAxiDma_Resume+0x170>
			}
		}

		TxRingPtr->RunState = AXIDMA_CHANNEL_NOT_HALTED;
c0010704:	fe442783          	lw	a5,-28(s0)
c0010708:	00100713          	li	a4,1
c001070c:	00e7a423          	sw	a4,8(a5)
	}

	if (InstancePtr->HasS2Mm) {
c0010710:	fdc42783          	lw	a5,-36(s0)
c0010714:	0087a783          	lw	a5,8(a5)
c0010718:	08078663          	beqz	a5,c00107a4 <XAxiDma_Resume+0x16c>
		int RingIndex = 0;
c001071c:	fe042623          	sw	zero,-20(s0)
		for (RingIndex = 0 ; RingIndex < InstancePtr->RxNumChannels;
c0010720:	fe042623          	sw	zero,-20(s0)
c0010724:	0700006f          	j	c0010794 <XAxiDma_Resume+0x15c>
					RingIndex++) {
			XAxiDma_BdRing *RxRingPtr;
			RxRingPtr = XAxiDma_GetRxIndexRing(InstancePtr, RingIndex);
c0010728:	fec42703          	lw	a4,-20(s0)
c001072c:	06c00793          	li	a5,108
c0010730:	02f707b3          	mul	a5,a4,a5
c0010734:	08078793          	addi	a5,a5,128
c0010738:	fdc42703          	lw	a4,-36(s0)
c001073c:	00f707b3          	add	a5,a4,a5
c0010740:	fef42023          	sw	a5,-32(s0)

			if(XAxiDma_HasSg(InstancePtr)) {
c0010744:	fdc42783          	lw	a5,-36(s0)
c0010748:	0107a783          	lw	a5,16(a5)
c001074c:	02078863          	beqz	a5,c001077c <XAxiDma_Resume+0x144>
				Status = XAxiDma_BdRingStart(RxRingPtr);
c0010750:	fe042503          	lw	a0,-32(s0)
c0010754:	914fe0ef          	jal	ra,c000e868 <XAxiDma_BdRingStart>
c0010758:	fea42423          	sw	a0,-24(s0)
				if (Status != XST_SUCCESS) {
c001075c:	fe842783          	lw	a5,-24(s0)
c0010760:	00078e63          	beqz	a5,c001077c <XAxiDma_Resume+0x144>
					printf("Resume: failed"
c0010764:	fe842583          	lw	a1,-24(s0)
c0010768:	07ff0517          	auipc	a0,0x7ff0
c001076c:	50850513          	addi	a0,a0,1288 # c8000c70 <__rodata_start+0xc70>
c0010770:	6340d0ef          	jal	ra,c001dda4 <printf>
					"to start rx ring %d\r\n", Status);

					return XST_DMA_ERROR;
c0010774:	00900793          	li	a5,9
c0010778:	0300006f          	j	c00107a8 <XAxiDma_Resume+0x170>
				}
			}

			RxRingPtr->RunState = AXIDMA_CHANNEL_NOT_HALTED;
c001077c:	fe042783          	lw	a5,-32(s0)
c0010780:	00100713          	li	a4,1
c0010784:	00e7a423          	sw	a4,8(a5)
					RingIndex++) {
c0010788:	fec42783          	lw	a5,-20(s0)
c001078c:	00178793          	addi	a5,a5,1
c0010790:	fef42623          	sw	a5,-20(s0)
		for (RingIndex = 0 ; RingIndex < InstancePtr->RxNumChannels;
c0010794:	fdc42783          	lw	a5,-36(s0)
c0010798:	7447a783          	lw	a5,1860(a5)
c001079c:	fec42703          	lw	a4,-20(s0)
c00107a0:	f8f744e3          	blt	a4,a5,c0010728 <XAxiDma_Resume+0xf0>
		}
	}

	return XST_SUCCESS;
c00107a4:	00000793          	li	a5,0
}
c00107a8:	00078513          	mv	a0,a5
c00107ac:	02c12083          	lw	ra,44(sp)
c00107b0:	02812403          	lw	s0,40(sp)
c00107b4:	03010113          	addi	sp,sp,48
c00107b8:	00008067          	ret

c00107bc <XAxiDma_Started>:
*
* @note		None
*
*****************************************************************************/
static int XAxiDma_Started(XAxiDma * InstancePtr)
{
c00107bc:	fd010113          	addi	sp,sp,-48
c00107c0:	02112623          	sw	ra,44(sp)
c00107c4:	02812423          	sw	s0,40(sp)
c00107c8:	03010413          	addi	s0,sp,48
c00107cc:	fca42e23          	sw	a0,-36(s0)

	if (!InstancePtr->Initialized) {
c00107d0:	fdc42783          	lw	a5,-36(s0)
c00107d4:	00c7a783          	lw	a5,12(a5)
c00107d8:	02079263          	bnez	a5,c00107fc <XAxiDma_Started+0x40>

		printf("Started: Driver not initialized"
c00107dc:	fdc42783          	lw	a5,-36(s0)
c00107e0:	00c7a783          	lw	a5,12(a5)
c00107e4:	00078593          	mv	a1,a5
c00107e8:	07ff0517          	auipc	a0,0x7ff0
c00107ec:	4ac50513          	addi	a0,a0,1196 # c8000c94 <__rodata_start+0xc94>
c00107f0:	5b40d0ef          	jal	ra,c001dda4 <printf>
		" %d\r\n",InstancePtr->Initialized);

		return 0;
c00107f4:	00000793          	li	a5,0
c00107f8:	0a00006f          	j	c0010898 <XAxiDma_Started+0xdc>
	}

	if (InstancePtr->HasMm2S) {
c00107fc:	fdc42783          	lw	a5,-36(s0)
c0010800:	0047a783          	lw	a5,4(a5)
c0010804:	04078263          	beqz	a5,c0010848 <XAxiDma_Started+0x8c>
		XAxiDma_BdRing *TxRingPtr;
		TxRingPtr = XAxiDma_GetTxRing(InstancePtr);
c0010808:	fdc42783          	lw	a5,-36(s0)
c001080c:	01478793          	addi	a5,a5,20
c0010810:	fef42623          	sw	a5,-20(s0)

		if (!XAxiDma_BdRingHwIsStarted(TxRingPtr)) {
c0010814:	fec42783          	lw	a5,-20(s0)
c0010818:	0007a783          	lw	a5,0(a5)
c001081c:	00478793          	addi	a5,a5,4
c0010820:	00078513          	mv	a0,a5
c0010824:	ad0ff0ef          	jal	ra,c000faf4 <Xil_In32>
c0010828:	00050793          	mv	a5,a0
c001082c:	0017f793          	andi	a5,a5,1
c0010830:	00078c63          	beqz	a5,c0010848 <XAxiDma_Started+0x8c>
			printf(
c0010834:	07ff0517          	auipc	a0,0x7ff0
c0010838:	48850513          	addi	a0,a0,1160 # c8000cbc <__rodata_start+0xcbc>
c001083c:	6840d0ef          	jal	ra,c001dec0 <puts>
				"Started: tx ring not started\r\n");

			return 0;
c0010840:	00000793          	li	a5,0
c0010844:	0540006f          	j	c0010898 <XAxiDma_Started+0xdc>
		}
	}

	if (InstancePtr->HasS2Mm) {
c0010848:	fdc42783          	lw	a5,-36(s0)
c001084c:	0087a783          	lw	a5,8(a5)
c0010850:	04078263          	beqz	a5,c0010894 <XAxiDma_Started+0xd8>
		XAxiDma_BdRing *RxRingPtr;
		RxRingPtr = XAxiDma_GetRxRing(InstancePtr);
c0010854:	fdc42783          	lw	a5,-36(s0)
c0010858:	08078793          	addi	a5,a5,128
c001085c:	fef42423          	sw	a5,-24(s0)

		if (!XAxiDma_BdRingHwIsStarted(RxRingPtr)) {
c0010860:	fe842783          	lw	a5,-24(s0)
c0010864:	0007a783          	lw	a5,0(a5)
c0010868:	00478793          	addi	a5,a5,4
c001086c:	00078513          	mv	a0,a5
c0010870:	a84ff0ef          	jal	ra,c000faf4 <Xil_In32>
c0010874:	00050793          	mv	a5,a0
c0010878:	0017f793          	andi	a5,a5,1
c001087c:	00078c63          	beqz	a5,c0010894 <XAxiDma_Started+0xd8>
			printf(
c0010880:	07ff0517          	auipc	a0,0x7ff0
c0010884:	45c50513          	addi	a0,a0,1116 # c8000cdc <__rodata_start+0xcdc>
c0010888:	6380d0ef          	jal	ra,c001dec0 <puts>
				"Started: rx ring not started\r\n");

			return 0;
c001088c:	00000793          	li	a5,0
c0010890:	0080006f          	j	c0010898 <XAxiDma_Started+0xdc>
		}
	}

	return 1;
c0010894:	00100793          	li	a5,1
}
c0010898:	00078513          	mv	a0,a5
c001089c:	02c12083          	lw	ra,44(sp)
c00108a0:	02812403          	lw	s0,40(sp)
c00108a4:	03010113          	addi	sp,sp,48
c00108a8:	00008067          	ret

c00108ac <XAxiDma_Busy>:
 *
 * @note	None.
 *
 *****************************************************************************/
u32 XAxiDma_Busy(XAxiDma *InstancePtr, int Direction)
{
c00108ac:	fe010113          	addi	sp,sp,-32
c00108b0:	00112e23          	sw	ra,28(sp)
c00108b4:	00812c23          	sw	s0,24(sp)
c00108b8:	02010413          	addi	s0,sp,32
c00108bc:	fea42623          	sw	a0,-20(s0)
c00108c0:	feb42423          	sw	a1,-24(s0)

	return ((XAxiDma_ReadReg(InstancePtr->RegBase +
c00108c4:	fec42783          	lw	a5,-20(s0)
c00108c8:	0007a683          	lw	a3,0(a5)
c00108cc:	fe842703          	lw	a4,-24(s0)
c00108d0:	00070793          	mv	a5,a4
c00108d4:	00179793          	slli	a5,a5,0x1
c00108d8:	00e787b3          	add	a5,a5,a4
c00108dc:	00479793          	slli	a5,a5,0x4
c00108e0:	00f687b3          	add	a5,a3,a5
c00108e4:	00478793          	addi	a5,a5,4
c00108e8:	00078513          	mv	a0,a5
c00108ec:	a08ff0ef          	jal	ra,c000faf4 <Xil_In32>
c00108f0:	00050793          	mv	a5,a0
				(XAXIDMA_RX_OFFSET * Direction),
				XAXIDMA_SR_OFFSET) &
c00108f4:	0027f793          	andi	a5,a5,2
				XAXIDMA_IDLE_MASK) ? FALSE : TRUE);
c00108f8:	0017b793          	seqz	a5,a5
c00108fc:	0ff7f793          	andi	a5,a5,255
}
c0010900:	00078513          	mv	a0,a5
c0010904:	01c12083          	lw	ra,28(sp)
c0010908:	01812403          	lw	s0,24(sp)
c001090c:	02010113          	addi	sp,sp,32
c0010910:	00008067          	ret

c0010914 <XAxiDma_SelectKeyHole>:
 *
 * @note	None.
 *
 *****************************************************************************/
int XAxiDma_SelectKeyHole(XAxiDma *InstancePtr, int Direction, int Select)
{
c0010914:	fd010113          	addi	sp,sp,-48
c0010918:	02112623          	sw	ra,44(sp)
c001091c:	02812423          	sw	s0,40(sp)
c0010920:	03010413          	addi	s0,sp,48
c0010924:	fca42e23          	sw	a0,-36(s0)
c0010928:	fcb42c23          	sw	a1,-40(s0)
c001092c:	fcc42a23          	sw	a2,-44(s0)
	u32 Value;

	Value = XAxiDma_ReadReg(InstancePtr->RegBase +
c0010930:	fdc42783          	lw	a5,-36(s0)
c0010934:	0007a683          	lw	a3,0(a5)
c0010938:	fd842703          	lw	a4,-40(s0)
c001093c:	00070793          	mv	a5,a4
c0010940:	00179793          	slli	a5,a5,0x1
c0010944:	00e787b3          	add	a5,a5,a4
c0010948:	00479793          	slli	a5,a5,0x4
c001094c:	00f687b3          	add	a5,a3,a5
c0010950:	00078513          	mv	a0,a5
c0010954:	9a0ff0ef          	jal	ra,c000faf4 <Xil_In32>
c0010958:	fea42623          	sw	a0,-20(s0)
				(XAXIDMA_RX_OFFSET * Direction),
				XAXIDMA_CR_OFFSET);

	if (Select)
c001095c:	fd442783          	lw	a5,-44(s0)
c0010960:	00078a63          	beqz	a5,c0010974 <XAxiDma_SelectKeyHole+0x60>
		Value |= XAXIDMA_CR_KEYHOLE_MASK;
c0010964:	fec42783          	lw	a5,-20(s0)
c0010968:	0087e793          	ori	a5,a5,8
c001096c:	fef42623          	sw	a5,-20(s0)
c0010970:	0100006f          	j	c0010980 <XAxiDma_SelectKeyHole+0x6c>
	else
		Value &= ~XAXIDMA_CR_KEYHOLE_MASK;
c0010974:	fec42783          	lw	a5,-20(s0)
c0010978:	ff77f793          	andi	a5,a5,-9
c001097c:	fef42623          	sw	a5,-20(s0)

	XAxiDma_WriteReg(InstancePtr->RegBase +
c0010980:	fdc42783          	lw	a5,-36(s0)
c0010984:	0007a683          	lw	a3,0(a5)
c0010988:	fd842703          	lw	a4,-40(s0)
c001098c:	00070793          	mv	a5,a4
c0010990:	00179793          	slli	a5,a5,0x1
c0010994:	00e787b3          	add	a5,a5,a4
c0010998:	00479793          	slli	a5,a5,0x4
c001099c:	00f687b3          	add	a5,a3,a5
c00109a0:	fec42583          	lw	a1,-20(s0)
c00109a4:	00078513          	mv	a0,a5
c00109a8:	974ff0ef          	jal	ra,c000fb1c <Xil_Out32>
			(XAXIDMA_RX_OFFSET * Direction),
			XAXIDMA_CR_OFFSET, Value);

	return XST_SUCCESS;
c00109ac:	00000793          	li	a5,0

}
c00109b0:	00078513          	mv	a0,a5
c00109b4:	02c12083          	lw	ra,44(sp)
c00109b8:	02812403          	lw	s0,40(sp)
c00109bc:	03010113          	addi	sp,sp,48
c00109c0:	00008067          	ret

c00109c4 <XAxiDma_SelectCyclicMode>:
 *
 * @note	None.
 *
 *****************************************************************************/
int XAxiDma_SelectCyclicMode(XAxiDma *InstancePtr, int Direction, int Select)
{
c00109c4:	fd010113          	addi	sp,sp,-48
c00109c8:	02112623          	sw	ra,44(sp)
c00109cc:	02812423          	sw	s0,40(sp)
c00109d0:	03010413          	addi	s0,sp,48
c00109d4:	fca42e23          	sw	a0,-36(s0)
c00109d8:	fcb42c23          	sw	a1,-40(s0)
c00109dc:	fcc42a23          	sw	a2,-44(s0)
	u32 Value;

	Value = XAxiDma_ReadReg(InstancePtr->RegBase +
c00109e0:	fdc42783          	lw	a5,-36(s0)
c00109e4:	0007a683          	lw	a3,0(a5)
c00109e8:	fd842703          	lw	a4,-40(s0)
c00109ec:	00070793          	mv	a5,a4
c00109f0:	00179793          	slli	a5,a5,0x1
c00109f4:	00e787b3          	add	a5,a5,a4
c00109f8:	00479793          	slli	a5,a5,0x4
c00109fc:	00f687b3          	add	a5,a3,a5
c0010a00:	00078513          	mv	a0,a5
c0010a04:	8f0ff0ef          	jal	ra,c000faf4 <Xil_In32>
c0010a08:	fea42623          	sw	a0,-20(s0)
				(XAXIDMA_RX_OFFSET * Direction),
				XAXIDMA_CR_OFFSET);

	if (Select)
c0010a0c:	fd442783          	lw	a5,-44(s0)
c0010a10:	00078a63          	beqz	a5,c0010a24 <XAxiDma_SelectCyclicMode+0x60>
		Value |= XAXIDMA_CR_CYCLIC_MASK;
c0010a14:	fec42783          	lw	a5,-20(s0)
c0010a18:	0107e793          	ori	a5,a5,16
c0010a1c:	fef42623          	sw	a5,-20(s0)
c0010a20:	0100006f          	j	c0010a30 <XAxiDma_SelectCyclicMode+0x6c>
	else
		Value &= ~XAXIDMA_CR_CYCLIC_MASK;
c0010a24:	fec42783          	lw	a5,-20(s0)
c0010a28:	fef7f793          	andi	a5,a5,-17
c0010a2c:	fef42623          	sw	a5,-20(s0)

	XAxiDma_WriteReg(InstancePtr->RegBase +
c0010a30:	fdc42783          	lw	a5,-36(s0)
c0010a34:	0007a683          	lw	a3,0(a5)
c0010a38:	fd842703          	lw	a4,-40(s0)
c0010a3c:	00070793          	mv	a5,a4
c0010a40:	00179793          	slli	a5,a5,0x1
c0010a44:	00e787b3          	add	a5,a5,a4
c0010a48:	00479793          	slli	a5,a5,0x4
c0010a4c:	00f687b3          	add	a5,a3,a5
c0010a50:	fec42583          	lw	a1,-20(s0)
c0010a54:	00078513          	mv	a0,a5
c0010a58:	8c4ff0ef          	jal	ra,c000fb1c <Xil_Out32>
			(XAXIDMA_RX_OFFSET * Direction),
			XAXIDMA_CR_OFFSET, Value);

	return XST_SUCCESS;
c0010a5c:	00000793          	li	a5,0
}
c0010a60:	00078513          	mv	a0,a5
c0010a64:	02c12083          	lw	ra,44(sp)
c0010a68:	02812403          	lw	s0,40(sp)
c0010a6c:	03010113          	addi	sp,sp,48
c0010a70:	00008067          	ret

c0010a74 <XAxiDma_SimpleTransfer>:
 *		Simple mode.
 *
 *****************************************************************************/
u32 XAxiDma_SimpleTransfer(XAxiDma *InstancePtr, UINTPTR BuffAddr, u32 Length,
	int Direction)
{
c0010a74:	fd010113          	addi	sp,sp,-48
c0010a78:	02112623          	sw	ra,44(sp)
c0010a7c:	02812423          	sw	s0,40(sp)
c0010a80:	02912223          	sw	s1,36(sp)
c0010a84:	03010413          	addi	s0,sp,48
c0010a88:	fca42e23          	sw	a0,-36(s0)
c0010a8c:	fcb42c23          	sw	a1,-40(s0)
c0010a90:	fcc42a23          	sw	a2,-44(s0)
c0010a94:	fcd42823          	sw	a3,-48(s0)
	u32 WordBits;
	int RingIndex = 0;
c0010a98:	fe042423          	sw	zero,-24(s0)

	/* If Scatter Gather is included then, cannot submit
	 */
	if (XAxiDma_HasSg(InstancePtr)) {
c0010a9c:	fdc42783          	lw	a5,-36(s0)
c0010aa0:	0107a783          	lw	a5,16(a5)
c0010aa4:	00078c63          	beqz	a5,c0010abc <XAxiDma_SimpleTransfer+0x48>
		printf("Simple DMA mode is not"
c0010aa8:	07ff0517          	auipc	a0,0x7ff0
c0010aac:	25450513          	addi	a0,a0,596 # c8000cfc <__rodata_start+0xcfc>
c0010ab0:	4100d0ef          	jal	ra,c001dec0 <puts>
							" supported\r\n");

		return XST_FAILURE;
c0010ab4:	00100793          	li	a5,1
c0010ab8:	3880006f          	j	c0010e40 <XAxiDma_SimpleTransfer+0x3cc>
	}

	if(Direction == XAXIDMA_DMA_TO_DEVICE){
c0010abc:	fd042783          	lw	a5,-48(s0)
c0010ac0:	16079a63          	bnez	a5,c0010c34 <XAxiDma_SimpleTransfer+0x1c0>
		if ((Length < 1) ||
c0010ac4:	fd442783          	lw	a5,-44(s0)
c0010ac8:	00078a63          	beqz	a5,c0010adc <XAxiDma_SimpleTransfer+0x68>
			(Length > InstancePtr->TxBdRing.MaxTransferLen)) {
c0010acc:	fdc42783          	lw	a5,-36(s0)
c0010ad0:	0307a783          	lw	a5,48(a5)
		if ((Length < 1) ||
c0010ad4:	fd442703          	lw	a4,-44(s0)
c0010ad8:	00e7f663          	bgeu	a5,a4,c0010ae4 <XAxiDma_SimpleTransfer+0x70>
			return XST_INVALID_PARAM;
c0010adc:	00f00793          	li	a5,15
c0010ae0:	3600006f          	j	c0010e40 <XAxiDma_SimpleTransfer+0x3cc>
		}

		if (!InstancePtr->HasMm2S) {
c0010ae4:	fdc42783          	lw	a5,-36(s0)
c0010ae8:	0047a783          	lw	a5,4(a5)
c0010aec:	00079c63          	bnez	a5,c0010b04 <XAxiDma_SimpleTransfer+0x90>
			printf("MM2S channel is not"
c0010af0:	07ff0517          	auipc	a0,0x7ff0
c0010af4:	23050513          	addi	a0,a0,560 # c8000d20 <__rodata_start+0xd20>
c0010af8:	3c80d0ef          	jal	ra,c001dec0 <puts>
							"supported\r\n");

			return XST_FAILURE;
c0010afc:	00100793          	li	a5,1
c0010b00:	3400006f          	j	c0010e40 <XAxiDma_SimpleTransfer+0x3cc>
		}

		/* If the engine is doing transfer, cannot submit
		 */

		if(!(XAxiDma_ReadReg(InstancePtr->TxBdRing.ChanBase,
c0010b04:	fdc42783          	lw	a5,-36(s0)
c0010b08:	0147a783          	lw	a5,20(a5)
c0010b0c:	00478793          	addi	a5,a5,4
c0010b10:	00078513          	mv	a0,a5
c0010b14:	fe1fe0ef          	jal	ra,c000faf4 <Xil_In32>
c0010b18:	00050793          	mv	a5,a0
				XAXIDMA_SR_OFFSET) & XAXIDMA_HALTED_MASK)) {
c0010b1c:	0017f793          	andi	a5,a5,1
		if(!(XAxiDma_ReadReg(InstancePtr->TxBdRing.ChanBase,
c0010b20:	02079663          	bnez	a5,c0010b4c <XAxiDma_SimpleTransfer+0xd8>
			if (XAxiDma_Busy(InstancePtr,Direction)) {
c0010b24:	fd042583          	lw	a1,-48(s0)
c0010b28:	fdc42503          	lw	a0,-36(s0)
c0010b2c:	d81ff0ef          	jal	ra,c00108ac <XAxiDma_Busy>
c0010b30:	00050793          	mv	a5,a0
c0010b34:	00078c63          	beqz	a5,c0010b4c <XAxiDma_SimpleTransfer+0xd8>
				printf(
c0010b38:	07ff0517          	auipc	a0,0x7ff0
c0010b3c:	20850513          	addi	a0,a0,520 # c8000d40 <__rodata_start+0xd40>
c0010b40:	3800d0ef          	jal	ra,c001dec0 <puts>
							"Engine is busy\r\n");
				return XST_FAILURE;
c0010b44:	00100793          	li	a5,1
c0010b48:	2f80006f          	j	c0010e40 <XAxiDma_SimpleTransfer+0x3cc>
			}
		}

		if (!InstancePtr->MicroDmaMode) {
c0010b4c:	fdc42783          	lw	a5,-36(s0)
c0010b50:	7487a783          	lw	a5,1864(a5)
c0010b54:	00079c63          	bnez	a5,c0010b6c <XAxiDma_SimpleTransfer+0xf8>
			WordBits = (u32)((InstancePtr->TxBdRing.DataWidth) - 1);
c0010b58:	fdc42783          	lw	a5,-36(s0)
c0010b5c:	0287a783          	lw	a5,40(a5)
c0010b60:	fff78793          	addi	a5,a5,-1
c0010b64:	fef42623          	sw	a5,-20(s0)
c0010b68:	0100006f          	j	c0010b78 <XAxiDma_SimpleTransfer+0x104>
		}
		else {
			WordBits = XAXIDMA_MICROMODE_MIN_BUF_ALIGN;
c0010b6c:	000017b7          	lui	a5,0x1
c0010b70:	fff78793          	addi	a5,a5,-1 # fff <_STACK_SIZE-0x1>
c0010b74:	fef42623          	sw	a5,-20(s0)
		}

		if ((BuffAddr & WordBits)) {
c0010b78:	fd842703          	lw	a4,-40(s0)
c0010b7c:	fec42783          	lw	a5,-20(s0)
c0010b80:	00f777b3          	and	a5,a4,a5
c0010b84:	02078463          	beqz	a5,c0010bac <XAxiDma_SimpleTransfer+0x138>

			if (!InstancePtr->TxBdRing.HasDRE) {
c0010b88:	fdc42783          	lw	a5,-36(s0)
c0010b8c:	0247a783          	lw	a5,36(a5)
c0010b90:	00079e63          	bnez	a5,c0010bac <XAxiDma_SimpleTransfer+0x138>
				printf(
c0010b94:	fd842583          	lw	a1,-40(s0)
c0010b98:	07ff0517          	auipc	a0,0x7ff0
c0010b9c:	1b850513          	addi	a0,a0,440 # c8000d50 <__rodata_start+0xd50>
c0010ba0:	2040d0ef          	jal	ra,c001dda4 <printf>
					"Unaligned transfer without"
					" DRE %x\r\n",(unsigned int)BuffAddr);

				return XST_INVALID_PARAM;
c0010ba4:	00f00793          	li	a5,15
c0010ba8:	2980006f          	j	c0010e40 <XAxiDma_SimpleTransfer+0x3cc>
			}
		}


		XAxiDma_WriteReg(InstancePtr->TxBdRing.ChanBase,
c0010bac:	fdc42783          	lw	a5,-36(s0)
c0010bb0:	0147a783          	lw	a5,20(a5)
c0010bb4:	01878793          	addi	a5,a5,24
c0010bb8:	fd842583          	lw	a1,-40(s0)
c0010bbc:	00078513          	mv	a0,a5
c0010bc0:	f5dfe0ef          	jal	ra,c000fb1c <Xil_Out32>
				 XAXIDMA_SRCADDR_OFFSET, LOWER_32_BITS(BuffAddr));
		if (InstancePtr->AddrWidth > 32)
c0010bc4:	fdc42783          	lw	a5,-36(s0)
c0010bc8:	74c7a703          	lw	a4,1868(a5)
c0010bcc:	02000793          	li	a5,32
c0010bd0:	00e7de63          	bge	a5,a4,c0010bec <XAxiDma_SimpleTransfer+0x178>
			XAxiDma_WriteReg(InstancePtr->TxBdRing.ChanBase,
c0010bd4:	fdc42783          	lw	a5,-36(s0)
c0010bd8:	0147a783          	lw	a5,20(a5)
c0010bdc:	01c78793          	addi	a5,a5,28
c0010be0:	00000593          	li	a1,0
c0010be4:	00078513          	mv	a0,a5
c0010be8:	f35fe0ef          	jal	ra,c000fb1c <Xil_Out32>
					 XAXIDMA_SRCADDR_MSB_OFFSET,
					 UPPER_32_BITS(BuffAddr));

		XAxiDma_WriteReg(InstancePtr->TxBdRing.ChanBase,
c0010bec:	fdc42783          	lw	a5,-36(s0)
c0010bf0:	0147a483          	lw	s1,20(a5)
c0010bf4:	fdc42783          	lw	a5,-36(s0)
c0010bf8:	0147a783          	lw	a5,20(a5)
c0010bfc:	00078513          	mv	a0,a5
c0010c00:	ef5fe0ef          	jal	ra,c000faf4 <Xil_In32>
c0010c04:	00050793          	mv	a5,a0
c0010c08:	0017e793          	ori	a5,a5,1
c0010c0c:	00078593          	mv	a1,a5
c0010c10:	00048513          	mv	a0,s1
c0010c14:	f09fe0ef          	jal	ra,c000fb1c <Xil_Out32>
				InstancePtr->TxBdRing.ChanBase,
				XAXIDMA_CR_OFFSET)| XAXIDMA_CR_RUNSTOP_MASK);

		/* Writing to the BTT register starts the transfer
		 */
		XAxiDma_WriteReg(InstancePtr->TxBdRing.ChanBase,
c0010c18:	fdc42783          	lw	a5,-36(s0)
c0010c1c:	0147a783          	lw	a5,20(a5)
c0010c20:	02878793          	addi	a5,a5,40
c0010c24:	fd442583          	lw	a1,-44(s0)
c0010c28:	00078513          	mv	a0,a5
c0010c2c:	ef1fe0ef          	jal	ra,c000fb1c <Xil_Out32>
c0010c30:	20c0006f          	j	c0010e3c <XAxiDma_SimpleTransfer+0x3c8>
					XAXIDMA_BUFFLEN_OFFSET, Length);
	}
	else if(Direction == XAXIDMA_DEVICE_TO_DMA){
c0010c34:	fd042703          	lw	a4,-48(s0)
c0010c38:	00100793          	li	a5,1
c0010c3c:	20f71063          	bne	a4,a5,c0010e3c <XAxiDma_SimpleTransfer+0x3c8>
		if ((Length < 1) ||
c0010c40:	fd442783          	lw	a5,-44(s0)
c0010c44:	02078263          	beqz	a5,c0010c68 <XAxiDma_SimpleTransfer+0x1f4>
			(Length >
			InstancePtr->RxBdRing[RingIndex].MaxTransferLen)) {
c0010c48:	fdc42703          	lw	a4,-36(s0)
c0010c4c:	fe842683          	lw	a3,-24(s0)
c0010c50:	06c00793          	li	a5,108
c0010c54:	02f687b3          	mul	a5,a3,a5
c0010c58:	00f707b3          	add	a5,a4,a5
c0010c5c:	09c7a783          	lw	a5,156(a5)
		if ((Length < 1) ||
c0010c60:	fd442703          	lw	a4,-44(s0)
c0010c64:	00e7f663          	bgeu	a5,a4,c0010c70 <XAxiDma_SimpleTransfer+0x1fc>
			return XST_INVALID_PARAM;
c0010c68:	00f00793          	li	a5,15
c0010c6c:	1d40006f          	j	c0010e40 <XAxiDma_SimpleTransfer+0x3cc>
		}


		if (!InstancePtr->HasS2Mm) {
c0010c70:	fdc42783          	lw	a5,-36(s0)
c0010c74:	0087a783          	lw	a5,8(a5)
c0010c78:	00079c63          	bnez	a5,c0010c90 <XAxiDma_SimpleTransfer+0x21c>
			printf("S2MM channel is not"
c0010c7c:	07ff0517          	auipc	a0,0x7ff0
c0010c80:	0f850513          	addi	a0,a0,248 # c8000d74 <__rodata_start+0xd74>
c0010c84:	23c0d0ef          	jal	ra,c001dec0 <puts>
							" supported\r\n");

			return XST_FAILURE;
c0010c88:	00100793          	li	a5,1
c0010c8c:	1b40006f          	j	c0010e40 <XAxiDma_SimpleTransfer+0x3cc>
		}

		if(!(XAxiDma_ReadReg(InstancePtr->RxBdRing[RingIndex].ChanBase,
c0010c90:	fdc42703          	lw	a4,-36(s0)
c0010c94:	fe842683          	lw	a3,-24(s0)
c0010c98:	06c00793          	li	a5,108
c0010c9c:	02f687b3          	mul	a5,a3,a5
c0010ca0:	00f707b3          	add	a5,a4,a5
c0010ca4:	0807a783          	lw	a5,128(a5)
c0010ca8:	00478793          	addi	a5,a5,4
c0010cac:	00078513          	mv	a0,a5
c0010cb0:	e45fe0ef          	jal	ra,c000faf4 <Xil_In32>
c0010cb4:	00050793          	mv	a5,a0
				XAXIDMA_SR_OFFSET) & XAXIDMA_HALTED_MASK)) {
c0010cb8:	0017f793          	andi	a5,a5,1
		if(!(XAxiDma_ReadReg(InstancePtr->RxBdRing[RingIndex].ChanBase,
c0010cbc:	02079663          	bnez	a5,c0010ce8 <XAxiDma_SimpleTransfer+0x274>
			if (XAxiDma_Busy(InstancePtr,Direction)) {
c0010cc0:	fd042583          	lw	a1,-48(s0)
c0010cc4:	fdc42503          	lw	a0,-36(s0)
c0010cc8:	be5ff0ef          	jal	ra,c00108ac <XAxiDma_Busy>
c0010ccc:	00050793          	mv	a5,a0
c0010cd0:	00078c63          	beqz	a5,c0010ce8 <XAxiDma_SimpleTransfer+0x274>
				printf(
c0010cd4:	07ff0517          	auipc	a0,0x7ff0
c0010cd8:	06c50513          	addi	a0,a0,108 # c8000d40 <__rodata_start+0xd40>
c0010cdc:	1e40d0ef          	jal	ra,c001dec0 <puts>
							"Engine is busy\r\n");
				return XST_FAILURE;
c0010ce0:	00100793          	li	a5,1
c0010ce4:	15c0006f          	j	c0010e40 <XAxiDma_SimpleTransfer+0x3cc>
			}
		}

		if (!InstancePtr->MicroDmaMode) {
c0010ce8:	fdc42783          	lw	a5,-36(s0)
c0010cec:	7487a783          	lw	a5,1864(a5)
c0010cf0:	02079463          	bnez	a5,c0010d18 <XAxiDma_SimpleTransfer+0x2a4>
			WordBits =
			 (u32)((InstancePtr->RxBdRing[RingIndex].DataWidth) - 1);
c0010cf4:	fdc42703          	lw	a4,-36(s0)
c0010cf8:	fe842683          	lw	a3,-24(s0)
c0010cfc:	06c00793          	li	a5,108
c0010d00:	02f687b3          	mul	a5,a3,a5
c0010d04:	00f707b3          	add	a5,a4,a5
c0010d08:	0947a783          	lw	a5,148(a5)
c0010d0c:	fff78793          	addi	a5,a5,-1
			WordBits =
c0010d10:	fef42623          	sw	a5,-20(s0)
c0010d14:	0100006f          	j	c0010d24 <XAxiDma_SimpleTransfer+0x2b0>
		}
		else {
			WordBits = XAXIDMA_MICROMODE_MIN_BUF_ALIGN;
c0010d18:	000017b7          	lui	a5,0x1
c0010d1c:	fff78793          	addi	a5,a5,-1 # fff <_STACK_SIZE-0x1>
c0010d20:	fef42623          	sw	a5,-20(s0)
		}

		if ((BuffAddr & WordBits)) {
c0010d24:	fd842703          	lw	a4,-40(s0)
c0010d28:	fec42783          	lw	a5,-20(s0)
c0010d2c:	00f777b3          	and	a5,a4,a5
c0010d30:	02078c63          	beqz	a5,c0010d68 <XAxiDma_SimpleTransfer+0x2f4>

			if (!InstancePtr->RxBdRing[RingIndex].HasDRE) {
c0010d34:	fdc42703          	lw	a4,-36(s0)
c0010d38:	fe842683          	lw	a3,-24(s0)
c0010d3c:	06c00793          	li	a5,108
c0010d40:	02f687b3          	mul	a5,a3,a5
c0010d44:	00f707b3          	add	a5,a4,a5
c0010d48:	0907a783          	lw	a5,144(a5)
c0010d4c:	00079e63          	bnez	a5,c0010d68 <XAxiDma_SimpleTransfer+0x2f4>
				printf(
c0010d50:	fd842583          	lw	a1,-40(s0)
c0010d54:	07ff0517          	auipc	a0,0x7ff0
c0010d58:	ffc50513          	addi	a0,a0,-4 # c8000d50 <__rodata_start+0xd50>
c0010d5c:	0480d0ef          	jal	ra,c001dda4 <printf>
					"Unaligned transfer without"
				" DRE %x\r\n", (unsigned int)BuffAddr);

				return XST_INVALID_PARAM;
c0010d60:	00f00793          	li	a5,15
c0010d64:	0dc0006f          	j	c0010e40 <XAxiDma_SimpleTransfer+0x3cc>
			}
		}


		XAxiDma_WriteReg(InstancePtr->RxBdRing[RingIndex].ChanBase,
c0010d68:	fdc42703          	lw	a4,-36(s0)
c0010d6c:	fe842683          	lw	a3,-24(s0)
c0010d70:	06c00793          	li	a5,108
c0010d74:	02f687b3          	mul	a5,a3,a5
c0010d78:	00f707b3          	add	a5,a4,a5
c0010d7c:	0807a783          	lw	a5,128(a5)
c0010d80:	01878793          	addi	a5,a5,24
c0010d84:	fd842583          	lw	a1,-40(s0)
c0010d88:	00078513          	mv	a0,a5
c0010d8c:	d91fe0ef          	jal	ra,c000fb1c <Xil_Out32>
				 XAXIDMA_DESTADDR_OFFSET, LOWER_32_BITS(BuffAddr));
		if (InstancePtr->AddrWidth > 32)
c0010d90:	fdc42783          	lw	a5,-36(s0)
c0010d94:	74c7a703          	lw	a4,1868(a5)
c0010d98:	02000793          	li	a5,32
c0010d9c:	02e7d663          	bge	a5,a4,c0010dc8 <XAxiDma_SimpleTransfer+0x354>
			XAxiDma_WriteReg(InstancePtr->RxBdRing[RingIndex].ChanBase,
c0010da0:	fdc42703          	lw	a4,-36(s0)
c0010da4:	fe842683          	lw	a3,-24(s0)
c0010da8:	06c00793          	li	a5,108
c0010dac:	02f687b3          	mul	a5,a3,a5
c0010db0:	00f707b3          	add	a5,a4,a5
c0010db4:	0807a783          	lw	a5,128(a5)
c0010db8:	01c78793          	addi	a5,a5,28
c0010dbc:	00000593          	li	a1,0
c0010dc0:	00078513          	mv	a0,a5
c0010dc4:	d59fe0ef          	jal	ra,c000fb1c <Xil_Out32>
					 XAXIDMA_DESTADDR_MSB_OFFSET,
					 UPPER_32_BITS(BuffAddr));

		XAxiDma_WriteReg(InstancePtr->RxBdRing[RingIndex].ChanBase,
c0010dc8:	fdc42703          	lw	a4,-36(s0)
c0010dcc:	fe842683          	lw	a3,-24(s0)
c0010dd0:	06c00793          	li	a5,108
c0010dd4:	02f687b3          	mul	a5,a3,a5
c0010dd8:	00f707b3          	add	a5,a4,a5
c0010ddc:	0807a483          	lw	s1,128(a5)
c0010de0:	fdc42703          	lw	a4,-36(s0)
c0010de4:	fe842683          	lw	a3,-24(s0)
c0010de8:	06c00793          	li	a5,108
c0010dec:	02f687b3          	mul	a5,a3,a5
c0010df0:	00f707b3          	add	a5,a4,a5
c0010df4:	0807a783          	lw	a5,128(a5)
c0010df8:	00078513          	mv	a0,a5
c0010dfc:	cf9fe0ef          	jal	ra,c000faf4 <Xil_In32>
c0010e00:	00050793          	mv	a5,a0
c0010e04:	0017e793          	ori	a5,a5,1
c0010e08:	00078593          	mv	a1,a5
c0010e0c:	00048513          	mv	a0,s1
c0010e10:	d0dfe0ef          	jal	ra,c000fb1c <Xil_Out32>
				XAXIDMA_CR_OFFSET,
			XAxiDma_ReadReg(InstancePtr->RxBdRing[RingIndex].ChanBase,
			XAXIDMA_CR_OFFSET)| XAXIDMA_CR_RUNSTOP_MASK);
		/* Writing to the BTT register starts the transfer
		 */
		XAxiDma_WriteReg(InstancePtr->RxBdRing[RingIndex].ChanBase,
c0010e14:	fdc42703          	lw	a4,-36(s0)
c0010e18:	fe842683          	lw	a3,-24(s0)
c0010e1c:	06c00793          	li	a5,108
c0010e20:	02f687b3          	mul	a5,a3,a5
c0010e24:	00f707b3          	add	a5,a4,a5
c0010e28:	0807a783          	lw	a5,128(a5)
c0010e2c:	02878793          	addi	a5,a5,40
c0010e30:	fd442583          	lw	a1,-44(s0)
c0010e34:	00078513          	mv	a0,a5
c0010e38:	ce5fe0ef          	jal	ra,c000fb1c <Xil_Out32>
					XAXIDMA_BUFFLEN_OFFSET, Length);

	}

	return XST_SUCCESS;
c0010e3c:	00000793          	li	a5,0
}
c0010e40:	00078513          	mv	a0,a5
c0010e44:	02c12083          	lw	ra,44(sp)
c0010e48:	02812403          	lw	s0,40(sp)
c0010e4c:	02412483          	lw	s1,36(sp)
c0010e50:	03010113          	addi	sp,sp,48
c0010e54:	00008067          	ret

c0010e58 <XAxiDma_Selftest>:
* @note
*     None.
*
******************************************************************************/
int XAxiDma_Selftest(XAxiDma * InstancePtr)
{
c0010e58:	fd010113          	addi	sp,sp,-48
c0010e5c:	02112623          	sw	ra,44(sp)
c0010e60:	02812423          	sw	s0,40(sp)
c0010e64:	03010413          	addi	s0,sp,48
c0010e68:	fca42e23          	sw	a0,-36(s0)
	int TimeOut;

	Xil_AssertNonvoid(InstancePtr != NULL);
c0010e6c:	fdc42783          	lw	a5,-36(s0)
c0010e70:	02078263          	beqz	a5,c0010e94 <XAxiDma_Selftest+0x3c>
c0010e74:	07ff2797          	auipc	a5,0x7ff2
c0010e78:	aa078793          	addi	a5,a5,-1376 # c8002914 <Xil_AssertStatus>
c0010e7c:	0007a023          	sw	zero,0(a5)

	XAxiDma_Reset(InstancePtr);
c0010e80:	fdc42503          	lw	a0,-36(s0)
c0010e84:	964ff0ef          	jal	ra,c000ffe8 <XAxiDma_Reset>

	/* At the initialization time, hardware should finish reset quickly
	 */
	TimeOut = XAXIDMA_RESET_TIMEOUT;
c0010e88:	1f400793          	li	a5,500
c0010e8c:	fef42623          	sw	a5,-20(s0)

	while (TimeOut) {
c0010e90:	0480006f          	j	c0010ed8 <XAxiDma_Selftest+0x80>
	Xil_AssertNonvoid(InstancePtr != NULL);
c0010e94:	05900593          	li	a1,89
c0010e98:	07ff0517          	auipc	a0,0x7ff0
c0010e9c:	efc50513          	addi	a0,a0,-260 # c8000d94 <__rodata_start+0xd94>
c0010ea0:	41d0c0ef          	jal	ra,c001dabc <Xil_Assert>
c0010ea4:	07ff2797          	auipc	a5,0x7ff2
c0010ea8:	a7078793          	addi	a5,a5,-1424 # c8002914 <Xil_AssertStatus>
c0010eac:	00100713          	li	a4,1
c0010eb0:	00e7a023          	sw	a4,0(a5)
c0010eb4:	00000793          	li	a5,0
c0010eb8:	0440006f          	j	c0010efc <XAxiDma_Selftest+0xa4>

		if(XAxiDma_ResetIsDone(InstancePtr)) {
c0010ebc:	fdc42503          	lw	a0,-36(s0)
c0010ec0:	bacff0ef          	jal	ra,c001026c <XAxiDma_ResetIsDone>
c0010ec4:	00050793          	mv	a5,a0
c0010ec8:	00079e63          	bnez	a5,c0010ee4 <XAxiDma_Selftest+0x8c>
			break;
		}

		TimeOut -= 1;
c0010ecc:	fec42783          	lw	a5,-20(s0)
c0010ed0:	fff78793          	addi	a5,a5,-1
c0010ed4:	fef42623          	sw	a5,-20(s0)
	while (TimeOut) {
c0010ed8:	fec42783          	lw	a5,-20(s0)
c0010edc:	fe0790e3          	bnez	a5,c0010ebc <XAxiDma_Selftest+0x64>
c0010ee0:	0080006f          	j	c0010ee8 <XAxiDma_Selftest+0x90>
			break;
c0010ee4:	00000013          	nop

	}

	if (!TimeOut)
c0010ee8:	fec42783          	lw	a5,-20(s0)
c0010eec:	00079663          	bnez	a5,c0010ef8 <XAxiDma_Selftest+0xa0>
		return XST_FAILURE;
c0010ef0:	00100793          	li	a5,1
c0010ef4:	0080006f          	j	c0010efc <XAxiDma_Selftest+0xa4>

	return XST_SUCCESS;
c0010ef8:	00000793          	li	a5,0
}
c0010efc:	00078513          	mv	a0,a5
c0010f00:	02c12083          	lw	ra,44(sp)
c0010f04:	02812403          	lw	s0,40(sp)
c0010f08:	03010113          	addi	sp,sp,48
c0010f0c:	00008067          	ret

c0010f10 <XAxiDma_LookupConfig>:
 *
 * @note	None
 *
 ******************************************************************************/
XAxiDma_Config *XAxiDma_LookupConfig(u32 DeviceId)
{
c0010f10:	fd010113          	addi	sp,sp,-48
c0010f14:	02812623          	sw	s0,44(sp)
c0010f18:	03010413          	addi	s0,sp,48
c0010f1c:	fca42e23          	sw	a0,-36(s0)
	extern XAxiDma_Config XAxiDma_ConfigTable[];
	XAxiDma_Config *CfgPtr;
	u32 Index;

	CfgPtr = NULL;
c0010f20:	fe042623          	sw	zero,-20(s0)

	for (Index = 0; Index < XPAR_XAXIDMA_NUM_INSTANCES; Index++) {
c0010f24:	fe042423          	sw	zero,-24(s0)
c0010f28:	0640006f          	j	c0010f8c <XAxiDma_LookupConfig+0x7c>
		if (XAxiDma_ConfigTable[Index].DeviceId == DeviceId) {
c0010f2c:	07ff2697          	auipc	a3,0x7ff2
c0010f30:	b2c68693          	addi	a3,a3,-1236 # c8002a58 <XAxiDma_ConfigTable>
c0010f34:	fe842703          	lw	a4,-24(s0)
c0010f38:	00070793          	mv	a5,a4
c0010f3c:	00479793          	slli	a5,a5,0x4
c0010f40:	00e787b3          	add	a5,a5,a4
c0010f44:	00279793          	slli	a5,a5,0x2
c0010f48:	00f687b3          	add	a5,a3,a5
c0010f4c:	0007a783          	lw	a5,0(a5)
c0010f50:	fdc42703          	lw	a4,-36(s0)
c0010f54:	02f71663          	bne	a4,a5,c0010f80 <XAxiDma_LookupConfig+0x70>

			CfgPtr = &XAxiDma_ConfigTable[Index];
c0010f58:	fe842703          	lw	a4,-24(s0)
c0010f5c:	00070793          	mv	a5,a4
c0010f60:	00479793          	slli	a5,a5,0x4
c0010f64:	00e787b3          	add	a5,a5,a4
c0010f68:	00279793          	slli	a5,a5,0x2
c0010f6c:	07ff2717          	auipc	a4,0x7ff2
c0010f70:	aec70713          	addi	a4,a4,-1300 # c8002a58 <XAxiDma_ConfigTable>
c0010f74:	00e787b3          	add	a5,a5,a4
c0010f78:	fef42623          	sw	a5,-20(s0)
			break;
c0010f7c:	0180006f          	j	c0010f94 <XAxiDma_LookupConfig+0x84>
	for (Index = 0; Index < XPAR_XAXIDMA_NUM_INSTANCES; Index++) {
c0010f80:	fe842783          	lw	a5,-24(s0)
c0010f84:	00178793          	addi	a5,a5,1
c0010f88:	fef42423          	sw	a5,-24(s0)
c0010f8c:	fe842783          	lw	a5,-24(s0)
c0010f90:	f8078ee3          	beqz	a5,c0010f2c <XAxiDma_LookupConfig+0x1c>
		}
	}

	return CfgPtr;
c0010f94:	fec42783          	lw	a5,-20(s0)
}
c0010f98:	00078513          	mv	a0,a5
c0010f9c:	02c12403          	lw	s0,44(sp)
c0010fa0:	03010113          	addi	sp,sp,48
c0010fa4:	00008067          	ret

c0010fa8 <XAxiDma_LookupConfigBaseAddr>:
 *
 * @note	None
 *
 ******************************************************************************/
XAxiDma_Config *XAxiDma_LookupConfigBaseAddr(UINTPTR Baseaddr)
{
c0010fa8:	fd010113          	addi	sp,sp,-48
c0010fac:	02812623          	sw	s0,44(sp)
c0010fb0:	03010413          	addi	s0,sp,48
c0010fb4:	fca42e23          	sw	a0,-36(s0)
	extern XAxiDma_Config XAxiDma_ConfigTable[];
	XAxiDma_Config *CfgPtr;
	u32 Index;

	CfgPtr = NULL;
c0010fb8:	fe042623          	sw	zero,-20(s0)

	for (Index = 0; Index < XPAR_XAXIDMA_NUM_INSTANCES; Index++) {
c0010fbc:	fe042423          	sw	zero,-24(s0)
c0010fc0:	0640006f          	j	c0011024 <XAxiDma_LookupConfigBaseAddr+0x7c>
		if (XAxiDma_ConfigTable[Index].BaseAddr == Baseaddr) {
c0010fc4:	07ff2697          	auipc	a3,0x7ff2
c0010fc8:	a9468693          	addi	a3,a3,-1388 # c8002a58 <XAxiDma_ConfigTable>
c0010fcc:	fe842703          	lw	a4,-24(s0)
c0010fd0:	00070793          	mv	a5,a4
c0010fd4:	00479793          	slli	a5,a5,0x4
c0010fd8:	00e787b3          	add	a5,a5,a4
c0010fdc:	00279793          	slli	a5,a5,0x2
c0010fe0:	00f687b3          	add	a5,a3,a5
c0010fe4:	0047a783          	lw	a5,4(a5)
c0010fe8:	fdc42703          	lw	a4,-36(s0)
c0010fec:	02f71663          	bne	a4,a5,c0011018 <XAxiDma_LookupConfigBaseAddr+0x70>

			CfgPtr = &XAxiDma_ConfigTable[Index];
c0010ff0:	fe842703          	lw	a4,-24(s0)
c0010ff4:	00070793          	mv	a5,a4
c0010ff8:	00479793          	slli	a5,a5,0x4
c0010ffc:	00e787b3          	add	a5,a5,a4
c0011000:	00279793          	slli	a5,a5,0x2
c0011004:	07ff2717          	auipc	a4,0x7ff2
c0011008:	a5470713          	addi	a4,a4,-1452 # c8002a58 <XAxiDma_ConfigTable>
c001100c:	00e787b3          	add	a5,a5,a4
c0011010:	fef42623          	sw	a5,-20(s0)
			break;
c0011014:	0180006f          	j	c001102c <XAxiDma_LookupConfigBaseAddr+0x84>
	for (Index = 0; Index < XPAR_XAXIDMA_NUM_INSTANCES; Index++) {
c0011018:	fe842783          	lw	a5,-24(s0)
c001101c:	00178793          	addi	a5,a5,1
c0011020:	fef42423          	sw	a5,-24(s0)
c0011024:	fe842783          	lw	a5,-24(s0)
c0011028:	f8078ee3          	beqz	a5,c0010fc4 <XAxiDma_LookupConfigBaseAddr+0x1c>
		}
	}

	return CfgPtr;
c001102c:	fec42783          	lw	a5,-20(s0)
}
c0011030:	00078513          	mv	a0,a5
c0011034:	02c12403          	lw	s0,44(sp)
c0011038:	03010113          	addi	sp,sp,48
c001103c:	00008067          	ret

c0011040 <Xil_In32>:
{
c0011040:	fe010113          	addi	sp,sp,-32
c0011044:	00812e23          	sw	s0,28(sp)
c0011048:	02010413          	addi	s0,sp,32
c001104c:	fea42623          	sw	a0,-20(s0)
	return *(volatile u32 *) Addr;
c0011050:	fec42783          	lw	a5,-20(s0)
c0011054:	0007a783          	lw	a5,0(a5)
}
c0011058:	00078513          	mv	a0,a5
c001105c:	01c12403          	lw	s0,28(sp)
c0011060:	02010113          	addi	sp,sp,32
c0011064:	00008067          	ret

c0011068 <Xil_Out32>:
{
c0011068:	fd010113          	addi	sp,sp,-48
c001106c:	02812623          	sw	s0,44(sp)
c0011070:	03010413          	addi	s0,sp,48
c0011074:	fca42e23          	sw	a0,-36(s0)
c0011078:	fcb42c23          	sw	a1,-40(s0)
	volatile u32 *LocalAddr = (volatile u32 *)Addr;
c001107c:	fdc42783          	lw	a5,-36(s0)
c0011080:	fef42623          	sw	a5,-20(s0)
	*LocalAddr = Value;
c0011084:	fec42783          	lw	a5,-20(s0)
c0011088:	fd842703          	lw	a4,-40(s0)
c001108c:	00e7a023          	sw	a4,0(a5)
}
c0011090:	00000013          	nop
c0011094:	02c12403          	lw	s0,44(sp)
c0011098:	03010113          	addi	sp,sp,48
c001109c:	00008067          	ret

c00110a0 <XAxiEthernet_CfgInitialize>:
*
******************************************************************************/
int XAxiEthernet_CfgInitialize(XAxiEthernet *InstancePtr,
				XAxiEthernet_Config *CfgPtr,
				UINTPTR EffectiveAddress)
{
c00110a0:	fe010113          	addi	sp,sp,-32
c00110a4:	00112e23          	sw	ra,28(sp)
c00110a8:	00812c23          	sw	s0,24(sp)
c00110ac:	02010413          	addi	s0,sp,32
c00110b0:	fea42623          	sw	a0,-20(s0)
c00110b4:	feb42423          	sw	a1,-24(s0)
c00110b8:	fec42223          	sw	a2,-28(s0)
	/* Verify arguments */
	Xil_AssertNonvoid(InstancePtr != NULL);
c00110bc:	fec42783          	lw	a5,-20(s0)
c00110c0:	06078063          	beqz	a5,c0011120 <XAxiEthernet_CfgInitialize+0x80>
c00110c4:	07ff2797          	auipc	a5,0x7ff2
c00110c8:	85078793          	addi	a5,a5,-1968 # c8002914 <Xil_AssertStatus>
c00110cc:	0007a023          	sw	zero,0(a5)

	/* Clear instance memory and make copy of configuration */
	memset(InstancePtr, 0, sizeof(XAxiEthernet));
c00110d0:	05c00613          	li	a2,92
c00110d4:	00000593          	li	a1,0
c00110d8:	fec42503          	lw	a0,-20(s0)
c00110dc:	3ad0c0ef          	jal	ra,c001dc88 <memset>
	memcpy(&InstancePtr->Config, CfgPtr, sizeof(XAxiEthernet_Config));
c00110e0:	fec42783          	lw	a5,-20(s0)
c00110e4:	04c00613          	li	a2,76
c00110e8:	fe842583          	lw	a1,-24(s0)
c00110ec:	00078513          	mv	a0,a5
c00110f0:	2710c0ef          	jal	ra,c001db60 <memcpy>

	xaxi_debug_printf("XAxiEthernet_CfgInitialize\r\n");

	/* Set device base address */
	InstancePtr->Config.BaseAddress = EffectiveAddress;
c00110f4:	fec42783          	lw	a5,-20(s0)
c00110f8:	fe442703          	lw	a4,-28(s0)
c00110fc:	00e7a223          	sw	a4,4(a5)

	/* Reset the hardware and set default options */
	InstancePtr->IsReady = XIL_COMPONENT_IS_READY;
c0011100:	fec42783          	lw	a5,-20(s0)
c0011104:	11111737          	lui	a4,0x11111
c0011108:	11170713          	addi	a4,a4,273 # 11111111 <_DMEM_LENGTH+0x10911111>
c001110c:	04e7a823          	sw	a4,80(a5)

	XAxiEthernet_Reset(InstancePtr);
c0011110:	fec42503          	lw	a0,-20(s0)
c0011114:	3cc000ef          	jal	ra,c00114e0 <XAxiEthernet_Reset>

	xaxi_debug_printf("AxiTEthernet_CfgInitialize: returning SUCCESS\r\n");
	return XST_SUCCESS;
c0011118:	00000793          	li	a5,0
c001111c:	0280006f          	j	c0011144 <XAxiEthernet_CfgInitialize+0xa4>
	Xil_AssertNonvoid(InstancePtr != NULL);
c0011120:	09b00593          	li	a1,155
c0011124:	07ff0517          	auipc	a0,0x7ff0
c0011128:	c9850513          	addi	a0,a0,-872 # c8000dbc <__rodata_start+0xdbc>
c001112c:	1910c0ef          	jal	ra,c001dabc <Xil_Assert>
c0011130:	07ff1797          	auipc	a5,0x7ff1
c0011134:	7e478793          	addi	a5,a5,2020 # c8002914 <Xil_AssertStatus>
c0011138:	00100713          	li	a4,1
c001113c:	00e7a023          	sw	a4,0(a5)
c0011140:	00000793          	li	a5,0
}
c0011144:	00078513          	mv	a0,a5
c0011148:	01c12083          	lw	ra,28(sp)
c001114c:	01812403          	lw	s0,24(sp)
c0011150:	02010113          	addi	sp,sp,32
c0011154:	00008067          	ret

c0011158 <XAxiEthernet_Initialize>:
*
******************************************************************************/
int XAxiEthernet_Initialize(XAxiEthernet *InstancePtr,
			    XAxiEthernet_Config *CfgPtr,
			    UINTPTR EffectiveAddress)
{
c0011158:	fe010113          	addi	sp,sp,-32
c001115c:	00112e23          	sw	ra,28(sp)
c0011160:	00812c23          	sw	s0,24(sp)
c0011164:	02010413          	addi	s0,sp,32
c0011168:	fea42623          	sw	a0,-20(s0)
c001116c:	feb42423          	sw	a1,-24(s0)
c0011170:	fec42223          	sw	a2,-28(s0)
	/* Verify arguments */
	Xil_AssertNonvoid(InstancePtr != NULL);
c0011174:	fec42783          	lw	a5,-20(s0)
c0011178:	04078c63          	beqz	a5,c00111d0 <XAxiEthernet_Initialize+0x78>
c001117c:	07ff1797          	auipc	a5,0x7ff1
c0011180:	79878793          	addi	a5,a5,1944 # c8002914 <Xil_AssertStatus>
c0011184:	0007a023          	sw	zero,0(a5)

	/* Clear instance memory and make copy of configuration */
	memset(InstancePtr, 0, sizeof(XAxiEthernet));
c0011188:	05c00613          	li	a2,92
c001118c:	00000593          	li	a1,0
c0011190:	fec42503          	lw	a0,-20(s0)
c0011194:	2f50c0ef          	jal	ra,c001dc88 <memset>
	memcpy(&InstancePtr->Config, CfgPtr, sizeof(XAxiEthernet_Config));
c0011198:	fec42783          	lw	a5,-20(s0)
c001119c:	04c00613          	li	a2,76
c00111a0:	fe842583          	lw	a1,-24(s0)
c00111a4:	00078513          	mv	a0,a5
c00111a8:	1b90c0ef          	jal	ra,c001db60 <memcpy>

	xaxi_debug_printf("XAxiEthernet_CfgInitialize\r\n");

	/* Set device base address */
	InstancePtr->Config.BaseAddress = EffectiveAddress;
c00111ac:	fec42783          	lw	a5,-20(s0)
c00111b0:	fe442703          	lw	a4,-28(s0)
c00111b4:	00e7a223          	sw	a4,4(a5)

	/* Set default options */
	InstancePtr->IsReady = XIL_COMPONENT_IS_READY;
c00111b8:	fec42783          	lw	a5,-20(s0)
c00111bc:	11111737          	lui	a4,0x11111
c00111c0:	11170713          	addi	a4,a4,273 # 11111111 <_DMEM_LENGTH+0x10911111>
c00111c4:	04e7a823          	sw	a4,80(a5)

	return XST_SUCCESS;
c00111c8:	00000793          	li	a5,0
c00111cc:	0280006f          	j	c00111f4 <XAxiEthernet_Initialize+0x9c>
	Xil_AssertNonvoid(InstancePtr != NULL);
c00111d0:	0d100593          	li	a1,209
c00111d4:	07ff0517          	auipc	a0,0x7ff0
c00111d8:	be850513          	addi	a0,a0,-1048 # c8000dbc <__rodata_start+0xdbc>
c00111dc:	0e10c0ef          	jal	ra,c001dabc <Xil_Assert>
c00111e0:	07ff1797          	auipc	a5,0x7ff1
c00111e4:	73478793          	addi	a5,a5,1844 # c8002914 <Xil_AssertStatus>
c00111e8:	00100713          	li	a4,1
c00111ec:	00e7a023          	sw	a4,0(a5)
c00111f0:	00000793          	li	a5,0
}
c00111f4:	00078513          	mv	a0,a5
c00111f8:	01c12083          	lw	ra,28(sp)
c00111fc:	01812403          	lw	s0,24(sp)
c0011200:	02010113          	addi	sp,sp,32
c0011204:	00008067          	ret

c0011208 <XAxiEthernet_Start>:
* @note		None.
*
*
******************************************************************************/
void XAxiEthernet_Start(XAxiEthernet *InstancePtr)
{
c0011208:	fd010113          	addi	sp,sp,-48
c001120c:	02112623          	sw	ra,44(sp)
c0011210:	02812423          	sw	s0,40(sp)
c0011214:	03010413          	addi	s0,sp,48
c0011218:	fca42e23          	sw	a0,-36(s0)
	u32 Reg;

	/* Assert bad arguments and conditions */
	Xil_AssertVoid(InstancePtr != NULL);
c001121c:	fdc42783          	lw	a5,-36(s0)
c0011220:	02078463          	beqz	a5,c0011248 <XAxiEthernet_Start+0x40>
c0011224:	07ff1797          	auipc	a5,0x7ff1
c0011228:	6f078793          	addi	a5,a5,1776 # c8002914 <Xil_AssertStatus>
c001122c:	0007a023          	sw	zero,0(a5)
	Xil_AssertVoid(InstancePtr->IsReady == XIL_COMPONENT_IS_READY);
c0011230:	fdc42783          	lw	a5,-36(s0)
c0011234:	0507a703          	lw	a4,80(a5)
c0011238:	111117b7          	lui	a5,0x11111
c001123c:	11178793          	addi	a5,a5,273 # 11111111 <_DMEM_LENGTH+0x10911111>
c0011240:	04f71863          	bne	a4,a5,c0011290 <XAxiEthernet_Start+0x88>
c0011244:	0280006f          	j	c001126c <XAxiEthernet_Start+0x64>
	Xil_AssertVoid(InstancePtr != NULL);
c0011248:	0f500593          	li	a1,245
c001124c:	07ff0517          	auipc	a0,0x7ff0
c0011250:	b7050513          	addi	a0,a0,-1168 # c8000dbc <__rodata_start+0xdbc>
c0011254:	0690c0ef          	jal	ra,c001dabc <Xil_Assert>
c0011258:	07ff1797          	auipc	a5,0x7ff1
c001125c:	6bc78793          	addi	a5,a5,1724 # c8002914 <Xil_AssertStatus>
c0011260:	00100713          	li	a4,1
c0011264:	00e7a023          	sw	a4,0(a5)
c0011268:	1140006f          	j	c001137c <XAxiEthernet_Start+0x174>
	Xil_AssertVoid(InstancePtr->IsReady == XIL_COMPONENT_IS_READY);
c001126c:	07ff1797          	auipc	a5,0x7ff1
c0011270:	6a878793          	addi	a5,a5,1704 # c8002914 <Xil_AssertStatus>
c0011274:	0007a023          	sw	zero,0(a5)


	/* If already started, then there is nothing to do */
	if (InstancePtr->IsStarted == XIL_COMPONENT_IS_STARTED) {
c0011278:	fdc42783          	lw	a5,-36(s0)
c001127c:	04c7a703          	lw	a4,76(a5)
c0011280:	222227b7          	lui	a5,0x22222
c0011284:	22278793          	addi	a5,a5,546 # 22222222 <_DMEM_LENGTH+0x21a22222>
c0011288:	02f71663          	bne	a4,a5,c00112b4 <XAxiEthernet_Start+0xac>
		return;
c001128c:	0f00006f          	j	c001137c <XAxiEthernet_Start+0x174>
	Xil_AssertVoid(InstancePtr->IsReady == XIL_COMPONENT_IS_READY);
c0011290:	0f600593          	li	a1,246
c0011294:	07ff0517          	auipc	a0,0x7ff0
c0011298:	b2850513          	addi	a0,a0,-1240 # c8000dbc <__rodata_start+0xdbc>
c001129c:	0210c0ef          	jal	ra,c001dabc <Xil_Assert>
c00112a0:	07ff1797          	auipc	a5,0x7ff1
c00112a4:	67478793          	addi	a5,a5,1652 # c8002914 <Xil_AssertStatus>
c00112a8:	00100713          	li	a4,1
c00112ac:	00e7a023          	sw	a4,0(a5)
c00112b0:	0cc0006f          	j	c001137c <XAxiEthernet_Start+0x174>
	}

	xaxi_debug_printf("XAxiEthernet_Start\r\n");

	/* Enable transmitter if not already enabled */
	if (InstancePtr->Options & XAE_TRANSMITTER_ENABLE_OPTION) {
c00112b4:	fdc42783          	lw	a5,-36(s0)
c00112b8:	0547a783          	lw	a5,84(a5)
c00112bc:	0807f793          	andi	a5,a5,128
c00112c0:	04078863          	beqz	a5,c0011310 <XAxiEthernet_Start+0x108>
		xaxi_debug_printf("enabling transmitter\r\n");
		Reg = XAxiEthernet_ReadReg(InstancePtr->Config.BaseAddress,
c00112c4:	fdc42783          	lw	a5,-36(s0)
c00112c8:	0047a783          	lw	a5,4(a5)
c00112cc:	40878793          	addi	a5,a5,1032
c00112d0:	00078513          	mv	a0,a5
c00112d4:	d6dff0ef          	jal	ra,c0011040 <Xil_In32>
c00112d8:	fea42623          	sw	a0,-20(s0)
							XAE_TC_OFFSET);
		if (!(Reg & XAE_TC_TX_MASK)) {
c00112dc:	fec42703          	lw	a4,-20(s0)
c00112e0:	100007b7          	lui	a5,0x10000
c00112e4:	00f777b3          	and	a5,a4,a5
c00112e8:	02079463          	bnez	a5,c0011310 <XAxiEthernet_Start+0x108>
			xaxi_debug_printf(
				"transmitter not enabled, enabling now\r\n");
			XAxiEthernet_WriteReg(InstancePtr->Config.BaseAddress,
c00112ec:	fdc42783          	lw	a5,-36(s0)
c00112f0:	0047a783          	lw	a5,4(a5) # 10000004 <_DMEM_LENGTH+0xf800004>
c00112f4:	40878693          	addi	a3,a5,1032
c00112f8:	fec42703          	lw	a4,-20(s0)
c00112fc:	100007b7          	lui	a5,0x10000
c0011300:	00f767b3          	or	a5,a4,a5
c0011304:	00078593          	mv	a1,a5
c0011308:	00068513          	mv	a0,a3
c001130c:	d5dff0ef          	jal	ra,c0011068 <Xil_Out32>
		}
		xaxi_debug_printf("transmitter enabled\r\n");
	}

	/* Enable receiver */
	if (InstancePtr->Options & XAE_RECEIVER_ENABLE_OPTION) {
c0011310:	fdc42783          	lw	a5,-36(s0)
c0011314:	0547a783          	lw	a5,84(a5) # 10000054 <_DMEM_LENGTH+0xf800054>
c0011318:	1007f793          	andi	a5,a5,256
c001131c:	04078863          	beqz	a5,c001136c <XAxiEthernet_Start+0x164>
		xaxi_debug_printf("enabling receiver\r\n");
		Reg = XAxiEthernet_ReadReg(InstancePtr->Config.BaseAddress,
c0011320:	fdc42783          	lw	a5,-36(s0)
c0011324:	0047a783          	lw	a5,4(a5)
c0011328:	40478793          	addi	a5,a5,1028
c001132c:	00078513          	mv	a0,a5
c0011330:	d11ff0ef          	jal	ra,c0011040 <Xil_In32>
c0011334:	fea42623          	sw	a0,-20(s0)
							XAE_RCW1_OFFSET);
		if (!(Reg & XAE_RCW1_RX_MASK)) {
c0011338:	fec42703          	lw	a4,-20(s0)
c001133c:	100007b7          	lui	a5,0x10000
c0011340:	00f777b3          	and	a5,a4,a5
c0011344:	02079463          	bnez	a5,c001136c <XAxiEthernet_Start+0x164>
			xaxi_debug_printf(
				"receiver not enabled, enabling now\r\n");

			XAxiEthernet_WriteReg(InstancePtr->Config.BaseAddress,
c0011348:	fdc42783          	lw	a5,-36(s0)
c001134c:	0047a783          	lw	a5,4(a5) # 10000004 <_DMEM_LENGTH+0xf800004>
c0011350:	40478693          	addi	a3,a5,1028
c0011354:	fec42703          	lw	a4,-20(s0)
c0011358:	100007b7          	lui	a5,0x10000
c001135c:	00f767b3          	or	a5,a4,a5
c0011360:	00078593          	mv	a1,a5
c0011364:	00068513          	mv	a0,a3
c0011368:	d01ff0ef          	jal	ra,c0011068 <Xil_Out32>
		}
		xaxi_debug_printf("receiver enabled\r\n");
	}

	/* Mark as started */
	InstancePtr->IsStarted = XIL_COMPONENT_IS_STARTED;
c001136c:	fdc42783          	lw	a5,-36(s0)
c0011370:	22222737          	lui	a4,0x22222
c0011374:	22270713          	addi	a4,a4,546 # 22222222 <_DMEM_LENGTH+0x21a22222>
c0011378:	04e7a623          	sw	a4,76(a5) # 1000004c <_DMEM_LENGTH+0xf80004c>
	xaxi_debug_printf("XAxiEthernet_Start: done\r\n");
}
c001137c:	02c12083          	lw	ra,44(sp)
c0011380:	02812403          	lw	s0,40(sp)
c0011384:	03010113          	addi	sp,sp,48
c0011388:	00008067          	ret

c001138c <XAxiEthernet_Stop>:
* @note		None.
*
*
******************************************************************************/
void XAxiEthernet_Stop(XAxiEthernet *InstancePtr)
{
c001138c:	fd010113          	addi	sp,sp,-48
c0011390:	02112623          	sw	ra,44(sp)
c0011394:	02812423          	sw	s0,40(sp)
c0011398:	03010413          	addi	s0,sp,48
c001139c:	fca42e23          	sw	a0,-36(s0)
	xaxi_debug_printf("XAxiEthernet_Stop\r\n");
	u32 Reg;

	Xil_AssertVoid(InstancePtr != NULL);
c00113a0:	fdc42783          	lw	a5,-36(s0)
c00113a4:	02078463          	beqz	a5,c00113cc <XAxiEthernet_Stop+0x40>
c00113a8:	07ff1797          	auipc	a5,0x7ff1
c00113ac:	56c78793          	addi	a5,a5,1388 # c8002914 <Xil_AssertStatus>
c00113b0:	0007a023          	sw	zero,0(a5)
	Xil_AssertVoid(InstancePtr->IsReady == XIL_COMPONENT_IS_READY);
c00113b4:	fdc42783          	lw	a5,-36(s0)
c00113b8:	0507a703          	lw	a4,80(a5)
c00113bc:	111117b7          	lui	a5,0x11111
c00113c0:	11178793          	addi	a5,a5,273 # 11111111 <_DMEM_LENGTH+0x10911111>
c00113c4:	04f71463          	bne	a4,a5,c001140c <XAxiEthernet_Stop+0x80>
c00113c8:	0280006f          	j	c00113f0 <XAxiEthernet_Stop+0x64>
	Xil_AssertVoid(InstancePtr != NULL);
c00113cc:	13c00593          	li	a1,316
c00113d0:	07ff0517          	auipc	a0,0x7ff0
c00113d4:	9ec50513          	addi	a0,a0,-1556 # c8000dbc <__rodata_start+0xdbc>
c00113d8:	6e40c0ef          	jal	ra,c001dabc <Xil_Assert>
c00113dc:	07ff1797          	auipc	a5,0x7ff1
c00113e0:	53878793          	addi	a5,a5,1336 # c8002914 <Xil_AssertStatus>
c00113e4:	00100713          	li	a4,1
c00113e8:	00e7a023          	sw	a4,0(a5)
c00113ec:	0e40006f          	j	c00114d0 <XAxiEthernet_Stop+0x144>
	Xil_AssertVoid(InstancePtr->IsReady == XIL_COMPONENT_IS_READY);
c00113f0:	07ff1797          	auipc	a5,0x7ff1
c00113f4:	52478793          	addi	a5,a5,1316 # c8002914 <Xil_AssertStatus>
c00113f8:	0007a023          	sw	zero,0(a5)


	/* If already stopped, then there is nothing to do */
	if (InstancePtr->IsStarted == 0) {
c00113fc:	fdc42783          	lw	a5,-36(s0)
c0011400:	04c7a783          	lw	a5,76(a5)
c0011404:	02079663          	bnez	a5,c0011430 <XAxiEthernet_Stop+0xa4>
		return;
c0011408:	0c80006f          	j	c00114d0 <XAxiEthernet_Stop+0x144>
	Xil_AssertVoid(InstancePtr->IsReady == XIL_COMPONENT_IS_READY);
c001140c:	13d00593          	li	a1,317
c0011410:	07ff0517          	auipc	a0,0x7ff0
c0011414:	9ac50513          	addi	a0,a0,-1620 # c8000dbc <__rodata_start+0xdbc>
c0011418:	6a40c0ef          	jal	ra,c001dabc <Xil_Assert>
c001141c:	07ff1797          	auipc	a5,0x7ff1
c0011420:	4f878793          	addi	a5,a5,1272 # c8002914 <Xil_AssertStatus>
c0011424:	00100713          	li	a4,1
c0011428:	00e7a023          	sw	a4,0(a5)
c001142c:	0a40006f          	j	c00114d0 <XAxiEthernet_Stop+0x144>

	xaxi_debug_printf("XAxiEthernet_Stop\r\n");
	xaxi_debug_printf("XAxiEthernet_Stop: disabling interrupts\r\n");

	/* Disable interrupts */
	XAxiEthernet_WriteReg(InstancePtr->Config.BaseAddress,
c0011430:	fdc42783          	lw	a5,-36(s0)
c0011434:	0047a783          	lw	a5,4(a5)
c0011438:	01478793          	addi	a5,a5,20
c001143c:	00000593          	li	a1,0
c0011440:	00078513          	mv	a0,a5
c0011444:	c25ff0ef          	jal	ra,c0011068 <Xil_Out32>
							XAE_IE_OFFSET, 0);

	xaxi_debug_printf("XAxiEthernet_Stop: disabling receiver\r\n");

	/* Disable the receiver */
	Reg = XAxiEthernet_ReadReg(InstancePtr->Config.BaseAddress,
c0011448:	fdc42783          	lw	a5,-36(s0)
c001144c:	0047a783          	lw	a5,4(a5)
c0011450:	40478793          	addi	a5,a5,1028
c0011454:	00078513          	mv	a0,a5
c0011458:	be9ff0ef          	jal	ra,c0011040 <Xil_In32>
c001145c:	fea42623          	sw	a0,-20(s0)
							XAE_RCW1_OFFSET);
	Reg &= ~XAE_RCW1_RX_MASK;
c0011460:	fec42703          	lw	a4,-20(s0)
c0011464:	f00007b7          	lui	a5,0xf0000
c0011468:	fff78793          	addi	a5,a5,-1 # efffffff <_end+0x27f7b77f>
c001146c:	00f777b3          	and	a5,a4,a5
c0011470:	fef42623          	sw	a5,-20(s0)
	XAxiEthernet_WriteReg(InstancePtr->Config.BaseAddress,
c0011474:	fdc42783          	lw	a5,-36(s0)
c0011478:	0047a783          	lw	a5,4(a5)
c001147c:	40478793          	addi	a5,a5,1028
c0011480:	fec42583          	lw	a1,-20(s0)
c0011484:	00078513          	mv	a0,a5
c0011488:	be1ff0ef          	jal	ra,c0011068 <Xil_Out32>
	/*
	 * Stopping the receiver in mid-packet causes a dropped packet
	 * indication from HW. Clear it.
	 */
	/* get the interrupt pending register */
	Reg = XAxiEthernet_ReadReg(InstancePtr->Config.BaseAddress,
c001148c:	fdc42783          	lw	a5,-36(s0)
c0011490:	0047a783          	lw	a5,4(a5)
c0011494:	01078793          	addi	a5,a5,16
c0011498:	00078513          	mv	a0,a5
c001149c:	ba5ff0ef          	jal	ra,c0011040 <Xil_In32>
c00114a0:	fea42623          	sw	a0,-20(s0)
							XAE_IP_OFFSET);
	if (Reg & XAE_INT_RXRJECT_MASK) {
c00114a4:	fec42783          	lw	a5,-20(s0)
c00114a8:	0087f793          	andi	a5,a5,8
c00114ac:	00078e63          	beqz	a5,c00114c8 <XAxiEthernet_Stop+0x13c>
		/* set the interrupt status register to clear the interrupt */
		XAxiEthernet_WriteReg(InstancePtr->Config.BaseAddress,
c00114b0:	fdc42783          	lw	a5,-36(s0)
c00114b4:	0047a783          	lw	a5,4(a5)
c00114b8:	00c78793          	addi	a5,a5,12
c00114bc:	00800593          	li	a1,8
c00114c0:	00078513          	mv	a0,a5
c00114c4:	ba5ff0ef          	jal	ra,c0011068 <Xil_Out32>
				XAE_IS_OFFSET, XAE_INT_RXRJECT_MASK);
	}

	/* Mark as stopped */
	InstancePtr->IsStarted = 0;
c00114c8:	fdc42783          	lw	a5,-36(s0)
c00114cc:	0407a623          	sw	zero,76(a5)
	xaxi_debug_printf("XAxiEthernet_Stop: done\r\n");
}
c00114d0:	02c12083          	lw	ra,44(sp)
c00114d4:	02812403          	lw	s0,40(sp)
c00114d8:	03010113          	addi	sp,sp,48
c00114dc:	00008067          	ret

c00114e0 <XAxiEthernet_Reset>:
*		through the device connected to the AXI4-Stream interface of
*		AxiEthernet.
*
******************************************************************************/
void XAxiEthernet_Reset(XAxiEthernet *InstancePtr)
{
c00114e0:	fd010113          	addi	sp,sp,-48
c00114e4:	02112623          	sw	ra,44(sp)
c00114e8:	02812423          	sw	s0,40(sp)
c00114ec:	03010413          	addi	s0,sp,48
c00114f0:	fca42e23          	sw	a0,-36(s0)
	volatile s32 TimeoutLoops;
	u32 value=0U;
c00114f4:	fe042223          	sw	zero,-28(s0)

	Xil_AssertVoid(InstancePtr != NULL);
c00114f8:	fdc42783          	lw	a5,-36(s0)
c00114fc:	02078463          	beqz	a5,c0011524 <XAxiEthernet_Reset+0x44>
c0011500:	07ff1797          	auipc	a5,0x7ff1
c0011504:	41478793          	addi	a5,a5,1044 # c8002914 <Xil_AssertStatus>
c0011508:	0007a023          	sw	zero,0(a5)
	Xil_AssertVoid(InstancePtr->IsReady == XIL_COMPONENT_IS_READY);
c001150c:	fdc42783          	lw	a5,-36(s0)
c0011510:	0507a703          	lw	a4,80(a5)
c0011514:	111117b7          	lui	a5,0x11111
c0011518:	11178793          	addi	a5,a5,273 # 11111111 <_DMEM_LENGTH+0x10911111>
c001151c:	04f71c63          	bne	a4,a5,c0011574 <XAxiEthernet_Reset+0x94>
c0011520:	0280006f          	j	c0011548 <XAxiEthernet_Reset+0x68>
	Xil_AssertVoid(InstancePtr != NULL);
c0011524:	18200593          	li	a1,386
c0011528:	07ff0517          	auipc	a0,0x7ff0
c001152c:	89450513          	addi	a0,a0,-1900 # c8000dbc <__rodata_start+0xdbc>
c0011530:	58c0c0ef          	jal	ra,c001dabc <Xil_Assert>
c0011534:	07ff1797          	auipc	a5,0x7ff1
c0011538:	3e078793          	addi	a5,a5,992 # c8002914 <Xil_AssertStatus>
c001153c:	00100713          	li	a4,1
c0011540:	00e7a023          	sw	a4,0(a5)
c0011544:	1340006f          	j	c0011678 <XAxiEthernet_Reset+0x198>
	Xil_AssertVoid(InstancePtr->IsReady == XIL_COMPONENT_IS_READY);
c0011548:	07ff1797          	auipc	a5,0x7ff1
c001154c:	3cc78793          	addi	a5,a5,972 # c8002914 <Xil_AssertStatus>
c0011550:	0007a023          	sw	zero,0(a5)
	/*
	 * Add delay of 1 sec to give enough time to the core to come
	 * out of reset. Till the time core comes out of reset none of the
	 * AxiEthernet registers are accessible including the IS register.
	 */
	sleep(1);
c0011554:	3e800513          	li	a0,1000
c0011558:	81df10ef          	jal	ra,c0002d74 <vTaskDelay>
	 * registers. This must be done to allow the MGT clock to become stable
	 * for the Sgmii and 1000BaseX PHY interfaces. No other register reads
	 * will be valid until this bit is valid.
	 * The bit is always a 1 for all other PHY interfaces.
	 */
	TimeoutLoops = Xil_poll_timeout(Xil_In32,InstancePtr->Config.BaseAddress+
c001155c:	00002737          	lui	a4,0x2
c0011560:	71070713          	addi	a4,a4,1808 # 2710 <_STACK_SIZE+0x1710>
c0011564:	00000793          	li	a5,0
c0011568:	fee42423          	sw	a4,-24(s0)
c001156c:	fef42623          	sw	a5,-20(s0)
c0011570:	0280006f          	j	c0011598 <XAxiEthernet_Reset+0xb8>
	Xil_AssertVoid(InstancePtr->IsReady == XIL_COMPONENT_IS_READY);
c0011574:	18300593          	li	a1,387
c0011578:	07ff0517          	auipc	a0,0x7ff0
c001157c:	84450513          	addi	a0,a0,-1980 # c8000dbc <__rodata_start+0xdbc>
c0011580:	53c0c0ef          	jal	ra,c001dabc <Xil_Assert>
c0011584:	07ff1797          	auipc	a5,0x7ff1
c0011588:	39078793          	addi	a5,a5,912 # c8002914 <Xil_AssertStatus>
c001158c:	00100713          	li	a4,1
c0011590:	00e7a023          	sw	a4,0(a5)
c0011594:	0e40006f          	j	c0011678 <XAxiEthernet_Reset+0x198>
	TimeoutLoops = Xil_poll_timeout(Xil_In32,InstancePtr->Config.BaseAddress+
c0011598:	fdc42783          	lw	a5,-36(s0)
c001159c:	0047a783          	lw	a5,4(a5)
c00115a0:	00c78793          	addi	a5,a5,12
c00115a4:	00078513          	mv	a0,a5
c00115a8:	a99ff0ef          	jal	ra,c0011040 <Xil_In32>
c00115ac:	fea42223          	sw	a0,-28(s0)
c00115b0:	fe442783          	lw	a5,-28(s0)
c00115b4:	0807f793          	andi	a5,a5,128
c00115b8:	04079863          	bnez	a5,c0011608 <XAxiEthernet_Reset+0x128>
c00115bc:	00100513          	li	a0,1
c00115c0:	fb4f10ef          	jal	ra,c0002d74 <vTaskDelay>
c00115c4:	fe842603          	lw	a2,-24(s0)
c00115c8:	fec42683          	lw	a3,-20(s0)
c00115cc:	fff00513          	li	a0,-1
c00115d0:	fff00593          	li	a1,-1
c00115d4:	00a60733          	add	a4,a2,a0
c00115d8:	00070813          	mv	a6,a4
c00115dc:	00c83833          	sltu	a6,a6,a2
c00115e0:	00b687b3          	add	a5,a3,a1
c00115e4:	00f806b3          	add	a3,a6,a5
c00115e8:	00068793          	mv	a5,a3
c00115ec:	fee42423          	sw	a4,-24(s0)
c00115f0:	fef42623          	sw	a5,-20(s0)
c00115f4:	fe842783          	lw	a5,-24(s0)
c00115f8:	fec42703          	lw	a4,-20(s0)
c00115fc:	00e7e7b3          	or	a5,a5,a4
c0011600:	00078463          	beqz	a5,c0011608 <XAxiEthernet_Reset+0x128>
c0011604:	f95ff06f          	j	c0011598 <XAxiEthernet_Reset+0xb8>
c0011608:	00000013          	nop
c001160c:	fe842783          	lw	a5,-24(s0)
c0011610:	fec42703          	lw	a4,-20(s0)
c0011614:	00e7e7b3          	or	a5,a5,a4
c0011618:	00078663          	beqz	a5,c0011624 <XAxiEthernet_Reset+0x144>
c001161c:	00000793          	li	a5,0
c0011620:	0080006f          	j	c0011628 <XAxiEthernet_Reset+0x148>
c0011624:	fff00793          	li	a5,-1
c0011628:	fef42023          	sw	a5,-32(s0)
	      XAE_IS_OFFSET, value, (value&XAE_INT_MGTRDY_MASK)!=0,
		           XAE_RST_DEFAULT_TIMEOUT_VAL);

	if(-1 == TimeoutLoops) {
c001162c:	fe042703          	lw	a4,-32(s0)
c0011630:	fff00793          	li	a5,-1
c0011634:	02f71463          	bne	a4,a5,c001165c <XAxiEthernet_Reset+0x17c>
		Xil_AssertVoidAlways();
c0011638:	19800593          	li	a1,408
c001163c:	07fef517          	auipc	a0,0x7fef
c0011640:	78050513          	addi	a0,a0,1920 # c8000dbc <__rodata_start+0xdbc>
c0011644:	4780c0ef          	jal	ra,c001dabc <Xil_Assert>
c0011648:	07ff1797          	auipc	a5,0x7ff1
c001164c:	2cc78793          	addi	a5,a5,716 # c8002914 <Xil_AssertStatus>
c0011650:	00100713          	li	a4,1
c0011654:	00e7a023          	sw	a4,0(a5)
c0011658:	0200006f          	j	c0011678 <XAxiEthernet_Reset+0x198>
	}

	xaxi_debug_printf("XAxiEthernet_Reset\r\n");

	/* Stop the device and reset HW */
	XAxiEthernet_Stop(InstancePtr);
c001165c:	fdc42503          	lw	a0,-36(s0)
c0011660:	d2dff0ef          	jal	ra,c001138c <XAxiEthernet_Stop>
	InstancePtr->Options = XAE_DEFAULT_OPTIONS;
c0011664:	fdc42783          	lw	a5,-36(s0)
c0011668:	3f800713          	li	a4,1016
c001166c:	04e7aa23          	sw	a4,84(a5)

	/* Setup HW */
	InitHw(InstancePtr);
c0011670:	fdc42503          	lw	a0,-36(s0)
c0011674:	014000ef          	jal	ra,c0011688 <InitHw>
}
c0011678:	02c12083          	lw	ra,44(sp)
c001167c:	02812403          	lw	s0,40(sp)
c0011680:	03010113          	addi	sp,sp,48
c0011684:	00008067          	ret

c0011688 <InitHw>:
* @note		None.
*
*
******************************************************************************/
static void InitHw(XAxiEthernet *InstancePtr)
{
c0011688:	fd010113          	addi	sp,sp,-48
c001168c:	02112623          	sw	ra,44(sp)
c0011690:	02812423          	sw	s0,40(sp)
c0011694:	03010413          	addi	s0,sp,48
c0011698:	fca42e23          	sw	a0,-36(s0)

	xaxi_debug_printf("XAxiEthernet InitHw\r\n");


	/* Disable the receiver */
	Reg = XAxiEthernet_ReadReg(InstancePtr->Config.BaseAddress,
c001169c:	fdc42783          	lw	a5,-36(s0)
c00116a0:	0047a783          	lw	a5,4(a5)
c00116a4:	40478793          	addi	a5,a5,1028
c00116a8:	00078513          	mv	a0,a5
c00116ac:	995ff0ef          	jal	ra,c0011040 <Xil_In32>
c00116b0:	fea42623          	sw	a0,-20(s0)
							XAE_RCW1_OFFSET);
	Reg &= ~XAE_RCW1_RX_MASK;
c00116b4:	fec42703          	lw	a4,-20(s0)
c00116b8:	f00007b7          	lui	a5,0xf0000
c00116bc:	fff78793          	addi	a5,a5,-1 # efffffff <_end+0x27f7b77f>
c00116c0:	00f777b3          	and	a5,a4,a5
c00116c4:	fef42623          	sw	a5,-20(s0)
	XAxiEthernet_WriteReg(InstancePtr->Config.BaseAddress,
c00116c8:	fdc42783          	lw	a5,-36(s0)
c00116cc:	0047a783          	lw	a5,4(a5)
c00116d0:	40478793          	addi	a5,a5,1028
c00116d4:	fec42583          	lw	a1,-20(s0)
c00116d8:	00078513          	mv	a0,a5
c00116dc:	98dff0ef          	jal	ra,c0011068 <Xil_Out32>
	/*
	 * Stopping the receiver in mid-packet causes a dropped packet
	 * indication from HW. Clear it.
	 */
	/* Get the interrupt pending register */
	Reg = XAxiEthernet_ReadReg(InstancePtr->Config.BaseAddress,
c00116e0:	fdc42783          	lw	a5,-36(s0)
c00116e4:	0047a783          	lw	a5,4(a5)
c00116e8:	01078793          	addi	a5,a5,16
c00116ec:	00078513          	mv	a0,a5
c00116f0:	951ff0ef          	jal	ra,c0011040 <Xil_In32>
c00116f4:	fea42623          	sw	a0,-20(s0)
								XAE_IP_OFFSET);
	if (Reg & XAE_INT_RXRJECT_MASK) {
c00116f8:	fec42783          	lw	a5,-20(s0)
c00116fc:	0087f793          	andi	a5,a5,8
c0011700:	00078e63          	beqz	a5,c001171c <InitHw+0x94>
		/*
		 * Set the interrupt status register to clear the pending
		 * interrupt
		 */
		XAxiEthernet_WriteReg(InstancePtr->Config.BaseAddress,
c0011704:	fdc42783          	lw	a5,-36(s0)
c0011708:	0047a783          	lw	a5,4(a5)
c001170c:	00c78793          	addi	a5,a5,12
c0011710:	00800593          	li	a1,8
c0011714:	00078513          	mv	a0,a5
c0011718:	951ff0ef          	jal	ra,c0011068 <Xil_Out32>
	 * Sync default options with HW but leave receiver and transmitter
	 * disabled. They get enabled with XAxiEthernet_Start() if
	 * XAE_TRANSMITTER_ENABLE_OPTION and XAE_RECEIVER_ENABLE_OPTION
	 * are set
	 */
	XAxiEthernet_SetOptions(InstancePtr, InstancePtr->Options &
c001171c:	fdc42783          	lw	a5,-36(s0)
c0011720:	0547a783          	lw	a5,84(a5)
c0011724:	e7f7f793          	andi	a5,a5,-385
c0011728:	00078593          	mv	a1,a5
c001172c:	fdc42503          	lw	a0,-36(s0)
c0011730:	73c000ef          	jal	ra,c0011e6c <XAxiEthernet_SetOptions>
					~(XAE_TRANSMITTER_ENABLE_OPTION |
					XAE_RECEIVER_ENABLE_OPTION));

	XAxiEthernet_ClearOptions(InstancePtr, ~InstancePtr->Options);
c0011734:	fdc42783          	lw	a5,-36(s0)
c0011738:	0547a783          	lw	a5,84(a5)
c001173c:	fff7c793          	not	a5,a5
c0011740:	00078593          	mv	a1,a5
c0011744:	fdc42503          	lw	a0,-36(s0)
c0011748:	46d000ef          	jal	ra,c00123b4 <XAxiEthernet_ClearOptions>

	/* Set default MDIO divisor */
	XAxiEthernet_PhySetMdioDivisor(InstancePtr, XAE_MDIO_DIV_DFT);
c001174c:	01d00593          	li	a1,29
c0011750:	fdc42503          	lw	a0,-36(s0)
c0011754:	774010ef          	jal	ra,c0012ec8 <XAxiEthernet_PhySetMdioDivisor>

	xaxi_debug_printf("XAxiEthernet InitHw: done\r\n");
}
c0011758:	00000013          	nop
c001175c:	02c12083          	lw	ra,44(sp)
c0011760:	02812403          	lw	s0,40(sp)
c0011764:	03010113          	addi	sp,sp,48
c0011768:	00008067          	ret

c001176c <XAxiEthernet_SetMacAddress>:
 * This routine also supports the extended/new VLAN and multicast mode. The
 * XAE_RAF_NEWFNCENBL_MASK bit dictates which offset will be configured.
 *
 ******************************************************************************/
int XAxiEthernet_SetMacAddress(XAxiEthernet *InstancePtr, void *AddressPtr)
{
c001176c:	fd010113          	addi	sp,sp,-48
c0011770:	02112623          	sw	ra,44(sp)
c0011774:	02812423          	sw	s0,40(sp)
c0011778:	03010413          	addi	s0,sp,48
c001177c:	fca42e23          	sw	a0,-36(s0)
c0011780:	fcb42c23          	sw	a1,-40(s0)
	u32 MacAddr;

	Xil_AssertNonvoid(InstancePtr != NULL);
c0011784:	fdc42783          	lw	a5,-36(s0)
c0011788:	02078463          	beqz	a5,c00117b0 <XAxiEthernet_SetMacAddress+0x44>
c001178c:	07ff1797          	auipc	a5,0x7ff1
c0011790:	18878793          	addi	a5,a5,392 # c8002914 <Xil_AssertStatus>
c0011794:	0007a023          	sw	zero,0(a5)
	Xil_AssertNonvoid(InstancePtr->IsReady == XIL_COMPONENT_IS_READY);
c0011798:	fdc42783          	lw	a5,-36(s0)
c001179c:	0507a703          	lw	a4,80(a5)
c00117a0:	111117b7          	lui	a5,0x11111
c00117a4:	11178793          	addi	a5,a5,273 # 11111111 <_DMEM_LENGTH+0x10911111>
c00117a8:	04f71463          	bne	a4,a5,c00117f0 <XAxiEthernet_SetMacAddress+0x84>
c00117ac:	02c0006f          	j	c00117d8 <XAxiEthernet_SetMacAddress+0x6c>
	Xil_AssertNonvoid(InstancePtr != NULL);
c00117b0:	1fa00593          	li	a1,506
c00117b4:	07fef517          	auipc	a0,0x7fef
c00117b8:	60850513          	addi	a0,a0,1544 # c8000dbc <__rodata_start+0xdbc>
c00117bc:	3000c0ef          	jal	ra,c001dabc <Xil_Assert>
c00117c0:	07ff1797          	auipc	a5,0x7ff1
c00117c4:	15478793          	addi	a5,a5,340 # c8002914 <Xil_AssertStatus>
c00117c8:	00100713          	li	a4,1
c00117cc:	00e7a023          	sw	a4,0(a5)
c00117d0:	00000793          	li	a5,0
c00117d4:	2400006f          	j	c0011a14 <XAxiEthernet_SetMacAddress+0x2a8>
	Xil_AssertNonvoid(InstancePtr->IsReady == XIL_COMPONENT_IS_READY);
c00117d8:	07ff1797          	auipc	a5,0x7ff1
c00117dc:	13c78793          	addi	a5,a5,316 # c8002914 <Xil_AssertStatus>
c00117e0:	0007a023          	sw	zero,0(a5)
	Xil_AssertNonvoid(AddressPtr != NULL);
c00117e4:	fd842783          	lw	a5,-40(s0)
c00117e8:	04078e63          	beqz	a5,c0011844 <XAxiEthernet_SetMacAddress+0xd8>
c00117ec:	02c0006f          	j	c0011818 <XAxiEthernet_SetMacAddress+0xac>
	Xil_AssertNonvoid(InstancePtr->IsReady == XIL_COMPONENT_IS_READY);
c00117f0:	1fb00593          	li	a1,507
c00117f4:	07fef517          	auipc	a0,0x7fef
c00117f8:	5c850513          	addi	a0,a0,1480 # c8000dbc <__rodata_start+0xdbc>
c00117fc:	2c00c0ef          	jal	ra,c001dabc <Xil_Assert>
c0011800:	07ff1797          	auipc	a5,0x7ff1
c0011804:	11478793          	addi	a5,a5,276 # c8002914 <Xil_AssertStatus>
c0011808:	00100713          	li	a4,1
c001180c:	00e7a023          	sw	a4,0(a5)
c0011810:	00000793          	li	a5,0
c0011814:	2000006f          	j	c0011a14 <XAxiEthernet_SetMacAddress+0x2a8>
	Xil_AssertNonvoid(AddressPtr != NULL);
c0011818:	07ff1797          	auipc	a5,0x7ff1
c001181c:	0fc78793          	addi	a5,a5,252 # c8002914 <Xil_AssertStatus>
c0011820:	0007a023          	sw	zero,0(a5)

	u8 *Aptr = (u8 *) AddressPtr;
c0011824:	fd842783          	lw	a5,-40(s0)
c0011828:	fef42623          	sw	a5,-20(s0)

	/* Be sure device has been stopped */
	if (InstancePtr->IsStarted == XIL_COMPONENT_IS_STARTED) {
c001182c:	fdc42783          	lw	a5,-36(s0)
c0011830:	04c7a703          	lw	a4,76(a5)
c0011834:	222227b7          	lui	a5,0x22222
c0011838:	22278793          	addi	a5,a5,546 # 22222222 <_DMEM_LENGTH+0x21a22222>
c001183c:	02f71c63          	bne	a4,a5,c0011874 <XAxiEthernet_SetMacAddress+0x108>
c0011840:	02c0006f          	j	c001186c <XAxiEthernet_SetMacAddress+0x100>
	Xil_AssertNonvoid(AddressPtr != NULL);
c0011844:	1fc00593          	li	a1,508
c0011848:	07fef517          	auipc	a0,0x7fef
c001184c:	57450513          	addi	a0,a0,1396 # c8000dbc <__rodata_start+0xdbc>
c0011850:	26c0c0ef          	jal	ra,c001dabc <Xil_Assert>
c0011854:	07ff1797          	auipc	a5,0x7ff1
c0011858:	0c078793          	addi	a5,a5,192 # c8002914 <Xil_AssertStatus>
c001185c:	00100713          	li	a4,1
c0011860:	00e7a023          	sw	a4,0(a5)
c0011864:	00000793          	li	a5,0
c0011868:	1ac0006f          	j	c0011a14 <XAxiEthernet_SetMacAddress+0x2a8>
		return (XST_DEVICE_IS_STARTED);
c001186c:	00500793          	li	a5,5
c0011870:	1a40006f          	j	c0011a14 <XAxiEthernet_SetMacAddress+0x2a8>

	xaxi_debug_printf(	"XAxiEthernet_SetMacAddress: setting mac address to:0x%08x%8x%8x%8x%8x%8x\r\n",
		Aptr[0],  Aptr[1], Aptr[2], Aptr[3], Aptr[4], Aptr[5]);

	/* Prepare MAC bits in either UAW0/UAWL */
	MacAddr = Aptr[0];
c0011874:	fec42783          	lw	a5,-20(s0)
c0011878:	0007c783          	lbu	a5,0(a5)
c001187c:	fef42423          	sw	a5,-24(s0)
	MacAddr |= Aptr[1] << 8;
c0011880:	fec42783          	lw	a5,-20(s0)
c0011884:	00178793          	addi	a5,a5,1
c0011888:	0007c783          	lbu	a5,0(a5)
c001188c:	00879793          	slli	a5,a5,0x8
c0011890:	00078713          	mv	a4,a5
c0011894:	fe842783          	lw	a5,-24(s0)
c0011898:	00e7e7b3          	or	a5,a5,a4
c001189c:	fef42423          	sw	a5,-24(s0)
	MacAddr |= Aptr[2] << 16;
c00118a0:	fec42783          	lw	a5,-20(s0)
c00118a4:	00278793          	addi	a5,a5,2
c00118a8:	0007c783          	lbu	a5,0(a5)
c00118ac:	01079793          	slli	a5,a5,0x10
c00118b0:	00078713          	mv	a4,a5
c00118b4:	fe842783          	lw	a5,-24(s0)
c00118b8:	00e7e7b3          	or	a5,a5,a4
c00118bc:	fef42423          	sw	a5,-24(s0)
	MacAddr |= Aptr[3] << 24;
c00118c0:	fec42783          	lw	a5,-20(s0)
c00118c4:	00378793          	addi	a5,a5,3
c00118c8:	0007c783          	lbu	a5,0(a5)
c00118cc:	01879793          	slli	a5,a5,0x18
c00118d0:	00078713          	mv	a4,a5
c00118d4:	fe842783          	lw	a5,-24(s0)
c00118d8:	00e7e7b3          	or	a5,a5,a4
c00118dc:	fef42423          	sw	a5,-24(s0)
	/* Check to see if it is in extended/new mode. */
	if (!(XAxiEthernet_IsExtFuncCap(InstancePtr))) {
c00118e0:	fdc42783          	lw	a5,-36(s0)
c00118e4:	0047a783          	lw	a5,4(a5)
c00118e8:	00078513          	mv	a0,a5
c00118ec:	f54ff0ef          	jal	ra,c0011040 <Xil_In32>
c00118f0:	00050713          	mv	a4,a0
c00118f4:	000017b7          	lui	a5,0x1
c00118f8:	80078793          	addi	a5,a5,-2048 # 800 <_STACK_SIZE-0x800>
c00118fc:	00f777b3          	and	a5,a4,a5
c0011900:	0a079063          	bnez	a5,c00119a0 <XAxiEthernet_SetMacAddress+0x234>
		/*
		 * Set the MAC bits [31:0] in UAW0.
		 * Having Aptr be unsigned type prevents the following
		 * operations from sign extending.
		 */
		XAxiEthernet_WriteReg(InstancePtr->Config.BaseAddress,
c0011904:	fdc42783          	lw	a5,-36(s0)
c0011908:	0047a783          	lw	a5,4(a5)
c001190c:	70078793          	addi	a5,a5,1792
c0011910:	fe842583          	lw	a1,-24(s0)
c0011914:	00078513          	mv	a0,a5
c0011918:	f50ff0ef          	jal	ra,c0011068 <Xil_Out32>
						XAE_UAW0_OFFSET, MacAddr);

		/* There are reserved bits in UAW1 so don't affect them */
		MacAddr = XAxiEthernet_ReadReg(InstancePtr->Config.BaseAddress,
c001191c:	fdc42783          	lw	a5,-36(s0)
c0011920:	0047a783          	lw	a5,4(a5)
c0011924:	70478793          	addi	a5,a5,1796
c0011928:	00078513          	mv	a0,a5
c001192c:	f14ff0ef          	jal	ra,c0011040 <Xil_In32>
c0011930:	fea42423          	sw	a0,-24(s0)
						XAE_UAW1_OFFSET);
		MacAddr &= ~XAE_UAW1_UNICASTADDR_MASK;
c0011934:	fe842703          	lw	a4,-24(s0)
c0011938:	ffff07b7          	lui	a5,0xffff0
c001193c:	00f777b3          	and	a5,a4,a5
c0011940:	fef42423          	sw	a5,-24(s0)

		/* Set MAC bits [47:32] in UAW1 */
		MacAddr |= Aptr[4];
c0011944:	fec42783          	lw	a5,-20(s0)
c0011948:	00478793          	addi	a5,a5,4 # ffff0004 <_end+0x37f6b784>
c001194c:	0007c783          	lbu	a5,0(a5)
c0011950:	00078713          	mv	a4,a5
c0011954:	fe842783          	lw	a5,-24(s0)
c0011958:	00e7e7b3          	or	a5,a5,a4
c001195c:	fef42423          	sw	a5,-24(s0)
		MacAddr |= Aptr[5] << 8;
c0011960:	fec42783          	lw	a5,-20(s0)
c0011964:	00578793          	addi	a5,a5,5
c0011968:	0007c783          	lbu	a5,0(a5)
c001196c:	00879793          	slli	a5,a5,0x8
c0011970:	00078713          	mv	a4,a5
c0011974:	fe842783          	lw	a5,-24(s0)
c0011978:	00e7e7b3          	or	a5,a5,a4
c001197c:	fef42423          	sw	a5,-24(s0)
		XAxiEthernet_WriteReg(InstancePtr->Config.BaseAddress,
c0011980:	fdc42783          	lw	a5,-36(s0)
c0011984:	0047a783          	lw	a5,4(a5)
c0011988:	70478793          	addi	a5,a5,1796
c001198c:	fe842583          	lw	a1,-24(s0)
c0011990:	00078513          	mv	a0,a5
c0011994:	ed4ff0ef          	jal	ra,c0011068 <Xil_Out32>
				XAE_UAW1_OFFSET, MacAddr);

		return (XST_SUCCESS);
c0011998:	00000793          	li	a5,0
c001199c:	0780006f          	j	c0011a14 <XAxiEthernet_SetMacAddress+0x2a8>
		/*
		 * Set the MAC bits [31:0] in UAWL register.
		 * Having Aptr be unsigned type prevents the following
		 * operations from sign extending.
		 */
		XAxiEthernet_WriteReg(InstancePtr->Config.BaseAddress,
c00119a0:	fdc42783          	lw	a5,-36(s0)
c00119a4:	0047a783          	lw	a5,4(a5)
c00119a8:	02078793          	addi	a5,a5,32
c00119ac:	fe842583          	lw	a1,-24(s0)
c00119b0:	00078513          	mv	a0,a5
c00119b4:	eb4ff0ef          	jal	ra,c0011068 <Xil_Out32>
						XAE_UAWL_OFFSET, MacAddr);

		/* Set MAC bits [47:32] in UAWU register. */
		MacAddr  = 0;
c00119b8:	fe042423          	sw	zero,-24(s0)
		MacAddr |= Aptr[4];
c00119bc:	fec42783          	lw	a5,-20(s0)
c00119c0:	00478793          	addi	a5,a5,4
c00119c4:	0007c783          	lbu	a5,0(a5)
c00119c8:	00078713          	mv	a4,a5
c00119cc:	fe842783          	lw	a5,-24(s0)
c00119d0:	00e7e7b3          	or	a5,a5,a4
c00119d4:	fef42423          	sw	a5,-24(s0)
		MacAddr |= Aptr[5] << 8;
c00119d8:	fec42783          	lw	a5,-20(s0)
c00119dc:	00578793          	addi	a5,a5,5
c00119e0:	0007c783          	lbu	a5,0(a5)
c00119e4:	00879793          	slli	a5,a5,0x8
c00119e8:	00078713          	mv	a4,a5
c00119ec:	fe842783          	lw	a5,-24(s0)
c00119f0:	00e7e7b3          	or	a5,a5,a4
c00119f4:	fef42423          	sw	a5,-24(s0)
		XAxiEthernet_WriteReg(InstancePtr->Config.BaseAddress,
c00119f8:	fdc42783          	lw	a5,-36(s0)
c00119fc:	0047a783          	lw	a5,4(a5)
c0011a00:	02478793          	addi	a5,a5,36
c0011a04:	fe842583          	lw	a1,-24(s0)
c0011a08:	00078513          	mv	a0,a5
c0011a0c:	e5cff0ef          	jal	ra,c0011068 <Xil_Out32>
						XAE_UAWU_OFFSET, MacAddr);

		return (XST_SUCCESS);
c0011a10:	00000793          	li	a5,0
	}
}
c0011a14:	00078513          	mv	a0,a5
c0011a18:	02c12083          	lw	ra,44(sp)
c0011a1c:	02812403          	lw	s0,40(sp)
c0011a20:	03010113          	addi	sp,sp,48
c0011a24:	00008067          	ret

c0011a28 <XAxiEthernet_GetMacAddress>:
 * This routine also supports the extended/new VLAN and multicast mode. The
 * XAE_RAF_NEWFNCENBL_MASK bit dictates which offset will be configured.
 *
 ******************************************************************************/
void XAxiEthernet_GetMacAddress(XAxiEthernet *InstancePtr, void *AddressPtr)
{
c0011a28:	fd010113          	addi	sp,sp,-48
c0011a2c:	02112623          	sw	ra,44(sp)
c0011a30:	02812423          	sw	s0,40(sp)
c0011a34:	03010413          	addi	s0,sp,48
c0011a38:	fca42e23          	sw	a0,-36(s0)
c0011a3c:	fcb42c23          	sw	a1,-40(s0)
	u32 MacAddr;
	u8 *Aptr = (u8 *) AddressPtr;
c0011a40:	fd842783          	lw	a5,-40(s0)
c0011a44:	fef42623          	sw	a5,-20(s0)

	Xil_AssertVoid(InstancePtr != NULL);
c0011a48:	fdc42783          	lw	a5,-36(s0)
c0011a4c:	00078e63          	beqz	a5,c0011a68 <XAxiEthernet_GetMacAddress+0x40>
c0011a50:	07ff1797          	auipc	a5,0x7ff1
c0011a54:	ec478793          	addi	a5,a5,-316 # c8002914 <Xil_AssertStatus>
c0011a58:	0007a023          	sw	zero,0(a5)
	Xil_AssertVoid(AddressPtr != NULL);
c0011a5c:	fd842783          	lw	a5,-40(s0)
c0011a60:	04078863          	beqz	a5,c0011ab0 <XAxiEthernet_GetMacAddress+0x88>
c0011a64:	0280006f          	j	c0011a8c <XAxiEthernet_GetMacAddress+0x64>
	Xil_AssertVoid(InstancePtr != NULL);
c0011a68:	25100593          	li	a1,593
c0011a6c:	07fef517          	auipc	a0,0x7fef
c0011a70:	35050513          	addi	a0,a0,848 # c8000dbc <__rodata_start+0xdbc>
c0011a74:	0480c0ef          	jal	ra,c001dabc <Xil_Assert>
c0011a78:	07ff1797          	auipc	a5,0x7ff1
c0011a7c:	e9c78793          	addi	a5,a5,-356 # c8002914 <Xil_AssertStatus>
c0011a80:	00100713          	li	a4,1
c0011a84:	00e7a023          	sw	a4,0(a5)
c0011a88:	2100006f          	j	c0011c98 <XAxiEthernet_GetMacAddress+0x270>
	Xil_AssertVoid(AddressPtr != NULL);
c0011a8c:	07ff1797          	auipc	a5,0x7ff1
c0011a90:	e8878793          	addi	a5,a5,-376 # c8002914 <Xil_AssertStatus>
c0011a94:	0007a023          	sw	zero,0(a5)
	Xil_AssertVoid(InstancePtr->IsReady == XIL_COMPONENT_IS_READY);
c0011a98:	fdc42783          	lw	a5,-36(s0)
c0011a9c:	0507a703          	lw	a4,80(a5)
c0011aa0:	111117b7          	lui	a5,0x11111
c0011aa4:	11178793          	addi	a5,a5,273 # 11111111 <_DMEM_LENGTH+0x10911111>
c0011aa8:	06f71063          	bne	a4,a5,c0011b08 <XAxiEthernet_GetMacAddress+0xe0>
c0011aac:	0280006f          	j	c0011ad4 <XAxiEthernet_GetMacAddress+0xac>
	Xil_AssertVoid(AddressPtr != NULL);
c0011ab0:	25200593          	li	a1,594
c0011ab4:	07fef517          	auipc	a0,0x7fef
c0011ab8:	30850513          	addi	a0,a0,776 # c8000dbc <__rodata_start+0xdbc>
c0011abc:	0000c0ef          	jal	ra,c001dabc <Xil_Assert>
c0011ac0:	07ff1797          	auipc	a5,0x7ff1
c0011ac4:	e5478793          	addi	a5,a5,-428 # c8002914 <Xil_AssertStatus>
c0011ac8:	00100713          	li	a4,1
c0011acc:	00e7a023          	sw	a4,0(a5)
c0011ad0:	1c80006f          	j	c0011c98 <XAxiEthernet_GetMacAddress+0x270>
	Xil_AssertVoid(InstancePtr->IsReady == XIL_COMPONENT_IS_READY);
c0011ad4:	07ff1797          	auipc	a5,0x7ff1
c0011ad8:	e4078793          	addi	a5,a5,-448 # c8002914 <Xil_AssertStatus>
c0011adc:	0007a023          	sw	zero,0(a5)


	/* Check to see if it is in extended/new mode. */
	if (!(XAxiEthernet_IsExtFuncCap(InstancePtr))) {
c0011ae0:	fdc42783          	lw	a5,-36(s0)
c0011ae4:	0047a783          	lw	a5,4(a5)
c0011ae8:	00078513          	mv	a0,a5
c0011aec:	d54ff0ef          	jal	ra,c0011040 <Xil_In32>
c0011af0:	00050713          	mv	a4,a0
c0011af4:	000017b7          	lui	a5,0x1
c0011af8:	80078793          	addi	a5,a5,-2048 # 800 <_STACK_SIZE-0x800>
c0011afc:	00f777b3          	and	a5,a4,a5
c0011b00:	0e079263          	bnez	a5,c0011be4 <XAxiEthernet_GetMacAddress+0x1bc>
c0011b04:	0280006f          	j	c0011b2c <XAxiEthernet_GetMacAddress+0x104>
	Xil_AssertVoid(InstancePtr->IsReady == XIL_COMPONENT_IS_READY);
c0011b08:	25300593          	li	a1,595
c0011b0c:	07fef517          	auipc	a0,0x7fef
c0011b10:	2b050513          	addi	a0,a0,688 # c8000dbc <__rodata_start+0xdbc>
c0011b14:	7a90b0ef          	jal	ra,c001dabc <Xil_Assert>
c0011b18:	07ff1797          	auipc	a5,0x7ff1
c0011b1c:	dfc78793          	addi	a5,a5,-516 # c8002914 <Xil_AssertStatus>
c0011b20:	00100713          	li	a4,1
c0011b24:	00e7a023          	sw	a4,0(a5)
c0011b28:	1700006f          	j	c0011c98 <XAxiEthernet_GetMacAddress+0x270>
		/* Read MAC bits [31:0] in UAW0 */
		MacAddr = XAxiEthernet_ReadReg(InstancePtr->Config.BaseAddress,
c0011b2c:	fdc42783          	lw	a5,-36(s0)
c0011b30:	0047a783          	lw	a5,4(a5)
c0011b34:	70078793          	addi	a5,a5,1792
c0011b38:	00078513          	mv	a0,a5
c0011b3c:	d04ff0ef          	jal	ra,c0011040 <Xil_In32>
c0011b40:	fea42423          	sw	a0,-24(s0)
							XAE_UAW0_OFFSET);
		Aptr[0] = (u8) MacAddr;
c0011b44:	fe842783          	lw	a5,-24(s0)
c0011b48:	0ff7f713          	andi	a4,a5,255
c0011b4c:	fec42783          	lw	a5,-20(s0)
c0011b50:	00e78023          	sb	a4,0(a5)
		Aptr[1] = (u8) (MacAddr >> 8);
c0011b54:	fe842783          	lw	a5,-24(s0)
c0011b58:	0087d713          	srli	a4,a5,0x8
c0011b5c:	fec42783          	lw	a5,-20(s0)
c0011b60:	00178793          	addi	a5,a5,1
c0011b64:	0ff77713          	andi	a4,a4,255
c0011b68:	00e78023          	sb	a4,0(a5)
		Aptr[2] = (u8) (MacAddr >> 16);
c0011b6c:	fe842783          	lw	a5,-24(s0)
c0011b70:	0107d713          	srli	a4,a5,0x10
c0011b74:	fec42783          	lw	a5,-20(s0)
c0011b78:	00278793          	addi	a5,a5,2
c0011b7c:	0ff77713          	andi	a4,a4,255
c0011b80:	00e78023          	sb	a4,0(a5)
		Aptr[3] = (u8) (MacAddr >> 24);
c0011b84:	fe842783          	lw	a5,-24(s0)
c0011b88:	0187d713          	srli	a4,a5,0x18
c0011b8c:	fec42783          	lw	a5,-20(s0)
c0011b90:	00378793          	addi	a5,a5,3
c0011b94:	0ff77713          	andi	a4,a4,255
c0011b98:	00e78023          	sb	a4,0(a5)

		/* Read MAC bits [47:32] in UAW1 */
		MacAddr = XAxiEthernet_ReadReg(InstancePtr->Config.BaseAddress,
c0011b9c:	fdc42783          	lw	a5,-36(s0)
c0011ba0:	0047a783          	lw	a5,4(a5)
c0011ba4:	70478793          	addi	a5,a5,1796
c0011ba8:	00078513          	mv	a0,a5
c0011bac:	c94ff0ef          	jal	ra,c0011040 <Xil_In32>
c0011bb0:	fea42423          	sw	a0,-24(s0)
							XAE_UAW1_OFFSET);
		Aptr[4] = (u8) MacAddr;
c0011bb4:	fec42783          	lw	a5,-20(s0)
c0011bb8:	00478793          	addi	a5,a5,4
c0011bbc:	fe842703          	lw	a4,-24(s0)
c0011bc0:	0ff77713          	andi	a4,a4,255
c0011bc4:	00e78023          	sb	a4,0(a5)
		Aptr[5] = (u8) (MacAddr >> 8);
c0011bc8:	fe842783          	lw	a5,-24(s0)
c0011bcc:	0087d713          	srli	a4,a5,0x8
c0011bd0:	fec42783          	lw	a5,-20(s0)
c0011bd4:	00578793          	addi	a5,a5,5
c0011bd8:	0ff77713          	andi	a4,a4,255
c0011bdc:	00e78023          	sb	a4,0(a5)
c0011be0:	0b80006f          	j	c0011c98 <XAxiEthernet_GetMacAddress+0x270>
	} else { /* Extended/new mode */
		/* Read MAC bits [31:0] in UAWL register */
		MacAddr = XAxiEthernet_ReadReg(InstancePtr->Config.BaseAddress,
c0011be4:	fdc42783          	lw	a5,-36(s0)
c0011be8:	0047a783          	lw	a5,4(a5)
c0011bec:	02078793          	addi	a5,a5,32
c0011bf0:	00078513          	mv	a0,a5
c0011bf4:	c4cff0ef          	jal	ra,c0011040 <Xil_In32>
c0011bf8:	fea42423          	sw	a0,-24(s0)
							XAE_UAWL_OFFSET);
		Aptr[0] = (u8) MacAddr;
c0011bfc:	fe842783          	lw	a5,-24(s0)
c0011c00:	0ff7f713          	andi	a4,a5,255
c0011c04:	fec42783          	lw	a5,-20(s0)
c0011c08:	00e78023          	sb	a4,0(a5)
		Aptr[1] = (u8) (MacAddr >> 8);
c0011c0c:	fe842783          	lw	a5,-24(s0)
c0011c10:	0087d713          	srli	a4,a5,0x8
c0011c14:	fec42783          	lw	a5,-20(s0)
c0011c18:	00178793          	addi	a5,a5,1
c0011c1c:	0ff77713          	andi	a4,a4,255
c0011c20:	00e78023          	sb	a4,0(a5)
		Aptr[2] = (u8) (MacAddr >> 16);
c0011c24:	fe842783          	lw	a5,-24(s0)
c0011c28:	0107d713          	srli	a4,a5,0x10
c0011c2c:	fec42783          	lw	a5,-20(s0)
c0011c30:	00278793          	addi	a5,a5,2
c0011c34:	0ff77713          	andi	a4,a4,255
c0011c38:	00e78023          	sb	a4,0(a5)
		Aptr[3] = (u8) (MacAddr >> 24);
c0011c3c:	fe842783          	lw	a5,-24(s0)
c0011c40:	0187d713          	srli	a4,a5,0x18
c0011c44:	fec42783          	lw	a5,-20(s0)
c0011c48:	00378793          	addi	a5,a5,3
c0011c4c:	0ff77713          	andi	a4,a4,255
c0011c50:	00e78023          	sb	a4,0(a5)

		/* Read MAC bits [47:32] in UAWU register */
		MacAddr = XAxiEthernet_ReadReg(InstancePtr->Config.BaseAddress,
c0011c54:	fdc42783          	lw	a5,-36(s0)
c0011c58:	0047a783          	lw	a5,4(a5)
c0011c5c:	02478793          	addi	a5,a5,36
c0011c60:	00078513          	mv	a0,a5
c0011c64:	bdcff0ef          	jal	ra,c0011040 <Xil_In32>
c0011c68:	fea42423          	sw	a0,-24(s0)
							XAE_UAWU_OFFSET);
		Aptr[4] = (u8) MacAddr;
c0011c6c:	fec42783          	lw	a5,-20(s0)
c0011c70:	00478793          	addi	a5,a5,4
c0011c74:	fe842703          	lw	a4,-24(s0)
c0011c78:	0ff77713          	andi	a4,a4,255
c0011c7c:	00e78023          	sb	a4,0(a5)
		Aptr[5] = (u8) (MacAddr >> 8);
c0011c80:	fe842783          	lw	a5,-24(s0)
c0011c84:	0087d713          	srli	a4,a5,0x8
c0011c88:	fec42783          	lw	a5,-20(s0)
c0011c8c:	00578793          	addi	a5,a5,5
c0011c90:	0ff77713          	andi	a4,a4,255
c0011c94:	00e78023          	sb	a4,0(a5)
	}
}
c0011c98:	02c12083          	lw	ra,44(sp)
c0011c9c:	02812403          	lw	s0,40(sp)
c0011ca0:	03010113          	addi	sp,sp,48
c0011ca4:	00008067          	ret

c0011ca8 <XAxiEthernet_UpdateDepOptions>:
 *	- XAE_FCS_STRIP_OPTION
 *	- XAE_PROMISC_OPTION.
 *
 ******************************************************************************/
static u32 XAxiEthernet_UpdateDepOptions(XAxiEthernet *InstancePtr)
{
c0011ca8:	fd010113          	addi	sp,sp,-48
c0011cac:	02812623          	sw	s0,44(sp)
c0011cb0:	03010413          	addi	s0,sp,48
c0011cb4:	fca42e23          	sw	a0,-36(s0)
	/*
	 * This is a helper function for XAxiEthernet_[Set|Clear]Options(),
	 * verification has been done before invoke this function.
	 */
	u32 DepOptions = InstancePtr->Options;
c0011cb8:	fdc42783          	lw	a5,-36(s0)
c0011cbc:	0547a783          	lw	a5,84(a5)
c0011cc0:	fef42623          	sw	a5,-20(s0)
	 * OPTIONS are in sync and _[Set|Clear]Options() can be performed
	 * seamlessly.
	 */

	/* Enable extended multicast option */
	if (DepOptions & XAE_EXT_MULTICAST_OPTION) {
c0011cc4:	fec42703          	lw	a4,-20(s0)
c0011cc8:	000017b7          	lui	a5,0x1
c0011ccc:	80078793          	addi	a5,a5,-2048 # 800 <_STACK_SIZE-0x800>
c0011cd0:	00f777b3          	and	a5,a4,a5
c0011cd4:	00078e63          	beqz	a5,c0011cf0 <XAxiEthernet_UpdateDepOptions+0x48>
		/*
		 * When extended multicast module is enabled in HW,
		 * XAE_PROMISC_OPTION is required to be enabled.
		 */
		if (XAxiEthernet_IsExtMcast(InstancePtr)) {
c0011cd8:	fdc42783          	lw	a5,-36(s0)
c0011cdc:	0127c783          	lbu	a5,18(a5)
c0011ce0:	00078863          	beqz	a5,c0011cf0 <XAxiEthernet_UpdateDepOptions+0x48>
			DepOptions |= XAE_PROMISC_OPTION;
c0011ce4:	fec42783          	lw	a5,-20(s0)
c0011ce8:	0017e793          	ori	a5,a5,1
c0011cec:	fef42623          	sw	a5,-20(s0)
			"EXT MULTICAST is not built in hardware\r\n");
		}
	}

	/* Enable extended transmit VLAN translation option */
	if (DepOptions & XAE_EXT_TXVLAN_TRAN_OPTION) {
c0011cf0:	fec42703          	lw	a4,-20(s0)
c0011cf4:	000017b7          	lui	a5,0x1
c0011cf8:	00f777b3          	and	a5,a4,a5
c0011cfc:	02078463          	beqz	a5,c0011d24 <XAxiEthernet_UpdateDepOptions+0x7c>
		/*
		 * Check if hardware is built with extend TX VLAN translation.
		 * if not, output an information message.
		 */
		if (XAxiEthernet_IsTxVlanTran(InstancePtr)) {
c0011d00:	fdc42783          	lw	a5,-36(s0)
c0011d04:	00c7c783          	lbu	a5,12(a5) # 100c <_STACK_SIZE+0xc>
c0011d08:	00078e63          	beqz	a5,c0011d24 <XAxiEthernet_UpdateDepOptions+0x7c>
			DepOptions |= XAE_FCS_INSERT_OPTION;
c0011d0c:	fec42783          	lw	a5,-20(s0)
c0011d10:	0207e793          	ori	a5,a5,32
c0011d14:	fef42623          	sw	a5,-20(s0)
			DepOptions &= ~XAE_VLAN_OPTION;
c0011d18:	fec42783          	lw	a5,-20(s0)
c0011d1c:	ffb7f793          	andi	a5,a5,-5
c0011d20:	fef42623          	sw	a5,-20(s0)
			"TX VLAN TRANSLATION is not built in hardware\r\n");
		}
	}

	/* Enable extended receive VLAN translation option */
	if (DepOptions & XAE_EXT_RXVLAN_TRAN_OPTION) {
c0011d24:	fec42703          	lw	a4,-20(s0)
c0011d28:	000027b7          	lui	a5,0x2
c0011d2c:	00f777b3          	and	a5,a4,a5
c0011d30:	02078463          	beqz	a5,c0011d58 <XAxiEthernet_UpdateDepOptions+0xb0>
		/*
		 * Check if hardware is built with extend RX VLAN translation.
		 * if not, output an information message.
		 */
		if (XAxiEthernet_IsRxVlanTran(InstancePtr)) {
c0011d34:	fdc42783          	lw	a5,-36(s0)
c0011d38:	00d7c783          	lbu	a5,13(a5) # 200d <_STACK_SIZE+0x100d>
c0011d3c:	00078e63          	beqz	a5,c0011d58 <XAxiEthernet_UpdateDepOptions+0xb0>
			DepOptions |= XAE_FCS_STRIP_OPTION;
c0011d40:	fec42783          	lw	a5,-20(s0)
c0011d44:	0107e793          	ori	a5,a5,16
c0011d48:	fef42623          	sw	a5,-20(s0)
			DepOptions &= ~XAE_VLAN_OPTION;
c0011d4c:	fec42783          	lw	a5,-20(s0)
c0011d50:	ffb7f793          	andi	a5,a5,-5
c0011d54:	fef42623          	sw	a5,-20(s0)
			"RX VLAN TRANSLATION is not built in hardware\r\n");
		}
	}

	/* Enable extended transmit VLAN tag option */
	if (DepOptions & XAE_EXT_TXVLAN_TAG_OPTION) {
c0011d58:	fec42703          	lw	a4,-20(s0)
c0011d5c:	000047b7          	lui	a5,0x4
c0011d60:	00f777b3          	and	a5,a4,a5
c0011d64:	02078a63          	beqz	a5,c0011d98 <XAxiEthernet_UpdateDepOptions+0xf0>
		/*
		 * Check if hardware is built with extend TX VLAN tagging.
		 * if not, output an information message.
		 */
		if (XAxiEthernet_IsTxVlanTag(InstancePtr)) {
c0011d68:	fdc42783          	lw	a5,-36(s0)
c0011d6c:	00e7c783          	lbu	a5,14(a5) # 400e <_STACK_SIZE+0x300e>
c0011d70:	02078463          	beqz	a5,c0011d98 <XAxiEthernet_UpdateDepOptions+0xf0>
			DepOptions |= XAE_FCS_INSERT_OPTION;
c0011d74:	fec42783          	lw	a5,-20(s0)
c0011d78:	0207e793          	ori	a5,a5,32
c0011d7c:	fef42623          	sw	a5,-20(s0)
			DepOptions &= ~XAE_VLAN_OPTION;
c0011d80:	fec42783          	lw	a5,-20(s0)
c0011d84:	ffb7f793          	andi	a5,a5,-5
c0011d88:	fef42623          	sw	a5,-20(s0)
			DepOptions |= XAE_JUMBO_OPTION;
c0011d8c:	fec42783          	lw	a5,-20(s0)
c0011d90:	0027e793          	ori	a5,a5,2
c0011d94:	fef42623          	sw	a5,-20(s0)
			xaxi_debug_printf("TX VLAN TAG is not built in hardware\r\n");
		}
	}

	/* Enable extended receive VLAN tag option */
	if (DepOptions & XAE_EXT_RXVLAN_TAG_OPTION) {
c0011d98:	fec42703          	lw	a4,-20(s0)
c0011d9c:	000087b7          	lui	a5,0x8
c0011da0:	00f777b3          	and	a5,a4,a5
c0011da4:	02078a63          	beqz	a5,c0011dd8 <XAxiEthernet_UpdateDepOptions+0x130>
		/*
		 * Check if hardware is built with extend RX VLAN tagging.
		 * if not, output an information message.
		 */
		if (XAxiEthernet_IsRxVlanTag(InstancePtr)) {
c0011da8:	fdc42783          	lw	a5,-36(s0)
c0011dac:	00f7c783          	lbu	a5,15(a5) # 800f <_STACK_SIZE+0x700f>
c0011db0:	02078463          	beqz	a5,c0011dd8 <XAxiEthernet_UpdateDepOptions+0x130>
			DepOptions |= XAE_FCS_STRIP_OPTION;
c0011db4:	fec42783          	lw	a5,-20(s0)
c0011db8:	0107e793          	ori	a5,a5,16
c0011dbc:	fef42623          	sw	a5,-20(s0)
			DepOptions &= ~XAE_VLAN_OPTION;
c0011dc0:	fec42783          	lw	a5,-20(s0)
c0011dc4:	ffb7f793          	andi	a5,a5,-5
c0011dc8:	fef42623          	sw	a5,-20(s0)
			DepOptions |= XAE_JUMBO_OPTION;
c0011dcc:	fec42783          	lw	a5,-20(s0)
c0011dd0:	0027e793          	ori	a5,a5,2
c0011dd4:	fef42623          	sw	a5,-20(s0)
			"RX VLAN TAG is not built in hardware\r\n");
		}
	}

	/* Enable extended transmit VLAN strip option */
	if (DepOptions & XAE_EXT_TXVLAN_STRP_OPTION) {
c0011dd8:	fec42703          	lw	a4,-20(s0)
c0011ddc:	000107b7          	lui	a5,0x10
c0011de0:	00f777b3          	and	a5,a4,a5
c0011de4:	02078a63          	beqz	a5,c0011e18 <XAxiEthernet_UpdateDepOptions+0x170>
		/*
		 * Check if hardware is built with extend TX VLAN stripping.
		 * if not, output an information message.
		 */
		if (XAxiEthernet_IsTxVlanStrp(InstancePtr)) {
c0011de8:	fdc42783          	lw	a5,-36(s0)
c0011dec:	0107c783          	lbu	a5,16(a5) # 10010 <_STACK_SIZE+0xf010>
c0011df0:	02078463          	beqz	a5,c0011e18 <XAxiEthernet_UpdateDepOptions+0x170>
			DepOptions |= XAE_FCS_INSERT_OPTION;
c0011df4:	fec42783          	lw	a5,-20(s0)
c0011df8:	0207e793          	ori	a5,a5,32
c0011dfc:	fef42623          	sw	a5,-20(s0)
			DepOptions &= ~XAE_VLAN_OPTION;
c0011e00:	fec42783          	lw	a5,-20(s0)
c0011e04:	ffb7f793          	andi	a5,a5,-5
c0011e08:	fef42623          	sw	a5,-20(s0)
			DepOptions |= XAE_JUMBO_OPTION;
c0011e0c:	fec42783          	lw	a5,-20(s0)
c0011e10:	0027e793          	ori	a5,a5,2
c0011e14:	fef42623          	sw	a5,-20(s0)
			xaxi_debug_printf("TX VLAN STRIP is not built in hardware\r\n");
		}
	}

	/* Enable extended receive VLAN strip option */
	if (DepOptions & XAE_EXT_RXVLAN_STRP_OPTION) {
c0011e18:	fec42703          	lw	a4,-20(s0)
c0011e1c:	000207b7          	lui	a5,0x20
c0011e20:	00f777b3          	and	a5,a4,a5
c0011e24:	02078a63          	beqz	a5,c0011e58 <XAxiEthernet_UpdateDepOptions+0x1b0>
		/*
		 * Check if hardware is built with extend RX VLAN stripping.
		 * if not, output an information message.
		 */
		if (XAxiEthernet_IsRxVlanStrp(InstancePtr)) {
c0011e28:	fdc42783          	lw	a5,-36(s0)
c0011e2c:	0117c783          	lbu	a5,17(a5) # 20011 <_STACK_SIZE+0x1f011>
c0011e30:	02078463          	beqz	a5,c0011e58 <XAxiEthernet_UpdateDepOptions+0x1b0>
			DepOptions |= XAE_FCS_STRIP_OPTION;
c0011e34:	fec42783          	lw	a5,-20(s0)
c0011e38:	0107e793          	ori	a5,a5,16
c0011e3c:	fef42623          	sw	a5,-20(s0)
			DepOptions &= ~XAE_VLAN_OPTION;
c0011e40:	fec42783          	lw	a5,-20(s0)
c0011e44:	ffb7f793          	andi	a5,a5,-5
c0011e48:	fef42623          	sw	a5,-20(s0)
			DepOptions |= XAE_JUMBO_OPTION;
c0011e4c:	fec42783          	lw	a5,-20(s0)
c0011e50:	0027e793          	ori	a5,a5,2
c0011e54:	fef42623          	sw	a5,-20(s0)
	 * are happy with. But we still need to keep original options
	 * in case option(s) are set/cleared, overall options can be managed.
	 * Return DepOptions to XAxiEthernet_[Set|Clear]Options for final
	 * configuration.
	 */
	return(DepOptions);
c0011e58:	fec42783          	lw	a5,-20(s0)
}
c0011e5c:	00078513          	mv	a0,a5
c0011e60:	02c12403          	lw	s0,44(sp)
c0011e64:	03010113          	addi	sp,sp,48
c0011e68:	00008067          	ret

c0011e6c <XAxiEthernet_SetOptions>:
* See xaxiethernet.h for a description of the available options.
*
*
******************************************************************************/
int XAxiEthernet_SetOptions(XAxiEthernet *InstancePtr, u32 Options)
{
c0011e6c:	fc010113          	addi	sp,sp,-64
c0011e70:	02112e23          	sw	ra,60(sp)
c0011e74:	02812c23          	sw	s0,56(sp)
c0011e78:	02912a23          	sw	s1,52(sp)
c0011e7c:	04010413          	addi	s0,sp,64
c0011e80:	fca42623          	sw	a0,-52(s0)
c0011e84:	fcb42423          	sw	a1,-56(s0)
	u32 RegTc;	/* Reflects original contents of TC  */
	u32 RegNewRcw1;	/* Reflects new contents of RCW1 */
	u32 RegNewTc;	/* Reflects new contents of TC  */
	u32 DepOptions;	/* Required dependent options for new features */

	Xil_AssertNonvoid(InstancePtr != NULL);
c0011e88:	fcc42783          	lw	a5,-52(s0)
c0011e8c:	02078463          	beqz	a5,c0011eb4 <XAxiEthernet_SetOptions+0x48>
c0011e90:	07ff1797          	auipc	a5,0x7ff1
c0011e94:	a8478793          	addi	a5,a5,-1404 # c8002914 <Xil_AssertStatus>
c0011e98:	0007a023          	sw	zero,0(a5)
	Xil_AssertNonvoid(InstancePtr->IsReady == XIL_COMPONENT_IS_READY);
c0011e9c:	fcc42783          	lw	a5,-52(s0)
c0011ea0:	0507a703          	lw	a4,80(a5)
c0011ea4:	111117b7          	lui	a5,0x11111
c0011ea8:	11178793          	addi	a5,a5,273 # 11111111 <_DMEM_LENGTH+0x10911111>
c0011eac:	04f71a63          	bne	a4,a5,c0011f00 <XAxiEthernet_SetOptions+0x94>
c0011eb0:	02c0006f          	j	c0011edc <XAxiEthernet_SetOptions+0x70>
	Xil_AssertNonvoid(InstancePtr != NULL);
c0011eb4:	34a00593          	li	a1,842
c0011eb8:	07fef517          	auipc	a0,0x7fef
c0011ebc:	f0450513          	addi	a0,a0,-252 # c8000dbc <__rodata_start+0xdbc>
c0011ec0:	3fd0b0ef          	jal	ra,c001dabc <Xil_Assert>
c0011ec4:	07ff1797          	auipc	a5,0x7ff1
c0011ec8:	a5078793          	addi	a5,a5,-1456 # c8002914 <Xil_AssertStatus>
c0011ecc:	00100713          	li	a4,1
c0011ed0:	00e7a023          	sw	a4,0(a5)
c0011ed4:	00000793          	li	a5,0
c0011ed8:	4c40006f          	j	c001239c <XAxiEthernet_SetOptions+0x530>
	Xil_AssertNonvoid(InstancePtr->IsReady == XIL_COMPONENT_IS_READY);
c0011edc:	07ff1797          	auipc	a5,0x7ff1
c0011ee0:	a3878793          	addi	a5,a5,-1480 # c8002914 <Xil_AssertStatus>
c0011ee4:	0007a023          	sw	zero,0(a5)

	/* Be sure device has been stopped */
	if (InstancePtr->IsStarted == XIL_COMPONENT_IS_STARTED) {
c0011ee8:	fcc42783          	lw	a5,-52(s0)
c0011eec:	04c7a703          	lw	a4,76(a5)
c0011ef0:	222227b7          	lui	a5,0x22222
c0011ef4:	22278793          	addi	a5,a5,546 # 22222222 <_DMEM_LENGTH+0x21a22222>
c0011ef8:	02f71c63          	bne	a4,a5,c0011f30 <XAxiEthernet_SetOptions+0xc4>
c0011efc:	02c0006f          	j	c0011f28 <XAxiEthernet_SetOptions+0xbc>
	Xil_AssertNonvoid(InstancePtr->IsReady == XIL_COMPONENT_IS_READY);
c0011f00:	34b00593          	li	a1,843
c0011f04:	07fef517          	auipc	a0,0x7fef
c0011f08:	eb850513          	addi	a0,a0,-328 # c8000dbc <__rodata_start+0xdbc>
c0011f0c:	3b10b0ef          	jal	ra,c001dabc <Xil_Assert>
c0011f10:	07ff1797          	auipc	a5,0x7ff1
c0011f14:	a0478793          	addi	a5,a5,-1532 # c8002914 <Xil_AssertStatus>
c0011f18:	00100713          	li	a4,1
c0011f1c:	00e7a023          	sw	a4,0(a5)
c0011f20:	00000793          	li	a5,0
c0011f24:	4780006f          	j	c001239c <XAxiEthernet_SetOptions+0x530>
		return (XST_DEVICE_IS_STARTED);
c0011f28:	00500793          	li	a5,5
c0011f2c:	4700006f          	j	c001239c <XAxiEthernet_SetOptions+0x530>
	/*
	 * Set options word to its new value.
	 * The step is required before calling _UpdateDepOptions() since
	 * we are operating on updated options.
	 */
	InstancePtr->Options |= Options;
c0011f30:	fcc42783          	lw	a5,-52(s0)
c0011f34:	0547a703          	lw	a4,84(a5)
c0011f38:	fc842783          	lw	a5,-56(s0)
c0011f3c:	00f76733          	or	a4,a4,a5
c0011f40:	fcc42783          	lw	a5,-52(s0)
c0011f44:	04e7aa23          	sw	a4,84(a5)
	/*
	 * There are options required to be on/off per hardware requirement.
	 * Invoke _UpdateDepOptions to check hardware availability and update
	 * options accordingly.
	 */
	DepOptions = XAxiEthernet_UpdateDepOptions(InstancePtr);
c0011f48:	fcc42503          	lw	a0,-52(s0)
c0011f4c:	d5dff0ef          	jal	ra,c0011ca8 <XAxiEthernet_UpdateDepOptions>
c0011f50:	fea42223          	sw	a0,-28(s0)

	/*
	 * New/extended function bit should be on if any new/extended features
	 * are on and hardware is built with them.
	 */
	if (DepOptions & (XAE_EXT_MULTICAST_OPTION   |
c0011f54:	fe442703          	lw	a4,-28(s0)
c0011f58:	000407b7          	lui	a5,0x40
c0011f5c:	80078793          	addi	a5,a5,-2048 # 3f800 <_STACK_SIZE+0x3e800>
c0011f60:	00f777b3          	and	a5,a4,a5
c0011f64:	02078c63          	beqz	a5,c0011f9c <XAxiEthernet_SetOptions+0x130>
			  XAE_EXT_TXVLAN_TAG_OPTION  |
			  XAE_EXT_RXVLAN_TAG_OPTION  |
			  XAE_EXT_TXVLAN_STRP_OPTION |
			  XAE_EXT_RXVLAN_STRP_OPTION)) {

		XAxiEthernet_WriteReg((InstancePtr)->Config.BaseAddress,
c0011f68:	fcc42783          	lw	a5,-52(s0)
c0011f6c:	0047a483          	lw	s1,4(a5)
c0011f70:	fcc42783          	lw	a5,-52(s0)
c0011f74:	0047a783          	lw	a5,4(a5)
c0011f78:	00078513          	mv	a0,a5
c0011f7c:	8c4ff0ef          	jal	ra,c0011040 <Xil_In32>
c0011f80:	00050713          	mv	a4,a0
c0011f84:	000017b7          	lui	a5,0x1
c0011f88:	80078793          	addi	a5,a5,-2048 # 800 <_STACK_SIZE-0x800>
c0011f8c:	00f767b3          	or	a5,a4,a5
c0011f90:	00078593          	mv	a1,a5
c0011f94:	00048513          	mv	a0,s1
c0011f98:	8d0ff0ef          	jal	ra,c0011068 <Xil_Out32>
	 * Many of these options will change the RCW1 or TC registers.
	 * To reduce the amount of IO to the device, group these options here
	 * and change them all at once.
	 */
	/* Get current register contents */
	RegRcw1 = XAxiEthernet_ReadReg(InstancePtr->Config.BaseAddress,
c0011f9c:	fcc42783          	lw	a5,-52(s0)
c0011fa0:	0047a783          	lw	a5,4(a5)
c0011fa4:	40478793          	addi	a5,a5,1028
c0011fa8:	00078513          	mv	a0,a5
c0011fac:	894ff0ef          	jal	ra,c0011040 <Xil_In32>
c0011fb0:	fea42023          	sw	a0,-32(s0)
							XAE_RCW1_OFFSET);
	RegTc = XAxiEthernet_ReadReg(InstancePtr->Config.BaseAddress,
c0011fb4:	fcc42783          	lw	a5,-52(s0)
c0011fb8:	0047a783          	lw	a5,4(a5)
c0011fbc:	40878793          	addi	a5,a5,1032
c0011fc0:	00078513          	mv	a0,a5
c0011fc4:	87cff0ef          	jal	ra,c0011040 <Xil_In32>
c0011fc8:	fca42e23          	sw	a0,-36(s0)
							XAE_TC_OFFSET);
	RegNewRcw1 = RegRcw1;
c0011fcc:	fe042783          	lw	a5,-32(s0)
c0011fd0:	fef42623          	sw	a5,-20(s0)
	RegNewTc = RegTc;
c0011fd4:	fdc42783          	lw	a5,-36(s0)
c0011fd8:	fef42423          	sw	a5,-24(s0)
	xaxi_debug_printf(
			"Options: 0x%0lx; default options: 0x%0x\r\n",Options,
							XAE_DEFAULT_OPTIONS);

	/* Turn on jumbo packet support for both Rx and Tx */
	if (DepOptions & XAE_JUMBO_OPTION) {
c0011fdc:	fe442783          	lw	a5,-28(s0)
c0011fe0:	0027f793          	andi	a5,a5,2
c0011fe4:	02078263          	beqz	a5,c0012008 <XAxiEthernet_SetOptions+0x19c>
		RegNewTc |= XAE_TC_JUM_MASK;
c0011fe8:	fe842703          	lw	a4,-24(s0)
c0011fec:	400007b7          	lui	a5,0x40000
c0011ff0:	00f767b3          	or	a5,a4,a5
c0011ff4:	fef42423          	sw	a5,-24(s0)
		RegNewRcw1 |= XAE_RCW1_JUM_MASK;
c0011ff8:	fec42703          	lw	a4,-20(s0)
c0011ffc:	400007b7          	lui	a5,0x40000
c0012000:	00f767b3          	or	a5,a4,a5
c0012004:	fef42623          	sw	a5,-20(s0)
	}

	/* Turn on VLAN packet support for both Rx and Tx */
	if (DepOptions & XAE_VLAN_OPTION) {
c0012008:	fe442783          	lw	a5,-28(s0)
c001200c:	0047f793          	andi	a5,a5,4
c0012010:	02078263          	beqz	a5,c0012034 <XAxiEthernet_SetOptions+0x1c8>
		RegNewTc |= XAE_TC_VLAN_MASK;
c0012014:	fe842703          	lw	a4,-24(s0)
c0012018:	080007b7          	lui	a5,0x8000
c001201c:	00f767b3          	or	a5,a4,a5
c0012020:	fef42423          	sw	a5,-24(s0)
		RegNewRcw1 |= XAE_RCW1_VLAN_MASK;
c0012024:	fec42703          	lw	a4,-20(s0)
c0012028:	080007b7          	lui	a5,0x8000
c001202c:	00f767b3          	or	a5,a4,a5
c0012030:	fef42623          	sw	a5,-20(s0)
	}

	/* Turn on FCS stripping on receive packets */
	if (DepOptions & XAE_FCS_STRIP_OPTION) {
c0012034:	fe442783          	lw	a5,-28(s0)
c0012038:	0107f793          	andi	a5,a5,16
c001203c:	00078c63          	beqz	a5,c0012054 <XAxiEthernet_SetOptions+0x1e8>
		xaxi_debug_printf(
				"setOptions: enabling fcs stripping\r\n");
		RegNewRcw1 &= ~XAE_RCW1_FCS_MASK;
c0012040:	fec42703          	lw	a4,-20(s0)
c0012044:	e00007b7          	lui	a5,0xe0000
c0012048:	fff78793          	addi	a5,a5,-1 # dfffffff <_end+0x17f7b77f>
c001204c:	00f777b3          	and	a5,a4,a5
c0012050:	fef42623          	sw	a5,-20(s0)
	}

	/* Turn on FCS insertion on transmit packets */
	if (DepOptions & XAE_FCS_INSERT_OPTION) {
c0012054:	fe442783          	lw	a5,-28(s0)
c0012058:	0207f793          	andi	a5,a5,32
c001205c:	00078c63          	beqz	a5,c0012074 <XAxiEthernet_SetOptions+0x208>
		xaxi_debug_printf(
				"setOptions: enabling fcs insertion\r\n");
		RegNewTc &= ~XAE_TC_FCS_MASK;
c0012060:	fe842703          	lw	a4,-24(s0)
c0012064:	e00007b7          	lui	a5,0xe0000
c0012068:	fff78793          	addi	a5,a5,-1 # dfffffff <_end+0x17f7b77f>
c001206c:	00f777b3          	and	a5,a4,a5
c0012070:	fef42423          	sw	a5,-24(s0)
	}

	/* Turn on length/type field checking on receive packets */
	if (DepOptions & XAE_LENTYPE_ERR_OPTION) {
c0012074:	fe442783          	lw	a5,-28(s0)
c0012078:	0407f793          	andi	a5,a5,64
c001207c:	00078c63          	beqz	a5,c0012094 <XAxiEthernet_SetOptions+0x228>
		RegNewRcw1 &= ~XAE_RCW1_LT_DIS_MASK;
c0012080:	fec42703          	lw	a4,-20(s0)
c0012084:	fe0007b7          	lui	a5,0xfe000
c0012088:	fff78793          	addi	a5,a5,-1 # fdffffff <_end+0x35f7b77f>
c001208c:	00f777b3          	and	a5,a4,a5
c0012090:	fef42623          	sw	a5,-20(s0)
	}

	/* Enable transmitter */
	if (DepOptions & XAE_TRANSMITTER_ENABLE_OPTION) {
c0012094:	fe442783          	lw	a5,-28(s0)
c0012098:	0807f793          	andi	a5,a5,128
c001209c:	00078a63          	beqz	a5,c00120b0 <XAxiEthernet_SetOptions+0x244>
		RegNewTc |= XAE_TC_TX_MASK;
c00120a0:	fe842703          	lw	a4,-24(s0)
c00120a4:	100007b7          	lui	a5,0x10000
c00120a8:	00f767b3          	or	a5,a4,a5
c00120ac:	fef42423          	sw	a5,-24(s0)
	}

	/* Enable receiver */
	if (DepOptions & XAE_RECEIVER_ENABLE_OPTION) {
c00120b0:	fe442783          	lw	a5,-28(s0)
c00120b4:	1007f793          	andi	a5,a5,256
c00120b8:	00078a63          	beqz	a5,c00120cc <XAxiEthernet_SetOptions+0x260>
		RegNewRcw1 |= XAE_RCW1_RX_MASK;
c00120bc:	fec42703          	lw	a4,-20(s0)
c00120c0:	100007b7          	lui	a5,0x10000
c00120c4:	00f767b3          	or	a5,a4,a5
c00120c8:	fef42623          	sw	a5,-20(s0)
	}

	/* Change the TC or RCW1 registers if they need to be modified */
	if (RegTc != RegNewTc) {
c00120cc:	fdc42703          	lw	a4,-36(s0)
c00120d0:	fe842783          	lw	a5,-24(s0)
c00120d4:	00f70e63          	beq	a4,a5,c00120f0 <XAxiEthernet_SetOptions+0x284>
		xaxi_debug_printf(
				"setOptions: writing tc: 0x%0lx\r\n", RegNewTc);
		XAxiEthernet_WriteReg(InstancePtr->Config.BaseAddress,
c00120d8:	fcc42783          	lw	a5,-52(s0)
c00120dc:	0047a783          	lw	a5,4(a5) # 10000004 <_DMEM_LENGTH+0xf800004>
c00120e0:	40878793          	addi	a5,a5,1032
c00120e4:	fe842583          	lw	a1,-24(s0)
c00120e8:	00078513          	mv	a0,a5
c00120ec:	f7dfe0ef          	jal	ra,c0011068 <Xil_Out32>
						XAE_TC_OFFSET, RegNewTc);
	}

	if (RegRcw1 != RegNewRcw1) {
c00120f0:	fe042703          	lw	a4,-32(s0)
c00120f4:	fec42783          	lw	a5,-20(s0)
c00120f8:	00f70e63          	beq	a4,a5,c0012114 <XAxiEthernet_SetOptions+0x2a8>
		xaxi_debug_printf(
			"setOptions: writing rcw1: 0x%0lx\r\n", RegNewRcw1);
		XAxiEthernet_WriteReg(InstancePtr->Config.BaseAddress,
c00120fc:	fcc42783          	lw	a5,-52(s0)
c0012100:	0047a783          	lw	a5,4(a5)
c0012104:	40478793          	addi	a5,a5,1028
c0012108:	fec42583          	lw	a1,-20(s0)
c001210c:	00078513          	mv	a0,a5
c0012110:	f59fe0ef          	jal	ra,c0011068 <Xil_Out32>
	 * Rest of options twiddle bits of other registers. Handle them one at
	 * a time
	 */

	/* Turn on flow control */
	if (DepOptions & XAE_FLOW_CONTROL_OPTION) {
c0012114:	fe442783          	lw	a5,-28(s0)
c0012118:	0087f793          	andi	a5,a5,8
c001211c:	04078263          	beqz	a5,c0012160 <XAxiEthernet_SetOptions+0x2f4>
		xaxi_debug_printf(
				"setOptions: enabling flow control\r\n");
		Reg = XAxiEthernet_ReadReg(InstancePtr->Config.BaseAddress,
c0012120:	fcc42783          	lw	a5,-52(s0)
c0012124:	0047a783          	lw	a5,4(a5)
c0012128:	40c78793          	addi	a5,a5,1036
c001212c:	00078513          	mv	a0,a5
c0012130:	f11fe0ef          	jal	ra,c0011040 <Xil_In32>
c0012134:	fca42c23          	sw	a0,-40(s0)
							XAE_FCC_OFFSET);
		Reg |= XAE_FCC_FCRX_MASK;
c0012138:	fd842703          	lw	a4,-40(s0)
c001213c:	200007b7          	lui	a5,0x20000
c0012140:	00f767b3          	or	a5,a4,a5
c0012144:	fcf42c23          	sw	a5,-40(s0)
		XAxiEthernet_WriteReg(InstancePtr->Config.BaseAddress,
c0012148:	fcc42783          	lw	a5,-52(s0)
c001214c:	0047a783          	lw	a5,4(a5) # 20000004 <_DMEM_LENGTH+0x1f800004>
c0012150:	40c78793          	addi	a5,a5,1036
c0012154:	fd842583          	lw	a1,-40(s0)
c0012158:	00078513          	mv	a0,a5
c001215c:	f0dfe0ef          	jal	ra,c0011068 <Xil_Out32>
	"setOptions: rcw1 is now (fcc):0x%0lx\r\n",
	XAxiEthernet_ReadReg(InstancePtr->Config.BaseAddress,
							XAE_RCW1_OFFSET));

	/* Turn on promiscuous frame filtering (all frames are received ) */
	if (DepOptions & XAE_PROMISC_OPTION) {
c0012160:	fe442783          	lw	a5,-28(s0)
c0012164:	0017f793          	andi	a5,a5,1
c0012168:	04078263          	beqz	a5,c00121ac <XAxiEthernet_SetOptions+0x340>
		xaxi_debug_printf(
				"setOptions: enabling promiscuous mode\r\n");
		Reg = XAxiEthernet_ReadReg(InstancePtr->Config.BaseAddress,
c001216c:	fcc42783          	lw	a5,-52(s0)
c0012170:	0047a783          	lw	a5,4(a5)
c0012174:	70878793          	addi	a5,a5,1800
c0012178:	00078513          	mv	a0,a5
c001217c:	ec5fe0ef          	jal	ra,c0011040 <Xil_In32>
c0012180:	fca42c23          	sw	a0,-40(s0)
							XAE_FMI_OFFSET);
		Reg |= XAE_FMI_PM_MASK;
c0012184:	fd842703          	lw	a4,-40(s0)
c0012188:	800007b7          	lui	a5,0x80000
c001218c:	00f767b3          	or	a5,a4,a5
c0012190:	fcf42c23          	sw	a5,-40(s0)
		XAxiEthernet_WriteReg(InstancePtr->Config.BaseAddress,
c0012194:	fcc42783          	lw	a5,-52(s0)
c0012198:	0047a783          	lw	a5,4(a5) # 80000004 <_end+0xb7f7b784>
c001219c:	70878793          	addi	a5,a5,1800
c00121a0:	fd842583          	lw	a1,-40(s0)
c00121a4:	00078513          	mv	a0,a5
c00121a8:	ec1fe0ef          	jal	ra,c0011068 <Xil_Out32>
	"setOptions: rcw1 is now (afm):0x%0lx\r\n",
	XAxiEthernet_ReadReg(InstancePtr->Config.BaseAddress,
							XAE_RCW1_OFFSET));

	/* Allow broadcast address filtering */
	if (DepOptions & XAE_BROADCAST_OPTION) {
c00121ac:	fe442783          	lw	a5,-28(s0)
c00121b0:	2007f793          	andi	a5,a5,512
c00121b4:	02078c63          	beqz	a5,c00121ec <XAxiEthernet_SetOptions+0x380>
		Reg = XAxiEthernet_ReadReg(InstancePtr->Config.BaseAddress,
c00121b8:	fcc42783          	lw	a5,-52(s0)
c00121bc:	0047a783          	lw	a5,4(a5)
c00121c0:	00078513          	mv	a0,a5
c00121c4:	e7dfe0ef          	jal	ra,c0011040 <Xil_In32>
c00121c8:	fca42c23          	sw	a0,-40(s0)
							XAE_RAF_OFFSET);
		Reg &= ~XAE_RAF_BCSTREJ_MASK;
c00121cc:	fd842783          	lw	a5,-40(s0)
c00121d0:	ffb7f793          	andi	a5,a5,-5
c00121d4:	fcf42c23          	sw	a5,-40(s0)
		XAxiEthernet_WriteReg(InstancePtr->Config.BaseAddress,
c00121d8:	fcc42783          	lw	a5,-52(s0)
c00121dc:	0047a783          	lw	a5,4(a5)
c00121e0:	fd842583          	lw	a1,-40(s0)
c00121e4:	00078513          	mv	a0,a5
c00121e8:	e81fe0ef          	jal	ra,c0011068 <Xil_Out32>
	"setOptions: rcw1 is now (raf):0x%0lx\r\n",
	XAxiEthernet_ReadReg(InstancePtr->Config.BaseAddress,
							XAE_RCW1_OFFSET));

	/* Allow multicast address filtering */
	if (DepOptions & (XAE_MULTICAST_OPTION | XAE_EXT_MULTICAST_OPTION)) {
c00121ec:	fe442703          	lw	a4,-28(s0)
c00121f0:	000017b7          	lui	a5,0x1
c00121f4:	c0078793          	addi	a5,a5,-1024 # c00 <_STACK_SIZE-0x400>
c00121f8:	00f777b3          	and	a5,a4,a5
c00121fc:	02078c63          	beqz	a5,c0012234 <XAxiEthernet_SetOptions+0x3c8>
		Reg = XAxiEthernet_ReadReg(InstancePtr->Config.BaseAddress,
c0012200:	fcc42783          	lw	a5,-52(s0)
c0012204:	0047a783          	lw	a5,4(a5)
c0012208:	00078513          	mv	a0,a5
c001220c:	e35fe0ef          	jal	ra,c0011040 <Xil_In32>
c0012210:	fca42c23          	sw	a0,-40(s0)
							XAE_RAF_OFFSET);
		Reg &= ~XAE_RAF_MCSTREJ_MASK;
c0012214:	fd842783          	lw	a5,-40(s0)
c0012218:	ffd7f793          	andi	a5,a5,-3
c001221c:	fcf42c23          	sw	a5,-40(s0)
		XAxiEthernet_WriteReg(InstancePtr->Config.BaseAddress,
c0012220:	fcc42783          	lw	a5,-52(s0)
c0012224:	0047a783          	lw	a5,4(a5)
c0012228:	fd842583          	lw	a1,-40(s0)
c001222c:	00078513          	mv	a0,a5
c0012230:	e39fe0ef          	jal	ra,c0011068 <Xil_Out32>
	 * driver. No register modifications are needed at this time.
	 * Reflecting the option in InstancePtr->Options is good enough for
	 * now.
	 */
	/* Enable extended multicast option */
	if (DepOptions & XAE_EXT_MULTICAST_OPTION) {
c0012234:	fe442703          	lw	a4,-28(s0)
c0012238:	000017b7          	lui	a5,0x1
c001223c:	80078793          	addi	a5,a5,-2048 # 800 <_STACK_SIZE-0x800>
c0012240:	00f777b3          	and	a5,a4,a5
c0012244:	02078a63          	beqz	a5,c0012278 <XAxiEthernet_SetOptions+0x40c>
		XAxiEthernet_WriteReg((InstancePtr)->Config.BaseAddress,
c0012248:	fcc42783          	lw	a5,-52(s0)
c001224c:	0047a483          	lw	s1,4(a5)
c0012250:	fcc42783          	lw	a5,-52(s0)
c0012254:	0047a783          	lw	a5,4(a5)
c0012258:	00078513          	mv	a0,a5
c001225c:	de5fe0ef          	jal	ra,c0011040 <Xil_In32>
c0012260:	00050713          	mv	a4,a0
c0012264:	000017b7          	lui	a5,0x1
c0012268:	00f767b3          	or	a5,a4,a5
c001226c:	00078593          	mv	a1,a5
c0012270:	00048513          	mv	a0,s1
c0012274:	df5fe0ef          	jal	ra,c0011068 <Xil_Out32>
	 * New/extended [TX|RX] VLAN translation option does not have specific
	 * bits to on/off.
	 */

	/* Enable extended transmit VLAN tag option */
	if (DepOptions & XAE_EXT_TXVLAN_TAG_OPTION) {
c0012278:	fe442703          	lw	a4,-28(s0)
c001227c:	000047b7          	lui	a5,0x4
c0012280:	00f777b3          	and	a5,a4,a5
c0012284:	02078e63          	beqz	a5,c00122c0 <XAxiEthernet_SetOptions+0x454>
		Reg = XAxiEthernet_ReadReg((InstancePtr)->Config.BaseAddress,
c0012288:	fcc42783          	lw	a5,-52(s0)
c001228c:	0047a783          	lw	a5,4(a5) # 4004 <_STACK_SIZE+0x3004>
c0012290:	00078513          	mv	a0,a5
c0012294:	dadfe0ef          	jal	ra,c0011040 <Xil_In32>
c0012298:	fca42c23          	sw	a0,-40(s0)
							XAE_RAF_OFFSET);
		Reg = (Reg & ~XAE_RAF_TXVTAGMODE_MASK) |
c001229c:	fd842783          	lw	a5,-40(s0)
c00122a0:	fe77f793          	andi	a5,a5,-25
c00122a4:	0087e793          	ori	a5,a5,8
c00122a8:	fcf42c23          	sw	a5,-40(s0)
			  (XAE_DEFAULT_TXVTAG_MODE <<
						XAE_RAF_TXVTAGMODE_SHIFT);
		XAxiEthernet_WriteReg((InstancePtr)->Config.BaseAddress,
c00122ac:	fcc42783          	lw	a5,-52(s0)
c00122b0:	0047a783          	lw	a5,4(a5)
c00122b4:	fd842583          	lw	a1,-40(s0)
c00122b8:	00078513          	mv	a0,a5
c00122bc:	dadfe0ef          	jal	ra,c0011068 <Xil_Out32>
							XAE_RAF_OFFSET, Reg);
	}

	/* Enable extended receive VLAN tag option */
	if (DepOptions & XAE_EXT_RXVLAN_TAG_OPTION) {
c00122c0:	fe442703          	lw	a4,-28(s0)
c00122c4:	000087b7          	lui	a5,0x8
c00122c8:	00f777b3          	and	a5,a4,a5
c00122cc:	02078e63          	beqz	a5,c0012308 <XAxiEthernet_SetOptions+0x49c>
		Reg = XAxiEthernet_ReadReg((InstancePtr)->Config.BaseAddress,
c00122d0:	fcc42783          	lw	a5,-52(s0)
c00122d4:	0047a783          	lw	a5,4(a5) # 8004 <_STACK_SIZE+0x7004>
c00122d8:	00078513          	mv	a0,a5
c00122dc:	d65fe0ef          	jal	ra,c0011040 <Xil_In32>
c00122e0:	fca42c23          	sw	a0,-40(s0)
							XAE_RAF_OFFSET);
		Reg = (Reg & ~XAE_RAF_RXVTAGMODE_MASK) |
c00122e4:	fd842783          	lw	a5,-40(s0)
c00122e8:	f9f7f793          	andi	a5,a5,-97
c00122ec:	0207e793          	ori	a5,a5,32
c00122f0:	fcf42c23          	sw	a5,-40(s0)
			  (XAE_DEFAULT_RXVTAG_MODE <<
						XAE_RAF_RXVTAGMODE_SHIFT);
		XAxiEthernet_WriteReg((InstancePtr)->Config.BaseAddress,
c00122f4:	fcc42783          	lw	a5,-52(s0)
c00122f8:	0047a783          	lw	a5,4(a5)
c00122fc:	fd842583          	lw	a1,-40(s0)
c0012300:	00078513          	mv	a0,a5
c0012304:	d65fe0ef          	jal	ra,c0011068 <Xil_Out32>
							XAE_RAF_OFFSET, Reg);
	}

	/* Enable extended transmit VLAN strip option */
	if (Options & XAE_EXT_TXVLAN_STRP_OPTION) {
c0012308:	fc842703          	lw	a4,-56(s0)
c001230c:	000107b7          	lui	a5,0x10
c0012310:	00f777b3          	and	a5,a4,a5
c0012314:	02078e63          	beqz	a5,c0012350 <XAxiEthernet_SetOptions+0x4e4>
		Reg = XAxiEthernet_ReadReg((InstancePtr)->Config.BaseAddress,
c0012318:	fcc42783          	lw	a5,-52(s0)
c001231c:	0047a783          	lw	a5,4(a5) # 10004 <_STACK_SIZE+0xf004>
c0012320:	00078513          	mv	a0,a5
c0012324:	d1dfe0ef          	jal	ra,c0011040 <Xil_In32>
c0012328:	fca42c23          	sw	a0,-40(s0)
							XAE_RAF_OFFSET);
		Reg = (Reg & ~XAE_RAF_TXVSTRPMODE_MASK) |
c001232c:	fd842783          	lw	a5,-40(s0)
c0012330:	e7f7f793          	andi	a5,a5,-385
c0012334:	0807e793          	ori	a5,a5,128
c0012338:	fcf42c23          	sw	a5,-40(s0)
			  (XAE_DEFAULT_TXVSTRP_MODE <<
						XAE_RAF_TXVSTRPMODE_SHIFT);
		XAxiEthernet_WriteReg((InstancePtr)->Config.BaseAddress,
c001233c:	fcc42783          	lw	a5,-52(s0)
c0012340:	0047a783          	lw	a5,4(a5)
c0012344:	fd842583          	lw	a1,-40(s0)
c0012348:	00078513          	mv	a0,a5
c001234c:	d1dfe0ef          	jal	ra,c0011068 <Xil_Out32>
							XAE_RAF_OFFSET, Reg);
	}

	/* Enable extended receive VLAN strip option */
	if (Options & XAE_EXT_RXVLAN_STRP_OPTION) {
c0012350:	fc842703          	lw	a4,-56(s0)
c0012354:	000207b7          	lui	a5,0x20
c0012358:	00f777b3          	and	a5,a4,a5
c001235c:	02078e63          	beqz	a5,c0012398 <XAxiEthernet_SetOptions+0x52c>
		Reg = XAxiEthernet_ReadReg((InstancePtr)->Config.BaseAddress,
c0012360:	fcc42783          	lw	a5,-52(s0)
c0012364:	0047a783          	lw	a5,4(a5) # 20004 <_STACK_SIZE+0x1f004>
c0012368:	00078513          	mv	a0,a5
c001236c:	cd5fe0ef          	jal	ra,c0011040 <Xil_In32>
c0012370:	fca42c23          	sw	a0,-40(s0)
							XAE_RAF_OFFSET);
		Reg = (Reg & ~XAE_RAF_RXVSTRPMODE_MASK) |
c0012374:	fd842783          	lw	a5,-40(s0)
c0012378:	9ff7f793          	andi	a5,a5,-1537
c001237c:	2007e793          	ori	a5,a5,512
c0012380:	fcf42c23          	sw	a5,-40(s0)
			  (XAE_DEFAULT_RXVSTRP_MODE <<
						XAE_RAF_RXVSTRPMODE_SHIFT);
		XAxiEthernet_WriteReg((InstancePtr)->Config.BaseAddress,
c0012384:	fcc42783          	lw	a5,-52(s0)
c0012388:	0047a783          	lw	a5,4(a5)
c001238c:	fd842583          	lw	a1,-40(s0)
c0012390:	00078513          	mv	a0,a5
c0012394:	cd5fe0ef          	jal	ra,c0011068 <Xil_Out32>
	 * driver. No register modifications are needed at this time.
	 * Reflecting the option in InstancePtr->Options is good enough for
	 * now.
	 */
	xaxi_debug_printf("setOptions: returning SUCCESS\r\n");
	return (XST_SUCCESS);
c0012398:	00000793          	li	a5,0
}
c001239c:	00078513          	mv	a0,a5
c00123a0:	03c12083          	lw	ra,60(sp)
c00123a4:	03812403          	lw	s0,56(sp)
c00123a8:	03412483          	lw	s1,52(sp)
c00123ac:	04010113          	addi	sp,sp,64
c00123b0:	00008067          	ret

c00123b4 <XAxiEthernet_ClearOptions>:
* @note
* See xaxiethernet.h for a description of the available options.
*
******************************************************************************/
int XAxiEthernet_ClearOptions(XAxiEthernet *InstancePtr, u32 Options)
{
c00123b4:	fc010113          	addi	sp,sp,-64
c00123b8:	02112e23          	sw	ra,60(sp)
c00123bc:	02812c23          	sw	s0,56(sp)
c00123c0:	02912a23          	sw	s1,52(sp)
c00123c4:	04010413          	addi	s0,sp,64
c00123c8:	fca42623          	sw	a0,-52(s0)
c00123cc:	fcb42423          	sw	a1,-56(s0)
	u32 RegTc;	/* Reflects original contents of TC  */
	u32 RegNewRcw1;	/* Reflects new contents of RCW1 */
	u32 RegNewTc;	/* Reflects new contents of TC  */
	u32 DepOptions;	/* Required dependent options for new features */

	Xil_AssertNonvoid(InstancePtr != NULL);
c00123d0:	fcc42783          	lw	a5,-52(s0)
c00123d4:	02078463          	beqz	a5,c00123fc <XAxiEthernet_ClearOptions+0x48>
c00123d8:	07ff0797          	auipc	a5,0x7ff0
c00123dc:	53c78793          	addi	a5,a5,1340 # c8002914 <Xil_AssertStatus>
c00123e0:	0007a023          	sw	zero,0(a5)
	Xil_AssertNonvoid(InstancePtr->IsReady == XIL_COMPONENT_IS_READY);
c00123e4:	fcc42783          	lw	a5,-52(s0)
c00123e8:	0507a703          	lw	a4,80(a5)
c00123ec:	111117b7          	lui	a5,0x11111
c00123f0:	11178793          	addi	a5,a5,273 # 11111111 <_DMEM_LENGTH+0x10911111>
c00123f4:	04f71a63          	bne	a4,a5,c0012448 <XAxiEthernet_ClearOptions+0x94>
c00123f8:	02c0006f          	j	c0012424 <XAxiEthernet_ClearOptions+0x70>
	Xil_AssertNonvoid(InstancePtr != NULL);
c00123fc:	46900593          	li	a1,1129
c0012400:	07fef517          	auipc	a0,0x7fef
c0012404:	9bc50513          	addi	a0,a0,-1604 # c8000dbc <__rodata_start+0xdbc>
c0012408:	6b40b0ef          	jal	ra,c001dabc <Xil_Assert>
c001240c:	07ff0797          	auipc	a5,0x7ff0
c0012410:	50878793          	addi	a5,a5,1288 # c8002914 <Xil_AssertStatus>
c0012414:	00100713          	li	a4,1
c0012418:	00e7a023          	sw	a4,0(a5)
c001241c:	00000793          	li	a5,0
c0012420:	4c80006f          	j	c00128e8 <XAxiEthernet_ClearOptions+0x534>
	Xil_AssertNonvoid(InstancePtr->IsReady == XIL_COMPONENT_IS_READY);
c0012424:	07ff0797          	auipc	a5,0x7ff0
c0012428:	4f078793          	addi	a5,a5,1264 # c8002914 <Xil_AssertStatus>
c001242c:	0007a023          	sw	zero,0(a5)


	xaxi_debug_printf("XAxiEthernet_ClearOptions: 0x%08lx\r\n",
								Options);
	/* Be sure device has been stopped */
	if (InstancePtr->IsStarted == XIL_COMPONENT_IS_STARTED) {
c0012430:	fcc42783          	lw	a5,-52(s0)
c0012434:	04c7a703          	lw	a4,76(a5)
c0012438:	222227b7          	lui	a5,0x22222
c001243c:	22278793          	addi	a5,a5,546 # 22222222 <_DMEM_LENGTH+0x21a22222>
c0012440:	02f71c63          	bne	a4,a5,c0012478 <XAxiEthernet_ClearOptions+0xc4>
c0012444:	02c0006f          	j	c0012470 <XAxiEthernet_ClearOptions+0xbc>
	Xil_AssertNonvoid(InstancePtr->IsReady == XIL_COMPONENT_IS_READY);
c0012448:	46a00593          	li	a1,1130
c001244c:	07fef517          	auipc	a0,0x7fef
c0012450:	97050513          	addi	a0,a0,-1680 # c8000dbc <__rodata_start+0xdbc>
c0012454:	6680b0ef          	jal	ra,c001dabc <Xil_Assert>
c0012458:	07ff0797          	auipc	a5,0x7ff0
c001245c:	4bc78793          	addi	a5,a5,1212 # c8002914 <Xil_AssertStatus>
c0012460:	00100713          	li	a4,1
c0012464:	00e7a023          	sw	a4,0(a5)
c0012468:	00000793          	li	a5,0
c001246c:	47c0006f          	j	c00128e8 <XAxiEthernet_ClearOptions+0x534>
		return (XST_DEVICE_IS_STARTED);
c0012470:	00500793          	li	a5,5
c0012474:	4740006f          	j	c00128e8 <XAxiEthernet_ClearOptions+0x534>
	/*
	 * Set options word to its new value.
	 * The step is required before calling _UpdateDepOptions() since
	 * we are operating on updated options.
	 */
	InstancePtr->Options &= ~Options;
c0012478:	fcc42783          	lw	a5,-52(s0)
c001247c:	0547a703          	lw	a4,84(a5)
c0012480:	fc842783          	lw	a5,-56(s0)
c0012484:	fff7c793          	not	a5,a5
c0012488:	00f77733          	and	a4,a4,a5
c001248c:	fcc42783          	lw	a5,-52(s0)
c0012490:	04e7aa23          	sw	a4,84(a5)
	/*
	 * There are options required to be on/off per hardware requirement.
	 * Invoke _UpdateDepOptions to check hardware availability and update
	 * options accordingly.
	 */
	DepOptions = ~(XAxiEthernet_UpdateDepOptions(InstancePtr));
c0012494:	fcc42503          	lw	a0,-52(s0)
c0012498:	811ff0ef          	jal	ra,c0011ca8 <XAxiEthernet_UpdateDepOptions>
c001249c:	00050793          	mv	a5,a0
c00124a0:	fff7c793          	not	a5,a5
c00124a4:	fef42223          	sw	a5,-28(s0)
	/*
	 * New/extended function bit should be off if none of new/extended
	 * features is on after hardware is validated and gone through
	 * _UpdateDepOptions().
	 */
	if (!(~(DepOptions) &  (XAE_EXT_MULTICAST_OPTION   |
c00124a8:	fe442783          	lw	a5,-28(s0)
c00124ac:	fff7c713          	not	a4,a5
c00124b0:	000407b7          	lui	a5,0x40
c00124b4:	80078793          	addi	a5,a5,-2048 # 3f800 <_STACK_SIZE+0x3e800>
c00124b8:	00f777b3          	and	a5,a4,a5
c00124bc:	02079c63          	bnez	a5,c00124f4 <XAxiEthernet_ClearOptions+0x140>
				XAE_EXT_RXVLAN_TRAN_OPTION |
				XAE_EXT_TXVLAN_TAG_OPTION  |
				XAE_EXT_RXVLAN_TAG_OPTION  |
				XAE_EXT_TXVLAN_STRP_OPTION |
				XAE_EXT_RXVLAN_STRP_OPTION))) {
		XAxiEthernet_WriteReg((InstancePtr)->Config.BaseAddress,
c00124c0:	fcc42783          	lw	a5,-52(s0)
c00124c4:	0047a483          	lw	s1,4(a5)
c00124c8:	fcc42783          	lw	a5,-52(s0)
c00124cc:	0047a783          	lw	a5,4(a5)
c00124d0:	00078513          	mv	a0,a5
c00124d4:	b6dfe0ef          	jal	ra,c0011040 <Xil_In32>
c00124d8:	00050713          	mv	a4,a0
c00124dc:	fffff7b7          	lui	a5,0xfffff
c00124e0:	7ff78793          	addi	a5,a5,2047 # fffff7ff <_end+0x37f7af7f>
c00124e4:	00f777b3          	and	a5,a4,a5
c00124e8:	00078593          	mv	a1,a5
c00124ec:	00048513          	mv	a0,s1
c00124f0:	b79fe0ef          	jal	ra,c0011068 <Xil_Out32>
	 * Group these options here and change them all at once. What we are
	 * trying to accomplish is to reduce the amount of IO to the device
	 */

	/* Get the current register contents */
	RegRcw1 = XAxiEthernet_ReadReg(InstancePtr->Config.BaseAddress,
c00124f4:	fcc42783          	lw	a5,-52(s0)
c00124f8:	0047a783          	lw	a5,4(a5)
c00124fc:	40478793          	addi	a5,a5,1028
c0012500:	00078513          	mv	a0,a5
c0012504:	b3dfe0ef          	jal	ra,c0011040 <Xil_In32>
c0012508:	fea42023          	sw	a0,-32(s0)
							XAE_RCW1_OFFSET);
	RegTc = XAxiEthernet_ReadReg(InstancePtr->Config.BaseAddress,
c001250c:	fcc42783          	lw	a5,-52(s0)
c0012510:	0047a783          	lw	a5,4(a5)
c0012514:	40878793          	addi	a5,a5,1032
c0012518:	00078513          	mv	a0,a5
c001251c:	b25fe0ef          	jal	ra,c0011040 <Xil_In32>
c0012520:	fca42e23          	sw	a0,-36(s0)
							XAE_TC_OFFSET);
	RegNewRcw1 = RegRcw1;
c0012524:	fe042783          	lw	a5,-32(s0)
c0012528:	fef42623          	sw	a5,-20(s0)
	RegNewTc = RegTc;
c001252c:	fdc42783          	lw	a5,-36(s0)
c0012530:	fef42423          	sw	a5,-24(s0)

	/* Turn off jumbo packet support for both Rx and Tx */
	if (DepOptions & XAE_JUMBO_OPTION) {
c0012534:	fe442783          	lw	a5,-28(s0)
c0012538:	0027f793          	andi	a5,a5,2
c001253c:	02078663          	beqz	a5,c0012568 <XAxiEthernet_ClearOptions+0x1b4>
		xaxi_debug_printf(
		"XAxiEthernet_ClearOptions: disabling jumbo\r\n");
		RegNewTc &= ~XAE_TC_JUM_MASK;
c0012540:	fe842703          	lw	a4,-24(s0)
c0012544:	c00007b7          	lui	a5,0xc0000
c0012548:	fff78793          	addi	a5,a5,-1 # bfffffff <_end+0xf7f7b77f>
c001254c:	00f777b3          	and	a5,a4,a5
c0012550:	fef42423          	sw	a5,-24(s0)
		RegNewRcw1 &= ~XAE_RCW1_JUM_MASK;
c0012554:	fec42703          	lw	a4,-20(s0)
c0012558:	c00007b7          	lui	a5,0xc0000
c001255c:	fff78793          	addi	a5,a5,-1 # bfffffff <_end+0xf7f7b77f>
c0012560:	00f777b3          	and	a5,a4,a5
c0012564:	fef42623          	sw	a5,-20(s0)
	}

	/* Turn off VLAN packet support for both Rx and Tx */
	if (DepOptions & XAE_VLAN_OPTION) {
c0012568:	fe442783          	lw	a5,-28(s0)
c001256c:	0047f793          	andi	a5,a5,4
c0012570:	02078663          	beqz	a5,c001259c <XAxiEthernet_ClearOptions+0x1e8>
		xaxi_debug_printf(
		"XAxiEthernet_ClearOptions: disabling vlan\r\n");
		RegNewTc &= ~XAE_TC_VLAN_MASK;
c0012574:	fe842703          	lw	a4,-24(s0)
c0012578:	f80007b7          	lui	a5,0xf8000
c001257c:	fff78793          	addi	a5,a5,-1 # f7ffffff <_end+0x2ff7b77f>
c0012580:	00f777b3          	and	a5,a4,a5
c0012584:	fef42423          	sw	a5,-24(s0)
		RegNewRcw1 &= ~XAE_RCW1_VLAN_MASK;
c0012588:	fec42703          	lw	a4,-20(s0)
c001258c:	f80007b7          	lui	a5,0xf8000
c0012590:	fff78793          	addi	a5,a5,-1 # f7ffffff <_end+0x2ff7b77f>
c0012594:	00f777b3          	and	a5,a4,a5
c0012598:	fef42623          	sw	a5,-20(s0)
	}

	/* Turn off FCS stripping on receive packets */
	if (DepOptions & XAE_FCS_STRIP_OPTION) {
c001259c:	fe442783          	lw	a5,-28(s0)
c00125a0:	0107f793          	andi	a5,a5,16
c00125a4:	00078a63          	beqz	a5,c00125b8 <XAxiEthernet_ClearOptions+0x204>
		xaxi_debug_printf(
		"XAxiEthernet_ClearOptions: disabling fcs strip\r\n");
		RegNewRcw1 |= XAE_RCW1_FCS_MASK;
c00125a8:	fec42703          	lw	a4,-20(s0)
c00125ac:	200007b7          	lui	a5,0x20000
c00125b0:	00f767b3          	or	a5,a4,a5
c00125b4:	fef42623          	sw	a5,-20(s0)
	}

	/* Turn off FCS insertion on transmit packets */
	if (DepOptions & XAE_FCS_INSERT_OPTION) {
c00125b8:	fe442783          	lw	a5,-28(s0)
c00125bc:	0207f793          	andi	a5,a5,32
c00125c0:	00078a63          	beqz	a5,c00125d4 <XAxiEthernet_ClearOptions+0x220>
		xaxi_debug_printf(
		"XAxiEthernet_ClearOptions: disabling fcs insert\r\n");
		RegNewTc |= XAE_TC_FCS_MASK;
c00125c4:	fe842703          	lw	a4,-24(s0)
c00125c8:	200007b7          	lui	a5,0x20000
c00125cc:	00f767b3          	or	a5,a4,a5
c00125d0:	fef42423          	sw	a5,-24(s0)
	}

	/* Turn off length/type field checking on receive packets */
	if (DepOptions & XAE_LENTYPE_ERR_OPTION) {
c00125d4:	fe442783          	lw	a5,-28(s0)
c00125d8:	0407f793          	andi	a5,a5,64
c00125dc:	00078a63          	beqz	a5,c00125f0 <XAxiEthernet_ClearOptions+0x23c>
		xaxi_debug_printf(
		"XAxiEthernet_ClearOptions: disabling lentype err\r\n");
		RegNewRcw1 |= XAE_RCW1_LT_DIS_MASK;
c00125e0:	fec42703          	lw	a4,-20(s0)
c00125e4:	020007b7          	lui	a5,0x2000
c00125e8:	00f767b3          	or	a5,a4,a5
c00125ec:	fef42623          	sw	a5,-20(s0)
	}

	/* Disable transmitter */
	if (DepOptions & XAE_TRANSMITTER_ENABLE_OPTION) {
c00125f0:	fe442783          	lw	a5,-28(s0)
c00125f4:	0807f793          	andi	a5,a5,128
c00125f8:	00078c63          	beqz	a5,c0012610 <XAxiEthernet_ClearOptions+0x25c>
		xaxi_debug_printf(
		"XAxiEthernet_ClearOptions: disabling transmitter\r\n");
		RegNewTc &= ~XAE_TC_TX_MASK;
c00125fc:	fe842703          	lw	a4,-24(s0)
c0012600:	f00007b7          	lui	a5,0xf0000
c0012604:	fff78793          	addi	a5,a5,-1 # efffffff <_end+0x27f7b77f>
c0012608:	00f777b3          	and	a5,a4,a5
c001260c:	fef42423          	sw	a5,-24(s0)
	}

	/* Disable receiver */
	if (DepOptions & XAE_RECEIVER_ENABLE_OPTION) {
c0012610:	fe442783          	lw	a5,-28(s0)
c0012614:	1007f793          	andi	a5,a5,256
c0012618:	00078c63          	beqz	a5,c0012630 <XAxiEthernet_ClearOptions+0x27c>
		xaxi_debug_printf(
		"XAxiEthernet_ClearOptions: disabling receiver\r\n");
		RegNewRcw1 &= ~XAE_RCW1_RX_MASK;
c001261c:	fec42703          	lw	a4,-20(s0)
c0012620:	f00007b7          	lui	a5,0xf0000
c0012624:	fff78793          	addi	a5,a5,-1 # efffffff <_end+0x27f7b77f>
c0012628:	00f777b3          	and	a5,a4,a5
c001262c:	fef42623          	sw	a5,-20(s0)
	}

	/* Change the TC and RCW1 registers if they need to be
	 * modified
	 */
	if (RegTc != RegNewTc) {
c0012630:	fdc42703          	lw	a4,-36(s0)
c0012634:	fe842783          	lw	a5,-24(s0)
c0012638:	00f70e63          	beq	a4,a5,c0012654 <XAxiEthernet_ClearOptions+0x2a0>
		xaxi_debug_printf(
		"XAxiEthernet_ClearOptions: setting TC: 0x%0lx\r\n", RegNewTc);
		XAxiEthernet_WriteReg(InstancePtr->Config.BaseAddress,
c001263c:	fcc42783          	lw	a5,-52(s0)
c0012640:	0047a783          	lw	a5,4(a5)
c0012644:	40878793          	addi	a5,a5,1032
c0012648:	fe842583          	lw	a1,-24(s0)
c001264c:	00078513          	mv	a0,a5
c0012650:	a19fe0ef          	jal	ra,c0011068 <Xil_Out32>
						XAE_TC_OFFSET, RegNewTc);
	}

	if (RegRcw1 != RegNewRcw1) {
c0012654:	fe042703          	lw	a4,-32(s0)
c0012658:	fec42783          	lw	a5,-20(s0)
c001265c:	00f70e63          	beq	a4,a5,c0012678 <XAxiEthernet_ClearOptions+0x2c4>
		xaxi_debug_printf(
		"XAxiEthernet_ClearOptions: setting RCW1: 0x%0lx\r\n",RegNewRcw1);
		XAxiEthernet_WriteReg(InstancePtr->Config.BaseAddress,
c0012660:	fcc42783          	lw	a5,-52(s0)
c0012664:	0047a783          	lw	a5,4(a5)
c0012668:	40478793          	addi	a5,a5,1028
c001266c:	fec42583          	lw	a1,-20(s0)
c0012670:	00078513          	mv	a0,a5
c0012674:	9f5fe0ef          	jal	ra,c0011068 <Xil_Out32>
	 * Rest of options twiddle bits of other registers. Handle them one at
	 * a time
	 */

	/* Turn off flow control */
	if (DepOptions & XAE_FLOW_CONTROL_OPTION) {
c0012678:	fe442783          	lw	a5,-28(s0)
c001267c:	0087f793          	andi	a5,a5,8
c0012680:	04078463          	beqz	a5,c00126c8 <XAxiEthernet_ClearOptions+0x314>
		xaxi_debug_printf(
		"XAxiEthernet_ClearOptions: disabling flow control\r\n");
		Reg = XAxiEthernet_ReadReg(InstancePtr->Config.BaseAddress,
c0012684:	fcc42783          	lw	a5,-52(s0)
c0012688:	0047a783          	lw	a5,4(a5)
c001268c:	40c78793          	addi	a5,a5,1036
c0012690:	00078513          	mv	a0,a5
c0012694:	9adfe0ef          	jal	ra,c0011040 <Xil_In32>
c0012698:	fca42c23          	sw	a0,-40(s0)
							XAE_FCC_OFFSET);
		Reg &= ~XAE_FCC_FCRX_MASK;
c001269c:	fd842703          	lw	a4,-40(s0)
c00126a0:	e00007b7          	lui	a5,0xe0000
c00126a4:	fff78793          	addi	a5,a5,-1 # dfffffff <_end+0x17f7b77f>
c00126a8:	00f777b3          	and	a5,a4,a5
c00126ac:	fcf42c23          	sw	a5,-40(s0)
		XAxiEthernet_WriteReg(InstancePtr->Config.BaseAddress,
c00126b0:	fcc42783          	lw	a5,-52(s0)
c00126b4:	0047a783          	lw	a5,4(a5)
c00126b8:	40c78793          	addi	a5,a5,1036
c00126bc:	fd842583          	lw	a1,-40(s0)
c00126c0:	00078513          	mv	a0,a5
c00126c4:	9a5fe0ef          	jal	ra,c0011068 <Xil_Out32>
							XAE_FCC_OFFSET, Reg);
	}

	/* Turn off promiscuous frame filtering */
	if (DepOptions & XAE_PROMISC_OPTION) {
c00126c8:	fe442783          	lw	a5,-28(s0)
c00126cc:	0017f793          	andi	a5,a5,1
c00126d0:	04078463          	beqz	a5,c0012718 <XAxiEthernet_ClearOptions+0x364>
		xaxi_debug_printf(
		"XAxiEthernet_ClearOptions: disabling promiscuous mode\r\n");
		Reg = XAxiEthernet_ReadReg(InstancePtr->Config.BaseAddress,
c00126d4:	fcc42783          	lw	a5,-52(s0)
c00126d8:	0047a783          	lw	a5,4(a5)
c00126dc:	70878793          	addi	a5,a5,1800
c00126e0:	00078513          	mv	a0,a5
c00126e4:	95dfe0ef          	jal	ra,c0011040 <Xil_In32>
c00126e8:	fca42c23          	sw	a0,-40(s0)
							XAE_FMI_OFFSET);
		Reg &= ~XAE_FMI_PM_MASK;
c00126ec:	fd842703          	lw	a4,-40(s0)
c00126f0:	800007b7          	lui	a5,0x80000
c00126f4:	fff7c793          	not	a5,a5
c00126f8:	00f777b3          	and	a5,a4,a5
c00126fc:	fcf42c23          	sw	a5,-40(s0)
		XAxiEthernet_WriteReg(InstancePtr->Config.BaseAddress,
c0012700:	fcc42783          	lw	a5,-52(s0)
c0012704:	0047a783          	lw	a5,4(a5) # 80000004 <_end+0xb7f7b784>
c0012708:	70878793          	addi	a5,a5,1800
c001270c:	fd842583          	lw	a1,-40(s0)
c0012710:	00078513          	mv	a0,a5
c0012714:	955fe0ef          	jal	ra,c0011068 <Xil_Out32>
							XAE_FMI_OFFSET, Reg);
	}

	/* Disable broadcast address filtering */
	if (DepOptions & XAE_BROADCAST_OPTION) {
c0012718:	fe442783          	lw	a5,-28(s0)
c001271c:	2007f793          	andi	a5,a5,512
c0012720:	02078c63          	beqz	a5,c0012758 <XAxiEthernet_ClearOptions+0x3a4>
		xaxi_debug_printf(
		"XAxiEthernet_ClearOptions: disabling broadcast mode\r\n");
		Reg = XAxiEthernet_ReadReg(InstancePtr->Config.BaseAddress,
c0012724:	fcc42783          	lw	a5,-52(s0)
c0012728:	0047a783          	lw	a5,4(a5)
c001272c:	00078513          	mv	a0,a5
c0012730:	911fe0ef          	jal	ra,c0011040 <Xil_In32>
c0012734:	fca42c23          	sw	a0,-40(s0)
							XAE_RAF_OFFSET);
		Reg |= XAE_RAF_BCSTREJ_MASK;
c0012738:	fd842783          	lw	a5,-40(s0)
c001273c:	0047e793          	ori	a5,a5,4
c0012740:	fcf42c23          	sw	a5,-40(s0)
		XAxiEthernet_WriteReg(InstancePtr->Config.BaseAddress,
c0012744:	fcc42783          	lw	a5,-52(s0)
c0012748:	0047a783          	lw	a5,4(a5)
c001274c:	fd842583          	lw	a1,-40(s0)
c0012750:	00078513          	mv	a0,a5
c0012754:	915fe0ef          	jal	ra,c0011068 <Xil_Out32>
							XAE_RAF_OFFSET, Reg);
	}

	/* Disable multicast address filtering */
	if ((DepOptions & XAE_MULTICAST_OPTION) &&
c0012758:	fe442783          	lw	a5,-28(s0)
c001275c:	4007f793          	andi	a5,a5,1024
c0012760:	04078663          	beqz	a5,c00127ac <XAxiEthernet_ClearOptions+0x3f8>
		(DepOptions & XAE_EXT_MULTICAST_OPTION)) {
c0012764:	fe442703          	lw	a4,-28(s0)
c0012768:	000017b7          	lui	a5,0x1
c001276c:	80078793          	addi	a5,a5,-2048 # 800 <_STACK_SIZE-0x800>
c0012770:	00f777b3          	and	a5,a4,a5
	if ((DepOptions & XAE_MULTICAST_OPTION) &&
c0012774:	02078c63          	beqz	a5,c00127ac <XAxiEthernet_ClearOptions+0x3f8>
		xaxi_debug_printf(
		"XAxiEthernet_ClearOptions:disabling multicast mode\r\n");
		Reg = XAxiEthernet_ReadReg(InstancePtr->Config.BaseAddress,
c0012778:	fcc42783          	lw	a5,-52(s0)
c001277c:	0047a783          	lw	a5,4(a5)
c0012780:	00078513          	mv	a0,a5
c0012784:	8bdfe0ef          	jal	ra,c0011040 <Xil_In32>
c0012788:	fca42c23          	sw	a0,-40(s0)
							XAE_RAF_OFFSET);
		Reg |= XAE_RAF_MCSTREJ_MASK;
c001278c:	fd842783          	lw	a5,-40(s0)
c0012790:	0027e793          	ori	a5,a5,2
c0012794:	fcf42c23          	sw	a5,-40(s0)
		XAxiEthernet_WriteReg(InstancePtr->Config.BaseAddress,
c0012798:	fcc42783          	lw	a5,-52(s0)
c001279c:	0047a783          	lw	a5,4(a5)
c00127a0:	fd842583          	lw	a1,-40(s0)
c00127a4:	00078513          	mv	a0,a5
c00127a8:	8c1fe0ef          	jal	ra,c0011068 <Xil_Out32>
							XAE_RAF_OFFSET, Reg);
	}

	/* Disable extended multicast option */
	if (DepOptions & XAE_EXT_MULTICAST_OPTION) {
c00127ac:	fe442703          	lw	a4,-28(s0)
c00127b0:	000017b7          	lui	a5,0x1
c00127b4:	80078793          	addi	a5,a5,-2048 # 800 <_STACK_SIZE-0x800>
c00127b8:	00f777b3          	and	a5,a4,a5
c00127bc:	02078c63          	beqz	a5,c00127f4 <XAxiEthernet_ClearOptions+0x440>
		xaxi_debug_printf(
		"XAxiEthernet_ClearOptions:disabling extended multicast mode\r\n");
		XAxiEthernet_WriteReg((InstancePtr)->Config.BaseAddress,
c00127c0:	fcc42783          	lw	a5,-52(s0)
c00127c4:	0047a483          	lw	s1,4(a5)
c00127c8:	fcc42783          	lw	a5,-52(s0)
c00127cc:	0047a783          	lw	a5,4(a5)
c00127d0:	00078513          	mv	a0,a5
c00127d4:	86dfe0ef          	jal	ra,c0011040 <Xil_In32>
c00127d8:	00050713          	mv	a4,a0
c00127dc:	fffff7b7          	lui	a5,0xfffff
c00127e0:	fff78793          	addi	a5,a5,-1 # ffffefff <_end+0x37f7a77f>
c00127e4:	00f777b3          	and	a5,a4,a5
c00127e8:	00078593          	mv	a1,a5
c00127ec:	00048513          	mv	a0,s1
c00127f0:	879fe0ef          	jal	ra,c0011068 <Xil_Out32>
			XAxiEthernet_ReadReg((InstancePtr)->Config.BaseAddress,
			XAE_RAF_OFFSET) & ~XAE_RAF_EMULTIFLTRENBL_MASK);
	}

	/* Disable extended transmit VLAN tag option */
	if (DepOptions & XAE_EXT_TXVLAN_TAG_OPTION) {
c00127f4:	fe442703          	lw	a4,-28(s0)
c00127f8:	000047b7          	lui	a5,0x4
c00127fc:	00f777b3          	and	a5,a4,a5
c0012800:	02078863          	beqz	a5,c0012830 <XAxiEthernet_ClearOptions+0x47c>
		xaxi_debug_printf(
		"XAxiEthernet_ClearOptions:disabling extended TX VLAN tag mode\r\n");
		XAxiEthernet_WriteReg((InstancePtr)->Config.BaseAddress,
c0012804:	fcc42783          	lw	a5,-52(s0)
c0012808:	0047a483          	lw	s1,4(a5) # 4004 <_STACK_SIZE+0x3004>
c001280c:	fcc42783          	lw	a5,-52(s0)
c0012810:	0047a783          	lw	a5,4(a5)
c0012814:	00078513          	mv	a0,a5
c0012818:	829fe0ef          	jal	ra,c0011040 <Xil_In32>
c001281c:	00050793          	mv	a5,a0
c0012820:	fe77f793          	andi	a5,a5,-25
c0012824:	00078593          	mv	a1,a5
c0012828:	00048513          	mv	a0,s1
c001282c:	83dfe0ef          	jal	ra,c0011068 <Xil_Out32>
			XAxiEthernet_ReadReg((InstancePtr)->Config.BaseAddress,
			XAE_RAF_OFFSET) & ~XAE_RAF_TXVTAGMODE_MASK);
	}

	/* Disable extended receive VLAN tag option */
	if (DepOptions & XAE_EXT_RXVLAN_TAG_OPTION) {
c0012830:	fe442703          	lw	a4,-28(s0)
c0012834:	000087b7          	lui	a5,0x8
c0012838:	00f777b3          	and	a5,a4,a5
c001283c:	02078863          	beqz	a5,c001286c <XAxiEthernet_ClearOptions+0x4b8>
		xaxi_debug_printf(
		"XAxiEthernet_ClearOptions:disabling extended RX VLAN tag mode\r\n");
		XAxiEthernet_WriteReg((InstancePtr)->Config.BaseAddress,
c0012840:	fcc42783          	lw	a5,-52(s0)
c0012844:	0047a483          	lw	s1,4(a5) # 8004 <_STACK_SIZE+0x7004>
c0012848:	fcc42783          	lw	a5,-52(s0)
c001284c:	0047a783          	lw	a5,4(a5)
c0012850:	00078513          	mv	a0,a5
c0012854:	fecfe0ef          	jal	ra,c0011040 <Xil_In32>
c0012858:	00050793          	mv	a5,a0
c001285c:	f9f7f793          	andi	a5,a5,-97
c0012860:	00078593          	mv	a1,a5
c0012864:	00048513          	mv	a0,s1
c0012868:	801fe0ef          	jal	ra,c0011068 <Xil_Out32>
			XAxiEthernet_ReadReg((InstancePtr)->Config.BaseAddress,
			XAE_RAF_OFFSET) & ~XAE_RAF_RXVTAGMODE_MASK);
	}

	/* Disable extended transmit VLAN strip option */
	if (DepOptions & XAE_EXT_TXVLAN_STRP_OPTION) {
c001286c:	fe442703          	lw	a4,-28(s0)
c0012870:	000107b7          	lui	a5,0x10
c0012874:	00f777b3          	and	a5,a4,a5
c0012878:	02078863          	beqz	a5,c00128a8 <XAxiEthernet_ClearOptions+0x4f4>
		xaxi_debug_printf(
		"XAxiEthernet_ClearOptions:disabling extended TX VLAN strip mode\r\n");
		XAxiEthernet_WriteReg((InstancePtr)->Config.BaseAddress,
c001287c:	fcc42783          	lw	a5,-52(s0)
c0012880:	0047a483          	lw	s1,4(a5) # 10004 <_STACK_SIZE+0xf004>
c0012884:	fcc42783          	lw	a5,-52(s0)
c0012888:	0047a783          	lw	a5,4(a5)
c001288c:	00078513          	mv	a0,a5
c0012890:	fb0fe0ef          	jal	ra,c0011040 <Xil_In32>
c0012894:	00050793          	mv	a5,a0
c0012898:	e7f7f793          	andi	a5,a5,-385
c001289c:	00078593          	mv	a1,a5
c00128a0:	00048513          	mv	a0,s1
c00128a4:	fc4fe0ef          	jal	ra,c0011068 <Xil_Out32>
			XAxiEthernet_ReadReg((InstancePtr)->Config.BaseAddress,
			XAE_RAF_OFFSET) & ~XAE_RAF_TXVSTRPMODE_MASK);
	}

	/* Disable extended receive VLAN strip option */
	if (DepOptions & XAE_EXT_RXVLAN_STRP_OPTION) {
c00128a8:	fe442703          	lw	a4,-28(s0)
c00128ac:	000207b7          	lui	a5,0x20
c00128b0:	00f777b3          	and	a5,a4,a5
c00128b4:	02078863          	beqz	a5,c00128e4 <XAxiEthernet_ClearOptions+0x530>
		xaxi_debug_printf(
		"XAxiEthernet_ClearOptions:disabling extended RX VLAN strip mode\r\n");
		XAxiEthernet_WriteReg((InstancePtr)->Config.BaseAddress,
c00128b8:	fcc42783          	lw	a5,-52(s0)
c00128bc:	0047a483          	lw	s1,4(a5) # 20004 <_STACK_SIZE+0x1f004>
c00128c0:	fcc42783          	lw	a5,-52(s0)
c00128c4:	0047a783          	lw	a5,4(a5)
c00128c8:	00078513          	mv	a0,a5
c00128cc:	f74fe0ef          	jal	ra,c0011040 <Xil_In32>
c00128d0:	00050793          	mv	a5,a0
c00128d4:	9ff7f793          	andi	a5,a5,-1537
c00128d8:	00078593          	mv	a1,a5
c00128dc:	00048513          	mv	a0,s1
c00128e0:	f88fe0ef          	jal	ra,c0011068 <Xil_Out32>
	 * driver. No register modifications are needed at this time.
	 * Reflecting the option in InstancePtr->Options is good enough for
	 * now.
	 */
	xaxi_debug_printf("ClearOptions: returning SUCCESS\r\n");
	return (XST_SUCCESS);
c00128e4:	00000793          	li	a5,0
}
c00128e8:	00078513          	mv	a0,a5
c00128ec:	03c12083          	lw	ra,60(sp)
c00128f0:	03812403          	lw	s0,56(sp)
c00128f4:	03412483          	lw	s1,52(sp)
c00128f8:	04010113          	addi	sp,sp,64
c00128fc:	00008067          	ret

c0012900 <XAxiEthernet_GetOptions>:
* @note
* See xaxiethernet.h for a description of the available options.
*
******************************************************************************/
u32 XAxiEthernet_GetOptions(XAxiEthernet *InstancePtr)
{
c0012900:	fe010113          	addi	sp,sp,-32
c0012904:	00112e23          	sw	ra,28(sp)
c0012908:	00812c23          	sw	s0,24(sp)
c001290c:	02010413          	addi	s0,sp,32
c0012910:	fea42623          	sw	a0,-20(s0)
	Xil_AssertNonvoid(InstancePtr != NULL);
c0012914:	fec42783          	lw	a5,-20(s0)
c0012918:	02078463          	beqz	a5,c0012940 <XAxiEthernet_GetOptions+0x40>
c001291c:	07ff0797          	auipc	a5,0x7ff0
c0012920:	ff878793          	addi	a5,a5,-8 # c8002914 <Xil_AssertStatus>
c0012924:	0007a023          	sw	zero,0(a5)
	Xil_AssertNonvoid(InstancePtr->IsReady == XIL_COMPONENT_IS_READY);
c0012928:	fec42783          	lw	a5,-20(s0)
c001292c:	0507a703          	lw	a4,80(a5)
c0012930:	111117b7          	lui	a5,0x11111
c0012934:	11178793          	addi	a5,a5,273 # 11111111 <_DMEM_LENGTH+0x10911111>
c0012938:	04f71463          	bne	a4,a5,c0012980 <XAxiEthernet_GetOptions+0x80>
c001293c:	02c0006f          	j	c0012968 <XAxiEthernet_GetOptions+0x68>
	Xil_AssertNonvoid(InstancePtr != NULL);
c0012940:	56400593          	li	a1,1380
c0012944:	07fee517          	auipc	a0,0x7fee
c0012948:	47850513          	addi	a0,a0,1144 # c8000dbc <__rodata_start+0xdbc>
c001294c:	1700b0ef          	jal	ra,c001dabc <Xil_Assert>
c0012950:	07ff0797          	auipc	a5,0x7ff0
c0012954:	fc478793          	addi	a5,a5,-60 # c8002914 <Xil_AssertStatus>
c0012958:	00100713          	li	a4,1
c001295c:	00e7a023          	sw	a4,0(a5)
c0012960:	00000793          	li	a5,0
c0012964:	0400006f          	j	c00129a4 <XAxiEthernet_GetOptions+0xa4>
	Xil_AssertNonvoid(InstancePtr->IsReady == XIL_COMPONENT_IS_READY);
c0012968:	07ff0797          	auipc	a5,0x7ff0
c001296c:	fac78793          	addi	a5,a5,-84 # c8002914 <Xil_AssertStatus>
c0012970:	0007a023          	sw	zero,0(a5)

	return (InstancePtr->Options);
c0012974:	fec42783          	lw	a5,-20(s0)
c0012978:	0547a783          	lw	a5,84(a5)
c001297c:	0280006f          	j	c00129a4 <XAxiEthernet_GetOptions+0xa4>
	Xil_AssertNonvoid(InstancePtr->IsReady == XIL_COMPONENT_IS_READY);
c0012980:	56500593          	li	a1,1381
c0012984:	07fee517          	auipc	a0,0x7fee
c0012988:	43850513          	addi	a0,a0,1080 # c8000dbc <__rodata_start+0xdbc>
c001298c:	1300b0ef          	jal	ra,c001dabc <Xil_Assert>
c0012990:	07ff0797          	auipc	a5,0x7ff0
c0012994:	f8478793          	addi	a5,a5,-124 # c8002914 <Xil_AssertStatus>
c0012998:	00100713          	li	a4,1
c001299c:	00e7a023          	sw	a4,0(a5)
c00129a0:	00000793          	li	a5,0
}
c00129a4:	00078513          	mv	a0,a5
c00129a8:	01c12083          	lw	ra,28(sp)
c00129ac:	01812403          	lw	s0,24(sp)
c00129b0:	02010113          	addi	sp,sp,32
c00129b4:	00008067          	ret

c00129b8 <XAxiEthernet_GetOperatingSpeed>:
 *
 * @note	None.
 *
 ******************************************************************************/
u16 XAxiEthernet_GetOperatingSpeed(XAxiEthernet *InstancePtr)
{
c00129b8:	fe010113          	addi	sp,sp,-32
c00129bc:	00112e23          	sw	ra,28(sp)
c00129c0:	00812c23          	sw	s0,24(sp)
c00129c4:	02010413          	addi	s0,sp,32
c00129c8:	fea42623          	sw	a0,-20(s0)
	Xil_AssertNonvoid(InstancePtr != NULL);
c00129cc:	fec42783          	lw	a5,-20(s0)
c00129d0:	02078463          	beqz	a5,c00129f8 <XAxiEthernet_GetOperatingSpeed+0x40>
c00129d4:	07ff0797          	auipc	a5,0x7ff0
c00129d8:	f4078793          	addi	a5,a5,-192 # c8002914 <Xil_AssertStatus>
c00129dc:	0007a023          	sw	zero,0(a5)
	Xil_AssertNonvoid(InstancePtr->IsReady == XIL_COMPONENT_IS_READY);
c00129e0:	fec42783          	lw	a5,-20(s0)
c00129e4:	0507a703          	lw	a4,80(a5)
c00129e8:	111117b7          	lui	a5,0x11111
c00129ec:	11178793          	addi	a5,a5,273 # 11111111 <_DMEM_LENGTH+0x10911111>
c00129f0:	06f71463          	bne	a4,a5,c0012a58 <XAxiEthernet_GetOperatingSpeed+0xa0>
c00129f4:	02c0006f          	j	c0012a20 <XAxiEthernet_GetOperatingSpeed+0x68>
	Xil_AssertNonvoid(InstancePtr != NULL);
c00129f8:	57d00593          	li	a1,1405
c00129fc:	07fee517          	auipc	a0,0x7fee
c0012a00:	3c050513          	addi	a0,a0,960 # c8000dbc <__rodata_start+0xdbc>
c0012a04:	0b80b0ef          	jal	ra,c001dabc <Xil_Assert>
c0012a08:	07ff0797          	auipc	a5,0x7ff0
c0012a0c:	f0c78793          	addi	a5,a5,-244 # c8002914 <Xil_AssertStatus>
c0012a10:	00100713          	li	a4,1
c0012a14:	00e7a023          	sw	a4,0(a5)
c0012a18:	00000793          	li	a5,0
c0012a1c:	0980006f          	j	c0012ab4 <XAxiEthernet_GetOperatingSpeed+0xfc>
	Xil_AssertNonvoid(InstancePtr->IsReady == XIL_COMPONENT_IS_READY);
c0012a20:	07ff0797          	auipc	a5,0x7ff0
c0012a24:	ef478793          	addi	a5,a5,-268 # c8002914 <Xil_AssertStatus>
c0012a28:	0007a023          	sw	zero,0(a5)

	xaxi_debug_printf("XAxiEthernet_GetOperatingSpeed\r\n");
	switch (XAxiEthernet_ReadReg(InstancePtr->Config.BaseAddress,
c0012a2c:	fec42783          	lw	a5,-20(s0)
c0012a30:	0047a783          	lw	a5,4(a5)
c0012a34:	41078793          	addi	a5,a5,1040
c0012a38:	00078513          	mv	a0,a5
c0012a3c:	e04fe0ef          	jal	ra,c0011040 <Xil_In32>
c0012a40:	00050713          	mv	a4,a0
			XAE_EMMC_OFFSET) & XAE_EMMC_LINKSPEED_MASK) {
c0012a44:	c00007b7          	lui	a5,0xc0000
c0012a48:	00f777b3          	and	a5,a4,a5
	switch (XAxiEthernet_ReadReg(InstancePtr->Config.BaseAddress,
c0012a4c:	80000737          	lui	a4,0x80000
c0012a50:	04e78463          	beq	a5,a4,c0012a98 <XAxiEthernet_GetOperatingSpeed+0xe0>
c0012a54:	02c0006f          	j	c0012a80 <XAxiEthernet_GetOperatingSpeed+0xc8>
	Xil_AssertNonvoid(InstancePtr->IsReady == XIL_COMPONENT_IS_READY);
c0012a58:	57e00593          	li	a1,1406
c0012a5c:	07fee517          	auipc	a0,0x7fee
c0012a60:	36050513          	addi	a0,a0,864 # c8000dbc <__rodata_start+0xdbc>
c0012a64:	0580b0ef          	jal	ra,c001dabc <Xil_Assert>
c0012a68:	07ff0797          	auipc	a5,0x7ff0
c0012a6c:	eac78793          	addi	a5,a5,-340 # c8002914 <Xil_AssertStatus>
c0012a70:	00100713          	li	a4,1
c0012a74:	00e7a023          	sw	a4,0(a5)
c0012a78:	00000793          	li	a5,0
c0012a7c:	0380006f          	j	c0012ab4 <XAxiEthernet_GetOperatingSpeed+0xfc>
	switch (XAxiEthernet_ReadReg(InstancePtr->Config.BaseAddress,
c0012a80:	80000737          	lui	a4,0x80000
c0012a84:	02f76663          	bltu	a4,a5,c0012ab0 <XAxiEthernet_GetOperatingSpeed+0xf8>
c0012a88:	02078063          	beqz	a5,c0012aa8 <XAxiEthernet_GetOperatingSpeed+0xf0>
c0012a8c:	40000737          	lui	a4,0x40000
c0012a90:	00e78863          	beq	a5,a4,c0012aa0 <XAxiEthernet_GetOperatingSpeed+0xe8>
c0012a94:	01c0006f          	j	c0012ab0 <XAxiEthernet_GetOperatingSpeed+0xf8>

	case XAE_EMMC_LINKSPD_1000:
		xaxi_debug_printf(
			"XAxiEthernet_GetOperatingSpeed: returning 1000\r\n");
		return XAE_SPEED_1000_MBPS;
c0012a98:	3e800793          	li	a5,1000
c0012a9c:	0180006f          	j	c0012ab4 <XAxiEthernet_GetOperatingSpeed+0xfc>

	case XAE_EMMC_LINKSPD_100:
		xaxi_debug_printf(
			"XAxiEthernet_GetOperatingSpeed: returning 100\r\n");
		return XAE_SPEED_100_MBPS;
c0012aa0:	06400793          	li	a5,100
c0012aa4:	0100006f          	j	c0012ab4 <XAxiEthernet_GetOperatingSpeed+0xfc>

	case XAE_EMMC_LINKSPD_10:
		xaxi_debug_printf(
			"XAxiEthernet_GetOperatingSpeed: returning 10\r\n");
		return (XAE_SPEED_10_MBPS);
c0012aa8:	00a00793          	li	a5,10
c0012aac:	0080006f          	j	c0012ab4 <XAxiEthernet_GetOperatingSpeed+0xfc>

	default:
		return (0);
c0012ab0:	00000793          	li	a5,0
	}
}
c0012ab4:	00078513          	mv	a0,a5
c0012ab8:	01c12083          	lw	ra,28(sp)
c0012abc:	01812403          	lw	s0,24(sp)
c0012ac0:	02010113          	addi	sp,sp,32
c0012ac4:	00008067          	ret

c0012ac8 <XAxiEthernet_SetOperatingSpeed>:
 * @note	None.
 *
 *
 ******************************************************************************/
int XAxiEthernet_SetOperatingSpeed(XAxiEthernet *InstancePtr, u16 Speed)
{
c0012ac8:	fd010113          	addi	sp,sp,-48
c0012acc:	02112623          	sw	ra,44(sp)
c0012ad0:	02812423          	sw	s0,40(sp)
c0012ad4:	03010413          	addi	s0,sp,48
c0012ad8:	fca42e23          	sw	a0,-36(s0)
c0012adc:	00058793          	mv	a5,a1
c0012ae0:	fcf41d23          	sh	a5,-38(s0)
	u32 EmmcReg;
	u8  TemacType;
	u8  PhyType;
	u8  SetSpeed = TRUE;
c0012ae4:	00100793          	li	a5,1
c0012ae8:	fef405a3          	sb	a5,-21(s0)

	Xil_AssertNonvoid(InstancePtr != NULL);
c0012aec:	fdc42783          	lw	a5,-36(s0)
c0012af0:	02078463          	beqz	a5,c0012b18 <XAxiEthernet_SetOperatingSpeed+0x50>
c0012af4:	07ff0797          	auipc	a5,0x7ff0
c0012af8:	e2078793          	addi	a5,a5,-480 # c8002914 <Xil_AssertStatus>
c0012afc:	0007a023          	sw	zero,0(a5)
	Xil_AssertNonvoid(InstancePtr->IsReady == XIL_COMPONENT_IS_READY);
c0012b00:	fdc42783          	lw	a5,-36(s0)
c0012b04:	0507a703          	lw	a4,80(a5)
c0012b08:	111117b7          	lui	a5,0x11111
c0012b0c:	11178793          	addi	a5,a5,273 # 11111111 <_DMEM_LENGTH+0x10911111>
c0012b10:	04f71663          	bne	a4,a5,c0012b5c <XAxiEthernet_SetOperatingSpeed+0x94>
c0012b14:	02c0006f          	j	c0012b40 <XAxiEthernet_SetOperatingSpeed+0x78>
	Xil_AssertNonvoid(InstancePtr != NULL);
c0012b18:	5b300593          	li	a1,1459
c0012b1c:	07fee517          	auipc	a0,0x7fee
c0012b20:	2a050513          	addi	a0,a0,672 # c8000dbc <__rodata_start+0xdbc>
c0012b24:	7990a0ef          	jal	ra,c001dabc <Xil_Assert>
c0012b28:	07ff0797          	auipc	a5,0x7ff0
c0012b2c:	dec78793          	addi	a5,a5,-532 # c8002914 <Xil_AssertStatus>
c0012b30:	00100713          	li	a4,1
c0012b34:	00e7a023          	sw	a4,0(a5)
c0012b38:	00000793          	li	a5,0
c0012b3c:	1e00006f          	j	c0012d1c <XAxiEthernet_SetOperatingSpeed+0x254>
	Xil_AssertNonvoid(InstancePtr->IsReady == XIL_COMPONENT_IS_READY);
c0012b40:	07ff0797          	auipc	a5,0x7ff0
c0012b44:	dd478793          	addi	a5,a5,-556 # c8002914 <Xil_AssertStatus>
c0012b48:	0007a023          	sw	zero,0(a5)
	Xil_AssertNonvoid((Speed == XAE_SPEED_10_MBPS) ||
c0012b4c:	fda45703          	lhu	a4,-38(s0)
c0012b50:	00a00793          	li	a5,10
c0012b54:	04f70c63          	beq	a4,a5,c0012bac <XAxiEthernet_SetOperatingSpeed+0xe4>
c0012b58:	02c0006f          	j	c0012b84 <XAxiEthernet_SetOperatingSpeed+0xbc>
	Xil_AssertNonvoid(InstancePtr->IsReady == XIL_COMPONENT_IS_READY);
c0012b5c:	5b400593          	li	a1,1460
c0012b60:	07fee517          	auipc	a0,0x7fee
c0012b64:	25c50513          	addi	a0,a0,604 # c8000dbc <__rodata_start+0xdbc>
c0012b68:	7550a0ef          	jal	ra,c001dabc <Xil_Assert>
c0012b6c:	07ff0797          	auipc	a5,0x7ff0
c0012b70:	da878793          	addi	a5,a5,-600 # c8002914 <Xil_AssertStatus>
c0012b74:	00100713          	li	a4,1
c0012b78:	00e7a023          	sw	a4,0(a5)
c0012b7c:	00000793          	li	a5,0
c0012b80:	19c0006f          	j	c0012d1c <XAxiEthernet_SetOperatingSpeed+0x254>
	Xil_AssertNonvoid((Speed == XAE_SPEED_10_MBPS) ||
c0012b84:	fda45703          	lhu	a4,-38(s0)
c0012b88:	06400793          	li	a5,100
c0012b8c:	02f70063          	beq	a4,a5,c0012bac <XAxiEthernet_SetOperatingSpeed+0xe4>
c0012b90:	fda45703          	lhu	a4,-38(s0)
c0012b94:	3e800793          	li	a5,1000
c0012b98:	00f70a63          	beq	a4,a5,c0012bac <XAxiEthernet_SetOperatingSpeed+0xe4>
c0012b9c:	fda45703          	lhu	a4,-38(s0)
c0012ba0:	000017b7          	lui	a5,0x1
c0012ba4:	9c478793          	addi	a5,a5,-1596 # 9c4 <_STACK_SIZE-0x63c>
c0012ba8:	02f71c63          	bne	a4,a5,c0012be0 <XAxiEthernet_SetOperatingSpeed+0x118>
c0012bac:	07ff0797          	auipc	a5,0x7ff0
c0012bb0:	d6878793          	addi	a5,a5,-664 # c8002914 <Xil_AssertStatus>
c0012bb4:	0007a023          	sw	zero,0(a5)

	xaxi_debug_printf("XAxiEthernet_SetOperatingSpeed\r\n");
	xaxi_debug_printf(	"XAxiEthernet_SetOperatingSpeed: setting speed to:%d (0x%0x)\r\n",
		Speed, Speed);

	TemacType = XAxiEthernet_GetTemacType(InstancePtr);
c0012bb8:	fdc42783          	lw	a5,-36(s0)
c0012bbc:	0087c783          	lbu	a5,8(a5)
c0012bc0:	fef40523          	sb	a5,-22(s0)
	PhyType = XAxiEthernet_GetPhysicalInterface(InstancePtr);
c0012bc4:	fdc42783          	lw	a5,-36(s0)
c0012bc8:	00b7c783          	lbu	a5,11(a5)
c0012bcc:	fef404a3          	sb	a5,-23(s0)
	 * more information on it.
	 * For PHY type 1000Base-x, 10 and 100 Mbps are not supported.
	 * For soft/hard Axi Ethernet core, 1000 Mbps is supported in all PHY
	 * types except MII.
	 */
	if((Speed == XAE_SPEED_10_MBPS) || (Speed == XAE_SPEED_100_MBPS)) {
c0012bd0:	fda45703          	lhu	a4,-38(s0)
c0012bd4:	00a00793          	li	a5,10
c0012bd8:	02f70e63          	beq	a4,a5,c0012c14 <XAxiEthernet_SetOperatingSpeed+0x14c>
c0012bdc:	02c0006f          	j	c0012c08 <XAxiEthernet_SetOperatingSpeed+0x140>
	Xil_AssertNonvoid((Speed == XAE_SPEED_10_MBPS) ||
c0012be0:	5b500593          	li	a1,1461
c0012be4:	07fee517          	auipc	a0,0x7fee
c0012be8:	1d850513          	addi	a0,a0,472 # c8000dbc <__rodata_start+0xdbc>
c0012bec:	6d10a0ef          	jal	ra,c001dabc <Xil_Assert>
c0012bf0:	07ff0797          	auipc	a5,0x7ff0
c0012bf4:	d2478793          	addi	a5,a5,-732 # c8002914 <Xil_AssertStatus>
c0012bf8:	00100713          	li	a4,1
c0012bfc:	00e7a023          	sw	a4,0(a5)
c0012c00:	00000793          	li	a5,0
c0012c04:	1180006f          	j	c0012d1c <XAxiEthernet_SetOperatingSpeed+0x254>
	if((Speed == XAE_SPEED_10_MBPS) || (Speed == XAE_SPEED_100_MBPS)) {
c0012c08:	fda45703          	lhu	a4,-38(s0)
c0012c0c:	06400793          	li	a5,100
c0012c10:	00f71c63          	bne	a4,a5,c0012c28 <XAxiEthernet_SetOperatingSpeed+0x160>
		if(PhyType == XAE_PHY_TYPE_1000BASE_X) {
c0012c14:	fe944703          	lbu	a4,-23(s0)
c0012c18:	00500793          	li	a5,5
c0012c1c:	02f71263          	bne	a4,a5,c0012c40 <XAxiEthernet_SetOperatingSpeed+0x178>
			SetSpeed = FALSE;
c0012c20:	fe0405a3          	sb	zero,-21(s0)
		if(PhyType == XAE_PHY_TYPE_1000BASE_X) {
c0012c24:	01c0006f          	j	c0012c40 <XAxiEthernet_SetOperatingSpeed+0x178>
		}
	}
	else {
		if((Speed == XAE_SPEED_1000_MBPS) &&
c0012c28:	fda45703          	lhu	a4,-38(s0)
c0012c2c:	3e800793          	li	a5,1000
c0012c30:	00f71863          	bne	a4,a5,c0012c40 <XAxiEthernet_SetOperatingSpeed+0x178>
c0012c34:	fe944783          	lbu	a5,-23(s0)
c0012c38:	00079463          	bnez	a5,c0012c40 <XAxiEthernet_SetOperatingSpeed+0x178>
					(PhyType == XAE_PHY_TYPE_MII)) {
			SetSpeed = FALSE;
c0012c3c:	fe0405a3          	sb	zero,-21(s0)
		}
	}

	if(SetSpeed == TRUE) {
c0012c40:	feb44703          	lbu	a4,-21(s0)
c0012c44:	00100793          	li	a5,1
c0012c48:	0cf71863          	bne	a4,a5,c0012d18 <XAxiEthernet_SetOperatingSpeed+0x250>
		/*
		 * Get the current contents of the EMAC config register and
		 * zero out speed bits
		 */
		EmmcReg = XAxiEthernet_ReadReg(InstancePtr->Config.BaseAddress,
c0012c4c:	fdc42783          	lw	a5,-36(s0)
c0012c50:	0047a783          	lw	a5,4(a5)
c0012c54:	41078793          	addi	a5,a5,1040
c0012c58:	00078513          	mv	a0,a5
c0012c5c:	be4fe0ef          	jal	ra,c0011040 <Xil_In32>
c0012c60:	00050713          	mv	a4,a0
c0012c64:	400007b7          	lui	a5,0x40000
c0012c68:	fff78793          	addi	a5,a5,-1 # 3fffffff <_DMEM_LENGTH+0x3f7fffff>
c0012c6c:	00f777b3          	and	a5,a4,a5
c0012c70:	fef42623          	sw	a5,-20(s0)
				XAE_EMMC_OFFSET) & ~XAE_EMMC_LINKSPEED_MASK;

		xaxi_debug_printf(
		"XAxiEthernet_SetOperatingSpeed: current speed: 0x%0lx\r\n",
								EmmcReg);
		switch (Speed) {
c0012c74:	fda45783          	lhu	a5,-38(s0)
c0012c78:	00001737          	lui	a4,0x1
c0012c7c:	9c470713          	addi	a4,a4,-1596 # 9c4 <_STACK_SIZE-0x63c>
c0012c80:	04e78c63          	beq	a5,a4,c0012cd8 <XAxiEthernet_SetOperatingSpeed+0x210>
c0012c84:	00001737          	lui	a4,0x1
c0012c88:	9c470713          	addi	a4,a4,-1596 # 9c4 <_STACK_SIZE-0x63c>
c0012c8c:	06f74063          	blt	a4,a5,c0012cec <XAxiEthernet_SetOperatingSpeed+0x224>
c0012c90:	3e800713          	li	a4,1000
c0012c94:	02e78863          	beq	a5,a4,c0012cc4 <XAxiEthernet_SetOperatingSpeed+0x1fc>
c0012c98:	3e800713          	li	a4,1000
c0012c9c:	04f74863          	blt	a4,a5,c0012cec <XAxiEthernet_SetOperatingSpeed+0x224>
c0012ca0:	00a00713          	li	a4,10
c0012ca4:	04e78863          	beq	a5,a4,c0012cf4 <XAxiEthernet_SetOperatingSpeed+0x22c>
c0012ca8:	06400713          	li	a4,100
c0012cac:	04e79063          	bne	a5,a4,c0012cec <XAxiEthernet_SetOperatingSpeed+0x224>
		case XAE_SPEED_10_MBPS:
			break;

		case XAE_SPEED_100_MBPS:
			EmmcReg |= XAE_EMMC_LINKSPD_100;
c0012cb0:	fec42703          	lw	a4,-20(s0)
c0012cb4:	400007b7          	lui	a5,0x40000
c0012cb8:	00f767b3          	or	a5,a4,a5
c0012cbc:	fef42623          	sw	a5,-20(s0)
			break;
c0012cc0:	0380006f          	j	c0012cf8 <XAxiEthernet_SetOperatingSpeed+0x230>

		case XAE_SPEED_1000_MBPS:
			EmmcReg |= XAE_EMMC_LINKSPD_1000;
c0012cc4:	fec42703          	lw	a4,-20(s0)
c0012cc8:	800007b7          	lui	a5,0x80000
c0012ccc:	00f767b3          	or	a5,a4,a5
c0012cd0:	fef42623          	sw	a5,-20(s0)
			break;
c0012cd4:	0240006f          	j	c0012cf8 <XAxiEthernet_SetOperatingSpeed+0x230>

		case XAE_SPEED_2500_MBPS:
			EmmcReg |= XAE_EMMC_LINKSPD_1000;
c0012cd8:	fec42703          	lw	a4,-20(s0)
c0012cdc:	800007b7          	lui	a5,0x80000
c0012ce0:	00f767b3          	or	a5,a4,a5
c0012ce4:	fef42623          	sw	a5,-20(s0)
			break;
c0012ce8:	0100006f          	j	c0012cf8 <XAxiEthernet_SetOperatingSpeed+0x230>

		default:
			return (XST_FAILURE);
c0012cec:	00100793          	li	a5,1
c0012cf0:	02c0006f          	j	c0012d1c <XAxiEthernet_SetOperatingSpeed+0x254>
			break;
c0012cf4:	00000013          	nop

		xaxi_debug_printf(
			"XAxiEthernet_SetOperatingSpeed: new speed: 0x%0lx\r\n",
								EmmcReg);
		/* Set register and return */
		XAxiEthernet_WriteReg(InstancePtr->Config.BaseAddress,
c0012cf8:	fdc42783          	lw	a5,-36(s0)
c0012cfc:	0047a783          	lw	a5,4(a5) # 80000004 <_end+0xb7f7b784>
c0012d00:	41078793          	addi	a5,a5,1040
c0012d04:	fec42583          	lw	a1,-20(s0)
c0012d08:	00078513          	mv	a0,a5
c0012d0c:	b5cfe0ef          	jal	ra,c0011068 <Xil_Out32>
				XAE_EMMC_OFFSET, EmmcReg);
		xaxi_debug_printf(
				"XAxiEthernet_SetOperatingSpeed: done\r\n");
		return (XST_SUCCESS);
c0012d10:	00000793          	li	a5,0
c0012d14:	0080006f          	j	c0012d1c <XAxiEthernet_SetOperatingSpeed+0x254>
	}
	else {
		xaxi_debug_printf("Speed not compatible with the Axi Ethernet Phy type\r\n");
		return (XST_FAILURE);
c0012d18:	00100793          	li	a5,1
	}

}
c0012d1c:	00078513          	mv	a0,a5
c0012d20:	02c12083          	lw	ra,44(sp)
c0012d24:	02812403          	lw	s0,40(sp)
c0012d28:	03010113          	addi	sp,sp,48
c0012d2c:	00008067          	ret

c0012d30 <XAxiEthernet_SetBadFrmRcvOption>:
*
* @note		None
*
******************************************************************************/
void XAxiEthernet_SetBadFrmRcvOption(XAxiEthernet *InstancePtr)
{
c0012d30:	fd010113          	addi	sp,sp,-48
c0012d34:	02112623          	sw	ra,44(sp)
c0012d38:	02812423          	sw	s0,40(sp)
c0012d3c:	03010413          	addi	s0,sp,48
c0012d40:	fca42e23          	sw	a0,-36(s0)
	u32 Reg;

	Reg = XAxiEthernet_ReadReg(InstancePtr->Config.BaseAddress,
c0012d44:	fdc42783          	lw	a5,-36(s0)
c0012d48:	0047a783          	lw	a5,4(a5)
c0012d4c:	00078513          	mv	a0,a5
c0012d50:	af0fe0ef          	jal	ra,c0011040 <Xil_In32>
c0012d54:	fea42623          	sw	a0,-20(s0)
							XAE_RAF_OFFSET);
	Reg |= XAE_RAF_RXBADFRMEN_MASK;
c0012d58:	fec42703          	lw	a4,-20(s0)
c0012d5c:	000047b7          	lui	a5,0x4
c0012d60:	00f767b3          	or	a5,a4,a5
c0012d64:	fef42623          	sw	a5,-20(s0)
	XAxiEthernet_WriteReg(InstancePtr->Config.BaseAddress,
c0012d68:	fdc42783          	lw	a5,-36(s0)
c0012d6c:	0047a783          	lw	a5,4(a5) # 4004 <_STACK_SIZE+0x3004>
c0012d70:	fec42583          	lw	a1,-20(s0)
c0012d74:	00078513          	mv	a0,a5
c0012d78:	af0fe0ef          	jal	ra,c0011068 <Xil_Out32>
							XAE_RAF_OFFSET, Reg);
}
c0012d7c:	00000013          	nop
c0012d80:	02c12083          	lw	ra,44(sp)
c0012d84:	02812403          	lw	s0,40(sp)
c0012d88:	03010113          	addi	sp,sp,48
c0012d8c:	00008067          	ret

c0012d90 <XAxiEthernet_ClearBadFrmRcvOption>:
*
* @note		None.
*
******************************************************************************/
void XAxiEthernet_ClearBadFrmRcvOption(XAxiEthernet *InstancePtr)
{
c0012d90:	fd010113          	addi	sp,sp,-48
c0012d94:	02112623          	sw	ra,44(sp)
c0012d98:	02812423          	sw	s0,40(sp)
c0012d9c:	03010413          	addi	s0,sp,48
c0012da0:	fca42e23          	sw	a0,-36(s0)
	u32 Reg;

	Reg = XAxiEthernet_ReadReg(InstancePtr->Config.BaseAddress,
c0012da4:	fdc42783          	lw	a5,-36(s0)
c0012da8:	0047a783          	lw	a5,4(a5)
c0012dac:	00078513          	mv	a0,a5
c0012db0:	a90fe0ef          	jal	ra,c0011040 <Xil_In32>
c0012db4:	fea42623          	sw	a0,-20(s0)
							XAE_RAF_OFFSET);
	Reg &= ~XAE_RAF_RXBADFRMEN_MASK;
c0012db8:	fec42703          	lw	a4,-20(s0)
c0012dbc:	ffffc7b7          	lui	a5,0xffffc
c0012dc0:	fff78793          	addi	a5,a5,-1 # ffffbfff <_end+0x37f7777f>
c0012dc4:	00f777b3          	and	a5,a4,a5
c0012dc8:	fef42623          	sw	a5,-20(s0)
	XAxiEthernet_WriteReg(InstancePtr->Config.BaseAddress,
c0012dcc:	fdc42783          	lw	a5,-36(s0)
c0012dd0:	0047a783          	lw	a5,4(a5)
c0012dd4:	fec42583          	lw	a1,-20(s0)
c0012dd8:	00078513          	mv	a0,a5
c0012ddc:	a8cfe0ef          	jal	ra,c0011068 <Xil_Out32>
							XAE_RAF_OFFSET, Reg);
}
c0012de0:	00000013          	nop
c0012de4:	02c12083          	lw	ra,44(sp)
c0012de8:	02812403          	lw	s0,40(sp)
c0012dec:	03010113          	addi	sp,sp,48
c0012df0:	00008067          	ret

c0012df4 <XAxiEthernet_DisableControlFrameLenCheck>:
*
* @note		None.
*
******************************************************************************/
void XAxiEthernet_DisableControlFrameLenCheck(XAxiEthernet *InstancePtr)
{
c0012df4:	fd010113          	addi	sp,sp,-48
c0012df8:	02112623          	sw	ra,44(sp)
c0012dfc:	02812423          	sw	s0,40(sp)
c0012e00:	03010413          	addi	s0,sp,48
c0012e04:	fca42e23          	sw	a0,-36(s0)
	u32 RegRcw1;

	/* Get the current register contents */
	RegRcw1 = XAxiEthernet_ReadReg(InstancePtr->Config.BaseAddress,
c0012e08:	fdc42783          	lw	a5,-36(s0)
c0012e0c:	0047a783          	lw	a5,4(a5)
c0012e10:	40478793          	addi	a5,a5,1028
c0012e14:	00078513          	mv	a0,a5
c0012e18:	a28fe0ef          	jal	ra,c0011040 <Xil_In32>
c0012e1c:	fea42623          	sw	a0,-20(s0)
							XAE_RCW1_OFFSET);
	RegRcw1 |= XAE_RCW1_CL_DIS_MASK;
c0012e20:	fec42703          	lw	a4,-20(s0)
c0012e24:	010007b7          	lui	a5,0x1000
c0012e28:	00f767b3          	or	a5,a4,a5
c0012e2c:	fef42623          	sw	a5,-20(s0)
	XAxiEthernet_WriteReg(InstancePtr->Config.BaseAddress,
c0012e30:	fdc42783          	lw	a5,-36(s0)
c0012e34:	0047a783          	lw	a5,4(a5) # 1000004 <_DMEM_LENGTH+0x800004>
c0012e38:	40478793          	addi	a5,a5,1028
c0012e3c:	fec42583          	lw	a1,-20(s0)
c0012e40:	00078513          	mv	a0,a5
c0012e44:	a24fe0ef          	jal	ra,c0011068 <Xil_Out32>
						XAE_RCW1_OFFSET, RegRcw1);
}
c0012e48:	00000013          	nop
c0012e4c:	02c12083          	lw	ra,44(sp)
c0012e50:	02812403          	lw	s0,40(sp)
c0012e54:	03010113          	addi	sp,sp,48
c0012e58:	00008067          	ret

c0012e5c <XAxiEthernet_EnableControlFrameLenCheck>:
*
* @note		None.
*
******************************************************************************/
void XAxiEthernet_EnableControlFrameLenCheck(XAxiEthernet *InstancePtr)
{
c0012e5c:	fd010113          	addi	sp,sp,-48
c0012e60:	02112623          	sw	ra,44(sp)
c0012e64:	02812423          	sw	s0,40(sp)
c0012e68:	03010413          	addi	s0,sp,48
c0012e6c:	fca42e23          	sw	a0,-36(s0)
	u32 RegRcw1;

	/* Get the current register contents */
	RegRcw1 = XAxiEthernet_ReadReg(InstancePtr->Config.BaseAddress,
c0012e70:	fdc42783          	lw	a5,-36(s0)
c0012e74:	0047a783          	lw	a5,4(a5)
c0012e78:	40478793          	addi	a5,a5,1028
c0012e7c:	00078513          	mv	a0,a5
c0012e80:	9c0fe0ef          	jal	ra,c0011040 <Xil_In32>
c0012e84:	fea42623          	sw	a0,-20(s0)
							XAE_RCW1_OFFSET);
	RegRcw1 &= ~XAE_RCW1_CL_DIS_MASK;
c0012e88:	fec42703          	lw	a4,-20(s0)
c0012e8c:	ff0007b7          	lui	a5,0xff000
c0012e90:	fff78793          	addi	a5,a5,-1 # feffffff <_end+0x36f7b77f>
c0012e94:	00f777b3          	and	a5,a4,a5
c0012e98:	fef42623          	sw	a5,-20(s0)
	XAxiEthernet_WriteReg(InstancePtr->Config.BaseAddress,
c0012e9c:	fdc42783          	lw	a5,-36(s0)
c0012ea0:	0047a783          	lw	a5,4(a5)
c0012ea4:	40478793          	addi	a5,a5,1028
c0012ea8:	fec42583          	lw	a1,-20(s0)
c0012eac:	00078513          	mv	a0,a5
c0012eb0:	9b8fe0ef          	jal	ra,c0011068 <Xil_Out32>
						XAE_RCW1_OFFSET, RegRcw1);
}
c0012eb4:	00000013          	nop
c0012eb8:	02c12083          	lw	ra,44(sp)
c0012ebc:	02812403          	lw	s0,40(sp)
c0012ec0:	03010113          	addi	sp,sp,48
c0012ec4:	00008067          	ret

c0012ec8 <XAxiEthernet_PhySetMdioDivisor>:
*
* @note	None.
*
******************************************************************************/
void XAxiEthernet_PhySetMdioDivisor(XAxiEthernet *InstancePtr, u8 Divisor)
{
c0012ec8:	fe010113          	addi	sp,sp,-32
c0012ecc:	00112e23          	sw	ra,28(sp)
c0012ed0:	00812c23          	sw	s0,24(sp)
c0012ed4:	02010413          	addi	s0,sp,32
c0012ed8:	fea42623          	sw	a0,-20(s0)
c0012edc:	00058793          	mv	a5,a1
c0012ee0:	fef405a3          	sb	a5,-21(s0)
	Xil_AssertVoid(InstancePtr != NULL);
c0012ee4:	fec42783          	lw	a5,-20(s0)
c0012ee8:	02078463          	beqz	a5,c0012f10 <XAxiEthernet_PhySetMdioDivisor+0x48>
c0012eec:	07ff0797          	auipc	a5,0x7ff0
c0012ef0:	a2878793          	addi	a5,a5,-1496 # c8002914 <Xil_AssertStatus>
c0012ef4:	0007a023          	sw	zero,0(a5)
	Xil_AssertVoid(InstancePtr->IsReady == XIL_COMPONENT_IS_READY)
c0012ef8:	fec42783          	lw	a5,-20(s0)
c0012efc:	0507a703          	lw	a4,80(a5)
c0012f00:	111117b7          	lui	a5,0x11111
c0012f04:	11178793          	addi	a5,a5,273 # 11111111 <_DMEM_LENGTH+0x10911111>
c0012f08:	04f71463          	bne	a4,a5,c0012f50 <XAxiEthernet_PhySetMdioDivisor+0x88>
c0012f0c:	0280006f          	j	c0012f34 <XAxiEthernet_PhySetMdioDivisor+0x6c>
	Xil_AssertVoid(InstancePtr != NULL);
c0012f10:	68f00593          	li	a1,1679
c0012f14:	07fee517          	auipc	a0,0x7fee
c0012f18:	ea850513          	addi	a0,a0,-344 # c8000dbc <__rodata_start+0xdbc>
c0012f1c:	3a10a0ef          	jal	ra,c001dabc <Xil_Assert>
c0012f20:	07ff0797          	auipc	a5,0x7ff0
c0012f24:	9f478793          	addi	a5,a5,-1548 # c8002914 <Xil_AssertStatus>
c0012f28:	00100713          	li	a4,1
c0012f2c:	00e7a023          	sw	a4,0(a5)
c0012f30:	09c0006f          	j	c0012fcc <XAxiEthernet_PhySetMdioDivisor+0x104>
	Xil_AssertVoid(InstancePtr->IsReady == XIL_COMPONENT_IS_READY)
c0012f34:	07ff0797          	auipc	a5,0x7ff0
c0012f38:	9e078793          	addi	a5,a5,-1568 # c8002914 <Xil_AssertStatus>
c0012f3c:	0007a023          	sw	zero,0(a5)
	Xil_AssertVoid(Divisor <= XAE_MDIO_MC_CLOCK_DIVIDE_MAX);
c0012f40:	feb44703          	lbu	a4,-21(s0)
c0012f44:	03f00793          	li	a5,63
c0012f48:	06e7e063          	bltu	a5,a4,c0012fa8 <XAxiEthernet_PhySetMdioDivisor+0xe0>
c0012f4c:	0280006f          	j	c0012f74 <XAxiEthernet_PhySetMdioDivisor+0xac>
	Xil_AssertVoid(InstancePtr->IsReady == XIL_COMPONENT_IS_READY)
c0012f50:	69000593          	li	a1,1680
c0012f54:	07fee517          	auipc	a0,0x7fee
c0012f58:	e6850513          	addi	a0,a0,-408 # c8000dbc <__rodata_start+0xdbc>
c0012f5c:	3610a0ef          	jal	ra,c001dabc <Xil_Assert>
c0012f60:	07ff0797          	auipc	a5,0x7ff0
c0012f64:	9b478793          	addi	a5,a5,-1612 # c8002914 <Xil_AssertStatus>
c0012f68:	00100713          	li	a4,1
c0012f6c:	00e7a023          	sw	a4,0(a5)
c0012f70:	05c0006f          	j	c0012fcc <XAxiEthernet_PhySetMdioDivisor+0x104>
	Xil_AssertVoid(Divisor <= XAE_MDIO_MC_CLOCK_DIVIDE_MAX);
c0012f74:	07ff0797          	auipc	a5,0x7ff0
c0012f78:	9a078793          	addi	a5,a5,-1632 # c8002914 <Xil_AssertStatus>
c0012f7c:	0007a023          	sw	zero,0(a5)


	xaxi_debug_printf("XAxiEthernet_PhySetMdioDivisor\r\n");

	XAxiEthernet_WriteReg(InstancePtr->Config.BaseAddress,
c0012f80:	fec42783          	lw	a5,-20(s0)
c0012f84:	0047a783          	lw	a5,4(a5)
c0012f88:	50078713          	addi	a4,a5,1280
c0012f8c:	feb44783          	lbu	a5,-21(s0)
c0012f90:	0407e793          	ori	a5,a5,64
c0012f94:	0ff7f793          	andi	a5,a5,255
c0012f98:	00078593          	mv	a1,a5
c0012f9c:	00070513          	mv	a0,a4
c0012fa0:	8c8fe0ef          	jal	ra,c0011068 <Xil_Out32>
c0012fa4:	0280006f          	j	c0012fcc <XAxiEthernet_PhySetMdioDivisor+0x104>
	Xil_AssertVoid(Divisor <= XAE_MDIO_MC_CLOCK_DIVIDE_MAX);
c0012fa8:	69100593          	li	a1,1681
c0012fac:	07fee517          	auipc	a0,0x7fee
c0012fb0:	e1050513          	addi	a0,a0,-496 # c8000dbc <__rodata_start+0xdbc>
c0012fb4:	3090a0ef          	jal	ra,c001dabc <Xil_Assert>
c0012fb8:	07ff0797          	auipc	a5,0x7ff0
c0012fbc:	95c78793          	addi	a5,a5,-1700 # c8002914 <Xil_AssertStatus>
c0012fc0:	00100713          	li	a4,1
c0012fc4:	00e7a023          	sw	a4,0(a5)
c0012fc8:	00000013          	nop
				XAE_MDIO_MC_OFFSET,
				(u32) Divisor | XAE_MDIO_MC_MDIOEN_MASK);
}
c0012fcc:	01c12083          	lw	ra,28(sp)
c0012fd0:	01812403          	lw	s0,24(sp)
c0012fd4:	02010113          	addi	sp,sp,32
c0012fd8:	00008067          	ret

c0012fdc <XAxiEthernet_PhyRead>:
* suitable for recovery.
*
******************************************************************************/
void XAxiEthernet_PhyRead(XAxiEthernet *InstancePtr, u32 PhyAddress,
			   u32 RegisterNum, u16 *PhyDataPtr)
{
c0012fdc:	fc010113          	addi	sp,sp,-64
c0012fe0:	02112e23          	sw	ra,60(sp)
c0012fe4:	02812c23          	sw	s0,56(sp)
c0012fe8:	04010413          	addi	s0,sp,64
c0012fec:	fca42623          	sw	a0,-52(s0)
c0012ff0:	fcb42423          	sw	a1,-56(s0)
c0012ff4:	fcc42223          	sw	a2,-60(s0)
c0012ff8:	fcd42023          	sw	a3,-64(s0)
	u32 MdioCtrlReg = 0;
c0012ffc:	fc042e23          	sw	zero,-36(s0)
	u32 value=0U;
c0013000:	fc042c23          	sw	zero,-40(s0)
		InstancePtr->Config.BaseAddress, RegisterNum);

	/*
	 * Verify that each of the inputs are valid.
	 */
	Xil_AssertVoid(InstancePtr != NULL);
c0013004:	fcc42783          	lw	a5,-52(s0)
c0013008:	02078063          	beqz	a5,c0013028 <XAxiEthernet_PhyRead+0x4c>
c001300c:	07ff0797          	auipc	a5,0x7ff0
c0013010:	90878793          	addi	a5,a5,-1784 # c8002914 <Xil_AssertStatus>
c0013014:	0007a023          	sw	zero,0(a5)
	Xil_AssertVoid(PhyAddress <= XAE_PHY_ADDR_LIMIT);
c0013018:	fc842703          	lw	a4,-56(s0)
c001301c:	01f00793          	li	a5,31
c0013020:	04e7e463          	bltu	a5,a4,c0013068 <XAxiEthernet_PhyRead+0x8c>
c0013024:	0280006f          	j	c001304c <XAxiEthernet_PhyRead+0x70>
	Xil_AssertVoid(InstancePtr != NULL);
c0013028:	6cd00593          	li	a1,1741
c001302c:	07fee517          	auipc	a0,0x7fee
c0013030:	d9050513          	addi	a0,a0,-624 # c8000dbc <__rodata_start+0xdbc>
c0013034:	2890a0ef          	jal	ra,c001dabc <Xil_Assert>
c0013038:	07ff0797          	auipc	a5,0x7ff0
c001303c:	8dc78793          	addi	a5,a5,-1828 # c8002914 <Xil_AssertStatus>
c0013040:	00100713          	li	a4,1
c0013044:	00e7a023          	sw	a4,0(a5)
c0013048:	29c0006f          	j	c00132e4 <XAxiEthernet_PhyRead+0x308>
	Xil_AssertVoid(PhyAddress <= XAE_PHY_ADDR_LIMIT);
c001304c:	07ff0797          	auipc	a5,0x7ff0
c0013050:	8c878793          	addi	a5,a5,-1848 # c8002914 <Xil_AssertStatus>
c0013054:	0007a023          	sw	zero,0(a5)
	Xil_AssertVoid(RegisterNum <= XAE_PHY_REG_NUM_LIMIT);
c0013058:	fc442703          	lw	a4,-60(s0)
c001305c:	01f00793          	li	a5,31
c0013060:	04e7e863          	bltu	a5,a4,c00130b0 <XAxiEthernet_PhyRead+0xd4>
c0013064:	0280006f          	j	c001308c <XAxiEthernet_PhyRead+0xb0>
	Xil_AssertVoid(PhyAddress <= XAE_PHY_ADDR_LIMIT);
c0013068:	6ce00593          	li	a1,1742
c001306c:	07fee517          	auipc	a0,0x7fee
c0013070:	d5050513          	addi	a0,a0,-688 # c8000dbc <__rodata_start+0xdbc>
c0013074:	2490a0ef          	jal	ra,c001dabc <Xil_Assert>
c0013078:	07ff0797          	auipc	a5,0x7ff0
c001307c:	89c78793          	addi	a5,a5,-1892 # c8002914 <Xil_AssertStatus>
c0013080:	00100713          	li	a4,1
c0013084:	00e7a023          	sw	a4,0(a5)
c0013088:	25c0006f          	j	c00132e4 <XAxiEthernet_PhyRead+0x308>
	Xil_AssertVoid(RegisterNum <= XAE_PHY_REG_NUM_LIMIT);
c001308c:	07ff0797          	auipc	a5,0x7ff0
c0013090:	88878793          	addi	a5,a5,-1912 # c8002914 <Xil_AssertStatus>
c0013094:	0007a023          	sw	zero,0(a5)

	/*
	 * Wait till MDIO interface is ready to accept a new transaction.
	 */
	TimeoutLoops = Xil_poll_timeout(Xil_In32,InstancePtr->Config.BaseAddress+
c0013098:	00002737          	lui	a4,0x2
c001309c:	71070713          	addi	a4,a4,1808 # 2710 <_STACK_SIZE+0x1710>
c00130a0:	00000793          	li	a5,0
c00130a4:	fee42423          	sw	a4,-24(s0)
c00130a8:	fef42623          	sw	a5,-20(s0)
c00130ac:	0280006f          	j	c00130d4 <XAxiEthernet_PhyRead+0xf8>
	Xil_AssertVoid(RegisterNum <= XAE_PHY_REG_NUM_LIMIT);
c00130b0:	6cf00593          	li	a1,1743
c00130b4:	07fee517          	auipc	a0,0x7fee
c00130b8:	d0850513          	addi	a0,a0,-760 # c8000dbc <__rodata_start+0xdbc>
c00130bc:	2010a0ef          	jal	ra,c001dabc <Xil_Assert>
c00130c0:	07ff0797          	auipc	a5,0x7ff0
c00130c4:	85478793          	addi	a5,a5,-1964 # c8002914 <Xil_AssertStatus>
c00130c8:	00100713          	li	a4,1
c00130cc:	00e7a023          	sw	a4,0(a5)
c00130d0:	2140006f          	j	c00132e4 <XAxiEthernet_PhyRead+0x308>
	TimeoutLoops = Xil_poll_timeout(Xil_In32,InstancePtr->Config.BaseAddress+
c00130d4:	fcc42783          	lw	a5,-52(s0)
c00130d8:	0047a783          	lw	a5,4(a5)
c00130dc:	50478793          	addi	a5,a5,1284
c00130e0:	00078513          	mv	a0,a5
c00130e4:	f5dfd0ef          	jal	ra,c0011040 <Xil_In32>
c00130e8:	fca42c23          	sw	a0,-40(s0)
c00130ec:	fd842783          	lw	a5,-40(s0)
c00130f0:	0807f793          	andi	a5,a5,128
c00130f4:	04079863          	bnez	a5,c0013144 <XAxiEthernet_PhyRead+0x168>
c00130f8:	00100513          	li	a0,1
c00130fc:	c79ef0ef          	jal	ra,c0002d74 <vTaskDelay>
c0013100:	fe842603          	lw	a2,-24(s0)
c0013104:	fec42683          	lw	a3,-20(s0)
c0013108:	fff00513          	li	a0,-1
c001310c:	fff00593          	li	a1,-1
c0013110:	00a60733          	add	a4,a2,a0
c0013114:	00070813          	mv	a6,a4
c0013118:	00c83833          	sltu	a6,a6,a2
c001311c:	00b687b3          	add	a5,a3,a1
c0013120:	00f806b3          	add	a3,a6,a5
c0013124:	00068793          	mv	a5,a3
c0013128:	fee42423          	sw	a4,-24(s0)
c001312c:	fef42623          	sw	a5,-20(s0)
c0013130:	fe842783          	lw	a5,-24(s0)
c0013134:	fec42703          	lw	a4,-20(s0)
c0013138:	00e7e7b3          	or	a5,a5,a4
c001313c:	00078463          	beqz	a5,c0013144 <XAxiEthernet_PhyRead+0x168>
c0013140:	f95ff06f          	j	c00130d4 <XAxiEthernet_PhyRead+0xf8>
c0013144:	00000013          	nop
c0013148:	fe842783          	lw	a5,-24(s0)
c001314c:	fec42703          	lw	a4,-20(s0)
c0013150:	00e7e7b3          	or	a5,a5,a4
c0013154:	00078663          	beqz	a5,c0013160 <XAxiEthernet_PhyRead+0x184>
c0013158:	00000793          	li	a5,0
c001315c:	0080006f          	j	c0013164 <XAxiEthernet_PhyRead+0x188>
c0013160:	fff00793          	li	a5,-1
c0013164:	fcf42a23          	sw	a5,-44(s0)
	   XAE_MDIO_MCR_OFFSET, value,(value&XAE_MDIO_MCR_READY_MASK)!=0,
			   XAE_RST_DEFAULT_TIMEOUT_VAL);
	if(-1 == TimeoutLoops) {
c0013168:	fd442703          	lw	a4,-44(s0)
c001316c:	fff00793          	li	a5,-1
c0013170:	02f71463          	bne	a4,a5,c0013198 <XAxiEthernet_PhyRead+0x1bc>
		Xil_AssertVoidAlways();
c0013174:	6d800593          	li	a1,1752
c0013178:	07fee517          	auipc	a0,0x7fee
c001317c:	c4450513          	addi	a0,a0,-956 # c8000dbc <__rodata_start+0xdbc>
c0013180:	13d0a0ef          	jal	ra,c001dabc <Xil_Assert>
c0013184:	07fef797          	auipc	a5,0x7fef
c0013188:	79078793          	addi	a5,a5,1936 # c8002914 <Xil_AssertStatus>
c001318c:	00100713          	li	a4,1
c0013190:	00e7a023          	sw	a4,0(a5)
c0013194:	1500006f          	j	c00132e4 <XAxiEthernet_PhyRead+0x308>
	}

	MdioCtrlReg =   ((PhyAddress << XAE_MDIO_MCR_PHYAD_SHIFT) &
c0013198:	fc842783          	lw	a5,-56(s0)
c001319c:	01879713          	slli	a4,a5,0x18
c00131a0:	1f0007b7          	lui	a5,0x1f000
c00131a4:	00f77733          	and	a4,a4,a5
			XAE_MDIO_MCR_PHYAD_MASK) |
			((RegisterNum << XAE_MDIO_MCR_REGAD_SHIFT)
c00131a8:	fc442783          	lw	a5,-60(s0)
c00131ac:	01079693          	slli	a3,a5,0x10
			& XAE_MDIO_MCR_REGAD_MASK) |
c00131b0:	001f07b7          	lui	a5,0x1f0
c00131b4:	00f6f7b3          	and	a5,a3,a5
			XAE_MDIO_MCR_PHYAD_MASK) |
c00131b8:	00f76733          	or	a4,a4,a5
	MdioCtrlReg =   ((PhyAddress << XAE_MDIO_MCR_PHYAD_SHIFT) &
c00131bc:	000097b7          	lui	a5,0x9
c00131c0:	80078793          	addi	a5,a5,-2048 # 8800 <_STACK_SIZE+0x7800>
c00131c4:	00f767b3          	or	a5,a4,a5
c00131c8:	fcf42e23          	sw	a5,-36(s0)
			XAE_MDIO_MCR_INITIATE_MASK |
			XAE_MDIO_MCR_OP_READ_MASK;

	XAxiEthernet_WriteReg(InstancePtr->Config.BaseAddress,
c00131cc:	fcc42783          	lw	a5,-52(s0)
c00131d0:	0047a783          	lw	a5,4(a5)
c00131d4:	50478793          	addi	a5,a5,1284
c00131d8:	fdc42583          	lw	a1,-36(s0)
c00131dc:	00078513          	mv	a0,a5
c00131e0:	e89fd0ef          	jal	ra,c0011068 <Xil_Out32>


	/*
	 * Wait till MDIO transaction is completed.
	 */
	TimeoutLoops = Xil_poll_timeout(Xil_In32,InstancePtr->Config.BaseAddress+
c00131e4:	00002737          	lui	a4,0x2
c00131e8:	71070713          	addi	a4,a4,1808 # 2710 <_STACK_SIZE+0x1710>
c00131ec:	00000793          	li	a5,0
c00131f0:	fee42023          	sw	a4,-32(s0)
c00131f4:	fef42223          	sw	a5,-28(s0)
c00131f8:	fcc42783          	lw	a5,-52(s0)
c00131fc:	0047a783          	lw	a5,4(a5)
c0013200:	50478793          	addi	a5,a5,1284
c0013204:	00078513          	mv	a0,a5
c0013208:	e39fd0ef          	jal	ra,c0011040 <Xil_In32>
c001320c:	fca42c23          	sw	a0,-40(s0)
c0013210:	fd842783          	lw	a5,-40(s0)
c0013214:	0807f793          	andi	a5,a5,128
c0013218:	04079863          	bnez	a5,c0013268 <XAxiEthernet_PhyRead+0x28c>
c001321c:	00100513          	li	a0,1
c0013220:	b55ef0ef          	jal	ra,c0002d74 <vTaskDelay>
c0013224:	fe042603          	lw	a2,-32(s0)
c0013228:	fe442683          	lw	a3,-28(s0)
c001322c:	fff00513          	li	a0,-1
c0013230:	fff00593          	li	a1,-1
c0013234:	00a60733          	add	a4,a2,a0
c0013238:	00070813          	mv	a6,a4
c001323c:	00c83833          	sltu	a6,a6,a2
c0013240:	00b687b3          	add	a5,a3,a1
c0013244:	00f806b3          	add	a3,a6,a5
c0013248:	00068793          	mv	a5,a3
c001324c:	fee42023          	sw	a4,-32(s0)
c0013250:	fef42223          	sw	a5,-28(s0)
c0013254:	fe042783          	lw	a5,-32(s0)
c0013258:	fe442703          	lw	a4,-28(s0)
c001325c:	00e7e7b3          	or	a5,a5,a4
c0013260:	00078463          	beqz	a5,c0013268 <XAxiEthernet_PhyRead+0x28c>
c0013264:	f95ff06f          	j	c00131f8 <XAxiEthernet_PhyRead+0x21c>
c0013268:	00000013          	nop
c001326c:	fe042783          	lw	a5,-32(s0)
c0013270:	fe442703          	lw	a4,-28(s0)
c0013274:	00e7e7b3          	or	a5,a5,a4
c0013278:	00078663          	beqz	a5,c0013284 <XAxiEthernet_PhyRead+0x2a8>
c001327c:	00000793          	li	a5,0
c0013280:	0080006f          	j	c0013288 <XAxiEthernet_PhyRead+0x2ac>
c0013284:	fff00793          	li	a5,-1
c0013288:	fcf42a23          	sw	a5,-44(s0)
	   XAE_MDIO_MCR_OFFSET, value,(value&XAE_MDIO_MCR_READY_MASK)!=0,
		   XAE_RST_DEFAULT_TIMEOUT_VAL);
	if(-1 == TimeoutLoops) {
c001328c:	fd442703          	lw	a4,-44(s0)
c0013290:	fff00793          	li	a5,-1
c0013294:	02f71463          	bne	a4,a5,c00132bc <XAxiEthernet_PhyRead+0x2e0>
		Xil_AssertVoidAlways();
c0013298:	6ed00593          	li	a1,1773
c001329c:	07fee517          	auipc	a0,0x7fee
c00132a0:	b2050513          	addi	a0,a0,-1248 # c8000dbc <__rodata_start+0xdbc>
c00132a4:	0190a0ef          	jal	ra,c001dabc <Xil_Assert>
c00132a8:	07fef797          	auipc	a5,0x7fef
c00132ac:	66c78793          	addi	a5,a5,1644 # c8002914 <Xil_AssertStatus>
c00132b0:	00100713          	li	a4,1
c00132b4:	00e7a023          	sw	a4,0(a5)
c00132b8:	02c0006f          	j	c00132e4 <XAxiEthernet_PhyRead+0x308>
	}

	/* Read data */
	*PhyDataPtr = (u16) XAxiEthernet_ReadReg
c00132bc:	fcc42783          	lw	a5,-52(s0)
c00132c0:	0047a783          	lw	a5,4(a5)
c00132c4:	50c78793          	addi	a5,a5,1292
c00132c8:	00078513          	mv	a0,a5
c00132cc:	d75fd0ef          	jal	ra,c0011040 <Xil_In32>
c00132d0:	00050793          	mv	a5,a0
c00132d4:	01079713          	slli	a4,a5,0x10
c00132d8:	01075713          	srli	a4,a4,0x10
c00132dc:	fc042783          	lw	a5,-64(s0)
c00132e0:	00e79023          	sh	a4,0(a5)
			(InstancePtr->Config.BaseAddress,XAE_MDIO_MRD_OFFSET);
	xaxi_debug_printf(
		"XAxiEthernet_PhyRead: Value retrieved: 0x%0x\r\n", *PhyDataPtr);

}
c00132e4:	03c12083          	lw	ra,60(sp)
c00132e8:	03812403          	lw	s0,56(sp)
c00132ec:	04010113          	addi	sp,sp,64
c00132f0:	00008067          	ret

c00132f4 <XAxiEthernet_PhyWrite>:
* suitable for recovery.
*
******************************************************************************/
void XAxiEthernet_PhyWrite(XAxiEthernet *InstancePtr, u32 PhyAddress,
			u32 RegisterNum, u16 PhyData)
{
c00132f4:	fc010113          	addi	sp,sp,-64
c00132f8:	02112e23          	sw	ra,60(sp)
c00132fc:	02812c23          	sw	s0,56(sp)
c0013300:	04010413          	addi	s0,sp,64
c0013304:	fca42623          	sw	a0,-52(s0)
c0013308:	fcb42423          	sw	a1,-56(s0)
c001330c:	fcc42223          	sw	a2,-60(s0)
c0013310:	00068793          	mv	a5,a3
c0013314:	fcf41123          	sh	a5,-62(s0)
	u32 MdioCtrlReg = 0;
c0013318:	fc042e23          	sw	zero,-36(s0)
	u32 value=0U;
c001331c:	fc042c23          	sw	zero,-40(s0)
	volatile s32 TimeoutLoops;

	/*
	 * Verify that each of the inputs are valid.
	 */
	Xil_AssertVoid(InstancePtr != NULL);
c0013320:	fcc42783          	lw	a5,-52(s0)
c0013324:	02078063          	beqz	a5,c0013344 <XAxiEthernet_PhyWrite+0x50>
c0013328:	07fef797          	auipc	a5,0x7fef
c001332c:	5ec78793          	addi	a5,a5,1516 # c8002914 <Xil_AssertStatus>
c0013330:	0007a023          	sw	zero,0(a5)
	Xil_AssertVoid(PhyAddress <= XAE_PHY_ADDR_LIMIT);
c0013334:	fc842703          	lw	a4,-56(s0)
c0013338:	01f00793          	li	a5,31
c001333c:	04e7e463          	bltu	a5,a4,c0013384 <XAxiEthernet_PhyWrite+0x90>
c0013340:	0280006f          	j	c0013368 <XAxiEthernet_PhyWrite+0x74>
	Xil_AssertVoid(InstancePtr != NULL);
c0013344:	72600593          	li	a1,1830
c0013348:	07fee517          	auipc	a0,0x7fee
c001334c:	a7450513          	addi	a0,a0,-1420 # c8000dbc <__rodata_start+0xdbc>
c0013350:	76c0a0ef          	jal	ra,c001dabc <Xil_Assert>
c0013354:	07fef797          	auipc	a5,0x7fef
c0013358:	5c078793          	addi	a5,a5,1472 # c8002914 <Xil_AssertStatus>
c001335c:	00100713          	li	a4,1
c0013360:	00e7a023          	sw	a4,0(a5)
c0013364:	2900006f          	j	c00135f4 <XAxiEthernet_PhyWrite+0x300>
	Xil_AssertVoid(PhyAddress <= XAE_PHY_ADDR_LIMIT);
c0013368:	07fef797          	auipc	a5,0x7fef
c001336c:	5ac78793          	addi	a5,a5,1452 # c8002914 <Xil_AssertStatus>
c0013370:	0007a023          	sw	zero,0(a5)
	Xil_AssertVoid(RegisterNum <= XAE_PHY_REG_NUM_LIMIT);
c0013374:	fc442703          	lw	a4,-60(s0)
c0013378:	01f00793          	li	a5,31
c001337c:	04e7e863          	bltu	a5,a4,c00133cc <XAxiEthernet_PhyWrite+0xd8>
c0013380:	0280006f          	j	c00133a8 <XAxiEthernet_PhyWrite+0xb4>
	Xil_AssertVoid(PhyAddress <= XAE_PHY_ADDR_LIMIT);
c0013384:	72700593          	li	a1,1831
c0013388:	07fee517          	auipc	a0,0x7fee
c001338c:	a3450513          	addi	a0,a0,-1484 # c8000dbc <__rodata_start+0xdbc>
c0013390:	72c0a0ef          	jal	ra,c001dabc <Xil_Assert>
c0013394:	07fef797          	auipc	a5,0x7fef
c0013398:	58078793          	addi	a5,a5,1408 # c8002914 <Xil_AssertStatus>
c001339c:	00100713          	li	a4,1
c00133a0:	00e7a023          	sw	a4,0(a5)
c00133a4:	2500006f          	j	c00135f4 <XAxiEthernet_PhyWrite+0x300>
	Xil_AssertVoid(RegisterNum <= XAE_PHY_REG_NUM_LIMIT);
c00133a8:	07fef797          	auipc	a5,0x7fef
c00133ac:	56c78793          	addi	a5,a5,1388 # c8002914 <Xil_AssertStatus>
c00133b0:	0007a023          	sw	zero,0(a5)
	xaxi_debug_printf("XAxiEthernet_PhyWrite\r\n");

	/*
	 * Wait till the MDIO interface is ready to accept a new transaction.
	 */
	TimeoutLoops = Xil_poll_timeout(Xil_In32, InstancePtr->Config.BaseAddress +
c00133b4:	00002737          	lui	a4,0x2
c00133b8:	71070713          	addi	a4,a4,1808 # 2710 <_STACK_SIZE+0x1710>
c00133bc:	00000793          	li	a5,0
c00133c0:	fee42423          	sw	a4,-24(s0)
c00133c4:	fef42623          	sw	a5,-20(s0)
c00133c8:	0280006f          	j	c00133f0 <XAxiEthernet_PhyWrite+0xfc>
	Xil_AssertVoid(RegisterNum <= XAE_PHY_REG_NUM_LIMIT);
c00133cc:	72800593          	li	a1,1832
c00133d0:	07fee517          	auipc	a0,0x7fee
c00133d4:	9ec50513          	addi	a0,a0,-1556 # c8000dbc <__rodata_start+0xdbc>
c00133d8:	6e40a0ef          	jal	ra,c001dabc <Xil_Assert>
c00133dc:	07fef797          	auipc	a5,0x7fef
c00133e0:	53878793          	addi	a5,a5,1336 # c8002914 <Xil_AssertStatus>
c00133e4:	00100713          	li	a4,1
c00133e8:	00e7a023          	sw	a4,0(a5)
c00133ec:	2080006f          	j	c00135f4 <XAxiEthernet_PhyWrite+0x300>
	TimeoutLoops = Xil_poll_timeout(Xil_In32, InstancePtr->Config.BaseAddress +
c00133f0:	fcc42783          	lw	a5,-52(s0)
c00133f4:	0047a783          	lw	a5,4(a5)
c00133f8:	50478793          	addi	a5,a5,1284
c00133fc:	00078513          	mv	a0,a5
c0013400:	c41fd0ef          	jal	ra,c0011040 <Xil_In32>
c0013404:	fca42c23          	sw	a0,-40(s0)
c0013408:	fd842783          	lw	a5,-40(s0)
c001340c:	0807f793          	andi	a5,a5,128
c0013410:	04079863          	bnez	a5,c0013460 <XAxiEthernet_PhyWrite+0x16c>
c0013414:	00100513          	li	a0,1
c0013418:	95def0ef          	jal	ra,c0002d74 <vTaskDelay>
c001341c:	fe842603          	lw	a2,-24(s0)
c0013420:	fec42683          	lw	a3,-20(s0)
c0013424:	fff00513          	li	a0,-1
c0013428:	fff00593          	li	a1,-1
c001342c:	00a60733          	add	a4,a2,a0
c0013430:	00070813          	mv	a6,a4
c0013434:	00c83833          	sltu	a6,a6,a2
c0013438:	00b687b3          	add	a5,a3,a1
c001343c:	00f806b3          	add	a3,a6,a5
c0013440:	00068793          	mv	a5,a3
c0013444:	fee42423          	sw	a4,-24(s0)
c0013448:	fef42623          	sw	a5,-20(s0)
c001344c:	fe842783          	lw	a5,-24(s0)
c0013450:	fec42703          	lw	a4,-20(s0)
c0013454:	00e7e7b3          	or	a5,a5,a4
c0013458:	00078463          	beqz	a5,c0013460 <XAxiEthernet_PhyWrite+0x16c>
c001345c:	f95ff06f          	j	c00133f0 <XAxiEthernet_PhyWrite+0xfc>
c0013460:	00000013          	nop
c0013464:	fe842783          	lw	a5,-24(s0)
c0013468:	fec42703          	lw	a4,-20(s0)
c001346c:	00e7e7b3          	or	a5,a5,a4
c0013470:	00078663          	beqz	a5,c001347c <XAxiEthernet_PhyWrite+0x188>
c0013474:	00000793          	li	a5,0
c0013478:	0080006f          	j	c0013480 <XAxiEthernet_PhyWrite+0x18c>
c001347c:	fff00793          	li	a5,-1
c0013480:	fcf42a23          	sw	a5,-44(s0)
	   XAE_MDIO_MCR_OFFSET, value,(value&XAE_MDIO_MCR_READY_MASK)!=0,
	                 XAE_RST_DEFAULT_TIMEOUT_VAL);
	if(-1 == TimeoutLoops) {
c0013484:	fd442703          	lw	a4,-44(s0)
c0013488:	fff00793          	li	a5,-1
c001348c:	02f71463          	bne	a4,a5,c00134b4 <XAxiEthernet_PhyWrite+0x1c0>
		Xil_AssertVoidAlways();
c0013490:	73400593          	li	a1,1844
c0013494:	07fee517          	auipc	a0,0x7fee
c0013498:	92850513          	addi	a0,a0,-1752 # c8000dbc <__rodata_start+0xdbc>
c001349c:	6200a0ef          	jal	ra,c001dabc <Xil_Assert>
c00134a0:	07fef797          	auipc	a5,0x7fef
c00134a4:	47478793          	addi	a5,a5,1140 # c8002914 <Xil_AssertStatus>
c00134a8:	00100713          	li	a4,1
c00134ac:	00e7a023          	sw	a4,0(a5)
c00134b0:	1440006f          	j	c00135f4 <XAxiEthernet_PhyWrite+0x300>
	}

	MdioCtrlReg =   ((PhyAddress << XAE_MDIO_MCR_PHYAD_SHIFT) &
c00134b4:	fc842783          	lw	a5,-56(s0)
c00134b8:	01879713          	slli	a4,a5,0x18
c00134bc:	1f0007b7          	lui	a5,0x1f000
c00134c0:	00f77733          	and	a4,a4,a5
			XAE_MDIO_MCR_PHYAD_MASK) |
			((RegisterNum << XAE_MDIO_MCR_REGAD_SHIFT) &
c00134c4:	fc442783          	lw	a5,-60(s0)
c00134c8:	01079693          	slli	a3,a5,0x10
c00134cc:	001f07b7          	lui	a5,0x1f0
c00134d0:	00f6f7b3          	and	a5,a3,a5
			XAE_MDIO_MCR_PHYAD_MASK) |
c00134d4:	00f76733          	or	a4,a4,a5
	MdioCtrlReg =   ((PhyAddress << XAE_MDIO_MCR_PHYAD_SHIFT) &
c00134d8:	000057b7          	lui	a5,0x5
c00134dc:	80078793          	addi	a5,a5,-2048 # 4800 <_STACK_SIZE+0x3800>
c00134e0:	00f767b3          	or	a5,a4,a5
c00134e4:	fcf42e23          	sw	a5,-36(s0)
			XAE_MDIO_MCR_REGAD_MASK) |
			XAE_MDIO_MCR_INITIATE_MASK |
			XAE_MDIO_MCR_OP_WRITE_MASK;

	XAxiEthernet_WriteReg(InstancePtr->Config.BaseAddress,
c00134e8:	fcc42783          	lw	a5,-52(s0)
c00134ec:	0047a783          	lw	a5,4(a5)
c00134f0:	50878793          	addi	a5,a5,1288
c00134f4:	fc245703          	lhu	a4,-62(s0)
c00134f8:	00070593          	mv	a1,a4
c00134fc:	00078513          	mv	a0,a5
c0013500:	b69fd0ef          	jal	ra,c0011068 <Xil_Out32>
			XAE_MDIO_MWD_OFFSET, PhyData);

	XAxiEthernet_WriteReg(InstancePtr->Config.BaseAddress,
c0013504:	fcc42783          	lw	a5,-52(s0)
c0013508:	0047a783          	lw	a5,4(a5)
c001350c:	50478793          	addi	a5,a5,1284
c0013510:	fdc42583          	lw	a1,-36(s0)
c0013514:	00078513          	mv	a0,a5
c0013518:	b51fd0ef          	jal	ra,c0011068 <Xil_Out32>
			XAE_MDIO_MCR_OFFSET, MdioCtrlReg);

	/*
	 * Wait till the MDIO interface is ready to accept a new transaction.
	 */
	TimeoutLoops = Xil_poll_timeout(Xil_In32,InstancePtr->Config.BaseAddress+
c001351c:	00002737          	lui	a4,0x2
c0013520:	71070713          	addi	a4,a4,1808 # 2710 <_STACK_SIZE+0x1710>
c0013524:	00000793          	li	a5,0
c0013528:	fee42023          	sw	a4,-32(s0)
c001352c:	fef42223          	sw	a5,-28(s0)
c0013530:	fcc42783          	lw	a5,-52(s0)
c0013534:	0047a783          	lw	a5,4(a5)
c0013538:	50478793          	addi	a5,a5,1284
c001353c:	00078513          	mv	a0,a5
c0013540:	b01fd0ef          	jal	ra,c0011040 <Xil_In32>
c0013544:	fca42c23          	sw	a0,-40(s0)
c0013548:	fd842783          	lw	a5,-40(s0)
c001354c:	0807f793          	andi	a5,a5,128
c0013550:	04079863          	bnez	a5,c00135a0 <XAxiEthernet_PhyWrite+0x2ac>
c0013554:	00100513          	li	a0,1
c0013558:	81def0ef          	jal	ra,c0002d74 <vTaskDelay>
c001355c:	fe042603          	lw	a2,-32(s0)
c0013560:	fe442683          	lw	a3,-28(s0)
c0013564:	fff00513          	li	a0,-1
c0013568:	fff00593          	li	a1,-1
c001356c:	00a60733          	add	a4,a2,a0
c0013570:	00070813          	mv	a6,a4
c0013574:	00c83833          	sltu	a6,a6,a2
c0013578:	00b687b3          	add	a5,a3,a1
c001357c:	00f806b3          	add	a3,a6,a5
c0013580:	00068793          	mv	a5,a3
c0013584:	fee42023          	sw	a4,-32(s0)
c0013588:	fef42223          	sw	a5,-28(s0)
c001358c:	fe042783          	lw	a5,-32(s0)
c0013590:	fe442703          	lw	a4,-28(s0)
c0013594:	00e7e7b3          	or	a5,a5,a4
c0013598:	00078463          	beqz	a5,c00135a0 <XAxiEthernet_PhyWrite+0x2ac>
c001359c:	f95ff06f          	j	c0013530 <XAxiEthernet_PhyWrite+0x23c>
c00135a0:	00000013          	nop
c00135a4:	fe042783          	lw	a5,-32(s0)
c00135a8:	fe442703          	lw	a4,-28(s0)
c00135ac:	00e7e7b3          	or	a5,a5,a4
c00135b0:	00078663          	beqz	a5,c00135bc <XAxiEthernet_PhyWrite+0x2c8>
c00135b4:	00000793          	li	a5,0
c00135b8:	0080006f          	j	c00135c0 <XAxiEthernet_PhyWrite+0x2cc>
c00135bc:	fff00793          	li	a5,-1
c00135c0:	fcf42a23          	sw	a5,-44(s0)
	   XAE_MDIO_MCR_OFFSET, value,(value&XAE_MDIO_MCR_READY_MASK)!=0,
		   XAE_RST_DEFAULT_TIMEOUT_VAL);
	if(-1 == TimeoutLoops) {
c00135c4:	fd442703          	lw	a4,-44(s0)
c00135c8:	fff00793          	li	a5,-1
c00135cc:	02f71463          	bne	a4,a5,c00135f4 <XAxiEthernet_PhyWrite+0x300>
		Xil_AssertVoidAlways();
c00135d0:	74b00593          	li	a1,1867
c00135d4:	07fed517          	auipc	a0,0x7fed
c00135d8:	7e850513          	addi	a0,a0,2024 # c8000dbc <__rodata_start+0xdbc>
c00135dc:	4e00a0ef          	jal	ra,c001dabc <Xil_Assert>
c00135e0:	07fef797          	auipc	a5,0x7fef
c00135e4:	33478793          	addi	a5,a5,820 # c8002914 <Xil_AssertStatus>
c00135e8:	00100713          	li	a4,1
c00135ec:	00e7a023          	sw	a4,0(a5)
c00135f0:	00000013          	nop
	}

}
c00135f4:	03c12083          	lw	ra,60(sp)
c00135f8:	03812403          	lw	s0,56(sp)
c00135fc:	04010113          	addi	sp,sp,64
c0013600:	00008067          	ret

c0013604 <Xil_In32>:
{
c0013604:	fe010113          	addi	sp,sp,-32
c0013608:	00812e23          	sw	s0,28(sp)
c001360c:	02010413          	addi	s0,sp,32
c0013610:	fea42623          	sw	a0,-20(s0)
	return *(volatile u32 *) Addr;
c0013614:	fec42783          	lw	a5,-20(s0)
c0013618:	0007a783          	lw	a5,0(a5)
}
c001361c:	00078513          	mv	a0,a5
c0013620:	01c12403          	lw	s0,28(sp)
c0013624:	02010113          	addi	sp,sp,32
c0013628:	00008067          	ret

c001362c <Xil_Out32>:
{
c001362c:	fd010113          	addi	sp,sp,-48
c0013630:	02812623          	sw	s0,44(sp)
c0013634:	03010413          	addi	s0,sp,48
c0013638:	fca42e23          	sw	a0,-36(s0)
c001363c:	fcb42c23          	sw	a1,-40(s0)
	volatile u32 *LocalAddr = (volatile u32 *)Addr;
c0013640:	fdc42783          	lw	a5,-36(s0)
c0013644:	fef42623          	sw	a5,-20(s0)
	*LocalAddr = Value;
c0013648:	fec42783          	lw	a5,-20(s0)
c001364c:	fd842703          	lw	a4,-40(s0)
c0013650:	00e7a023          	sw	a4,0(a5)
}
c0013654:	00000013          	nop
c0013658:	02c12403          	lw	s0,44(sp)
c001365c:	03010113          	addi	sp,sp,48
c0013660:	00008067          	ret

c0013664 <XAxiEthernet_MulticastAdd>:
* multicast address groups.
*
******************************************************************************/
int XAxiEthernet_MulticastAdd(XAxiEthernet *InstancePtr, void *AddressPtr,
								int Entry)
{
c0013664:	fd010113          	addi	sp,sp,-48
c0013668:	02112623          	sw	ra,44(sp)
c001366c:	02812423          	sw	s0,40(sp)
c0013670:	03010413          	addi	s0,sp,48
c0013674:	fca42e23          	sw	a0,-36(s0)
c0013678:	fcb42c23          	sw	a1,-40(s0)
c001367c:	fcc42a23          	sw	a2,-44(s0)
	u32 Af0Reg;
	u32 Af1Reg;
	u32 FmiReg;

	Xil_AssertNonvoid(InstancePtr != NULL);
c0013680:	fdc42783          	lw	a5,-36(s0)
c0013684:	02078463          	beqz	a5,c00136ac <XAxiEthernet_MulticastAdd+0x48>
c0013688:	07fef797          	auipc	a5,0x7fef
c001368c:	28c78793          	addi	a5,a5,652 # c8002914 <Xil_AssertStatus>
c0013690:	0007a023          	sw	zero,0(a5)
	Xil_AssertNonvoid(InstancePtr->IsReady == XIL_COMPONENT_IS_READY);
c0013694:	fdc42783          	lw	a5,-36(s0)
c0013698:	0507a703          	lw	a4,80(a5)
c001369c:	111117b7          	lui	a5,0x11111
c00136a0:	11178793          	addi	a5,a5,273 # 11111111 <_DMEM_LENGTH+0x10911111>
c00136a4:	04f71463          	bne	a4,a5,c00136ec <XAxiEthernet_MulticastAdd+0x88>
c00136a8:	02c0006f          	j	c00136d4 <XAxiEthernet_MulticastAdd+0x70>
	Xil_AssertNonvoid(InstancePtr != NULL);
c00136ac:	07c00593          	li	a1,124
c00136b0:	07fed517          	auipc	a0,0x7fed
c00136b4:	73450513          	addi	a0,a0,1844 # c8000de4 <__rodata_start+0xde4>
c00136b8:	4040a0ef          	jal	ra,c001dabc <Xil_Assert>
c00136bc:	07fef797          	auipc	a5,0x7fef
c00136c0:	25878793          	addi	a5,a5,600 # c8002914 <Xil_AssertStatus>
c00136c4:	00100713          	li	a4,1
c00136c8:	00e7a023          	sw	a4,0(a5)
c00136cc:	00000793          	li	a5,0
c00136d0:	2300006f          	j	c0013900 <XAxiEthernet_MulticastAdd+0x29c>
	Xil_AssertNonvoid(InstancePtr->IsReady == XIL_COMPONENT_IS_READY);
c00136d4:	07fef797          	auipc	a5,0x7fef
c00136d8:	24078793          	addi	a5,a5,576 # c8002914 <Xil_AssertStatus>
c00136dc:	0007a023          	sw	zero,0(a5)
	Xil_AssertNonvoid(AddressPtr != NULL);
c00136e0:	fd842783          	lw	a5,-40(s0)
c00136e4:	04078a63          	beqz	a5,c0013738 <XAxiEthernet_MulticastAdd+0xd4>
c00136e8:	02c0006f          	j	c0013714 <XAxiEthernet_MulticastAdd+0xb0>
	Xil_AssertNonvoid(InstancePtr->IsReady == XIL_COMPONENT_IS_READY);
c00136ec:	07d00593          	li	a1,125
c00136f0:	07fed517          	auipc	a0,0x7fed
c00136f4:	6f450513          	addi	a0,a0,1780 # c8000de4 <__rodata_start+0xde4>
c00136f8:	3c40a0ef          	jal	ra,c001dabc <Xil_Assert>
c00136fc:	07fef797          	auipc	a5,0x7fef
c0013700:	21878793          	addi	a5,a5,536 # c8002914 <Xil_AssertStatus>
c0013704:	00100713          	li	a4,1
c0013708:	00e7a023          	sw	a4,0(a5)
c001370c:	00000793          	li	a5,0
c0013710:	1f00006f          	j	c0013900 <XAxiEthernet_MulticastAdd+0x29c>
	Xil_AssertNonvoid(AddressPtr != NULL);
c0013714:	07fef797          	auipc	a5,0x7fef
c0013718:	20078793          	addi	a5,a5,512 # c8002914 <Xil_AssertStatus>
c001371c:	0007a023          	sw	zero,0(a5)
	Xil_AssertNonvoid(Entry < InstancePtr->Config.NumTableEntries);
c0013720:	fdc42783          	lw	a5,-36(s0)
c0013724:	01c7c783          	lbu	a5,28(a5)
c0013728:	00078713          	mv	a4,a5
c001372c:	fd442783          	lw	a5,-44(s0)
c0013730:	06e7d463          	bge	a5,a4,c0013798 <XAxiEthernet_MulticastAdd+0x134>
c0013734:	02c0006f          	j	c0013760 <XAxiEthernet_MulticastAdd+0xfc>
	Xil_AssertNonvoid(AddressPtr != NULL);
c0013738:	07e00593          	li	a1,126
c001373c:	07fed517          	auipc	a0,0x7fed
c0013740:	6a850513          	addi	a0,a0,1704 # c8000de4 <__rodata_start+0xde4>
c0013744:	3780a0ef          	jal	ra,c001dabc <Xil_Assert>
c0013748:	07fef797          	auipc	a5,0x7fef
c001374c:	1cc78793          	addi	a5,a5,460 # c8002914 <Xil_AssertStatus>
c0013750:	00100713          	li	a4,1
c0013754:	00e7a023          	sw	a4,0(a5)
c0013758:	00000793          	li	a5,0
c001375c:	1a40006f          	j	c0013900 <XAxiEthernet_MulticastAdd+0x29c>
	Xil_AssertNonvoid(Entry < InstancePtr->Config.NumTableEntries);
c0013760:	07fef797          	auipc	a5,0x7fef
c0013764:	1b478793          	addi	a5,a5,436 # c8002914 <Xil_AssertStatus>
c0013768:	0007a023          	sw	zero,0(a5)

	u8 *Aptr = (u8 *) AddressPtr;
c001376c:	fd842783          	lw	a5,-40(s0)
c0013770:	fef42623          	sw	a5,-20(s0)
	printf("XAxiEthernet_MulticastAddr\r\n");
c0013774:	07fed517          	auipc	a0,0x7fed
c0013778:	6a050513          	addi	a0,a0,1696 # c8000e14 <__rodata_start+0xe14>
c001377c:	7440a0ef          	jal	ra,c001dec0 <puts>

	/* The device must be stopped before clearing the multicast hash
	 * table.
	 */
	if (InstancePtr->IsStarted == XIL_COMPONENT_IS_STARTED) {
c0013780:	fdc42783          	lw	a5,-36(s0)
c0013784:	04c7a703          	lw	a4,76(a5)
c0013788:	222227b7          	lui	a5,0x22222
c001378c:	22278793          	addi	a5,a5,546 # 22222222 <_DMEM_LENGTH+0x21a22222>
c0013790:	04f71263          	bne	a4,a5,c00137d4 <XAxiEthernet_MulticastAdd+0x170>
c0013794:	02c0006f          	j	c00137c0 <XAxiEthernet_MulticastAdd+0x15c>
	Xil_AssertNonvoid(Entry < InstancePtr->Config.NumTableEntries);
c0013798:	07f00593          	li	a1,127
c001379c:	07fed517          	auipc	a0,0x7fed
c00137a0:	64850513          	addi	a0,a0,1608 # c8000de4 <__rodata_start+0xde4>
c00137a4:	3180a0ef          	jal	ra,c001dabc <Xil_Assert>
c00137a8:	07fef797          	auipc	a5,0x7fef
c00137ac:	16c78793          	addi	a5,a5,364 # c8002914 <Xil_AssertStatus>
c00137b0:	00100713          	li	a4,1
c00137b4:	00e7a023          	sw	a4,0(a5)
c00137b8:	00000793          	li	a5,0
c00137bc:	1440006f          	j	c0013900 <XAxiEthernet_MulticastAdd+0x29c>
		printf("XAxiEthernet_MulticastAdd: returning DEVICE_IS_STARTED\r\n");
c00137c0:	07fed517          	auipc	a0,0x7fed
c00137c4:	67050513          	addi	a0,a0,1648 # c8000e30 <__rodata_start+0xe30>
c00137c8:	6f80a0ef          	jal	ra,c001dec0 <puts>
		return (XST_DEVICE_IS_STARTED);
c00137cc:	00500793          	li	a5,5
c00137d0:	1300006f          	j	c0013900 <XAxiEthernet_MulticastAdd+0x29c>
	}

	/* Set MAC bits [31:0] */
	Af0Reg = Aptr[0];
c00137d4:	fec42783          	lw	a5,-20(s0)
c00137d8:	0007c783          	lbu	a5,0(a5)
c00137dc:	fef42423          	sw	a5,-24(s0)
	Af0Reg |= Aptr[1] << 8;
c00137e0:	fec42783          	lw	a5,-20(s0)
c00137e4:	00178793          	addi	a5,a5,1
c00137e8:	0007c783          	lbu	a5,0(a5)
c00137ec:	00879793          	slli	a5,a5,0x8
c00137f0:	00078713          	mv	a4,a5
c00137f4:	fe842783          	lw	a5,-24(s0)
c00137f8:	00e7e7b3          	or	a5,a5,a4
c00137fc:	fef42423          	sw	a5,-24(s0)
	Af0Reg |= Aptr[2] << 16;
c0013800:	fec42783          	lw	a5,-20(s0)
c0013804:	00278793          	addi	a5,a5,2
c0013808:	0007c783          	lbu	a5,0(a5)
c001380c:	01079793          	slli	a5,a5,0x10
c0013810:	00078713          	mv	a4,a5
c0013814:	fe842783          	lw	a5,-24(s0)
c0013818:	00e7e7b3          	or	a5,a5,a4
c001381c:	fef42423          	sw	a5,-24(s0)
	Af0Reg |= Aptr[3] << 24;
c0013820:	fec42783          	lw	a5,-20(s0)
c0013824:	00378793          	addi	a5,a5,3
c0013828:	0007c783          	lbu	a5,0(a5)
c001382c:	01879793          	slli	a5,a5,0x18
c0013830:	00078713          	mv	a4,a5
c0013834:	fe842783          	lw	a5,-24(s0)
c0013838:	00e7e7b3          	or	a5,a5,a4
c001383c:	fef42423          	sw	a5,-24(s0)

	/* Set MAC bits [47:32] */
	Af1Reg = Aptr[4];
c0013840:	fec42783          	lw	a5,-20(s0)
c0013844:	00478793          	addi	a5,a5,4
c0013848:	0007c783          	lbu	a5,0(a5)
c001384c:	fef42223          	sw	a5,-28(s0)
	Af1Reg |= Aptr[5] << 8;
c0013850:	fec42783          	lw	a5,-20(s0)
c0013854:	00578793          	addi	a5,a5,5
c0013858:	0007c783          	lbu	a5,0(a5)
c001385c:	00879793          	slli	a5,a5,0x8
c0013860:	00078713          	mv	a4,a5
c0013864:	fe442783          	lw	a5,-28(s0)
c0013868:	00e7e7b3          	or	a5,a5,a4
c001386c:	fef42223          	sw	a5,-28(s0)


	FmiReg = XAxiEthernet_ReadReg(InstancePtr->Config.BaseAddress,
c0013870:	fdc42783          	lw	a5,-36(s0)
c0013874:	0047a783          	lw	a5,4(a5)
c0013878:	70878793          	addi	a5,a5,1800
c001387c:	00078513          	mv	a0,a5
c0013880:	d85ff0ef          	jal	ra,c0013604 <Xil_In32>
c0013884:	fea42023          	sw	a0,-32(s0)
							XAE_FMI_OFFSET);
	FmiReg &= 0xFFFFFF00;
c0013888:	fe042783          	lw	a5,-32(s0)
c001388c:	f007f793          	andi	a5,a5,-256
c0013890:	fef42023          	sw	a5,-32(s0)
	FmiReg |= (Entry);
c0013894:	fd442783          	lw	a5,-44(s0)
c0013898:	fe042703          	lw	a4,-32(s0)
c001389c:	00f767b3          	or	a5,a4,a5
c00138a0:	fef42023          	sw	a5,-32(s0)
	XAxiEthernet_WriteReg(InstancePtr->Config.BaseAddress,
c00138a4:	fdc42783          	lw	a5,-36(s0)
c00138a8:	0047a783          	lw	a5,4(a5)
c00138ac:	70878793          	addi	a5,a5,1800
c00138b0:	fe042583          	lw	a1,-32(s0)
c00138b4:	00078513          	mv	a0,a5
c00138b8:	d75ff0ef          	jal	ra,c001362c <Xil_Out32>
						XAE_FMI_OFFSET, FmiReg);

	/* Add in MAT address */
	printf("Setting MAT entry: %d\r\n", Entry);
c00138bc:	fd442583          	lw	a1,-44(s0)
c00138c0:	07fed517          	auipc	a0,0x7fed
c00138c4:	5a850513          	addi	a0,a0,1448 # c8000e68 <__rodata_start+0xe68>
c00138c8:	4dc0a0ef          	jal	ra,c001dda4 <printf>
	XAxiEthernet_WriteReg(InstancePtr->Config.BaseAddress,
c00138cc:	fdc42783          	lw	a5,-36(s0)
c00138d0:	0047a783          	lw	a5,4(a5)
c00138d4:	71078793          	addi	a5,a5,1808
c00138d8:	fe842583          	lw	a1,-24(s0)
c00138dc:	00078513          	mv	a0,a5
c00138e0:	d4dff0ef          	jal	ra,c001362c <Xil_Out32>
						XAE_AF0_OFFSET, Af0Reg);

	XAxiEthernet_WriteReg(InstancePtr->Config.BaseAddress,
c00138e4:	fdc42783          	lw	a5,-36(s0)
c00138e8:	0047a783          	lw	a5,4(a5)
c00138ec:	71478793          	addi	a5,a5,1812
c00138f0:	fe442583          	lw	a1,-28(s0)
c00138f4:	00078513          	mv	a0,a5
c00138f8:	d35ff0ef          	jal	ra,c001362c <Xil_Out32>
						XAE_AF1_OFFSET, Af1Reg);

	return (XST_SUCCESS);
c00138fc:	00000793          	li	a5,0
}
c0013900:	00078513          	mv	a0,a5
c0013904:	02c12083          	lw	ra,44(sp)
c0013908:	02812403          	lw	s0,40(sp)
c001390c:	03010113          	addi	sp,sp,48
c0013910:	00008067          	ret

c0013914 <XAxiEthernet_MulticastGet>:
* multicast address groups.
*
******************************************************************************/
void XAxiEthernet_MulticastGet(XAxiEthernet *InstancePtr, void *AddressPtr,
								int Entry)
{
c0013914:	fd010113          	addi	sp,sp,-48
c0013918:	02112623          	sw	ra,44(sp)
c001391c:	02812423          	sw	s0,40(sp)
c0013920:	03010413          	addi	s0,sp,48
c0013924:	fca42e23          	sw	a0,-36(s0)
c0013928:	fcb42c23          	sw	a1,-40(s0)
c001392c:	fcc42a23          	sw	a2,-44(s0)
	u32 Af0Reg;
	u32 Af1Reg;
	u32 FmiReg;

	Xil_AssertVoid(InstancePtr != NULL);
c0013930:	fdc42783          	lw	a5,-36(s0)
c0013934:	02078463          	beqz	a5,c001395c <XAxiEthernet_MulticastGet+0x48>
c0013938:	07fef797          	auipc	a5,0x7fef
c001393c:	fdc78793          	addi	a5,a5,-36 # c8002914 <Xil_AssertStatus>
c0013940:	0007a023          	sw	zero,0(a5)
	Xil_AssertVoid(InstancePtr->IsReady == XIL_COMPONENT_IS_READY);
c0013944:	fdc42783          	lw	a5,-36(s0)
c0013948:	0507a703          	lw	a4,80(a5)
c001394c:	111117b7          	lui	a5,0x11111
c0013950:	11178793          	addi	a5,a5,273 # 11111111 <_DMEM_LENGTH+0x10911111>
c0013954:	04f71263          	bne	a4,a5,c0013998 <XAxiEthernet_MulticastGet+0x84>
c0013958:	0280006f          	j	c0013980 <XAxiEthernet_MulticastGet+0x6c>
	Xil_AssertVoid(InstancePtr != NULL);
c001395c:	0cc00593          	li	a1,204
c0013960:	07fed517          	auipc	a0,0x7fed
c0013964:	48450513          	addi	a0,a0,1156 # c8000de4 <__rodata_start+0xde4>
c0013968:	1540a0ef          	jal	ra,c001dabc <Xil_Assert>
c001396c:	07fef797          	auipc	a5,0x7fef
c0013970:	fa878793          	addi	a5,a5,-88 # c8002914 <Xil_AssertStatus>
c0013974:	00100713          	li	a4,1
c0013978:	00e7a023          	sw	a4,0(a5)
c001397c:	1dc0006f          	j	c0013b58 <XAxiEthernet_MulticastGet+0x244>
	Xil_AssertVoid(InstancePtr->IsReady == XIL_COMPONENT_IS_READY);
c0013980:	07fef797          	auipc	a5,0x7fef
c0013984:	f9478793          	addi	a5,a5,-108 # c8002914 <Xil_AssertStatus>
c0013988:	0007a023          	sw	zero,0(a5)
	Xil_AssertVoid(AddressPtr != NULL);
c001398c:	fd842783          	lw	a5,-40(s0)
c0013990:	04078863          	beqz	a5,c00139e0 <XAxiEthernet_MulticastGet+0xcc>
c0013994:	0280006f          	j	c00139bc <XAxiEthernet_MulticastGet+0xa8>
	Xil_AssertVoid(InstancePtr->IsReady == XIL_COMPONENT_IS_READY);
c0013998:	0cd00593          	li	a1,205
c001399c:	07fed517          	auipc	a0,0x7fed
c00139a0:	44850513          	addi	a0,a0,1096 # c8000de4 <__rodata_start+0xde4>
c00139a4:	1180a0ef          	jal	ra,c001dabc <Xil_Assert>
c00139a8:	07fef797          	auipc	a5,0x7fef
c00139ac:	f6c78793          	addi	a5,a5,-148 # c8002914 <Xil_AssertStatus>
c00139b0:	00100713          	li	a4,1
c00139b4:	00e7a023          	sw	a4,0(a5)
c00139b8:	1a00006f          	j	c0013b58 <XAxiEthernet_MulticastGet+0x244>
	Xil_AssertVoid(AddressPtr != NULL);
c00139bc:	07fef797          	auipc	a5,0x7fef
c00139c0:	f5878793          	addi	a5,a5,-168 # c8002914 <Xil_AssertStatus>
c00139c4:	0007a023          	sw	zero,0(a5)
	Xil_AssertVoid(Entry < InstancePtr->Config.NumTableEntries);
c00139c8:	fdc42783          	lw	a5,-36(s0)
c00139cc:	01c7c783          	lbu	a5,28(a5)
c00139d0:	00078713          	mv	a4,a5
c00139d4:	fd442783          	lw	a5,-44(s0)
c00139d8:	14e7de63          	bge	a5,a4,c0013b34 <XAxiEthernet_MulticastGet+0x220>
c00139dc:	0280006f          	j	c0013a04 <XAxiEthernet_MulticastGet+0xf0>
	Xil_AssertVoid(AddressPtr != NULL);
c00139e0:	0ce00593          	li	a1,206
c00139e4:	07fed517          	auipc	a0,0x7fed
c00139e8:	40050513          	addi	a0,a0,1024 # c8000de4 <__rodata_start+0xde4>
c00139ec:	0d00a0ef          	jal	ra,c001dabc <Xil_Assert>
c00139f0:	07fef797          	auipc	a5,0x7fef
c00139f4:	f2478793          	addi	a5,a5,-220 # c8002914 <Xil_AssertStatus>
c00139f8:	00100713          	li	a4,1
c00139fc:	00e7a023          	sw	a4,0(a5)
c0013a00:	1580006f          	j	c0013b58 <XAxiEthernet_MulticastGet+0x244>
	Xil_AssertVoid(Entry < InstancePtr->Config.NumTableEntries);
c0013a04:	07fef797          	auipc	a5,0x7fef
c0013a08:	f1078793          	addi	a5,a5,-240 # c8002914 <Xil_AssertStatus>
c0013a0c:	0007a023          	sw	zero,0(a5)

	u8 *Aptr = (u8 *) AddressPtr;
c0013a10:	fd842783          	lw	a5,-40(s0)
c0013a14:	fef42623          	sw	a5,-20(s0)
	printf("XAxiEthernet_MulticastGet\r\n");
c0013a18:	07fed517          	auipc	a0,0x7fed
c0013a1c:	46850513          	addi	a0,a0,1128 # c8000e80 <__rodata_start+0xe80>
c0013a20:	4a00a0ef          	jal	ra,c001dec0 <puts>


	FmiReg = XAxiEthernet_ReadReg(InstancePtr->Config.BaseAddress,
c0013a24:	fdc42783          	lw	a5,-36(s0)
c0013a28:	0047a783          	lw	a5,4(a5)
c0013a2c:	70878793          	addi	a5,a5,1800
c0013a30:	00078513          	mv	a0,a5
c0013a34:	bd1ff0ef          	jal	ra,c0013604 <Xil_In32>
c0013a38:	fea42423          	sw	a0,-24(s0)
							XAE_FMI_OFFSET);
	FmiReg &= 0xFFFFFF00;
c0013a3c:	fe842783          	lw	a5,-24(s0)
c0013a40:	f007f793          	andi	a5,a5,-256
c0013a44:	fef42423          	sw	a5,-24(s0)
	FmiReg |= (Entry);
c0013a48:	fd442783          	lw	a5,-44(s0)
c0013a4c:	fe842703          	lw	a4,-24(s0)
c0013a50:	00f767b3          	or	a5,a4,a5
c0013a54:	fef42423          	sw	a5,-24(s0)
	XAxiEthernet_WriteReg(InstancePtr->Config.BaseAddress,
c0013a58:	fdc42783          	lw	a5,-36(s0)
c0013a5c:	0047a783          	lw	a5,4(a5)
c0013a60:	70878793          	addi	a5,a5,1800
c0013a64:	fe842583          	lw	a1,-24(s0)
c0013a68:	00078513          	mv	a0,a5
c0013a6c:	bc1ff0ef          	jal	ra,c001362c <Xil_Out32>
						XAE_FMI_OFFSET, FmiReg);


	Af0Reg = XAxiEthernet_ReadReg(InstancePtr->Config.BaseAddress,
c0013a70:	fdc42783          	lw	a5,-36(s0)
c0013a74:	0047a783          	lw	a5,4(a5)
c0013a78:	71078793          	addi	a5,a5,1808
c0013a7c:	00078513          	mv	a0,a5
c0013a80:	b85ff0ef          	jal	ra,c0013604 <Xil_In32>
c0013a84:	fea42223          	sw	a0,-28(s0)
							XAE_AF0_OFFSET);
	Af1Reg = XAxiEthernet_ReadReg(InstancePtr->Config.BaseAddress,
c0013a88:	fdc42783          	lw	a5,-36(s0)
c0013a8c:	0047a783          	lw	a5,4(a5)
c0013a90:	71478793          	addi	a5,a5,1812
c0013a94:	00078513          	mv	a0,a5
c0013a98:	b6dff0ef          	jal	ra,c0013604 <Xil_In32>
c0013a9c:	fea42023          	sw	a0,-32(s0)
							XAE_AF1_OFFSET);

	/* Copy the address to the user buffer */
	Aptr[0] = (u8) Af0Reg;
c0013aa0:	fe442783          	lw	a5,-28(s0)
c0013aa4:	0ff7f713          	andi	a4,a5,255
c0013aa8:	fec42783          	lw	a5,-20(s0)
c0013aac:	00e78023          	sb	a4,0(a5)
	Aptr[1] = (u8) (Af0Reg >> 8);
c0013ab0:	fe442783          	lw	a5,-28(s0)
c0013ab4:	0087d713          	srli	a4,a5,0x8
c0013ab8:	fec42783          	lw	a5,-20(s0)
c0013abc:	00178793          	addi	a5,a5,1
c0013ac0:	0ff77713          	andi	a4,a4,255
c0013ac4:	00e78023          	sb	a4,0(a5)
	Aptr[2] = (u8) (Af0Reg >> 16);
c0013ac8:	fe442783          	lw	a5,-28(s0)
c0013acc:	0107d713          	srli	a4,a5,0x10
c0013ad0:	fec42783          	lw	a5,-20(s0)
c0013ad4:	00278793          	addi	a5,a5,2
c0013ad8:	0ff77713          	andi	a4,a4,255
c0013adc:	00e78023          	sb	a4,0(a5)
	Aptr[3] = (u8) (Af0Reg >> 24);
c0013ae0:	fe442783          	lw	a5,-28(s0)
c0013ae4:	0187d713          	srli	a4,a5,0x18
c0013ae8:	fec42783          	lw	a5,-20(s0)
c0013aec:	00378793          	addi	a5,a5,3
c0013af0:	0ff77713          	andi	a4,a4,255
c0013af4:	00e78023          	sb	a4,0(a5)
	Aptr[4] = (u8) Af1Reg;
c0013af8:	fec42783          	lw	a5,-20(s0)
c0013afc:	00478793          	addi	a5,a5,4
c0013b00:	fe042703          	lw	a4,-32(s0)
c0013b04:	0ff77713          	andi	a4,a4,255
c0013b08:	00e78023          	sb	a4,0(a5)
	Aptr[5] = (u8) (Af1Reg >> 8);
c0013b0c:	fe042783          	lw	a5,-32(s0)
c0013b10:	0087d713          	srli	a4,a5,0x8
c0013b14:	fec42783          	lw	a5,-20(s0)
c0013b18:	00578793          	addi	a5,a5,5
c0013b1c:	0ff77713          	andi	a4,a4,255
c0013b20:	00e78023          	sb	a4,0(a5)

	printf("XAxiEthernet_MulticastGet: done\r\n");
c0013b24:	07fed517          	auipc	a0,0x7fed
c0013b28:	37850513          	addi	a0,a0,888 # c8000e9c <__rodata_start+0xe9c>
c0013b2c:	3940a0ef          	jal	ra,c001dec0 <puts>
c0013b30:	0280006f          	j	c0013b58 <XAxiEthernet_MulticastGet+0x244>
	Xil_AssertVoid(Entry < InstancePtr->Config.NumTableEntries);
c0013b34:	0cf00593          	li	a1,207
c0013b38:	07fed517          	auipc	a0,0x7fed
c0013b3c:	2ac50513          	addi	a0,a0,684 # c8000de4 <__rodata_start+0xde4>
c0013b40:	77d090ef          	jal	ra,c001dabc <Xil_Assert>
c0013b44:	07fef797          	auipc	a5,0x7fef
c0013b48:	dd078793          	addi	a5,a5,-560 # c8002914 <Xil_AssertStatus>
c0013b4c:	00100713          	li	a4,1
c0013b50:	00e7a023          	sw	a4,0(a5)
c0013b54:	00000013          	nop
}
c0013b58:	02c12083          	lw	ra,44(sp)
c0013b5c:	02812403          	lw	s0,40(sp)
c0013b60:	03010113          	addi	sp,sp,48
c0013b64:	00008067          	ret

c0013b68 <XAxiEthernet_MulticastClear>:
* XAxiEthernet_[Add|Clear|Get]ExtMulticastGroup() must be used to manage
* multicast address groups.
*
******************************************************************************/
int XAxiEthernet_MulticastClear(XAxiEthernet *InstancePtr, int Entry)
{
c0013b68:	fd010113          	addi	sp,sp,-48
c0013b6c:	02112623          	sw	ra,44(sp)
c0013b70:	02812423          	sw	s0,40(sp)
c0013b74:	03010413          	addi	s0,sp,48
c0013b78:	fca42e23          	sw	a0,-36(s0)
c0013b7c:	fcb42c23          	sw	a1,-40(s0)
	u32 FmiReg;

	Xil_AssertNonvoid(InstancePtr != NULL);
c0013b80:	fdc42783          	lw	a5,-36(s0)
c0013b84:	02078463          	beqz	a5,c0013bac <XAxiEthernet_MulticastClear+0x44>
c0013b88:	07fef797          	auipc	a5,0x7fef
c0013b8c:	d8c78793          	addi	a5,a5,-628 # c8002914 <Xil_AssertStatus>
c0013b90:	0007a023          	sw	zero,0(a5)
	Xil_AssertNonvoid(InstancePtr->IsReady == XIL_COMPONENT_IS_READY);
c0013b94:	fdc42783          	lw	a5,-36(s0)
c0013b98:	0507a703          	lw	a4,80(a5)
c0013b9c:	111117b7          	lui	a5,0x11111
c0013ba0:	11178793          	addi	a5,a5,273 # 11111111 <_DMEM_LENGTH+0x10911111>
c0013ba4:	04f71a63          	bne	a4,a5,c0013bf8 <XAxiEthernet_MulticastClear+0x90>
c0013ba8:	02c0006f          	j	c0013bd4 <XAxiEthernet_MulticastClear+0x6c>
	Xil_AssertNonvoid(InstancePtr != NULL);
c0013bac:	10e00593          	li	a1,270
c0013bb0:	07fed517          	auipc	a0,0x7fed
c0013bb4:	23450513          	addi	a0,a0,564 # c8000de4 <__rodata_start+0xde4>
c0013bb8:	705090ef          	jal	ra,c001dabc <Xil_Assert>
c0013bbc:	07fef797          	auipc	a5,0x7fef
c0013bc0:	d5878793          	addi	a5,a5,-680 # c8002914 <Xil_AssertStatus>
c0013bc4:	00100713          	li	a4,1
c0013bc8:	00e7a023          	sw	a4,0(a5)
c0013bcc:	00000793          	li	a5,0
c0013bd0:	1480006f          	j	c0013d18 <XAxiEthernet_MulticastClear+0x1b0>
	Xil_AssertNonvoid(InstancePtr->IsReady == XIL_COMPONENT_IS_READY);
c0013bd4:	07fef797          	auipc	a5,0x7fef
c0013bd8:	d4078793          	addi	a5,a5,-704 # c8002914 <Xil_AssertStatus>
c0013bdc:	0007a023          	sw	zero,0(a5)
	Xil_AssertNonvoid(Entry < InstancePtr->Config.NumTableEntries);
c0013be0:	fdc42783          	lw	a5,-36(s0)
c0013be4:	01c7c783          	lbu	a5,28(a5)
c0013be8:	00078713          	mv	a4,a5
c0013bec:	fd842783          	lw	a5,-40(s0)
c0013bf0:	06e7d063          	bge	a5,a4,c0013c50 <XAxiEthernet_MulticastClear+0xe8>
c0013bf4:	02c0006f          	j	c0013c20 <XAxiEthernet_MulticastClear+0xb8>
	Xil_AssertNonvoid(InstancePtr->IsReady == XIL_COMPONENT_IS_READY);
c0013bf8:	10f00593          	li	a1,271
c0013bfc:	07fed517          	auipc	a0,0x7fed
c0013c00:	1e850513          	addi	a0,a0,488 # c8000de4 <__rodata_start+0xde4>
c0013c04:	6b9090ef          	jal	ra,c001dabc <Xil_Assert>
c0013c08:	07fef797          	auipc	a5,0x7fef
c0013c0c:	d0c78793          	addi	a5,a5,-756 # c8002914 <Xil_AssertStatus>
c0013c10:	00100713          	li	a4,1
c0013c14:	00e7a023          	sw	a4,0(a5)
c0013c18:	00000793          	li	a5,0
c0013c1c:	0fc0006f          	j	c0013d18 <XAxiEthernet_MulticastClear+0x1b0>
	Xil_AssertNonvoid(Entry < InstancePtr->Config.NumTableEntries);
c0013c20:	07fef797          	auipc	a5,0x7fef
c0013c24:	cf478793          	addi	a5,a5,-780 # c8002914 <Xil_AssertStatus>
c0013c28:	0007a023          	sw	zero,0(a5)

	printf("XAxiEthernet_MulticastClear\r\n");
c0013c2c:	07fed517          	auipc	a0,0x7fed
c0013c30:	29450513          	addi	a0,a0,660 # c8000ec0 <__rodata_start+0xec0>
c0013c34:	28c0a0ef          	jal	ra,c001dec0 <puts>

	/*
	 * The device must be stopped before clearing the multicast hash
	 * table.
	 */
	if (InstancePtr->IsStarted == XIL_COMPONENT_IS_STARTED) {
c0013c38:	fdc42783          	lw	a5,-36(s0)
c0013c3c:	04c7a703          	lw	a4,76(a5)
c0013c40:	222227b7          	lui	a5,0x22222
c0013c44:	22278793          	addi	a5,a5,546 # 22222222 <_DMEM_LENGTH+0x21a22222>
c0013c48:	04f71263          	bne	a4,a5,c0013c8c <XAxiEthernet_MulticastClear+0x124>
c0013c4c:	02c0006f          	j	c0013c78 <XAxiEthernet_MulticastClear+0x110>
	Xil_AssertNonvoid(Entry < InstancePtr->Config.NumTableEntries);
c0013c50:	11000593          	li	a1,272
c0013c54:	07fed517          	auipc	a0,0x7fed
c0013c58:	19050513          	addi	a0,a0,400 # c8000de4 <__rodata_start+0xde4>
c0013c5c:	661090ef          	jal	ra,c001dabc <Xil_Assert>
c0013c60:	07fef797          	auipc	a5,0x7fef
c0013c64:	cb478793          	addi	a5,a5,-844 # c8002914 <Xil_AssertStatus>
c0013c68:	00100713          	li	a4,1
c0013c6c:	00e7a023          	sw	a4,0(a5)
c0013c70:	00000793          	li	a5,0
c0013c74:	0a40006f          	j	c0013d18 <XAxiEthernet_MulticastClear+0x1b0>
		printf(
c0013c78:	07fed517          	auipc	a0,0x7fed
c0013c7c:	26850513          	addi	a0,a0,616 # c8000ee0 <__rodata_start+0xee0>
c0013c80:	2400a0ef          	jal	ra,c001dec0 <puts>
		"XAxiEthernet_MulticastClear:returning DEVICE_IS_STARTED\r\n");
		return (XST_DEVICE_IS_STARTED);
c0013c84:	00500793          	li	a5,5
c0013c88:	0900006f          	j	c0013d18 <XAxiEthernet_MulticastClear+0x1b0>
	}

	FmiReg = XAxiEthernet_ReadReg(InstancePtr->Config.BaseAddress,
c0013c8c:	fdc42783          	lw	a5,-36(s0)
c0013c90:	0047a783          	lw	a5,4(a5)
c0013c94:	70878793          	addi	a5,a5,1800
c0013c98:	00078513          	mv	a0,a5
c0013c9c:	969ff0ef          	jal	ra,c0013604 <Xil_In32>
c0013ca0:	fea42623          	sw	a0,-20(s0)
							XAE_FMI_OFFSET);
	FmiReg &= 0xFFFFFF00;
c0013ca4:	fec42783          	lw	a5,-20(s0)
c0013ca8:	f007f793          	andi	a5,a5,-256
c0013cac:	fef42623          	sw	a5,-20(s0)
	FmiReg |= (Entry);
c0013cb0:	fd842783          	lw	a5,-40(s0)
c0013cb4:	fec42703          	lw	a4,-20(s0)
c0013cb8:	00f767b3          	or	a5,a4,a5
c0013cbc:	fef42623          	sw	a5,-20(s0)
	XAxiEthernet_WriteReg(InstancePtr->Config.BaseAddress,
c0013cc0:	fdc42783          	lw	a5,-36(s0)
c0013cc4:	0047a783          	lw	a5,4(a5)
c0013cc8:	70878793          	addi	a5,a5,1800
c0013ccc:	fec42583          	lw	a1,-20(s0)
c0013cd0:	00078513          	mv	a0,a5
c0013cd4:	959ff0ef          	jal	ra,c001362c <Xil_Out32>
						XAE_FMI_OFFSET, FmiReg);


	/* Clear the entry by writing 0:0:0:0:0:0 to it */
	XAxiEthernet_WriteReg(InstancePtr->Config.BaseAddress,
c0013cd8:	fdc42783          	lw	a5,-36(s0)
c0013cdc:	0047a783          	lw	a5,4(a5)
c0013ce0:	71078793          	addi	a5,a5,1808
c0013ce4:	00000593          	li	a1,0
c0013ce8:	00078513          	mv	a0,a5
c0013cec:	941ff0ef          	jal	ra,c001362c <Xil_Out32>
						XAE_AF0_OFFSET, 0);

	XAxiEthernet_WriteReg(InstancePtr->Config.BaseAddress,
c0013cf0:	fdc42783          	lw	a5,-36(s0)
c0013cf4:	0047a783          	lw	a5,4(a5)
c0013cf8:	71478793          	addi	a5,a5,1812
c0013cfc:	00000593          	li	a1,0
c0013d00:	00078513          	mv	a0,a5
c0013d04:	929ff0ef          	jal	ra,c001362c <Xil_Out32>
						XAE_AF1_OFFSET, 0);

	printf(
c0013d08:	07fed517          	auipc	a0,0x7fed
c0013d0c:	21450513          	addi	a0,a0,532 # c8000f1c <__rodata_start+0xf1c>
c0013d10:	1b00a0ef          	jal	ra,c001dec0 <puts>
			"XAxiEthernet_MulticastClear: returning SUCCESS\r\n");
	return (XST_SUCCESS);
c0013d14:	00000793          	li	a5,0
}
c0013d18:	00078513          	mv	a0,a5
c0013d1c:	02c12083          	lw	ra,44(sp)
c0013d20:	02812403          	lw	s0,40(sp)
c0013d24:	03010113          	addi	sp,sp,48
c0013d28:	00008067          	ret

c0013d2c <XAxiEthernet_SetMacPauseAddress>:
* @note		None.
*
******************************************************************************/
int XAxiEthernet_SetMacPauseAddress(XAxiEthernet *InstancePtr,
							void *AddressPtr)
{
c0013d2c:	fd010113          	addi	sp,sp,-48
c0013d30:	02112623          	sw	ra,44(sp)
c0013d34:	02812423          	sw	s0,40(sp)
c0013d38:	03010413          	addi	s0,sp,48
c0013d3c:	fca42e23          	sw	a0,-36(s0)
c0013d40:	fcb42c23          	sw	a1,-40(s0)
	u32 MacAddr;

	Xil_AssertNonvoid(InstancePtr != NULL);
c0013d44:	fdc42783          	lw	a5,-36(s0)
c0013d48:	02078463          	beqz	a5,c0013d70 <XAxiEthernet_SetMacPauseAddress+0x44>
c0013d4c:	07fef797          	auipc	a5,0x7fef
c0013d50:	bc878793          	addi	a5,a5,-1080 # c8002914 <Xil_AssertStatus>
c0013d54:	0007a023          	sw	zero,0(a5)
	Xil_AssertNonvoid(InstancePtr->IsReady == XIL_COMPONENT_IS_READY);
c0013d58:	fdc42783          	lw	a5,-36(s0)
c0013d5c:	0507a703          	lw	a4,80(a5)
c0013d60:	111117b7          	lui	a5,0x11111
c0013d64:	11178793          	addi	a5,a5,273 # 11111111 <_DMEM_LENGTH+0x10911111>
c0013d68:	04f71463          	bne	a4,a5,c0013db0 <XAxiEthernet_SetMacPauseAddress+0x84>
c0013d6c:	02c0006f          	j	c0013d98 <XAxiEthernet_SetMacPauseAddress+0x6c>
	Xil_AssertNonvoid(InstancePtr != NULL);
c0013d70:	14b00593          	li	a1,331
c0013d74:	07fed517          	auipc	a0,0x7fed
c0013d78:	07050513          	addi	a0,a0,112 # c8000de4 <__rodata_start+0xde4>
c0013d7c:	541090ef          	jal	ra,c001dabc <Xil_Assert>
c0013d80:	07fef797          	auipc	a5,0x7fef
c0013d84:	b9478793          	addi	a5,a5,-1132 # c8002914 <Xil_AssertStatus>
c0013d88:	00100713          	li	a4,1
c0013d8c:	00e7a023          	sw	a4,0(a5)
c0013d90:	00000793          	li	a5,0
c0013d94:	1c80006f          	j	c0013f5c <XAxiEthernet_SetMacPauseAddress+0x230>
	Xil_AssertNonvoid(InstancePtr->IsReady == XIL_COMPONENT_IS_READY);
c0013d98:	07fef797          	auipc	a5,0x7fef
c0013d9c:	b7c78793          	addi	a5,a5,-1156 # c8002914 <Xil_AssertStatus>
c0013da0:	0007a023          	sw	zero,0(a5)
	Xil_AssertNonvoid(AddressPtr != NULL);
c0013da4:	fd842783          	lw	a5,-40(s0)
c0013da8:	06078463          	beqz	a5,c0013e10 <XAxiEthernet_SetMacPauseAddress+0xe4>
c0013dac:	02c0006f          	j	c0013dd8 <XAxiEthernet_SetMacPauseAddress+0xac>
	Xil_AssertNonvoid(InstancePtr->IsReady == XIL_COMPONENT_IS_READY);
c0013db0:	14c00593          	li	a1,332
c0013db4:	07fed517          	auipc	a0,0x7fed
c0013db8:	03050513          	addi	a0,a0,48 # c8000de4 <__rodata_start+0xde4>
c0013dbc:	501090ef          	jal	ra,c001dabc <Xil_Assert>
c0013dc0:	07fef797          	auipc	a5,0x7fef
c0013dc4:	b5478793          	addi	a5,a5,-1196 # c8002914 <Xil_AssertStatus>
c0013dc8:	00100713          	li	a4,1
c0013dcc:	00e7a023          	sw	a4,0(a5)
c0013dd0:	00000793          	li	a5,0
c0013dd4:	1880006f          	j	c0013f5c <XAxiEthernet_SetMacPauseAddress+0x230>
	Xil_AssertNonvoid(AddressPtr != NULL);
c0013dd8:	07fef797          	auipc	a5,0x7fef
c0013ddc:	b3c78793          	addi	a5,a5,-1220 # c8002914 <Xil_AssertStatus>
c0013de0:	0007a023          	sw	zero,0(a5)

	u8 *Aptr = (u8 *) AddressPtr;
c0013de4:	fd842783          	lw	a5,-40(s0)
c0013de8:	fef42623          	sw	a5,-20(s0)
	printf("XAxiEthernet_SetMacPauseAddress\r\n");
c0013dec:	07fed517          	auipc	a0,0x7fed
c0013df0:	16050513          	addi	a0,a0,352 # c8000f4c <__rodata_start+0xf4c>
c0013df4:	0cc0a0ef          	jal	ra,c001dec0 <puts>

	/* Be sure device has been stopped */
	if (InstancePtr->IsStarted == XIL_COMPONENT_IS_STARTED) {
c0013df8:	fdc42783          	lw	a5,-36(s0)
c0013dfc:	04c7a703          	lw	a4,76(a5)
c0013e00:	222227b7          	lui	a5,0x22222
c0013e04:	22278793          	addi	a5,a5,546 # 22222222 <_DMEM_LENGTH+0x21a22222>
c0013e08:	04f71263          	bne	a4,a5,c0013e4c <XAxiEthernet_SetMacPauseAddress+0x120>
c0013e0c:	02c0006f          	j	c0013e38 <XAxiEthernet_SetMacPauseAddress+0x10c>
	Xil_AssertNonvoid(AddressPtr != NULL);
c0013e10:	14d00593          	li	a1,333
c0013e14:	07fed517          	auipc	a0,0x7fed
c0013e18:	fd050513          	addi	a0,a0,-48 # c8000de4 <__rodata_start+0xde4>
c0013e1c:	4a1090ef          	jal	ra,c001dabc <Xil_Assert>
c0013e20:	07fef797          	auipc	a5,0x7fef
c0013e24:	af478793          	addi	a5,a5,-1292 # c8002914 <Xil_AssertStatus>
c0013e28:	00100713          	li	a4,1
c0013e2c:	00e7a023          	sw	a4,0(a5)
c0013e30:	00000793          	li	a5,0
c0013e34:	1280006f          	j	c0013f5c <XAxiEthernet_SetMacPauseAddress+0x230>
		printf(
c0013e38:	07fed517          	auipc	a0,0x7fed
c0013e3c:	13850513          	addi	a0,a0,312 # c8000f70 <__rodata_start+0xf70>
c0013e40:	0800a0ef          	jal	ra,c001dec0 <puts>
		"XAxiEthernet_SetMacPauseAddress:returning DEVICE_IS_STARTED\r\n");
		return (XST_DEVICE_IS_STARTED);
c0013e44:	00500793          	li	a5,5
c0013e48:	1140006f          	j	c0013f5c <XAxiEthernet_SetMacPauseAddress+0x230>
	}

	/* Set the MAC bits [31:0] in RCW0 register */
	MacAddr = Aptr[0];
c0013e4c:	fec42783          	lw	a5,-20(s0)
c0013e50:	0007c783          	lbu	a5,0(a5)
c0013e54:	fef42423          	sw	a5,-24(s0)
	MacAddr |= Aptr[1] << 8;
c0013e58:	fec42783          	lw	a5,-20(s0)
c0013e5c:	00178793          	addi	a5,a5,1
c0013e60:	0007c783          	lbu	a5,0(a5)
c0013e64:	00879793          	slli	a5,a5,0x8
c0013e68:	00078713          	mv	a4,a5
c0013e6c:	fe842783          	lw	a5,-24(s0)
c0013e70:	00e7e7b3          	or	a5,a5,a4
c0013e74:	fef42423          	sw	a5,-24(s0)
	MacAddr |= Aptr[2] << 16;
c0013e78:	fec42783          	lw	a5,-20(s0)
c0013e7c:	00278793          	addi	a5,a5,2
c0013e80:	0007c783          	lbu	a5,0(a5)
c0013e84:	01079793          	slli	a5,a5,0x10
c0013e88:	00078713          	mv	a4,a5
c0013e8c:	fe842783          	lw	a5,-24(s0)
c0013e90:	00e7e7b3          	or	a5,a5,a4
c0013e94:	fef42423          	sw	a5,-24(s0)
	MacAddr |= Aptr[3] << 24;
c0013e98:	fec42783          	lw	a5,-20(s0)
c0013e9c:	00378793          	addi	a5,a5,3
c0013ea0:	0007c783          	lbu	a5,0(a5)
c0013ea4:	01879793          	slli	a5,a5,0x18
c0013ea8:	00078713          	mv	a4,a5
c0013eac:	fe842783          	lw	a5,-24(s0)
c0013eb0:	00e7e7b3          	or	a5,a5,a4
c0013eb4:	fef42423          	sw	a5,-24(s0)
	XAxiEthernet_WriteReg(InstancePtr->Config.BaseAddress,
c0013eb8:	fdc42783          	lw	a5,-36(s0)
c0013ebc:	0047a783          	lw	a5,4(a5)
c0013ec0:	40078793          	addi	a5,a5,1024
c0013ec4:	fe842583          	lw	a1,-24(s0)
c0013ec8:	00078513          	mv	a0,a5
c0013ecc:	f60ff0ef          	jal	ra,c001362c <Xil_Out32>
						XAE_RCW0_OFFSET, MacAddr);

	/* RCW1 contains other info that must be preserved */
	MacAddr = XAxiEthernet_ReadReg(InstancePtr->Config.BaseAddress,
c0013ed0:	fdc42783          	lw	a5,-36(s0)
c0013ed4:	0047a783          	lw	a5,4(a5)
c0013ed8:	40478793          	addi	a5,a5,1028
c0013edc:	00078513          	mv	a0,a5
c0013ee0:	f24ff0ef          	jal	ra,c0013604 <Xil_In32>
c0013ee4:	fea42423          	sw	a0,-24(s0)
							XAE_RCW1_OFFSET);
	MacAddr &= ~XAE_RCW1_PAUSEADDR_MASK;
c0013ee8:	fe842703          	lw	a4,-24(s0)
c0013eec:	ffff07b7          	lui	a5,0xffff0
c0013ef0:	00f777b3          	and	a5,a4,a5
c0013ef4:	fef42423          	sw	a5,-24(s0)

	/* Set MAC bits [47:32] */
	MacAddr |= Aptr[4];
c0013ef8:	fec42783          	lw	a5,-20(s0)
c0013efc:	00478793          	addi	a5,a5,4 # ffff0004 <_end+0x37f6b784>
c0013f00:	0007c783          	lbu	a5,0(a5)
c0013f04:	00078713          	mv	a4,a5
c0013f08:	fe842783          	lw	a5,-24(s0)
c0013f0c:	00e7e7b3          	or	a5,a5,a4
c0013f10:	fef42423          	sw	a5,-24(s0)
	MacAddr |= Aptr[5] << 8;
c0013f14:	fec42783          	lw	a5,-20(s0)
c0013f18:	00578793          	addi	a5,a5,5
c0013f1c:	0007c783          	lbu	a5,0(a5)
c0013f20:	00879793          	slli	a5,a5,0x8
c0013f24:	00078713          	mv	a4,a5
c0013f28:	fe842783          	lw	a5,-24(s0)
c0013f2c:	00e7e7b3          	or	a5,a5,a4
c0013f30:	fef42423          	sw	a5,-24(s0)
	XAxiEthernet_WriteReg(InstancePtr->Config.BaseAddress,
c0013f34:	fdc42783          	lw	a5,-36(s0)
c0013f38:	0047a783          	lw	a5,4(a5)
c0013f3c:	40478793          	addi	a5,a5,1028
c0013f40:	fe842583          	lw	a1,-24(s0)
c0013f44:	00078513          	mv	a0,a5
c0013f48:	ee4ff0ef          	jal	ra,c001362c <Xil_Out32>
						XAE_RCW1_OFFSET, MacAddr);

	printf(
c0013f4c:	07fed517          	auipc	a0,0x7fed
c0013f50:	06450513          	addi	a0,a0,100 # c8000fb0 <__rodata_start+0xfb0>
c0013f54:	76d090ef          	jal	ra,c001dec0 <puts>
		   "XAxiEthernet_SetMacPauseAddress: returning SUCCESS\r\n");

	return (XST_SUCCESS);
c0013f58:	00000793          	li	a5,0
}
c0013f5c:	00078513          	mv	a0,a5
c0013f60:	02c12083          	lw	ra,44(sp)
c0013f64:	02812403          	lw	s0,40(sp)
c0013f68:	03010113          	addi	sp,sp,48
c0013f6c:	00008067          	ret

c0013f70 <XAxiEthernet_GetMacPauseAddress>:
* @note		None.
*
******************************************************************************/
void XAxiEthernet_GetMacPauseAddress(XAxiEthernet *InstancePtr,
							void *AddressPtr)
{
c0013f70:	fd010113          	addi	sp,sp,-48
c0013f74:	02112623          	sw	ra,44(sp)
c0013f78:	02812423          	sw	s0,40(sp)
c0013f7c:	03010413          	addi	s0,sp,48
c0013f80:	fca42e23          	sw	a0,-36(s0)
c0013f84:	fcb42c23          	sw	a1,-40(s0)
	u32 MacAddr;

	Xil_AssertVoid(InstancePtr != NULL);
c0013f88:	fdc42783          	lw	a5,-36(s0)
c0013f8c:	02078463          	beqz	a5,c0013fb4 <XAxiEthernet_GetMacPauseAddress+0x44>
c0013f90:	07fef797          	auipc	a5,0x7fef
c0013f94:	98478793          	addi	a5,a5,-1660 # c8002914 <Xil_AssertStatus>
c0013f98:	0007a023          	sw	zero,0(a5)
	Xil_AssertVoid(InstancePtr->IsReady == XIL_COMPONENT_IS_READY);
c0013f9c:	fdc42783          	lw	a5,-36(s0)
c0013fa0:	0507a703          	lw	a4,80(a5)
c0013fa4:	111117b7          	lui	a5,0x11111
c0013fa8:	11178793          	addi	a5,a5,273 # 11111111 <_DMEM_LENGTH+0x10911111>
c0013fac:	04f71263          	bne	a4,a5,c0013ff0 <XAxiEthernet_GetMacPauseAddress+0x80>
c0013fb0:	0280006f          	j	c0013fd8 <XAxiEthernet_GetMacPauseAddress+0x68>
	Xil_AssertVoid(InstancePtr != NULL);
c0013fb4:	18800593          	li	a1,392
c0013fb8:	07fed517          	auipc	a0,0x7fed
c0013fbc:	e2c50513          	addi	a0,a0,-468 # c8000de4 <__rodata_start+0xde4>
c0013fc0:	2fd090ef          	jal	ra,c001dabc <Xil_Assert>
c0013fc4:	07fef797          	auipc	a5,0x7fef
c0013fc8:	95078793          	addi	a5,a5,-1712 # c8002914 <Xil_AssertStatus>
c0013fcc:	00100713          	li	a4,1
c0013fd0:	00e7a023          	sw	a4,0(a5)
c0013fd4:	1480006f          	j	c001411c <XAxiEthernet_GetMacPauseAddress+0x1ac>
	Xil_AssertVoid(InstancePtr->IsReady == XIL_COMPONENT_IS_READY);
c0013fd8:	07fef797          	auipc	a5,0x7fef
c0013fdc:	93c78793          	addi	a5,a5,-1732 # c8002914 <Xil_AssertStatus>
c0013fe0:	0007a023          	sw	zero,0(a5)
	Xil_AssertVoid(AddressPtr != NULL);
c0013fe4:	fd842783          	lw	a5,-40(s0)
c0013fe8:	10078863          	beqz	a5,c00140f8 <XAxiEthernet_GetMacPauseAddress+0x188>
c0013fec:	0280006f          	j	c0014014 <XAxiEthernet_GetMacPauseAddress+0xa4>
	Xil_AssertVoid(InstancePtr->IsReady == XIL_COMPONENT_IS_READY);
c0013ff0:	18900593          	li	a1,393
c0013ff4:	07fed517          	auipc	a0,0x7fed
c0013ff8:	df050513          	addi	a0,a0,-528 # c8000de4 <__rodata_start+0xde4>
c0013ffc:	2c1090ef          	jal	ra,c001dabc <Xil_Assert>
c0014000:	07fef797          	auipc	a5,0x7fef
c0014004:	91478793          	addi	a5,a5,-1772 # c8002914 <Xil_AssertStatus>
c0014008:	00100713          	li	a4,1
c001400c:	00e7a023          	sw	a4,0(a5)
c0014010:	10c0006f          	j	c001411c <XAxiEthernet_GetMacPauseAddress+0x1ac>
	Xil_AssertVoid(AddressPtr != NULL);
c0014014:	07fef797          	auipc	a5,0x7fef
c0014018:	90078793          	addi	a5,a5,-1792 # c8002914 <Xil_AssertStatus>
c001401c:	0007a023          	sw	zero,0(a5)


	u8 *Aptr = (u8 *) AddressPtr;
c0014020:	fd842783          	lw	a5,-40(s0)
c0014024:	fef42623          	sw	a5,-20(s0)
	printf("XAxiEthernet_SetMacPauseAddress\r\n");
c0014028:	07fed517          	auipc	a0,0x7fed
c001402c:	f2450513          	addi	a0,a0,-220 # c8000f4c <__rodata_start+0xf4c>
c0014030:	691090ef          	jal	ra,c001dec0 <puts>

	/* Read MAC bits [31:0] in ERXC0 */
	MacAddr = XAxiEthernet_ReadReg(InstancePtr->Config.BaseAddress,
c0014034:	fdc42783          	lw	a5,-36(s0)
c0014038:	0047a783          	lw	a5,4(a5)
c001403c:	40078793          	addi	a5,a5,1024
c0014040:	00078513          	mv	a0,a5
c0014044:	dc0ff0ef          	jal	ra,c0013604 <Xil_In32>
c0014048:	fea42423          	sw	a0,-24(s0)
							XAE_RCW0_OFFSET);
	Aptr[0] = (u8) MacAddr;
c001404c:	fe842783          	lw	a5,-24(s0)
c0014050:	0ff7f713          	andi	a4,a5,255
c0014054:	fec42783          	lw	a5,-20(s0)
c0014058:	00e78023          	sb	a4,0(a5)
	Aptr[1] = (u8) (MacAddr >> 8);
c001405c:	fe842783          	lw	a5,-24(s0)
c0014060:	0087d713          	srli	a4,a5,0x8
c0014064:	fec42783          	lw	a5,-20(s0)
c0014068:	00178793          	addi	a5,a5,1
c001406c:	0ff77713          	andi	a4,a4,255
c0014070:	00e78023          	sb	a4,0(a5)
	Aptr[2] = (u8) (MacAddr >> 16);
c0014074:	fe842783          	lw	a5,-24(s0)
c0014078:	0107d713          	srli	a4,a5,0x10
c001407c:	fec42783          	lw	a5,-20(s0)
c0014080:	00278793          	addi	a5,a5,2
c0014084:	0ff77713          	andi	a4,a4,255
c0014088:	00e78023          	sb	a4,0(a5)
	Aptr[3] = (u8) (MacAddr >> 24);
c001408c:	fe842783          	lw	a5,-24(s0)
c0014090:	0187d713          	srli	a4,a5,0x18
c0014094:	fec42783          	lw	a5,-20(s0)
c0014098:	00378793          	addi	a5,a5,3
c001409c:	0ff77713          	andi	a4,a4,255
c00140a0:	00e78023          	sb	a4,0(a5)

	/* Read MAC bits [47:32] in RCW1 */
	MacAddr = XAxiEthernet_ReadReg(InstancePtr->Config.BaseAddress,
c00140a4:	fdc42783          	lw	a5,-36(s0)
c00140a8:	0047a783          	lw	a5,4(a5)
c00140ac:	40478793          	addi	a5,a5,1028
c00140b0:	00078513          	mv	a0,a5
c00140b4:	d50ff0ef          	jal	ra,c0013604 <Xil_In32>
c00140b8:	fea42423          	sw	a0,-24(s0)
							XAE_RCW1_OFFSET);
	Aptr[4] = (u8) MacAddr;
c00140bc:	fec42783          	lw	a5,-20(s0)
c00140c0:	00478793          	addi	a5,a5,4
c00140c4:	fe842703          	lw	a4,-24(s0)
c00140c8:	0ff77713          	andi	a4,a4,255
c00140cc:	00e78023          	sb	a4,0(a5)
	Aptr[5] = (u8) (MacAddr >> 8);
c00140d0:	fe842783          	lw	a5,-24(s0)
c00140d4:	0087d713          	srli	a4,a5,0x8
c00140d8:	fec42783          	lw	a5,-20(s0)
c00140dc:	00578793          	addi	a5,a5,5
c00140e0:	0ff77713          	andi	a4,a4,255
c00140e4:	00e78023          	sb	a4,0(a5)

	printf(
c00140e8:	07fed517          	auipc	a0,0x7fed
c00140ec:	efc50513          	addi	a0,a0,-260 # c8000fe4 <__rodata_start+0xfe4>
c00140f0:	5d1090ef          	jal	ra,c001dec0 <puts>
c00140f4:	0280006f          	j	c001411c <XAxiEthernet_GetMacPauseAddress+0x1ac>
	Xil_AssertVoid(AddressPtr != NULL);
c00140f8:	18a00593          	li	a1,394
c00140fc:	07fed517          	auipc	a0,0x7fed
c0014100:	ce850513          	addi	a0,a0,-792 # c8000de4 <__rodata_start+0xde4>
c0014104:	1b9090ef          	jal	ra,c001dabc <Xil_Assert>
c0014108:	07fef797          	auipc	a5,0x7fef
c001410c:	80c78793          	addi	a5,a5,-2036 # c8002914 <Xil_AssertStatus>
c0014110:	00100713          	li	a4,1
c0014114:	00e7a023          	sw	a4,0(a5)
c0014118:	00000013          	nop
				"XAxiEthernet_SetMacPauseAddress: done\r\n");
}
c001411c:	02c12083          	lw	ra,44(sp)
c0014120:	02812403          	lw	s0,40(sp)
c0014124:	03010113          	addi	sp,sp,48
c0014128:	00008067          	ret

c001412c <XAxiEthernet_SendPausePacket>:
*
* @note		None.
*
******************************************************************************/
int XAxiEthernet_SendPausePacket(XAxiEthernet *InstancePtr, u16 PauseValue)
{
c001412c:	fe010113          	addi	sp,sp,-32
c0014130:	00112e23          	sw	ra,28(sp)
c0014134:	00812c23          	sw	s0,24(sp)
c0014138:	02010413          	addi	s0,sp,32
c001413c:	fea42623          	sw	a0,-20(s0)
c0014140:	00058793          	mv	a5,a1
c0014144:	fef41523          	sh	a5,-22(s0)
	Xil_AssertNonvoid(InstancePtr != NULL);
c0014148:	fec42783          	lw	a5,-20(s0)
c001414c:	02078463          	beqz	a5,c0014174 <XAxiEthernet_SendPausePacket+0x48>
c0014150:	07fee797          	auipc	a5,0x7fee
c0014154:	7c478793          	addi	a5,a5,1988 # c8002914 <Xil_AssertStatus>
c0014158:	0007a023          	sw	zero,0(a5)
	Xil_AssertNonvoid(InstancePtr->IsReady == XIL_COMPONENT_IS_READY);
c001415c:	fec42783          	lw	a5,-20(s0)
c0014160:	0507a703          	lw	a4,80(a5)
c0014164:	111117b7          	lui	a5,0x11111
c0014168:	11178793          	addi	a5,a5,273 # 11111111 <_DMEM_LENGTH+0x10911111>
c001416c:	06f71063          	bne	a4,a5,c00141cc <XAxiEthernet_SendPausePacket+0xa0>
c0014170:	02c0006f          	j	c001419c <XAxiEthernet_SendPausePacket+0x70>
	Xil_AssertNonvoid(InstancePtr != NULL);
c0014174:	1b500593          	li	a1,437
c0014178:	07fed517          	auipc	a0,0x7fed
c001417c:	c6c50513          	addi	a0,a0,-916 # c8000de4 <__rodata_start+0xde4>
c0014180:	13d090ef          	jal	ra,c001dabc <Xil_Assert>
c0014184:	07fee797          	auipc	a5,0x7fee
c0014188:	79078793          	addi	a5,a5,1936 # c8002914 <Xil_AssertStatus>
c001418c:	00100713          	li	a4,1
c0014190:	00e7a023          	sw	a4,0(a5)
c0014194:	00000793          	li	a5,0
c0014198:	09c0006f          	j	c0014234 <XAxiEthernet_SendPausePacket+0x108>
	Xil_AssertNonvoid(InstancePtr->IsReady == XIL_COMPONENT_IS_READY);
c001419c:	07fee797          	auipc	a5,0x7fee
c00141a0:	77878793          	addi	a5,a5,1912 # c8002914 <Xil_AssertStatus>
c00141a4:	0007a023          	sw	zero,0(a5)


	printf("XAxiEthernet_SetMacPauseAddress\r\n");
c00141a8:	07fed517          	auipc	a0,0x7fed
c00141ac:	da450513          	addi	a0,a0,-604 # c8000f4c <__rodata_start+0xf4c>
c00141b0:	511090ef          	jal	ra,c001dec0 <puts>

	/* Make sure device is ready for this operation */
	if (InstancePtr->IsStarted != XIL_COMPONENT_IS_STARTED) {
c00141b4:	fec42783          	lw	a5,-20(s0)
c00141b8:	04c7a703          	lw	a4,76(a5)
c00141bc:	222227b7          	lui	a5,0x22222
c00141c0:	22278793          	addi	a5,a5,546 # 22222222 <_DMEM_LENGTH+0x21a22222>
c00141c4:	04f70263          	beq	a4,a5,c0014208 <XAxiEthernet_SendPausePacket+0xdc>
c00141c8:	02c0006f          	j	c00141f4 <XAxiEthernet_SendPausePacket+0xc8>
	Xil_AssertNonvoid(InstancePtr->IsReady == XIL_COMPONENT_IS_READY);
c00141cc:	1b600593          	li	a1,438
c00141d0:	07fed517          	auipc	a0,0x7fed
c00141d4:	c1450513          	addi	a0,a0,-1004 # c8000de4 <__rodata_start+0xde4>
c00141d8:	0e5090ef          	jal	ra,c001dabc <Xil_Assert>
c00141dc:	07fee797          	auipc	a5,0x7fee
c00141e0:	73878793          	addi	a5,a5,1848 # c8002914 <Xil_AssertStatus>
c00141e4:	00100713          	li	a4,1
c00141e8:	00e7a023          	sw	a4,0(a5)
c00141ec:	00000793          	li	a5,0
c00141f0:	0440006f          	j	c0014234 <XAxiEthernet_SendPausePacket+0x108>
		printf(
c00141f4:	07fed517          	auipc	a0,0x7fed
c00141f8:	e1850513          	addi	a0,a0,-488 # c800100c <__rodata_start+0x100c>
c00141fc:	4c5090ef          	jal	ra,c001dec0 <puts>
		"XAxiEthernet_SendPausePacket:returning DEVICE_IS_STOPPED\r\n");
		return (XST_DEVICE_IS_STOPPED);
c0014200:	00600793          	li	a5,6
c0014204:	0300006f          	j	c0014234 <XAxiEthernet_SendPausePacket+0x108>
	}

	/* Send flow control frame */
	XAxiEthernet_WriteReg(InstancePtr->Config.BaseAddress, XAE_TPF_OFFSET,
c0014208:	fec42783          	lw	a5,-20(s0)
c001420c:	0047a783          	lw	a5,4(a5)
c0014210:	00478793          	addi	a5,a5,4
c0014214:	fea45703          	lhu	a4,-22(s0)
c0014218:	00070593          	mv	a1,a4
c001421c:	00078513          	mv	a0,a5
c0014220:	c0cff0ef          	jal	ra,c001362c <Xil_Out32>
				 (u32) PauseValue & XAE_TPF_TPFV_MASK);

	printf(
c0014224:	07fed517          	auipc	a0,0x7fed
c0014228:	e2450513          	addi	a0,a0,-476 # c8001048 <__rodata_start+0x1048>
c001422c:	495090ef          	jal	ra,c001dec0 <puts>
		   "XAxiEthernet_SendPausePacket: returning SUCCESS\r\n");
	return (XST_SUCCESS);
c0014230:	00000793          	li	a5,0
}
c0014234:	00078513          	mv	a0,a5
c0014238:	01c12083          	lw	ra,28(sp)
c001423c:	01812403          	lw	s0,24(sp)
c0014240:	02010113          	addi	sp,sp,32
c0014244:	00008067          	ret

c0014248 <XAxiEthernet_GetSgmiiStatus>:
*
* @note		Currently SGMII PHY does not support half duplex mode.
*
******************************************************************************/
int XAxiEthernet_GetSgmiiStatus(XAxiEthernet *InstancePtr, u16 *SpeedPtr)
{
c0014248:	fd010113          	addi	sp,sp,-48
c001424c:	02112623          	sw	ra,44(sp)
c0014250:	02812423          	sw	s0,40(sp)
c0014254:	03010413          	addi	s0,sp,48
c0014258:	fca42e23          	sw	a0,-36(s0)
c001425c:	fcb42c23          	sw	a1,-40(s0)
	int PhyType;
	u32 EgmicReg;

	Xil_AssertNonvoid(InstancePtr != NULL);
c0014260:	fdc42783          	lw	a5,-36(s0)
c0014264:	02078463          	beqz	a5,c001428c <XAxiEthernet_GetSgmiiStatus+0x44>
c0014268:	07fee797          	auipc	a5,0x7fee
c001426c:	6ac78793          	addi	a5,a5,1708 # c8002914 <Xil_AssertStatus>
c0014270:	0007a023          	sw	zero,0(a5)
	Xil_AssertNonvoid(InstancePtr->IsReady == XIL_COMPONENT_IS_READY);
c0014274:	fdc42783          	lw	a5,-36(s0)
c0014278:	0507a703          	lw	a4,80(a5)
c001427c:	111117b7          	lui	a5,0x11111
c0014280:	11178793          	addi	a5,a5,273 # 11111111 <_DMEM_LENGTH+0x10911111>
c0014284:	04f71463          	bne	a4,a5,c00142cc <XAxiEthernet_GetSgmiiStatus+0x84>
c0014288:	02c0006f          	j	c00142b4 <XAxiEthernet_GetSgmiiStatus+0x6c>
	Xil_AssertNonvoid(InstancePtr != NULL);
c001428c:	1e300593          	li	a1,483
c0014290:	07fed517          	auipc	a0,0x7fed
c0014294:	b5450513          	addi	a0,a0,-1196 # c8000de4 <__rodata_start+0xde4>
c0014298:	025090ef          	jal	ra,c001dabc <Xil_Assert>
c001429c:	07fee797          	auipc	a5,0x7fee
c00142a0:	67878793          	addi	a5,a5,1656 # c8002914 <Xil_AssertStatus>
c00142a4:	00100713          	li	a4,1
c00142a8:	00e7a023          	sw	a4,0(a5)
c00142ac:	00000793          	li	a5,0
c00142b0:	1280006f          	j	c00143d8 <XAxiEthernet_GetSgmiiStatus+0x190>
	Xil_AssertNonvoid(InstancePtr->IsReady == XIL_COMPONENT_IS_READY);
c00142b4:	07fee797          	auipc	a5,0x7fee
c00142b8:	66078793          	addi	a5,a5,1632 # c8002914 <Xil_AssertStatus>
c00142bc:	0007a023          	sw	zero,0(a5)
	Xil_AssertNonvoid(SpeedPtr != NULL);
c00142c0:	fd842783          	lw	a5,-40(s0)
c00142c4:	04078c63          	beqz	a5,c001431c <XAxiEthernet_GetSgmiiStatus+0xd4>
c00142c8:	02c0006f          	j	c00142f4 <XAxiEthernet_GetSgmiiStatus+0xac>
	Xil_AssertNonvoid(InstancePtr->IsReady == XIL_COMPONENT_IS_READY);
c00142cc:	1e400593          	li	a1,484
c00142d0:	07fed517          	auipc	a0,0x7fed
c00142d4:	b1450513          	addi	a0,a0,-1260 # c8000de4 <__rodata_start+0xde4>
c00142d8:	7e4090ef          	jal	ra,c001dabc <Xil_Assert>
c00142dc:	07fee797          	auipc	a5,0x7fee
c00142e0:	63878793          	addi	a5,a5,1592 # c8002914 <Xil_AssertStatus>
c00142e4:	00100713          	li	a4,1
c00142e8:	00e7a023          	sw	a4,0(a5)
c00142ec:	00000793          	li	a5,0
c00142f0:	0e80006f          	j	c00143d8 <XAxiEthernet_GetSgmiiStatus+0x190>
	Xil_AssertNonvoid(SpeedPtr != NULL);
c00142f4:	07fee797          	auipc	a5,0x7fee
c00142f8:	62078793          	addi	a5,a5,1568 # c8002914 <Xil_AssertStatus>
c00142fc:	0007a023          	sw	zero,0(a5)

	xaxi_debug_printf("XAxiEthernet_GetSgmiiStatus\r\n");

	/* Make sure PHY is SGMII */
	PhyType = XAxiEthernet_GetPhysicalInterface(InstancePtr);
c0014300:	fdc42783          	lw	a5,-36(s0)
c0014304:	00b7c783          	lbu	a5,11(a5)
c0014308:	fef42623          	sw	a5,-20(s0)
	if (PhyType != XAE_PHY_TYPE_SGMII) {
c001430c:	fec42703          	lw	a4,-20(s0)
c0014310:	00400793          	li	a5,4
c0014314:	04f70263          	beq	a4,a5,c0014358 <XAxiEthernet_GetSgmiiStatus+0x110>
c0014318:	02c0006f          	j	c0014344 <XAxiEthernet_GetSgmiiStatus+0xfc>
	Xil_AssertNonvoid(SpeedPtr != NULL);
c001431c:	1e500593          	li	a1,485
c0014320:	07fed517          	auipc	a0,0x7fed
c0014324:	ac450513          	addi	a0,a0,-1340 # c8000de4 <__rodata_start+0xde4>
c0014328:	794090ef          	jal	ra,c001dabc <Xil_Assert>
c001432c:	07fee797          	auipc	a5,0x7fee
c0014330:	5e878793          	addi	a5,a5,1512 # c8002914 <Xil_AssertStatus>
c0014334:	00100713          	li	a4,1
c0014338:	00e7a023          	sw	a4,0(a5)
c001433c:	00000793          	li	a5,0
c0014340:	0980006f          	j	c00143d8 <XAxiEthernet_GetSgmiiStatus+0x190>
		printf(
c0014344:	07fed517          	auipc	a0,0x7fed
c0014348:	d3850513          	addi	a0,a0,-712 # c800107c <__rodata_start+0x107c>
c001434c:	375090ef          	jal	ra,c001dec0 <puts>
		"XAxiEthernet_GetSgmiiStatus: returning NO_FEATURE\r\n");
		return (XST_NO_FEATURE);
c0014350:	01300793          	li	a5,19
c0014354:	0840006f          	j	c00143d8 <XAxiEthernet_GetSgmiiStatus+0x190>
	}

	/* Get the current contents of RGMII/SGMII config register */
	EgmicReg = XAxiEthernet_ReadReg(InstancePtr->Config.BaseAddress,
c0014358:	fdc42783          	lw	a5,-36(s0)
c001435c:	0047a783          	lw	a5,4(a5)
c0014360:	42078793          	addi	a5,a5,1056
c0014364:	00078513          	mv	a0,a5
c0014368:	a9cff0ef          	jal	ra,c0013604 <Xil_In32>
c001436c:	fea42423          	sw	a0,-24(s0)
						XAE_PHYC_OFFSET);

	/* Extract speed */
	switch (EgmicReg & XAE_PHYC_SGMIILINKSPEED_MASK) {
c0014370:	fe842703          	lw	a4,-24(s0)
c0014374:	c00007b7          	lui	a5,0xc0000
c0014378:	00f777b3          	and	a5,a4,a5
c001437c:	80000737          	lui	a4,0x80000
c0014380:	02e78e63          	beq	a5,a4,c00143bc <XAxiEthernet_GetSgmiiStatus+0x174>
c0014384:	80000737          	lui	a4,0x80000
c0014388:	04f76263          	bltu	a4,a5,c00143cc <XAxiEthernet_GetSgmiiStatus+0x184>
c001438c:	00078863          	beqz	a5,c001439c <XAxiEthernet_GetSgmiiStatus+0x154>
c0014390:	40000737          	lui	a4,0x40000
c0014394:	00e78c63          	beq	a5,a4,c00143ac <XAxiEthernet_GetSgmiiStatus+0x164>
c0014398:	0340006f          	j	c00143cc <XAxiEthernet_GetSgmiiStatus+0x184>
	case XAE_PHYC_SGLINKSPD_10:
		*SpeedPtr = XAE_SPEED_10_MBPS;
c001439c:	fd842783          	lw	a5,-40(s0)
c00143a0:	00a00713          	li	a4,10
c00143a4:	00e79023          	sh	a4,0(a5) # c0000000 <_end+0xf7f7b780>
		break;
c00143a8:	02c0006f          	j	c00143d4 <XAxiEthernet_GetSgmiiStatus+0x18c>

	case XAE_PHYC_SGLINKSPD_100:
		*SpeedPtr = XAE_SPEED_100_MBPS;
c00143ac:	fd842783          	lw	a5,-40(s0)
c00143b0:	06400713          	li	a4,100
c00143b4:	00e79023          	sh	a4,0(a5)
		break;
c00143b8:	01c0006f          	j	c00143d4 <XAxiEthernet_GetSgmiiStatus+0x18c>

	case XAE_PHYC_SGLINKSPD_1000:
		*SpeedPtr = XAE_SPEED_1000_MBPS;
c00143bc:	fd842783          	lw	a5,-40(s0)
c00143c0:	3e800713          	li	a4,1000
c00143c4:	00e79023          	sh	a4,0(a5)
		break;
c00143c8:	00c0006f          	j	c00143d4 <XAxiEthernet_GetSgmiiStatus+0x18c>

	default:
		*SpeedPtr = 0;
c00143cc:	fd842783          	lw	a5,-40(s0)
c00143d0:	00079023          	sh	zero,0(a5)
	}

	xaxi_debug_printf(
		   "XAxiEthernet_GetSgmiiStatus: returning SUCCESS\r\n");
	return (XST_SUCCESS);
c00143d4:	00000793          	li	a5,0
}
c00143d8:	00078513          	mv	a0,a5
c00143dc:	02c12083          	lw	ra,44(sp)
c00143e0:	02812403          	lw	s0,40(sp)
c00143e4:	03010113          	addi	sp,sp,48
c00143e8:	00008067          	ret

c00143ec <XAxiEthernet_GetRgmiiStatus>:
* @note		None.
*
******************************************************************************/
int XAxiEthernet_GetRgmiiStatus(XAxiEthernet *InstancePtr, u16 *SpeedPtr,
				int *IsFullDuplexPtr, int *IsLinkUpPtr)
{
c00143ec:	fd010113          	addi	sp,sp,-48
c00143f0:	02112623          	sw	ra,44(sp)
c00143f4:	02812423          	sw	s0,40(sp)
c00143f8:	03010413          	addi	s0,sp,48
c00143fc:	fca42e23          	sw	a0,-36(s0)
c0014400:	fcb42c23          	sw	a1,-40(s0)
c0014404:	fcc42a23          	sw	a2,-44(s0)
c0014408:	fcd42823          	sw	a3,-48(s0)
	int PhyType;
	u32 EgmicReg;

	Xil_AssertNonvoid(InstancePtr != NULL);
c001440c:	fdc42783          	lw	a5,-36(s0)
c0014410:	02078463          	beqz	a5,c0014438 <XAxiEthernet_GetRgmiiStatus+0x4c>
c0014414:	07fee797          	auipc	a5,0x7fee
c0014418:	50078793          	addi	a5,a5,1280 # c8002914 <Xil_AssertStatus>
c001441c:	0007a023          	sw	zero,0(a5)
	Xil_AssertNonvoid(InstancePtr->IsReady == XIL_COMPONENT_IS_READY);
c0014420:	fdc42783          	lw	a5,-36(s0)
c0014424:	0507a703          	lw	a4,80(a5)
c0014428:	111117b7          	lui	a5,0x11111
c001442c:	11178793          	addi	a5,a5,273 # 11111111 <_DMEM_LENGTH+0x10911111>
c0014430:	04f71463          	bne	a4,a5,c0014478 <XAxiEthernet_GetRgmiiStatus+0x8c>
c0014434:	02c0006f          	j	c0014460 <XAxiEthernet_GetRgmiiStatus+0x74>
	Xil_AssertNonvoid(InstancePtr != NULL);
c0014438:	22d00593          	li	a1,557
c001443c:	07fed517          	auipc	a0,0x7fed
c0014440:	9a850513          	addi	a0,a0,-1624 # c8000de4 <__rodata_start+0xde4>
c0014444:	678090ef          	jal	ra,c001dabc <Xil_Assert>
c0014448:	07fee797          	auipc	a5,0x7fee
c001444c:	4cc78793          	addi	a5,a5,1228 # c8002914 <Xil_AssertStatus>
c0014450:	00100713          	li	a4,1
c0014454:	00e7a023          	sw	a4,0(a5)
c0014458:	00000793          	li	a5,0
c001445c:	2100006f          	j	c001466c <XAxiEthernet_GetRgmiiStatus+0x280>
	Xil_AssertNonvoid(InstancePtr->IsReady == XIL_COMPONENT_IS_READY);
c0014460:	07fee797          	auipc	a5,0x7fee
c0014464:	4b478793          	addi	a5,a5,1204 # c8002914 <Xil_AssertStatus>
c0014468:	0007a023          	sw	zero,0(a5)
	Xil_AssertNonvoid(SpeedPtr != NULL);
c001446c:	fd842783          	lw	a5,-40(s0)
c0014470:	04078463          	beqz	a5,c00144b8 <XAxiEthernet_GetRgmiiStatus+0xcc>
c0014474:	02c0006f          	j	c00144a0 <XAxiEthernet_GetRgmiiStatus+0xb4>
	Xil_AssertNonvoid(InstancePtr->IsReady == XIL_COMPONENT_IS_READY);
c0014478:	22e00593          	li	a1,558
c001447c:	07fed517          	auipc	a0,0x7fed
c0014480:	96850513          	addi	a0,a0,-1688 # c8000de4 <__rodata_start+0xde4>
c0014484:	638090ef          	jal	ra,c001dabc <Xil_Assert>
c0014488:	07fee797          	auipc	a5,0x7fee
c001448c:	48c78793          	addi	a5,a5,1164 # c8002914 <Xil_AssertStatus>
c0014490:	00100713          	li	a4,1
c0014494:	00e7a023          	sw	a4,0(a5)
c0014498:	00000793          	li	a5,0
c001449c:	1d00006f          	j	c001466c <XAxiEthernet_GetRgmiiStatus+0x280>
	Xil_AssertNonvoid(SpeedPtr != NULL);
c00144a0:	07fee797          	auipc	a5,0x7fee
c00144a4:	47478793          	addi	a5,a5,1140 # c8002914 <Xil_AssertStatus>
c00144a8:	0007a023          	sw	zero,0(a5)
	Xil_AssertNonvoid(IsFullDuplexPtr != NULL);
c00144ac:	fd442783          	lw	a5,-44(s0)
c00144b0:	04078463          	beqz	a5,c00144f8 <XAxiEthernet_GetRgmiiStatus+0x10c>
c00144b4:	02c0006f          	j	c00144e0 <XAxiEthernet_GetRgmiiStatus+0xf4>
	Xil_AssertNonvoid(SpeedPtr != NULL);
c00144b8:	22f00593          	li	a1,559
c00144bc:	07fed517          	auipc	a0,0x7fed
c00144c0:	92850513          	addi	a0,a0,-1752 # c8000de4 <__rodata_start+0xde4>
c00144c4:	5f8090ef          	jal	ra,c001dabc <Xil_Assert>
c00144c8:	07fee797          	auipc	a5,0x7fee
c00144cc:	44c78793          	addi	a5,a5,1100 # c8002914 <Xil_AssertStatus>
c00144d0:	00100713          	li	a4,1
c00144d4:	00e7a023          	sw	a4,0(a5)
c00144d8:	00000793          	li	a5,0
c00144dc:	1900006f          	j	c001466c <XAxiEthernet_GetRgmiiStatus+0x280>
	Xil_AssertNonvoid(IsFullDuplexPtr != NULL);
c00144e0:	07fee797          	auipc	a5,0x7fee
c00144e4:	43478793          	addi	a5,a5,1076 # c8002914 <Xil_AssertStatus>
c00144e8:	0007a023          	sw	zero,0(a5)
	Xil_AssertNonvoid(IsLinkUpPtr != NULL);
c00144ec:	fd042783          	lw	a5,-48(s0)
c00144f0:	06078263          	beqz	a5,c0014554 <XAxiEthernet_GetRgmiiStatus+0x168>
c00144f4:	02c0006f          	j	c0014520 <XAxiEthernet_GetRgmiiStatus+0x134>
	Xil_AssertNonvoid(IsFullDuplexPtr != NULL);
c00144f8:	23000593          	li	a1,560
c00144fc:	07fed517          	auipc	a0,0x7fed
c0014500:	8e850513          	addi	a0,a0,-1816 # c8000de4 <__rodata_start+0xde4>
c0014504:	5b8090ef          	jal	ra,c001dabc <Xil_Assert>
c0014508:	07fee797          	auipc	a5,0x7fee
c001450c:	40c78793          	addi	a5,a5,1036 # c8002914 <Xil_AssertStatus>
c0014510:	00100713          	li	a4,1
c0014514:	00e7a023          	sw	a4,0(a5)
c0014518:	00000793          	li	a5,0
c001451c:	1500006f          	j	c001466c <XAxiEthernet_GetRgmiiStatus+0x280>
	Xil_AssertNonvoid(IsLinkUpPtr != NULL);
c0014520:	07fee797          	auipc	a5,0x7fee
c0014524:	3f478793          	addi	a5,a5,1012 # c8002914 <Xil_AssertStatus>
c0014528:	0007a023          	sw	zero,0(a5)


	printf("XAxiEthernet_GetRgmiiStatus\r\n");
c001452c:	07fed517          	auipc	a0,0x7fed
c0014530:	b8450513          	addi	a0,a0,-1148 # c80010b0 <__rodata_start+0x10b0>
c0014534:	18d090ef          	jal	ra,c001dec0 <puts>

	/* Make sure PHY is RGMII */
	PhyType = XAxiEthernet_GetPhysicalInterface(InstancePtr);
c0014538:	fdc42783          	lw	a5,-36(s0)
c001453c:	00b7c783          	lbu	a5,11(a5)
c0014540:	fef42623          	sw	a5,-20(s0)
	if ((PhyType != XAE_PHY_TYPE_RGMII_1_3) &&
c0014544:	fec42703          	lw	a4,-20(s0)
c0014548:	00200793          	li	a5,2
c001454c:	04f70863          	beq	a4,a5,c001459c <XAxiEthernet_GetRgmiiStatus+0x1b0>
c0014550:	02c0006f          	j	c001457c <XAxiEthernet_GetRgmiiStatus+0x190>
	Xil_AssertNonvoid(IsLinkUpPtr != NULL);
c0014554:	23100593          	li	a1,561
c0014558:	07fed517          	auipc	a0,0x7fed
c001455c:	88c50513          	addi	a0,a0,-1908 # c8000de4 <__rodata_start+0xde4>
c0014560:	55c090ef          	jal	ra,c001dabc <Xil_Assert>
c0014564:	07fee797          	auipc	a5,0x7fee
c0014568:	3b078793          	addi	a5,a5,944 # c8002914 <Xil_AssertStatus>
c001456c:	00100713          	li	a4,1
c0014570:	00e7a023          	sw	a4,0(a5)
c0014574:	00000793          	li	a5,0
c0014578:	0f40006f          	j	c001466c <XAxiEthernet_GetRgmiiStatus+0x280>
	if ((PhyType != XAE_PHY_TYPE_RGMII_1_3) &&
c001457c:	fec42703          	lw	a4,-20(s0)
c0014580:	00300793          	li	a5,3
c0014584:	00f70c63          	beq	a4,a5,c001459c <XAxiEthernet_GetRgmiiStatus+0x1b0>
		(PhyType != XAE_PHY_TYPE_RGMII_2_0)) {
		printf(
c0014588:	07fed517          	auipc	a0,0x7fed
c001458c:	b4850513          	addi	a0,a0,-1208 # c80010d0 <__rodata_start+0x10d0>
c0014590:	131090ef          	jal	ra,c001dec0 <puts>
			"XAxiEthernet_GetRgmiiStatus: returning NO_FEATURE\r\n");
		return (XST_NO_FEATURE);
c0014594:	01300793          	li	a5,19
c0014598:	0d40006f          	j	c001466c <XAxiEthernet_GetRgmiiStatus+0x280>
	}

	/* Get the current contents of RGMII/SGMII config register */
	EgmicReg = XAxiEthernet_ReadReg(InstancePtr->Config.BaseAddress,
c001459c:	fdc42783          	lw	a5,-36(s0)
c00145a0:	0047a783          	lw	a5,4(a5)
c00145a4:	42078793          	addi	a5,a5,1056
c00145a8:	00078513          	mv	a0,a5
c00145ac:	858ff0ef          	jal	ra,c0013604 <Xil_In32>
c00145b0:	fea42423          	sw	a0,-24(s0)
						XAE_PHYC_OFFSET);

	/* Extract speed */
	switch (EgmicReg & XAE_PHYC_RGMIILINKSPEED_MASK) {
c00145b4:	fe842783          	lw	a5,-24(s0)
c00145b8:	00c7f793          	andi	a5,a5,12
c00145bc:	00800713          	li	a4,8
c00145c0:	02e78e63          	beq	a5,a4,c00145fc <XAxiEthernet_GetRgmiiStatus+0x210>
c00145c4:	00800713          	li	a4,8
c00145c8:	04f76263          	bltu	a4,a5,c001460c <XAxiEthernet_GetRgmiiStatus+0x220>
c00145cc:	00078863          	beqz	a5,c00145dc <XAxiEthernet_GetRgmiiStatus+0x1f0>
c00145d0:	00400713          	li	a4,4
c00145d4:	00e78c63          	beq	a5,a4,c00145ec <XAxiEthernet_GetRgmiiStatus+0x200>
c00145d8:	0340006f          	j	c001460c <XAxiEthernet_GetRgmiiStatus+0x220>
	case XAE_PHYC_RGLINKSPD_10:
		*SpeedPtr = XAE_SPEED_10_MBPS;
c00145dc:	fd842783          	lw	a5,-40(s0)
c00145e0:	00a00713          	li	a4,10
c00145e4:	00e79023          	sh	a4,0(a5)
		break;
c00145e8:	02c0006f          	j	c0014614 <XAxiEthernet_GetRgmiiStatus+0x228>

	case XAE_PHYC_RGLINKSPD_100:
		*SpeedPtr = XAE_SPEED_100_MBPS;
c00145ec:	fd842783          	lw	a5,-40(s0)
c00145f0:	06400713          	li	a4,100
c00145f4:	00e79023          	sh	a4,0(a5)
		break;
c00145f8:	01c0006f          	j	c0014614 <XAxiEthernet_GetRgmiiStatus+0x228>

	case XAE_PHYC_RGLINKSPD_1000:
		*SpeedPtr = XAE_SPEED_1000_MBPS;
c00145fc:	fd842783          	lw	a5,-40(s0)
c0014600:	3e800713          	li	a4,1000
c0014604:	00e79023          	sh	a4,0(a5)
		break;
c0014608:	00c0006f          	j	c0014614 <XAxiEthernet_GetRgmiiStatus+0x228>

	default:
		*SpeedPtr = 0;
c001460c:	fd842783          	lw	a5,-40(s0)
c0014610:	00079023          	sh	zero,0(a5)
	}

	/* Extract duplex and link status */
	if (EgmicReg & XAE_PHYC_RGMIIHD_MASK) {
c0014614:	fe842783          	lw	a5,-24(s0)
c0014618:	0027f793          	andi	a5,a5,2
c001461c:	00078863          	beqz	a5,c001462c <XAxiEthernet_GetRgmiiStatus+0x240>
		*IsFullDuplexPtr = FALSE;
c0014620:	fd442783          	lw	a5,-44(s0)
c0014624:	0007a023          	sw	zero,0(a5)
c0014628:	0100006f          	j	c0014638 <XAxiEthernet_GetRgmiiStatus+0x24c>
	} else {
		*IsFullDuplexPtr = TRUE;
c001462c:	fd442783          	lw	a5,-44(s0)
c0014630:	00100713          	li	a4,1
c0014634:	00e7a023          	sw	a4,0(a5)
	}

	if (EgmicReg & XAE_PHYC_RGMIILINK_MASK) {
c0014638:	fe842783          	lw	a5,-24(s0)
c001463c:	0017f793          	andi	a5,a5,1
c0014640:	00078a63          	beqz	a5,c0014654 <XAxiEthernet_GetRgmiiStatus+0x268>
		*IsLinkUpPtr = TRUE;
c0014644:	fd042783          	lw	a5,-48(s0)
c0014648:	00100713          	li	a4,1
c001464c:	00e7a023          	sw	a4,0(a5)
c0014650:	00c0006f          	j	c001465c <XAxiEthernet_GetRgmiiStatus+0x270>
	} else {
		*IsLinkUpPtr = FALSE;
c0014654:	fd042783          	lw	a5,-48(s0)
c0014658:	0007a023          	sw	zero,0(a5)
	}

	printf(
c001465c:	07fed517          	auipc	a0,0x7fed
c0014660:	aa850513          	addi	a0,a0,-1368 # c8001104 <__rodata_start+0x1104>
c0014664:	05d090ef          	jal	ra,c001dec0 <puts>
		   "XAxiEthernet_GetRgmiiStatus: returning SUCCESS\r\n");
	return (XST_SUCCESS);
c0014668:	00000793          	li	a5,0
}
c001466c:	00078513          	mv	a0,a5
c0014670:	02c12083          	lw	ra,44(sp)
c0014674:	02812403          	lw	s0,40(sp)
c0014678:	03010113          	addi	sp,sp,48
c001467c:	00008067          	ret

c0014680 <XAxiEthernet_SetTpid>:
*
* @note		The device must be stopped to use this function.
*
*****************************************************************************/
int XAxiEthernet_SetTpid(XAxiEthernet *InstancePtr, u16 Tpid, u8 Entry)
{
c0014680:	fd010113          	addi	sp,sp,-48
c0014684:	02112623          	sw	ra,44(sp)
c0014688:	02812423          	sw	s0,40(sp)
c001468c:	03010413          	addi	s0,sp,48
c0014690:	fca42e23          	sw	a0,-36(s0)
c0014694:	00058793          	mv	a5,a1
c0014698:	00060713          	mv	a4,a2
c001469c:	fcf41d23          	sh	a5,-38(s0)
c00146a0:	00070793          	mv	a5,a4
c00146a4:	fcf40ca3          	sb	a5,-39(s0)
	u32 RegTpid;
	u32 RegTpidOffset;
	Xil_AssertNonvoid(InstancePtr != NULL);
c00146a8:	fdc42783          	lw	a5,-36(s0)
c00146ac:	02078463          	beqz	a5,c00146d4 <XAxiEthernet_SetTpid+0x54>
c00146b0:	07fee797          	auipc	a5,0x7fee
c00146b4:	26478793          	addi	a5,a5,612 # c8002914 <Xil_AssertStatus>
c00146b8:	0007a023          	sw	zero,0(a5)
	Xil_AssertNonvoid(InstancePtr->IsReady == XIL_COMPONENT_IS_READY);
c00146bc:	fdc42783          	lw	a5,-36(s0)
c00146c0:	0507a703          	lw	a4,80(a5)
c00146c4:	111117b7          	lui	a5,0x11111
c00146c8:	11178793          	addi	a5,a5,273 # 11111111 <_DMEM_LENGTH+0x10911111>
c00146cc:	04f71663          	bne	a4,a5,c0014718 <XAxiEthernet_SetTpid+0x98>
c00146d0:	02c0006f          	j	c00146fc <XAxiEthernet_SetTpid+0x7c>
	Xil_AssertNonvoid(InstancePtr != NULL);
c00146d4:	28400593          	li	a1,644
c00146d8:	07fec517          	auipc	a0,0x7fec
c00146dc:	70c50513          	addi	a0,a0,1804 # c8000de4 <__rodata_start+0xde4>
c00146e0:	3dc090ef          	jal	ra,c001dabc <Xil_Assert>
c00146e4:	07fee797          	auipc	a5,0x7fee
c00146e8:	23078793          	addi	a5,a5,560 # c8002914 <Xil_AssertStatus>
c00146ec:	00100713          	li	a4,1
c00146f0:	00e7a023          	sw	a4,0(a5)
c00146f4:	00000793          	li	a5,0
c00146f8:	20c0006f          	j	c0014904 <XAxiEthernet_SetTpid+0x284>
	Xil_AssertNonvoid(InstancePtr->IsReady == XIL_COMPONENT_IS_READY);
c00146fc:	07fee797          	auipc	a5,0x7fee
c0014700:	21878793          	addi	a5,a5,536 # c8002914 <Xil_AssertStatus>
c0014704:	0007a023          	sw	zero,0(a5)
	Xil_AssertNonvoid(Entry < XAE_TPID_MAX_ENTRIES);
c0014708:	fd944703          	lbu	a4,-39(s0)
c001470c:	00300793          	li	a5,3
c0014710:	04e7ea63          	bltu	a5,a4,c0014764 <XAxiEthernet_SetTpid+0xe4>
c0014714:	02c0006f          	j	c0014740 <XAxiEthernet_SetTpid+0xc0>
	Xil_AssertNonvoid(InstancePtr->IsReady == XIL_COMPONENT_IS_READY);
c0014718:	28500593          	li	a1,645
c001471c:	07fec517          	auipc	a0,0x7fec
c0014720:	6c850513          	addi	a0,a0,1736 # c8000de4 <__rodata_start+0xde4>
c0014724:	398090ef          	jal	ra,c001dabc <Xil_Assert>
c0014728:	07fee797          	auipc	a5,0x7fee
c001472c:	1ec78793          	addi	a5,a5,492 # c8002914 <Xil_AssertStatus>
c0014730:	00100713          	li	a4,1
c0014734:	00e7a023          	sw	a4,0(a5)
c0014738:	00000793          	li	a5,0
c001473c:	1c80006f          	j	c0014904 <XAxiEthernet_SetTpid+0x284>
	Xil_AssertNonvoid(Entry < XAE_TPID_MAX_ENTRIES);
c0014740:	07fee797          	auipc	a5,0x7fee
c0014744:	1d478793          	addi	a5,a5,468 # c8002914 <Xil_AssertStatus>
c0014748:	0007a023          	sw	zero,0(a5)

	/* The device must be stopped before modify VLAN TPID */
	if (InstancePtr->IsStarted == XIL_COMPONENT_IS_STARTED) {
c001474c:	fdc42783          	lw	a5,-36(s0)
c0014750:	04c7a703          	lw	a4,76(a5)
c0014754:	222227b7          	lui	a5,0x22222
c0014758:	22278793          	addi	a5,a5,546 # 22222222 <_DMEM_LENGTH+0x21a22222>
c001475c:	04f71263          	bne	a4,a5,c00147a0 <XAxiEthernet_SetTpid+0x120>
c0014760:	02c0006f          	j	c001478c <XAxiEthernet_SetTpid+0x10c>
	Xil_AssertNonvoid(Entry < XAE_TPID_MAX_ENTRIES);
c0014764:	28600593          	li	a1,646
c0014768:	07fec517          	auipc	a0,0x7fec
c001476c:	67c50513          	addi	a0,a0,1660 # c8000de4 <__rodata_start+0xde4>
c0014770:	34c090ef          	jal	ra,c001dabc <Xil_Assert>
c0014774:	07fee797          	auipc	a5,0x7fee
c0014778:	1a078793          	addi	a5,a5,416 # c8002914 <Xil_AssertStatus>
c001477c:	00100713          	li	a4,1
c0014780:	00e7a023          	sw	a4,0(a5)
c0014784:	00000793          	li	a5,0
c0014788:	17c0006f          	j	c0014904 <XAxiEthernet_SetTpid+0x284>
		printf(
c001478c:	07fed517          	auipc	a0,0x7fed
c0014790:	9a850513          	addi	a0,a0,-1624 # c8001134 <__rodata_start+0x1134>
c0014794:	72c090ef          	jal	ra,c001dec0 <puts>
		"XAxiEthernet_SetTpid: returning DEVICE_IS_STARTED\r\n");
		return (XST_DEVICE_IS_STARTED);
c0014798:	00500793          	li	a5,5
c001479c:	1680006f          	j	c0014904 <XAxiEthernet_SetTpid+0x284>
	}

	/* Check hw capability */
	if (!XAxiEthernet_IsExtFuncCap(InstancePtr)) {
c00147a0:	fdc42783          	lw	a5,-36(s0)
c00147a4:	0047a783          	lw	a5,4(a5)
c00147a8:	00078513          	mv	a0,a5
c00147ac:	e59fe0ef          	jal	ra,c0013604 <Xil_In32>
c00147b0:	00050713          	mv	a4,a0
c00147b4:	000017b7          	lui	a5,0x1
c00147b8:	80078793          	addi	a5,a5,-2048 # 800 <_STACK_SIZE-0x800>
c00147bc:	00f777b3          	and	a5,a4,a5
c00147c0:	00079c63          	bnez	a5,c00147d8 <XAxiEthernet_SetTpid+0x158>
		printf(
c00147c4:	07fed517          	auipc	a0,0x7fed
c00147c8:	9a450513          	addi	a0,a0,-1628 # c8001168 <__rodata_start+0x1168>
c00147cc:	6f4090ef          	jal	ra,c001dec0 <puts>
		"XAxiEthernet_SetTpid: returning DEVICE_NO_FEATURE\r\n");
		return (XST_NO_FEATURE);
c00147d0:	01300793          	li	a5,19
c00147d4:	1300006f          	j	c0014904 <XAxiEthernet_SetTpid+0x284>
	}

	printf("XAxiEthernet_SetTpid\r\n");
c00147d8:	07fed517          	auipc	a0,0x7fed
c00147dc:	9c450513          	addi	a0,a0,-1596 # c800119c <__rodata_start+0x119c>
c00147e0:	6e0090ef          	jal	ra,c001dec0 <puts>

	/* Verify TPID */
	switch (Tpid) {
c00147e4:	fda45783          	lhu	a5,-38(s0)
c00147e8:	00009737          	lui	a4,0x9
c00147ec:	20070713          	addi	a4,a4,512 # 9200 <_STACK_SIZE+0x8200>
c00147f0:	04e78463          	beq	a5,a4,c0014838 <XAxiEthernet_SetTpid+0x1b8>
c00147f4:	00009737          	lui	a4,0x9
c00147f8:	20070713          	addi	a4,a4,512 # 9200 <_STACK_SIZE+0x8200>
c00147fc:	02f74a63          	blt	a4,a5,c0014830 <XAxiEthernet_SetTpid+0x1b0>
c0014800:	00009737          	lui	a4,0x9
c0014804:	10070713          	addi	a4,a4,256 # 9100 <_STACK_SIZE+0x8100>
c0014808:	02e78863          	beq	a5,a4,c0014838 <XAxiEthernet_SetTpid+0x1b8>
c001480c:	00009737          	lui	a4,0x9
c0014810:	10070713          	addi	a4,a4,256 # 9100 <_STACK_SIZE+0x8100>
c0014814:	00f74e63          	blt	a4,a5,c0014830 <XAxiEthernet_SetTpid+0x1b0>
c0014818:	00008737          	lui	a4,0x8
c001481c:	10070713          	addi	a4,a4,256 # 8100 <_STACK_SIZE+0x7100>
c0014820:	00e78c63          	beq	a5,a4,c0014838 <XAxiEthernet_SetTpid+0x1b8>
c0014824:	00009737          	lui	a4,0x9
c0014828:	8a870713          	addi	a4,a4,-1880 # 88a8 <_STACK_SIZE+0x78a8>
c001482c:	00e78663          	beq	a5,a4,c0014838 <XAxiEthernet_SetTpid+0x1b8>
		case 0x88a8:
		case 0x9100:
		case 0x9200:
			break;
		default:
			return (XST_INVALID_PARAM);
c0014830:	00f00793          	li	a5,15
c0014834:	0d00006f          	j	c0014904 <XAxiEthernet_SetTpid+0x284>
			break;
c0014838:	00000013          	nop
	}

	/* Determine which register to operate on */
	if (Entry < 2) {
c001483c:	fd944703          	lbu	a4,-39(s0)
c0014840:	00100793          	li	a5,1
c0014844:	00e7e863          	bltu	a5,a4,c0014854 <XAxiEthernet_SetTpid+0x1d4>
		RegTpidOffset = XAE_TPID0_OFFSET;
c0014848:	02800793          	li	a5,40
c001484c:	fef42623          	sw	a5,-20(s0)
c0014850:	00c0006f          	j	c001485c <XAxiEthernet_SetTpid+0x1dc>
	} else {
		RegTpidOffset = XAE_TPID1_OFFSET;
c0014854:	02c00793          	li	a5,44
c0014858:	fef42623          	sw	a5,-20(s0)
	}

	RegTpid = XAxiEthernet_ReadReg(InstancePtr->Config.BaseAddress,
c001485c:	fdc42783          	lw	a5,-36(s0)
c0014860:	0047a703          	lw	a4,4(a5)
c0014864:	fec42783          	lw	a5,-20(s0)
c0014868:	00f707b3          	add	a5,a4,a5
c001486c:	00078513          	mv	a0,a5
c0014870:	d95fe0ef          	jal	ra,c0013604 <Xil_In32>
c0014874:	fea42423          	sw	a0,-24(s0)
								RegTpidOffset);

	/* Determine upper/lower 16 bits to operate on */
	if (Entry % 2) {
c0014878:	fd944783          	lbu	a5,-39(s0)
c001487c:	0017f793          	andi	a5,a5,1
c0014880:	0ff7f793          	andi	a5,a5,255
c0014884:	04078063          	beqz	a5,c00148c4 <XAxiEthernet_SetTpid+0x244>
		/* Program HW */
		XAxiEthernet_WriteReg(InstancePtr->Config.BaseAddress,
c0014888:	fdc42783          	lw	a5,-36(s0)
c001488c:	0047a703          	lw	a4,4(a5)
c0014890:	fec42783          	lw	a5,-20(s0)
c0014894:	00f706b3          	add	a3,a4,a5
c0014898:	fe842703          	lw	a4,-24(s0)
c001489c:	000107b7          	lui	a5,0x10
c00148a0:	fff78793          	addi	a5,a5,-1 # ffff <_STACK_SIZE+0xefff>
c00148a4:	00f777b3          	and	a5,a4,a5
c00148a8:	fda45703          	lhu	a4,-38(s0)
c00148ac:	01071713          	slli	a4,a4,0x10
c00148b0:	00e7e7b3          	or	a5,a5,a4
c00148b4:	00078593          	mv	a1,a5
c00148b8:	00068513          	mv	a0,a3
c00148bc:	d71fe0ef          	jal	ra,c001362c <Xil_Out32>
c00148c0:	0340006f          	j	c00148f4 <XAxiEthernet_SetTpid+0x274>
			RegTpidOffset, (RegTpid & XAE_TPID_0_MASK) |
			(Tpid << 16));
	} else {
		/* Program HW */
		XAxiEthernet_WriteReg(InstancePtr->Config.BaseAddress,
c00148c4:	fdc42783          	lw	a5,-36(s0)
c00148c8:	0047a703          	lw	a4,4(a5)
c00148cc:	fec42783          	lw	a5,-20(s0)
c00148d0:	00f706b3          	add	a3,a4,a5
c00148d4:	fe842703          	lw	a4,-24(s0)
c00148d8:	ffff07b7          	lui	a5,0xffff0
c00148dc:	00f77733          	and	a4,a4,a5
c00148e0:	fda45783          	lhu	a5,-38(s0)
c00148e4:	00f767b3          	or	a5,a4,a5
c00148e8:	00078593          	mv	a1,a5
c00148ec:	00068513          	mv	a0,a3
c00148f0:	d3dfe0ef          	jal	ra,c001362c <Xil_Out32>
			RegTpidOffset, (RegTpid & XAE_TPID_1_MASK) |
			Tpid);
	}
	printf(
c00148f4:	07fed517          	auipc	a0,0x7fed
c00148f8:	8c050513          	addi	a0,a0,-1856 # c80011b4 <__rodata_start+0x11b4>
c00148fc:	5c4090ef          	jal	ra,c001dec0 <puts>
			"XAxiEthernet_SetTpid: returning SUCCESS\r\n");
	return (XST_SUCCESS);
c0014900:	00000793          	li	a5,0
}
c0014904:	00078513          	mv	a0,a5
c0014908:	02c12083          	lw	ra,44(sp)
c001490c:	02812403          	lw	s0,40(sp)
c0014910:	03010113          	addi	sp,sp,48
c0014914:	00008067          	ret

c0014918 <XAxiEthernet_ClearTpid>:
*
* @note		The device must be stopped to use this function.
*
*****************************************************************************/
int XAxiEthernet_ClearTpid(XAxiEthernet *InstancePtr, u8 Entry)
{
c0014918:	fd010113          	addi	sp,sp,-48
c001491c:	02112623          	sw	ra,44(sp)
c0014920:	02812423          	sw	s0,40(sp)
c0014924:	03010413          	addi	s0,sp,48
c0014928:	fca42e23          	sw	a0,-36(s0)
c001492c:	00058793          	mv	a5,a1
c0014930:	fcf40da3          	sb	a5,-37(s0)
	u32 RegTpid;
	u32 RegTpidOffset;

	Xil_AssertNonvoid(InstancePtr != NULL);
c0014934:	fdc42783          	lw	a5,-36(s0)
c0014938:	02078463          	beqz	a5,c0014960 <XAxiEthernet_ClearTpid+0x48>
c001493c:	07fee797          	auipc	a5,0x7fee
c0014940:	fd878793          	addi	a5,a5,-40 # c8002914 <Xil_AssertStatus>
c0014944:	0007a023          	sw	zero,0(a5)
	Xil_AssertNonvoid(InstancePtr->IsReady == XIL_COMPONENT_IS_READY);
c0014948:	fdc42783          	lw	a5,-36(s0)
c001494c:	0507a703          	lw	a4,80(a5)
c0014950:	111117b7          	lui	a5,0x11111
c0014954:	11178793          	addi	a5,a5,273 # 11111111 <_DMEM_LENGTH+0x10911111>
c0014958:	04f71663          	bne	a4,a5,c00149a4 <XAxiEthernet_ClearTpid+0x8c>
c001495c:	02c0006f          	j	c0014988 <XAxiEthernet_ClearTpid+0x70>
	Xil_AssertNonvoid(InstancePtr != NULL);
c0014960:	2d700593          	li	a1,727
c0014964:	07fec517          	auipc	a0,0x7fec
c0014968:	48050513          	addi	a0,a0,1152 # c8000de4 <__rodata_start+0xde4>
c001496c:	150090ef          	jal	ra,c001dabc <Xil_Assert>
c0014970:	07fee797          	auipc	a5,0x7fee
c0014974:	fa478793          	addi	a5,a5,-92 # c8002914 <Xil_AssertStatus>
c0014978:	00100713          	li	a4,1
c001497c:	00e7a023          	sw	a4,0(a5)
c0014980:	00000793          	li	a5,0
c0014984:	1a00006f          	j	c0014b24 <XAxiEthernet_ClearTpid+0x20c>
	Xil_AssertNonvoid(InstancePtr->IsReady == XIL_COMPONENT_IS_READY);
c0014988:	07fee797          	auipc	a5,0x7fee
c001498c:	f8c78793          	addi	a5,a5,-116 # c8002914 <Xil_AssertStatus>
c0014990:	0007a023          	sw	zero,0(a5)
	Xil_AssertNonvoid(Entry < XAE_TPID_MAX_ENTRIES);
c0014994:	fdb44703          	lbu	a4,-37(s0)
c0014998:	00300793          	li	a5,3
c001499c:	04e7ea63          	bltu	a5,a4,c00149f0 <XAxiEthernet_ClearTpid+0xd8>
c00149a0:	02c0006f          	j	c00149cc <XAxiEthernet_ClearTpid+0xb4>
	Xil_AssertNonvoid(InstancePtr->IsReady == XIL_COMPONENT_IS_READY);
c00149a4:	2d800593          	li	a1,728
c00149a8:	07fec517          	auipc	a0,0x7fec
c00149ac:	43c50513          	addi	a0,a0,1084 # c8000de4 <__rodata_start+0xde4>
c00149b0:	10c090ef          	jal	ra,c001dabc <Xil_Assert>
c00149b4:	07fee797          	auipc	a5,0x7fee
c00149b8:	f6078793          	addi	a5,a5,-160 # c8002914 <Xil_AssertStatus>
c00149bc:	00100713          	li	a4,1
c00149c0:	00e7a023          	sw	a4,0(a5)
c00149c4:	00000793          	li	a5,0
c00149c8:	15c0006f          	j	c0014b24 <XAxiEthernet_ClearTpid+0x20c>
	Xil_AssertNonvoid(Entry < XAE_TPID_MAX_ENTRIES);
c00149cc:	07fee797          	auipc	a5,0x7fee
c00149d0:	f4878793          	addi	a5,a5,-184 # c8002914 <Xil_AssertStatus>
c00149d4:	0007a023          	sw	zero,0(a5)

	/* The device must be stopped before modify VLAN TPID */
	if (InstancePtr->IsStarted == XIL_COMPONENT_IS_STARTED) {
c00149d8:	fdc42783          	lw	a5,-36(s0)
c00149dc:	04c7a703          	lw	a4,76(a5)
c00149e0:	222227b7          	lui	a5,0x22222
c00149e4:	22278793          	addi	a5,a5,546 # 22222222 <_DMEM_LENGTH+0x21a22222>
c00149e8:	04f71263          	bne	a4,a5,c0014a2c <XAxiEthernet_ClearTpid+0x114>
c00149ec:	02c0006f          	j	c0014a18 <XAxiEthernet_ClearTpid+0x100>
	Xil_AssertNonvoid(Entry < XAE_TPID_MAX_ENTRIES);
c00149f0:	2d900593          	li	a1,729
c00149f4:	07fec517          	auipc	a0,0x7fec
c00149f8:	3f050513          	addi	a0,a0,1008 # c8000de4 <__rodata_start+0xde4>
c00149fc:	0c0090ef          	jal	ra,c001dabc <Xil_Assert>
c0014a00:	07fee797          	auipc	a5,0x7fee
c0014a04:	f1478793          	addi	a5,a5,-236 # c8002914 <Xil_AssertStatus>
c0014a08:	00100713          	li	a4,1
c0014a0c:	00e7a023          	sw	a4,0(a5)
c0014a10:	00000793          	li	a5,0
c0014a14:	1100006f          	j	c0014b24 <XAxiEthernet_ClearTpid+0x20c>
		printf(
c0014a18:	07fec517          	auipc	a0,0x7fec
c0014a1c:	7c850513          	addi	a0,a0,1992 # c80011e0 <__rodata_start+0x11e0>
c0014a20:	4a0090ef          	jal	ra,c001dec0 <puts>
		"XAxiEthernet_ClearTpid: returning DEVICE_IS_STARTED\r\n");
		return (XST_DEVICE_IS_STARTED);
c0014a24:	00500793          	li	a5,5
c0014a28:	0fc0006f          	j	c0014b24 <XAxiEthernet_ClearTpid+0x20c>
	}

	/* Check hw capability */
	if (!XAxiEthernet_IsExtFuncCap(InstancePtr)) {
c0014a2c:	fdc42783          	lw	a5,-36(s0)
c0014a30:	0047a783          	lw	a5,4(a5)
c0014a34:	00078513          	mv	a0,a5
c0014a38:	bcdfe0ef          	jal	ra,c0013604 <Xil_In32>
c0014a3c:	00050713          	mv	a4,a0
c0014a40:	000017b7          	lui	a5,0x1
c0014a44:	80078793          	addi	a5,a5,-2048 # 800 <_STACK_SIZE-0x800>
c0014a48:	00f777b3          	and	a5,a4,a5
c0014a4c:	00079c63          	bnez	a5,c0014a64 <XAxiEthernet_ClearTpid+0x14c>
		printf(
c0014a50:	07fec517          	auipc	a0,0x7fec
c0014a54:	7c850513          	addi	a0,a0,1992 # c8001218 <__rodata_start+0x1218>
c0014a58:	468090ef          	jal	ra,c001dec0 <puts>
		"XAxiEthernet_ClearTpid: returning DEVICE_NO_FEATURE\r\n");
		return (XST_NO_FEATURE);
c0014a5c:	01300793          	li	a5,19
c0014a60:	0c40006f          	j	c0014b24 <XAxiEthernet_ClearTpid+0x20c>
	}

	printf("XAxiEthernet_ClearExtTpid\r\n");
c0014a64:	07fec517          	auipc	a0,0x7fec
c0014a68:	7ec50513          	addi	a0,a0,2028 # c8001250 <__rodata_start+0x1250>
c0014a6c:	454090ef          	jal	ra,c001dec0 <puts>

	/* Determine which register to operate on */
	if (Entry < 2) {
c0014a70:	fdb44703          	lbu	a4,-37(s0)
c0014a74:	00100793          	li	a5,1
c0014a78:	00e7e863          	bltu	a5,a4,c0014a88 <XAxiEthernet_ClearTpid+0x170>
		RegTpidOffset = XAE_TPID0_OFFSET;
c0014a7c:	02800793          	li	a5,40
c0014a80:	fef42623          	sw	a5,-20(s0)
c0014a84:	00c0006f          	j	c0014a90 <XAxiEthernet_ClearTpid+0x178>
	} else {
		RegTpidOffset = XAE_TPID1_OFFSET;
c0014a88:	02c00793          	li	a5,44
c0014a8c:	fef42623          	sw	a5,-20(s0)
	}

	RegTpid = XAxiEthernet_ReadReg(InstancePtr->Config.BaseAddress,
c0014a90:	fdc42783          	lw	a5,-36(s0)
c0014a94:	0047a703          	lw	a4,4(a5)
c0014a98:	fec42783          	lw	a5,-20(s0)
c0014a9c:	00f707b3          	add	a5,a4,a5
c0014aa0:	00078513          	mv	a0,a5
c0014aa4:	b61fe0ef          	jal	ra,c0013604 <Xil_In32>
c0014aa8:	fea42423          	sw	a0,-24(s0)
				RegTpidOffset);

	/* Determine upper/lower 16 bits to operate on */
	if (Entry % 2) {
c0014aac:	fdb44783          	lbu	a5,-37(s0)
c0014ab0:	0017f793          	andi	a5,a5,1
c0014ab4:	0ff7f793          	andi	a5,a5,255
c0014ab8:	02078863          	beqz	a5,c0014ae8 <XAxiEthernet_ClearTpid+0x1d0>
		/* Program HW */
		XAxiEthernet_WriteReg(InstancePtr->Config.BaseAddress,
c0014abc:	fdc42783          	lw	a5,-36(s0)
c0014ac0:	0047a703          	lw	a4,4(a5)
c0014ac4:	fec42783          	lw	a5,-20(s0)
c0014ac8:	00f706b3          	add	a3,a4,a5
c0014acc:	fe842703          	lw	a4,-24(s0)
c0014ad0:	ffff07b7          	lui	a5,0xffff0
c0014ad4:	00f777b3          	and	a5,a4,a5
c0014ad8:	00078593          	mv	a1,a5
c0014adc:	00068513          	mv	a0,a3
c0014ae0:	b4dfe0ef          	jal	ra,c001362c <Xil_Out32>
c0014ae4:	0300006f          	j	c0014b14 <XAxiEthernet_ClearTpid+0x1fc>
			RegTpidOffset, (RegTpid & XAE_TPID_1_MASK));
	} else {
		/* Program HW */
		XAxiEthernet_WriteReg(InstancePtr->Config.BaseAddress,
c0014ae8:	fdc42783          	lw	a5,-36(s0)
c0014aec:	0047a703          	lw	a4,4(a5) # ffff0004 <_end+0x37f6b784>
c0014af0:	fec42783          	lw	a5,-20(s0)
c0014af4:	00f706b3          	add	a3,a4,a5
c0014af8:	fe842703          	lw	a4,-24(s0)
c0014afc:	000107b7          	lui	a5,0x10
c0014b00:	fff78793          	addi	a5,a5,-1 # ffff <_STACK_SIZE+0xefff>
c0014b04:	00f777b3          	and	a5,a4,a5
c0014b08:	00078593          	mv	a1,a5
c0014b0c:	00068513          	mv	a0,a3
c0014b10:	b1dfe0ef          	jal	ra,c001362c <Xil_Out32>
			RegTpidOffset, (RegTpid & XAE_TPID_0_MASK));
	}
	printf(
c0014b14:	07fec517          	auipc	a0,0x7fec
c0014b18:	75850513          	addi	a0,a0,1880 # c800126c <__rodata_start+0x126c>
c0014b1c:	3a4090ef          	jal	ra,c001dec0 <puts>
			"XAxiEthernet_ClearTpid: returning SUCCESS\r\n");

	return (XST_SUCCESS);
c0014b20:	00000793          	li	a5,0
}
c0014b24:	00078513          	mv	a0,a5
c0014b28:	02c12083          	lw	ra,44(sp)
c0014b2c:	02812403          	lw	s0,40(sp)
c0014b30:	03010113          	addi	sp,sp,48
c0014b34:	00008067          	ret

c0014b38 <XAxiEthernet_GetTpid>:
*
* @note		None.
*
*****************************************************************************/
void XAxiEthernet_GetTpid(XAxiEthernet *InstancePtr, u16 *TpidPtr, u8 Entry)
{
c0014b38:	fd010113          	addi	sp,sp,-48
c0014b3c:	02112623          	sw	ra,44(sp)
c0014b40:	02812423          	sw	s0,40(sp)
c0014b44:	03010413          	addi	s0,sp,48
c0014b48:	fca42e23          	sw	a0,-36(s0)
c0014b4c:	fcb42c23          	sw	a1,-40(s0)
c0014b50:	00060793          	mv	a5,a2
c0014b54:	fcf40ba3          	sb	a5,-41(s0)
	u32 RegTpid;
	Xil_AssertVoid(InstancePtr != NULL);
c0014b58:	fdc42783          	lw	a5,-36(s0)
c0014b5c:	02078463          	beqz	a5,c0014b84 <XAxiEthernet_GetTpid+0x4c>
c0014b60:	07fee797          	auipc	a5,0x7fee
c0014b64:	db478793          	addi	a5,a5,-588 # c8002914 <Xil_AssertStatus>
c0014b68:	0007a023          	sw	zero,0(a5)
	Xil_AssertVoid(InstancePtr->IsReady == XIL_COMPONENT_IS_READY);
c0014b6c:	fdc42783          	lw	a5,-36(s0)
c0014b70:	0507a703          	lw	a4,80(a5)
c0014b74:	111117b7          	lui	a5,0x11111
c0014b78:	11178793          	addi	a5,a5,273 # 11111111 <_DMEM_LENGTH+0x10911111>
c0014b7c:	04f71263          	bne	a4,a5,c0014bc0 <XAxiEthernet_GetTpid+0x88>
c0014b80:	0280006f          	j	c0014ba8 <XAxiEthernet_GetTpid+0x70>
	Xil_AssertVoid(InstancePtr != NULL);
c0014b84:	31800593          	li	a1,792
c0014b88:	07fec517          	auipc	a0,0x7fec
c0014b8c:	25c50513          	addi	a0,a0,604 # c8000de4 <__rodata_start+0xde4>
c0014b90:	72d080ef          	jal	ra,c001dabc <Xil_Assert>
c0014b94:	07fee797          	auipc	a5,0x7fee
c0014b98:	d8078793          	addi	a5,a5,-640 # c8002914 <Xil_AssertStatus>
c0014b9c:	00100713          	li	a4,1
c0014ba0:	00e7a023          	sw	a4,0(a5)
c0014ba4:	14c0006f          	j	c0014cf0 <XAxiEthernet_GetTpid+0x1b8>
	Xil_AssertVoid(InstancePtr->IsReady == XIL_COMPONENT_IS_READY);
c0014ba8:	07fee797          	auipc	a5,0x7fee
c0014bac:	d6c78793          	addi	a5,a5,-660 # c8002914 <Xil_AssertStatus>
c0014bb0:	0007a023          	sw	zero,0(a5)
	Xil_AssertVoid(TpidPtr != NULL);
c0014bb4:	fd842783          	lw	a5,-40(s0)
c0014bb8:	04078463          	beqz	a5,c0014c00 <XAxiEthernet_GetTpid+0xc8>
c0014bbc:	0280006f          	j	c0014be4 <XAxiEthernet_GetTpid+0xac>
	Xil_AssertVoid(InstancePtr->IsReady == XIL_COMPONENT_IS_READY);
c0014bc0:	31900593          	li	a1,793
c0014bc4:	07fec517          	auipc	a0,0x7fec
c0014bc8:	22050513          	addi	a0,a0,544 # c8000de4 <__rodata_start+0xde4>
c0014bcc:	6f1080ef          	jal	ra,c001dabc <Xil_Assert>
c0014bd0:	07fee797          	auipc	a5,0x7fee
c0014bd4:	d4478793          	addi	a5,a5,-700 # c8002914 <Xil_AssertStatus>
c0014bd8:	00100713          	li	a4,1
c0014bdc:	00e7a023          	sw	a4,0(a5)
c0014be0:	1100006f          	j	c0014cf0 <XAxiEthernet_GetTpid+0x1b8>
	Xil_AssertVoid(TpidPtr != NULL);
c0014be4:	07fee797          	auipc	a5,0x7fee
c0014be8:	d3078793          	addi	a5,a5,-720 # c8002914 <Xil_AssertStatus>
c0014bec:	0007a023          	sw	zero,0(a5)
	Xil_AssertVoid(Entry < XAE_TPID_MAX_ENTRIES);
c0014bf0:	fd744703          	lbu	a4,-41(s0)
c0014bf4:	00300793          	li	a5,3
c0014bf8:	04e7ea63          	bltu	a5,a4,c0014c4c <XAxiEthernet_GetTpid+0x114>
c0014bfc:	0280006f          	j	c0014c24 <XAxiEthernet_GetTpid+0xec>
	Xil_AssertVoid(TpidPtr != NULL);
c0014c00:	31a00593          	li	a1,794
c0014c04:	07fec517          	auipc	a0,0x7fec
c0014c08:	1e050513          	addi	a0,a0,480 # c8000de4 <__rodata_start+0xde4>
c0014c0c:	6b1080ef          	jal	ra,c001dabc <Xil_Assert>
c0014c10:	07fee797          	auipc	a5,0x7fee
c0014c14:	d0478793          	addi	a5,a5,-764 # c8002914 <Xil_AssertStatus>
c0014c18:	00100713          	li	a4,1
c0014c1c:	00e7a023          	sw	a4,0(a5)
c0014c20:	0d00006f          	j	c0014cf0 <XAxiEthernet_GetTpid+0x1b8>
	Xil_AssertVoid(Entry < XAE_TPID_MAX_ENTRIES);
c0014c24:	07fee797          	auipc	a5,0x7fee
c0014c28:	cf078793          	addi	a5,a5,-784 # c8002914 <Xil_AssertStatus>
c0014c2c:	0007a023          	sw	zero,0(a5)

	printf("XAxiEthernet_GetTpid\r\n");
c0014c30:	07fec517          	auipc	a0,0x7fec
c0014c34:	66850513          	addi	a0,a0,1640 # c8001298 <__rodata_start+0x1298>
c0014c38:	288090ef          	jal	ra,c001dec0 <puts>

	if (Entry < 2) {
c0014c3c:	fd744703          	lbu	a4,-41(s0)
c0014c40:	00100793          	li	a5,1
c0014c44:	04e7e463          	bltu	a5,a4,c0014c8c <XAxiEthernet_GetTpid+0x154>
c0014c48:	0280006f          	j	c0014c70 <XAxiEthernet_GetTpid+0x138>
	Xil_AssertVoid(Entry < XAE_TPID_MAX_ENTRIES);
c0014c4c:	31b00593          	li	a1,795
c0014c50:	07fec517          	auipc	a0,0x7fec
c0014c54:	19450513          	addi	a0,a0,404 # c8000de4 <__rodata_start+0xde4>
c0014c58:	665080ef          	jal	ra,c001dabc <Xil_Assert>
c0014c5c:	07fee797          	auipc	a5,0x7fee
c0014c60:	cb878793          	addi	a5,a5,-840 # c8002914 <Xil_AssertStatus>
c0014c64:	00100713          	li	a4,1
c0014c68:	00e7a023          	sw	a4,0(a5)
c0014c6c:	0840006f          	j	c0014cf0 <XAxiEthernet_GetTpid+0x1b8>
		RegTpid = XAxiEthernet_ReadReg(InstancePtr->Config.BaseAddress,
c0014c70:	fdc42783          	lw	a5,-36(s0)
c0014c74:	0047a783          	lw	a5,4(a5)
c0014c78:	02878793          	addi	a5,a5,40
c0014c7c:	00078513          	mv	a0,a5
c0014c80:	985fe0ef          	jal	ra,c0013604 <Xil_In32>
c0014c84:	fea42623          	sw	a0,-20(s0)
c0014c88:	01c0006f          	j	c0014ca4 <XAxiEthernet_GetTpid+0x16c>
					XAE_TPID0_OFFSET);
	} else {
		RegTpid = XAxiEthernet_ReadReg(InstancePtr->Config.BaseAddress,
c0014c8c:	fdc42783          	lw	a5,-36(s0)
c0014c90:	0047a783          	lw	a5,4(a5)
c0014c94:	02c78793          	addi	a5,a5,44
c0014c98:	00078513          	mv	a0,a5
c0014c9c:	969fe0ef          	jal	ra,c0013604 <Xil_In32>
c0014ca0:	fea42623          	sw	a0,-20(s0)
					XAE_TPID1_OFFSET);
	}

	if (Entry % 2) {
c0014ca4:	fd744783          	lbu	a5,-41(s0)
c0014ca8:	0017f793          	andi	a5,a5,1
c0014cac:	0ff7f793          	andi	a5,a5,255
c0014cb0:	02078063          	beqz	a5,c0014cd0 <XAxiEthernet_GetTpid+0x198>
		*TpidPtr = (RegTpid >> 16);
c0014cb4:	fec42783          	lw	a5,-20(s0)
c0014cb8:	0107d793          	srli	a5,a5,0x10
c0014cbc:	01079713          	slli	a4,a5,0x10
c0014cc0:	01075713          	srli	a4,a4,0x10
c0014cc4:	fd842783          	lw	a5,-40(s0)
c0014cc8:	00e79023          	sh	a4,0(a5)
c0014ccc:	0180006f          	j	c0014ce4 <XAxiEthernet_GetTpid+0x1ac>
	} else {
		*TpidPtr = (RegTpid & XAE_TPID_0_MASK);
c0014cd0:	fec42783          	lw	a5,-20(s0)
c0014cd4:	01079713          	slli	a4,a5,0x10
c0014cd8:	01075713          	srli	a4,a4,0x10
c0014cdc:	fd842783          	lw	a5,-40(s0)
c0014ce0:	00e79023          	sh	a4,0(a5)
	}
	printf("XAxiEthernet_GetTpid: done\r\n");
c0014ce4:	07fec517          	auipc	a0,0x7fec
c0014ce8:	5cc50513          	addi	a0,a0,1484 # c80012b0 <__rodata_start+0x12b0>
c0014cec:	1d4090ef          	jal	ra,c001dec0 <puts>
}
c0014cf0:	02c12083          	lw	ra,44(sp)
c0014cf4:	02812403          	lw	s0,40(sp)
c0014cf8:	03010113          	addi	sp,sp,48
c0014cfc:	00008067          	ret

c0014d00 <XAxiEthernet_SetVTagMode>:
* Mode value shifting is handled in this function. No shifting is required to
* call this function.
*
*****************************************************************************/
int XAxiEthernet_SetVTagMode(XAxiEthernet *InstancePtr, u32 Mode, int Dir)
{
c0014d00:	fd010113          	addi	sp,sp,-48
c0014d04:	02112623          	sw	ra,44(sp)
c0014d08:	02812423          	sw	s0,40(sp)
c0014d0c:	03010413          	addi	s0,sp,48
c0014d10:	fca42e23          	sw	a0,-36(s0)
c0014d14:	fcb42c23          	sw	a1,-40(s0)
c0014d18:	fcc42a23          	sw	a2,-44(s0)
	u32 RegRaf;

	Xil_AssertNonvoid(InstancePtr != NULL);
c0014d1c:	fdc42783          	lw	a5,-36(s0)
c0014d20:	02078463          	beqz	a5,c0014d48 <XAxiEthernet_SetVTagMode+0x48>
c0014d24:	07fee797          	auipc	a5,0x7fee
c0014d28:	bf078793          	addi	a5,a5,-1040 # c8002914 <Xil_AssertStatus>
c0014d2c:	0007a023          	sw	zero,0(a5)
	Xil_AssertNonvoid(InstancePtr->IsReady == XIL_COMPONENT_IS_READY);
c0014d30:	fdc42783          	lw	a5,-36(s0)
c0014d34:	0507a703          	lw	a4,80(a5)
c0014d38:	111117b7          	lui	a5,0x11111
c0014d3c:	11178793          	addi	a5,a5,273 # 11111111 <_DMEM_LENGTH+0x10911111>
c0014d40:	04f71663          	bne	a4,a5,c0014d8c <XAxiEthernet_SetVTagMode+0x8c>
c0014d44:	02c0006f          	j	c0014d70 <XAxiEthernet_SetVTagMode+0x70>
	Xil_AssertNonvoid(InstancePtr != NULL);
c0014d48:	35900593          	li	a1,857
c0014d4c:	07fec517          	auipc	a0,0x7fec
c0014d50:	09850513          	addi	a0,a0,152 # c8000de4 <__rodata_start+0xde4>
c0014d54:	569080ef          	jal	ra,c001dabc <Xil_Assert>
c0014d58:	07fee797          	auipc	a5,0x7fee
c0014d5c:	bbc78793          	addi	a5,a5,-1092 # c8002914 <Xil_AssertStatus>
c0014d60:	00100713          	li	a4,1
c0014d64:	00e7a023          	sw	a4,0(a5)
c0014d68:	00000793          	li	a5,0
c0014d6c:	1940006f          	j	c0014f00 <XAxiEthernet_SetVTagMode+0x200>
	Xil_AssertNonvoid(InstancePtr->IsReady == XIL_COMPONENT_IS_READY);
c0014d70:	07fee797          	auipc	a5,0x7fee
c0014d74:	ba478793          	addi	a5,a5,-1116 # c8002914 <Xil_AssertStatus>
c0014d78:	0007a023          	sw	zero,0(a5)
	Xil_AssertNonvoid((Dir == XAE_TX) || (Dir == XAE_RX));
c0014d7c:	fd442703          	lw	a4,-44(s0)
c0014d80:	00200793          	li	a5,2
c0014d84:	02f70e63          	beq	a4,a5,c0014dc0 <XAxiEthernet_SetVTagMode+0xc0>
c0014d88:	02c0006f          	j	c0014db4 <XAxiEthernet_SetVTagMode+0xb4>
	Xil_AssertNonvoid(InstancePtr->IsReady == XIL_COMPONENT_IS_READY);
c0014d8c:	35a00593          	li	a1,858
c0014d90:	07fec517          	auipc	a0,0x7fec
c0014d94:	05450513          	addi	a0,a0,84 # c8000de4 <__rodata_start+0xde4>
c0014d98:	525080ef          	jal	ra,c001dabc <Xil_Assert>
c0014d9c:	07fee797          	auipc	a5,0x7fee
c0014da0:	b7878793          	addi	a5,a5,-1160 # c8002914 <Xil_AssertStatus>
c0014da4:	00100713          	li	a4,1
c0014da8:	00e7a023          	sw	a4,0(a5)
c0014dac:	00000793          	li	a5,0
c0014db0:	1500006f          	j	c0014f00 <XAxiEthernet_SetVTagMode+0x200>
	Xil_AssertNonvoid((Dir == XAE_TX) || (Dir == XAE_RX));
c0014db4:	fd442703          	lw	a4,-44(s0)
c0014db8:	00100793          	li	a5,1
c0014dbc:	02f71463          	bne	a4,a5,c0014de4 <XAxiEthernet_SetVTagMode+0xe4>
c0014dc0:	07fee797          	auipc	a5,0x7fee
c0014dc4:	b5478793          	addi	a5,a5,-1196 # c8002914 <Xil_AssertStatus>
c0014dc8:	0007a023          	sw	zero,0(a5)

	/* The device must be stopped before modify TX VLAN Tag mode */
	if (InstancePtr->IsStarted == XIL_COMPONENT_IS_STARTED) {
c0014dcc:	fdc42783          	lw	a5,-36(s0)
c0014dd0:	04c7a703          	lw	a4,76(a5)
c0014dd4:	222227b7          	lui	a5,0x22222
c0014dd8:	22278793          	addi	a5,a5,546 # 22222222 <_DMEM_LENGTH+0x21a22222>
c0014ddc:	02f70863          	beq	a4,a5,c0014e0c <XAxiEthernet_SetVTagMode+0x10c>
c0014de0:	0400006f          	j	c0014e20 <XAxiEthernet_SetVTagMode+0x120>
	Xil_AssertNonvoid((Dir == XAE_TX) || (Dir == XAE_RX));
c0014de4:	35b00593          	li	a1,859
c0014de8:	07fec517          	auipc	a0,0x7fec
c0014dec:	ffc50513          	addi	a0,a0,-4 # c8000de4 <__rodata_start+0xde4>
c0014df0:	4cd080ef          	jal	ra,c001dabc <Xil_Assert>
c0014df4:	07fee797          	auipc	a5,0x7fee
c0014df8:	b2078793          	addi	a5,a5,-1248 # c8002914 <Xil_AssertStatus>
c0014dfc:	00100713          	li	a4,1
c0014e00:	00e7a023          	sw	a4,0(a5)
c0014e04:	00000793          	li	a5,0
c0014e08:	0f80006f          	j	c0014f00 <XAxiEthernet_SetVTagMode+0x200>
		printf(
c0014e0c:	07fec517          	auipc	a0,0x7fec
c0014e10:	4c050513          	addi	a0,a0,1216 # c80012cc <__rodata_start+0x12cc>
c0014e14:	0ac090ef          	jal	ra,c001dec0 <puts>
		"XAxiEthernet_SetVTagMode:returning DEVICE_IS_STARTED\r\n");
		return (XST_DEVICE_IS_STARTED);
c0014e18:	00500793          	li	a5,5
c0014e1c:	0e40006f          	j	c0014f00 <XAxiEthernet_SetVTagMode+0x200>
	}

	/* Check hw capability */
	if (!XAxiEthernet_IsExtFuncCap(InstancePtr)) {
c0014e20:	fdc42783          	lw	a5,-36(s0)
c0014e24:	0047a783          	lw	a5,4(a5)
c0014e28:	00078513          	mv	a0,a5
c0014e2c:	fd8fe0ef          	jal	ra,c0013604 <Xil_In32>
c0014e30:	00050713          	mv	a4,a0
c0014e34:	000017b7          	lui	a5,0x1
c0014e38:	80078793          	addi	a5,a5,-2048 # 800 <_STACK_SIZE-0x800>
c0014e3c:	00f777b3          	and	a5,a4,a5
c0014e40:	00079c63          	bnez	a5,c0014e58 <XAxiEthernet_SetVTagMode+0x158>
		printf(
c0014e44:	07fec517          	auipc	a0,0x7fec
c0014e48:	4c050513          	addi	a0,a0,1216 # c8001304 <__rodata_start+0x1304>
c0014e4c:	074090ef          	jal	ra,c001dec0 <puts>
		"XAxiEthernet_SetVTagMode: returning DEVICE_NO_FEATURE\r\n");
		return (XST_NO_FEATURE);
c0014e50:	01300793          	li	a5,19
c0014e54:	0ac0006f          	j	c0014f00 <XAxiEthernet_SetVTagMode+0x200>
	}

	/* Mode has to be one of the supported values */
	switch (Mode) {
c0014e58:	fd842703          	lw	a4,-40(s0)
c0014e5c:	00300793          	li	a5,3
c0014e60:	00e7f663          	bgeu	a5,a4,c0014e6c <XAxiEthernet_SetVTagMode+0x16c>
		case XAE_VTAG_ALL:
		case XAE_VTAG_EXISTED:
		case XAE_VTAG_SELECT:
			break;
		default:
			return (XST_INVALID_PARAM);
c0014e64:	00f00793          	li	a5,15
c0014e68:	0980006f          	j	c0014f00 <XAxiEthernet_SetVTagMode+0x200>
			break;
c0014e6c:	00000013          	nop
	}

	printf("XAxiEthernet_SetVTagMode\r\n");
c0014e70:	07fec517          	auipc	a0,0x7fec
c0014e74:	4cc50513          	addi	a0,a0,1228 # c800133c <__rodata_start+0x133c>
c0014e78:	048090ef          	jal	ra,c001dec0 <puts>

	/* Program HW */
	RegRaf = XAxiEthernet_ReadReg(InstancePtr->Config.BaseAddress,
c0014e7c:	fdc42783          	lw	a5,-36(s0)
c0014e80:	0047a783          	lw	a5,4(a5)
c0014e84:	00078513          	mv	a0,a5
c0014e88:	f7cfe0ef          	jal	ra,c0013604 <Xil_In32>
c0014e8c:	fea42623          	sw	a0,-20(s0)
							XAE_RAF_OFFSET);
	/* Transmit direction */
	if (XAE_TX == Dir) {
c0014e90:	fd442703          	lw	a4,-44(s0)
c0014e94:	00200793          	li	a5,2
c0014e98:	02f71863          	bne	a4,a5,c0014ec8 <XAxiEthernet_SetVTagMode+0x1c8>
		XAxiEthernet_WriteReg(InstancePtr->Config.BaseAddress,
c0014e9c:	fdc42783          	lw	a5,-36(s0)
c0014ea0:	0047a683          	lw	a3,4(a5)
c0014ea4:	fec42783          	lw	a5,-20(s0)
c0014ea8:	fe77f713          	andi	a4,a5,-25
c0014eac:	fd842783          	lw	a5,-40(s0)
c0014eb0:	00379793          	slli	a5,a5,0x3
c0014eb4:	00f767b3          	or	a5,a4,a5
c0014eb8:	00078593          	mv	a1,a5
c0014ebc:	00068513          	mv	a0,a3
c0014ec0:	f6cfe0ef          	jal	ra,c001362c <Xil_Out32>
c0014ec4:	02c0006f          	j	c0014ef0 <XAxiEthernet_SetVTagMode+0x1f0>
			XAE_RAF_OFFSET, ((RegRaf & ~XAE_RAF_TXVTAGMODE_MASK) |
			(Mode << XAE_RAF_TXVTAGMODE_SHIFT)));
	} else { /* Receive direction */
		XAxiEthernet_WriteReg(InstancePtr->Config.BaseAddress,
c0014ec8:	fdc42783          	lw	a5,-36(s0)
c0014ecc:	0047a683          	lw	a3,4(a5)
c0014ed0:	fec42783          	lw	a5,-20(s0)
c0014ed4:	f9f7f713          	andi	a4,a5,-97
c0014ed8:	fd842783          	lw	a5,-40(s0)
c0014edc:	00579793          	slli	a5,a5,0x5
c0014ee0:	00f767b3          	or	a5,a4,a5
c0014ee4:	00078593          	mv	a1,a5
c0014ee8:	00068513          	mv	a0,a3
c0014eec:	f40fe0ef          	jal	ra,c001362c <Xil_Out32>
			XAE_RAF_OFFSET, ((RegRaf & ~XAE_RAF_RXVTAGMODE_MASK) |
			(Mode << XAE_RAF_RXVTAGMODE_SHIFT)));
	}

	printf(
c0014ef0:	07fec517          	auipc	a0,0x7fec
c0014ef4:	46850513          	addi	a0,a0,1128 # c8001358 <__rodata_start+0x1358>
c0014ef8:	7c9080ef          	jal	ra,c001dec0 <puts>
			"XAxiEthernet_SetVTagMode: returning SUCCESS\r\n");

	return (XST_SUCCESS);
c0014efc:	00000793          	li	a5,0
}
c0014f00:	00078513          	mv	a0,a5
c0014f04:	02c12083          	lw	ra,44(sp)
c0014f08:	02812403          	lw	s0,40(sp)
c0014f0c:	03010113          	addi	sp,sp,48
c0014f10:	00008067          	ret

c0014f14 <XAxiEthernet_GetVTagMode>:
* Mode value shifting is handled in this function. No shifting is required to
* call this function.
*
*****************************************************************************/
void XAxiEthernet_GetVTagMode(XAxiEthernet *InstancePtr, u8 *ModePtr, int Dir)
{
c0014f14:	fd010113          	addi	sp,sp,-48
c0014f18:	02112623          	sw	ra,44(sp)
c0014f1c:	02812423          	sw	s0,40(sp)
c0014f20:	03010413          	addi	s0,sp,48
c0014f24:	fca42e23          	sw	a0,-36(s0)
c0014f28:	fcb42c23          	sw	a1,-40(s0)
c0014f2c:	fcc42a23          	sw	a2,-44(s0)
	u32 RegRaf;

	Xil_AssertVoid(InstancePtr != NULL);
c0014f30:	fdc42783          	lw	a5,-36(s0)
c0014f34:	02078463          	beqz	a5,c0014f5c <XAxiEthernet_GetVTagMode+0x48>
c0014f38:	07fee797          	auipc	a5,0x7fee
c0014f3c:	9dc78793          	addi	a5,a5,-1572 # c8002914 <Xil_AssertStatus>
c0014f40:	0007a023          	sw	zero,0(a5)
	Xil_AssertVoid(InstancePtr->IsReady == XIL_COMPONENT_IS_READY);
c0014f44:	fdc42783          	lw	a5,-36(s0)
c0014f48:	0507a703          	lw	a4,80(a5)
c0014f4c:	111117b7          	lui	a5,0x11111
c0014f50:	11178793          	addi	a5,a5,273 # 11111111 <_DMEM_LENGTH+0x10911111>
c0014f54:	04f71263          	bne	a4,a5,c0014f98 <XAxiEthernet_GetVTagMode+0x84>
c0014f58:	0280006f          	j	c0014f80 <XAxiEthernet_GetVTagMode+0x6c>
	Xil_AssertVoid(InstancePtr != NULL);
c0014f5c:	3a300593          	li	a1,931
c0014f60:	07fec517          	auipc	a0,0x7fec
c0014f64:	e8450513          	addi	a0,a0,-380 # c8000de4 <__rodata_start+0xde4>
c0014f68:	355080ef          	jal	ra,c001dabc <Xil_Assert>
c0014f6c:	07fee797          	auipc	a5,0x7fee
c0014f70:	9a878793          	addi	a5,a5,-1624 # c8002914 <Xil_AssertStatus>
c0014f74:	00100713          	li	a4,1
c0014f78:	00e7a023          	sw	a4,0(a5)
c0014f7c:	1340006f          	j	c00150b0 <XAxiEthernet_GetVTagMode+0x19c>
	Xil_AssertVoid(InstancePtr->IsReady == XIL_COMPONENT_IS_READY);
c0014f80:	07fee797          	auipc	a5,0x7fee
c0014f84:	99478793          	addi	a5,a5,-1644 # c8002914 <Xil_AssertStatus>
c0014f88:	0007a023          	sw	zero,0(a5)
	Xil_AssertVoid(ModePtr != NULL);
c0014f8c:	fd842783          	lw	a5,-40(s0)
c0014f90:	04078463          	beqz	a5,c0014fd8 <XAxiEthernet_GetVTagMode+0xc4>
c0014f94:	0280006f          	j	c0014fbc <XAxiEthernet_GetVTagMode+0xa8>
	Xil_AssertVoid(InstancePtr->IsReady == XIL_COMPONENT_IS_READY);
c0014f98:	3a400593          	li	a1,932
c0014f9c:	07fec517          	auipc	a0,0x7fec
c0014fa0:	e4850513          	addi	a0,a0,-440 # c8000de4 <__rodata_start+0xde4>
c0014fa4:	319080ef          	jal	ra,c001dabc <Xil_Assert>
c0014fa8:	07fee797          	auipc	a5,0x7fee
c0014fac:	96c78793          	addi	a5,a5,-1684 # c8002914 <Xil_AssertStatus>
c0014fb0:	00100713          	li	a4,1
c0014fb4:	00e7a023          	sw	a4,0(a5)
c0014fb8:	0f80006f          	j	c00150b0 <XAxiEthernet_GetVTagMode+0x19c>
	Xil_AssertVoid(ModePtr != NULL);
c0014fbc:	07fee797          	auipc	a5,0x7fee
c0014fc0:	95878793          	addi	a5,a5,-1704 # c8002914 <Xil_AssertStatus>
c0014fc4:	0007a023          	sw	zero,0(a5)
	Xil_AssertVoid((Dir == XAE_TX) || (Dir == XAE_RX));
c0014fc8:	fd442703          	lw	a4,-44(s0)
c0014fcc:	00200793          	li	a5,2
c0014fd0:	02f70c63          	beq	a4,a5,c0015008 <XAxiEthernet_GetVTagMode+0xf4>
c0014fd4:	0280006f          	j	c0014ffc <XAxiEthernet_GetVTagMode+0xe8>
	Xil_AssertVoid(ModePtr != NULL);
c0014fd8:	3a500593          	li	a1,933
c0014fdc:	07fec517          	auipc	a0,0x7fec
c0014fe0:	e0850513          	addi	a0,a0,-504 # c8000de4 <__rodata_start+0xde4>
c0014fe4:	2d9080ef          	jal	ra,c001dabc <Xil_Assert>
c0014fe8:	07fee797          	auipc	a5,0x7fee
c0014fec:	92c78793          	addi	a5,a5,-1748 # c8002914 <Xil_AssertStatus>
c0014ff0:	00100713          	li	a4,1
c0014ff4:	00e7a023          	sw	a4,0(a5)
c0014ff8:	0b80006f          	j	c00150b0 <XAxiEthernet_GetVTagMode+0x19c>
	Xil_AssertVoid((Dir == XAE_TX) || (Dir == XAE_RX));
c0014ffc:	fd442703          	lw	a4,-44(s0)
c0015000:	00100793          	li	a5,1
c0015004:	04f71063          	bne	a4,a5,c0015044 <XAxiEthernet_GetVTagMode+0x130>
c0015008:	07fee797          	auipc	a5,0x7fee
c001500c:	90c78793          	addi	a5,a5,-1780 # c8002914 <Xil_AssertStatus>
c0015010:	0007a023          	sw	zero,0(a5)

	printf("XAxiEthernet_GetVTagMode\r\n");
c0015014:	07fec517          	auipc	a0,0x7fec
c0015018:	37450513          	addi	a0,a0,884 # c8001388 <__rodata_start+0x1388>
c001501c:	6a5080ef          	jal	ra,c001dec0 <puts>

	/* Access HW configuration */
	RegRaf = XAxiEthernet_ReadReg(InstancePtr->Config.BaseAddress,
c0015020:	fdc42783          	lw	a5,-36(s0)
c0015024:	0047a783          	lw	a5,4(a5)
c0015028:	00078513          	mv	a0,a5
c001502c:	dd8fe0ef          	jal	ra,c0013604 <Xil_In32>
c0015030:	fea42623          	sw	a0,-20(s0)
							XAE_RAF_OFFSET);
	/* Transmit direction */
	if (XAE_TX == Dir) {
c0015034:	fd442703          	lw	a4,-44(s0)
c0015038:	00200793          	li	a5,2
c001503c:	02f70663          	beq	a4,a5,c0015068 <XAxiEthernet_GetVTagMode+0x154>
c0015040:	0480006f          	j	c0015088 <XAxiEthernet_GetVTagMode+0x174>
	Xil_AssertVoid((Dir == XAE_TX) || (Dir == XAE_RX));
c0015044:	3a600593          	li	a1,934
c0015048:	07fec517          	auipc	a0,0x7fec
c001504c:	d9c50513          	addi	a0,a0,-612 # c8000de4 <__rodata_start+0xde4>
c0015050:	26d080ef          	jal	ra,c001dabc <Xil_Assert>
c0015054:	07fee797          	auipc	a5,0x7fee
c0015058:	8c078793          	addi	a5,a5,-1856 # c8002914 <Xil_AssertStatus>
c001505c:	00100713          	li	a4,1
c0015060:	00e7a023          	sw	a4,0(a5)
c0015064:	04c0006f          	j	c00150b0 <XAxiEthernet_GetVTagMode+0x19c>
		*ModePtr = (RegRaf & XAE_RAF_TXVTAGMODE_MASK) >>
c0015068:	fec42783          	lw	a5,-20(s0)
c001506c:	0037d793          	srli	a5,a5,0x3
c0015070:	0ff7f793          	andi	a5,a5,255
c0015074:	0037f793          	andi	a5,a5,3
c0015078:	0ff7f713          	andi	a4,a5,255
c001507c:	fd842783          	lw	a5,-40(s0)
c0015080:	00e78023          	sb	a4,0(a5)
c0015084:	0200006f          	j	c00150a4 <XAxiEthernet_GetVTagMode+0x190>
				XAE_RAF_TXVTAGMODE_SHIFT;
	} else { /* Receive direction */
		*ModePtr = (RegRaf & XAE_RAF_RXVTAGMODE_MASK) >>
c0015088:	fec42783          	lw	a5,-20(s0)
c001508c:	0057d793          	srli	a5,a5,0x5
c0015090:	0ff7f793          	andi	a5,a5,255
c0015094:	0037f793          	andi	a5,a5,3
c0015098:	0ff7f713          	andi	a4,a5,255
c001509c:	fd842783          	lw	a5,-40(s0)
c00150a0:	00e78023          	sb	a4,0(a5)
				XAE_RAF_RXVTAGMODE_SHIFT;
	}

	printf("XAxiEthernet_GetVTagMode: done\r\n");
c00150a4:	07fec517          	auipc	a0,0x7fec
c00150a8:	30050513          	addi	a0,a0,768 # c80013a4 <__rodata_start+0x13a4>
c00150ac:	615080ef          	jal	ra,c001dec0 <puts>

}
c00150b0:	02c12083          	lw	ra,44(sp)
c00150b4:	02812403          	lw	s0,40(sp)
c00150b8:	03010113          	addi	sp,sp,48
c00150bc:	00008067          	ret

c00150c0 <XAxiEthernet_SetVStripMode>:
* Mode value shifting is handled in this function. No shifting is required to
* call this function.
*
*****************************************************************************/
int XAxiEthernet_SetVStripMode(XAxiEthernet *InstancePtr, u32 Mode, int Dir)
{
c00150c0:	fd010113          	addi	sp,sp,-48
c00150c4:	02112623          	sw	ra,44(sp)
c00150c8:	02812423          	sw	s0,40(sp)
c00150cc:	03010413          	addi	s0,sp,48
c00150d0:	fca42e23          	sw	a0,-36(s0)
c00150d4:	fcb42c23          	sw	a1,-40(s0)
c00150d8:	fcc42a23          	sw	a2,-44(s0)
	u32 RegRaf;

	Xil_AssertNonvoid(InstancePtr != NULL);
c00150dc:	fdc42783          	lw	a5,-36(s0)
c00150e0:	02078463          	beqz	a5,c0015108 <XAxiEthernet_SetVStripMode+0x48>
c00150e4:	07fee797          	auipc	a5,0x7fee
c00150e8:	83078793          	addi	a5,a5,-2000 # c8002914 <Xil_AssertStatus>
c00150ec:	0007a023          	sw	zero,0(a5)
	Xil_AssertNonvoid(InstancePtr->IsReady == XIL_COMPONENT_IS_READY);
c00150f0:	fdc42783          	lw	a5,-36(s0)
c00150f4:	0507a703          	lw	a4,80(a5)
c00150f8:	111117b7          	lui	a5,0x11111
c00150fc:	11178793          	addi	a5,a5,273 # 11111111 <_DMEM_LENGTH+0x10911111>
c0015100:	04f71663          	bne	a4,a5,c001514c <XAxiEthernet_SetVStripMode+0x8c>
c0015104:	02c0006f          	j	c0015130 <XAxiEthernet_SetVStripMode+0x70>
	Xil_AssertNonvoid(InstancePtr != NULL);
c0015108:	3e200593          	li	a1,994
c001510c:	07fec517          	auipc	a0,0x7fec
c0015110:	cd850513          	addi	a0,a0,-808 # c8000de4 <__rodata_start+0xde4>
c0015114:	1a9080ef          	jal	ra,c001dabc <Xil_Assert>
c0015118:	07fed797          	auipc	a5,0x7fed
c001511c:	7fc78793          	addi	a5,a5,2044 # c8002914 <Xil_AssertStatus>
c0015120:	00100713          	li	a4,1
c0015124:	00e7a023          	sw	a4,0(a5)
c0015128:	00000793          	li	a5,0
c001512c:	1a00006f          	j	c00152cc <XAxiEthernet_SetVStripMode+0x20c>
	Xil_AssertNonvoid(InstancePtr->IsReady == XIL_COMPONENT_IS_READY);
c0015130:	07fed797          	auipc	a5,0x7fed
c0015134:	7e478793          	addi	a5,a5,2020 # c8002914 <Xil_AssertStatus>
c0015138:	0007a023          	sw	zero,0(a5)
	Xil_AssertNonvoid((Dir == XAE_TX) || (Dir == XAE_RX));
c001513c:	fd442703          	lw	a4,-44(s0)
c0015140:	00200793          	li	a5,2
c0015144:	02f70e63          	beq	a4,a5,c0015180 <XAxiEthernet_SetVStripMode+0xc0>
c0015148:	02c0006f          	j	c0015174 <XAxiEthernet_SetVStripMode+0xb4>
	Xil_AssertNonvoid(InstancePtr->IsReady == XIL_COMPONENT_IS_READY);
c001514c:	3e300593          	li	a1,995
c0015150:	07fec517          	auipc	a0,0x7fec
c0015154:	c9450513          	addi	a0,a0,-876 # c8000de4 <__rodata_start+0xde4>
c0015158:	165080ef          	jal	ra,c001dabc <Xil_Assert>
c001515c:	07fed797          	auipc	a5,0x7fed
c0015160:	7b878793          	addi	a5,a5,1976 # c8002914 <Xil_AssertStatus>
c0015164:	00100713          	li	a4,1
c0015168:	00e7a023          	sw	a4,0(a5)
c001516c:	00000793          	li	a5,0
c0015170:	15c0006f          	j	c00152cc <XAxiEthernet_SetVStripMode+0x20c>
	Xil_AssertNonvoid((Dir == XAE_TX) || (Dir == XAE_RX));
c0015174:	fd442703          	lw	a4,-44(s0)
c0015178:	00100793          	li	a5,1
c001517c:	02f71463          	bne	a4,a5,c00151a4 <XAxiEthernet_SetVStripMode+0xe4>
c0015180:	07fed797          	auipc	a5,0x7fed
c0015184:	79478793          	addi	a5,a5,1940 # c8002914 <Xil_AssertStatus>
c0015188:	0007a023          	sw	zero,0(a5)

	/* The device must be stopped before modify TX VLAN Tag mode */
	if (InstancePtr->IsStarted == XIL_COMPONENT_IS_STARTED) {
c001518c:	fdc42783          	lw	a5,-36(s0)
c0015190:	04c7a703          	lw	a4,76(a5)
c0015194:	222227b7          	lui	a5,0x22222
c0015198:	22278793          	addi	a5,a5,546 # 22222222 <_DMEM_LENGTH+0x21a22222>
c001519c:	02f70863          	beq	a4,a5,c00151cc <XAxiEthernet_SetVStripMode+0x10c>
c00151a0:	0400006f          	j	c00151e0 <XAxiEthernet_SetVStripMode+0x120>
	Xil_AssertNonvoid((Dir == XAE_TX) || (Dir == XAE_RX));
c00151a4:	3e400593          	li	a1,996
c00151a8:	07fec517          	auipc	a0,0x7fec
c00151ac:	c3c50513          	addi	a0,a0,-964 # c8000de4 <__rodata_start+0xde4>
c00151b0:	10d080ef          	jal	ra,c001dabc <Xil_Assert>
c00151b4:	07fed797          	auipc	a5,0x7fed
c00151b8:	76078793          	addi	a5,a5,1888 # c8002914 <Xil_AssertStatus>
c00151bc:	00100713          	li	a4,1
c00151c0:	00e7a023          	sw	a4,0(a5)
c00151c4:	00000793          	li	a5,0
c00151c8:	1040006f          	j	c00152cc <XAxiEthernet_SetVStripMode+0x20c>
		printf(
c00151cc:	07fec517          	auipc	a0,0x7fec
c00151d0:	1f850513          	addi	a0,a0,504 # c80013c4 <__rodata_start+0x13c4>
c00151d4:	4ed080ef          	jal	ra,c001dec0 <puts>
		"XAxiEthernet_SetVStripMode: returning DEVICE_IS_STARTED\r\n");
		return (XST_DEVICE_IS_STARTED);
c00151d8:	00500793          	li	a5,5
c00151dc:	0f00006f          	j	c00152cc <XAxiEthernet_SetVStripMode+0x20c>
	}

	/* Check HW capability */
	if (!XAxiEthernet_IsExtFuncCap(InstancePtr)) {
c00151e0:	fdc42783          	lw	a5,-36(s0)
c00151e4:	0047a783          	lw	a5,4(a5)
c00151e8:	00078513          	mv	a0,a5
c00151ec:	c18fe0ef          	jal	ra,c0013604 <Xil_In32>
c00151f0:	00050713          	mv	a4,a0
c00151f4:	000017b7          	lui	a5,0x1
c00151f8:	80078793          	addi	a5,a5,-2048 # 800 <_STACK_SIZE-0x800>
c00151fc:	00f777b3          	and	a5,a4,a5
c0015200:	00079c63          	bnez	a5,c0015218 <XAxiEthernet_SetVStripMode+0x158>
		printf(
c0015204:	07fec517          	auipc	a0,0x7fec
c0015208:	1fc50513          	addi	a0,a0,508 # c8001400 <__rodata_start+0x1400>
c001520c:	4b5080ef          	jal	ra,c001dec0 <puts>
		"XAxiEthernet_SetVStripMode:returning DEVICE_NO_FEATURE\r\n");
		return (XST_NO_FEATURE);
c0015210:	01300793          	li	a5,19
c0015214:	0b80006f          	j	c00152cc <XAxiEthernet_SetVStripMode+0x20c>
	}

	/* Mode has to be one of the supported values */
	switch (Mode) {
c0015218:	fd842703          	lw	a4,-40(s0)
c001521c:	00100793          	li	a5,1
c0015220:	00e7fc63          	bgeu	a5,a4,c0015238 <XAxiEthernet_SetVStripMode+0x178>
c0015224:	fd842703          	lw	a4,-40(s0)
c0015228:	00300793          	li	a5,3
c001522c:	00f70663          	beq	a4,a5,c0015238 <XAxiEthernet_SetVStripMode+0x178>
		case XAE_VSTRP_NONE:
		case XAE_VSTRP_ALL:
		case XAE_VSTRP_SELECT:
			break;
		default:
			return (XST_INVALID_PARAM);
c0015230:	00f00793          	li	a5,15
c0015234:	0980006f          	j	c00152cc <XAxiEthernet_SetVStripMode+0x20c>
			break;
c0015238:	00000013          	nop
	}

	printf("XAxiEthernet_SetStripMode\r\n");
c001523c:	07fec517          	auipc	a0,0x7fec
c0015240:	1fc50513          	addi	a0,a0,508 # c8001438 <__rodata_start+0x1438>
c0015244:	47d080ef          	jal	ra,c001dec0 <puts>

	/* Program HW */
	RegRaf = XAxiEthernet_ReadReg(InstancePtr->Config.BaseAddress,
c0015248:	fdc42783          	lw	a5,-36(s0)
c001524c:	0047a783          	lw	a5,4(a5)
c0015250:	00078513          	mv	a0,a5
c0015254:	bb0fe0ef          	jal	ra,c0013604 <Xil_In32>
c0015258:	fea42623          	sw	a0,-20(s0)
							XAE_RAF_OFFSET);
	/* Transmit direction */
	if (XAE_TX == Dir) {
c001525c:	fd442703          	lw	a4,-44(s0)
c0015260:	00200793          	li	a5,2
c0015264:	02f71863          	bne	a4,a5,c0015294 <XAxiEthernet_SetVStripMode+0x1d4>
		XAxiEthernet_WriteReg(InstancePtr->Config.BaseAddress,
c0015268:	fdc42783          	lw	a5,-36(s0)
c001526c:	0047a683          	lw	a3,4(a5)
c0015270:	fec42783          	lw	a5,-20(s0)
c0015274:	e7f7f713          	andi	a4,a5,-385
c0015278:	fd842783          	lw	a5,-40(s0)
c001527c:	00779793          	slli	a5,a5,0x7
c0015280:	00f767b3          	or	a5,a4,a5
c0015284:	00078593          	mv	a1,a5
c0015288:	00068513          	mv	a0,a3
c001528c:	ba0fe0ef          	jal	ra,c001362c <Xil_Out32>
c0015290:	02c0006f          	j	c00152bc <XAxiEthernet_SetVStripMode+0x1fc>
			XAE_RAF_OFFSET, ((RegRaf & ~XAE_RAF_TXVSTRPMODE_MASK) |
			(Mode << XAE_RAF_TXVSTRPMODE_SHIFT)));
	} else { /* Receive direction */
		XAxiEthernet_WriteReg(InstancePtr->Config.BaseAddress,
c0015294:	fdc42783          	lw	a5,-36(s0)
c0015298:	0047a683          	lw	a3,4(a5)
c001529c:	fec42783          	lw	a5,-20(s0)
c00152a0:	9ff7f713          	andi	a4,a5,-1537
c00152a4:	fd842783          	lw	a5,-40(s0)
c00152a8:	00979793          	slli	a5,a5,0x9
c00152ac:	00f767b3          	or	a5,a4,a5
c00152b0:	00078593          	mv	a1,a5
c00152b4:	00068513          	mv	a0,a3
c00152b8:	b74fe0ef          	jal	ra,c001362c <Xil_Out32>
			XAE_RAF_OFFSET, ((RegRaf & ~XAE_RAF_RXVSTRPMODE_MASK) |
			(Mode << XAE_RAF_RXVSTRPMODE_SHIFT)));
	}

	printf(
c00152bc:	07fec517          	auipc	a0,0x7fec
c00152c0:	19850513          	addi	a0,a0,408 # c8001454 <__rodata_start+0x1454>
c00152c4:	3fd080ef          	jal	ra,c001dec0 <puts>
			"XAxiEthernet_SetVStripMode:returning SUCCESS\r\n");

	return (XST_SUCCESS);
c00152c8:	00000793          	li	a5,0
}
c00152cc:	00078513          	mv	a0,a5
c00152d0:	02c12083          	lw	ra,44(sp)
c00152d4:	02812403          	lw	s0,40(sp)
c00152d8:	03010113          	addi	sp,sp,48
c00152dc:	00008067          	ret

c00152e0 <XAxiEthernet_GetVStripMode>:
* call this function.
*
*****************************************************************************/
void XAxiEthernet_GetVStripMode(XAxiEthernet *InstancePtr, u8 *ModePtr,
								int Dir)
{
c00152e0:	fd010113          	addi	sp,sp,-48
c00152e4:	02112623          	sw	ra,44(sp)
c00152e8:	02812423          	sw	s0,40(sp)
c00152ec:	03010413          	addi	s0,sp,48
c00152f0:	fca42e23          	sw	a0,-36(s0)
c00152f4:	fcb42c23          	sw	a1,-40(s0)
c00152f8:	fcc42a23          	sw	a2,-44(s0)
	u32 RegRaf;

	Xil_AssertVoid(InstancePtr != NULL);
c00152fc:	fdc42783          	lw	a5,-36(s0)
c0015300:	02078463          	beqz	a5,c0015328 <XAxiEthernet_GetVStripMode+0x48>
c0015304:	07fed797          	auipc	a5,0x7fed
c0015308:	61078793          	addi	a5,a5,1552 # c8002914 <Xil_AssertStatus>
c001530c:	0007a023          	sw	zero,0(a5)
	Xil_AssertVoid(InstancePtr->IsReady == XIL_COMPONENT_IS_READY);
c0015310:	fdc42783          	lw	a5,-36(s0)
c0015314:	0507a703          	lw	a4,80(a5)
c0015318:	111117b7          	lui	a5,0x11111
c001531c:	11178793          	addi	a5,a5,273 # 11111111 <_DMEM_LENGTH+0x10911111>
c0015320:	04f71263          	bne	a4,a5,c0015364 <XAxiEthernet_GetVStripMode+0x84>
c0015324:	0280006f          	j	c001534c <XAxiEthernet_GetVStripMode+0x6c>
	Xil_AssertVoid(InstancePtr != NULL);
c0015328:	42e00593          	li	a1,1070
c001532c:	07fec517          	auipc	a0,0x7fec
c0015330:	ab850513          	addi	a0,a0,-1352 # c8000de4 <__rodata_start+0xde4>
c0015334:	788080ef          	jal	ra,c001dabc <Xil_Assert>
c0015338:	07fed797          	auipc	a5,0x7fed
c001533c:	5dc78793          	addi	a5,a5,1500 # c8002914 <Xil_AssertStatus>
c0015340:	00100713          	li	a4,1
c0015344:	00e7a023          	sw	a4,0(a5)
c0015348:	1340006f          	j	c001547c <XAxiEthernet_GetVStripMode+0x19c>
	Xil_AssertVoid(InstancePtr->IsReady == XIL_COMPONENT_IS_READY);
c001534c:	07fed797          	auipc	a5,0x7fed
c0015350:	5c878793          	addi	a5,a5,1480 # c8002914 <Xil_AssertStatus>
c0015354:	0007a023          	sw	zero,0(a5)
	Xil_AssertVoid(ModePtr != NULL);
c0015358:	fd842783          	lw	a5,-40(s0)
c001535c:	04078463          	beqz	a5,c00153a4 <XAxiEthernet_GetVStripMode+0xc4>
c0015360:	0280006f          	j	c0015388 <XAxiEthernet_GetVStripMode+0xa8>
	Xil_AssertVoid(InstancePtr->IsReady == XIL_COMPONENT_IS_READY);
c0015364:	42f00593          	li	a1,1071
c0015368:	07fec517          	auipc	a0,0x7fec
c001536c:	a7c50513          	addi	a0,a0,-1412 # c8000de4 <__rodata_start+0xde4>
c0015370:	74c080ef          	jal	ra,c001dabc <Xil_Assert>
c0015374:	07fed797          	auipc	a5,0x7fed
c0015378:	5a078793          	addi	a5,a5,1440 # c8002914 <Xil_AssertStatus>
c001537c:	00100713          	li	a4,1
c0015380:	00e7a023          	sw	a4,0(a5)
c0015384:	0f80006f          	j	c001547c <XAxiEthernet_GetVStripMode+0x19c>
	Xil_AssertVoid(ModePtr != NULL);
c0015388:	07fed797          	auipc	a5,0x7fed
c001538c:	58c78793          	addi	a5,a5,1420 # c8002914 <Xil_AssertStatus>
c0015390:	0007a023          	sw	zero,0(a5)
	Xil_AssertVoid((Dir == XAE_TX) || (Dir == XAE_RX));
c0015394:	fd442703          	lw	a4,-44(s0)
c0015398:	00200793          	li	a5,2
c001539c:	02f70c63          	beq	a4,a5,c00153d4 <XAxiEthernet_GetVStripMode+0xf4>
c00153a0:	0280006f          	j	c00153c8 <XAxiEthernet_GetVStripMode+0xe8>
	Xil_AssertVoid(ModePtr != NULL);
c00153a4:	43000593          	li	a1,1072
c00153a8:	07fec517          	auipc	a0,0x7fec
c00153ac:	a3c50513          	addi	a0,a0,-1476 # c8000de4 <__rodata_start+0xde4>
c00153b0:	70c080ef          	jal	ra,c001dabc <Xil_Assert>
c00153b4:	07fed797          	auipc	a5,0x7fed
c00153b8:	56078793          	addi	a5,a5,1376 # c8002914 <Xil_AssertStatus>
c00153bc:	00100713          	li	a4,1
c00153c0:	00e7a023          	sw	a4,0(a5)
c00153c4:	0b80006f          	j	c001547c <XAxiEthernet_GetVStripMode+0x19c>
	Xil_AssertVoid((Dir == XAE_TX) || (Dir == XAE_RX));
c00153c8:	fd442703          	lw	a4,-44(s0)
c00153cc:	00100793          	li	a5,1
c00153d0:	04f71063          	bne	a4,a5,c0015410 <XAxiEthernet_GetVStripMode+0x130>
c00153d4:	07fed797          	auipc	a5,0x7fed
c00153d8:	54078793          	addi	a5,a5,1344 # c8002914 <Xil_AssertStatus>
c00153dc:	0007a023          	sw	zero,0(a5)

	printf("XAxiEthernet_GetVStripMode\r\n");
c00153e0:	07fec517          	auipc	a0,0x7fec
c00153e4:	0a450513          	addi	a0,a0,164 # c8001484 <__rodata_start+0x1484>
c00153e8:	2d9080ef          	jal	ra,c001dec0 <puts>

	/* Access HW configuration */
	RegRaf = XAxiEthernet_ReadReg(InstancePtr->Config.BaseAddress,
c00153ec:	fdc42783          	lw	a5,-36(s0)
c00153f0:	0047a783          	lw	a5,4(a5)
c00153f4:	00078513          	mv	a0,a5
c00153f8:	a0cfe0ef          	jal	ra,c0013604 <Xil_In32>
c00153fc:	fea42623          	sw	a0,-20(s0)
							XAE_RAF_OFFSET);
	/* Transmit direction */
	if (XAE_TX == Dir) {
c0015400:	fd442703          	lw	a4,-44(s0)
c0015404:	00200793          	li	a5,2
c0015408:	02f70663          	beq	a4,a5,c0015434 <XAxiEthernet_GetVStripMode+0x154>
c001540c:	0480006f          	j	c0015454 <XAxiEthernet_GetVStripMode+0x174>
	Xil_AssertVoid((Dir == XAE_TX) || (Dir == XAE_RX));
c0015410:	43100593          	li	a1,1073
c0015414:	07fec517          	auipc	a0,0x7fec
c0015418:	9d050513          	addi	a0,a0,-1584 # c8000de4 <__rodata_start+0xde4>
c001541c:	6a0080ef          	jal	ra,c001dabc <Xil_Assert>
c0015420:	07fed797          	auipc	a5,0x7fed
c0015424:	4f478793          	addi	a5,a5,1268 # c8002914 <Xil_AssertStatus>
c0015428:	00100713          	li	a4,1
c001542c:	00e7a023          	sw	a4,0(a5)
c0015430:	04c0006f          	j	c001547c <XAxiEthernet_GetVStripMode+0x19c>
		*ModePtr = (RegRaf & XAE_RAF_TXVSTRPMODE_MASK) >>
c0015434:	fec42783          	lw	a5,-20(s0)
c0015438:	0077d793          	srli	a5,a5,0x7
c001543c:	0ff7f793          	andi	a5,a5,255
c0015440:	0037f793          	andi	a5,a5,3
c0015444:	0ff7f713          	andi	a4,a5,255
c0015448:	fd842783          	lw	a5,-40(s0)
c001544c:	00e78023          	sb	a4,0(a5)
c0015450:	0200006f          	j	c0015470 <XAxiEthernet_GetVStripMode+0x190>
					XAE_RAF_TXVSTRPMODE_SHIFT;
	} else { /* Receive direction */
		*ModePtr = (RegRaf & XAE_RAF_RXVSTRPMODE_MASK) >>
c0015454:	fec42783          	lw	a5,-20(s0)
c0015458:	0097d793          	srli	a5,a5,0x9
c001545c:	0ff7f793          	andi	a5,a5,255
c0015460:	0037f793          	andi	a5,a5,3
c0015464:	0ff7f713          	andi	a4,a5,255
c0015468:	fd842783          	lw	a5,-40(s0)
c001546c:	00e78023          	sb	a4,0(a5)
					XAE_RAF_RXVSTRPMODE_SHIFT;
	}

	printf("XAxiEthernet_GetVStripMode: done\r\n");
c0015470:	07fec517          	auipc	a0,0x7fec
c0015474:	03050513          	addi	a0,a0,48 # c80014a0 <__rodata_start+0x14a0>
c0015478:	249080ef          	jal	ra,c001dec0 <puts>
}
c001547c:	02c12083          	lw	ra,44(sp)
c0015480:	02812403          	lw	s0,40(sp)
c0015484:	03010113          	addi	sp,sp,48
c0015488:	00008067          	ret

c001548c <XAxiEthernet_SetVTagValue>:
*                   TPID (16b)      priority bit (3b)
*
*****************************************************************************/
int XAxiEthernet_SetVTagValue(XAxiEthernet *InstancePtr, u32 VTagValue,
								int Dir)
{
c001548c:	fe010113          	addi	sp,sp,-32
c0015490:	00112e23          	sw	ra,28(sp)
c0015494:	00812c23          	sw	s0,24(sp)
c0015498:	02010413          	addi	s0,sp,32
c001549c:	fea42623          	sw	a0,-20(s0)
c00154a0:	feb42423          	sw	a1,-24(s0)
c00154a4:	fec42223          	sw	a2,-28(s0)
	Xil_AssertNonvoid(InstancePtr != NULL);
c00154a8:	fec42783          	lw	a5,-20(s0)
c00154ac:	02078463          	beqz	a5,c00154d4 <XAxiEthernet_SetVTagValue+0x48>
c00154b0:	07fed797          	auipc	a5,0x7fed
c00154b4:	46478793          	addi	a5,a5,1124 # c8002914 <Xil_AssertStatus>
c00154b8:	0007a023          	sw	zero,0(a5)
	Xil_AssertNonvoid(InstancePtr->IsReady == XIL_COMPONENT_IS_READY);
c00154bc:	fec42783          	lw	a5,-20(s0)
c00154c0:	0507a703          	lw	a4,80(a5)
c00154c4:	111117b7          	lui	a5,0x11111
c00154c8:	11178793          	addi	a5,a5,273 # 11111111 <_DMEM_LENGTH+0x10911111>
c00154cc:	04f71663          	bne	a4,a5,c0015518 <XAxiEthernet_SetVTagValue+0x8c>
c00154d0:	02c0006f          	j	c00154fc <XAxiEthernet_SetVTagValue+0x70>
	Xil_AssertNonvoid(InstancePtr != NULL);
c00154d4:	46e00593          	li	a1,1134
c00154d8:	07fec517          	auipc	a0,0x7fec
c00154dc:	90c50513          	addi	a0,a0,-1780 # c8000de4 <__rodata_start+0xde4>
c00154e0:	5dc080ef          	jal	ra,c001dabc <Xil_Assert>
c00154e4:	07fed797          	auipc	a5,0x7fed
c00154e8:	43078793          	addi	a5,a5,1072 # c8002914 <Xil_AssertStatus>
c00154ec:	00100713          	li	a4,1
c00154f0:	00e7a023          	sw	a4,0(a5)
c00154f4:	00000793          	li	a5,0
c00154f8:	1a40006f          	j	c001569c <XAxiEthernet_SetVTagValue+0x210>
	Xil_AssertNonvoid(InstancePtr->IsReady == XIL_COMPONENT_IS_READY);
c00154fc:	07fed797          	auipc	a5,0x7fed
c0015500:	41878793          	addi	a5,a5,1048 # c8002914 <Xil_AssertStatus>
c0015504:	0007a023          	sw	zero,0(a5)
	Xil_AssertNonvoid((Dir == XAE_TX) || (Dir == XAE_RX));
c0015508:	fe442703          	lw	a4,-28(s0)
c001550c:	00200793          	li	a5,2
c0015510:	02f70e63          	beq	a4,a5,c001554c <XAxiEthernet_SetVTagValue+0xc0>
c0015514:	02c0006f          	j	c0015540 <XAxiEthernet_SetVTagValue+0xb4>
	Xil_AssertNonvoid(InstancePtr->IsReady == XIL_COMPONENT_IS_READY);
c0015518:	46f00593          	li	a1,1135
c001551c:	07fec517          	auipc	a0,0x7fec
c0015520:	8c850513          	addi	a0,a0,-1848 # c8000de4 <__rodata_start+0xde4>
c0015524:	598080ef          	jal	ra,c001dabc <Xil_Assert>
c0015528:	07fed797          	auipc	a5,0x7fed
c001552c:	3ec78793          	addi	a5,a5,1004 # c8002914 <Xil_AssertStatus>
c0015530:	00100713          	li	a4,1
c0015534:	00e7a023          	sw	a4,0(a5)
c0015538:	00000793          	li	a5,0
c001553c:	1600006f          	j	c001569c <XAxiEthernet_SetVTagValue+0x210>
	Xil_AssertNonvoid((Dir == XAE_TX) || (Dir == XAE_RX));
c0015540:	fe442703          	lw	a4,-28(s0)
c0015544:	00100793          	li	a5,1
c0015548:	02f71463          	bne	a4,a5,c0015570 <XAxiEthernet_SetVTagValue+0xe4>
c001554c:	07fed797          	auipc	a5,0x7fed
c0015550:	3c878793          	addi	a5,a5,968 # c8002914 <Xil_AssertStatus>
c0015554:	0007a023          	sw	zero,0(a5)

	/* The device must be stopped before modifying TX VLAN Tag value */
	if (InstancePtr->IsStarted == XIL_COMPONENT_IS_STARTED) {
c0015558:	fec42783          	lw	a5,-20(s0)
c001555c:	04c7a703          	lw	a4,76(a5)
c0015560:	222227b7          	lui	a5,0x22222
c0015564:	22278793          	addi	a5,a5,546 # 22222222 <_DMEM_LENGTH+0x21a22222>
c0015568:	02f70863          	beq	a4,a5,c0015598 <XAxiEthernet_SetVTagValue+0x10c>
c001556c:	0400006f          	j	c00155ac <XAxiEthernet_SetVTagValue+0x120>
	Xil_AssertNonvoid((Dir == XAE_TX) || (Dir == XAE_RX));
c0015570:	47000593          	li	a1,1136
c0015574:	07fec517          	auipc	a0,0x7fec
c0015578:	87050513          	addi	a0,a0,-1936 # c8000de4 <__rodata_start+0xde4>
c001557c:	540080ef          	jal	ra,c001dabc <Xil_Assert>
c0015580:	07fed797          	auipc	a5,0x7fed
c0015584:	39478793          	addi	a5,a5,916 # c8002914 <Xil_AssertStatus>
c0015588:	00100713          	li	a4,1
c001558c:	00e7a023          	sw	a4,0(a5)
c0015590:	00000793          	li	a5,0
c0015594:	1080006f          	j	c001569c <XAxiEthernet_SetVTagValue+0x210>
		printf(
c0015598:	07fec517          	auipc	a0,0x7fec
c001559c:	f2c50513          	addi	a0,a0,-212 # c80014c4 <__rodata_start+0x14c4>
c00155a0:	121080ef          	jal	ra,c001dec0 <puts>
		"XAxiEthernet_SetVTagValue:returning DEVICE_IS_STARTED\r\n");
		return (XST_DEVICE_IS_STARTED);
c00155a4:	00500793          	li	a5,5
c00155a8:	0f40006f          	j	c001569c <XAxiEthernet_SetVTagValue+0x210>
	}

	/* Check HW capability */
	if (!XAxiEthernet_IsExtFuncCap(InstancePtr)) {
c00155ac:	fec42783          	lw	a5,-20(s0)
c00155b0:	0047a783          	lw	a5,4(a5)
c00155b4:	00078513          	mv	a0,a5
c00155b8:	84cfe0ef          	jal	ra,c0013604 <Xil_In32>
c00155bc:	00050713          	mv	a4,a0
c00155c0:	000017b7          	lui	a5,0x1
c00155c4:	80078793          	addi	a5,a5,-2048 # 800 <_STACK_SIZE-0x800>
c00155c8:	00f777b3          	and	a5,a4,a5
c00155cc:	00079c63          	bnez	a5,c00155e4 <XAxiEthernet_SetVTagValue+0x158>
		printf(
c00155d0:	07fec517          	auipc	a0,0x7fec
c00155d4:	f2c50513          	addi	a0,a0,-212 # c80014fc <__rodata_start+0x14fc>
c00155d8:	0e9080ef          	jal	ra,c001dec0 <puts>
		"XAxiEthernet_SetVTagValue:returning DEVICE_NO_FEATURE\r\n");
		return (XST_NO_FEATURE);
c00155dc:	01300793          	li	a5,19
c00155e0:	0bc0006f          	j	c001569c <XAxiEthernet_SetVTagValue+0x210>
	}

	/* Verify TPID */
	switch (VTagValue >> 16) {
c00155e4:	fe842783          	lw	a5,-24(s0)
c00155e8:	0107d793          	srli	a5,a5,0x10
c00155ec:	00009737          	lui	a4,0x9
c00155f0:	20070713          	addi	a4,a4,512 # 9200 <_STACK_SIZE+0x8200>
c00155f4:	04e78463          	beq	a5,a4,c001563c <XAxiEthernet_SetVTagValue+0x1b0>
c00155f8:	00009737          	lui	a4,0x9
c00155fc:	20070713          	addi	a4,a4,512 # 9200 <_STACK_SIZE+0x8200>
c0015600:	02f76a63          	bltu	a4,a5,c0015634 <XAxiEthernet_SetVTagValue+0x1a8>
c0015604:	00009737          	lui	a4,0x9
c0015608:	10070713          	addi	a4,a4,256 # 9100 <_STACK_SIZE+0x8100>
c001560c:	02e78863          	beq	a5,a4,c001563c <XAxiEthernet_SetVTagValue+0x1b0>
c0015610:	00009737          	lui	a4,0x9
c0015614:	10070713          	addi	a4,a4,256 # 9100 <_STACK_SIZE+0x8100>
c0015618:	00f76e63          	bltu	a4,a5,c0015634 <XAxiEthernet_SetVTagValue+0x1a8>
c001561c:	00008737          	lui	a4,0x8
c0015620:	10070713          	addi	a4,a4,256 # 8100 <_STACK_SIZE+0x7100>
c0015624:	00e78c63          	beq	a5,a4,c001563c <XAxiEthernet_SetVTagValue+0x1b0>
c0015628:	00009737          	lui	a4,0x9
c001562c:	8a870713          	addi	a4,a4,-1880 # 88a8 <_STACK_SIZE+0x78a8>
c0015630:	00e78663          	beq	a5,a4,c001563c <XAxiEthernet_SetVTagValue+0x1b0>
		case 0x88a8:
		case 0x9100:
		case 0x9200:
			break;
		default:
			return (XST_INVALID_PARAM);
c0015634:	00f00793          	li	a5,15
c0015638:	0640006f          	j	c001569c <XAxiEthernet_SetVTagValue+0x210>
			break;
c001563c:	00000013          	nop
	}

	printf("XAxiEthernet_SetVTagValue\r\n");
c0015640:	07fec517          	auipc	a0,0x7fec
c0015644:	ef450513          	addi	a0,a0,-268 # c8001534 <__rodata_start+0x1534>
c0015648:	079080ef          	jal	ra,c001dec0 <puts>

	/* Program HW */
	/* Transmit direction */
	if (XAE_TX == Dir) {
c001564c:	fe442703          	lw	a4,-28(s0)
c0015650:	00200793          	li	a5,2
c0015654:	02f71063          	bne	a4,a5,c0015674 <XAxiEthernet_SetVTagValue+0x1e8>
		XAxiEthernet_WriteReg(InstancePtr->Config.BaseAddress,
c0015658:	fec42783          	lw	a5,-20(s0)
c001565c:	0047a783          	lw	a5,4(a5)
c0015660:	01878793          	addi	a5,a5,24
c0015664:	fe842583          	lw	a1,-24(s0)
c0015668:	00078513          	mv	a0,a5
c001566c:	fc1fd0ef          	jal	ra,c001362c <Xil_Out32>
c0015670:	01c0006f          	j	c001568c <XAxiEthernet_SetVTagValue+0x200>
					XAE_TTAG_OFFSET, VTagValue);
	} else { /* Receive direction */
		XAxiEthernet_WriteReg(InstancePtr->Config.BaseAddress,
c0015674:	fec42783          	lw	a5,-20(s0)
c0015678:	0047a783          	lw	a5,4(a5)
c001567c:	01c78793          	addi	a5,a5,28
c0015680:	fe842583          	lw	a1,-24(s0)
c0015684:	00078513          	mv	a0,a5
c0015688:	fa5fd0ef          	jal	ra,c001362c <Xil_Out32>
					XAE_RTAG_OFFSET, VTagValue);
	}

	printf(
c001568c:	07fec517          	auipc	a0,0x7fec
c0015690:	ec450513          	addi	a0,a0,-316 # c8001550 <__rodata_start+0x1550>
c0015694:	02d080ef          	jal	ra,c001dec0 <puts>
			"XAxiEthernet_SetVTagValue:returning SUCCESS\r\n");

	return (XST_SUCCESS);
c0015698:	00000793          	li	a5,0
}
c001569c:	00078513          	mv	a0,a5
c00156a0:	01c12083          	lw	ra,28(sp)
c00156a4:	01812403          	lw	s0,24(sp)
c00156a8:	02010113          	addi	sp,sp,32
c00156ac:	00008067          	ret

c00156b0 <XAxiEthernet_GetVTagValue>:
*                   TPID (16b)      priority bit (3b)
*
*****************************************************************************/
void XAxiEthernet_GetVTagValue(XAxiEthernet *InstancePtr, u32 *VTagValuePtr,
								int Dir)
{
c00156b0:	fe010113          	addi	sp,sp,-32
c00156b4:	00112e23          	sw	ra,28(sp)
c00156b8:	00812c23          	sw	s0,24(sp)
c00156bc:	02010413          	addi	s0,sp,32
c00156c0:	fea42623          	sw	a0,-20(s0)
c00156c4:	feb42423          	sw	a1,-24(s0)
c00156c8:	fec42223          	sw	a2,-28(s0)
	Xil_AssertVoid(InstancePtr != NULL);
c00156cc:	fec42783          	lw	a5,-20(s0)
c00156d0:	02078463          	beqz	a5,c00156f8 <XAxiEthernet_GetVTagValue+0x48>
c00156d4:	07fed797          	auipc	a5,0x7fed
c00156d8:	24078793          	addi	a5,a5,576 # c8002914 <Xil_AssertStatus>
c00156dc:	0007a023          	sw	zero,0(a5)
	Xil_AssertVoid(InstancePtr->IsReady == XIL_COMPONENT_IS_READY);
c00156e0:	fec42783          	lw	a5,-20(s0)
c00156e4:	0507a703          	lw	a4,80(a5)
c00156e8:	111117b7          	lui	a5,0x11111
c00156ec:	11178793          	addi	a5,a5,273 # 11111111 <_DMEM_LENGTH+0x10911111>
c00156f0:	04f71263          	bne	a4,a5,c0015734 <XAxiEthernet_GetVTagValue+0x84>
c00156f4:	0280006f          	j	c001571c <XAxiEthernet_GetVTagValue+0x6c>
	Xil_AssertVoid(InstancePtr != NULL);
c00156f8:	4bb00593          	li	a1,1211
c00156fc:	07feb517          	auipc	a0,0x7feb
c0015700:	6e850513          	addi	a0,a0,1768 # c8000de4 <__rodata_start+0xde4>
c0015704:	3b8080ef          	jal	ra,c001dabc <Xil_Assert>
c0015708:	07fed797          	auipc	a5,0x7fed
c001570c:	20c78793          	addi	a5,a5,524 # c8002914 <Xil_AssertStatus>
c0015710:	00100713          	li	a4,1
c0015714:	00e7a023          	sw	a4,0(a5)
c0015718:	1280006f          	j	c0015840 <XAxiEthernet_GetVTagValue+0x190>
	Xil_AssertVoid(InstancePtr->IsReady == XIL_COMPONENT_IS_READY);
c001571c:	07fed797          	auipc	a5,0x7fed
c0015720:	1f878793          	addi	a5,a5,504 # c8002914 <Xil_AssertStatus>
c0015724:	0007a023          	sw	zero,0(a5)
	Xil_AssertVoid(VTagValuePtr != NULL);
c0015728:	fe842783          	lw	a5,-24(s0)
c001572c:	04078463          	beqz	a5,c0015774 <XAxiEthernet_GetVTagValue+0xc4>
c0015730:	0280006f          	j	c0015758 <XAxiEthernet_GetVTagValue+0xa8>
	Xil_AssertVoid(InstancePtr->IsReady == XIL_COMPONENT_IS_READY);
c0015734:	4bc00593          	li	a1,1212
c0015738:	07feb517          	auipc	a0,0x7feb
c001573c:	6ac50513          	addi	a0,a0,1708 # c8000de4 <__rodata_start+0xde4>
c0015740:	37c080ef          	jal	ra,c001dabc <Xil_Assert>
c0015744:	07fed797          	auipc	a5,0x7fed
c0015748:	1d078793          	addi	a5,a5,464 # c8002914 <Xil_AssertStatus>
c001574c:	00100713          	li	a4,1
c0015750:	00e7a023          	sw	a4,0(a5)
c0015754:	0ec0006f          	j	c0015840 <XAxiEthernet_GetVTagValue+0x190>
	Xil_AssertVoid(VTagValuePtr != NULL);
c0015758:	07fed797          	auipc	a5,0x7fed
c001575c:	1bc78793          	addi	a5,a5,444 # c8002914 <Xil_AssertStatus>
c0015760:	0007a023          	sw	zero,0(a5)
	Xil_AssertVoid((Dir == XAE_TX) || (Dir == XAE_RX));
c0015764:	fe442703          	lw	a4,-28(s0)
c0015768:	00200793          	li	a5,2
c001576c:	02f70c63          	beq	a4,a5,c00157a4 <XAxiEthernet_GetVTagValue+0xf4>
c0015770:	0280006f          	j	c0015798 <XAxiEthernet_GetVTagValue+0xe8>
	Xil_AssertVoid(VTagValuePtr != NULL);
c0015774:	4bd00593          	li	a1,1213
c0015778:	07feb517          	auipc	a0,0x7feb
c001577c:	66c50513          	addi	a0,a0,1644 # c8000de4 <__rodata_start+0xde4>
c0015780:	33c080ef          	jal	ra,c001dabc <Xil_Assert>
c0015784:	07fed797          	auipc	a5,0x7fed
c0015788:	19078793          	addi	a5,a5,400 # c8002914 <Xil_AssertStatus>
c001578c:	00100713          	li	a4,1
c0015790:	00e7a023          	sw	a4,0(a5)
c0015794:	0ac0006f          	j	c0015840 <XAxiEthernet_GetVTagValue+0x190>
	Xil_AssertVoid((Dir == XAE_TX) || (Dir == XAE_RX));
c0015798:	fe442703          	lw	a4,-28(s0)
c001579c:	00100793          	li	a5,1
c00157a0:	02f71663          	bne	a4,a5,c00157cc <XAxiEthernet_GetVTagValue+0x11c>
c00157a4:	07fed797          	auipc	a5,0x7fed
c00157a8:	17078793          	addi	a5,a5,368 # c8002914 <Xil_AssertStatus>
c00157ac:	0007a023          	sw	zero,0(a5)

	printf("XAxiEthernet_GetVTagValue\r\n");
c00157b0:	07fec517          	auipc	a0,0x7fec
c00157b4:	dd050513          	addi	a0,a0,-560 # c8001580 <__rodata_start+0x1580>
c00157b8:	708080ef          	jal	ra,c001dec0 <puts>

	/* Transmit direction */
	if (XAE_TX == Dir) {
c00157bc:	fe442703          	lw	a4,-28(s0)
c00157c0:	00200793          	li	a5,2
c00157c4:	02f70663          	beq	a4,a5,c00157f0 <XAxiEthernet_GetVTagValue+0x140>
c00157c8:	04c0006f          	j	c0015814 <XAxiEthernet_GetVTagValue+0x164>
	Xil_AssertVoid((Dir == XAE_TX) || (Dir == XAE_RX));
c00157cc:	4be00593          	li	a1,1214
c00157d0:	07feb517          	auipc	a0,0x7feb
c00157d4:	61450513          	addi	a0,a0,1556 # c8000de4 <__rodata_start+0xde4>
c00157d8:	2e4080ef          	jal	ra,c001dabc <Xil_Assert>
c00157dc:	07fed797          	auipc	a5,0x7fed
c00157e0:	13878793          	addi	a5,a5,312 # c8002914 <Xil_AssertStatus>
c00157e4:	00100713          	li	a4,1
c00157e8:	00e7a023          	sw	a4,0(a5)
c00157ec:	0540006f          	j	c0015840 <XAxiEthernet_GetVTagValue+0x190>
		*VTagValuePtr = XAxiEthernet_ReadReg
c00157f0:	fec42783          	lw	a5,-20(s0)
c00157f4:	0047a783          	lw	a5,4(a5)
c00157f8:	01878793          	addi	a5,a5,24
c00157fc:	00078513          	mv	a0,a5
c0015800:	e05fd0ef          	jal	ra,c0013604 <Xil_In32>
c0015804:	00050713          	mv	a4,a0
c0015808:	fe842783          	lw	a5,-24(s0)
c001580c:	00e7a023          	sw	a4,0(a5)
c0015810:	0240006f          	j	c0015834 <XAxiEthernet_GetVTagValue+0x184>
					(InstancePtr->Config.BaseAddress,
							XAE_TTAG_OFFSET);
	}
	else { /* Receive direction */
		*VTagValuePtr = XAxiEthernet_ReadReg(
c0015814:	fec42783          	lw	a5,-20(s0)
c0015818:	0047a783          	lw	a5,4(a5)
c001581c:	01c78793          	addi	a5,a5,28
c0015820:	00078513          	mv	a0,a5
c0015824:	de1fd0ef          	jal	ra,c0013604 <Xil_In32>
c0015828:	00050713          	mv	a4,a0
c001582c:	fe842783          	lw	a5,-24(s0)
c0015830:	00e7a023          	sw	a4,0(a5)
					InstancePtr->Config.BaseAddress,
							XAE_RTAG_OFFSET);
	}

	printf("XAxiEthernet_GetVTagValue: done\r\n");
c0015834:	07fec517          	auipc	a0,0x7fec
c0015838:	d6850513          	addi	a0,a0,-664 # c800159c <__rodata_start+0x159c>
c001583c:	684080ef          	jal	ra,c001dec0 <puts>
}
c0015840:	01c12083          	lw	ra,28(sp)
c0015844:	01812403          	lw	s0,24(sp)
c0015848:	02010113          	addi	sp,sp,32
c001584c:	00008067          	ret

c0015850 <XAxiEthernet_SetVidTable>:
* To disable translation indexed by Entry, Set Vid = Entry.
*
*****************************************************************************/
int XAxiEthernet_SetVidTable(XAxiEthernet *InstancePtr, u32 Entry, u32 Vid,
				u8 Strip, u8 Tag, int Dir)
{
c0015850:	fc010113          	addi	sp,sp,-64
c0015854:	02112e23          	sw	ra,60(sp)
c0015858:	02812c23          	sw	s0,56(sp)
c001585c:	04010413          	addi	s0,sp,64
c0015860:	fca42e23          	sw	a0,-36(s0)
c0015864:	fcb42c23          	sw	a1,-40(s0)
c0015868:	fcc42a23          	sw	a2,-44(s0)
c001586c:	fcf42623          	sw	a5,-52(s0)
c0015870:	00068793          	mv	a5,a3
c0015874:	fcf409a3          	sb	a5,-45(s0)
c0015878:	00070793          	mv	a5,a4
c001587c:	fcf40923          	sb	a5,-46(s0)
	u32 Reg;

	Xil_AssertNonvoid(InstancePtr != NULL);
c0015880:	fdc42783          	lw	a5,-36(s0)
c0015884:	02078463          	beqz	a5,c00158ac <XAxiEthernet_SetVidTable+0x5c>
c0015888:	07fed797          	auipc	a5,0x7fed
c001588c:	08c78793          	addi	a5,a5,140 # c8002914 <Xil_AssertStatus>
c0015890:	0007a023          	sw	zero,0(a5)
	Xil_AssertNonvoid(InstancePtr->IsReady == XIL_COMPONENT_IS_READY);
c0015894:	fdc42783          	lw	a5,-36(s0)
c0015898:	0507a703          	lw	a4,80(a5)
c001589c:	111117b7          	lui	a5,0x11111
c00158a0:	11178793          	addi	a5,a5,273 # 11111111 <_DMEM_LENGTH+0x10911111>
c00158a4:	04f71663          	bne	a4,a5,c00158f0 <XAxiEthernet_SetVidTable+0xa0>
c00158a8:	02c0006f          	j	c00158d4 <XAxiEthernet_SetVidTable+0x84>
	Xil_AssertNonvoid(InstancePtr != NULL);
c00158ac:	4fc00593          	li	a1,1276
c00158b0:	07feb517          	auipc	a0,0x7feb
c00158b4:	53450513          	addi	a0,a0,1332 # c8000de4 <__rodata_start+0xde4>
c00158b8:	204080ef          	jal	ra,c001dabc <Xil_Assert>
c00158bc:	07fed797          	auipc	a5,0x7fed
c00158c0:	05878793          	addi	a5,a5,88 # c8002914 <Xil_AssertStatus>
c00158c4:	00100713          	li	a4,1
c00158c8:	00e7a023          	sw	a4,0(a5)
c00158cc:	00000793          	li	a5,0
c00158d0:	2980006f          	j	c0015b68 <XAxiEthernet_SetVidTable+0x318>
	Xil_AssertNonvoid(InstancePtr->IsReady == XIL_COMPONENT_IS_READY);
c00158d4:	07fed797          	auipc	a5,0x7fed
c00158d8:	04078793          	addi	a5,a5,64 # c8002914 <Xil_AssertStatus>
c00158dc:	0007a023          	sw	zero,0(a5)
	Xil_AssertNonvoid(Entry <= XAE_MAX_VLAN_TABL_ENTRY);
c00158e0:	fd842703          	lw	a4,-40(s0)
c00158e4:	000017b7          	lui	a5,0x1
c00158e8:	04f77663          	bgeu	a4,a5,c0015934 <XAxiEthernet_SetVidTable+0xe4>
c00158ec:	02c0006f          	j	c0015918 <XAxiEthernet_SetVidTable+0xc8>
	Xil_AssertNonvoid(InstancePtr->IsReady == XIL_COMPONENT_IS_READY);
c00158f0:	4fd00593          	li	a1,1277
c00158f4:	07feb517          	auipc	a0,0x7feb
c00158f8:	4f050513          	addi	a0,a0,1264 # c8000de4 <__rodata_start+0xde4>
c00158fc:	1c0080ef          	jal	ra,c001dabc <Xil_Assert>
c0015900:	07fed797          	auipc	a5,0x7fed
c0015904:	01478793          	addi	a5,a5,20 # c8002914 <Xil_AssertStatus>
c0015908:	00100713          	li	a4,1
c001590c:	00e7a023          	sw	a4,0(a5)
c0015910:	00000793          	li	a5,0
c0015914:	2540006f          	j	c0015b68 <XAxiEthernet_SetVidTable+0x318>
	Xil_AssertNonvoid(Entry <= XAE_MAX_VLAN_TABL_ENTRY);
c0015918:	07fed797          	auipc	a5,0x7fed
c001591c:	ffc78793          	addi	a5,a5,-4 # c8002914 <Xil_AssertStatus>
c0015920:	0007a023          	sw	zero,0(a5)
	Xil_AssertNonvoid((Dir == XAE_TX) || (Dir == XAE_RX));
c0015924:	fcc42703          	lw	a4,-52(s0)
c0015928:	00200793          	li	a5,2
c001592c:	02f70e63          	beq	a4,a5,c0015968 <XAxiEthernet_SetVidTable+0x118>
c0015930:	02c0006f          	j	c001595c <XAxiEthernet_SetVidTable+0x10c>
	Xil_AssertNonvoid(Entry <= XAE_MAX_VLAN_TABL_ENTRY);
c0015934:	4fe00593          	li	a1,1278
c0015938:	07feb517          	auipc	a0,0x7feb
c001593c:	4ac50513          	addi	a0,a0,1196 # c8000de4 <__rodata_start+0xde4>
c0015940:	17c080ef          	jal	ra,c001dabc <Xil_Assert>
c0015944:	07fed797          	auipc	a5,0x7fed
c0015948:	fd078793          	addi	a5,a5,-48 # c8002914 <Xil_AssertStatus>
c001594c:	00100713          	li	a4,1
c0015950:	00e7a023          	sw	a4,0(a5)
c0015954:	00000793          	li	a5,0
c0015958:	2100006f          	j	c0015b68 <XAxiEthernet_SetVidTable+0x318>
	Xil_AssertNonvoid((Dir == XAE_TX) || (Dir == XAE_RX));
c001595c:	fcc42703          	lw	a4,-52(s0)
c0015960:	00100793          	li	a5,1
c0015964:	02f71063          	bne	a4,a5,c0015984 <XAxiEthernet_SetVidTable+0x134>
c0015968:	07fed797          	auipc	a5,0x7fed
c001596c:	fac78793          	addi	a5,a5,-84 # c8002914 <Xil_AssertStatus>
c0015970:	0007a023          	sw	zero,0(a5)
	Xil_AssertNonvoid(Vid <= XAE_MAX_VLAN_TABL_ENTRY);
c0015974:	fd442703          	lw	a4,-44(s0)
c0015978:	000017b7          	lui	a5,0x1
c001597c:	02f76863          	bltu	a4,a5,c00159ac <XAxiEthernet_SetVidTable+0x15c>
c0015980:	0480006f          	j	c00159c8 <XAxiEthernet_SetVidTable+0x178>
	Xil_AssertNonvoid((Dir == XAE_TX) || (Dir == XAE_RX));
c0015984:	4ff00593          	li	a1,1279
c0015988:	07feb517          	auipc	a0,0x7feb
c001598c:	45c50513          	addi	a0,a0,1116 # c8000de4 <__rodata_start+0xde4>
c0015990:	12c080ef          	jal	ra,c001dabc <Xil_Assert>
c0015994:	07fed797          	auipc	a5,0x7fed
c0015998:	f8078793          	addi	a5,a5,-128 # c8002914 <Xil_AssertStatus>
c001599c:	00100713          	li	a4,1
c00159a0:	00e7a023          	sw	a4,0(a5)
c00159a4:	00000793          	li	a5,0
c00159a8:	1c00006f          	j	c0015b68 <XAxiEthernet_SetVidTable+0x318>
	Xil_AssertNonvoid(Vid <= XAE_MAX_VLAN_TABL_ENTRY);
c00159ac:	07fed797          	auipc	a5,0x7fed
c00159b0:	f6878793          	addi	a5,a5,-152 # c8002914 <Xil_AssertStatus>
c00159b4:	0007a023          	sw	zero,0(a5)
	Xil_AssertNonvoid(Strip <= XAE_VLAN_TABL_STRP_FLD_LEN);
c00159b8:	fd344703          	lbu	a4,-45(s0)
c00159bc:	00100793          	li	a5,1
c00159c0:	04e7e663          	bltu	a5,a4,c0015a0c <XAxiEthernet_SetVidTable+0x1bc>
c00159c4:	02c0006f          	j	c00159f0 <XAxiEthernet_SetVidTable+0x1a0>
	Xil_AssertNonvoid(Vid <= XAE_MAX_VLAN_TABL_ENTRY);
c00159c8:	50000593          	li	a1,1280
c00159cc:	07feb517          	auipc	a0,0x7feb
c00159d0:	41850513          	addi	a0,a0,1048 # c8000de4 <__rodata_start+0xde4>
c00159d4:	0e8080ef          	jal	ra,c001dabc <Xil_Assert>
c00159d8:	07fed797          	auipc	a5,0x7fed
c00159dc:	f3c78793          	addi	a5,a5,-196 # c8002914 <Xil_AssertStatus>
c00159e0:	00100713          	li	a4,1
c00159e4:	00e7a023          	sw	a4,0(a5)
c00159e8:	00000793          	li	a5,0
c00159ec:	17c0006f          	j	c0015b68 <XAxiEthernet_SetVidTable+0x318>
	Xil_AssertNonvoid(Strip <= XAE_VLAN_TABL_STRP_FLD_LEN);
c00159f0:	07fed797          	auipc	a5,0x7fed
c00159f4:	f2478793          	addi	a5,a5,-220 # c8002914 <Xil_AssertStatus>
c00159f8:	0007a023          	sw	zero,0(a5)
	Xil_AssertNonvoid(Tag <= XAE_VLAN_TABL_TAG_FLD_LEN);
c00159fc:	fd244703          	lbu	a4,-46(s0)
c0015a00:	00100793          	li	a5,1
c0015a04:	04e7ea63          	bltu	a5,a4,c0015a58 <XAxiEthernet_SetVidTable+0x208>
c0015a08:	02c0006f          	j	c0015a34 <XAxiEthernet_SetVidTable+0x1e4>
	Xil_AssertNonvoid(Strip <= XAE_VLAN_TABL_STRP_FLD_LEN);
c0015a0c:	50100593          	li	a1,1281
c0015a10:	07feb517          	auipc	a0,0x7feb
c0015a14:	3d450513          	addi	a0,a0,980 # c8000de4 <__rodata_start+0xde4>
c0015a18:	0a4080ef          	jal	ra,c001dabc <Xil_Assert>
c0015a1c:	07fed797          	auipc	a5,0x7fed
c0015a20:	ef878793          	addi	a5,a5,-264 # c8002914 <Xil_AssertStatus>
c0015a24:	00100713          	li	a4,1
c0015a28:	00e7a023          	sw	a4,0(a5)
c0015a2c:	00000793          	li	a5,0
c0015a30:	1380006f          	j	c0015b68 <XAxiEthernet_SetVidTable+0x318>
	Xil_AssertNonvoid(Tag <= XAE_VLAN_TABL_TAG_FLD_LEN);
c0015a34:	07fed797          	auipc	a5,0x7fed
c0015a38:	ee078793          	addi	a5,a5,-288 # c8002914 <Xil_AssertStatus>
c0015a3c:	0007a023          	sw	zero,0(a5)

	/* The device must be stopped before modify TX VLAN Tag value */
	if (InstancePtr->IsStarted == XIL_COMPONENT_IS_STARTED) {
c0015a40:	fdc42783          	lw	a5,-36(s0)
c0015a44:	04c7a703          	lw	a4,76(a5)
c0015a48:	222227b7          	lui	a5,0x22222
c0015a4c:	22278793          	addi	a5,a5,546 # 22222222 <_DMEM_LENGTH+0x21a22222>
c0015a50:	04f71263          	bne	a4,a5,c0015a94 <XAxiEthernet_SetVidTable+0x244>
c0015a54:	02c0006f          	j	c0015a80 <XAxiEthernet_SetVidTable+0x230>
	Xil_AssertNonvoid(Tag <= XAE_VLAN_TABL_TAG_FLD_LEN);
c0015a58:	50200593          	li	a1,1282
c0015a5c:	07feb517          	auipc	a0,0x7feb
c0015a60:	38850513          	addi	a0,a0,904 # c8000de4 <__rodata_start+0xde4>
c0015a64:	058080ef          	jal	ra,c001dabc <Xil_Assert>
c0015a68:	07fed797          	auipc	a5,0x7fed
c0015a6c:	eac78793          	addi	a5,a5,-340 # c8002914 <Xil_AssertStatus>
c0015a70:	00100713          	li	a4,1
c0015a74:	00e7a023          	sw	a4,0(a5)
c0015a78:	00000793          	li	a5,0
c0015a7c:	0ec0006f          	j	c0015b68 <XAxiEthernet_SetVidTable+0x318>
		printf(
c0015a80:	07fec517          	auipc	a0,0x7fec
c0015a84:	b4050513          	addi	a0,a0,-1216 # c80015c0 <__rodata_start+0x15c0>
c0015a88:	438080ef          	jal	ra,c001dec0 <puts>
		"XAxiEthernet_SetVidTable:returning DEVICE_IS_STARTED\r\n");
		return (XST_DEVICE_IS_STARTED);
c0015a8c:	00500793          	li	a5,5
c0015a90:	0d80006f          	j	c0015b68 <XAxiEthernet_SetVidTable+0x318>
	}

	/* Check HW capability */
	if (!XAxiEthernet_IsExtFuncCap(InstancePtr)) {
c0015a94:	fdc42783          	lw	a5,-36(s0)
c0015a98:	0047a783          	lw	a5,4(a5)
c0015a9c:	00078513          	mv	a0,a5
c0015aa0:	b65fd0ef          	jal	ra,c0013604 <Xil_In32>
c0015aa4:	00050713          	mv	a4,a0
c0015aa8:	000017b7          	lui	a5,0x1
c0015aac:	80078793          	addi	a5,a5,-2048 # 800 <_STACK_SIZE-0x800>
c0015ab0:	00f777b3          	and	a5,a4,a5
c0015ab4:	00079c63          	bnez	a5,c0015acc <XAxiEthernet_SetVidTable+0x27c>
		printf(
c0015ab8:	07fec517          	auipc	a0,0x7fec
c0015abc:	b4050513          	addi	a0,a0,-1216 # c80015f8 <__rodata_start+0x15f8>
c0015ac0:	400080ef          	jal	ra,c001dec0 <puts>
		"XAxiEthernet_SetVidTable:returning DEVICE_NO_FEATURE\r\n");
		return (XST_NO_FEATURE);
c0015ac4:	01300793          	li	a5,19
c0015ac8:	0a00006f          	j	c0015b68 <XAxiEthernet_SetVidTable+0x318>
	}

	printf("XAxiEthernet_SetVidTable\r\n");
c0015acc:	07fec517          	auipc	a0,0x7fec
c0015ad0:	b6450513          	addi	a0,a0,-1180 # c8001630 <__rodata_start+0x1630>
c0015ad4:	3ec080ef          	jal	ra,c001dec0 <puts>

	/* Program HW */
	Reg = (Vid << XAE_VLAN_TABL_VID_START_OFFSET) |
c0015ad8:	fd442783          	lw	a5,-44(s0)
c0015adc:	00279793          	slli	a5,a5,0x2
			(Strip << XAE_VLAN_TABL_STRP_STRT_OFFSET) | Tag;
c0015ae0:	fd344703          	lbu	a4,-45(s0)
c0015ae4:	00171713          	slli	a4,a4,0x1
	Reg = (Vid << XAE_VLAN_TABL_VID_START_OFFSET) |
c0015ae8:	00e7e733          	or	a4,a5,a4
			(Strip << XAE_VLAN_TABL_STRP_STRT_OFFSET) | Tag;
c0015aec:	fd244783          	lbu	a5,-46(s0)
	Reg = (Vid << XAE_VLAN_TABL_VID_START_OFFSET) |
c0015af0:	00f767b3          	or	a5,a4,a5
c0015af4:	fef42623          	sw	a5,-20(s0)
	/* Transmit direction */
	if (XAE_TX == Dir) {
c0015af8:	fcc42703          	lw	a4,-52(s0)
c0015afc:	00200793          	li	a5,2
c0015b00:	02f71863          	bne	a4,a5,c0015b30 <XAxiEthernet_SetVidTable+0x2e0>
		XAxiEthernet_WriteReg(InstancePtr->Config.BaseAddress,
c0015b04:	fdc42783          	lw	a5,-36(s0)
c0015b08:	0047a703          	lw	a4,4(a5)
c0015b0c:	fd842783          	lw	a5,-40(s0)
c0015b10:	00279793          	slli	a5,a5,0x2
c0015b14:	00f70733          	add	a4,a4,a5
c0015b18:	000047b7          	lui	a5,0x4
c0015b1c:	00f707b3          	add	a5,a4,a5
c0015b20:	fec42583          	lw	a1,-20(s0)
c0015b24:	00078513          	mv	a0,a5
c0015b28:	b05fd0ef          	jal	ra,c001362c <Xil_Out32>
c0015b2c:	02c0006f          	j	c0015b58 <XAxiEthernet_SetVidTable+0x308>
			XAE_TX_VLAN_DATA_OFFSET +
			(Entry << XAE_VLAN_TABL_VID_START_OFFSET), Reg);
	} else { /* Receive direction */
		XAxiEthernet_WriteReg(InstancePtr->Config.BaseAddress,
c0015b30:	fdc42783          	lw	a5,-36(s0)
c0015b34:	0047a703          	lw	a4,4(a5) # 4004 <_STACK_SIZE+0x3004>
c0015b38:	fd842783          	lw	a5,-40(s0)
c0015b3c:	00279793          	slli	a5,a5,0x2
c0015b40:	00f70733          	add	a4,a4,a5
c0015b44:	000087b7          	lui	a5,0x8
c0015b48:	00f707b3          	add	a5,a4,a5
c0015b4c:	fec42583          	lw	a1,-20(s0)
c0015b50:	00078513          	mv	a0,a5
c0015b54:	ad9fd0ef          	jal	ra,c001362c <Xil_Out32>
			XAE_RX_VLAN_DATA_OFFSET +
			(Entry << XAE_VLAN_TABL_VID_START_OFFSET), Reg);
	}

	printf(
c0015b58:	07fec517          	auipc	a0,0x7fec
c0015b5c:	af450513          	addi	a0,a0,-1292 # c800164c <__rodata_start+0x164c>
c0015b60:	360080ef          	jal	ra,c001dec0 <puts>
			"XAxiEthernet_SetVidTable: returning SUCCESS\r\n");
	return (XST_SUCCESS);
c0015b64:	00000793          	li	a5,0
}
c0015b68:	00078513          	mv	a0,a5
c0015b6c:	03c12083          	lw	ra,60(sp)
c0015b70:	03812403          	lw	s0,56(sp)
c0015b74:	04010113          	addi	sp,sp,64
c0015b78:	00008067          	ret

c0015b7c <XAxiEthernet_GetVidTable>:
*                               VLAN strip enable bit
*
*****************************************************************************/
void XAxiEthernet_GetVidTable(XAxiEthernet *InstancePtr, u32 Entry,
			u32 *VidPtr, u8 *StripPtr, u8 *TagPtr, int Dir)
{
c0015b7c:	fc010113          	addi	sp,sp,-64
c0015b80:	02112e23          	sw	ra,60(sp)
c0015b84:	02812c23          	sw	s0,56(sp)
c0015b88:	04010413          	addi	s0,sp,64
c0015b8c:	fca42e23          	sw	a0,-36(s0)
c0015b90:	fcb42c23          	sw	a1,-40(s0)
c0015b94:	fcc42a23          	sw	a2,-44(s0)
c0015b98:	fcd42823          	sw	a3,-48(s0)
c0015b9c:	fce42623          	sw	a4,-52(s0)
c0015ba0:	fcf42423          	sw	a5,-56(s0)
	u32 Reg;

	Xil_AssertVoid(InstancePtr != NULL);
c0015ba4:	fdc42783          	lw	a5,-36(s0)
c0015ba8:	02078463          	beqz	a5,c0015bd0 <XAxiEthernet_GetVidTable+0x54>
c0015bac:	07fed797          	auipc	a5,0x7fed
c0015bb0:	d6878793          	addi	a5,a5,-664 # c8002914 <Xil_AssertStatus>
c0015bb4:	0007a023          	sw	zero,0(a5)
	Xil_AssertVoid(InstancePtr->IsReady == XIL_COMPONENT_IS_READY);
c0015bb8:	fdc42783          	lw	a5,-36(s0)
c0015bbc:	0507a703          	lw	a4,80(a5)
c0015bc0:	111117b7          	lui	a5,0x11111
c0015bc4:	11178793          	addi	a5,a5,273 # 11111111 <_DMEM_LENGTH+0x10911111>
c0015bc8:	04f71463          	bne	a4,a5,c0015c10 <XAxiEthernet_GetVidTable+0x94>
c0015bcc:	0280006f          	j	c0015bf4 <XAxiEthernet_GetVidTable+0x78>
	Xil_AssertVoid(InstancePtr != NULL);
c0015bd0:	55000593          	li	a1,1360
c0015bd4:	07feb517          	auipc	a0,0x7feb
c0015bd8:	21050513          	addi	a0,a0,528 # c8000de4 <__rodata_start+0xde4>
c0015bdc:	6e1070ef          	jal	ra,c001dabc <Xil_Assert>
c0015be0:	07fed797          	auipc	a5,0x7fed
c0015be4:	d3478793          	addi	a5,a5,-716 # c8002914 <Xil_AssertStatus>
c0015be8:	00100713          	li	a4,1
c0015bec:	00e7a023          	sw	a4,0(a5)
c0015bf0:	2340006f          	j	c0015e24 <XAxiEthernet_GetVidTable+0x2a8>
	Xil_AssertVoid(InstancePtr->IsReady == XIL_COMPONENT_IS_READY);
c0015bf4:	07fed797          	auipc	a5,0x7fed
c0015bf8:	d2078793          	addi	a5,a5,-736 # c8002914 <Xil_AssertStatus>
c0015bfc:	0007a023          	sw	zero,0(a5)
	Xil_AssertVoid(Entry <= XAE_MAX_VLAN_TABL_ENTRY);
c0015c00:	fd842703          	lw	a4,-40(s0)
c0015c04:	000017b7          	lui	a5,0x1
c0015c08:	04f77263          	bgeu	a4,a5,c0015c4c <XAxiEthernet_GetVidTable+0xd0>
c0015c0c:	0280006f          	j	c0015c34 <XAxiEthernet_GetVidTable+0xb8>
	Xil_AssertVoid(InstancePtr->IsReady == XIL_COMPONENT_IS_READY);
c0015c10:	55100593          	li	a1,1361
c0015c14:	07feb517          	auipc	a0,0x7feb
c0015c18:	1d050513          	addi	a0,a0,464 # c8000de4 <__rodata_start+0xde4>
c0015c1c:	6a1070ef          	jal	ra,c001dabc <Xil_Assert>
c0015c20:	07fed797          	auipc	a5,0x7fed
c0015c24:	cf478793          	addi	a5,a5,-780 # c8002914 <Xil_AssertStatus>
c0015c28:	00100713          	li	a4,1
c0015c2c:	00e7a023          	sw	a4,0(a5)
c0015c30:	1f40006f          	j	c0015e24 <XAxiEthernet_GetVidTable+0x2a8>
	Xil_AssertVoid(Entry <= XAE_MAX_VLAN_TABL_ENTRY);
c0015c34:	07fed797          	auipc	a5,0x7fed
c0015c38:	ce078793          	addi	a5,a5,-800 # c8002914 <Xil_AssertStatus>
c0015c3c:	0007a023          	sw	zero,0(a5)
	Xil_AssertVoid(VidPtr != NULL);
c0015c40:	fd442783          	lw	a5,-44(s0)
c0015c44:	04078263          	beqz	a5,c0015c88 <XAxiEthernet_GetVidTable+0x10c>
c0015c48:	0280006f          	j	c0015c70 <XAxiEthernet_GetVidTable+0xf4>
	Xil_AssertVoid(Entry <= XAE_MAX_VLAN_TABL_ENTRY);
c0015c4c:	55200593          	li	a1,1362
c0015c50:	07feb517          	auipc	a0,0x7feb
c0015c54:	19450513          	addi	a0,a0,404 # c8000de4 <__rodata_start+0xde4>
c0015c58:	665070ef          	jal	ra,c001dabc <Xil_Assert>
c0015c5c:	07fed797          	auipc	a5,0x7fed
c0015c60:	cb878793          	addi	a5,a5,-840 # c8002914 <Xil_AssertStatus>
c0015c64:	00100713          	li	a4,1
c0015c68:	00e7a023          	sw	a4,0(a5)
c0015c6c:	1b80006f          	j	c0015e24 <XAxiEthernet_GetVidTable+0x2a8>
	Xil_AssertVoid(VidPtr != NULL);
c0015c70:	07fed797          	auipc	a5,0x7fed
c0015c74:	ca478793          	addi	a5,a5,-860 # c8002914 <Xil_AssertStatus>
c0015c78:	0007a023          	sw	zero,0(a5)
	Xil_AssertVoid(StripPtr != NULL);
c0015c7c:	fd042783          	lw	a5,-48(s0)
c0015c80:	04078263          	beqz	a5,c0015cc4 <XAxiEthernet_GetVidTable+0x148>
c0015c84:	0280006f          	j	c0015cac <XAxiEthernet_GetVidTable+0x130>
	Xil_AssertVoid(VidPtr != NULL);
c0015c88:	55300593          	li	a1,1363
c0015c8c:	07feb517          	auipc	a0,0x7feb
c0015c90:	15850513          	addi	a0,a0,344 # c8000de4 <__rodata_start+0xde4>
c0015c94:	629070ef          	jal	ra,c001dabc <Xil_Assert>
c0015c98:	07fed797          	auipc	a5,0x7fed
c0015c9c:	c7c78793          	addi	a5,a5,-900 # c8002914 <Xil_AssertStatus>
c0015ca0:	00100713          	li	a4,1
c0015ca4:	00e7a023          	sw	a4,0(a5)
c0015ca8:	17c0006f          	j	c0015e24 <XAxiEthernet_GetVidTable+0x2a8>
	Xil_AssertVoid(StripPtr != NULL);
c0015cac:	07fed797          	auipc	a5,0x7fed
c0015cb0:	c6878793          	addi	a5,a5,-920 # c8002914 <Xil_AssertStatus>
c0015cb4:	0007a023          	sw	zero,0(a5)
	Xil_AssertVoid(TagPtr != NULL);
c0015cb8:	fcc42783          	lw	a5,-52(s0)
c0015cbc:	04078463          	beqz	a5,c0015d04 <XAxiEthernet_GetVidTable+0x188>
c0015cc0:	0280006f          	j	c0015ce8 <XAxiEthernet_GetVidTable+0x16c>
	Xil_AssertVoid(StripPtr != NULL);
c0015cc4:	55400593          	li	a1,1364
c0015cc8:	07feb517          	auipc	a0,0x7feb
c0015ccc:	11c50513          	addi	a0,a0,284 # c8000de4 <__rodata_start+0xde4>
c0015cd0:	5ed070ef          	jal	ra,c001dabc <Xil_Assert>
c0015cd4:	07fed797          	auipc	a5,0x7fed
c0015cd8:	c4078793          	addi	a5,a5,-960 # c8002914 <Xil_AssertStatus>
c0015cdc:	00100713          	li	a4,1
c0015ce0:	00e7a023          	sw	a4,0(a5)
c0015ce4:	1400006f          	j	c0015e24 <XAxiEthernet_GetVidTable+0x2a8>
	Xil_AssertVoid(TagPtr != NULL);
c0015ce8:	07fed797          	auipc	a5,0x7fed
c0015cec:	c2c78793          	addi	a5,a5,-980 # c8002914 <Xil_AssertStatus>
c0015cf0:	0007a023          	sw	zero,0(a5)
	Xil_AssertVoid((Dir == XAE_TX) || (Dir == XAE_RX));
c0015cf4:	fc842703          	lw	a4,-56(s0)
c0015cf8:	00200793          	li	a5,2
c0015cfc:	02f70c63          	beq	a4,a5,c0015d34 <XAxiEthernet_GetVidTable+0x1b8>
c0015d00:	0280006f          	j	c0015d28 <XAxiEthernet_GetVidTable+0x1ac>
	Xil_AssertVoid(TagPtr != NULL);
c0015d04:	55500593          	li	a1,1365
c0015d08:	07feb517          	auipc	a0,0x7feb
c0015d0c:	0dc50513          	addi	a0,a0,220 # c8000de4 <__rodata_start+0xde4>
c0015d10:	5ad070ef          	jal	ra,c001dabc <Xil_Assert>
c0015d14:	07fed797          	auipc	a5,0x7fed
c0015d18:	c0078793          	addi	a5,a5,-1024 # c8002914 <Xil_AssertStatus>
c0015d1c:	00100713          	li	a4,1
c0015d20:	00e7a023          	sw	a4,0(a5)
c0015d24:	1000006f          	j	c0015e24 <XAxiEthernet_GetVidTable+0x2a8>
	Xil_AssertVoid((Dir == XAE_TX) || (Dir == XAE_RX));
c0015d28:	fc842703          	lw	a4,-56(s0)
c0015d2c:	00100793          	li	a5,1
c0015d30:	02f71663          	bne	a4,a5,c0015d5c <XAxiEthernet_GetVidTable+0x1e0>
c0015d34:	07fed797          	auipc	a5,0x7fed
c0015d38:	be078793          	addi	a5,a5,-1056 # c8002914 <Xil_AssertStatus>
c0015d3c:	0007a023          	sw	zero,0(a5)

	printf("XAxiEthernet_GetVidTable\r\n");
c0015d40:	07fec517          	auipc	a0,0x7fec
c0015d44:	93c50513          	addi	a0,a0,-1732 # c800167c <__rodata_start+0x167c>
c0015d48:	178080ef          	jal	ra,c001dec0 <puts>

	/* Transmit direction */
	if (XAE_TX == Dir) {
c0015d4c:	fc842703          	lw	a4,-56(s0)
c0015d50:	00200793          	li	a5,2
c0015d54:	02f70663          	beq	a4,a5,c0015d80 <XAxiEthernet_GetVidTable+0x204>
c0015d58:	0540006f          	j	c0015dac <XAxiEthernet_GetVidTable+0x230>
	Xil_AssertVoid((Dir == XAE_TX) || (Dir == XAE_RX));
c0015d5c:	55600593          	li	a1,1366
c0015d60:	07feb517          	auipc	a0,0x7feb
c0015d64:	08450513          	addi	a0,a0,132 # c8000de4 <__rodata_start+0xde4>
c0015d68:	555070ef          	jal	ra,c001dabc <Xil_Assert>
c0015d6c:	07fed797          	auipc	a5,0x7fed
c0015d70:	ba878793          	addi	a5,a5,-1112 # c8002914 <Xil_AssertStatus>
c0015d74:	00100713          	li	a4,1
c0015d78:	00e7a023          	sw	a4,0(a5)
c0015d7c:	0a80006f          	j	c0015e24 <XAxiEthernet_GetVidTable+0x2a8>
		Reg = XAxiEthernet_ReadReg(InstancePtr->Config.BaseAddress,
c0015d80:	fdc42783          	lw	a5,-36(s0)
c0015d84:	0047a703          	lw	a4,4(a5)
c0015d88:	fd842783          	lw	a5,-40(s0)
c0015d8c:	00279793          	slli	a5,a5,0x2
c0015d90:	00f70733          	add	a4,a4,a5
c0015d94:	000047b7          	lui	a5,0x4
c0015d98:	00f707b3          	add	a5,a4,a5
c0015d9c:	00078513          	mv	a0,a5
c0015da0:	865fd0ef          	jal	ra,c0013604 <Xil_In32>
c0015da4:	fea42623          	sw	a0,-20(s0)
c0015da8:	02c0006f          	j	c0015dd4 <XAxiEthernet_GetVidTable+0x258>
			XAE_TX_VLAN_DATA_OFFSET +
				(Entry << XAE_VLAN_TABL_VID_START_OFFSET));
	} else { /* Receive direction */
		Reg = XAxiEthernet_ReadReg(InstancePtr->Config.BaseAddress,
c0015dac:	fdc42783          	lw	a5,-36(s0)
c0015db0:	0047a703          	lw	a4,4(a5) # 4004 <_STACK_SIZE+0x3004>
c0015db4:	fd842783          	lw	a5,-40(s0)
c0015db8:	00279793          	slli	a5,a5,0x2
c0015dbc:	00f70733          	add	a4,a4,a5
c0015dc0:	000087b7          	lui	a5,0x8
c0015dc4:	00f707b3          	add	a5,a4,a5
c0015dc8:	00078513          	mv	a0,a5
c0015dcc:	839fd0ef          	jal	ra,c0013604 <Xil_In32>
c0015dd0:	fea42623          	sw	a0,-20(s0)
			XAE_RX_VLAN_DATA_OFFSET +
				(Entry << XAE_VLAN_TABL_VID_START_OFFSET));
	}

	*VidPtr   = (Reg >> XAE_VLAN_TABL_VID_START_OFFSET);
c0015dd4:	fec42783          	lw	a5,-20(s0)
c0015dd8:	0027d713          	srli	a4,a5,0x2
c0015ddc:	fd442783          	lw	a5,-44(s0)
c0015de0:	00e7a023          	sw	a4,0(a5) # 8000 <_STACK_SIZE+0x7000>
	*StripPtr = (Reg >> XAE_VLAN_TABL_STRP_STRT_OFFSET) &
c0015de4:	fec42783          	lw	a5,-20(s0)
c0015de8:	0017d793          	srli	a5,a5,0x1
c0015dec:	0ff7f793          	andi	a5,a5,255
c0015df0:	0017f793          	andi	a5,a5,1
c0015df4:	0ff7f713          	andi	a4,a5,255
c0015df8:	fd042783          	lw	a5,-48(s0)
c0015dfc:	00e78023          	sb	a4,0(a5)
					XAE_VLAN_TABL_STRP_ENTRY_MASK;
	*TagPtr   = Reg & XAE_VLAN_TABL_TAG_ENTRY_MASK;
c0015e00:	fec42783          	lw	a5,-20(s0)
c0015e04:	0ff7f793          	andi	a5,a5,255
c0015e08:	0017f793          	andi	a5,a5,1
c0015e0c:	0ff7f713          	andi	a4,a5,255
c0015e10:	fcc42783          	lw	a5,-52(s0)
c0015e14:	00e78023          	sb	a4,0(a5)

	printf("XAxiEthernet_GetVidTable: done\r\n");
c0015e18:	07fec517          	auipc	a0,0x7fec
c0015e1c:	88050513          	addi	a0,a0,-1920 # c8001698 <__rodata_start+0x1698>
c0015e20:	0a0080ef          	jal	ra,c001dec0 <puts>
}
c0015e24:	03c12083          	lw	ra,60(sp)
c0015e28:	03812403          	lw	s0,56(sp)
c0015e2c:	04010113          	addi	sp,sp,64
c0015e30:	00008067          	ret

c0015e34 <XAxiEthernet_AddExtMulticastGroup>:
* this table appropriately.
*
*****************************************************************************/
int XAxiEthernet_AddExtMulticastGroup(XAxiEthernet *InstancePtr,
							void *AddressPtr)
{
c0015e34:	fd010113          	addi	sp,sp,-48
c0015e38:	02112623          	sw	ra,44(sp)
c0015e3c:	02812423          	sw	s0,40(sp)
c0015e40:	03010413          	addi	s0,sp,48
c0015e44:	fca42e23          	sw	a0,-36(s0)
c0015e48:	fcb42c23          	sw	a1,-40(s0)
	u32 Loc;

	Xil_AssertNonvoid(InstancePtr != NULL);
c0015e4c:	fdc42783          	lw	a5,-36(s0)
c0015e50:	02078463          	beqz	a5,c0015e78 <XAxiEthernet_AddExtMulticastGroup+0x44>
c0015e54:	07fed797          	auipc	a5,0x7fed
c0015e58:	ac078793          	addi	a5,a5,-1344 # c8002914 <Xil_AssertStatus>
c0015e5c:	0007a023          	sw	zero,0(a5)
	Xil_AssertNonvoid(InstancePtr->IsReady == XIL_COMPONENT_IS_READY);
c0015e60:	fdc42783          	lw	a5,-36(s0)
c0015e64:	0507a703          	lw	a4,80(a5)
c0015e68:	111117b7          	lui	a5,0x11111
c0015e6c:	11178793          	addi	a5,a5,273 # 11111111 <_DMEM_LENGTH+0x10911111>
c0015e70:	04f71463          	bne	a4,a5,c0015eb8 <XAxiEthernet_AddExtMulticastGroup+0x84>
c0015e74:	02c0006f          	j	c0015ea0 <XAxiEthernet_AddExtMulticastGroup+0x6c>
	Xil_AssertNonvoid(InstancePtr != NULL);
c0015e78:	59e00593          	li	a1,1438
c0015e7c:	07feb517          	auipc	a0,0x7feb
c0015e80:	f6850513          	addi	a0,a0,-152 # c8000de4 <__rodata_start+0xde4>
c0015e84:	439070ef          	jal	ra,c001dabc <Xil_Assert>
c0015e88:	07fed797          	auipc	a5,0x7fed
c0015e8c:	a8c78793          	addi	a5,a5,-1396 # c8002914 <Xil_AssertStatus>
c0015e90:	00100713          	li	a4,1
c0015e94:	00e7a023          	sw	a4,0(a5)
c0015e98:	00000793          	li	a5,0
c0015e9c:	1dc0006f          	j	c0016078 <XAxiEthernet_AddExtMulticastGroup+0x244>
	Xil_AssertNonvoid(InstancePtr->IsReady == XIL_COMPONENT_IS_READY);
c0015ea0:	07fed797          	auipc	a5,0x7fed
c0015ea4:	a7478793          	addi	a5,a5,-1420 # c8002914 <Xil_AssertStatus>
c0015ea8:	0007a023          	sw	zero,0(a5)
	Xil_AssertNonvoid(AddressPtr != NULL);
c0015eac:	fd842783          	lw	a5,-40(s0)
c0015eb0:	06078463          	beqz	a5,c0015f18 <XAxiEthernet_AddExtMulticastGroup+0xe4>
c0015eb4:	02c0006f          	j	c0015ee0 <XAxiEthernet_AddExtMulticastGroup+0xac>
	Xil_AssertNonvoid(InstancePtr->IsReady == XIL_COMPONENT_IS_READY);
c0015eb8:	59f00593          	li	a1,1439
c0015ebc:	07feb517          	auipc	a0,0x7feb
c0015ec0:	f2850513          	addi	a0,a0,-216 # c8000de4 <__rodata_start+0xde4>
c0015ec4:	3f9070ef          	jal	ra,c001dabc <Xil_Assert>
c0015ec8:	07fed797          	auipc	a5,0x7fed
c0015ecc:	a4c78793          	addi	a5,a5,-1460 # c8002914 <Xil_AssertStatus>
c0015ed0:	00100713          	li	a4,1
c0015ed4:	00e7a023          	sw	a4,0(a5)
c0015ed8:	00000793          	li	a5,0
c0015edc:	19c0006f          	j	c0016078 <XAxiEthernet_AddExtMulticastGroup+0x244>
	Xil_AssertNonvoid(AddressPtr != NULL);
c0015ee0:	07fed797          	auipc	a5,0x7fed
c0015ee4:	a3478793          	addi	a5,a5,-1484 # c8002914 <Xil_AssertStatus>
c0015ee8:	0007a023          	sw	zero,0(a5)

	u8 *Aptr = (u8 *) AddressPtr;
c0015eec:	fd842783          	lw	a5,-40(s0)
c0015ef0:	fef42623          	sw	a5,-20(s0)
	printf("XAxiEthernet_AddExtMulticastGroup\r\n");
c0015ef4:	07feb517          	auipc	a0,0x7feb
c0015ef8:	7c450513          	addi	a0,a0,1988 # c80016b8 <__rodata_start+0x16b8>
c0015efc:	7c5070ef          	jal	ra,c001dec0 <puts>

	/*
	 * The device must be stopped before setting the multicast table.
	 */
	if (InstancePtr->IsStarted == XIL_COMPONENT_IS_STARTED) {
c0015f00:	fdc42783          	lw	a5,-36(s0)
c0015f04:	04c7a703          	lw	a4,76(a5)
c0015f08:	222227b7          	lui	a5,0x22222
c0015f0c:	22278793          	addi	a5,a5,546 # 22222222 <_DMEM_LENGTH+0x21a22222>
c0015f10:	04f71263          	bne	a4,a5,c0015f54 <XAxiEthernet_AddExtMulticastGroup+0x120>
c0015f14:	02c0006f          	j	c0015f40 <XAxiEthernet_AddExtMulticastGroup+0x10c>
	Xil_AssertNonvoid(AddressPtr != NULL);
c0015f18:	5a000593          	li	a1,1440
c0015f1c:	07feb517          	auipc	a0,0x7feb
c0015f20:	ec850513          	addi	a0,a0,-312 # c8000de4 <__rodata_start+0xde4>
c0015f24:	399070ef          	jal	ra,c001dabc <Xil_Assert>
c0015f28:	07fed797          	auipc	a5,0x7fed
c0015f2c:	9ec78793          	addi	a5,a5,-1556 # c8002914 <Xil_AssertStatus>
c0015f30:	00100713          	li	a4,1
c0015f34:	00e7a023          	sw	a4,0(a5)
c0015f38:	00000793          	li	a5,0
c0015f3c:	13c0006f          	j	c0016078 <XAxiEthernet_AddExtMulticastGroup+0x244>
		printf(
c0015f40:	07feb517          	auipc	a0,0x7feb
c0015f44:	79c50513          	addi	a0,a0,1948 # c80016dc <__rodata_start+0x16dc>
c0015f48:	779070ef          	jal	ra,c001dec0 <puts>
		"XAxiEthernet_AddExtMulticastGroup:returning DEVICE_IS_STARTED\r\n");

		return (XST_DEVICE_IS_STARTED);
c0015f4c:	00500793          	li	a5,5
c0015f50:	1280006f          	j	c0016078 <XAxiEthernet_AddExtMulticastGroup+0x244>
	}

	/* Check HW capability */
	if (!XAxiEthernet_IsExtFuncCap(InstancePtr) ||
c0015f54:	fdc42783          	lw	a5,-36(s0)
c0015f58:	0047a783          	lw	a5,4(a5)
c0015f5c:	00078513          	mv	a0,a5
c0015f60:	ea4fd0ef          	jal	ra,c0013604 <Xil_In32>
c0015f64:	00050713          	mv	a4,a0
c0015f68:	000017b7          	lui	a5,0x1
c0015f6c:	80078793          	addi	a5,a5,-2048 # 800 <_STACK_SIZE-0x800>
c0015f70:	00f777b3          	and	a5,a4,a5
c0015f74:	02078263          	beqz	a5,c0015f98 <XAxiEthernet_AddExtMulticastGroup+0x164>
		!XAxiEthernet_IsExtMcastEnable(InstancePtr)) {
c0015f78:	fdc42783          	lw	a5,-36(s0)
c0015f7c:	0047a783          	lw	a5,4(a5)
c0015f80:	00078513          	mv	a0,a5
c0015f84:	e80fd0ef          	jal	ra,c0013604 <Xil_In32>
c0015f88:	00050713          	mv	a4,a0
c0015f8c:	000017b7          	lui	a5,0x1
c0015f90:	00f777b3          	and	a5,a4,a5
	if (!XAxiEthernet_IsExtFuncCap(InstancePtr) ||
c0015f94:	00079c63          	bnez	a5,c0015fac <XAxiEthernet_AddExtMulticastGroup+0x178>
		printf(
c0015f98:	07feb517          	auipc	a0,0x7feb
c0015f9c:	78450513          	addi	a0,a0,1924 # c800171c <__rodata_start+0x171c>
c0015fa0:	721070ef          	jal	ra,c001dec0 <puts>
		"XAxiEthernet_AddExtMulticastGroup:returning DEVICE_NO_FEATURE\r\n");
		return (XST_NO_FEATURE);
c0015fa4:	01300793          	li	a5,19
c0015fa8:	0d00006f          	j	c0016078 <XAxiEthernet_AddExtMulticastGroup+0x244>
	/*
	 * Verify if address is a good/valid multicast address, between
	 * 01:00:5E:00:00:00 to 01:00:5E:7F:FF:FF per RFC1112.
	 * This address is referenced to be index to the table.
	 */
	if ((0x01 != Aptr[0]) || (0x00 != Aptr[1]) || (0x5e != Aptr[2]) ||
c0015fac:	fec42783          	lw	a5,-20(s0)
c0015fb0:	0007c703          	lbu	a4,0(a5) # 1000 <_STACK_SIZE>
c0015fb4:	00100793          	li	a5,1
c0015fb8:	04f71063          	bne	a4,a5,c0015ff8 <XAxiEthernet_AddExtMulticastGroup+0x1c4>
c0015fbc:	fec42783          	lw	a5,-20(s0)
c0015fc0:	00178793          	addi	a5,a5,1
c0015fc4:	0007c783          	lbu	a5,0(a5)
c0015fc8:	02079863          	bnez	a5,c0015ff8 <XAxiEthernet_AddExtMulticastGroup+0x1c4>
c0015fcc:	fec42783          	lw	a5,-20(s0)
c0015fd0:	00278793          	addi	a5,a5,2
c0015fd4:	0007c703          	lbu	a4,0(a5)
c0015fd8:	05e00793          	li	a5,94
c0015fdc:	00f71e63          	bne	a4,a5,c0015ff8 <XAxiEthernet_AddExtMulticastGroup+0x1c4>
		(0x0 != (Aptr[3] & 0x80)))
c0015fe0:	fec42783          	lw	a5,-20(s0)
c0015fe4:	00378793          	addi	a5,a5,3
c0015fe8:	0007c783          	lbu	a5,0(a5)
c0015fec:	01879793          	slli	a5,a5,0x18
c0015ff0:	4187d793          	srai	a5,a5,0x18
	if ((0x01 != Aptr[0]) || (0x00 != Aptr[1]) || (0x5e != Aptr[2]) ||
c0015ff4:	0007d663          	bgez	a5,c0016000 <XAxiEthernet_AddExtMulticastGroup+0x1cc>
		return (XST_INVALID_PARAM);
c0015ff8:	00f00793          	li	a5,15
c0015ffc:	07c0006f          	j	c0016078 <XAxiEthernet_AddExtMulticastGroup+0x244>
	/*
	 * Program hardware table, index : bit 22-8. Bit 23 is 0,
	 * when passed the if statement above.
	 * note: if the index/bits changed, need to revisit calculation.
	 */
	Loc  = Aptr[3];
c0016000:	fec42783          	lw	a5,-20(s0)
c0016004:	00378793          	addi	a5,a5,3
c0016008:	0007c783          	lbu	a5,0(a5)
c001600c:	fef42423          	sw	a5,-24(s0)
	Loc  = Loc << 8;
c0016010:	fe842783          	lw	a5,-24(s0)
c0016014:	00879793          	slli	a5,a5,0x8
c0016018:	fef42423          	sw	a5,-24(s0)
	Loc |= Aptr[4];
c001601c:	fec42783          	lw	a5,-20(s0)
c0016020:	00478793          	addi	a5,a5,4
c0016024:	0007c783          	lbu	a5,0(a5)
c0016028:	00078713          	mv	a4,a5
c001602c:	fe842783          	lw	a5,-24(s0)
c0016030:	00e7e7b3          	or	a5,a5,a4
c0016034:	fef42423          	sw	a5,-24(s0)

	/* Word aligned address access */
	Loc  = Loc << 2;
c0016038:	fe842783          	lw	a5,-24(s0)
c001603c:	00279793          	slli	a5,a5,0x2
c0016040:	fef42423          	sw	a5,-24(s0)

	XAxiEthernet_WriteReg(InstancePtr->Config.BaseAddress,
c0016044:	fdc42783          	lw	a5,-36(s0)
c0016048:	0047a703          	lw	a4,4(a5)
c001604c:	fe842783          	lw	a5,-24(s0)
c0016050:	00f70733          	add	a4,a4,a5
c0016054:	000207b7          	lui	a5,0x20
c0016058:	00f707b3          	add	a5,a4,a5
c001605c:	00100593          	li	a1,1
c0016060:	00078513          	mv	a0,a5
c0016064:	dc8fd0ef          	jal	ra,c001362c <Xil_Out32>
			XAE_MCAST_TABLE_OFFSET + Loc, 0x01);

	printf(
c0016068:	07feb517          	auipc	a0,0x7feb
c001606c:	6f450513          	addi	a0,a0,1780 # c800175c <__rodata_start+0x175c>
c0016070:	651070ef          	jal	ra,c001dec0 <puts>
		"XAxiEthernet_AddExtMulticastGroup: returning SUCCESS\r\n");

	return (XST_SUCCESS);
c0016074:	00000793          	li	a5,0
}
c0016078:	00078513          	mv	a0,a5
c001607c:	02c12083          	lw	ra,44(sp)
c0016080:	02812403          	lw	s0,40(sp)
c0016084:	03010113          	addi	sp,sp,48
c0016088:	00008067          	ret

c001608c <XAxiEthernet_ClearExtMulticastGroup>:
* provision this table appropriately.
*
*****************************************************************************/
int XAxiEthernet_ClearExtMulticastGroup(XAxiEthernet *InstancePtr,
							void *AddressPtr)
{
c001608c:	fd010113          	addi	sp,sp,-48
c0016090:	02112623          	sw	ra,44(sp)
c0016094:	02812423          	sw	s0,40(sp)
c0016098:	03010413          	addi	s0,sp,48
c001609c:	fca42e23          	sw	a0,-36(s0)
c00160a0:	fcb42c23          	sw	a1,-40(s0)
	u32 Loc;

	Xil_AssertNonvoid(InstancePtr != NULL);
c00160a4:	fdc42783          	lw	a5,-36(s0)
c00160a8:	02078463          	beqz	a5,c00160d0 <XAxiEthernet_ClearExtMulticastGroup+0x44>
c00160ac:	07fed797          	auipc	a5,0x7fed
c00160b0:	86878793          	addi	a5,a5,-1944 # c8002914 <Xil_AssertStatus>
c00160b4:	0007a023          	sw	zero,0(a5)
	Xil_AssertNonvoid(InstancePtr->IsReady == XIL_COMPONENT_IS_READY);
c00160b8:	fdc42783          	lw	a5,-36(s0)
c00160bc:	0507a703          	lw	a4,80(a5)
c00160c0:	111117b7          	lui	a5,0x11111
c00160c4:	11178793          	addi	a5,a5,273 # 11111111 <_DMEM_LENGTH+0x10911111>
c00160c8:	04f71463          	bne	a4,a5,c0016110 <XAxiEthernet_ClearExtMulticastGroup+0x84>
c00160cc:	02c0006f          	j	c00160f8 <XAxiEthernet_ClearExtMulticastGroup+0x6c>
	Xil_AssertNonvoid(InstancePtr != NULL);
c00160d0:	60500593          	li	a1,1541
c00160d4:	07feb517          	auipc	a0,0x7feb
c00160d8:	d1050513          	addi	a0,a0,-752 # c8000de4 <__rodata_start+0xde4>
c00160dc:	1e1070ef          	jal	ra,c001dabc <Xil_Assert>
c00160e0:	07fed797          	auipc	a5,0x7fed
c00160e4:	83478793          	addi	a5,a5,-1996 # c8002914 <Xil_AssertStatus>
c00160e8:	00100713          	li	a4,1
c00160ec:	00e7a023          	sw	a4,0(a5)
c00160f0:	00000793          	li	a5,0
c00160f4:	1dc0006f          	j	c00162d0 <XAxiEthernet_ClearExtMulticastGroup+0x244>
	Xil_AssertNonvoid(InstancePtr->IsReady == XIL_COMPONENT_IS_READY);
c00160f8:	07fed797          	auipc	a5,0x7fed
c00160fc:	81c78793          	addi	a5,a5,-2020 # c8002914 <Xil_AssertStatus>
c0016100:	0007a023          	sw	zero,0(a5)
	Xil_AssertNonvoid(AddressPtr != NULL);
c0016104:	fd842783          	lw	a5,-40(s0)
c0016108:	06078463          	beqz	a5,c0016170 <XAxiEthernet_ClearExtMulticastGroup+0xe4>
c001610c:	02c0006f          	j	c0016138 <XAxiEthernet_ClearExtMulticastGroup+0xac>
	Xil_AssertNonvoid(InstancePtr->IsReady == XIL_COMPONENT_IS_READY);
c0016110:	60600593          	li	a1,1542
c0016114:	07feb517          	auipc	a0,0x7feb
c0016118:	cd050513          	addi	a0,a0,-816 # c8000de4 <__rodata_start+0xde4>
c001611c:	1a1070ef          	jal	ra,c001dabc <Xil_Assert>
c0016120:	07fec797          	auipc	a5,0x7fec
c0016124:	7f478793          	addi	a5,a5,2036 # c8002914 <Xil_AssertStatus>
c0016128:	00100713          	li	a4,1
c001612c:	00e7a023          	sw	a4,0(a5)
c0016130:	00000793          	li	a5,0
c0016134:	19c0006f          	j	c00162d0 <XAxiEthernet_ClearExtMulticastGroup+0x244>
	Xil_AssertNonvoid(AddressPtr != NULL);
c0016138:	07fec797          	auipc	a5,0x7fec
c001613c:	7dc78793          	addi	a5,a5,2012 # c8002914 <Xil_AssertStatus>
c0016140:	0007a023          	sw	zero,0(a5)

	u8 *Aptr = (u8 *) AddressPtr;
c0016144:	fd842783          	lw	a5,-40(s0)
c0016148:	fef42623          	sw	a5,-20(s0)
	printf(
c001614c:	07feb517          	auipc	a0,0x7feb
c0016150:	64850513          	addi	a0,a0,1608 # c8001794 <__rodata_start+0x1794>
c0016154:	56d070ef          	jal	ra,c001dec0 <puts>
				"XAxiEthernet_ClearExtMulticastGroup\r\n");

	/*
	 * The device must be stopped before clearing the multicast table.
	 */
	if (InstancePtr->IsStarted == XIL_COMPONENT_IS_STARTED) {
c0016158:	fdc42783          	lw	a5,-36(s0)
c001615c:	04c7a703          	lw	a4,76(a5)
c0016160:	222227b7          	lui	a5,0x22222
c0016164:	22278793          	addi	a5,a5,546 # 22222222 <_DMEM_LENGTH+0x21a22222>
c0016168:	04f71263          	bne	a4,a5,c00161ac <XAxiEthernet_ClearExtMulticastGroup+0x120>
c001616c:	02c0006f          	j	c0016198 <XAxiEthernet_ClearExtMulticastGroup+0x10c>
	Xil_AssertNonvoid(AddressPtr != NULL);
c0016170:	60700593          	li	a1,1543
c0016174:	07feb517          	auipc	a0,0x7feb
c0016178:	c7050513          	addi	a0,a0,-912 # c8000de4 <__rodata_start+0xde4>
c001617c:	141070ef          	jal	ra,c001dabc <Xil_Assert>
c0016180:	07fec797          	auipc	a5,0x7fec
c0016184:	79478793          	addi	a5,a5,1940 # c8002914 <Xil_AssertStatus>
c0016188:	00100713          	li	a4,1
c001618c:	00e7a023          	sw	a4,0(a5)
c0016190:	00000793          	li	a5,0
c0016194:	13c0006f          	j	c00162d0 <XAxiEthernet_ClearExtMulticastGroup+0x244>
		printf(
c0016198:	07feb517          	auipc	a0,0x7feb
c001619c:	62450513          	addi	a0,a0,1572 # c80017bc <__rodata_start+0x17bc>
c00161a0:	521070ef          	jal	ra,c001dec0 <puts>
		"XAxiEthernet_ClearExtMulticastGroup:returning DEVICE_IS_STARTED\r\n");
		return (XST_DEVICE_IS_STARTED);
c00161a4:	00500793          	li	a5,5
c00161a8:	1280006f          	j	c00162d0 <XAxiEthernet_ClearExtMulticastGroup+0x244>
	}

	/* Check HW capability */
	if (!XAxiEthernet_IsExtFuncCap(InstancePtr) ||
c00161ac:	fdc42783          	lw	a5,-36(s0)
c00161b0:	0047a783          	lw	a5,4(a5)
c00161b4:	00078513          	mv	a0,a5
c00161b8:	c4cfd0ef          	jal	ra,c0013604 <Xil_In32>
c00161bc:	00050713          	mv	a4,a0
c00161c0:	000017b7          	lui	a5,0x1
c00161c4:	80078793          	addi	a5,a5,-2048 # 800 <_STACK_SIZE-0x800>
c00161c8:	00f777b3          	and	a5,a4,a5
c00161cc:	02078263          	beqz	a5,c00161f0 <XAxiEthernet_ClearExtMulticastGroup+0x164>
		!XAxiEthernet_IsExtMcastEnable(InstancePtr)) {
c00161d0:	fdc42783          	lw	a5,-36(s0)
c00161d4:	0047a783          	lw	a5,4(a5)
c00161d8:	00078513          	mv	a0,a5
c00161dc:	c28fd0ef          	jal	ra,c0013604 <Xil_In32>
c00161e0:	00050713          	mv	a4,a0
c00161e4:	000017b7          	lui	a5,0x1
c00161e8:	00f777b3          	and	a5,a4,a5
	if (!XAxiEthernet_IsExtFuncCap(InstancePtr) ||
c00161ec:	00079c63          	bnez	a5,c0016204 <XAxiEthernet_ClearExtMulticastGroup+0x178>
		printf(
c00161f0:	07feb517          	auipc	a0,0x7feb
c00161f4:	61050513          	addi	a0,a0,1552 # c8001800 <__rodata_start+0x1800>
c00161f8:	4c9070ef          	jal	ra,c001dec0 <puts>
		"XAxiEthernet_ClearExtMulticastGroup:returning DEVICE_NO_FEATURE\r\n");
		return (XST_NO_FEATURE);
c00161fc:	01300793          	li	a5,19
c0016200:	0d00006f          	j	c00162d0 <XAxiEthernet_ClearExtMulticastGroup+0x244>
	/*
	 * Verify if address is a good/valid multicast address, between
	 * 01:00:5E:00:00:00 to 01:00:5E:7F:FF:FF per RFC1112.
	 * This address is referenced to be index to the table.
	 */
	if ((0x01 != Aptr[0]) || (0x00 != Aptr[1]) || (0x5e != Aptr[2]) ||
c0016204:	fec42783          	lw	a5,-20(s0)
c0016208:	0007c703          	lbu	a4,0(a5) # 1000 <_STACK_SIZE>
c001620c:	00100793          	li	a5,1
c0016210:	04f71063          	bne	a4,a5,c0016250 <XAxiEthernet_ClearExtMulticastGroup+0x1c4>
c0016214:	fec42783          	lw	a5,-20(s0)
c0016218:	00178793          	addi	a5,a5,1
c001621c:	0007c783          	lbu	a5,0(a5)
c0016220:	02079863          	bnez	a5,c0016250 <XAxiEthernet_ClearExtMulticastGroup+0x1c4>
c0016224:	fec42783          	lw	a5,-20(s0)
c0016228:	00278793          	addi	a5,a5,2
c001622c:	0007c703          	lbu	a4,0(a5)
c0016230:	05e00793          	li	a5,94
c0016234:	00f71e63          	bne	a4,a5,c0016250 <XAxiEthernet_ClearExtMulticastGroup+0x1c4>
		(0x0 != (Aptr[3] & 0x80)))
c0016238:	fec42783          	lw	a5,-20(s0)
c001623c:	00378793          	addi	a5,a5,3
c0016240:	0007c783          	lbu	a5,0(a5)
c0016244:	01879793          	slli	a5,a5,0x18
c0016248:	4187d793          	srai	a5,a5,0x18
	if ((0x01 != Aptr[0]) || (0x00 != Aptr[1]) || (0x5e != Aptr[2]) ||
c001624c:	0007d663          	bgez	a5,c0016258 <XAxiEthernet_ClearExtMulticastGroup+0x1cc>
		return (XST_INVALID_PARAM);
c0016250:	00f00793          	li	a5,15
c0016254:	07c0006f          	j	c00162d0 <XAxiEthernet_ClearExtMulticastGroup+0x244>

	Loc  = Aptr[3];
c0016258:	fec42783          	lw	a5,-20(s0)
c001625c:	00378793          	addi	a5,a5,3
c0016260:	0007c783          	lbu	a5,0(a5)
c0016264:	fef42423          	sw	a5,-24(s0)
	Loc  = Loc << 8;
c0016268:	fe842783          	lw	a5,-24(s0)
c001626c:	00879793          	slli	a5,a5,0x8
c0016270:	fef42423          	sw	a5,-24(s0)
	Loc |= Aptr[4];
c0016274:	fec42783          	lw	a5,-20(s0)
c0016278:	00478793          	addi	a5,a5,4
c001627c:	0007c783          	lbu	a5,0(a5)
c0016280:	00078713          	mv	a4,a5
c0016284:	fe842783          	lw	a5,-24(s0)
c0016288:	00e7e7b3          	or	a5,a5,a4
c001628c:	fef42423          	sw	a5,-24(s0)

	/* Word aligned address access */
	Loc  = Loc << 2;
c0016290:	fe842783          	lw	a5,-24(s0)
c0016294:	00279793          	slli	a5,a5,0x2
c0016298:	fef42423          	sw	a5,-24(s0)

	XAxiEthernet_WriteReg(InstancePtr->Config.BaseAddress,
c001629c:	fdc42783          	lw	a5,-36(s0)
c00162a0:	0047a703          	lw	a4,4(a5)
c00162a4:	fe842783          	lw	a5,-24(s0)
c00162a8:	00f70733          	add	a4,a4,a5
c00162ac:	000207b7          	lui	a5,0x20
c00162b0:	00f707b3          	add	a5,a4,a5
c00162b4:	00000593          	li	a1,0
c00162b8:	00078513          	mv	a0,a5
c00162bc:	b70fd0ef          	jal	ra,c001362c <Xil_Out32>
		XAE_MCAST_TABLE_OFFSET + Loc, 0x00);

	printf(
c00162c0:	07feb517          	auipc	a0,0x7feb
c00162c4:	58450513          	addi	a0,a0,1412 # c8001844 <__rodata_start+0x1844>
c00162c8:	3f9070ef          	jal	ra,c001dec0 <puts>
		"XAxiEthernet_ClearExtMulticastGroup: returning SUCCESS\r\n");

	return (XST_SUCCESS);
c00162cc:	00000793          	li	a5,0
}
c00162d0:	00078513          	mv	a0,a5
c00162d4:	02c12083          	lw	ra,44(sp)
c00162d8:	02812403          	lw	s0,40(sp)
c00162dc:	03010113          	addi	sp,sp,48
c00162e0:	00008067          	ret

c00162e4 <XAxiEthernet_GetExtMulticastGroup>:
* This API operates at a group (256 MAC addresses) level.
*
*****************************************************************************/
int XAxiEthernet_GetExtMulticastGroup(XAxiEthernet *InstancePtr,
							void *AddressPtr)
{
c00162e4:	fd010113          	addi	sp,sp,-48
c00162e8:	02112623          	sw	ra,44(sp)
c00162ec:	02812423          	sw	s0,40(sp)
c00162f0:	03010413          	addi	s0,sp,48
c00162f4:	fca42e23          	sw	a0,-36(s0)
c00162f8:	fcb42c23          	sw	a1,-40(s0)
	u32 Loc;
	u8 Bit;

	Xil_AssertNonvoid(InstancePtr != NULL);
c00162fc:	fdc42783          	lw	a5,-36(s0)
c0016300:	02078463          	beqz	a5,c0016328 <XAxiEthernet_GetExtMulticastGroup+0x44>
c0016304:	07fec797          	auipc	a5,0x7fec
c0016308:	61078793          	addi	a5,a5,1552 # c8002914 <Xil_AssertStatus>
c001630c:	0007a023          	sw	zero,0(a5)
	Xil_AssertNonvoid(InstancePtr->IsReady == XIL_COMPONENT_IS_READY);
c0016310:	fdc42783          	lw	a5,-36(s0)
c0016314:	0507a703          	lw	a4,80(a5)
c0016318:	111117b7          	lui	a5,0x11111
c001631c:	11178793          	addi	a5,a5,273 # 11111111 <_DMEM_LENGTH+0x10911111>
c0016320:	04f71463          	bne	a4,a5,c0016368 <XAxiEthernet_GetExtMulticastGroup+0x84>
c0016324:	02c0006f          	j	c0016350 <XAxiEthernet_GetExtMulticastGroup+0x6c>
	Xil_AssertNonvoid(InstancePtr != NULL);
c0016328:	65400593          	li	a1,1620
c001632c:	07feb517          	auipc	a0,0x7feb
c0016330:	ab850513          	addi	a0,a0,-1352 # c8000de4 <__rodata_start+0xde4>
c0016334:	788070ef          	jal	ra,c001dabc <Xil_Assert>
c0016338:	07fec797          	auipc	a5,0x7fec
c001633c:	5dc78793          	addi	a5,a5,1500 # c8002914 <Xil_AssertStatus>
c0016340:	00100713          	li	a4,1
c0016344:	00e7a023          	sw	a4,0(a5)
c0016348:	00000793          	li	a5,0
c001634c:	1640006f          	j	c00164b0 <XAxiEthernet_GetExtMulticastGroup+0x1cc>
	Xil_AssertNonvoid(InstancePtr->IsReady == XIL_COMPONENT_IS_READY);
c0016350:	07fec797          	auipc	a5,0x7fec
c0016354:	5c478793          	addi	a5,a5,1476 # c8002914 <Xil_AssertStatus>
c0016358:	0007a023          	sw	zero,0(a5)
	Xil_AssertNonvoid(AddressPtr != NULL);
c001635c:	fd842783          	lw	a5,-40(s0)
c0016360:	06078263          	beqz	a5,c00163c4 <XAxiEthernet_GetExtMulticastGroup+0xe0>
c0016364:	02c0006f          	j	c0016390 <XAxiEthernet_GetExtMulticastGroup+0xac>
	Xil_AssertNonvoid(InstancePtr->IsReady == XIL_COMPONENT_IS_READY);
c0016368:	65500593          	li	a1,1621
c001636c:	07feb517          	auipc	a0,0x7feb
c0016370:	a7850513          	addi	a0,a0,-1416 # c8000de4 <__rodata_start+0xde4>
c0016374:	748070ef          	jal	ra,c001dabc <Xil_Assert>
c0016378:	07fec797          	auipc	a5,0x7fec
c001637c:	59c78793          	addi	a5,a5,1436 # c8002914 <Xil_AssertStatus>
c0016380:	00100713          	li	a4,1
c0016384:	00e7a023          	sw	a4,0(a5)
c0016388:	00000793          	li	a5,0
c001638c:	1240006f          	j	c00164b0 <XAxiEthernet_GetExtMulticastGroup+0x1cc>
	Xil_AssertNonvoid(AddressPtr != NULL);
c0016390:	07fec797          	auipc	a5,0x7fec
c0016394:	58478793          	addi	a5,a5,1412 # c8002914 <Xil_AssertStatus>
c0016398:	0007a023          	sw	zero,0(a5)

	u8 *Aptr = (u8 *) AddressPtr;
c001639c:	fd842783          	lw	a5,-40(s0)
c00163a0:	fef42623          	sw	a5,-20(s0)
	printf("XAxiEthernet_GetExtMulticastGroup\r\n");
c00163a4:	07feb517          	auipc	a0,0x7feb
c00163a8:	4d850513          	addi	a0,a0,1240 # c800187c <__rodata_start+0x187c>
c00163ac:	315070ef          	jal	ra,c001dec0 <puts>
	/*
	 * Verify if address is a good/valid multicast address, between
	 * 01:00:5E:00:00:00 to 01:00:5E:7F:FF:FF per RFC1112.
	 * This address is referenced to be index to the table.
	 */
	if ((0x01 != Aptr[0]) || (0x00 != Aptr[1]) || (0x5e != Aptr[2]) ||
c00163b0:	fec42783          	lw	a5,-20(s0)
c00163b4:	0007c703          	lbu	a4,0(a5)
c00163b8:	00100793          	li	a5,1
c00163bc:	06f71663          	bne	a4,a5,c0016428 <XAxiEthernet_GetExtMulticastGroup+0x144>
c00163c0:	02c0006f          	j	c00163ec <XAxiEthernet_GetExtMulticastGroup+0x108>
	Xil_AssertNonvoid(AddressPtr != NULL);
c00163c4:	65600593          	li	a1,1622
c00163c8:	07feb517          	auipc	a0,0x7feb
c00163cc:	a1c50513          	addi	a0,a0,-1508 # c8000de4 <__rodata_start+0xde4>
c00163d0:	6ec070ef          	jal	ra,c001dabc <Xil_Assert>
c00163d4:	07fec797          	auipc	a5,0x7fec
c00163d8:	54078793          	addi	a5,a5,1344 # c8002914 <Xil_AssertStatus>
c00163dc:	00100713          	li	a4,1
c00163e0:	00e7a023          	sw	a4,0(a5)
c00163e4:	00000793          	li	a5,0
c00163e8:	0c80006f          	j	c00164b0 <XAxiEthernet_GetExtMulticastGroup+0x1cc>
	if ((0x01 != Aptr[0]) || (0x00 != Aptr[1]) || (0x5e != Aptr[2]) ||
c00163ec:	fec42783          	lw	a5,-20(s0)
c00163f0:	00178793          	addi	a5,a5,1
c00163f4:	0007c783          	lbu	a5,0(a5)
c00163f8:	02079863          	bnez	a5,c0016428 <XAxiEthernet_GetExtMulticastGroup+0x144>
c00163fc:	fec42783          	lw	a5,-20(s0)
c0016400:	00278793          	addi	a5,a5,2
c0016404:	0007c703          	lbu	a4,0(a5)
c0016408:	05e00793          	li	a5,94
c001640c:	00f71e63          	bne	a4,a5,c0016428 <XAxiEthernet_GetExtMulticastGroup+0x144>
		(0x0 != (Aptr[3] & 0x80)))
c0016410:	fec42783          	lw	a5,-20(s0)
c0016414:	00378793          	addi	a5,a5,3
c0016418:	0007c783          	lbu	a5,0(a5)
c001641c:	01879793          	slli	a5,a5,0x18
c0016420:	4187d793          	srai	a5,a5,0x18
	if ((0x01 != Aptr[0]) || (0x00 != Aptr[1]) || (0x5e != Aptr[2]) ||
c0016424:	0007d663          	bgez	a5,c0016430 <XAxiEthernet_GetExtMulticastGroup+0x14c>
		return (FALSE);
c0016428:	00000793          	li	a5,0
c001642c:	0840006f          	j	c00164b0 <XAxiEthernet_GetExtMulticastGroup+0x1cc>

	Loc  = Aptr[3];
c0016430:	fec42783          	lw	a5,-20(s0)
c0016434:	00378793          	addi	a5,a5,3
c0016438:	0007c783          	lbu	a5,0(a5)
c001643c:	fef42423          	sw	a5,-24(s0)
	Loc  = Loc << 8;
c0016440:	fe842783          	lw	a5,-24(s0)
c0016444:	00879793          	slli	a5,a5,0x8
c0016448:	fef42423          	sw	a5,-24(s0)
	Loc |= Aptr[4];
c001644c:	fec42783          	lw	a5,-20(s0)
c0016450:	00478793          	addi	a5,a5,4
c0016454:	0007c783          	lbu	a5,0(a5)
c0016458:	00078713          	mv	a4,a5
c001645c:	fe842783          	lw	a5,-24(s0)
c0016460:	00e7e7b3          	or	a5,a5,a4
c0016464:	fef42423          	sw	a5,-24(s0)

	/*
	 * Word aligned address access
	 */
	Loc  = Loc << 2;
c0016468:	fe842783          	lw	a5,-24(s0)
c001646c:	00279793          	slli	a5,a5,0x2
c0016470:	fef42423          	sw	a5,-24(s0)

	Bit = XAxiEthernet_ReadReg(InstancePtr->Config.BaseAddress,
c0016474:	fdc42783          	lw	a5,-36(s0)
c0016478:	0047a703          	lw	a4,4(a5)
c001647c:	fe842783          	lw	a5,-24(s0)
c0016480:	00f70733          	add	a4,a4,a5
c0016484:	000207b7          	lui	a5,0x20
c0016488:	00f707b3          	add	a5,a4,a5
c001648c:	00078513          	mv	a0,a5
c0016490:	974fd0ef          	jal	ra,c0013604 <Xil_In32>
c0016494:	00050793          	mv	a5,a0
c0016498:	fef403a3          	sb	a5,-25(s0)
		XAE_MCAST_TABLE_OFFSET + Loc);

	if (Bit) {
c001649c:	fe744783          	lbu	a5,-25(s0)
c00164a0:	00078663          	beqz	a5,c00164ac <XAxiEthernet_GetExtMulticastGroup+0x1c8>
		return (TRUE);
c00164a4:	00100793          	li	a5,1
c00164a8:	0080006f          	j	c00164b0 <XAxiEthernet_GetExtMulticastGroup+0x1cc>
	} else {
		return (FALSE);
c00164ac:	00000793          	li	a5,0
	}
	printf("XAxiEthernet_GetExtMulticastGroup:done\r\n");
}
c00164b0:	00078513          	mv	a0,a5
c00164b4:	02c12083          	lw	ra,44(sp)
c00164b8:	02812403          	lw	s0,40(sp)
c00164bc:	03010113          	addi	sp,sp,48
c00164c0:	00008067          	ret

c00164c4 <XAxiEthernet_DumpExtMulticastGroup>:
*
* This API operates at a set (256 MAC addresses) level.
*
*****************************************************************************/
void XAxiEthernet_DumpExtMulticastGroup(XAxiEthernet *InstancePtr)
{
c00164c4:	fd010113          	addi	sp,sp,-48
c00164c8:	02112623          	sw	ra,44(sp)
c00164cc:	02812423          	sw	s0,40(sp)
c00164d0:	03010413          	addi	s0,sp,48
c00164d4:	fca42e23          	sw	a0,-36(s0)
	u32 Loc;
	u32 Index;
	u8  Bit;
	char MacAddr[6];

	Xil_AssertVoid(InstancePtr != NULL);
c00164d8:	fdc42783          	lw	a5,-36(s0)
c00164dc:	02078663          	beqz	a5,c0016508 <XAxiEthernet_DumpExtMulticastGroup+0x44>
c00164e0:	07fec797          	auipc	a5,0x7fec
c00164e4:	43478793          	addi	a5,a5,1076 # c8002914 <Xil_AssertStatus>
c00164e8:	0007a023          	sw	zero,0(a5)

	/*
	 * Pre-populated these bytes, we know and guarantee these if
	 * provisioned through the XAxiEthernet_AddExtMulticastGroup().
	 */
	MacAddr[0] = 0x01;
c00164ec:	00100793          	li	a5,1
c00164f0:	fef40023          	sb	a5,-32(s0)
	MacAddr[1] = 0x00;
c00164f4:	fe0400a3          	sb	zero,-31(s0)
	MacAddr[2] = 0x5E;
c00164f8:	05e00793          	li	a5,94
c00164fc:	fef40123          	sb	a5,-30(s0)

	for (Index = 0; Index < (1 << 15); Index++) {
c0016500:	fe042623          	sw	zero,-20(s0)
c0016504:	0dc0006f          	j	c00165e0 <XAxiEthernet_DumpExtMulticastGroup+0x11c>
	Xil_AssertVoid(InstancePtr != NULL);
c0016508:	69200593          	li	a1,1682
c001650c:	07feb517          	auipc	a0,0x7feb
c0016510:	8d850513          	addi	a0,a0,-1832 # c8000de4 <__rodata_start+0xde4>
c0016514:	5a8070ef          	jal	ra,c001dabc <Xil_Assert>
c0016518:	07fec797          	auipc	a5,0x7fec
c001651c:	3fc78793          	addi	a5,a5,1020 # c8002914 <Xil_AssertStatus>
c0016520:	00100713          	li	a4,1
c0016524:	00e7a023          	sw	a4,0(a5)
c0016528:	0c40006f          	j	c00165ec <XAxiEthernet_DumpExtMulticastGroup+0x128>
		MacAddr[3] = Index << 16;
c001652c:	fe0401a3          	sb	zero,-29(s0)
		MacAddr[4] = Index << 8;
c0016530:	fe040223          	sb	zero,-28(s0)
		MacAddr[5] = 0;
c0016534:	fe0402a3          	sb	zero,-27(s0)

		Loc  = MacAddr[3];
c0016538:	fe344783          	lbu	a5,-29(s0)
c001653c:	fef42423          	sw	a5,-24(s0)
		Loc |= MacAddr[4] << 8;
c0016540:	fe444783          	lbu	a5,-28(s0)
c0016544:	00879793          	slli	a5,a5,0x8
c0016548:	00078713          	mv	a4,a5
c001654c:	fe842783          	lw	a5,-24(s0)
c0016550:	00e7e7b3          	or	a5,a5,a4
c0016554:	fef42423          	sw	a5,-24(s0)

		/* Word aligned address access */
		Loc  = Loc << 2;
c0016558:	fe842783          	lw	a5,-24(s0)
c001655c:	00279793          	slli	a5,a5,0x2
c0016560:	fef42423          	sw	a5,-24(s0)

		Bit = XAxiEthernet_ReadReg(InstancePtr->Config.BaseAddress,
c0016564:	fdc42783          	lw	a5,-36(s0)
c0016568:	0047a703          	lw	a4,4(a5)
c001656c:	fe842783          	lw	a5,-24(s0)
c0016570:	00f70733          	add	a4,a4,a5
c0016574:	000207b7          	lui	a5,0x20
c0016578:	00f707b3          	add	a5,a4,a5
c001657c:	00078513          	mv	a0,a5
c0016580:	884fd0ef          	jal	ra,c0013604 <Xil_In32>
c0016584:	00050793          	mv	a5,a0
c0016588:	fef403a3          	sb	a5,-25(s0)
			XAE_MCAST_TABLE_OFFSET + Loc);
		if (Bit) {
c001658c:	fe744783          	lbu	a5,-25(s0)
c0016590:	04078263          	beqz	a5,c00165d4 <XAxiEthernet_DumpExtMulticastGroup+0x110>
			printf(
			"%x:%x:%x:%x:%x:%x\r\n", MacAddr[5], MacAddr[4],
c0016594:	fe544783          	lbu	a5,-27(s0)
			printf(
c0016598:	00078593          	mv	a1,a5
			"%x:%x:%x:%x:%x:%x\r\n", MacAddr[5], MacAddr[4],
c001659c:	fe444783          	lbu	a5,-28(s0)
			printf(
c00165a0:	00078613          	mv	a2,a5
			MacAddr[3], MacAddr[2], MacAddr[1], MacAddr[0]);
c00165a4:	fe344783          	lbu	a5,-29(s0)
			printf(
c00165a8:	00078693          	mv	a3,a5
			MacAddr[3], MacAddr[2], MacAddr[1], MacAddr[0]);
c00165ac:	fe244783          	lbu	a5,-30(s0)
			printf(
c00165b0:	00078713          	mv	a4,a5
			MacAddr[3], MacAddr[2], MacAddr[1], MacAddr[0]);
c00165b4:	fe144783          	lbu	a5,-31(s0)
			printf(
c00165b8:	00078513          	mv	a0,a5
			MacAddr[3], MacAddr[2], MacAddr[1], MacAddr[0]);
c00165bc:	fe044783          	lbu	a5,-32(s0)
			printf(
c00165c0:	00078813          	mv	a6,a5
c00165c4:	00050793          	mv	a5,a0
c00165c8:	07feb517          	auipc	a0,0x7feb
c00165cc:	2d850513          	addi	a0,a0,728 # c80018a0 <__rodata_start+0x18a0>
c00165d0:	7d4070ef          	jal	ra,c001dda4 <printf>
	for (Index = 0; Index < (1 << 15); Index++) {
c00165d4:	fec42783          	lw	a5,-20(s0)
c00165d8:	00178793          	addi	a5,a5,1 # 20001 <_STACK_SIZE+0x1f001>
c00165dc:	fef42623          	sw	a5,-20(s0)
c00165e0:	fec42703          	lw	a4,-20(s0)
c00165e4:	000087b7          	lui	a5,0x8
c00165e8:	f4f762e3          	bltu	a4,a5,c001652c <XAxiEthernet_DumpExtMulticastGroup+0x68>
		}
	}
}
c00165ec:	02c12083          	lw	ra,44(sp)
c00165f0:	02812403          	lw	s0,40(sp)
c00165f4:	03010113          	addi	sp,sp,48
c00165f8:	00008067          	ret

c00165fc <XAxiEthernet_LookupConfig>:
*		  <i>DeviceId</i>, or NULL
*		- NULL if no match is found.
*
******************************************************************************/
XAxiEthernet_Config *XAxiEthernet_LookupConfig(u16 DeviceId)
{
c00165fc:	fd010113          	addi	sp,sp,-48
c0016600:	02812623          	sw	s0,44(sp)
c0016604:	03010413          	addi	s0,sp,48
c0016608:	00050793          	mv	a5,a0
c001660c:	fcf41f23          	sh	a5,-34(s0)
	extern XAxiEthernet_Config XAxiEthernet_ConfigTable[];
	XAxiEthernet_Config *CfgPtr = NULL;
c0016610:	fe042623          	sw	zero,-20(s0)
	u32 Index;

	for (Index = 0U; Index < XPAR_XAXIETHERNET_NUM_INSTANCES; Index++) {
c0016614:	fe042423          	sw	zero,-24(s0)
c0016618:	0540006f          	j	c001666c <XAxiEthernet_LookupConfig+0x70>
		if (XAxiEthernet_ConfigTable[Index].DeviceId == DeviceId) {
c001661c:	07fec717          	auipc	a4,0x7fec
c0016620:	48070713          	addi	a4,a4,1152 # c8002a9c <XAxiEthernet_ConfigTable>
c0016624:	fe842683          	lw	a3,-24(s0)
c0016628:	04c00793          	li	a5,76
c001662c:	02f687b3          	mul	a5,a3,a5
c0016630:	00f707b3          	add	a5,a4,a5
c0016634:	0007d783          	lhu	a5,0(a5) # 8000 <_STACK_SIZE+0x7000>
c0016638:	fde45703          	lhu	a4,-34(s0)
c001663c:	02f71263          	bne	a4,a5,c0016660 <XAxiEthernet_LookupConfig+0x64>
			CfgPtr = &XAxiEthernet_ConfigTable[Index];
c0016640:	fe842703          	lw	a4,-24(s0)
c0016644:	04c00793          	li	a5,76
c0016648:	02f70733          	mul	a4,a4,a5
c001664c:	07fec797          	auipc	a5,0x7fec
c0016650:	45078793          	addi	a5,a5,1104 # c8002a9c <XAxiEthernet_ConfigTable>
c0016654:	00f707b3          	add	a5,a4,a5
c0016658:	fef42623          	sw	a5,-20(s0)
			break;
c001665c:	0180006f          	j	c0016674 <XAxiEthernet_LookupConfig+0x78>
	for (Index = 0U; Index < XPAR_XAXIETHERNET_NUM_INSTANCES; Index++) {
c0016660:	fe842783          	lw	a5,-24(s0)
c0016664:	00178793          	addi	a5,a5,1
c0016668:	fef42423          	sw	a5,-24(s0)
c001666c:	fe842783          	lw	a5,-24(s0)
c0016670:	fa0786e3          	beqz	a5,c001661c <XAxiEthernet_LookupConfig+0x20>
		}
	}

	return (CfgPtr);
c0016674:	fec42783          	lw	a5,-20(s0)
}
c0016678:	00078513          	mv	a0,a5
c001667c:	02c12403          	lw	s0,44(sp)
c0016680:	03010113          	addi	sp,sp,48
c0016684:	00008067          	ret

c0016688 <Xil_In32>:
{
c0016688:	fe010113          	addi	sp,sp,-32
c001668c:	00812e23          	sw	s0,28(sp)
c0016690:	02010413          	addi	s0,sp,32
c0016694:	fea42623          	sw	a0,-20(s0)
	return *(volatile u32 *) Addr;
c0016698:	fec42783          	lw	a5,-20(s0)
c001669c:	0007a783          	lw	a5,0(a5)
}
c00166a0:	00078513          	mv	a0,a5
c00166a4:	01c12403          	lw	s0,28(sp)
c00166a8:	02010113          	addi	sp,sp,32
c00166ac:	00008067          	ret

c00166b0 <Xil_Out32>:
{
c00166b0:	fd010113          	addi	sp,sp,-48
c00166b4:	02812623          	sw	s0,44(sp)
c00166b8:	03010413          	addi	s0,sp,48
c00166bc:	fca42e23          	sw	a0,-36(s0)
c00166c0:	fcb42c23          	sw	a1,-40(s0)
	volatile u32 *LocalAddr = (volatile u32 *)Addr;
c00166c4:	fdc42783          	lw	a5,-36(s0)
c00166c8:	fef42623          	sw	a5,-20(s0)
	*LocalAddr = Value;
c00166cc:	fec42783          	lw	a5,-20(s0)
c00166d0:	fd842703          	lw	a4,-40(s0)
c00166d4:	00e7a023          	sw	a4,0(a5)
}
c00166d8:	00000013          	nop
c00166dc:	02c12403          	lw	s0,44(sp)
c00166e0:	03010113          	addi	sp,sp,48
c00166e4:	00008067          	ret

c00166e8 <XIic_CfgInitialize>:
* @note		None.
*
****************************************************************************/
int XIic_CfgInitialize(XIic *InstancePtr, XIic_Config * Config,
			   UINTPTR EffectiveAddr)
{
c00166e8:	fe010113          	addi	sp,sp,-32
c00166ec:	00112e23          	sw	ra,28(sp)
c00166f0:	00812c23          	sw	s0,24(sp)
c00166f4:	02010413          	addi	s0,sp,32
c00166f8:	fea42623          	sw	a0,-20(s0)
c00166fc:	feb42423          	sw	a1,-24(s0)
c0016700:	fec42223          	sw	a2,-28(s0)
	/*
	 * Asserts test the validity of selected input arguments.
	 */
	Xil_AssertNonvoid(InstancePtr != NULL);
c0016704:	fec42783          	lw	a5,-20(s0)
c0016708:	02078863          	beqz	a5,c0016738 <XIic_CfgInitialize+0x50>
c001670c:	07fec797          	auipc	a5,0x7fec
c0016710:	20878793          	addi	a5,a5,520 # c8002914 <Xil_AssertStatus>
c0016714:	0007a023          	sw	zero,0(a5)

	InstancePtr->IsReady = 0;
c0016718:	fec42783          	lw	a5,-20(s0)
c001671c:	0007aa23          	sw	zero,20(a5)
	 * If the device is started, disallow the initialize and return a Status
	 * indicating it is started.  This allows the user to stop the device
	 * and reinitialize, but prevents a user from inadvertently
	 * initializing.
	 */
	if (InstancePtr->IsStarted == XIL_COMPONENT_IS_STARTED) {
c0016720:	fec42783          	lw	a5,-20(s0)
c0016724:	0187a703          	lw	a4,24(a5)
c0016728:	222227b7          	lui	a5,0x22222
c001672c:	22278793          	addi	a5,a5,546 # 22222222 <_DMEM_LENGTH+0x21a22222>
c0016730:	02f71c63          	bne	a4,a5,c0016768 <XIic_CfgInitialize+0x80>
c0016734:	02c0006f          	j	c0016760 <XIic_CfgInitialize+0x78>
	Xil_AssertNonvoid(InstancePtr != NULL);
c0016738:	09e00593          	li	a1,158
c001673c:	07feb517          	auipc	a0,0x7feb
c0016740:	17850513          	addi	a0,a0,376 # c80018b4 <__rodata_start+0x18b4>
c0016744:	378070ef          	jal	ra,c001dabc <Xil_Assert>
c0016748:	07fec797          	auipc	a5,0x7fec
c001674c:	1cc78793          	addi	a5,a5,460 # c8002914 <Xil_AssertStatus>
c0016750:	00100713          	li	a4,1
c0016754:	00e7a023          	sw	a4,0(a5)
c0016758:	00000793          	li	a5,0
c001675c:	0c40006f          	j	c0016820 <XIic_CfgInitialize+0x138>
		return XST_DEVICE_IS_STARTED;
c0016760:	00500793          	li	a5,5
c0016764:	0bc0006f          	j	c0016820 <XIic_CfgInitialize+0x138>
	/*
	 * Set default values and configuration data, including setting the
	 * callback handlers to stubs  so the system will not crash should the
	 * application not assign its own callbacks.
	 */
	InstancePtr->IsStarted = 0;
c0016768:	fec42783          	lw	a5,-20(s0)
c001676c:	0007ac23          	sw	zero,24(a5)
	InstancePtr->BaseAddress = EffectiveAddr;
c0016770:	fec42783          	lw	a5,-20(s0)
c0016774:	fe442703          	lw	a4,-28(s0)
c0016778:	00e7a623          	sw	a4,12(a5)
	InstancePtr->RecvHandler = XIic_StubHandler;
c001677c:	fec42783          	lw	a5,-20(s0)
c0016780:	00001717          	auipc	a4,0x1
c0016784:	bb470713          	addi	a4,a4,-1100 # c0017334 <XIic_StubHandler>
c0016788:	04e7a423          	sw	a4,72(a5)
	InstancePtr->RecvBufferPtr = NULL;
c001678c:	fec42783          	lw	a5,-20(s0)
c0016790:	0207a423          	sw	zero,40(a5)
	InstancePtr->SendHandler = XIic_StubHandler;
c0016794:	fec42783          	lw	a5,-20(s0)
c0016798:	00001717          	auipc	a4,0x1
c001679c:	b9c70713          	addi	a4,a4,-1124 # c0017334 <XIic_StubHandler>
c00167a0:	04e7a823          	sw	a4,80(a5)
	InstancePtr->SendBufferPtr = NULL;
c00167a4:	fec42783          	lw	a5,-20(s0)
c00167a8:	0207a223          	sw	zero,36(a5)
	InstancePtr->StatusHandler = XIic_StubStatusHandler;
c00167ac:	fec42783          	lw	a5,-20(s0)
c00167b0:	00001717          	auipc	a4,0x1
c00167b4:	bd070713          	addi	a4,a4,-1072 # c0017380 <XIic_StubStatusHandler>
c00167b8:	04e7a023          	sw	a4,64(a5)
	InstancePtr->Has10BitAddr = Config->Has10BitAddr;
c00167bc:	fe842783          	lw	a5,-24(s0)
c00167c0:	0087a703          	lw	a4,8(a5)
c00167c4:	fec42783          	lw	a5,-20(s0)
c00167c8:	00e7a823          	sw	a4,16(a5)
	InstancePtr->IsReady = XIL_COMPONENT_IS_READY;
c00167cc:	fec42783          	lw	a5,-20(s0)
c00167d0:	11111737          	lui	a4,0x11111
c00167d4:	11170713          	addi	a4,a4,273 # 11111111 <_DMEM_LENGTH+0x10911111>
c00167d8:	00e7aa23          	sw	a4,20(a5)
	InstancePtr->Options = 0;
c00167dc:	fec42783          	lw	a5,-20(s0)
c00167e0:	0207a023          	sw	zero,32(a5)
	InstancePtr->BNBOnly = FALSE;
c00167e4:	fec42783          	lw	a5,-20(s0)
c00167e8:	0207ac23          	sw	zero,56(a5)
	InstancePtr->GpOutWidth = Config->GpOutWidth;
c00167ec:	fe842783          	lw	a5,-24(s0)
c00167f0:	00c7c703          	lbu	a4,12(a5)
c00167f4:	fec42783          	lw	a5,-20(s0)
c00167f8:	02e78e23          	sb	a4,60(a5)
	InstancePtr->IsDynamic = FALSE;
c00167fc:	fec42783          	lw	a5,-20(s0)
c0016800:	0407ac23          	sw	zero,88(a5)
	InstancePtr->IsSlaveSetAckOff = FALSE;
c0016804:	fec42783          	lw	a5,-20(s0)
c0016808:	0407ae23          	sw	zero,92(a5)

	/*
	 * Reset the device.
	 */
	XIic_Reset(InstancePtr);
c001680c:	fec42503          	lw	a0,-20(s0)
c0016810:	2e4000ef          	jal	ra,c0016af4 <XIic_Reset>

	XIic_ClearStats(InstancePtr);
c0016814:	fec42503          	lw	a0,-20(s0)
c0016818:	0c5030ef          	jal	ra,c001a0dc <XIic_ClearStats>

	return XST_SUCCESS;
c001681c:	00000793          	li	a5,0
}
c0016820:	00078513          	mv	a0,a5
c0016824:	01c12083          	lw	ra,28(sp)
c0016828:	01812403          	lw	s0,24(sp)
c001682c:	02010113          	addi	sp,sp,32
c0016830:	00008067          	ret

c0016834 <XIic_Start>:
* to use the device. Stopping the device completely stops all device
* interrupts from the processor.
*
****************************************************************************/
int XIic_Start(XIic *InstancePtr)
{
c0016834:	fe010113          	addi	sp,sp,-32
c0016838:	00112e23          	sw	ra,28(sp)
c001683c:	00812c23          	sw	s0,24(sp)
c0016840:	00912a23          	sw	s1,20(sp)
c0016844:	02010413          	addi	s0,sp,32
c0016848:	fea42623          	sw	a0,-20(s0)
	Xil_AssertNonvoid(InstancePtr != NULL);
c001684c:	fec42783          	lw	a5,-20(s0)
c0016850:	02078463          	beqz	a5,c0016878 <XIic_Start+0x44>
c0016854:	07fec797          	auipc	a5,0x7fec
c0016858:	0c078793          	addi	a5,a5,192 # c8002914 <Xil_AssertStatus>
c001685c:	0007a023          	sw	zero,0(a5)
	Xil_AssertNonvoid(InstancePtr->IsReady == XIL_COMPONENT_IS_READY);
c0016860:	fec42783          	lw	a5,-20(s0)
c0016864:	0147a703          	lw	a4,20(a5)
c0016868:	111117b7          	lui	a5,0x11111
c001686c:	11178793          	addi	a5,a5,273 # 11111111 <_DMEM_LENGTH+0x10911111>
c0016870:	14f71a63          	bne	a4,a5,c00169c4 <XIic_Start+0x190>
c0016874:	02c0006f          	j	c00168a0 <XIic_Start+0x6c>
	Xil_AssertNonvoid(InstancePtr != NULL);
c0016878:	0ef00593          	li	a1,239
c001687c:	07feb517          	auipc	a0,0x7feb
c0016880:	03850513          	addi	a0,a0,56 # c80018b4 <__rodata_start+0x18b4>
c0016884:	238070ef          	jal	ra,c001dabc <Xil_Assert>
c0016888:	07fec797          	auipc	a5,0x7fec
c001688c:	08c78793          	addi	a5,a5,140 # c8002914 <Xil_AssertStatus>
c0016890:	00100713          	li	a4,1
c0016894:	00e7a023          	sw	a4,0(a5)
c0016898:	00000793          	li	a5,0
c001689c:	14c0006f          	j	c00169e8 <XIic_Start+0x1b4>
	Xil_AssertNonvoid(InstancePtr->IsReady == XIL_COMPONENT_IS_READY);
c00168a0:	07fec797          	auipc	a5,0x7fec
c00168a4:	07478793          	addi	a5,a5,116 # c8002914 <Xil_AssertStatus>
c00168a8:	0007a023          	sw	zero,0(a5)

	/*
	 * Mask off all interrupts, each is enabled when needed.
	 */
	XIic_WriteIier(InstancePtr->BaseAddress, 0);
c00168ac:	fec42783          	lw	a5,-20(s0)
c00168b0:	00c7a783          	lw	a5,12(a5)
c00168b4:	02878793          	addi	a5,a5,40
c00168b8:	00000593          	li	a1,0
c00168bc:	00078513          	mv	a0,a5
c00168c0:	df1ff0ef          	jal	ra,c00166b0 <Xil_Out32>

	/*
	 * Clear all interrupts by reading and rewriting exact value back.
	 * Only those bits set will get written as 1 (writing 1 clears intr).
	 */
	XIic_ClearIntr(InstancePtr->BaseAddress, 0xFFFFFFFF);
c00168c4:	fec42783          	lw	a5,-20(s0)
c00168c8:	00c7a783          	lw	a5,12(a5)
c00168cc:	02078493          	addi	s1,a5,32
c00168d0:	fec42783          	lw	a5,-20(s0)
c00168d4:	00c7a783          	lw	a5,12(a5)
c00168d8:	02078793          	addi	a5,a5,32
c00168dc:	00078513          	mv	a0,a5
c00168e0:	da9ff0ef          	jal	ra,c0016688 <Xil_In32>
c00168e4:	00050793          	mv	a5,a0
c00168e8:	00078593          	mv	a1,a5
c00168ec:	00048513          	mv	a0,s1
c00168f0:	dc1ff0ef          	jal	ra,c00166b0 <Xil_Out32>

	/*
	 * Enable the device.
	 */
	XIic_WriteReg(InstancePtr->BaseAddress, XIIC_CR_REG_OFFSET,
c00168f4:	fec42783          	lw	a5,-20(s0)
c00168f8:	00c7a783          	lw	a5,12(a5)
c00168fc:	10078793          	addi	a5,a5,256
c0016900:	00100593          	li	a1,1
c0016904:	00078513          	mv	a0,a5
c0016908:	da9ff0ef          	jal	ra,c00166b0 <Xil_Out32>
		 XIIC_CR_ENABLE_DEVICE_MASK);
	/*
	 * Set Rx FIFO Occupancy depth to throttle at
	 * first byte(after reset = 0).
	 */
	XIic_WriteReg(InstancePtr->BaseAddress, XIIC_RFD_REG_OFFSET, 0);
c001690c:	fec42783          	lw	a5,-20(s0)
c0016910:	00c7a783          	lw	a5,12(a5)
c0016914:	12078793          	addi	a5,a5,288
c0016918:	00000593          	li	a1,0
c001691c:	00078513          	mv	a0,a5
c0016920:	d91ff0ef          	jal	ra,c00166b0 <Xil_Out32>

	/*
	 * Clear and enable the interrupts needed.
	 */
	XIic_ClearEnableIntr(InstancePtr->BaseAddress,
c0016924:	fec42783          	lw	a5,-20(s0)
c0016928:	00c7a783          	lw	a5,12(a5)
c001692c:	02078493          	addi	s1,a5,32
c0016930:	fec42783          	lw	a5,-20(s0)
c0016934:	00c7a783          	lw	a5,12(a5)
c0016938:	02078793          	addi	a5,a5,32
c001693c:	00078513          	mv	a0,a5
c0016940:	d49ff0ef          	jal	ra,c0016688 <Xil_In32>
c0016944:	00050793          	mv	a5,a0
c0016948:	0217f793          	andi	a5,a5,33
c001694c:	00078593          	mv	a1,a5
c0016950:	00048513          	mv	a0,s1
c0016954:	d5dff0ef          	jal	ra,c00166b0 <Xil_Out32>
c0016958:	fec42783          	lw	a5,-20(s0)
c001695c:	00c7a783          	lw	a5,12(a5)
c0016960:	02878493          	addi	s1,a5,40
c0016964:	fec42783          	lw	a5,-20(s0)
c0016968:	00c7a783          	lw	a5,12(a5)
c001696c:	02878793          	addi	a5,a5,40
c0016970:	00078513          	mv	a0,a5
c0016974:	d15ff0ef          	jal	ra,c0016688 <Xil_In32>
c0016978:	00050793          	mv	a5,a0
c001697c:	0217e793          	ori	a5,a5,33
c0016980:	00078593          	mv	a1,a5
c0016984:	00048513          	mv	a0,s1
c0016988:	d29ff0ef          	jal	ra,c00166b0 <Xil_Out32>
				XIIC_INTR_AAS_MASK | XIIC_INTR_ARB_LOST_MASK);

	InstancePtr->IsStarted = XIL_COMPONENT_IS_STARTED;
c001698c:	fec42783          	lw	a5,-20(s0)
c0016990:	22222737          	lui	a4,0x22222
c0016994:	22270713          	addi	a4,a4,546 # 22222222 <_DMEM_LENGTH+0x21a22222>
c0016998:	00e7ac23          	sw	a4,24(a5)
	InstancePtr->IsDynamic = FALSE;
c001699c:	fec42783          	lw	a5,-20(s0)
c00169a0:	0407ac23          	sw	zero,88(a5)

	/*
	 * Enable the Global interrupt enable.
	 */
	XIic_IntrGlobalEnable(InstancePtr->BaseAddress);
c00169a4:	fec42783          	lw	a5,-20(s0)
c00169a8:	00c7a783          	lw	a5,12(a5)
c00169ac:	01c78793          	addi	a5,a5,28
c00169b0:	800005b7          	lui	a1,0x80000
c00169b4:	00078513          	mv	a0,a5
c00169b8:	cf9ff0ef          	jal	ra,c00166b0 <Xil_Out32>

	return XST_SUCCESS;
c00169bc:	00000793          	li	a5,0
c00169c0:	0280006f          	j	c00169e8 <XIic_Start+0x1b4>
	Xil_AssertNonvoid(InstancePtr->IsReady == XIL_COMPONENT_IS_READY);
c00169c4:	0f000593          	li	a1,240
c00169c8:	07feb517          	auipc	a0,0x7feb
c00169cc:	eec50513          	addi	a0,a0,-276 # c80018b4 <__rodata_start+0x18b4>
c00169d0:	0ec070ef          	jal	ra,c001dabc <Xil_Assert>
c00169d4:	07fec797          	auipc	a5,0x7fec
c00169d8:	f4078793          	addi	a5,a5,-192 # c8002914 <Xil_AssertStatus>
c00169dc:	00100713          	li	a4,1
c00169e0:	00e7a023          	sw	a4,0(a5)
c00169e4:	00000793          	li	a5,0
}
c00169e8:	00078513          	mv	a0,a5
c00169ec:	01c12083          	lw	ra,28(sp)
c00169f0:	01812403          	lw	s0,24(sp)
c00169f4:	01412483          	lw	s1,20(sp)
c00169f8:	02010113          	addi	sp,sp,32
c00169fc:	00008067          	ret

c0016a00 <XIic_Stop>:
*
* @note		None.
*
****************************************************************************/
int XIic_Stop(XIic *InstancePtr)
{
c0016a00:	fd010113          	addi	sp,sp,-48
c0016a04:	02112623          	sw	ra,44(sp)
c0016a08:	02812423          	sw	s0,40(sp)
c0016a0c:	03010413          	addi	s0,sp,48
c0016a10:	fca42e23          	sw	a0,-36(s0)
	u32 Status;
	u32 CntlReg;

	Xil_AssertNonvoid(InstancePtr != NULL);
c0016a14:	fdc42783          	lw	a5,-36(s0)
c0016a18:	06078463          	beqz	a5,c0016a80 <XIic_Stop+0x80>
c0016a1c:	07fec797          	auipc	a5,0x7fec
c0016a20:	ef878793          	addi	a5,a5,-264 # c8002914 <Xil_AssertStatus>
c0016a24:	0007a023          	sw	zero,0(a5)

	/*
	 * Disable all interrupts globally.
	 */
	XIic_IntrGlobalDisable(InstancePtr->BaseAddress);
c0016a28:	fdc42783          	lw	a5,-36(s0)
c0016a2c:	00c7a783          	lw	a5,12(a5)
c0016a30:	01c78793          	addi	a5,a5,28
c0016a34:	00000593          	li	a1,0
c0016a38:	00078513          	mv	a0,a5
c0016a3c:	c75ff0ef          	jal	ra,c00166b0 <Xil_Out32>

	CntlReg = XIic_ReadReg(InstancePtr->BaseAddress, XIIC_CR_REG_OFFSET);
c0016a40:	fdc42783          	lw	a5,-36(s0)
c0016a44:	00c7a783          	lw	a5,12(a5)
c0016a48:	10078793          	addi	a5,a5,256
c0016a4c:	00078513          	mv	a0,a5
c0016a50:	c39ff0ef          	jal	ra,c0016688 <Xil_In32>
c0016a54:	fea42623          	sw	a0,-20(s0)
	Status = XIic_ReadReg(InstancePtr->BaseAddress, XIIC_SR_REG_OFFSET);
c0016a58:	fdc42783          	lw	a5,-36(s0)
c0016a5c:	00c7a783          	lw	a5,12(a5)
c0016a60:	10478793          	addi	a5,a5,260
c0016a64:	00078513          	mv	a0,a5
c0016a68:	c21ff0ef          	jal	ra,c0016688 <Xil_In32>
c0016a6c:	fea42423          	sw	a0,-24(s0)

	if ((CntlReg & XIIC_CR_MSMS_MASK) ||
c0016a70:	fec42783          	lw	a5,-20(s0)
c0016a74:	0047f793          	andi	a5,a5,4
c0016a78:	02079e63          	bnez	a5,c0016ab4 <XIic_Stop+0xb4>
c0016a7c:	02c0006f          	j	c0016aa8 <XIic_Stop+0xa8>
	Xil_AssertNonvoid(InstancePtr != NULL);
c0016a80:	13900593          	li	a1,313
c0016a84:	07feb517          	auipc	a0,0x7feb
c0016a88:	e3050513          	addi	a0,a0,-464 # c80018b4 <__rodata_start+0x18b4>
c0016a8c:	030070ef          	jal	ra,c001dabc <Xil_Assert>
c0016a90:	07fec797          	auipc	a5,0x7fec
c0016a94:	e8478793          	addi	a5,a5,-380 # c8002914 <Xil_AssertStatus>
c0016a98:	00100713          	li	a4,1
c0016a9c:	00e7a023          	sw	a4,0(a5)
c0016aa0:	00000793          	li	a5,0
c0016aa4:	03c0006f          	j	c0016ae0 <XIic_Stop+0xe0>
		(Status & XIIC_SR_ADDR_AS_SLAVE_MASK)) {
c0016aa8:	fe842783          	lw	a5,-24(s0)
c0016aac:	0027f793          	andi	a5,a5,2
	if ((CntlReg & XIIC_CR_MSMS_MASK) ||
c0016ab0:	02078263          	beqz	a5,c0016ad4 <XIic_Stop+0xd4>
		/*
		 * When this device is using the bus
		 * - re-enable interrupts to finish current messaging
		 * - return bus busy
		 */
		XIic_IntrGlobalEnable(InstancePtr->BaseAddress);
c0016ab4:	fdc42783          	lw	a5,-36(s0)
c0016ab8:	00c7a783          	lw	a5,12(a5)
c0016abc:	01c78793          	addi	a5,a5,28
c0016ac0:	800005b7          	lui	a1,0x80000
c0016ac4:	00078513          	mv	a0,a5
c0016ac8:	be9ff0ef          	jal	ra,c00166b0 <Xil_Out32>

		return XST_IIC_BUS_BUSY;
c0016acc:	43500793          	li	a5,1077
c0016ad0:	0100006f          	j	c0016ae0 <XIic_Stop+0xe0>
	}

	InstancePtr->IsStarted = 0;
c0016ad4:	fdc42783          	lw	a5,-36(s0)
c0016ad8:	0007ac23          	sw	zero,24(a5)

	return XST_SUCCESS;
c0016adc:	00000793          	li	a5,0
}
c0016ae0:	00078513          	mv	a0,a5
c0016ae4:	02c12083          	lw	ra,44(sp)
c0016ae8:	02812403          	lw	s0,40(sp)
c0016aec:	03010113          	addi	sp,sp,48
c0016af0:	00008067          	ret

c0016af4 <XIic_Reset>:
*           the Interrupt Logic/Registers, please refer to the HW specification
*           for futher details about this.
*
****************************************************************************/
void XIic_Reset(XIic *InstancePtr)
{
c0016af4:	fe010113          	addi	sp,sp,-32
c0016af8:	00112e23          	sw	ra,28(sp)
c0016afc:	00812c23          	sw	s0,24(sp)
c0016b00:	02010413          	addi	s0,sp,32
c0016b04:	fea42623          	sw	a0,-20(s0)
	Xil_AssertVoid(InstancePtr != NULL);
c0016b08:	fec42783          	lw	a5,-20(s0)
c0016b0c:	02078463          	beqz	a5,c0016b34 <XIic_Reset+0x40>
c0016b10:	07fec797          	auipc	a5,0x7fec
c0016b14:	e0478793          	addi	a5,a5,-508 # c8002914 <Xil_AssertStatus>
c0016b18:	0007a023          	sw	zero,0(a5)
	Xil_AssertVoid(InstancePtr->IsReady == XIL_COMPONENT_IS_READY);
c0016b1c:	fec42783          	lw	a5,-20(s0)
c0016b20:	0147a703          	lw	a4,20(a5)
c0016b24:	111117b7          	lui	a5,0x11111
c0016b28:	11178793          	addi	a5,a5,273 # 11111111 <_DMEM_LENGTH+0x10911111>
c0016b2c:	04f71a63          	bne	a4,a5,c0016b80 <XIic_Reset+0x8c>
c0016b30:	0280006f          	j	c0016b58 <XIic_Reset+0x64>
	Xil_AssertVoid(InstancePtr != NULL);
c0016b34:	16500593          	li	a1,357
c0016b38:	07feb517          	auipc	a0,0x7feb
c0016b3c:	d7c50513          	addi	a0,a0,-644 # c80018b4 <__rodata_start+0x18b4>
c0016b40:	77d060ef          	jal	ra,c001dabc <Xil_Assert>
c0016b44:	07fec797          	auipc	a5,0x7fec
c0016b48:	dd078793          	addi	a5,a5,-560 # c8002914 <Xil_AssertStatus>
c0016b4c:	00100713          	li	a4,1
c0016b50:	00e7a023          	sw	a4,0(a5)
c0016b54:	0500006f          	j	c0016ba4 <XIic_Reset+0xb0>
	Xil_AssertVoid(InstancePtr->IsReady == XIL_COMPONENT_IS_READY);
c0016b58:	07fec797          	auipc	a5,0x7fec
c0016b5c:	dbc78793          	addi	a5,a5,-580 # c8002914 <Xil_AssertStatus>
c0016b60:	0007a023          	sw	zero,0(a5)

	XIic_WriteReg(InstancePtr->BaseAddress, XIIC_RESETR_OFFSET,
c0016b64:	fec42783          	lw	a5,-20(s0)
c0016b68:	00c7a783          	lw	a5,12(a5)
c0016b6c:	04078793          	addi	a5,a5,64
c0016b70:	00a00593          	li	a1,10
c0016b74:	00078513          	mv	a0,a5
c0016b78:	b39ff0ef          	jal	ra,c00166b0 <Xil_Out32>
c0016b7c:	0280006f          	j	c0016ba4 <XIic_Reset+0xb0>
	Xil_AssertVoid(InstancePtr->IsReady == XIL_COMPONENT_IS_READY);
c0016b80:	16600593          	li	a1,358
c0016b84:	07feb517          	auipc	a0,0x7feb
c0016b88:	d3050513          	addi	a0,a0,-720 # c80018b4 <__rodata_start+0x18b4>
c0016b8c:	731060ef          	jal	ra,c001dabc <Xil_Assert>
c0016b90:	07fec797          	auipc	a5,0x7fec
c0016b94:	d8478793          	addi	a5,a5,-636 # c8002914 <Xil_AssertStatus>
c0016b98:	00100713          	li	a4,1
c0016b9c:	00e7a023          	sw	a4,0(a5)
c0016ba0:	00000013          	nop
			XIIC_RESET_MASK);
}
c0016ba4:	01c12083          	lw	ra,28(sp)
c0016ba8:	01812403          	lw	s0,24(sp)
c0016bac:	02010113          	addi	sp,sp,32
c0016bb0:	00008067          	ret

c0016bb4 <XIic_SetAddress>:
* Upper bits of 10-bit address is written only when current device is built
* as a ten bit device.
*
****************************************************************************/
int XIic_SetAddress(XIic *InstancePtr, int AddressType, int Address)
{
c0016bb4:	fd010113          	addi	sp,sp,-48
c0016bb8:	02112623          	sw	ra,44(sp)
c0016bbc:	02812423          	sw	s0,40(sp)
c0016bc0:	03010413          	addi	s0,sp,48
c0016bc4:	fca42e23          	sw	a0,-36(s0)
c0016bc8:	fcb42c23          	sw	a1,-40(s0)
c0016bcc:	fcc42a23          	sw	a2,-44(s0)
	u32 SendAddr;

	Xil_AssertNonvoid(InstancePtr != NULL);
c0016bd0:	fdc42783          	lw	a5,-36(s0)
c0016bd4:	02078063          	beqz	a5,c0016bf4 <XIic_SetAddress+0x40>
c0016bd8:	07fec797          	auipc	a5,0x7fec
c0016bdc:	d3c78793          	addi	a5,a5,-708 # c8002914 <Xil_AssertStatus>
c0016be0:	0007a023          	sw	zero,0(a5)
	Xil_AssertNonvoid(Address < 1023);
c0016be4:	fd442703          	lw	a4,-44(s0)
c0016be8:	3fe00793          	li	a5,1022
c0016bec:	04e7c663          	blt	a5,a4,c0016c38 <XIic_SetAddress+0x84>
c0016bf0:	02c0006f          	j	c0016c1c <XIic_SetAddress+0x68>
	Xil_AssertNonvoid(InstancePtr != NULL);
c0016bf4:	19f00593          	li	a1,415
c0016bf8:	07feb517          	auipc	a0,0x7feb
c0016bfc:	cbc50513          	addi	a0,a0,-836 # c80018b4 <__rodata_start+0x18b4>
c0016c00:	6bd060ef          	jal	ra,c001dabc <Xil_Assert>
c0016c04:	07fec797          	auipc	a5,0x7fec
c0016c08:	d1078793          	addi	a5,a5,-752 # c8002914 <Xil_AssertStatus>
c0016c0c:	00100713          	li	a4,1
c0016c10:	00e7a023          	sw	a4,0(a5)
c0016c14:	00000793          	li	a5,0
c0016c18:	0d40006f          	j	c0016cec <XIic_SetAddress+0x138>
	Xil_AssertNonvoid(Address < 1023);
c0016c1c:	07fec797          	auipc	a5,0x7fec
c0016c20:	cf878793          	addi	a5,a5,-776 # c8002914 <Xil_AssertStatus>
c0016c24:	0007a023          	sw	zero,0(a5)

	/*
	 * Set address to respond to for this device into address registers.
	 */
	if (AddressType == XII_ADDR_TO_RESPOND_TYPE) {
c0016c28:	fd842703          	lw	a4,-40(s0)
c0016c2c:	00200793          	li	a5,2
c0016c30:	08f71c63          	bne	a4,a5,c0016cc8 <XIic_SetAddress+0x114>
c0016c34:	02c0006f          	j	c0016c60 <XIic_SetAddress+0xac>
	Xil_AssertNonvoid(Address < 1023);
c0016c38:	1a000593          	li	a1,416
c0016c3c:	07feb517          	auipc	a0,0x7feb
c0016c40:	c7850513          	addi	a0,a0,-904 # c80018b4 <__rodata_start+0x18b4>
c0016c44:	679060ef          	jal	ra,c001dabc <Xil_Assert>
c0016c48:	07fec797          	auipc	a5,0x7fec
c0016c4c:	ccc78793          	addi	a5,a5,-820 # c8002914 <Xil_AssertStatus>
c0016c50:	00100713          	li	a4,1
c0016c54:	00e7a023          	sw	a4,0(a5)
c0016c58:	00000793          	li	a5,0
c0016c5c:	0900006f          	j	c0016cec <XIic_SetAddress+0x138>
		/*
		 * Address in upper 7 bits.
		 */
		SendAddr = ((Address & 0x007F) << 1);
c0016c60:	fd442783          	lw	a5,-44(s0)
c0016c64:	00179793          	slli	a5,a5,0x1
c0016c68:	0ff7f793          	andi	a5,a5,255
c0016c6c:	fef42623          	sw	a5,-20(s0)
		XIic_WriteReg(InstancePtr->BaseAddress, XIIC_ADR_REG_OFFSET,
c0016c70:	fdc42783          	lw	a5,-36(s0)
c0016c74:	00c7a783          	lw	a5,12(a5)
c0016c78:	11078793          	addi	a5,a5,272
c0016c7c:	fec42583          	lw	a1,-20(s0)
c0016c80:	00078513          	mv	a0,a5
c0016c84:	a2dff0ef          	jal	ra,c00166b0 <Xil_Out32>
				SendAddr);

		if (InstancePtr->Has10BitAddr == TRUE) {
c0016c88:	fdc42783          	lw	a5,-36(s0)
c0016c8c:	0107a703          	lw	a4,16(a5)
c0016c90:	00100793          	li	a5,1
c0016c94:	02f71663          	bne	a4,a5,c0016cc0 <XIic_SetAddress+0x10c>
			/*
			 * Write upper 3 bits of addr to DTR only when 10 bit
			 * option included in design i.e. register exists.
			 */
			SendAddr = ((Address & 0x0380) >> 7);
c0016c98:	fd442783          	lw	a5,-44(s0)
c0016c9c:	4077d793          	srai	a5,a5,0x7
c0016ca0:	0077f793          	andi	a5,a5,7
c0016ca4:	fef42623          	sw	a5,-20(s0)
			XIic_WriteReg(InstancePtr->BaseAddress,
c0016ca8:	fdc42783          	lw	a5,-36(s0)
c0016cac:	00c7a783          	lw	a5,12(a5)
c0016cb0:	11c78793          	addi	a5,a5,284
c0016cb4:	fec42583          	lw	a1,-20(s0)
c0016cb8:	00078513          	mv	a0,a5
c0016cbc:	9f5ff0ef          	jal	ra,c00166b0 <Xil_Out32>
					XIIC_TBA_REG_OFFSET, SendAddr);
		}

		return XST_SUCCESS;
c0016cc0:	00000793          	li	a5,0
c0016cc4:	0280006f          	j	c0016cec <XIic_SetAddress+0x138>
	}

	/*
	 * Store address of slave device being read from.
	 */
	if (AddressType == XII_ADDR_TO_SEND_TYPE) {
c0016cc8:	fd842703          	lw	a4,-40(s0)
c0016ccc:	00100793          	li	a5,1
c0016cd0:	00f71c63          	bne	a4,a5,c0016ce8 <XIic_SetAddress+0x134>
		InstancePtr->AddrOfSlave = Address;
c0016cd4:	fdc42783          	lw	a5,-36(s0)
c0016cd8:	fd442703          	lw	a4,-44(s0)
c0016cdc:	00e7ae23          	sw	a4,28(a5)
		return XST_SUCCESS;
c0016ce0:	00000793          	li	a5,0
c0016ce4:	0080006f          	j	c0016cec <XIic_SetAddress+0x138>
	}

	return XST_INVALID_PARAM;
c0016ce8:	00f00793          	li	a5,15
}
c0016cec:	00078513          	mv	a0,a5
c0016cf0:	02c12083          	lw	ra,44(sp)
c0016cf4:	02812403          	lw	s0,40(sp)
c0016cf8:	03010113          	addi	sp,sp,48
c0016cfc:	00008067          	ret

c0016d00 <XIic_GetAddress>:
*
* @note		None.
*
****************************************************************************/
u16 XIic_GetAddress(XIic *InstancePtr, int AddressType)
{
c0016d00:	fd010113          	addi	sp,sp,-48
c0016d04:	02112623          	sw	ra,44(sp)
c0016d08:	02812423          	sw	s0,40(sp)
c0016d0c:	03010413          	addi	s0,sp,48
c0016d10:	fca42e23          	sw	a0,-36(s0)
c0016d14:	fcb42c23          	sw	a1,-40(s0)
	u8  LowAddr;
	u16 HighAddr = 0;
c0016d18:	fe041723          	sh	zero,-18(s0)

	Xil_AssertNonvoid(InstancePtr != NULL);
c0016d1c:	fdc42783          	lw	a5,-36(s0)
c0016d20:	02078063          	beqz	a5,c0016d40 <XIic_GetAddress+0x40>
c0016d24:	07fec797          	auipc	a5,0x7fec
c0016d28:	bf078793          	addi	a5,a5,-1040 # c8002914 <Xil_AssertStatus>
c0016d2c:	0007a023          	sw	zero,0(a5)

	/*
	 * Return this device's address.
	 */
	if (AddressType == XII_ADDR_TO_RESPOND_TYPE) {
c0016d30:	fd842703          	lw	a4,-40(s0)
c0016d34:	00200793          	li	a5,2
c0016d38:	0af71663          	bne	a4,a5,c0016de4 <XIic_GetAddress+0xe4>
c0016d3c:	02c0006f          	j	c0016d68 <XIic_GetAddress+0x68>
	Xil_AssertNonvoid(InstancePtr != NULL);
c0016d40:	1e300593          	li	a1,483
c0016d44:	07feb517          	auipc	a0,0x7feb
c0016d48:	b7050513          	addi	a0,a0,-1168 # c80018b4 <__rodata_start+0x18b4>
c0016d4c:	571060ef          	jal	ra,c001dabc <Xil_Assert>
c0016d50:	07fec797          	auipc	a5,0x7fec
c0016d54:	bc478793          	addi	a5,a5,-1084 # c8002914 <Xil_AssertStatus>
c0016d58:	00100713          	li	a4,1
c0016d5c:	00e7a023          	sw	a4,0(a5)
c0016d60:	00000793          	li	a5,0
c0016d64:	0900006f          	j	c0016df4 <XIic_GetAddress+0xf4>

		LowAddr = (u8) XIic_ReadReg(InstancePtr->BaseAddress,
c0016d68:	fdc42783          	lw	a5,-36(s0)
c0016d6c:	00c7a783          	lw	a5,12(a5)
c0016d70:	11078793          	addi	a5,a5,272
c0016d74:	00078513          	mv	a0,a5
c0016d78:	911ff0ef          	jal	ra,c0016688 <Xil_In32>
c0016d7c:	00050793          	mv	a5,a0
c0016d80:	fef406a3          	sb	a5,-19(s0)
					     XIIC_ADR_REG_OFFSET);

		if (InstancePtr->Has10BitAddr == TRUE) {
c0016d84:	fdc42783          	lw	a5,-36(s0)
c0016d88:	0107a703          	lw	a4,16(a5)
c0016d8c:	00100793          	li	a5,1
c0016d90:	02f71063          	bne	a4,a5,c0016db0 <XIic_GetAddress+0xb0>
			HighAddr = (u16) XIic_ReadReg(InstancePtr->BaseAddress,
c0016d94:	fdc42783          	lw	a5,-36(s0)
c0016d98:	00c7a783          	lw	a5,12(a5)
c0016d9c:	11c78793          	addi	a5,a5,284
c0016da0:	00078513          	mv	a0,a5
c0016da4:	8e5ff0ef          	jal	ra,c0016688 <Xil_In32>
c0016da8:	00050793          	mv	a5,a0
c0016dac:	fef41723          	sh	a5,-18(s0)
							XIIC_TBA_REG_OFFSET);
		}
		return ((HighAddr << 8) | (u16) LowAddr);
c0016db0:	fee45783          	lhu	a5,-18(s0)
c0016db4:	00879793          	slli	a5,a5,0x8
c0016db8:	01079713          	slli	a4,a5,0x10
c0016dbc:	41075713          	srai	a4,a4,0x10
c0016dc0:	fed44783          	lbu	a5,-19(s0)
c0016dc4:	01079793          	slli	a5,a5,0x10
c0016dc8:	4107d793          	srai	a5,a5,0x10
c0016dcc:	00f767b3          	or	a5,a4,a5
c0016dd0:	01079793          	slli	a5,a5,0x10
c0016dd4:	4107d793          	srai	a5,a5,0x10
c0016dd8:	01079793          	slli	a5,a5,0x10
c0016ddc:	0107d793          	srli	a5,a5,0x10
c0016de0:	0140006f          	j	c0016df4 <XIic_GetAddress+0xf4>
	}

	/*
	 * Otherwise return address of slave device on the IIC bus.
	 */
	return InstancePtr->AddrOfSlave;
c0016de4:	fdc42783          	lw	a5,-36(s0)
c0016de8:	01c7a783          	lw	a5,28(a5)
c0016dec:	01079793          	slli	a5,a5,0x10
c0016df0:	0107d793          	srli	a5,a5,0x10
}
c0016df4:	00078513          	mv	a0,a5
c0016df8:	02c12083          	lw	ra,44(sp)
c0016dfc:	02812403          	lw	s0,40(sp)
c0016e00:	03010113          	addi	sp,sp,48
c0016e04:	00008067          	ret

c0016e08 <XIic_SetGpOutput>:
*
* @note		None.
*
****************************************************************************/
int XIic_SetGpOutput(XIic *InstancePtr, u8 OutputValue)
{
c0016e08:	fe010113          	addi	sp,sp,-32
c0016e0c:	00112e23          	sw	ra,28(sp)
c0016e10:	00812c23          	sw	s0,24(sp)
c0016e14:	02010413          	addi	s0,sp,32
c0016e18:	fea42623          	sw	a0,-20(s0)
c0016e1c:	00058793          	mv	a5,a1
c0016e20:	fef405a3          	sb	a5,-21(s0)
	Xil_AssertNonvoid(InstancePtr != NULL);
c0016e24:	fec42783          	lw	a5,-20(s0)
c0016e28:	02078063          	beqz	a5,c0016e48 <XIic_SetGpOutput+0x40>
c0016e2c:	07fec797          	auipc	a5,0x7fec
c0016e30:	ae878793          	addi	a5,a5,-1304 # c8002914 <Xil_AssertStatus>
c0016e34:	0007a023          	sw	zero,0(a5)

	/*
	 * If the general purpose output register is implemented by the hardware
	 * then write the specified value to it, otherwise indicate an error.
	 */
	if (InstancePtr->GpOutWidth > 0) {
c0016e38:	fec42783          	lw	a5,-20(s0)
c0016e3c:	03c7c783          	lbu	a5,60(a5)
c0016e40:	04078a63          	beqz	a5,c0016e94 <XIic_SetGpOutput+0x8c>
c0016e44:	02c0006f          	j	c0016e70 <XIic_SetGpOutput+0x68>
	Xil_AssertNonvoid(InstancePtr != NULL);
c0016e48:	21100593          	li	a1,529
c0016e4c:	07feb517          	auipc	a0,0x7feb
c0016e50:	a6850513          	addi	a0,a0,-1432 # c80018b4 <__rodata_start+0x18b4>
c0016e54:	469060ef          	jal	ra,c001dabc <Xil_Assert>
c0016e58:	07fec797          	auipc	a5,0x7fec
c0016e5c:	abc78793          	addi	a5,a5,-1348 # c8002914 <Xil_AssertStatus>
c0016e60:	00100713          	li	a4,1
c0016e64:	00e7a023          	sw	a4,0(a5)
c0016e68:	00000793          	li	a5,0
c0016e6c:	02c0006f          	j	c0016e98 <XIic_SetGpOutput+0x90>
		XIic_WriteReg(InstancePtr->BaseAddress, XIIC_GPO_REG_OFFSET,
c0016e70:	fec42783          	lw	a5,-20(s0)
c0016e74:	00c7a783          	lw	a5,12(a5)
c0016e78:	12478793          	addi	a5,a5,292
c0016e7c:	feb44703          	lbu	a4,-21(s0)
c0016e80:	00070593          	mv	a1,a4
c0016e84:	00078513          	mv	a0,a5
c0016e88:	829ff0ef          	jal	ra,c00166b0 <Xil_Out32>
				OutputValue);
		return XST_SUCCESS;
c0016e8c:	00000793          	li	a5,0
c0016e90:	0080006f          	j	c0016e98 <XIic_SetGpOutput+0x90>
	} else {
		return XST_NO_FEATURE;
c0016e94:	01300793          	li	a5,19
	}
}
c0016e98:	00078513          	mv	a0,a5
c0016e9c:	01c12083          	lw	ra,28(sp)
c0016ea0:	01812403          	lw	s0,24(sp)
c0016ea4:	02010113          	addi	sp,sp,32
c0016ea8:	00008067          	ret

c0016eac <XIic_GetGpOutput>:
*
* @note		None.
*
****************************************************************************/
int XIic_GetGpOutput(XIic *InstancePtr, u8 *OutputValuePtr)
{
c0016eac:	fe010113          	addi	sp,sp,-32
c0016eb0:	00112e23          	sw	ra,28(sp)
c0016eb4:	00812c23          	sw	s0,24(sp)
c0016eb8:	02010413          	addi	s0,sp,32
c0016ebc:	fea42623          	sw	a0,-20(s0)
c0016ec0:	feb42423          	sw	a1,-24(s0)
	Xil_AssertNonvoid(InstancePtr != NULL);
c0016ec4:	fec42783          	lw	a5,-20(s0)
c0016ec8:	00078e63          	beqz	a5,c0016ee4 <XIic_GetGpOutput+0x38>
c0016ecc:	07fec797          	auipc	a5,0x7fec
c0016ed0:	a4878793          	addi	a5,a5,-1464 # c8002914 <Xil_AssertStatus>
c0016ed4:	0007a023          	sw	zero,0(a5)
	Xil_AssertNonvoid(OutputValuePtr != NULL);
c0016ed8:	fe842783          	lw	a5,-24(s0)
c0016edc:	04078663          	beqz	a5,c0016f28 <XIic_GetGpOutput+0x7c>
c0016ee0:	02c0006f          	j	c0016f0c <XIic_GetGpOutput+0x60>
	Xil_AssertNonvoid(InstancePtr != NULL);
c0016ee4:	23800593          	li	a1,568
c0016ee8:	07feb517          	auipc	a0,0x7feb
c0016eec:	9cc50513          	addi	a0,a0,-1588 # c80018b4 <__rodata_start+0x18b4>
c0016ef0:	3cd060ef          	jal	ra,c001dabc <Xil_Assert>
c0016ef4:	07fec797          	auipc	a5,0x7fec
c0016ef8:	a2078793          	addi	a5,a5,-1504 # c8002914 <Xil_AssertStatus>
c0016efc:	00100713          	li	a4,1
c0016f00:	00e7a023          	sw	a4,0(a5)
c0016f04:	00000793          	li	a5,0
c0016f08:	0780006f          	j	c0016f80 <XIic_GetGpOutput+0xd4>
	Xil_AssertNonvoid(OutputValuePtr != NULL);
c0016f0c:	07fec797          	auipc	a5,0x7fec
c0016f10:	a0878793          	addi	a5,a5,-1528 # c8002914 <Xil_AssertStatus>
c0016f14:	0007a023          	sw	zero,0(a5)

	/*
	 * If the general purpose output register is implemented by the hardware
	 * then read the value from it, otherwise indicate an error.
	 */
	if (InstancePtr->GpOutWidth > 0) {
c0016f18:	fec42783          	lw	a5,-20(s0)
c0016f1c:	03c7c783          	lbu	a5,60(a5)
c0016f20:	04078e63          	beqz	a5,c0016f7c <XIic_GetGpOutput+0xd0>
c0016f24:	02c0006f          	j	c0016f50 <XIic_GetGpOutput+0xa4>
	Xil_AssertNonvoid(OutputValuePtr != NULL);
c0016f28:	23900593          	li	a1,569
c0016f2c:	07feb517          	auipc	a0,0x7feb
c0016f30:	98850513          	addi	a0,a0,-1656 # c80018b4 <__rodata_start+0x18b4>
c0016f34:	389060ef          	jal	ra,c001dabc <Xil_Assert>
c0016f38:	07fec797          	auipc	a5,0x7fec
c0016f3c:	9dc78793          	addi	a5,a5,-1572 # c8002914 <Xil_AssertStatus>
c0016f40:	00100713          	li	a4,1
c0016f44:	00e7a023          	sw	a4,0(a5)
c0016f48:	00000793          	li	a5,0
c0016f4c:	0340006f          	j	c0016f80 <XIic_GetGpOutput+0xd4>
		*OutputValuePtr = XIic_ReadReg(InstancePtr->BaseAddress,
c0016f50:	fec42783          	lw	a5,-20(s0)
c0016f54:	00c7a783          	lw	a5,12(a5)
c0016f58:	12478793          	addi	a5,a5,292
c0016f5c:	00078513          	mv	a0,a5
c0016f60:	f28ff0ef          	jal	ra,c0016688 <Xil_In32>
c0016f64:	00050793          	mv	a5,a0
c0016f68:	0ff7f713          	andi	a4,a5,255
c0016f6c:	fe842783          	lw	a5,-24(s0)
c0016f70:	00e78023          	sb	a4,0(a5)
						XIIC_GPO_REG_OFFSET);
		return XST_SUCCESS;
c0016f74:	00000793          	li	a5,0
c0016f78:	0080006f          	j	c0016f80 <XIic_GetGpOutput+0xd4>
	} else {
		return XST_NO_FEATURE;
c0016f7c:	01300793          	li	a5,19
	}
}
c0016f80:	00078513          	mv	a0,a5
c0016f84:	01c12083          	lw	ra,28(sp)
c0016f88:	01812403          	lw	s0,24(sp)
c0016f8c:	02010113          	addi	sp,sp,32
c0016f90:	00008067          	ret

c0016f94 <XIic_IsSlave>:
*
* @note		None.
*
****************************************************************************/
u32 XIic_IsSlave(XIic *InstancePtr)
{
c0016f94:	fe010113          	addi	sp,sp,-32
c0016f98:	00112e23          	sw	ra,28(sp)
c0016f9c:	00812c23          	sw	s0,24(sp)
c0016fa0:	02010413          	addi	s0,sp,32
c0016fa4:	fea42623          	sw	a0,-20(s0)
	Xil_AssertNonvoid(InstancePtr != NULL);
c0016fa8:	fec42783          	lw	a5,-20(s0)
c0016fac:	02078a63          	beqz	a5,c0016fe0 <XIic_IsSlave+0x4c>
c0016fb0:	07fec797          	auipc	a5,0x7fec
c0016fb4:	96478793          	addi	a5,a5,-1692 # c8002914 <Xil_AssertStatus>
c0016fb8:	0007a023          	sw	zero,0(a5)

	if ((XIic_ReadReg(InstancePtr->BaseAddress, XIIC_SR_REG_OFFSET) &
c0016fbc:	fec42783          	lw	a5,-20(s0)
c0016fc0:	00c7a783          	lw	a5,12(a5)
c0016fc4:	10478793          	addi	a5,a5,260
c0016fc8:	00078513          	mv	a0,a5
c0016fcc:	ebcff0ef          	jal	ra,c0016688 <Xil_In32>
c0016fd0:	00050793          	mv	a5,a0
c0016fd4:	0027f793          	andi	a5,a5,2
c0016fd8:	02079c63          	bnez	a5,c0017010 <XIic_IsSlave+0x7c>
c0016fdc:	02c0006f          	j	c0017008 <XIic_IsSlave+0x74>
	Xil_AssertNonvoid(InstancePtr != NULL);
c0016fe0:	25800593          	li	a1,600
c0016fe4:	07feb517          	auipc	a0,0x7feb
c0016fe8:	8d050513          	addi	a0,a0,-1840 # c80018b4 <__rodata_start+0x18b4>
c0016fec:	2d1060ef          	jal	ra,c001dabc <Xil_Assert>
c0016ff0:	07fec797          	auipc	a5,0x7fec
c0016ff4:	92478793          	addi	a5,a5,-1756 # c8002914 <Xil_AssertStatus>
c0016ff8:	00100713          	li	a4,1
c0016ffc:	00e7a023          	sw	a4,0(a5)
c0017000:	00000793          	li	a5,0
c0017004:	0100006f          	j	c0017014 <XIic_IsSlave+0x80>
		 XIIC_SR_ADDR_AS_SLAVE_MASK) == 0) {
		return FALSE;
c0017008:	00000793          	li	a5,0
c001700c:	0080006f          	j	c0017014 <XIic_IsSlave+0x80>
	}
	return TRUE;
c0017010:	00100793          	li	a5,1
}
c0017014:	00078513          	mv	a0,a5
c0017018:	01c12083          	lw	ra,28(sp)
c001701c:	01812403          	lw	s0,24(sp)
c0017020:	02010113          	addi	sp,sp,32
c0017024:	00008067          	ret

c0017028 <XIic_SetRecvHandler>:
* @note		The handler is called within interrupt context .
*
****************************************************************************/
void XIic_SetRecvHandler(XIic *InstancePtr, void *CallBackRef,
			 XIic_Handler FuncPtr)
{
c0017028:	fe010113          	addi	sp,sp,-32
c001702c:	00112e23          	sw	ra,28(sp)
c0017030:	00812c23          	sw	s0,24(sp)
c0017034:	02010413          	addi	s0,sp,32
c0017038:	fea42623          	sw	a0,-20(s0)
c001703c:	feb42423          	sw	a1,-24(s0)
c0017040:	fec42223          	sw	a2,-28(s0)
	Xil_AssertVoid(InstancePtr->IsReady == XIL_COMPONENT_IS_READY);
c0017044:	fec42783          	lw	a5,-20(s0)
c0017048:	0147a703          	lw	a4,20(a5)
c001704c:	111117b7          	lui	a5,0x11111
c0017050:	11178793          	addi	a5,a5,273 # 11111111 <_DMEM_LENGTH+0x10911111>
c0017054:	00f71e63          	bne	a4,a5,c0017070 <XIic_SetRecvHandler+0x48>
c0017058:	07fec797          	auipc	a5,0x7fec
c001705c:	8bc78793          	addi	a5,a5,-1860 # c8002914 <Xil_AssertStatus>
c0017060:	0007a023          	sw	zero,0(a5)
	Xil_AssertVoid(InstancePtr != NULL);
c0017064:	fec42783          	lw	a5,-20(s0)
c0017068:	04078263          	beqz	a5,c00170ac <XIic_SetRecvHandler+0x84>
c001706c:	0280006f          	j	c0017094 <XIic_SetRecvHandler+0x6c>
	Xil_AssertVoid(InstancePtr->IsReady == XIL_COMPONENT_IS_READY);
c0017070:	27c00593          	li	a1,636
c0017074:	07feb517          	auipc	a0,0x7feb
c0017078:	84050513          	addi	a0,a0,-1984 # c80018b4 <__rodata_start+0x18b4>
c001707c:	241060ef          	jal	ra,c001dabc <Xil_Assert>
c0017080:	07fec797          	auipc	a5,0x7fec
c0017084:	89478793          	addi	a5,a5,-1900 # c8002914 <Xil_AssertStatus>
c0017088:	00100713          	li	a4,1
c001708c:	00e7a023          	sw	a4,0(a5)
c0017090:	08c0006f          	j	c001711c <XIic_SetRecvHandler+0xf4>
	Xil_AssertVoid(InstancePtr != NULL);
c0017094:	07fec797          	auipc	a5,0x7fec
c0017098:	88078793          	addi	a5,a5,-1920 # c8002914 <Xil_AssertStatus>
c001709c:	0007a023          	sw	zero,0(a5)
	Xil_AssertVoid(FuncPtr != NULL);
c00170a0:	fe442783          	lw	a5,-28(s0)
c00170a4:	04078a63          	beqz	a5,c00170f8 <XIic_SetRecvHandler+0xd0>
c00170a8:	0280006f          	j	c00170d0 <XIic_SetRecvHandler+0xa8>
	Xil_AssertVoid(InstancePtr != NULL);
c00170ac:	27d00593          	li	a1,637
c00170b0:	07feb517          	auipc	a0,0x7feb
c00170b4:	80450513          	addi	a0,a0,-2044 # c80018b4 <__rodata_start+0x18b4>
c00170b8:	205060ef          	jal	ra,c001dabc <Xil_Assert>
c00170bc:	07fec797          	auipc	a5,0x7fec
c00170c0:	85878793          	addi	a5,a5,-1960 # c8002914 <Xil_AssertStatus>
c00170c4:	00100713          	li	a4,1
c00170c8:	00e7a023          	sw	a4,0(a5)
c00170cc:	0500006f          	j	c001711c <XIic_SetRecvHandler+0xf4>
	Xil_AssertVoid(FuncPtr != NULL);
c00170d0:	07fec797          	auipc	a5,0x7fec
c00170d4:	84478793          	addi	a5,a5,-1980 # c8002914 <Xil_AssertStatus>
c00170d8:	0007a023          	sw	zero,0(a5)

	InstancePtr->RecvHandler = FuncPtr;
c00170dc:	fec42783          	lw	a5,-20(s0)
c00170e0:	fe442703          	lw	a4,-28(s0)
c00170e4:	04e7a423          	sw	a4,72(a5)
	InstancePtr->RecvCallBackRef = CallBackRef;
c00170e8:	fec42783          	lw	a5,-20(s0)
c00170ec:	fe842703          	lw	a4,-24(s0)
c00170f0:	04e7a623          	sw	a4,76(a5)
c00170f4:	0280006f          	j	c001711c <XIic_SetRecvHandler+0xf4>
	Xil_AssertVoid(FuncPtr != NULL);
c00170f8:	27e00593          	li	a1,638
c00170fc:	07fea517          	auipc	a0,0x7fea
c0017100:	7b850513          	addi	a0,a0,1976 # c80018b4 <__rodata_start+0x18b4>
c0017104:	1b9060ef          	jal	ra,c001dabc <Xil_Assert>
c0017108:	07fec797          	auipc	a5,0x7fec
c001710c:	80c78793          	addi	a5,a5,-2036 # c8002914 <Xil_AssertStatus>
c0017110:	00100713          	li	a4,1
c0017114:	00e7a023          	sw	a4,0(a5)
c0017118:	00000013          	nop
}
c001711c:	01c12083          	lw	ra,28(sp)
c0017120:	01812403          	lw	s0,24(sp)
c0017124:	02010113          	addi	sp,sp,32
c0017128:	00008067          	ret

c001712c <XIic_SetSendHandler>:
* @note		The handler is called within interrupt context .
*
****************************************************************************/
void XIic_SetSendHandler(XIic *InstancePtr, void *CallBackRef,
			 XIic_Handler FuncPtr)
{
c001712c:	fe010113          	addi	sp,sp,-32
c0017130:	00112e23          	sw	ra,28(sp)
c0017134:	00812c23          	sw	s0,24(sp)
c0017138:	02010413          	addi	s0,sp,32
c001713c:	fea42623          	sw	a0,-20(s0)
c0017140:	feb42423          	sw	a1,-24(s0)
c0017144:	fec42223          	sw	a2,-28(s0)
	Xil_AssertVoid(InstancePtr != NULL);
c0017148:	fec42783          	lw	a5,-20(s0)
c001714c:	02078463          	beqz	a5,c0017174 <XIic_SetSendHandler+0x48>
c0017150:	07feb797          	auipc	a5,0x7feb
c0017154:	7c478793          	addi	a5,a5,1988 # c8002914 <Xil_AssertStatus>
c0017158:	0007a023          	sw	zero,0(a5)
	Xil_AssertVoid(InstancePtr->IsReady == XIL_COMPONENT_IS_READY);
c001715c:	fec42783          	lw	a5,-20(s0)
c0017160:	0147a703          	lw	a4,20(a5)
c0017164:	111117b7          	lui	a5,0x11111
c0017168:	11178793          	addi	a5,a5,273 # 11111111 <_DMEM_LENGTH+0x10911111>
c001716c:	04f71263          	bne	a4,a5,c00171b0 <XIic_SetSendHandler+0x84>
c0017170:	0280006f          	j	c0017198 <XIic_SetSendHandler+0x6c>
	Xil_AssertVoid(InstancePtr != NULL);
c0017174:	29900593          	li	a1,665
c0017178:	07fea517          	auipc	a0,0x7fea
c001717c:	73c50513          	addi	a0,a0,1852 # c80018b4 <__rodata_start+0x18b4>
c0017180:	13d060ef          	jal	ra,c001dabc <Xil_Assert>
c0017184:	07feb797          	auipc	a5,0x7feb
c0017188:	79078793          	addi	a5,a5,1936 # c8002914 <Xil_AssertStatus>
c001718c:	00100713          	li	a4,1
c0017190:	00e7a023          	sw	a4,0(a5)
c0017194:	08c0006f          	j	c0017220 <XIic_SetSendHandler+0xf4>
	Xil_AssertVoid(InstancePtr->IsReady == XIL_COMPONENT_IS_READY);
c0017198:	07feb797          	auipc	a5,0x7feb
c001719c:	77c78793          	addi	a5,a5,1916 # c8002914 <Xil_AssertStatus>
c00171a0:	0007a023          	sw	zero,0(a5)
	Xil_AssertVoid(FuncPtr != NULL);
c00171a4:	fe442783          	lw	a5,-28(s0)
c00171a8:	04078a63          	beqz	a5,c00171fc <XIic_SetSendHandler+0xd0>
c00171ac:	0280006f          	j	c00171d4 <XIic_SetSendHandler+0xa8>
	Xil_AssertVoid(InstancePtr->IsReady == XIL_COMPONENT_IS_READY);
c00171b0:	29a00593          	li	a1,666
c00171b4:	07fea517          	auipc	a0,0x7fea
c00171b8:	70050513          	addi	a0,a0,1792 # c80018b4 <__rodata_start+0x18b4>
c00171bc:	101060ef          	jal	ra,c001dabc <Xil_Assert>
c00171c0:	07feb797          	auipc	a5,0x7feb
c00171c4:	75478793          	addi	a5,a5,1876 # c8002914 <Xil_AssertStatus>
c00171c8:	00100713          	li	a4,1
c00171cc:	00e7a023          	sw	a4,0(a5)
c00171d0:	0500006f          	j	c0017220 <XIic_SetSendHandler+0xf4>
	Xil_AssertVoid(FuncPtr != NULL);
c00171d4:	07feb797          	auipc	a5,0x7feb
c00171d8:	74078793          	addi	a5,a5,1856 # c8002914 <Xil_AssertStatus>
c00171dc:	0007a023          	sw	zero,0(a5)

	InstancePtr->SendHandler = FuncPtr;
c00171e0:	fec42783          	lw	a5,-20(s0)
c00171e4:	fe442703          	lw	a4,-28(s0)
c00171e8:	04e7a823          	sw	a4,80(a5)
	InstancePtr->SendCallBackRef = CallBackRef;
c00171ec:	fec42783          	lw	a5,-20(s0)
c00171f0:	fe842703          	lw	a4,-24(s0)
c00171f4:	04e7aa23          	sw	a4,84(a5)
c00171f8:	0280006f          	j	c0017220 <XIic_SetSendHandler+0xf4>
	Xil_AssertVoid(FuncPtr != NULL);
c00171fc:	29b00593          	li	a1,667
c0017200:	07fea517          	auipc	a0,0x7fea
c0017204:	6b450513          	addi	a0,a0,1716 # c80018b4 <__rodata_start+0x18b4>
c0017208:	0b5060ef          	jal	ra,c001dabc <Xil_Assert>
c001720c:	07feb797          	auipc	a5,0x7feb
c0017210:	70878793          	addi	a5,a5,1800 # c8002914 <Xil_AssertStatus>
c0017214:	00100713          	li	a4,1
c0017218:	00e7a023          	sw	a4,0(a5)
c001721c:	00000013          	nop
}
c0017220:	01c12083          	lw	ra,28(sp)
c0017224:	01812403          	lw	s0,24(sp)
c0017228:	02010113          	addi	sp,sp,32
c001722c:	00008067          	ret

c0017230 <XIic_SetStatusHandler>:
* @note		The handler is called within interrupt context .
*
****************************************************************************/
void XIic_SetStatusHandler(XIic *InstancePtr, void *CallBackRef,
			   XIic_StatusHandler FuncPtr)
{
c0017230:	fe010113          	addi	sp,sp,-32
c0017234:	00112e23          	sw	ra,28(sp)
c0017238:	00812c23          	sw	s0,24(sp)
c001723c:	02010413          	addi	s0,sp,32
c0017240:	fea42623          	sw	a0,-20(s0)
c0017244:	feb42423          	sw	a1,-24(s0)
c0017248:	fec42223          	sw	a2,-28(s0)
	Xil_AssertVoid(InstancePtr != NULL);
c001724c:	fec42783          	lw	a5,-20(s0)
c0017250:	02078463          	beqz	a5,c0017278 <XIic_SetStatusHandler+0x48>
c0017254:	07feb797          	auipc	a5,0x7feb
c0017258:	6c078793          	addi	a5,a5,1728 # c8002914 <Xil_AssertStatus>
c001725c:	0007a023          	sw	zero,0(a5)
	Xil_AssertVoid(InstancePtr->IsReady == XIL_COMPONENT_IS_READY);
c0017260:	fec42783          	lw	a5,-20(s0)
c0017264:	0147a703          	lw	a4,20(a5)
c0017268:	111117b7          	lui	a5,0x11111
c001726c:	11178793          	addi	a5,a5,273 # 11111111 <_DMEM_LENGTH+0x10911111>
c0017270:	04f71263          	bne	a4,a5,c00172b4 <XIic_SetStatusHandler+0x84>
c0017274:	0280006f          	j	c001729c <XIic_SetStatusHandler+0x6c>
	Xil_AssertVoid(InstancePtr != NULL);
c0017278:	2b700593          	li	a1,695
c001727c:	07fea517          	auipc	a0,0x7fea
c0017280:	63850513          	addi	a0,a0,1592 # c80018b4 <__rodata_start+0x18b4>
c0017284:	039060ef          	jal	ra,c001dabc <Xil_Assert>
c0017288:	07feb797          	auipc	a5,0x7feb
c001728c:	68c78793          	addi	a5,a5,1676 # c8002914 <Xil_AssertStatus>
c0017290:	00100713          	li	a4,1
c0017294:	00e7a023          	sw	a4,0(a5)
c0017298:	08c0006f          	j	c0017324 <XIic_SetStatusHandler+0xf4>
	Xil_AssertVoid(InstancePtr->IsReady == XIL_COMPONENT_IS_READY);
c001729c:	07feb797          	auipc	a5,0x7feb
c00172a0:	67878793          	addi	a5,a5,1656 # c8002914 <Xil_AssertStatus>
c00172a4:	0007a023          	sw	zero,0(a5)
	Xil_AssertVoid(FuncPtr != NULL);
c00172a8:	fe442783          	lw	a5,-28(s0)
c00172ac:	04078a63          	beqz	a5,c0017300 <XIic_SetStatusHandler+0xd0>
c00172b0:	0280006f          	j	c00172d8 <XIic_SetStatusHandler+0xa8>
	Xil_AssertVoid(InstancePtr->IsReady == XIL_COMPONENT_IS_READY);
c00172b4:	2b800593          	li	a1,696
c00172b8:	07fea517          	auipc	a0,0x7fea
c00172bc:	5fc50513          	addi	a0,a0,1532 # c80018b4 <__rodata_start+0x18b4>
c00172c0:	7fc060ef          	jal	ra,c001dabc <Xil_Assert>
c00172c4:	07feb797          	auipc	a5,0x7feb
c00172c8:	65078793          	addi	a5,a5,1616 # c8002914 <Xil_AssertStatus>
c00172cc:	00100713          	li	a4,1
c00172d0:	00e7a023          	sw	a4,0(a5)
c00172d4:	0500006f          	j	c0017324 <XIic_SetStatusHandler+0xf4>
	Xil_AssertVoid(FuncPtr != NULL);
c00172d8:	07feb797          	auipc	a5,0x7feb
c00172dc:	63c78793          	addi	a5,a5,1596 # c8002914 <Xil_AssertStatus>
c00172e0:	0007a023          	sw	zero,0(a5)

	InstancePtr->StatusHandler = FuncPtr;
c00172e4:	fec42783          	lw	a5,-20(s0)
c00172e8:	fe442703          	lw	a4,-28(s0)
c00172ec:	04e7a023          	sw	a4,64(a5)
	InstancePtr->StatusCallBackRef = CallBackRef;
c00172f0:	fec42783          	lw	a5,-20(s0)
c00172f4:	fe842703          	lw	a4,-24(s0)
c00172f8:	04e7a223          	sw	a4,68(a5)
c00172fc:	0280006f          	j	c0017324 <XIic_SetStatusHandler+0xf4>
	Xil_AssertVoid(FuncPtr != NULL);
c0017300:	2b900593          	li	a1,697
c0017304:	07fea517          	auipc	a0,0x7fea
c0017308:	5b050513          	addi	a0,a0,1456 # c80018b4 <__rodata_start+0x18b4>
c001730c:	7b0060ef          	jal	ra,c001dabc <Xil_Assert>
c0017310:	07feb797          	auipc	a5,0x7feb
c0017314:	60478793          	addi	a5,a5,1540 # c8002914 <Xil_AssertStatus>
c0017318:	00100713          	li	a4,1
c001731c:	00e7a023          	sw	a4,0(a5)
c0017320:	00000013          	nop
}
c0017324:	01c12083          	lw	ra,28(sp)
c0017328:	01812403          	lw	s0,24(sp)
c001732c:	02010113          	addi	sp,sp,32
c0017330:	00008067          	ret

c0017334 <XIic_StubHandler>:
*
* @note		None.
*
******************************************************************************/
static void XIic_StubHandler(void *CallBackRef, int ByteCount)
{
c0017334:	fe010113          	addi	sp,sp,-32
c0017338:	00112e23          	sw	ra,28(sp)
c001733c:	00812c23          	sw	s0,24(sp)
c0017340:	02010413          	addi	s0,sp,32
c0017344:	fea42623          	sw	a0,-20(s0)
c0017348:	feb42423          	sw	a1,-24(s0)
	(void) ByteCount;
	(void) CallBackRef;
	Xil_AssertVoidAlways();
c001734c:	2d000593          	li	a1,720
c0017350:	07fea517          	auipc	a0,0x7fea
c0017354:	56450513          	addi	a0,a0,1380 # c80018b4 <__rodata_start+0x18b4>
c0017358:	764060ef          	jal	ra,c001dabc <Xil_Assert>
c001735c:	07feb797          	auipc	a5,0x7feb
c0017360:	5b878793          	addi	a5,a5,1464 # c8002914 <Xil_AssertStatus>
c0017364:	00100713          	li	a4,1
c0017368:	00e7a023          	sw	a4,0(a5)
c001736c:	00000013          	nop
}
c0017370:	01c12083          	lw	ra,28(sp)
c0017374:	01812403          	lw	s0,24(sp)
c0017378:	02010113          	addi	sp,sp,32
c001737c:	00008067          	ret

c0017380 <XIic_StubStatusHandler>:
*
* @note		None.
*
******************************************************************************/
static void XIic_StubStatusHandler(void *CallBackRef, int ErrorCode)
{
c0017380:	fe010113          	addi	sp,sp,-32
c0017384:	00112e23          	sw	ra,28(sp)
c0017388:	00812c23          	sw	s0,24(sp)
c001738c:	02010413          	addi	s0,sp,32
c0017390:	fea42623          	sw	a0,-20(s0)
c0017394:	feb42423          	sw	a1,-24(s0)
	(void) ErrorCode;
	(void) CallBackRef;
	Xil_AssertVoidAlways();
c0017398:	2e500593          	li	a1,741
c001739c:	07fea517          	auipc	a0,0x7fea
c00173a0:	51850513          	addi	a0,a0,1304 # c80018b4 <__rodata_start+0x18b4>
c00173a4:	718060ef          	jal	ra,c001dabc <Xil_Assert>
c00173a8:	07feb797          	auipc	a5,0x7feb
c00173ac:	56c78793          	addi	a5,a5,1388 # c8002914 <Xil_AssertStatus>
c00173b0:	00100713          	li	a4,1
c00173b4:	00e7a023          	sw	a4,0(a5)
c00173b8:	00000013          	nop
}
c00173bc:	01c12083          	lw	ra,28(sp)
c00173c0:	01812403          	lw	s0,24(sp)
c00173c4:	02010113          	addi	sp,sp,32
c00173c8:	00008067          	ret

c00173cc <Xil_In32>:
{
c00173cc:	fe010113          	addi	sp,sp,-32
c00173d0:	00812e23          	sw	s0,28(sp)
c00173d4:	02010413          	addi	s0,sp,32
c00173d8:	fea42623          	sw	a0,-20(s0)
	return *(volatile u32 *) Addr;
c00173dc:	fec42783          	lw	a5,-20(s0)
c00173e0:	0007a783          	lw	a5,0(a5)
}
c00173e4:	00078513          	mv	a0,a5
c00173e8:	01c12403          	lw	s0,28(sp)
c00173ec:	02010113          	addi	sp,sp,32
c00173f0:	00008067          	ret

c00173f4 <Xil_Out32>:
{
c00173f4:	fd010113          	addi	sp,sp,-48
c00173f8:	02812623          	sw	s0,44(sp)
c00173fc:	03010413          	addi	s0,sp,48
c0017400:	fca42e23          	sw	a0,-36(s0)
c0017404:	fcb42c23          	sw	a1,-40(s0)
	volatile u32 *LocalAddr = (volatile u32 *)Addr;
c0017408:	fdc42783          	lw	a5,-36(s0)
c001740c:	fef42623          	sw	a5,-20(s0)
	*LocalAddr = Value;
c0017410:	fec42783          	lw	a5,-20(s0)
c0017414:	fd842703          	lw	a4,-40(s0)
c0017418:	00e7a023          	sw	a4,0(a5)
}
c001741c:	00000013          	nop
c0017420:	02c12403          	lw	s0,44(sp)
c0017424:	03010113          	addi	sp,sp,48
c0017428:	00008067          	ret

c001742c <XIic_Recv>:
* @note		None.
*
******************************************************************************/
unsigned XIic_Recv(UINTPTR BaseAddress, u8 Address,
			u8 *BufferPtr, unsigned ByteCount, u8 Option)
{
c001742c:	fd010113          	addi	sp,sp,-48
c0017430:	02112623          	sw	ra,44(sp)
c0017434:	02812423          	sw	s0,40(sp)
c0017438:	02912223          	sw	s1,36(sp)
c001743c:	03010413          	addi	s0,sp,48
c0017440:	fca42e23          	sw	a0,-36(s0)
c0017444:	00058793          	mv	a5,a1
c0017448:	fcc42a23          	sw	a2,-44(s0)
c001744c:	fcd42823          	sw	a3,-48(s0)
c0017450:	fcf40da3          	sb	a5,-37(s0)
c0017454:	00070793          	mv	a5,a4
c0017458:	fcf40d23          	sb	a5,-38(s0)
	 * address goes out therefore Tx error must not be enabled as it will go
	 * off immediately and the Rx full interrupt will be checked.  If full,
	 * then the one byte was received and the Tx error will be disabled
	 * without sending an error callback msg
	 */
	XIic_ClearIisr(BaseAddress,
c001745c:	fdc42783          	lw	a5,-36(s0)
c0017460:	02078493          	addi	s1,a5,32
c0017464:	fdc42783          	lw	a5,-36(s0)
c0017468:	02078793          	addi	a5,a5,32
c001746c:	00078513          	mv	a0,a5
c0017470:	f5dff0ef          	jal	ra,c00173cc <Xil_In32>
c0017474:	00050793          	mv	a5,a0
c0017478:	00b7f793          	andi	a5,a5,11
c001747c:	00078593          	mv	a1,a5
c0017480:	00048513          	mv	a0,s1
c0017484:	f71ff0ef          	jal	ra,c00173f4 <Xil_Out32>
			XIIC_INTR_RX_FULL_MASK | XIIC_INTR_TX_ERROR_MASK |
			XIIC_INTR_ARB_LOST_MASK);

	/* Set receive FIFO occupancy depth for 1 byte (zero based) */
	XIic_WriteReg(BaseAddress,  XIIC_RFD_REG_OFFSET, 0);
c0017488:	fdc42783          	lw	a5,-36(s0)
c001748c:	12078793          	addi	a5,a5,288
c0017490:	00000593          	li	a1,0
c0017494:	00078513          	mv	a0,a5
c0017498:	f5dff0ef          	jal	ra,c00173f4 <Xil_Out32>

	/* Check to see if already Master on the Bus.
	 * If Repeated Start bit is not set send Start bit by setting MSMS bit
	 * else Send the address
	 */
	CntlReg = XIic_ReadReg(BaseAddress,  XIIC_CR_REG_OFFSET);
c001749c:	fdc42783          	lw	a5,-36(s0)
c00174a0:	10078793          	addi	a5,a5,256
c00174a4:	00078513          	mv	a0,a5
c00174a8:	f25ff0ef          	jal	ra,c00173cc <Xil_In32>
c00174ac:	fea42623          	sw	a0,-20(s0)
	if ((CntlReg & XIIC_CR_REPEATED_START_MASK) == 0) {
c00174b0:	fec42783          	lw	a5,-20(s0)
c00174b4:	0207f793          	andi	a5,a5,32
c00174b8:	0c079c63          	bnez	a5,c0017590 <XIic_Recv+0x164>
		/* 7 bit slave address, send the address for a read operation
		 * and set the state to indicate the address has been sent
		 */
		XIic_Send7BitAddress(BaseAddress, Address,
c00174bc:	fdb44783          	lbu	a5,-37(s0)
c00174c0:	00179793          	slli	a5,a5,0x1
c00174c4:	fef40523          	sb	a5,-22(s0)
c00174c8:	fea44783          	lbu	a5,-22(s0)
c00174cc:	0017e793          	ori	a5,a5,1
c00174d0:	fef40523          	sb	a5,-22(s0)
c00174d4:	fdc42783          	lw	a5,-36(s0)
c00174d8:	10878793          	addi	a5,a5,264
c00174dc:	fea44703          	lbu	a4,-22(s0)
c00174e0:	00070593          	mv	a1,a4
c00174e4:	00078513          	mv	a0,a5
c00174e8:	f0dff0ef          	jal	ra,c00173f4 <Xil_Out32>
		/* MSMS gets set after putting data in FIFO. Start the master
		 * receive operation by setting CR Bits MSMS to Master, if the
		 * buffer is only one byte, then it should not be acknowledged
		 * to indicate the end of data
		 */
		CntlReg = XIIC_CR_MSMS_MASK | XIIC_CR_ENABLE_DEVICE_MASK;
c00174ec:	00500793          	li	a5,5
c00174f0:	fef42623          	sw	a5,-20(s0)
		if (ByteCount == 1) {
c00174f4:	fd042703          	lw	a4,-48(s0)
c00174f8:	00100793          	li	a5,1
c00174fc:	00f71863          	bne	a4,a5,c001750c <XIic_Recv+0xe0>
			CntlReg |= XIIC_CR_NO_ACK_MASK;
c0017500:	fec42783          	lw	a5,-20(s0)
c0017504:	0107e793          	ori	a5,a5,16
c0017508:	fef42623          	sw	a5,-20(s0)
		}

		/* Write out the control register to start receiving data and
		 * call the function to receive each byte into the buffer
		 */
		XIic_WriteReg(BaseAddress,  XIIC_CR_REG_OFFSET, CntlReg);
c001750c:	fdc42783          	lw	a5,-36(s0)
c0017510:	10078793          	addi	a5,a5,256
c0017514:	fec42583          	lw	a1,-20(s0)
c0017518:	00078513          	mv	a0,a5
c001751c:	ed9ff0ef          	jal	ra,c00173f4 <Xil_Out32>

		/* Clear the latched interrupt status for the bus not busy bit
		 * which must be done while the bus is busy
		 */
		StatusReg = XIic_ReadReg(BaseAddress,  XIIC_SR_REG_OFFSET);
c0017520:	fdc42783          	lw	a5,-36(s0)
c0017524:	10478793          	addi	a5,a5,260
c0017528:	00078513          	mv	a0,a5
c001752c:	ea1ff0ef          	jal	ra,c00173cc <Xil_In32>
c0017530:	00050793          	mv	a5,a0
c0017534:	fef42023          	sw	a5,-32(s0)

		while ((StatusReg & XIIC_SR_BUS_BUSY_MASK) == 0) {
c0017538:	01c0006f          	j	c0017554 <XIic_Recv+0x128>
			StatusReg = XIic_ReadReg(BaseAddress,
c001753c:	fdc42783          	lw	a5,-36(s0)
c0017540:	10478793          	addi	a5,a5,260
c0017544:	00078513          	mv	a0,a5
c0017548:	e85ff0ef          	jal	ra,c00173cc <Xil_In32>
c001754c:	00050793          	mv	a5,a0
c0017550:	fef42023          	sw	a5,-32(s0)
		while ((StatusReg & XIIC_SR_BUS_BUSY_MASK) == 0) {
c0017554:	fe042783          	lw	a5,-32(s0)
c0017558:	0047f793          	andi	a5,a5,4
c001755c:	fe0780e3          	beqz	a5,c001753c <XIic_Recv+0x110>
						  XIIC_SR_REG_OFFSET);
		}

		XIic_ClearIisr(BaseAddress, XIIC_INTR_BNB_MASK);
c0017560:	fdc42783          	lw	a5,-36(s0)
c0017564:	02078493          	addi	s1,a5,32
c0017568:	fdc42783          	lw	a5,-36(s0)
c001756c:	02078793          	addi	a5,a5,32
c0017570:	00078513          	mv	a0,a5
c0017574:	e59ff0ef          	jal	ra,c00173cc <Xil_In32>
c0017578:	00050793          	mv	a5,a0
c001757c:	0107f793          	andi	a5,a5,16
c0017580:	00078593          	mv	a1,a5
c0017584:	00048513          	mv	a0,s1
c0017588:	e6dff0ef          	jal	ra,c00173f4 <Xil_Out32>
c001758c:	06c0006f          	j	c00175f8 <XIic_Recv+0x1cc>
	} else {
	        /* Before writing 7bit slave address the Direction of Tx bit
		 * must be disabled
		 */
		CntlReg &= ~XIIC_CR_DIR_IS_TX_MASK;
c0017590:	fec42783          	lw	a5,-20(s0)
c0017594:	ff77f793          	andi	a5,a5,-9
c0017598:	fef42623          	sw	a5,-20(s0)
		if (ByteCount == 1) {
c001759c:	fd042703          	lw	a4,-48(s0)
c00175a0:	00100793          	li	a5,1
c00175a4:	00f71863          	bne	a4,a5,c00175b4 <XIic_Recv+0x188>
			CntlReg |= XIIC_CR_NO_ACK_MASK;
c00175a8:	fec42783          	lw	a5,-20(s0)
c00175ac:	0107e793          	ori	a5,a5,16
c00175b0:	fef42623          	sw	a5,-20(s0)
		}
		XIic_WriteReg(BaseAddress,  XIIC_CR_REG_OFFSET, CntlReg);
c00175b4:	fdc42783          	lw	a5,-36(s0)
c00175b8:	10078793          	addi	a5,a5,256
c00175bc:	fec42583          	lw	a1,-20(s0)
c00175c0:	00078513          	mv	a0,a5
c00175c4:	e31ff0ef          	jal	ra,c00173f4 <Xil_Out32>
		/* Already owns the Bus indicating that its a Repeated Start
		 * call. 7 bit slave address, send the address for a read
		 * operation and set the state to indicate the address has been
		 * sent
		 */
		XIic_Send7BitAddress(BaseAddress, Address,
c00175c8:	fdb44783          	lbu	a5,-37(s0)
c00175cc:	00179793          	slli	a5,a5,0x1
c00175d0:	fef405a3          	sb	a5,-21(s0)
c00175d4:	feb44783          	lbu	a5,-21(s0)
c00175d8:	0017e793          	ori	a5,a5,1
c00175dc:	fef405a3          	sb	a5,-21(s0)
c00175e0:	fdc42783          	lw	a5,-36(s0)
c00175e4:	10878793          	addi	a5,a5,264
c00175e8:	feb44703          	lbu	a4,-21(s0)
c00175ec:	00070593          	mv	a1,a4
c00175f0:	00078513          	mv	a0,a5
c00175f4:	e01ff0ef          	jal	ra,c00173f4 <Xil_Out32>
					XIIC_READ_OPERATION);
	}
	/* Try to receive the data from the IIC bus */

	RemainingByteCount = RecvData(BaseAddress, BufferPtr,
c00175f8:	fda44783          	lbu	a5,-38(s0)
c00175fc:	00078693          	mv	a3,a5
c0017600:	fd042603          	lw	a2,-48(s0)
c0017604:	fd442583          	lw	a1,-44(s0)
c0017608:	fdc42503          	lw	a0,-36(s0)
c001760c:	078000ef          	jal	ra,c0017684 <RecvData>
c0017610:	fea42223          	sw	a0,-28(s0)
				      ByteCount, Option);

	CntlReg = XIic_ReadReg(BaseAddress,  XIIC_CR_REG_OFFSET);
c0017614:	fdc42783          	lw	a5,-36(s0)
c0017618:	10078793          	addi	a5,a5,256
c001761c:	00078513          	mv	a0,a5
c0017620:	dadff0ef          	jal	ra,c00173cc <Xil_In32>
c0017624:	fea42623          	sw	a0,-20(s0)
	if ((CntlReg & XIIC_CR_REPEATED_START_MASK) == 0) {
c0017628:	fec42783          	lw	a5,-20(s0)
c001762c:	0207f793          	andi	a5,a5,32
c0017630:	00079c63          	bnez	a5,c0017648 <XIic_Recv+0x21c>
		/* The receive is complete, disable the IIC device if the Option
		 * is to release the Bus after Reception of data and return the
		 * number of bytes that was received
		 */
		XIic_WriteReg(BaseAddress,  XIIC_CR_REG_OFFSET, 0);
c0017634:	fdc42783          	lw	a5,-36(s0)
c0017638:	10078793          	addi	a5,a5,256
c001763c:	00000593          	li	a1,0
c0017640:	00078513          	mv	a0,a5
c0017644:	db1ff0ef          	jal	ra,c00173f4 <Xil_Out32>
	}

	/* Wait until I2C bus is freed, exit if timed out. */
	if (XIic_WaitBusFree(BaseAddress) != XST_SUCCESS) {
c0017648:	fdc42503          	lw	a0,-36(s0)
c001764c:	479000ef          	jal	ra,c00182c4 <XIic_WaitBusFree>
c0017650:	00050793          	mv	a5,a0
c0017654:	00078663          	beqz	a5,c0017660 <XIic_Recv+0x234>
		return 0;
c0017658:	00000793          	li	a5,0
c001765c:	0100006f          	j	c001766c <XIic_Recv+0x240>
	}

	/* Return the number of bytes that was received */
	return ByteCount - RemainingByteCount;
c0017660:	fd042703          	lw	a4,-48(s0)
c0017664:	fe442783          	lw	a5,-28(s0)
c0017668:	40f707b3          	sub	a5,a4,a5
}
c001766c:	00078513          	mv	a0,a5
c0017670:	02c12083          	lw	ra,44(sp)
c0017674:	02812403          	lw	s0,40(sp)
c0017678:	02412483          	lw	s1,36(sp)
c001767c:	03010113          	addi	sp,sp,48
c0017680:	00008067          	ret

c0017684 <RecvData>:
* after this function returns.
*
******************************************************************************/
static unsigned RecvData(UINTPTR BaseAddress, u8 *BufferPtr,
			 unsigned ByteCount, u8 Option)
{
c0017684:	fd010113          	addi	sp,sp,-48
c0017688:	02112623          	sw	ra,44(sp)
c001768c:	02812423          	sw	s0,40(sp)
c0017690:	02912223          	sw	s1,36(sp)
c0017694:	03010413          	addi	s0,sp,48
c0017698:	fca42e23          	sw	a0,-36(s0)
c001769c:	fcb42c23          	sw	a1,-40(s0)
c00176a0:	fcc42a23          	sw	a2,-44(s0)
c00176a4:	00068793          	mv	a5,a3
c00176a8:	fcf409a3          	sb	a5,-45(s0)
	u32 IntrStatusMask;
	u32 IntrStatus;

	/* Attempt to receive the specified number of bytes on the IIC bus */

	while (ByteCount > 0) {
c00176ac:	1500006f          	j	c00177fc <RecvData+0x178>
		/* Setup the mask to use for checking errors because when
		 * receiving one byte OR the last byte of a multibyte message an
		 * error naturally occurs when the no ack is done to tell the
		 * slave the last byte
		 */
		if (ByteCount == 1) {
c00176b0:	fd442703          	lw	a4,-44(s0)
c00176b4:	00100793          	li	a5,1
c00176b8:	00f71863          	bne	a4,a5,c00176c8 <RecvData+0x44>
			IntrStatusMask =
c00176bc:	01100793          	li	a5,17
c00176c0:	fef42623          	sw	a5,-20(s0)
c00176c4:	00c0006f          	j	c00176d0 <RecvData+0x4c>
				XIIC_INTR_ARB_LOST_MASK | XIIC_INTR_BNB_MASK;
		} else {
			IntrStatusMask =
c00176c8:	01300793          	li	a5,19
c00176cc:	fef42623          	sw	a5,-20(s0)
		/* Wait for the previous transmit and the 1st receive to
		 * complete by checking the interrupt status register of the
		 * IPIF
		 */
		while (1) {
			IntrStatus = XIic_ReadIisr(BaseAddress);
c00176d0:	fdc42783          	lw	a5,-36(s0)
c00176d4:	02078793          	addi	a5,a5,32
c00176d8:	00078513          	mv	a0,a5
c00176dc:	cf1ff0ef          	jal	ra,c00173cc <Xil_In32>
c00176e0:	fea42423          	sw	a0,-24(s0)
			if (IntrStatus & XIIC_INTR_RX_FULL_MASK) {
c00176e4:	fe842783          	lw	a5,-24(s0)
c00176e8:	0087f793          	andi	a5,a5,8
c00176ec:	00079e63          	bnez	a5,c0017708 <RecvData+0x84>
			/* Check the transmit error after the receive full
			 * because when sending only one byte transmit error
			 * will occur because of the no ack to indicate the end
			 * of the data
			 */
			if (IntrStatus & IntrStatusMask) {
c00176f0:	fe842703          	lw	a4,-24(s0)
c00176f4:	fec42783          	lw	a5,-20(s0)
c00176f8:	00f777b3          	and	a5,a4,a5
c00176fc:	fc078ae3          	beqz	a5,c00176d0 <RecvData+0x4c>
				return ByteCount;
c0017700:	fd442783          	lw	a5,-44(s0)
c0017704:	1300006f          	j	c0017834 <RecvData+0x1b0>
				break;
c0017708:	00000013          	nop
			}
		}

		CntlReg = XIic_ReadReg(BaseAddress,  XIIC_CR_REG_OFFSET);
c001770c:	fdc42783          	lw	a5,-36(s0)
c0017710:	10078793          	addi	a5,a5,256
c0017714:	00078513          	mv	a0,a5
c0017718:	cb5ff0ef          	jal	ra,c00173cc <Xil_In32>
c001771c:	fea42223          	sw	a0,-28(s0)
		/* Special conditions exist for the last two bytes so check for
		 * them. Note that the control register must be setup for these
		 * conditions before the data byte which was already received is
		 * read from the receive FIFO (while the bus is throttled
		 */
		if (ByteCount == 1) {
c0017720:	fd442703          	lw	a4,-44(s0)
c0017724:	00100793          	li	a5,1
c0017728:	02f71063          	bne	a4,a5,c0017748 <RecvData+0xc4>
			if (Option == XIIC_STOP) {
c001772c:	fd344783          	lbu	a5,-45(s0)
c0017730:	00079c63          	bnez	a5,c0017748 <RecvData+0xc4>
				 * last data byte, it has already been read and
				 * no ack has been done, so clear MSMS while
				 * leaving the device enabled so it can get off
				 * the IIC bus appropriately with a stop
				 */
				XIic_WriteReg(BaseAddress,  XIIC_CR_REG_OFFSET,
c0017734:	fdc42783          	lw	a5,-36(s0)
c0017738:	10078793          	addi	a5,a5,256
c001773c:	00100593          	li	a1,1
c0017740:	00078513          	mv	a0,a5
c0017744:	cb1ff0ef          	jal	ra,c00173f4 <Xil_Out32>

		/* Before the last byte is received, set NOACK to tell the slave
		 * IIC device that it is the end, this must be done before
		 * reading the byte from the FIFO
		 */
		if (ByteCount == 2) {
c0017748:	fd442703          	lw	a4,-44(s0)
c001774c:	00200793          	li	a5,2
c0017750:	02f71063          	bne	a4,a5,c0017770 <RecvData+0xec>
			/* Write control reg with NO ACK allowing last byte to
			 * have the No ack set to indicate to slave last byte
			 * read
			 */
			XIic_WriteReg(BaseAddress,  XIIC_CR_REG_OFFSET,
c0017754:	fdc42783          	lw	a5,-36(s0)
c0017758:	10078713          	addi	a4,a5,256
c001775c:	fe442783          	lw	a5,-28(s0)
c0017760:	0107e793          	ori	a5,a5,16
c0017764:	00078593          	mv	a1,a5
c0017768:	00070513          	mv	a0,a4
c001776c:	c89ff0ef          	jal	ra,c00173f4 <Xil_Out32>
		}

		/* Read in data from the FIFO and unthrottle the bus such that
		 * the next byte is read from the IIC bus
		 */
		*BufferPtr++ = (u8) XIic_ReadReg(BaseAddress,
c0017770:	fdc42783          	lw	a5,-36(s0)
c0017774:	10c78793          	addi	a5,a5,268
c0017778:	00078513          	mv	a0,a5
c001777c:	c51ff0ef          	jal	ra,c00173cc <Xil_In32>
c0017780:	00050693          	mv	a3,a0
c0017784:	fd842783          	lw	a5,-40(s0)
c0017788:	00178713          	addi	a4,a5,1
c001778c:	fce42c23          	sw	a4,-40(s0)
c0017790:	0ff6f713          	andi	a4,a3,255
c0017794:	00e78023          	sb	a4,0(a5)
						  XIIC_DRR_REG_OFFSET);

		if ((ByteCount == 1) && (Option == XIIC_REPEATED_START)) {
c0017798:	fd442703          	lw	a4,-44(s0)
c001779c:	00100793          	li	a5,1
c00177a0:	02f71263          	bne	a4,a5,c00177c4 <RecvData+0x140>
c00177a4:	fd344703          	lbu	a4,-45(s0)
c00177a8:	00100793          	li	a5,1
c00177ac:	00f71c63          	bne	a4,a5,c00177c4 <RecvData+0x140>

			/* RSTA bit should be set only when the FIFO is
			 * completely Empty.
			 */
			XIic_WriteReg(BaseAddress,  XIIC_CR_REG_OFFSET,
c00177b0:	fdc42783          	lw	a5,-36(s0)
c00177b4:	10078793          	addi	a5,a5,256
c00177b8:	02500593          	li	a1,37
c00177bc:	00078513          	mv	a0,a5
c00177c0:	c35ff0ef          	jal	ra,c00173f4 <Xil_Out32>

		/* Clear the latched interrupt status so that it will be updated
		 * with the new state when it changes, this must be done after
		 * the receive register is read
		 */
		XIic_ClearIisr(BaseAddress, XIIC_INTR_RX_FULL_MASK |
c00177c4:	fdc42783          	lw	a5,-36(s0)
c00177c8:	02078493          	addi	s1,a5,32
c00177cc:	fdc42783          	lw	a5,-36(s0)
c00177d0:	02078793          	addi	a5,a5,32
c00177d4:	00078513          	mv	a0,a5
c00177d8:	bf5ff0ef          	jal	ra,c00173cc <Xil_In32>
c00177dc:	00050793          	mv	a5,a0
c00177e0:	00b7f793          	andi	a5,a5,11
c00177e4:	00078593          	mv	a1,a5
c00177e8:	00048513          	mv	a0,s1
c00177ec:	c09ff0ef          	jal	ra,c00173f4 <Xil_Out32>
				XIIC_INTR_TX_ERROR_MASK |
				XIIC_INTR_ARB_LOST_MASK);
		ByteCount--;
c00177f0:	fd442783          	lw	a5,-44(s0)
c00177f4:	fff78793          	addi	a5,a5,-1
c00177f8:	fcf42a23          	sw	a5,-44(s0)
	while (ByteCount > 0) {
c00177fc:	fd442783          	lw	a5,-44(s0)
c0017800:	ea0798e3          	bnez	a5,c00176b0 <RecvData+0x2c>
	}

	if (Option == XIIC_STOP) {
c0017804:	fd344783          	lbu	a5,-45(s0)
c0017808:	02079463          	bnez	a5,c0017830 <RecvData+0x1ac>
		 * the IIC device cannot be disabled until this occurs. It
		 * should transition as the MSMS bit of the control register was
		 * cleared before the last byte was read from the FIFO
		 */
		while (1) {
			if (XIic_ReadIisr(BaseAddress) & XIIC_INTR_BNB_MASK) {
c001780c:	fdc42783          	lw	a5,-36(s0)
c0017810:	02078793          	addi	a5,a5,32
c0017814:	00078513          	mv	a0,a5
c0017818:	bb5ff0ef          	jal	ra,c00173cc <Xil_In32>
c001781c:	00050793          	mv	a5,a0
c0017820:	0107f793          	andi	a5,a5,16
c0017824:	00079463          	bnez	a5,c001782c <RecvData+0x1a8>
c0017828:	fe5ff06f          	j	c001780c <RecvData+0x188>
				break;
c001782c:	00000013          	nop
			}
		}
	}

	return ByteCount;
c0017830:	fd442783          	lw	a5,-44(s0)
}
c0017834:	00078513          	mv	a0,a5
c0017838:	02c12083          	lw	ra,44(sp)
c001783c:	02812403          	lw	s0,40(sp)
c0017840:	02412483          	lw	s1,36(sp)
c0017844:	03010113          	addi	sp,sp,48
c0017848:	00008067          	ret

c001784c <XIic_Send>:
* @note		None.
*
******************************************************************************/
unsigned XIic_Send(UINTPTR BaseAddress, u8 Address,
		   u8 *BufferPtr, unsigned ByteCount, u8 Option)
{
c001784c:	fd010113          	addi	sp,sp,-48
c0017850:	02112623          	sw	ra,44(sp)
c0017854:	02812423          	sw	s0,40(sp)
c0017858:	02912223          	sw	s1,36(sp)
c001785c:	03010413          	addi	s0,sp,48
c0017860:	fca42e23          	sw	a0,-36(s0)
c0017864:	00058793          	mv	a5,a1
c0017868:	fcc42a23          	sw	a2,-44(s0)
c001786c:	fcd42823          	sw	a3,-48(s0)
c0017870:	fcf40da3          	sb	a5,-37(s0)
c0017874:	00070793          	mv	a5,a4
c0017878:	fcf40d23          	sb	a5,-38(s0)
	unsigned RemainingByteCount;
	u32 ControlReg;
	volatile u32 StatusReg;

	/* Wait until I2C bus is freed, exit if timed out. */
	if (XIic_WaitBusFree(BaseAddress) != XST_SUCCESS) {
c001787c:	fdc42503          	lw	a0,-36(s0)
c0017880:	245000ef          	jal	ra,c00182c4 <XIic_WaitBusFree>
c0017884:	00050793          	mv	a5,a0
c0017888:	00078663          	beqz	a5,c0017894 <XIic_Send+0x48>
		return 0;
c001788c:	00000793          	li	a5,0
c0017890:	2180006f          	j	c0017aa8 <XIic_Send+0x25c>

	/* Check to see if already Master on the Bus.
	 * If Repeated Start bit is not set send Start bit by setting
	 * MSMS bit else Send the address.
	 */
	ControlReg = XIic_ReadReg(BaseAddress,  XIIC_CR_REG_OFFSET);
c0017894:	fdc42783          	lw	a5,-36(s0)
c0017898:	10078793          	addi	a5,a5,256
c001789c:	00078513          	mv	a0,a5
c00178a0:	b2dff0ef          	jal	ra,c00173cc <Xil_In32>
c00178a4:	fea42623          	sw	a0,-20(s0)
	if ((ControlReg & XIIC_CR_REPEATED_START_MASK) == 0) {
c00178a8:	fec42783          	lw	a5,-20(s0)
c00178ac:	0207f793          	andi	a5,a5,32
c00178b0:	0e079263          	bnez	a5,c0017994 <XIic_Send+0x148>
		/*
		 * Put the address into the FIFO to be sent and indicate
		 * that the operation to be performed on the bus is a
		 * write operation
		 */
		XIic_Send7BitAddress(BaseAddress, Address,
c00178b4:	fdb44783          	lbu	a5,-37(s0)
c00178b8:	00179793          	slli	a5,a5,0x1
c00178bc:	fef40523          	sb	a5,-22(s0)
c00178c0:	fea44783          	lbu	a5,-22(s0)
c00178c4:	ffe7f793          	andi	a5,a5,-2
c00178c8:	fef40523          	sb	a5,-22(s0)
c00178cc:	fdc42783          	lw	a5,-36(s0)
c00178d0:	10878793          	addi	a5,a5,264
c00178d4:	fea44703          	lbu	a4,-22(s0)
c00178d8:	00070593          	mv	a1,a4
c00178dc:	00078513          	mv	a0,a5
c00178e0:	b15ff0ef          	jal	ra,c00173f4 <Xil_Out32>
					XIIC_WRITE_OPERATION);
		/* Clear the latched interrupt status so that it will
		 * be updated with the new state when it changes, this
		 * must be done after the address is put in the FIFO
		 */
		XIic_ClearIisr(BaseAddress, XIIC_INTR_TX_EMPTY_MASK |
c00178e4:	fdc42783          	lw	a5,-36(s0)
c00178e8:	02078493          	addi	s1,a5,32
c00178ec:	fdc42783          	lw	a5,-36(s0)
c00178f0:	02078793          	addi	a5,a5,32
c00178f4:	00078513          	mv	a0,a5
c00178f8:	ad5ff0ef          	jal	ra,c00173cc <Xil_In32>
c00178fc:	00050793          	mv	a5,a0
c0017900:	0077f793          	andi	a5,a5,7
c0017904:	00078593          	mv	a1,a5
c0017908:	00048513          	mv	a0,s1
c001790c:	ae9ff0ef          	jal	ra,c00173f4 <Xil_Out32>
		/*
		 * MSMS must be set after putting data into transmit FIFO,
		 * indicate the direction is transmit, this device is master
		 * and enable the IIC device
		 */
		XIic_WriteReg(BaseAddress,  XIIC_CR_REG_OFFSET,
c0017910:	fdc42783          	lw	a5,-36(s0)
c0017914:	10078793          	addi	a5,a5,256
c0017918:	00d00593          	li	a1,13
c001791c:	00078513          	mv	a0,a5
c0017920:	ad5ff0ef          	jal	ra,c00173f4 <Xil_Out32>
		/*
		 * Clear the latched interrupt
		 * status for the bus not busy bit which must be done while
		 * the bus is busy
		 */
		StatusReg = XIic_ReadReg(BaseAddress,  XIIC_SR_REG_OFFSET);
c0017924:	fdc42783          	lw	a5,-36(s0)
c0017928:	10478793          	addi	a5,a5,260
c001792c:	00078513          	mv	a0,a5
c0017930:	a9dff0ef          	jal	ra,c00173cc <Xil_In32>
c0017934:	00050793          	mv	a5,a0
c0017938:	fef42023          	sw	a5,-32(s0)
		while ((StatusReg & XIIC_SR_BUS_BUSY_MASK) == 0) {
c001793c:	01c0006f          	j	c0017958 <XIic_Send+0x10c>
			StatusReg = XIic_ReadReg(BaseAddress,
c0017940:	fdc42783          	lw	a5,-36(s0)
c0017944:	10478793          	addi	a5,a5,260
c0017948:	00078513          	mv	a0,a5
c001794c:	a81ff0ef          	jal	ra,c00173cc <Xil_In32>
c0017950:	00050793          	mv	a5,a0
c0017954:	fef42023          	sw	a5,-32(s0)
		while ((StatusReg & XIIC_SR_BUS_BUSY_MASK) == 0) {
c0017958:	fe042783          	lw	a5,-32(s0)
c001795c:	0047f793          	andi	a5,a5,4
c0017960:	fe0780e3          	beqz	a5,c0017940 <XIic_Send+0xf4>
						  XIIC_SR_REG_OFFSET);
		}

		XIic_ClearIisr(BaseAddress, XIIC_INTR_BNB_MASK);
c0017964:	fdc42783          	lw	a5,-36(s0)
c0017968:	02078493          	addi	s1,a5,32
c001796c:	fdc42783          	lw	a5,-36(s0)
c0017970:	02078793          	addi	a5,a5,32
c0017974:	00078513          	mv	a0,a5
c0017978:	a55ff0ef          	jal	ra,c00173cc <Xil_In32>
c001797c:	00050793          	mv	a5,a0
c0017980:	0107f793          	andi	a5,a5,16
c0017984:	00078593          	mv	a1,a5
c0017988:	00048513          	mv	a0,s1
c001798c:	a69ff0ef          	jal	ra,c00173f4 <Xil_Out32>
c0017990:	0340006f          	j	c00179c4 <XIic_Send+0x178>
		 * Already owns the Bus indicating that its a Repeated Start
		 * call. 7 bit slave address, send the address for a write
		 * operation and set the state to indicate the address has
		 * been sent.
		 */
		XIic_Send7BitAddress(BaseAddress, Address,
c0017994:	fdb44783          	lbu	a5,-37(s0)
c0017998:	00179793          	slli	a5,a5,0x1
c001799c:	fef405a3          	sb	a5,-21(s0)
c00179a0:	feb44783          	lbu	a5,-21(s0)
c00179a4:	ffe7f793          	andi	a5,a5,-2
c00179a8:	fef405a3          	sb	a5,-21(s0)
c00179ac:	fdc42783          	lw	a5,-36(s0)
c00179b0:	10878793          	addi	a5,a5,264
c00179b4:	feb44703          	lbu	a4,-21(s0)
c00179b8:	00070593          	mv	a1,a4
c00179bc:	00078513          	mv	a0,a5
c00179c0:	a35ff0ef          	jal	ra,c00173f4 <Xil_Out32>
	}

	/* Send the specified data to the device on the IIC bus specified by the
	 * the address
	 */
	RemainingByteCount = SendData(BaseAddress, BufferPtr,
c00179c4:	fda44783          	lbu	a5,-38(s0)
c00179c8:	00078693          	mv	a3,a5
c00179cc:	fd042603          	lw	a2,-48(s0)
c00179d0:	fd442583          	lw	a1,-44(s0)
c00179d4:	fdc42503          	lw	a0,-36(s0)
c00179d8:	0e8000ef          	jal	ra,c0017ac0 <SendData>
c00179dc:	fea42223          	sw	a0,-28(s0)
					ByteCount, Option);

	ControlReg = XIic_ReadReg(BaseAddress,  XIIC_CR_REG_OFFSET);
c00179e0:	fdc42783          	lw	a5,-36(s0)
c00179e4:	10078793          	addi	a5,a5,256
c00179e8:	00078513          	mv	a0,a5
c00179ec:	9e1ff0ef          	jal	ra,c00173cc <Xil_In32>
c00179f0:	fea42623          	sw	a0,-20(s0)
	if ((ControlReg & XIIC_CR_REPEATED_START_MASK) == 0) {
c00179f4:	fec42783          	lw	a5,-20(s0)
c00179f8:	0207f793          	andi	a5,a5,32
c00179fc:	0a079063          	bnez	a5,c0017a9c <XIic_Send+0x250>
		 * the Option is to release the Bus after transmission of data
		 * and return the number of bytes that was received. Only wait
		 * if master, if addressed as slave just reset to release
		 * the bus.
		 */
		if ((ControlReg & XIIC_CR_MSMS_MASK) != 0) {
c0017a00:	fec42783          	lw	a5,-20(s0)
c0017a04:	0047f793          	andi	a5,a5,4
c0017a08:	02078063          	beqz	a5,c0017a28 <XIic_Send+0x1dc>
			XIic_WriteReg(BaseAddress,  XIIC_CR_REG_OFFSET,
c0017a0c:	fdc42783          	lw	a5,-36(s0)
c0017a10:	10078713          	addi	a4,a5,256
c0017a14:	fec42783          	lw	a5,-20(s0)
c0017a18:	ffb7f793          	andi	a5,a5,-5
c0017a1c:	00078593          	mv	a1,a5
c0017a20:	00070513          	mv	a0,a4
c0017a24:	9d1ff0ef          	jal	ra,c00173f4 <Xil_Out32>
				 (ControlReg & ~XIIC_CR_MSMS_MASK));
		}

		if ((XIic_ReadReg(BaseAddress, XIIC_SR_REG_OFFSET) &
c0017a28:	fdc42783          	lw	a5,-36(s0)
c0017a2c:	10478793          	addi	a5,a5,260
c0017a30:	00078513          	mv	a0,a5
c0017a34:	999ff0ef          	jal	ra,c00173cc <Xil_In32>
c0017a38:	00050793          	mv	a5,a0
c0017a3c:	0027f793          	andi	a5,a5,2
c0017a40:	00078e63          	beqz	a5,c0017a5c <XIic_Send+0x210>
		    XIIC_SR_ADDR_AS_SLAVE_MASK) != 0) {
			XIic_WriteReg(BaseAddress,  XIIC_CR_REG_OFFSET, 0);
c0017a44:	fdc42783          	lw	a5,-36(s0)
c0017a48:	10078793          	addi	a5,a5,256
c0017a4c:	00000593          	li	a1,0
c0017a50:	00078513          	mv	a0,a5
c0017a54:	9a1ff0ef          	jal	ra,c00173f4 <Xil_Out32>
c0017a58:	0440006f          	j	c0017a9c <XIic_Send+0x250>
		}
		else {
			StatusReg = XIic_ReadReg(BaseAddress,
c0017a5c:	fdc42783          	lw	a5,-36(s0)
c0017a60:	10478793          	addi	a5,a5,260
c0017a64:	00078513          	mv	a0,a5
c0017a68:	965ff0ef          	jal	ra,c00173cc <Xil_In32>
c0017a6c:	00050793          	mv	a5,a0
c0017a70:	fef42023          	sw	a5,-32(s0)
					XIIC_SR_REG_OFFSET);
			while ((StatusReg & XIIC_SR_BUS_BUSY_MASK) != 0) {
c0017a74:	01c0006f          	j	c0017a90 <XIic_Send+0x244>
				StatusReg = XIic_ReadReg(BaseAddress,
c0017a78:	fdc42783          	lw	a5,-36(s0)
c0017a7c:	10478793          	addi	a5,a5,260
c0017a80:	00078513          	mv	a0,a5
c0017a84:	949ff0ef          	jal	ra,c00173cc <Xil_In32>
c0017a88:	00050793          	mv	a5,a0
c0017a8c:	fef42023          	sw	a5,-32(s0)
			while ((StatusReg & XIIC_SR_BUS_BUSY_MASK) != 0) {
c0017a90:	fe042783          	lw	a5,-32(s0)
c0017a94:	0047f793          	andi	a5,a5,4
c0017a98:	fe0790e3          	bnez	a5,c0017a78 <XIic_Send+0x22c>
						XIIC_SR_REG_OFFSET);
			}
		}
	}

	return ByteCount - RemainingByteCount;
c0017a9c:	fd042703          	lw	a4,-48(s0)
c0017aa0:	fe442783          	lw	a5,-28(s0)
c0017aa4:	40f707b3          	sub	a5,a4,a5
}
c0017aa8:	00078513          	mv	a0,a5
c0017aac:	02c12083          	lw	ra,44(sp)
c0017ab0:	02812403          	lw	s0,40(sp)
c0017ab4:	02412483          	lw	s1,36(sp)
c0017ab8:	03010113          	addi	sp,sp,48
c0017abc:	00008067          	ret

c0017ac0 <SendData>:
* that could cause the function not to return if the hardware is not working.
*
******************************************************************************/
static unsigned SendData(UINTPTR BaseAddress, u8 *BufferPtr,
			 unsigned ByteCount, u8 Option)
{
c0017ac0:	fd010113          	addi	sp,sp,-48
c0017ac4:	02112623          	sw	ra,44(sp)
c0017ac8:	02812423          	sw	s0,40(sp)
c0017acc:	02912223          	sw	s1,36(sp)
c0017ad0:	03010413          	addi	s0,sp,48
c0017ad4:	fca42e23          	sw	a0,-36(s0)
c0017ad8:	fcb42c23          	sw	a1,-40(s0)
c0017adc:	fcc42a23          	sw	a2,-44(s0)
c0017ae0:	00068793          	mv	a5,a3
c0017ae4:	fcf409a3          	sb	a5,-45(s0)

	/*
	 * Send the specified number of bytes in the specified buffer by polling
	 * the device registers and blocking until complete
	 */
	while (ByteCount > 0) {
c0017ae8:	1580006f          	j	c0017c40 <SendData+0x180>
		/*
		 * Wait for the transmit to be empty before sending any more
		 * data by polling the interrupt status register
		 */
		while (1) {
			IntrStatus = XIic_ReadIisr(BaseAddress);
c0017aec:	fdc42783          	lw	a5,-36(s0)
c0017af0:	02078793          	addi	a5,a5,32
c0017af4:	00078513          	mv	a0,a5
c0017af8:	8d5ff0ef          	jal	ra,c00173cc <Xil_In32>
c0017afc:	fea42623          	sw	a0,-20(s0)

			if (IntrStatus & (XIIC_INTR_TX_ERROR_MASK |
c0017b00:	fec42783          	lw	a5,-20(s0)
c0017b04:	0137f793          	andi	a5,a5,19
c0017b08:	00078663          	beqz	a5,c0017b14 <SendData+0x54>
					  XIIC_INTR_ARB_LOST_MASK |
					  XIIC_INTR_BNB_MASK)) {
				return ByteCount;
c0017b0c:	fd442783          	lw	a5,-44(s0)
c0017b10:	1680006f          	j	c0017c78 <SendData+0x1b8>
			}

			if (IntrStatus & XIIC_INTR_TX_EMPTY_MASK) {
c0017b14:	fec42783          	lw	a5,-20(s0)
c0017b18:	0047f793          	andi	a5,a5,4
c0017b1c:	00079463          	bnez	a5,c0017b24 <SendData+0x64>
			IntrStatus = XIic_ReadIisr(BaseAddress);
c0017b20:	fcdff06f          	j	c0017aec <SendData+0x2c>
				break;
c0017b24:	00000013          	nop
			}
		}
		/* If there is more than one byte to send then put the
		 * next byte to send into the transmit FIFO
		 */
		if (ByteCount > 1) {
c0017b28:	fd442703          	lw	a4,-44(s0)
c0017b2c:	00100793          	li	a5,1
c0017b30:	02e7f663          	bgeu	a5,a4,c0017b5c <SendData+0x9c>
			XIic_WriteReg(BaseAddress,  XIIC_DTR_REG_OFFSET,
c0017b34:	fdc42783          	lw	a5,-36(s0)
c0017b38:	10878693          	addi	a3,a5,264
c0017b3c:	fd842783          	lw	a5,-40(s0)
c0017b40:	00178713          	addi	a4,a5,1
c0017b44:	fce42c23          	sw	a4,-40(s0)
c0017b48:	0007c783          	lbu	a5,0(a5)
c0017b4c:	00078593          	mv	a1,a5
c0017b50:	00068513          	mv	a0,a3
c0017b54:	8a1ff0ef          	jal	ra,c00173f4 <Xil_Out32>
c0017b58:	0b00006f          	j	c0017c08 <SendData+0x148>
				 *BufferPtr++);
		}
		else {
			if (Option == XIIC_STOP) {
c0017b5c:	fd344783          	lbu	a5,-45(s0)
c0017b60:	00079c63          	bnez	a5,c0017b78 <SendData+0xb8>
				 * that the stop Option will be generated
				 * immediately following the data. This is
				 * done by clearing the MSMS bit in the
				 * control register.
				 */
				XIic_WriteReg(BaseAddress,  XIIC_CR_REG_OFFSET,
c0017b64:	fdc42783          	lw	a5,-36(s0)
c0017b68:	10078793          	addi	a5,a5,256
c0017b6c:	00900593          	li	a1,9
c0017b70:	00078513          	mv	a0,a5
c0017b74:	881ff0ef          	jal	ra,c00173f4 <Xil_Out32>
			}

			/*
			 * Put the last byte to send in the transmit FIFO
			 */
			XIic_WriteReg(BaseAddress,  XIIC_DTR_REG_OFFSET,
c0017b78:	fdc42783          	lw	a5,-36(s0)
c0017b7c:	10878693          	addi	a3,a5,264
c0017b80:	fd842783          	lw	a5,-40(s0)
c0017b84:	00178713          	addi	a4,a5,1
c0017b88:	fce42c23          	sw	a4,-40(s0)
c0017b8c:	0007c783          	lbu	a5,0(a5)
c0017b90:	00078593          	mv	a1,a5
c0017b94:	00068513          	mv	a0,a3
c0017b98:	85dff0ef          	jal	ra,c00173f4 <Xil_Out32>
				 *BufferPtr++);

			if (Option == XIIC_REPEATED_START) {
c0017b9c:	fd344703          	lbu	a4,-45(s0)
c0017ba0:	00100793          	li	a5,1
c0017ba4:	06f71263          	bne	a4,a5,c0017c08 <SendData+0x148>
				XIic_ClearIisr(BaseAddress,
c0017ba8:	fdc42783          	lw	a5,-36(s0)
c0017bac:	02078493          	addi	s1,a5,32
c0017bb0:	fdc42783          	lw	a5,-36(s0)
c0017bb4:	02078793          	addi	a5,a5,32
c0017bb8:	00078513          	mv	a0,a5
c0017bbc:	811ff0ef          	jal	ra,c00173cc <Xil_In32>
c0017bc0:	00050793          	mv	a5,a0
c0017bc4:	0047f793          	andi	a5,a5,4
c0017bc8:	00078593          	mv	a1,a5
c0017bcc:	00048513          	mv	a0,s1
c0017bd0:	825ff0ef          	jal	ra,c00173f4 <Xil_Out32>
				 * Wait for the transmit to be empty before
				 * setting RSTA bit.
				 */
				while (1) {
					IntrStatus =
						XIic_ReadIisr(BaseAddress);
c0017bd4:	fdc42783          	lw	a5,-36(s0)
c0017bd8:	02078793          	addi	a5,a5,32
c0017bdc:	00078513          	mv	a0,a5
c0017be0:	fecff0ef          	jal	ra,c00173cc <Xil_In32>
c0017be4:	fea42623          	sw	a0,-20(s0)
					if (IntrStatus &
c0017be8:	fec42783          	lw	a5,-20(s0)
c0017bec:	0047f793          	andi	a5,a5,4
c0017bf0:	fe0782e3          	beqz	a5,c0017bd4 <SendData+0x114>
						/*
						 * RSTA bit should be set only
						 * when the FIFO is completely
						 * Empty.
						 */
						XIic_WriteReg(BaseAddress,
c0017bf4:	fdc42783          	lw	a5,-36(s0)
c0017bf8:	10078793          	addi	a5,a5,256
c0017bfc:	02d00593          	li	a1,45
c0017c00:	00078513          	mv	a0,a5
c0017c04:	ff0ff0ef          	jal	ra,c00173f4 <Xil_Out32>
		/*
		 * Clear the latched interrupt status register and this must be
		 * done after the transmit FIFO has been written to or it won't
		 * clear
		 */
		XIic_ClearIisr(BaseAddress, XIIC_INTR_TX_EMPTY_MASK);
c0017c08:	fdc42783          	lw	a5,-36(s0)
c0017c0c:	02078493          	addi	s1,a5,32
c0017c10:	fdc42783          	lw	a5,-36(s0)
c0017c14:	02078793          	addi	a5,a5,32
c0017c18:	00078513          	mv	a0,a5
c0017c1c:	fb0ff0ef          	jal	ra,c00173cc <Xil_In32>
c0017c20:	00050793          	mv	a5,a0
c0017c24:	0047f793          	andi	a5,a5,4
c0017c28:	00078593          	mv	a1,a5
c0017c2c:	00048513          	mv	a0,s1
c0017c30:	fc4ff0ef          	jal	ra,c00173f4 <Xil_Out32>
		/*
		 * Update the byte count to reflect the byte sent and clear
		 * the latched interrupt status so it will be updated for the
		 * new state
		 */
		ByteCount--;
c0017c34:	fd442783          	lw	a5,-44(s0)
c0017c38:	fff78793          	addi	a5,a5,-1
c0017c3c:	fcf42a23          	sw	a5,-44(s0)
	while (ByteCount > 0) {
c0017c40:	fd442783          	lw	a5,-44(s0)
c0017c44:	ea0794e3          	bnez	a5,c0017aec <SendData+0x2c>
	}

	if (Option == XIIC_STOP) {
c0017c48:	fd344783          	lbu	a5,-45(s0)
c0017c4c:	02079463          	bnez	a5,c0017c74 <SendData+0x1b4>
		 * returning, the IIC device cannot be disabled until this
		 * occurs. Note that this is different from a receive operation
		 * because the stop Option causes the bus to go not busy.
		 */
		while (1) {
			if (XIic_ReadIisr(BaseAddress) &
c0017c50:	fdc42783          	lw	a5,-36(s0)
c0017c54:	02078793          	addi	a5,a5,32
c0017c58:	00078513          	mv	a0,a5
c0017c5c:	f70ff0ef          	jal	ra,c00173cc <Xil_In32>
c0017c60:	00050793          	mv	a5,a0
c0017c64:	0107f793          	andi	a5,a5,16
c0017c68:	00079463          	bnez	a5,c0017c70 <SendData+0x1b0>
c0017c6c:	fe5ff06f          	j	c0017c50 <SendData+0x190>
				XIIC_INTR_BNB_MASK) {
				break;
c0017c70:	00000013          	nop
			}
		}
	}

	return ByteCount;
c0017c74:	fd442783          	lw	a5,-44(s0)
}
c0017c78:	00078513          	mv	a0,a5
c0017c7c:	02c12083          	lw	ra,44(sp)
c0017c80:	02812403          	lw	s0,40(sp)
c0017c84:	02412483          	lw	s1,36(sp)
c0017c88:	03010113          	addi	sp,sp,48
c0017c8c:	00008067          	ret

c0017c90 <XIic_DynRecv>:
* @note		Upon entry to this function, the IIC interface needs to be
*		already enabled in the CR register.
*
******************************************************************************/
unsigned XIic_DynRecv(UINTPTR BaseAddress, u8 Address, u8 *BufferPtr, u8 ByteCount)
{
c0017c90:	fd010113          	addi	sp,sp,-48
c0017c94:	02112623          	sw	ra,44(sp)
c0017c98:	02812423          	sw	s0,40(sp)
c0017c9c:	02912223          	sw	s1,36(sp)
c0017ca0:	03010413          	addi	s0,sp,48
c0017ca4:	fca42e23          	sw	a0,-36(s0)
c0017ca8:	00058793          	mv	a5,a1
c0017cac:	fcc42a23          	sw	a2,-44(s0)
c0017cb0:	00068713          	mv	a4,a3
c0017cb4:	fcf40da3          	sb	a5,-37(s0)
c0017cb8:	00070793          	mv	a5,a4
c0017cbc:	fcf40d23          	sb	a5,-38(s0)

	/*
	 * Clear the latched interrupt status so that it will be updated with
	 * the new state when it changes.
	 */
	XIic_ClearIisr(BaseAddress, XIIC_INTR_TX_EMPTY_MASK |
c0017cc0:	fdc42783          	lw	a5,-36(s0)
c0017cc4:	02078493          	addi	s1,a5,32
c0017cc8:	fdc42783          	lw	a5,-36(s0)
c0017ccc:	02078793          	addi	a5,a5,32
c0017cd0:	00078513          	mv	a0,a5
c0017cd4:	ef8ff0ef          	jal	ra,c00173cc <Xil_In32>
c0017cd8:	00050793          	mv	a5,a0
c0017cdc:	0077f793          	andi	a5,a5,7
c0017ce0:	00078593          	mv	a1,a5
c0017ce4:	00048513          	mv	a0,s1
c0017ce8:	f0cff0ef          	jal	ra,c00173f4 <Xil_Out32>
	 * to indicate the address has been sent. Upon writing the address, a
	 * start condition is initiated. MSMS is automatically set to master
	 * when the address is written to the Fifo. If MSMS was already set,
	 * then a re-start is sent prior to the address.
	 */
	XIic_DynSend7BitAddress(BaseAddress, Address, XIIC_READ_OPERATION);
c0017cec:	fdb44783          	lbu	a5,-37(s0)
c0017cf0:	00179793          	slli	a5,a5,0x1
c0017cf4:	fef405a3          	sb	a5,-21(s0)
c0017cf8:	feb44783          	lbu	a5,-21(s0)
c0017cfc:	0017e793          	ori	a5,a5,1
c0017d00:	fef405a3          	sb	a5,-21(s0)
c0017d04:	fdc42783          	lw	a5,-36(s0)
c0017d08:	10878713          	addi	a4,a5,264
c0017d0c:	feb44783          	lbu	a5,-21(s0)
c0017d10:	1007e793          	ori	a5,a5,256
c0017d14:	00078593          	mv	a1,a5
c0017d18:	00070513          	mv	a0,a4
c0017d1c:	ed8ff0ef          	jal	ra,c00173f4 <Xil_Out32>

	/*
	 * Wait for the bus to go busy.
	 */
	StatusRegister = XIic_ReadReg(BaseAddress,  XIIC_SR_REG_OFFSET);
c0017d20:	fdc42783          	lw	a5,-36(s0)
c0017d24:	10478793          	addi	a5,a5,260
c0017d28:	00078513          	mv	a0,a5
c0017d2c:	ea0ff0ef          	jal	ra,c00173cc <Xil_In32>
c0017d30:	fea42623          	sw	a0,-20(s0)

	while (( StatusRegister & XIIC_SR_BUS_BUSY_MASK)
c0017d34:	0180006f          	j	c0017d4c <XIic_DynRecv+0xbc>
			!= XIIC_SR_BUS_BUSY_MASK) {
		StatusRegister = XIic_ReadReg(BaseAddress,
c0017d38:	fdc42783          	lw	a5,-36(s0)
c0017d3c:	10478793          	addi	a5,a5,260
c0017d40:	00078513          	mv	a0,a5
c0017d44:	e88ff0ef          	jal	ra,c00173cc <Xil_In32>
c0017d48:	fea42623          	sw	a0,-20(s0)
	while (( StatusRegister & XIIC_SR_BUS_BUSY_MASK)
c0017d4c:	fec42783          	lw	a5,-20(s0)
c0017d50:	0047f793          	andi	a5,a5,4
c0017d54:	fe0782e3          	beqz	a5,c0017d38 <XIic_DynRecv+0xa8>

	/*
	 * Clear the latched interrupt status for the bus not busy bit which
	 * must be done while the bus is busy.
	 */
	XIic_ClearIisr(BaseAddress, XIIC_INTR_BNB_MASK);
c0017d58:	fdc42783          	lw	a5,-36(s0)
c0017d5c:	02078493          	addi	s1,a5,32
c0017d60:	fdc42783          	lw	a5,-36(s0)
c0017d64:	02078793          	addi	a5,a5,32
c0017d68:	00078513          	mv	a0,a5
c0017d6c:	e60ff0ef          	jal	ra,c00173cc <Xil_In32>
c0017d70:	00050793          	mv	a5,a0
c0017d74:	0107f793          	andi	a5,a5,16
c0017d78:	00078593          	mv	a1,a5
c0017d7c:	00048513          	mv	a0,s1
c0017d80:	e74ff0ef          	jal	ra,c00173f4 <Xil_Out32>
	/*
	 * Write to the Tx Fifo the dynamic stop control bit with the number of
	 * bytes that are to be read over the IIC interface from the presently
	 * addressed device.
	 */
	XIic_DynSendStop(BaseAddress, ByteCount);
c0017d84:	fdc42783          	lw	a5,-36(s0)
c0017d88:	10878713          	addi	a4,a5,264
c0017d8c:	fda44783          	lbu	a5,-38(s0)
c0017d90:	2007e793          	ori	a5,a5,512
c0017d94:	00078593          	mv	a1,a5
c0017d98:	00070513          	mv	a0,a4
c0017d9c:	e58ff0ef          	jal	ra,c00173f4 <Xil_Out32>

	/*
	 * Receive the data from the IIC bus.
	 */
	RemainingByteCount = DynRecvData(BaseAddress, BufferPtr, ByteCount);
c0017da0:	fda44783          	lbu	a5,-38(s0)
c0017da4:	00078613          	mv	a2,a5
c0017da8:	fd442583          	lw	a1,-44(s0)
c0017dac:	fdc42503          	lw	a0,-36(s0)
c0017db0:	044000ef          	jal	ra,c0017df4 <DynRecvData>
c0017db4:	fea42223          	sw	a0,-28(s0)

	/* Wait until I2C bus is freed, exit if timed out. */
	if (XIic_WaitBusFree(BaseAddress) != XST_SUCCESS) {
c0017db8:	fdc42503          	lw	a0,-36(s0)
c0017dbc:	508000ef          	jal	ra,c00182c4 <XIic_WaitBusFree>
c0017dc0:	00050793          	mv	a5,a0
c0017dc4:	00078663          	beqz	a5,c0017dd0 <XIic_DynRecv+0x140>
		return 0;
c0017dc8:	00000793          	li	a5,0
c0017dcc:	0100006f          	j	c0017ddc <XIic_DynRecv+0x14c>

	/*
	 * The receive is complete. Return the number of bytes that were
	 * received.
	 */
	return ByteCount - RemainingByteCount;
c0017dd0:	fda44703          	lbu	a4,-38(s0)
c0017dd4:	fe442783          	lw	a5,-28(s0)
c0017dd8:	40f707b3          	sub	a5,a4,a5
}
c0017ddc:	00078513          	mv	a0,a5
c0017de0:	02c12083          	lw	ra,44(sp)
c0017de4:	02812403          	lw	s0,40(sp)
c0017de8:	02412483          	lw	s1,36(sp)
c0017dec:	03010113          	addi	sp,sp,48
c0017df0:	00008067          	ret

c0017df4 <DynRecvData>:
* @note		This function contains loops that could cause the function not
*		to return if the hardware is not working.
*
******************************************************************************/
static unsigned DynRecvData(UINTPTR BaseAddress, u8 *BufferPtr, u8 ByteCount)
{
c0017df4:	fd010113          	addi	sp,sp,-48
c0017df8:	02112623          	sw	ra,44(sp)
c0017dfc:	02812423          	sw	s0,40(sp)
c0017e00:	03010413          	addi	s0,sp,48
c0017e04:	fca42e23          	sw	a0,-36(s0)
c0017e08:	fcb42c23          	sw	a1,-40(s0)
c0017e0c:	00060793          	mv	a5,a2
c0017e10:	fcf40ba3          	sb	a5,-41(s0)
	u32 StatusReg;
	u32 IntrStatus;
	u32 IntrStatusMask;

	while (ByteCount > 0) {
c0017e14:	0a80006f          	j	c0017ebc <DynRecvData+0xc8>
		 * Setup the mask to use for checking errors because when
		 * receiving one byte OR the last byte of a multibyte message
		 * an error naturally occurs when the no ack is done to tell
		 * the slave the last byte.
		 */
		if (ByteCount == 1) {
c0017e18:	fd744703          	lbu	a4,-41(s0)
c0017e1c:	00100793          	li	a5,1
c0017e20:	00f71863          	bne	a4,a5,c0017e30 <DynRecvData+0x3c>
			IntrStatusMask =
c0017e24:	01100793          	li	a5,17
c0017e28:	fef42623          	sw	a5,-20(s0)
c0017e2c:	00c0006f          	j	c0017e38 <DynRecvData+0x44>
				XIIC_INTR_ARB_LOST_MASK | XIIC_INTR_BNB_MASK;
		} else {
			IntrStatusMask =
c0017e30:	01300793          	li	a5,19
c0017e34:	fef42623          	sw	a5,-20(s0)

		/*
		 * Wait for a byte to show up in the Rx Fifo.
		 */
		while (1) {
			IntrStatus = XIic_ReadIisr(BaseAddress);
c0017e38:	fdc42783          	lw	a5,-36(s0)
c0017e3c:	02078793          	addi	a5,a5,32
c0017e40:	00078513          	mv	a0,a5
c0017e44:	d88ff0ef          	jal	ra,c00173cc <Xil_In32>
c0017e48:	fea42423          	sw	a0,-24(s0)
			StatusReg = XIic_ReadReg(BaseAddress,
c0017e4c:	fdc42783          	lw	a5,-36(s0)
c0017e50:	10478793          	addi	a5,a5,260
c0017e54:	00078513          	mv	a0,a5
c0017e58:	d74ff0ef          	jal	ra,c00173cc <Xil_In32>
c0017e5c:	fea42223          	sw	a0,-28(s0)
						  XIIC_SR_REG_OFFSET);

			if ((StatusReg & XIIC_SR_RX_FIFO_EMPTY_MASK) !=
c0017e60:	fe442783          	lw	a5,-28(s0)
c0017e64:	0407f793          	andi	a5,a5,64
c0017e68:	00078e63          	beqz	a5,c0017e84 <DynRecvData+0x90>
			 * Check the transmit error after the receive full
			 * because when sending only one byte transmit error
			 * will occur because of the no ack to indicate the end
			 * of the data.
			 */
			if (IntrStatus & IntrStatusMask) {
c0017e6c:	fe842703          	lw	a4,-24(s0)
c0017e70:	fec42783          	lw	a5,-20(s0)
c0017e74:	00f777b3          	and	a5,a4,a5
c0017e78:	fc0780e3          	beqz	a5,c0017e38 <DynRecvData+0x44>
				return ByteCount;
c0017e7c:	fd744783          	lbu	a5,-41(s0)
c0017e80:	0480006f          	j	c0017ec8 <DynRecvData+0xd4>
				break;
c0017e84:	00000013          	nop
		 * Read in byte from the Rx Fifo. If the Fifo reached the
		 * programmed occupancy depth as programmed in the Rx occupancy
		 * reg, this read access will un throttle the bus such that
		 * the next byte is read from the IIC bus.
		 */
		*BufferPtr++ = XIic_ReadReg(BaseAddress,  XIIC_DRR_REG_OFFSET);
c0017e88:	fdc42783          	lw	a5,-36(s0)
c0017e8c:	10c78793          	addi	a5,a5,268
c0017e90:	00078513          	mv	a0,a5
c0017e94:	d38ff0ef          	jal	ra,c00173cc <Xil_In32>
c0017e98:	00050693          	mv	a3,a0
c0017e9c:	fd842783          	lw	a5,-40(s0)
c0017ea0:	00178713          	addi	a4,a5,1
c0017ea4:	fce42c23          	sw	a4,-40(s0)
c0017ea8:	0ff6f713          	andi	a4,a3,255
c0017eac:	00e78023          	sb	a4,0(a5)
		ByteCount--;
c0017eb0:	fd744783          	lbu	a5,-41(s0)
c0017eb4:	fff78793          	addi	a5,a5,-1
c0017eb8:	fcf40ba3          	sb	a5,-41(s0)
	while (ByteCount > 0) {
c0017ebc:	fd744783          	lbu	a5,-41(s0)
c0017ec0:	f4079ce3          	bnez	a5,c0017e18 <DynRecvData+0x24>
	}

	return ByteCount;
c0017ec4:	fd744783          	lbu	a5,-41(s0)
}
c0017ec8:	00078513          	mv	a0,a5
c0017ecc:	02c12083          	lw	ra,44(sp)
c0017ed0:	02812403          	lw	s0,40(sp)
c0017ed4:	03010113          	addi	sp,sp,48
c0017ed8:	00008067          	ret

c0017edc <XIic_DynSend>:
* @note		None.
*
******************************************************************************/
unsigned XIic_DynSend(UINTPTR BaseAddress, u16 Address, u8 *BufferPtr,
			u8 ByteCount, u8 Option)
{
c0017edc:	fd010113          	addi	sp,sp,-48
c0017ee0:	02112623          	sw	ra,44(sp)
c0017ee4:	02812423          	sw	s0,40(sp)
c0017ee8:	02912223          	sw	s1,36(sp)
c0017eec:	03010413          	addi	s0,sp,48
c0017ef0:	fca42e23          	sw	a0,-36(s0)
c0017ef4:	00058793          	mv	a5,a1
c0017ef8:	fcc42a23          	sw	a2,-44(s0)
c0017efc:	fcf41d23          	sh	a5,-38(s0)
c0017f00:	00068793          	mv	a5,a3
c0017f04:	fcf40ca3          	sb	a5,-39(s0)
c0017f08:	00070793          	mv	a5,a4
c0017f0c:	fcf40c23          	sb	a5,-40(s0)
	unsigned RemainingByteCount;
	u32 StatusRegister;

	/* Wait until I2C bus is freed, exit if timed out. */
	if (XIic_WaitBusFree(BaseAddress) != XST_SUCCESS) {
c0017f10:	fdc42503          	lw	a0,-36(s0)
c0017f14:	3b0000ef          	jal	ra,c00182c4 <XIic_WaitBusFree>
c0017f18:	00050793          	mv	a5,a0
c0017f1c:	00078663          	beqz	a5,c0017f28 <XIic_DynSend+0x4c>
		return 0;
c0017f20:	00000793          	li	a5,0
c0017f24:	1400006f          	j	c0018064 <XIic_DynSend+0x188>
	/*
	 * Clear the latched interrupt status so that it will be updated with
	 * the new state when it changes, this must be done after the address
	 * is put in the FIFO
	 */
	XIic_ClearIisr(BaseAddress, XIIC_INTR_TX_EMPTY_MASK |
c0017f28:	fdc42783          	lw	a5,-36(s0)
c0017f2c:	02078493          	addi	s1,a5,32
c0017f30:	fdc42783          	lw	a5,-36(s0)
c0017f34:	02078793          	addi	a5,a5,32
c0017f38:	00078513          	mv	a0,a5
c0017f3c:	c90ff0ef          	jal	ra,c00173cc <Xil_In32>
c0017f40:	00050793          	mv	a5,a0
c0017f44:	0077f793          	andi	a5,a5,7
c0017f48:	00078593          	mv	a1,a5
c0017f4c:	00048513          	mv	a0,s1
c0017f50:	ca4ff0ef          	jal	ra,c00173f4 <Xil_Out32>
	 * writing the address, a start condition is initiated. MSMS is
	 * automatically set to master when the address is written to the Fifo.
	 * If MSMS was already set, then a re-start is sent prior to the
	 * address.
	 */
	if(!(Address & XIIC_TX_DYN_STOP_MASK)) {
c0017f54:	fda45783          	lhu	a5,-38(s0)
c0017f58:	2007f793          	andi	a5,a5,512
c0017f5c:	04079063          	bnez	a5,c0017f9c <XIic_DynSend+0xc0>

		XIic_DynSend7BitAddress(BaseAddress, Address,
c0017f60:	fda45783          	lhu	a5,-38(s0)
c0017f64:	0ff7f793          	andi	a5,a5,255
c0017f68:	00179793          	slli	a5,a5,0x1
c0017f6c:	fef40523          	sb	a5,-22(s0)
c0017f70:	fea44783          	lbu	a5,-22(s0)
c0017f74:	ffe7f793          	andi	a5,a5,-2
c0017f78:	fef40523          	sb	a5,-22(s0)
c0017f7c:	fdc42783          	lw	a5,-36(s0)
c0017f80:	10878713          	addi	a4,a5,264
c0017f84:	fea44783          	lbu	a5,-22(s0)
c0017f88:	1007e793          	ori	a5,a5,256
c0017f8c:	00078593          	mv	a1,a5
c0017f90:	00070513          	mv	a0,a4
c0017f94:	c60ff0ef          	jal	ra,c00173f4 <Xil_Out32>
c0017f98:	03c0006f          	j	c0017fd4 <XIic_DynSend+0xf8>
				XIIC_WRITE_OPERATION);
	} else {
		XIic_DynSendStartStopAddress(BaseAddress, Address,
c0017f9c:	fda45783          	lhu	a5,-38(s0)
c0017fa0:	0ff7f793          	andi	a5,a5,255
c0017fa4:	00179793          	slli	a5,a5,0x1
c0017fa8:	fef405a3          	sb	a5,-21(s0)
c0017fac:	feb44783          	lbu	a5,-21(s0)
c0017fb0:	ffe7f793          	andi	a5,a5,-2
c0017fb4:	fef405a3          	sb	a5,-21(s0)
c0017fb8:	fdc42783          	lw	a5,-36(s0)
c0017fbc:	10878713          	addi	a4,a5,264
c0017fc0:	feb44783          	lbu	a5,-21(s0)
c0017fc4:	3007e793          	ori	a5,a5,768
c0017fc8:	00078593          	mv	a1,a5
c0017fcc:	00070513          	mv	a0,a4
c0017fd0:	c24ff0ef          	jal	ra,c00173f4 <Xil_Out32>
	}

	/*
	 * Wait for the bus to go busy.
	 */
	StatusRegister = XIic_ReadReg(BaseAddress,  XIIC_SR_REG_OFFSET);
c0017fd4:	fdc42783          	lw	a5,-36(s0)
c0017fd8:	10478793          	addi	a5,a5,260
c0017fdc:	00078513          	mv	a0,a5
c0017fe0:	becff0ef          	jal	ra,c00173cc <Xil_In32>
c0017fe4:	fea42623          	sw	a0,-20(s0)

	while (( StatusRegister & XIIC_SR_BUS_BUSY_MASK) !=
c0017fe8:	0180006f          	j	c0018000 <XIic_DynSend+0x124>
			XIIC_SR_BUS_BUSY_MASK) {
		StatusRegister = XIic_ReadReg(BaseAddress,
c0017fec:	fdc42783          	lw	a5,-36(s0)
c0017ff0:	10478793          	addi	a5,a5,260
c0017ff4:	00078513          	mv	a0,a5
c0017ff8:	bd4ff0ef          	jal	ra,c00173cc <Xil_In32>
c0017ffc:	fea42623          	sw	a0,-20(s0)
	while (( StatusRegister & XIIC_SR_BUS_BUSY_MASK) !=
c0018000:	fec42783          	lw	a5,-20(s0)
c0018004:	0047f793          	andi	a5,a5,4
c0018008:	fe0782e3          	beqz	a5,c0017fec <XIic_DynSend+0x110>

	/*
	 * Clear the latched interrupt status for the bus not busy bit which
	 * must be done while the bus is busy.
	 */
	XIic_ClearIisr(BaseAddress, XIIC_INTR_BNB_MASK);
c001800c:	fdc42783          	lw	a5,-36(s0)
c0018010:	02078493          	addi	s1,a5,32
c0018014:	fdc42783          	lw	a5,-36(s0)
c0018018:	02078793          	addi	a5,a5,32
c001801c:	00078513          	mv	a0,a5
c0018020:	bacff0ef          	jal	ra,c00173cc <Xil_In32>
c0018024:	00050793          	mv	a5,a0
c0018028:	0107f793          	andi	a5,a5,16
c001802c:	00078593          	mv	a1,a5
c0018030:	00048513          	mv	a0,s1
c0018034:	bc0ff0ef          	jal	ra,c00173f4 <Xil_Out32>

	/*
	 * Send the specified data to the device on the IIC bus specified by the
	 * the address.
	 */
	RemainingByteCount = DynSendData(BaseAddress, BufferPtr, ByteCount,
c0018038:	fd844703          	lbu	a4,-40(s0)
c001803c:	fd944783          	lbu	a5,-39(s0)
c0018040:	00070693          	mv	a3,a4
c0018044:	00078613          	mv	a2,a5
c0018048:	fd442583          	lw	a1,-44(s0)
c001804c:	fdc42503          	lw	a0,-36(s0)
c0018050:	02c000ef          	jal	ra,c001807c <DynSendData>
c0018054:	fea42223          	sw	a0,-28(s0)
					 Option);

	/*
	 * The send is complete return the number of bytes that was sent.
	 */
	return ByteCount - RemainingByteCount;
c0018058:	fd944703          	lbu	a4,-39(s0)
c001805c:	fe442783          	lw	a5,-28(s0)
c0018060:	40f707b3          	sub	a5,a4,a5
}
c0018064:	00078513          	mv	a0,a5
c0018068:	02c12083          	lw	ra,44(sp)
c001806c:	02812403          	lw	s0,40(sp)
c0018070:	02412483          	lw	s1,36(sp)
c0018074:	03010113          	addi	sp,sp,48
c0018078:	00008067          	ret

c001807c <DynSendData>:
*		because it is designed for minimal code space and complexity.
*
******************************************************************************/
static unsigned DynSendData(UINTPTR BaseAddress, u8 *BufferPtr,
			    u8 ByteCount, u8 Option)
{
c001807c:	fd010113          	addi	sp,sp,-48
c0018080:	02112623          	sw	ra,44(sp)
c0018084:	02812423          	sw	s0,40(sp)
c0018088:	03010413          	addi	s0,sp,48
c001808c:	fca42e23          	sw	a0,-36(s0)
c0018090:	fcb42c23          	sw	a1,-40(s0)
c0018094:	00060793          	mv	a5,a2
c0018098:	00068713          	mv	a4,a3
c001809c:	fcf40ba3          	sb	a5,-41(s0)
c00180a0:	00070793          	mv	a5,a4
c00180a4:	fcf40b23          	sb	a5,-42(s0)
	u32 IntrStatus;

	while (ByteCount > 0) {
c00180a8:	0d80006f          	j	c0018180 <DynSendData+0x104>
		/*
		 * Wait for the transmit to be empty before sending any more
		 * data by polling the interrupt status register.
		 */
		while (1) {
			IntrStatus = XIic_ReadIisr(BaseAddress);
c00180ac:	fdc42783          	lw	a5,-36(s0)
c00180b0:	02078793          	addi	a5,a5,32
c00180b4:	00078513          	mv	a0,a5
c00180b8:	b14ff0ef          	jal	ra,c00173cc <Xil_In32>
c00180bc:	fea42623          	sw	a0,-20(s0)
			if (IntrStatus & (XIIC_INTR_TX_ERROR_MASK |
c00180c0:	fec42783          	lw	a5,-20(s0)
c00180c4:	0137f793          	andi	a5,a5,19
c00180c8:	02078a63          	beqz	a5,c00180fc <DynSendData+0x80>
				 * Error Has occurred. Clear the Control
				 * register to send a STOP condition on the Bus
				 * and return the number of bytes still to
				 * transmit.
				 */
				XIic_WriteReg(BaseAddress,  XIIC_CR_REG_OFFSET,
c00180cc:	fdc42783          	lw	a5,-36(s0)
c00180d0:	10078793          	addi	a5,a5,256
c00180d4:	00300593          	li	a1,3
c00180d8:	00078513          	mv	a0,a5
c00180dc:	b18ff0ef          	jal	ra,c00173f4 <Xil_Out32>
						0x03);
				XIic_WriteReg(BaseAddress,  XIIC_CR_REG_OFFSET,
c00180e0:	fdc42783          	lw	a5,-36(s0)
c00180e4:	10078793          	addi	a5,a5,256
c00180e8:	00100593          	li	a1,1
c00180ec:	00078513          	mv	a0,a5
c00180f0:	b04ff0ef          	jal	ra,c00173f4 <Xil_Out32>
						0x01);

				return ByteCount;
c00180f4:	fd744783          	lbu	a5,-41(s0)
c00180f8:	0c00006f          	j	c00181b8 <DynSendData+0x13c>
			}

			/*
			 * Check for the transmit Fifo to become Empty.
			 */
			if (IntrStatus & XIIC_INTR_TX_EMPTY_MASK) {
c00180fc:	fec42783          	lw	a5,-20(s0)
c0018100:	0047f793          	andi	a5,a5,4
c0018104:	00079463          	bnez	a5,c001810c <DynSendData+0x90>
			IntrStatus = XIic_ReadIisr(BaseAddress);
c0018108:	fa5ff06f          	j	c00180ac <DynSendData+0x30>
				break;
c001810c:	00000013          	nop

		/*
		 * Send data to Tx Fifo. If a stop condition is specified and
		 * the last byte is being sent, then set the dynamic stop bit.
		 */
		if ((ByteCount == 1) && (Option == XIIC_STOP)) {
c0018110:	fd744703          	lbu	a4,-41(s0)
c0018114:	00100793          	li	a5,1
c0018118:	02f71c63          	bne	a4,a5,c0018150 <DynSendData+0xd4>
c001811c:	fd644783          	lbu	a5,-42(s0)
c0018120:	02079863          	bnez	a5,c0018150 <DynSendData+0xd4>
			/*
			 * The MSMS will be cleared automatically upon setting
			 *  dynamic stop.
			 */
			XIic_WriteReg(BaseAddress,  XIIC_DTR_REG_OFFSET,
c0018124:	fdc42783          	lw	a5,-36(s0)
c0018128:	10878693          	addi	a3,a5,264
c001812c:	fd842783          	lw	a5,-40(s0)
c0018130:	00178713          	addi	a4,a5,1
c0018134:	fce42c23          	sw	a4,-40(s0)
c0018138:	0007c783          	lbu	a5,0(a5)
c001813c:	2007e793          	ori	a5,a5,512
c0018140:	00078593          	mv	a1,a5
c0018144:	00068513          	mv	a0,a3
c0018148:	aacff0ef          	jal	ra,c00173f4 <Xil_Out32>
c001814c:	0280006f          	j	c0018174 <DynSendData+0xf8>
					XIIC_TX_DYN_STOP_MASK | *BufferPtr++);
		} else {
			XIic_WriteReg(BaseAddress,  XIIC_DTR_REG_OFFSET,
c0018150:	fdc42783          	lw	a5,-36(s0)
c0018154:	10878693          	addi	a3,a5,264
c0018158:	fd842783          	lw	a5,-40(s0)
c001815c:	00178713          	addi	a4,a5,1
c0018160:	fce42c23          	sw	a4,-40(s0)
c0018164:	0007c783          	lbu	a5,0(a5)
c0018168:	00078593          	mv	a1,a5
c001816c:	00068513          	mv	a0,a3
c0018170:	a84ff0ef          	jal	ra,c00173f4 <Xil_Out32>
		}

		/*
		 * Update the byte count to reflect the byte sent.
		 */
		ByteCount--;
c0018174:	fd744783          	lbu	a5,-41(s0)
c0018178:	fff78793          	addi	a5,a5,-1
c001817c:	fcf40ba3          	sb	a5,-41(s0)
	while (ByteCount > 0) {
c0018180:	fd744783          	lbu	a5,-41(s0)
c0018184:	f20794e3          	bnez	a5,c00180ac <DynSendData+0x30>
	}

	if (Option == XIIC_STOP) {
c0018188:	fd644783          	lbu	a5,-42(s0)
c001818c:	02079463          	bnez	a5,c00181b4 <DynSendData+0x138>
		 * data, Wait for the bus to transition to not busy before
		 * returning, the IIC device cannot be disabled until this
		 * occurs.
		 */
		while (1) {
			if (XIic_ReadIisr(BaseAddress) & XIIC_INTR_BNB_MASK) {
c0018190:	fdc42783          	lw	a5,-36(s0)
c0018194:	02078793          	addi	a5,a5,32
c0018198:	00078513          	mv	a0,a5
c001819c:	a30ff0ef          	jal	ra,c00173cc <Xil_In32>
c00181a0:	00050793          	mv	a5,a0
c00181a4:	0107f793          	andi	a5,a5,16
c00181a8:	00079463          	bnez	a5,c00181b0 <DynSendData+0x134>
c00181ac:	fe5ff06f          	j	c0018190 <DynSendData+0x114>
				break;
c00181b0:	00000013          	nop
			}
		}
	}

	return ByteCount;
c00181b4:	fd744783          	lbu	a5,-41(s0)
}
c00181b8:	00078513          	mv	a0,a5
c00181bc:	02c12083          	lw	ra,44(sp)
c00181c0:	02812403          	lw	s0,40(sp)
c00181c4:	03010113          	addi	sp,sp,48
c00181c8:	00008067          	ret

c00181cc <XIic_DynInit>:
*
* @note		None.
*
******************************************************************************/
int XIic_DynInit(UINTPTR BaseAddress)
{
c00181cc:	fd010113          	addi	sp,sp,-48
c00181d0:	02112623          	sw	ra,44(sp)
c00181d4:	02812423          	sw	s0,40(sp)
c00181d8:	03010413          	addi	s0,sp,48
c00181dc:	fca42e23          	sw	a0,-36(s0)
	u32 Status;

	/*
	 * Reset IIC Core.
	 */
	XIic_WriteReg(BaseAddress, XIIC_RESETR_OFFSET, XIIC_RESET_MASK);
c00181e0:	fdc42783          	lw	a5,-36(s0)
c00181e4:	04078793          	addi	a5,a5,64
c00181e8:	00a00593          	li	a1,10
c00181ec:	00078513          	mv	a0,a5
c00181f0:	a04ff0ef          	jal	ra,c00173f4 <Xil_Out32>

	/*
	 * Set receive Fifo depth to maximum (zero based).
	 */
	XIic_WriteReg(BaseAddress,  XIIC_RFD_REG_OFFSET,
c00181f4:	fdc42783          	lw	a5,-36(s0)
c00181f8:	12078793          	addi	a5,a5,288
c00181fc:	00f00593          	li	a1,15
c0018200:	00078513          	mv	a0,a5
c0018204:	9f0ff0ef          	jal	ra,c00173f4 <Xil_Out32>
			IIC_RX_FIFO_DEPTH - 1);

	/*
	 * Reset Tx Fifo.
	 */
	XIic_WriteReg(BaseAddress,  XIIC_CR_REG_OFFSET,
c0018208:	fdc42783          	lw	a5,-36(s0)
c001820c:	10078793          	addi	a5,a5,256
c0018210:	00200593          	li	a1,2
c0018214:	00078513          	mv	a0,a5
c0018218:	9dcff0ef          	jal	ra,c00173f4 <Xil_Out32>
			XIIC_CR_TX_FIFO_RESET_MASK);

	/*
	 * Enable IIC Device, remove Tx Fifo reset & disable general call.
	 */
	XIic_WriteReg(BaseAddress, XIIC_CR_REG_OFFSET,
c001821c:	fdc42783          	lw	a5,-36(s0)
c0018220:	10078793          	addi	a5,a5,256
c0018224:	00100593          	li	a1,1
c0018228:	00078513          	mv	a0,a5
c001822c:	9c8ff0ef          	jal	ra,c00173f4 <Xil_Out32>

	/*
	 * Read status register and verify IIC Device is in initial state. Only
	 * the Tx Fifo and Rx Fifo empty bits should be set.
	 */
	Status = XIic_ReadReg(BaseAddress,  XIIC_SR_REG_OFFSET);
c0018230:	fdc42783          	lw	a5,-36(s0)
c0018234:	10478793          	addi	a5,a5,260
c0018238:	00078513          	mv	a0,a5
c001823c:	990ff0ef          	jal	ra,c00173cc <Xil_In32>
c0018240:	fea42623          	sw	a0,-20(s0)
	if(Status == (XIIC_SR_RX_FIFO_EMPTY_MASK |
c0018244:	fec42703          	lw	a4,-20(s0)
c0018248:	0c000793          	li	a5,192
c001824c:	00f71663          	bne	a4,a5,c0018258 <XIic_DynInit+0x8c>
		XIIC_SR_TX_FIFO_EMPTY_MASK)) {
		return XST_SUCCESS;
c0018250:	00000793          	li	a5,0
c0018254:	0080006f          	j	c001825c <XIic_DynInit+0x90>
	}

	return XST_FAILURE;
c0018258:	00100793          	li	a5,1
}
c001825c:	00078513          	mv	a0,a5
c0018260:	02c12083          	lw	ra,44(sp)
c0018264:	02812403          	lw	s0,40(sp)
c0018268:	03010113          	addi	sp,sp,48
c001826c:	00008067          	ret

c0018270 <XIic_CheckIsBusBusy>:
*
* @note		None.
*
******************************************************************************/
u32 XIic_CheckIsBusBusy(UINTPTR BaseAddress)
{
c0018270:	fd010113          	addi	sp,sp,-48
c0018274:	02112623          	sw	ra,44(sp)
c0018278:	02812423          	sw	s0,40(sp)
c001827c:	03010413          	addi	s0,sp,48
c0018280:	fca42e23          	sw	a0,-36(s0)
	u32 StatusReg;

	StatusReg = XIic_ReadReg(BaseAddress, XIIC_SR_REG_OFFSET);
c0018284:	fdc42783          	lw	a5,-36(s0)
c0018288:	10478793          	addi	a5,a5,260
c001828c:	00078513          	mv	a0,a5
c0018290:	93cff0ef          	jal	ra,c00173cc <Xil_In32>
c0018294:	fea42623          	sw	a0,-20(s0)
	if (StatusReg & XIIC_SR_BUS_BUSY_MASK) {
c0018298:	fec42783          	lw	a5,-20(s0)
c001829c:	0047f793          	andi	a5,a5,4
c00182a0:	00078663          	beqz	a5,c00182ac <XIic_CheckIsBusBusy+0x3c>
		return TRUE;
c00182a4:	00100793          	li	a5,1
c00182a8:	0080006f          	j	c00182b0 <XIic_CheckIsBusBusy+0x40>
	} else {
		return FALSE;
c00182ac:	00000793          	li	a5,0
	}
}
c00182b0:	00078513          	mv	a0,a5
c00182b4:	02c12083          	lw	ra,44(sp)
c00182b8:	02812403          	lw	s0,40(sp)
c00182bc:	03010113          	addi	sp,sp,48
c00182c0:	00008067          	ret

c00182c4 <XIic_WaitBusFree>:
*
* @note		None.
*
*******************************************************************************/
u32 XIic_WaitBusFree(UINTPTR BaseAddress)
{
c00182c4:	fd010113          	addi	sp,sp,-48
c00182c8:	02112623          	sw	ra,44(sp)
c00182cc:	02812423          	sw	s0,40(sp)
c00182d0:	03010413          	addi	s0,sp,48
c00182d4:	fca42e23          	sw	a0,-36(s0)
	u32 BusyCount = 0;
c00182d8:	fe042623          	sw	zero,-20(s0)

	while (XIic_CheckIsBusBusy(BaseAddress)) {
c00182dc:	02c0006f          	j	c0018308 <XIic_WaitBusFree+0x44>
		if (BusyCount++ > 10000) {
c00182e0:	fec42783          	lw	a5,-20(s0)
c00182e4:	00178713          	addi	a4,a5,1
c00182e8:	fee42623          	sw	a4,-20(s0)
c00182ec:	00002737          	lui	a4,0x2
c00182f0:	71070713          	addi	a4,a4,1808 # 2710 <_STACK_SIZE+0x1710>
c00182f4:	00f77663          	bgeu	a4,a5,c0018300 <XIic_WaitBusFree+0x3c>
			return XST_FAILURE;
c00182f8:	00100793          	li	a5,1
c00182fc:	0200006f          	j	c001831c <XIic_WaitBusFree+0x58>
		}
		msleep(0.1);
c0018300:	00000513          	li	a0,0
c0018304:	a71ea0ef          	jal	ra,c0002d74 <vTaskDelay>
	while (XIic_CheckIsBusBusy(BaseAddress)) {
c0018308:	fdc42503          	lw	a0,-36(s0)
c001830c:	f65ff0ef          	jal	ra,c0018270 <XIic_CheckIsBusBusy>
c0018310:	00050793          	mv	a5,a0
c0018314:	fc0796e3          	bnez	a5,c00182e0 <XIic_WaitBusFree+0x1c>
	}

	return XST_SUCCESS;
c0018318:	00000793          	li	a5,0
}
c001831c:	00078513          	mv	a0,a5
c0018320:	02c12083          	lw	ra,44(sp)
c0018324:	02812403          	lw	s0,40(sp)
c0018328:	03010113          	addi	sp,sp,48
c001832c:	00008067          	ret

c0018330 <XIic_LookupConfig>:
*
* @note		None.
*
******************************************************************************/
XIic_Config *XIic_LookupConfig(u16 DeviceId)
{
c0018330:	fd010113          	addi	sp,sp,-48
c0018334:	02812623          	sw	s0,44(sp)
c0018338:	03010413          	addi	s0,sp,48
c001833c:	00050793          	mv	a5,a0
c0018340:	fcf41f23          	sh	a5,-34(s0)
	XIic_Config *CfgPtr = NULL;
c0018344:	fe042623          	sw	zero,-20(s0)
	u32 Index;

	for (Index = 0; Index < XPAR_XIIC_NUM_INSTANCES; Index++) {
c0018348:	fe042423          	sw	zero,-24(s0)
c001834c:	04c0006f          	j	c0018398 <XIic_LookupConfig+0x68>
		if (XIic_ConfigTable[Index].DeviceId == DeviceId) {
c0018350:	07fea717          	auipc	a4,0x7fea
c0018354:	79870713          	addi	a4,a4,1944 # c8002ae8 <XIic_ConfigTable>
c0018358:	fe842783          	lw	a5,-24(s0)
c001835c:	00479793          	slli	a5,a5,0x4
c0018360:	00f707b3          	add	a5,a4,a5
c0018364:	0007d783          	lhu	a5,0(a5)
c0018368:	fde45703          	lhu	a4,-34(s0)
c001836c:	02f71063          	bne	a4,a5,c001838c <XIic_LookupConfig+0x5c>
			CfgPtr = &XIic_ConfigTable[Index];
c0018370:	fe842783          	lw	a5,-24(s0)
c0018374:	00479713          	slli	a4,a5,0x4
c0018378:	07fea797          	auipc	a5,0x7fea
c001837c:	77078793          	addi	a5,a5,1904 # c8002ae8 <XIic_ConfigTable>
c0018380:	00f707b3          	add	a5,a4,a5
c0018384:	fef42623          	sw	a5,-20(s0)
			break;
c0018388:	0180006f          	j	c00183a0 <XIic_LookupConfig+0x70>
	for (Index = 0; Index < XPAR_XIIC_NUM_INSTANCES; Index++) {
c001838c:	fe842783          	lw	a5,-24(s0)
c0018390:	00178793          	addi	a5,a5,1
c0018394:	fef42423          	sw	a5,-24(s0)
c0018398:	fe842783          	lw	a5,-24(s0)
c001839c:	fa078ae3          	beqz	a5,c0018350 <XIic_LookupConfig+0x20>
		}
	}

	return CfgPtr;
c00183a0:	fec42783          	lw	a5,-20(s0)
}
c00183a4:	00078513          	mv	a0,a5
c00183a8:	02c12403          	lw	s0,44(sp)
c00183ac:	03010113          	addi	sp,sp,48
c00183b0:	00008067          	ret

c00183b4 <XIic_Initialize>:
*
* @note		None.
*
****************************************************************************/
int XIic_Initialize(XIic *InstancePtr, u16 DeviceId)
{
c00183b4:	fd010113          	addi	sp,sp,-48
c00183b8:	02112623          	sw	ra,44(sp)
c00183bc:	02812423          	sw	s0,40(sp)
c00183c0:	03010413          	addi	s0,sp,48
c00183c4:	fca42e23          	sw	a0,-36(s0)
c00183c8:	00058793          	mv	a5,a1
c00183cc:	fcf41d23          	sh	a5,-38(s0)
	XIic_Config *ConfigPtr;	/* Pointer to configuration data */

	/*
	 * Asserts test the validity of selected input arguments.
	 */
	Xil_AssertNonvoid(InstancePtr != NULL);
c00183d0:	fdc42783          	lw	a5,-36(s0)
c00183d4:	02078663          	beqz	a5,c0018400 <XIic_Initialize+0x4c>
c00183d8:	07fea797          	auipc	a5,0x7fea
c00183dc:	53c78793          	addi	a5,a5,1340 # c8002914 <Xil_AssertStatus>
c00183e0:	0007a023          	sw	zero,0(a5)

	/*
	 * Lookup the device configuration in the temporary CROM table. Use this
	 * configuration info down below when initializing this component.
	 */
	ConfigPtr = XIic_LookupConfig(DeviceId);
c00183e4:	fda45783          	lhu	a5,-38(s0)
c00183e8:	00078513          	mv	a0,a5
c00183ec:	f45ff0ef          	jal	ra,c0018330 <XIic_LookupConfig>
c00183f0:	fea42623          	sw	a0,-20(s0)
	if (ConfigPtr == NULL) {
c00183f4:	fec42783          	lw	a5,-20(s0)
c00183f8:	02079c63          	bnez	a5,c0018430 <XIic_Initialize+0x7c>
c00183fc:	02c0006f          	j	c0018428 <XIic_Initialize+0x74>
	Xil_AssertNonvoid(InstancePtr != NULL);
c0018400:	09400593          	li	a1,148
c0018404:	07fe9517          	auipc	a0,0x7fe9
c0018408:	4c850513          	addi	a0,a0,1224 # c80018cc <__rodata_start+0x18cc>
c001840c:	6b0050ef          	jal	ra,c001dabc <Xil_Assert>
c0018410:	07fea797          	auipc	a5,0x7fea
c0018414:	50478793          	addi	a5,a5,1284 # c8002914 <Xil_AssertStatus>
c0018418:	00100713          	li	a4,1
c001841c:	00e7a023          	sw	a4,0(a5)
c0018420:	00000793          	li	a5,0
c0018424:	0280006f          	j	c001844c <XIic_Initialize+0x98>
		return XST_DEVICE_NOT_FOUND;
c0018428:	00200793          	li	a5,2
c001842c:	0200006f          	j	c001844c <XIic_Initialize+0x98>
	}

	return XIic_CfgInitialize(InstancePtr, ConfigPtr,
c0018430:	fec42783          	lw	a5,-20(s0)
c0018434:	0047a783          	lw	a5,4(a5)
c0018438:	00078613          	mv	a2,a5
c001843c:	fec42583          	lw	a1,-20(s0)
c0018440:	fdc42503          	lw	a0,-36(s0)
c0018444:	aa4fe0ef          	jal	ra,c00166e8 <XIic_CfgInitialize>
c0018448:	00050793          	mv	a5,a0
				  ConfigPtr->BaseAddress);
}
c001844c:	00078513          	mv	a0,a5
c0018450:	02c12083          	lw	ra,44(sp)
c0018454:	02812403          	lw	s0,40(sp)
c0018458:	03010113          	addi	sp,sp,48
c001845c:	00008067          	ret

c0018460 <Xil_In32>:
{
c0018460:	fe010113          	addi	sp,sp,-32
c0018464:	00812e23          	sw	s0,28(sp)
c0018468:	02010413          	addi	s0,sp,32
c001846c:	fea42623          	sw	a0,-20(s0)
	return *(volatile u32 *) Addr;
c0018470:	fec42783          	lw	a5,-20(s0)
c0018474:	0007a783          	lw	a5,0(a5)
}
c0018478:	00078513          	mv	a0,a5
c001847c:	01c12403          	lw	s0,28(sp)
c0018480:	02010113          	addi	sp,sp,32
c0018484:	00008067          	ret

c0018488 <Xil_Out32>:
{
c0018488:	fd010113          	addi	sp,sp,-48
c001848c:	02812623          	sw	s0,44(sp)
c0018490:	03010413          	addi	s0,sp,48
c0018494:	fca42e23          	sw	a0,-36(s0)
c0018498:	fcb42c23          	sw	a1,-40(s0)
	volatile u32 *LocalAddr = (volatile u32 *)Addr;
c001849c:	fdc42783          	lw	a5,-36(s0)
c00184a0:	fef42623          	sw	a5,-20(s0)
	*LocalAddr = Value;
c00184a4:	fec42783          	lw	a5,-20(s0)
c00184a8:	fd842703          	lw	a4,-40(s0)
c00184ac:	00e7a023          	sw	a4,0(a5)
}
c00184b0:	00000013          	nop
c00184b4:	02c12403          	lw	s0,44(sp)
c00184b8:	03010113          	addi	sp,sp,48
c00184bc:	00008067          	ret

c00184c0 <XIic_SelfTest>:
*
* @note		None.
*
****************************************************************************/
int XIic_SelfTest(XIic *InstancePtr)
{
c00184c0:	fd010113          	addi	sp,sp,-48
c00184c4:	02112623          	sw	ra,44(sp)
c00184c8:	02812423          	sw	s0,40(sp)
c00184cc:	03010413          	addi	s0,sp,48
c00184d0:	fca42e23          	sw	a0,-36(s0)
	int Status = XST_SUCCESS;
c00184d4:	fe042623          	sw	zero,-20(s0)
	int GlobalIntrStatus;
	u32 IntrEnableStatus;

	Xil_AssertNonvoid(InstancePtr != NULL);
c00184d8:	fdc42783          	lw	a5,-36(s0)
c00184dc:	02078463          	beqz	a5,c0018504 <XIic_SelfTest+0x44>
c00184e0:	07fea797          	auipc	a5,0x7fea
c00184e4:	43478793          	addi	a5,a5,1076 # c8002914 <Xil_AssertStatus>
c00184e8:	0007a023          	sw	zero,0(a5)
	Xil_AssertNonvoid(InstancePtr->IsReady == XIL_COMPONENT_IS_READY);
c00184ec:	fdc42783          	lw	a5,-36(s0)
c00184f0:	0147a703          	lw	a4,20(a5)
c00184f4:	111117b7          	lui	a5,0x11111
c00184f8:	11178793          	addi	a5,a5,273 # 11111111 <_DMEM_LENGTH+0x10911111>
c00184fc:	0af71663          	bne	a4,a5,c00185a8 <XIic_SelfTest+0xe8>
c0018500:	02c0006f          	j	c001852c <XIic_SelfTest+0x6c>
	Xil_AssertNonvoid(InstancePtr != NULL);
c0018504:	06d00593          	li	a1,109
c0018508:	07fe9517          	auipc	a0,0x7fe9
c001850c:	3e050513          	addi	a0,a0,992 # c80018e8 <__rodata_start+0x18e8>
c0018510:	5ac050ef          	jal	ra,c001dabc <Xil_Assert>
c0018514:	07fea797          	auipc	a5,0x7fea
c0018518:	40078793          	addi	a5,a5,1024 # c8002914 <Xil_AssertStatus>
c001851c:	00100713          	li	a4,1
c0018520:	00e7a023          	sw	a4,0(a5)
c0018524:	00000793          	li	a5,0
c0018528:	15c0006f          	j	c0018684 <XIic_SelfTest+0x1c4>
	Xil_AssertNonvoid(InstancePtr->IsReady == XIL_COMPONENT_IS_READY);
c001852c:	07fea797          	auipc	a5,0x7fea
c0018530:	3e878793          	addi	a5,a5,1000 # c8002914 <Xil_AssertStatus>
c0018534:	0007a023          	sw	zero,0(a5)

	/*
	 * Store the Global Interrupt Register and the Interrupt Enable Register
	 * contents.
	 */
	GlobalIntrStatus = XIic_IsIntrGlobalEnabled(InstancePtr->BaseAddress);
c0018538:	fdc42783          	lw	a5,-36(s0)
c001853c:	00c7a783          	lw	a5,12(a5)
c0018540:	01c78793          	addi	a5,a5,28
c0018544:	00078513          	mv	a0,a5
c0018548:	f19ff0ef          	jal	ra,c0018460 <Xil_In32>
c001854c:	00050713          	mv	a4,a0
c0018550:	800007b7          	lui	a5,0x80000
c0018554:	00f707b3          	add	a5,a4,a5
c0018558:	0017b793          	seqz	a5,a5
c001855c:	0ff7f793          	andi	a5,a5,255
c0018560:	fef42423          	sw	a5,-24(s0)
	IntrEnableStatus = XIic_ReadIier(InstancePtr->BaseAddress);
c0018564:	fdc42783          	lw	a5,-36(s0)
c0018568:	00c7a783          	lw	a5,12(a5) # 8000000c <_end+0xb7f7b78c>
c001856c:	02878793          	addi	a5,a5,40
c0018570:	00078513          	mv	a0,a5
c0018574:	eedff0ef          	jal	ra,c0018460 <Xil_In32>
c0018578:	fea42223          	sw	a0,-28(s0)

	/*
	 * Reset the device so it's in a known state and the default state of
	 * the interrupt registers can be tested.
	 */
	XIic_Reset(InstancePtr);
c001857c:	fdc42503          	lw	a0,-36(s0)
c0018580:	d74fe0ef          	jal	ra,c0016af4 <XIic_Reset>

	if (XIic_IsIntrGlobalEnabled(InstancePtr->BaseAddress)!= 0) {
c0018584:	fdc42783          	lw	a5,-36(s0)
c0018588:	00c7a783          	lw	a5,12(a5)
c001858c:	01c78793          	addi	a5,a5,28
c0018590:	00078513          	mv	a0,a5
c0018594:	ecdff0ef          	jal	ra,c0018460 <Xil_In32>
c0018598:	00050713          	mv	a4,a0
c001859c:	800007b7          	lui	a5,0x80000
c00185a0:	02f71c63          	bne	a4,a5,c00185d8 <XIic_SelfTest+0x118>
c00185a4:	02c0006f          	j	c00185d0 <XIic_SelfTest+0x110>
	Xil_AssertNonvoid(InstancePtr->IsReady == XIL_COMPONENT_IS_READY);
c00185a8:	06e00593          	li	a1,110
c00185ac:	07fe9517          	auipc	a0,0x7fe9
c00185b0:	33c50513          	addi	a0,a0,828 # c80018e8 <__rodata_start+0x18e8>
c00185b4:	508050ef          	jal	ra,c001dabc <Xil_Assert>
c00185b8:	07fea797          	auipc	a5,0x7fea
c00185bc:	35c78793          	addi	a5,a5,860 # c8002914 <Xil_AssertStatus>
c00185c0:	00100713          	li	a4,1
c00185c4:	00e7a023          	sw	a4,0(a5)
c00185c8:	00000793          	li	a5,0
c00185cc:	0b80006f          	j	c0018684 <XIic_SelfTest+0x1c4>
		Status = XST_FAILURE;
c00185d0:	00100793          	li	a5,1
c00185d4:	fef42623          	sw	a5,-20(s0)
	}

	if (XIic_ReadIier(InstancePtr->BaseAddress)!= 0) {
c00185d8:	fdc42783          	lw	a5,-36(s0)
c00185dc:	00c7a783          	lw	a5,12(a5)
c00185e0:	02878793          	addi	a5,a5,40
c00185e4:	00078513          	mv	a0,a5
c00185e8:	e79ff0ef          	jal	ra,c0018460 <Xil_In32>
c00185ec:	00050793          	mv	a5,a0
c00185f0:	00078663          	beqz	a5,c00185fc <XIic_SelfTest+0x13c>
		Status = XST_FAILURE;
c00185f4:	00100793          	li	a5,1
c00185f8:	fef42623          	sw	a5,-20(s0)
	}

	/*
	 * Test Read/Write to the Interrupt Enable register.
	 */
	XIic_WriteIier(InstancePtr->BaseAddress, XIIC_TX_RX_INTERRUPTS);
c00185fc:	fdc42783          	lw	a5,-36(s0)
c0018600:	00c7a783          	lw	a5,12(a5)
c0018604:	02878793          	addi	a5,a5,40
c0018608:	08e00593          	li	a1,142
c001860c:	00078513          	mv	a0,a5
c0018610:	e79ff0ef          	jal	ra,c0018488 <Xil_Out32>
	if (XIic_ReadIier(InstancePtr->BaseAddress)!= XIIC_TX_RX_INTERRUPTS) {
c0018614:	fdc42783          	lw	a5,-36(s0)
c0018618:	00c7a783          	lw	a5,12(a5)
c001861c:	02878793          	addi	a5,a5,40
c0018620:	00078513          	mv	a0,a5
c0018624:	e3dff0ef          	jal	ra,c0018460 <Xil_In32>
c0018628:	00050713          	mv	a4,a0
c001862c:	08e00793          	li	a5,142
c0018630:	00f70663          	beq	a4,a5,c001863c <XIic_SelfTest+0x17c>
		Status = XST_FAILURE;
c0018634:	00100793          	li	a5,1
c0018638:	fef42623          	sw	a5,-20(s0)
	}

	/*
	 * Reset device to remove the affects of the previous test.
	 */
	XIic_Reset(InstancePtr);
c001863c:	fdc42503          	lw	a0,-36(s0)
c0018640:	cb4fe0ef          	jal	ra,c0016af4 <XIic_Reset>

	/*
	 * Restore the Global Interrupt Register and the Interrupt Enable
	 * Register contents.
	 */
	if (GlobalIntrStatus == TRUE) {
c0018644:	fe842703          	lw	a4,-24(s0)
c0018648:	00100793          	li	a5,1
c001864c:	00f71e63          	bne	a4,a5,c0018668 <XIic_SelfTest+0x1a8>
		XIic_IntrGlobalEnable(InstancePtr->BaseAddress);
c0018650:	fdc42783          	lw	a5,-36(s0)
c0018654:	00c7a783          	lw	a5,12(a5)
c0018658:	01c78793          	addi	a5,a5,28
c001865c:	800005b7          	lui	a1,0x80000
c0018660:	00078513          	mv	a0,a5
c0018664:	e25ff0ef          	jal	ra,c0018488 <Xil_Out32>
	}
	XIic_WriteIier(InstancePtr->BaseAddress, IntrEnableStatus);
c0018668:	fdc42783          	lw	a5,-36(s0)
c001866c:	00c7a783          	lw	a5,12(a5)
c0018670:	02878793          	addi	a5,a5,40
c0018674:	fe442583          	lw	a1,-28(s0)
c0018678:	00078513          	mv	a0,a5
c001867c:	e0dff0ef          	jal	ra,c0018488 <Xil_Out32>

	return Status;
c0018680:	fec42783          	lw	a5,-20(s0)
}
c0018684:	00078513          	mv	a0,a5
c0018688:	02c12083          	lw	ra,44(sp)
c001868c:	02812403          	lw	s0,40(sp)
c0018690:	03010113          	addi	sp,sp,48
c0018694:	00008067          	ret

c0018698 <Xil_In32>:
{
c0018698:	fe010113          	addi	sp,sp,-32
c001869c:	00812e23          	sw	s0,28(sp)
c00186a0:	02010413          	addi	s0,sp,32
c00186a4:	fea42623          	sw	a0,-20(s0)
	return *(volatile u32 *) Addr;
c00186a8:	fec42783          	lw	a5,-20(s0)
c00186ac:	0007a783          	lw	a5,0(a5)
}
c00186b0:	00078513          	mv	a0,a5
c00186b4:	01c12403          	lw	s0,28(sp)
c00186b8:	02010113          	addi	sp,sp,32
c00186bc:	00008067          	ret

c00186c0 <Xil_Out32>:
{
c00186c0:	fd010113          	addi	sp,sp,-48
c00186c4:	02812623          	sw	s0,44(sp)
c00186c8:	03010413          	addi	s0,sp,48
c00186cc:	fca42e23          	sw	a0,-36(s0)
c00186d0:	fcb42c23          	sw	a1,-40(s0)
	volatile u32 *LocalAddr = (volatile u32 *)Addr;
c00186d4:	fdc42783          	lw	a5,-36(s0)
c00186d8:	fef42623          	sw	a5,-20(s0)
	*LocalAddr = Value;
c00186dc:	fec42783          	lw	a5,-20(s0)
c00186e0:	fd842703          	lw	a4,-40(s0)
c00186e4:	00e7a023          	sw	a4,0(a5)
}
c00186e8:	00000013          	nop
c00186ec:	02c12403          	lw	s0,44(sp)
c00186f0:	03010113          	addi	sp,sp,48
c00186f4:	00008067          	ret

c00186f8 <XIic_MasterSend>:
*
* @note		None.
*
******************************************************************************/
int XIic_MasterSend(XIic *InstancePtr, u8 *TxMsgPtr, int ByteCount)
{
c00186f8:	fd010113          	addi	sp,sp,-48
c00186fc:	02112623          	sw	ra,44(sp)
c0018700:	02812423          	sw	s0,40(sp)
c0018704:	02912223          	sw	s1,36(sp)
c0018708:	03010413          	addi	s0,sp,48
c001870c:	fca42e23          	sw	a0,-36(s0)
c0018710:	fcb42c23          	sw	a1,-40(s0)
c0018714:	fcc42a23          	sw	a2,-44(s0)
	u32 CntlReg;

	XIic_IntrGlobalDisable(InstancePtr->BaseAddress);
c0018718:	fdc42783          	lw	a5,-36(s0)
c001871c:	00c7a783          	lw	a5,12(a5)
c0018720:	01c78793          	addi	a5,a5,28
c0018724:	00000593          	li	a1,0
c0018728:	00078513          	mv	a0,a5
c001872c:	f95ff0ef          	jal	ra,c00186c0 <Xil_Out32>

	/*
	 * Ensure that the master processing has been included such that events
	 * will be properly handled.
	 */
	XIIC_MASTER_INCLUDE;
c0018730:	07fea797          	auipc	a5,0x7fea
c0018734:	24078793          	addi	a5,a5,576 # c8002970 <XIic_RecvMasterFuncPtr>
c0018738:	00001717          	auipc	a4,0x1
c001873c:	cf870713          	addi	a4,a4,-776 # c0019430 <RecvMasterData>
c0018740:	00e7a023          	sw	a4,0(a5)
c0018744:	07fea797          	auipc	a5,0x7fea
c0018748:	23078793          	addi	a5,a5,560 # c8002974 <XIic_SendMasterFuncPtr>
c001874c:	00001717          	auipc	a4,0x1
c0018750:	a0070713          	addi	a4,a4,-1536 # c001914c <SendMasterData>
c0018754:	00e7a023          	sw	a4,0(a5)
	InstancePtr->IsDynamic = FALSE;
c0018758:	fdc42783          	lw	a5,-36(s0)
c001875c:	0407ac23          	sw	zero,88(a5)

	/*
	 * If the busy is busy, then exit the critical region and wait for the
	 * bus to not be busy, the function enables the bus not busy interrupt.
	 */
	if (IsBusBusy(InstancePtr)) {
c0018760:	fdc42503          	lw	a0,-36(s0)
c0018764:	7ac000ef          	jal	ra,c0018f10 <IsBusBusy>
c0018768:	00050793          	mv	a5,a0
c001876c:	02078263          	beqz	a5,c0018790 <XIic_MasterSend+0x98>
		XIic_IntrGlobalEnable(InstancePtr->BaseAddress);
c0018770:	fdc42783          	lw	a5,-36(s0)
c0018774:	00c7a783          	lw	a5,12(a5)
c0018778:	01c78793          	addi	a5,a5,28
c001877c:	800005b7          	lui	a1,0x80000
c0018780:	00078513          	mv	a0,a5
c0018784:	f3dff0ef          	jal	ra,c00186c0 <Xil_Out32>

		return XST_IIC_BUS_BUSY;
c0018788:	43500793          	li	a5,1077
c001878c:	2cc0006f          	j	c0018a58 <XIic_MasterSend+0x360>
	/*
	 * If it is already a master on the bus (repeated start), the direction
	 * was set to Tx which is throttling bus. The control register needs to
	 * be set before putting data into the FIFO.
	 */
	CntlReg = XIic_ReadReg(InstancePtr->BaseAddress, XIIC_CR_REG_OFFSET);
c0018790:	fdc42783          	lw	a5,-36(s0)
c0018794:	00c7a783          	lw	a5,12(a5)
c0018798:	10078793          	addi	a5,a5,256
c001879c:	00078513          	mv	a0,a5
c00187a0:	ef9ff0ef          	jal	ra,c0018698 <Xil_In32>
c00187a4:	fea42623          	sw	a0,-20(s0)
	if (CntlReg & XIIC_CR_MSMS_MASK) {
c00187a8:	fec42783          	lw	a5,-20(s0)
c00187ac:	0047f793          	andi	a5,a5,4
c00187b0:	04078663          	beqz	a5,c00187fc <XIic_MasterSend+0x104>
		CntlReg &= ~XIIC_CR_NO_ACK_MASK;
c00187b4:	fec42783          	lw	a5,-20(s0)
c00187b8:	fef7f793          	andi	a5,a5,-17
c00187bc:	fef42623          	sw	a5,-20(s0)
		CntlReg |= (XIIC_CR_DIR_IS_TX_MASK |
c00187c0:	fec42783          	lw	a5,-20(s0)
c00187c4:	0287e793          	ori	a5,a5,40
c00187c8:	fef42623          	sw	a5,-20(s0)
				XIIC_CR_REPEATED_START_MASK);

		XIic_WriteReg(InstancePtr->BaseAddress, XIIC_CR_REG_OFFSET,
c00187cc:	fdc42783          	lw	a5,-36(s0)
c00187d0:	00c7a783          	lw	a5,12(a5)
c00187d4:	10078793          	addi	a5,a5,256
c00187d8:	fec42583          	lw	a1,-20(s0)
c00187dc:	00078513          	mv	a0,a5
c00187e0:	ee1ff0ef          	jal	ra,c00186c0 <Xil_Out32>
				CntlReg);
		InstancePtr->Stats.RepeatedStarts++;
c00187e4:	fdc42783          	lw	a5,-36(s0)
c00187e8:	0017c783          	lbu	a5,1(a5)
c00187ec:	00178793          	addi	a5,a5,1
c00187f0:	0ff7f713          	andi	a4,a5,255
c00187f4:	fdc42783          	lw	a5,-36(s0)
c00187f8:	00e780a3          	sb	a4,1(a5)
	}

	/*
	 * Save message state.
	 */
	InstancePtr->SendByteCount = ByteCount;
c00187fc:	fdc42783          	lw	a5,-36(s0)
c0018800:	fd442703          	lw	a4,-44(s0)
c0018804:	02e7a823          	sw	a4,48(a5)
	InstancePtr->SendBufferPtr = TxMsgPtr;
c0018808:	fdc42783          	lw	a5,-36(s0)
c001880c:	fd842703          	lw	a4,-40(s0)
c0018810:	02e7a223          	sw	a4,36(a5)
	InstancePtr->RecvBufferPtr = NULL;
c0018814:	fdc42783          	lw	a5,-36(s0)
c0018818:	0207a423          	sw	zero,40(a5)
	 * operation to be performed on the bus is a write operation,
	 * a general call address is handled the same as a 7 bit address even
	 * if 10 bit address is selected.
	 * Set the transmit address state to indicate the address has been sent.
	 */
	if ((InstancePtr->Options & XII_SEND_10_BIT_OPTION) &&
c001881c:	fdc42783          	lw	a5,-36(s0)
c0018820:	0207a783          	lw	a5,32(a5)
c0018824:	0047f793          	andi	a5,a5,4
c0018828:	08078063          	beqz	a5,c00188a8 <XIic_MasterSend+0x1b0>
		(InstancePtr->AddrOfSlave != 0)) {
c001882c:	fdc42783          	lw	a5,-36(s0)
c0018830:	01c7a783          	lw	a5,28(a5)
	if ((InstancePtr->Options & XII_SEND_10_BIT_OPTION) &&
c0018834:	06078a63          	beqz	a5,c00188a8 <XIic_MasterSend+0x1b0>
		XIic_Send10BitAddrByte1(InstancePtr->AddrOfSlave,
c0018838:	fdc42783          	lw	a5,-36(s0)
c001883c:	01c7a783          	lw	a5,28(a5)
c0018840:	4077d793          	srai	a5,a5,0x7
c0018844:	fef405a3          	sb	a5,-21(s0)
c0018848:	feb40783          	lb	a5,-21(s0)
c001884c:	0067f793          	andi	a5,a5,6
c0018850:	01879793          	slli	a5,a5,0x18
c0018854:	4187d793          	srai	a5,a5,0x18
c0018858:	ff07e793          	ori	a5,a5,-16
c001885c:	01879793          	slli	a5,a5,0x18
c0018860:	4187d793          	srai	a5,a5,0x18
c0018864:	fef405a3          	sb	a5,-21(s0)
c0018868:	fdc42783          	lw	a5,-36(s0)
c001886c:	00c7a783          	lw	a5,12(a5)
c0018870:	10878793          	addi	a5,a5,264
c0018874:	feb44703          	lbu	a4,-21(s0)
c0018878:	00070593          	mv	a1,a4
c001887c:	00078513          	mv	a0,a5
c0018880:	e41ff0ef          	jal	ra,c00186c0 <Xil_Out32>
					 XIIC_WRITE_OPERATION);
		XIic_Send10BitAddrByte2(InstancePtr->AddrOfSlave);
c0018884:	fdc42783          	lw	a5,-36(s0)
c0018888:	00c7a783          	lw	a5,12(a5)
c001888c:	10878713          	addi	a4,a5,264
c0018890:	fdc42783          	lw	a5,-36(s0)
c0018894:	01c7a783          	lw	a5,28(a5)
c0018898:	00078593          	mv	a1,a5
c001889c:	00070513          	mv	a0,a4
c00188a0:	e21ff0ef          	jal	ra,c00186c0 <Xil_Out32>
c00188a4:	0400006f          	j	c00188e4 <XIic_MasterSend+0x1ec>
	} else {
		XIic_Send7BitAddr(InstancePtr->AddrOfSlave,
c00188a8:	fdc42783          	lw	a5,-36(s0)
c00188ac:	01c7a783          	lw	a5,28(a5)
c00188b0:	0ff7f793          	andi	a5,a5,255
c00188b4:	00179793          	slli	a5,a5,0x1
c00188b8:	fef40523          	sb	a5,-22(s0)
c00188bc:	fea44783          	lbu	a5,-22(s0)
c00188c0:	ffe7f793          	andi	a5,a5,-2
c00188c4:	fef40523          	sb	a5,-22(s0)
c00188c8:	fdc42783          	lw	a5,-36(s0)
c00188cc:	00c7a783          	lw	a5,12(a5)
c00188d0:	10878793          	addi	a5,a5,264
c00188d4:	fea44703          	lbu	a4,-22(s0)
c00188d8:	00070593          	mv	a1,a4
c00188dc:	00078513          	mv	a0,a5
c00188e0:	de1ff0ef          	jal	ra,c00186c0 <Xil_Out32>
	}
	/*
	 * Set the transmit address state to indicate the address has been sent
	 * for communication with event driven processing.
	 */
	InstancePtr->TxAddrMode = XIIC_TX_ADDR_SENT;
c00188e4:	fdc42783          	lw	a5,-36(s0)
c00188e8:	02078623          	sb	zero,44(a5)

	/*
	 * Fill remaining available FIFO with message data.
	 */
	if (InstancePtr->SendByteCount > 1) {
c00188ec:	fdc42783          	lw	a5,-36(s0)
c00188f0:	0307a703          	lw	a4,48(a5)
c00188f4:	00100793          	li	a5,1
c00188f8:	00e7d863          	bge	a5,a4,c0018908 <XIic_MasterSend+0x210>
		XIic_TransmitFifoFill(InstancePtr, XIIC_MASTER_ROLE);
c00188fc:	00100593          	li	a1,1
c0018900:	fdc42503          	lw	a0,-36(s0)
c0018904:	294010ef          	jal	ra,c0019b98 <XIic_TransmitFifoFill>

	/*
	 * After filling fifo, if data yet to send > 1, enable Tx  empty
	 * interrupt.
	 */
	if (InstancePtr->SendByteCount > 1) {
c0018908:	fdc42783          	lw	a5,-36(s0)
c001890c:	0307a703          	lw	a4,48(a5)
c0018910:	00100793          	li	a5,1
c0018914:	06e7d663          	bge	a5,a4,c0018980 <XIic_MasterSend+0x288>
		XIic_ClearEnableIntr(InstancePtr->BaseAddress,
c0018918:	fdc42783          	lw	a5,-36(s0)
c001891c:	00c7a783          	lw	a5,12(a5)
c0018920:	02078493          	addi	s1,a5,32
c0018924:	fdc42783          	lw	a5,-36(s0)
c0018928:	00c7a783          	lw	a5,12(a5)
c001892c:	02078793          	addi	a5,a5,32
c0018930:	00078513          	mv	a0,a5
c0018934:	d65ff0ef          	jal	ra,c0018698 <Xil_In32>
c0018938:	00050793          	mv	a5,a0
c001893c:	0807f793          	andi	a5,a5,128
c0018940:	00078593          	mv	a1,a5
c0018944:	00048513          	mv	a0,s1
c0018948:	d79ff0ef          	jal	ra,c00186c0 <Xil_Out32>
c001894c:	fdc42783          	lw	a5,-36(s0)
c0018950:	00c7a783          	lw	a5,12(a5)
c0018954:	02878493          	addi	s1,a5,40
c0018958:	fdc42783          	lw	a5,-36(s0)
c001895c:	00c7a783          	lw	a5,12(a5)
c0018960:	02878793          	addi	a5,a5,40
c0018964:	00078513          	mv	a0,a5
c0018968:	d31ff0ef          	jal	ra,c0018698 <Xil_In32>
c001896c:	00050793          	mv	a5,a0
c0018970:	0807e793          	ori	a5,a5,128
c0018974:	00078593          	mv	a1,a5
c0018978:	00048513          	mv	a0,s1
c001897c:	d45ff0ef          	jal	ra,c00186c0 <Xil_Out32>
	}

	/*
	 * Clear any pending Tx empty, Tx Error and then enable them.
	 */
	XIic_ClearEnableIntr(InstancePtr->BaseAddress,
c0018980:	fdc42783          	lw	a5,-36(s0)
c0018984:	00c7a783          	lw	a5,12(a5)
c0018988:	02078493          	addi	s1,a5,32
c001898c:	fdc42783          	lw	a5,-36(s0)
c0018990:	00c7a783          	lw	a5,12(a5)
c0018994:	02078793          	addi	a5,a5,32
c0018998:	00078513          	mv	a0,a5
c001899c:	cfdff0ef          	jal	ra,c0018698 <Xil_In32>
c00189a0:	00050793          	mv	a5,a0
c00189a4:	0067f793          	andi	a5,a5,6
c00189a8:	00078593          	mv	a1,a5
c00189ac:	00048513          	mv	a0,s1
c00189b0:	d11ff0ef          	jal	ra,c00186c0 <Xil_Out32>
c00189b4:	fdc42783          	lw	a5,-36(s0)
c00189b8:	00c7a783          	lw	a5,12(a5)
c00189bc:	02878493          	addi	s1,a5,40
c00189c0:	fdc42783          	lw	a5,-36(s0)
c00189c4:	00c7a783          	lw	a5,12(a5)
c00189c8:	02878793          	addi	a5,a5,40
c00189cc:	00078513          	mv	a0,a5
c00189d0:	cc9ff0ef          	jal	ra,c0018698 <Xil_In32>
c00189d4:	00050793          	mv	a5,a0
c00189d8:	0067e793          	ori	a5,a5,6
c00189dc:	00078593          	mv	a1,a5
c00189e0:	00048513          	mv	a0,s1
c00189e4:	cddff0ef          	jal	ra,c00186c0 <Xil_Out32>

	/*
	 * When repeated start not used, MSMS must be set after putting data
	 * into transmit FIFO, start the transmitter.
	 */
	CntlReg = XIic_ReadReg(InstancePtr->BaseAddress, XIIC_CR_REG_OFFSET);
c00189e8:	fdc42783          	lw	a5,-36(s0)
c00189ec:	00c7a783          	lw	a5,12(a5)
c00189f0:	10078793          	addi	a5,a5,256
c00189f4:	00078513          	mv	a0,a5
c00189f8:	ca1ff0ef          	jal	ra,c0018698 <Xil_In32>
c00189fc:	fea42623          	sw	a0,-20(s0)
	if ((CntlReg & XIIC_CR_MSMS_MASK) == 0) {
c0018a00:	fec42783          	lw	a5,-20(s0)
c0018a04:	0047f793          	andi	a5,a5,4
c0018a08:	02079a63          	bnez	a5,c0018a3c <XIic_MasterSend+0x344>
		CntlReg &= ~XIIC_CR_NO_ACK_MASK;
c0018a0c:	fec42783          	lw	a5,-20(s0)
c0018a10:	fef7f793          	andi	a5,a5,-17
c0018a14:	fef42623          	sw	a5,-20(s0)
		CntlReg |= XIIC_CR_MSMS_MASK | XIIC_CR_DIR_IS_TX_MASK;
c0018a18:	fec42783          	lw	a5,-20(s0)
c0018a1c:	00c7e793          	ori	a5,a5,12
c0018a20:	fef42623          	sw	a5,-20(s0)
		XIic_WriteReg(InstancePtr->BaseAddress, XIIC_CR_REG_OFFSET,
c0018a24:	fdc42783          	lw	a5,-36(s0)
c0018a28:	00c7a783          	lw	a5,12(a5)
c0018a2c:	10078793          	addi	a5,a5,256
c0018a30:	fec42583          	lw	a1,-20(s0)
c0018a34:	00078513          	mv	a0,a5
c0018a38:	c89ff0ef          	jal	ra,c00186c0 <Xil_Out32>
			 CntlReg);
	}

	XIic_IntrGlobalEnable(InstancePtr->BaseAddress);
c0018a3c:	fdc42783          	lw	a5,-36(s0)
c0018a40:	00c7a783          	lw	a5,12(a5)
c0018a44:	01c78793          	addi	a5,a5,28
c0018a48:	800005b7          	lui	a1,0x80000
c0018a4c:	00078513          	mv	a0,a5
c0018a50:	c71ff0ef          	jal	ra,c00186c0 <Xil_Out32>

	return XST_SUCCESS;
c0018a54:	00000793          	li	a5,0
}
c0018a58:	00078513          	mv	a0,a5
c0018a5c:	02c12083          	lw	ra,44(sp)
c0018a60:	02812403          	lw	s0,40(sp)
c0018a64:	02412483          	lw	s1,36(sp)
c0018a68:	03010113          	addi	sp,sp,48
c0018a6c:	00008067          	ret

c0018a70 <XIic_MasterRecv>:
* data it is also necessary to not receive the last byte with the prior bytes
* because the acknowledge must be setup before the last byte is received.
*
******************************************************************************/
int XIic_MasterRecv(XIic *InstancePtr, u8 *RxMsgPtr, int ByteCount)
{
c0018a70:	fd010113          	addi	sp,sp,-48
c0018a74:	02112623          	sw	ra,44(sp)
c0018a78:	02812423          	sw	s0,40(sp)
c0018a7c:	02912223          	sw	s1,36(sp)
c0018a80:	03010413          	addi	s0,sp,48
c0018a84:	fca42e23          	sw	a0,-36(s0)
c0018a88:	fcb42c23          	sw	a1,-40(s0)
c0018a8c:	fcc42a23          	sw	a2,-44(s0)

	/*
	 * If the slave address is zero (general call) the master can't perform
	 * receive operations, indicate an error.
	 */
	if (InstancePtr->AddrOfSlave == 0) {
c0018a90:	fdc42783          	lw	a5,-36(s0)
c0018a94:	01c7a783          	lw	a5,28(a5)
c0018a98:	00079663          	bnez	a5,c0018aa4 <XIic_MasterRecv+0x34>
		return XST_IIC_GENERAL_CALL_ADDRESS;
c0018a9c:	43600793          	li	a5,1078
c0018aa0:	4580006f          	j	c0018ef8 <XIic_MasterRecv+0x488>
	}

	XIic_IntrGlobalDisable(InstancePtr->BaseAddress);
c0018aa4:	fdc42783          	lw	a5,-36(s0)
c0018aa8:	00c7a783          	lw	a5,12(a5)
c0018aac:	01c78793          	addi	a5,a5,28
c0018ab0:	00000593          	li	a1,0
c0018ab4:	00078513          	mv	a0,a5
c0018ab8:	c09ff0ef          	jal	ra,c00186c0 <Xil_Out32>

	/*
	 * Ensure that the master processing has been included such that events
	 * will be properly handled.
	 */
	XIIC_MASTER_INCLUDE;
c0018abc:	07fea797          	auipc	a5,0x7fea
c0018ac0:	eb478793          	addi	a5,a5,-332 # c8002970 <XIic_RecvMasterFuncPtr>
c0018ac4:	00001717          	auipc	a4,0x1
c0018ac8:	96c70713          	addi	a4,a4,-1684 # c0019430 <RecvMasterData>
c0018acc:	00e7a023          	sw	a4,0(a5)
c0018ad0:	07fea797          	auipc	a5,0x7fea
c0018ad4:	ea478793          	addi	a5,a5,-348 # c8002974 <XIic_SendMasterFuncPtr>
c0018ad8:	00000717          	auipc	a4,0x0
c0018adc:	67470713          	addi	a4,a4,1652 # c001914c <SendMasterData>
c0018ae0:	00e7a023          	sw	a4,0(a5)
	InstancePtr->IsDynamic = FALSE;
c0018ae4:	fdc42783          	lw	a5,-36(s0)
c0018ae8:	0407ac23          	sw	zero,88(a5)

	/*
	 * If the busy is busy, then exit the critical region and wait for the
	 * bus to not be busy, the function enables the bus not busy interrupt.
	 */
	if (IsBusBusy(InstancePtr)) {
c0018aec:	fdc42503          	lw	a0,-36(s0)
c0018af0:	420000ef          	jal	ra,c0018f10 <IsBusBusy>
c0018af4:	00050793          	mv	a5,a0
c0018af8:	02078263          	beqz	a5,c0018b1c <XIic_MasterRecv+0xac>
		XIic_IntrGlobalEnable(InstancePtr->BaseAddress);
c0018afc:	fdc42783          	lw	a5,-36(s0)
c0018b00:	00c7a783          	lw	a5,12(a5)
c0018b04:	01c78793          	addi	a5,a5,28
c0018b08:	800005b7          	lui	a1,0x80000
c0018b0c:	00078513          	mv	a0,a5
c0018b10:	bb1ff0ef          	jal	ra,c00186c0 <Xil_Out32>

		return XST_IIC_BUS_BUSY;
c0018b14:	43500793          	li	a5,1077
c0018b18:	3e00006f          	j	c0018ef8 <XIic_MasterRecv+0x488>
	}

	/*
	 * Save message state for event driven processing.
	 */
	InstancePtr->RecvByteCount = ByteCount;
c0018b1c:	fdc42783          	lw	a5,-36(s0)
c0018b20:	fd442703          	lw	a4,-44(s0)
c0018b24:	02e7aa23          	sw	a4,52(a5)
	InstancePtr->RecvBufferPtr = RxMsgPtr;
c0018b28:	fdc42783          	lw	a5,-36(s0)
c0018b2c:	fd842703          	lw	a4,-40(s0)
c0018b30:	02e7a423          	sw	a4,40(a5)
	InstancePtr->SendBufferPtr = NULL;
c0018b34:	fdc42783          	lw	a5,-36(s0)
c0018b38:	0207a223          	sw	zero,36(a5)
	/*
	 * Clear and enable Rx full interrupt if using 7 bit, If 10 bit, wait
	 * until last address byte sent incase arbitration gets lost while
	 * sending out address.
	 */
	if ((InstancePtr->Options & XII_SEND_10_BIT_OPTION) == 0) {
c0018b3c:	fdc42783          	lw	a5,-36(s0)
c0018b40:	0207a783          	lw	a5,32(a5)
c0018b44:	0047f793          	andi	a5,a5,4
c0018b48:	06079663          	bnez	a5,c0018bb4 <XIic_MasterRecv+0x144>
		XIic_ClearEnableIntr(InstancePtr->BaseAddress,
c0018b4c:	fdc42783          	lw	a5,-36(s0)
c0018b50:	00c7a783          	lw	a5,12(a5)
c0018b54:	02078493          	addi	s1,a5,32
c0018b58:	fdc42783          	lw	a5,-36(s0)
c0018b5c:	00c7a783          	lw	a5,12(a5)
c0018b60:	02078793          	addi	a5,a5,32
c0018b64:	00078513          	mv	a0,a5
c0018b68:	b31ff0ef          	jal	ra,c0018698 <Xil_In32>
c0018b6c:	00050793          	mv	a5,a0
c0018b70:	0087f793          	andi	a5,a5,8
c0018b74:	00078593          	mv	a1,a5
c0018b78:	00048513          	mv	a0,s1
c0018b7c:	b45ff0ef          	jal	ra,c00186c0 <Xil_Out32>
c0018b80:	fdc42783          	lw	a5,-36(s0)
c0018b84:	00c7a783          	lw	a5,12(a5)
c0018b88:	02878493          	addi	s1,a5,40
c0018b8c:	fdc42783          	lw	a5,-36(s0)
c0018b90:	00c7a783          	lw	a5,12(a5)
c0018b94:	02878793          	addi	a5,a5,40
c0018b98:	00078513          	mv	a0,a5
c0018b9c:	afdff0ef          	jal	ra,c0018698 <Xil_In32>
c0018ba0:	00050793          	mv	a5,a0
c0018ba4:	0087e793          	ori	a5,a5,8
c0018ba8:	00078593          	mv	a1,a5
c0018bac:	00048513          	mv	a0,s1
c0018bb0:	b11ff0ef          	jal	ra,c00186c0 <Xil_Out32>
	 * routine to Tx which is throttling bus because during Rxing, Tx reg is
	 * empty = throttle. CR needs setting before putting data or the address
	 * written will go out as Tx instead of receive. Start Master Rx by
	 * setting CR Bits MSMS to Master and msg direction.
	 */
	CntlReg = XIic_ReadReg(InstancePtr->BaseAddress, XIIC_CR_REG_OFFSET);
c0018bb4:	fdc42783          	lw	a5,-36(s0)
c0018bb8:	00c7a783          	lw	a5,12(a5)
c0018bbc:	10078793          	addi	a5,a5,256
c0018bc0:	00078513          	mv	a0,a5
c0018bc4:	ad5ff0ef          	jal	ra,c0018698 <Xil_In32>
c0018bc8:	fea42623          	sw	a0,-20(s0)

	if (CntlReg & XIIC_CR_MSMS_MASK) {
c0018bcc:	fec42783          	lw	a5,-20(s0)
c0018bd0:	0047f793          	andi	a5,a5,4
c0018bd4:	08078263          	beqz	a5,c0018c58 <XIic_MasterRecv+0x1e8>
		CntlReg |= XIIC_CR_REPEATED_START_MASK;
c0018bd8:	fec42783          	lw	a5,-20(s0)
c0018bdc:	0207e793          	ori	a5,a5,32
c0018be0:	fef42623          	sw	a5,-20(s0)
		XIic_SetControlRegister(InstancePtr, CntlReg, ByteCount);
c0018be4:	fec42783          	lw	a5,-20(s0)
c0018be8:	fe77f793          	andi	a5,a5,-25
c0018bec:	fef42623          	sw	a5,-20(s0)
c0018bf0:	fdc42783          	lw	a5,-36(s0)
c0018bf4:	0207a783          	lw	a5,32(a5)
c0018bf8:	0047f793          	andi	a5,a5,4
c0018bfc:	00078a63          	beqz	a5,c0018c10 <XIic_MasterRecv+0x1a0>
c0018c00:	fec42783          	lw	a5,-20(s0)
c0018c04:	0087e793          	ori	a5,a5,8
c0018c08:	fef42623          	sw	a5,-20(s0)
c0018c0c:	01c0006f          	j	c0018c28 <XIic_MasterRecv+0x1b8>
c0018c10:	fd442703          	lw	a4,-44(s0)
c0018c14:	00100793          	li	a5,1
c0018c18:	00f71863          	bne	a4,a5,c0018c28 <XIic_MasterRecv+0x1b8>
c0018c1c:	fec42783          	lw	a5,-20(s0)
c0018c20:	0107e793          	ori	a5,a5,16
c0018c24:	fef42623          	sw	a5,-20(s0)

		InstancePtr->Stats.RepeatedStarts++;
c0018c28:	fdc42783          	lw	a5,-36(s0)
c0018c2c:	0017c783          	lbu	a5,1(a5)
c0018c30:	00178793          	addi	a5,a5,1
c0018c34:	0ff7f713          	andi	a4,a5,255
c0018c38:	fdc42783          	lw	a5,-36(s0)
c0018c3c:	00e780a3          	sb	a4,1(a5)
		XIic_WriteReg(InstancePtr->BaseAddress, XIIC_CR_REG_OFFSET,
c0018c40:	fdc42783          	lw	a5,-36(s0)
c0018c44:	00c7a783          	lw	a5,12(a5)
c0018c48:	10078793          	addi	a5,a5,256
c0018c4c:	fec42583          	lw	a1,-20(s0)
c0018c50:	00078513          	mv	a0,a5
c0018c54:	a6dff0ef          	jal	ra,c00186c0 <Xil_Out32>
	 * Set receive FIFO occupancy depth which must be done prior to writing
	 * the address in the FIFO because the transmitter will immediatedly
	 * start when in repeated start mode followed by the receiver such that
	 * the number of  bytes to receive should be set 1st.
	 */
	if (ByteCount == 1) {
c0018c58:	fd442703          	lw	a4,-44(s0)
c0018c5c:	00100793          	li	a5,1
c0018c60:	00f71663          	bne	a4,a5,c0018c6c <XIic_MasterRecv+0x1fc>
		Temp = 0;
c0018c64:	fe0405a3          	sb	zero,-21(s0)
c0018c68:	02c0006f          	j	c0018c94 <XIic_MasterRecv+0x224>
	} else {
		if (ByteCount <= IIC_RX_FIFO_DEPTH) {
c0018c6c:	fd442703          	lw	a4,-44(s0)
c0018c70:	01000793          	li	a5,16
c0018c74:	00e7cc63          	blt	a5,a4,c0018c8c <XIic_MasterRecv+0x21c>
			Temp = ByteCount - 2;
c0018c78:	fd442783          	lw	a5,-44(s0)
c0018c7c:	0ff7f793          	andi	a5,a5,255
c0018c80:	ffe78793          	addi	a5,a5,-2
c0018c84:	fef405a3          	sb	a5,-21(s0)
c0018c88:	00c0006f          	j	c0018c94 <XIic_MasterRecv+0x224>
		} else {
			Temp = IIC_RX_FIFO_DEPTH - 1;
c0018c8c:	00f00793          	li	a5,15
c0018c90:	fef405a3          	sb	a5,-21(s0)
		}
	}
	XIic_WriteReg(InstancePtr->BaseAddress, XIIC_RFD_REG_OFFSET,
c0018c94:	fdc42783          	lw	a5,-36(s0)
c0018c98:	00c7a783          	lw	a5,12(a5)
c0018c9c:	12078793          	addi	a5,a5,288
c0018ca0:	feb44703          	lbu	a4,-21(s0)
c0018ca4:	00070593          	mv	a1,a4
c0018ca8:	00078513          	mv	a0,a5
c0018cac:	a15ff0ef          	jal	ra,c00186c0 <Xil_Out32>
			(u32) Temp);

	if (InstancePtr->Options & XII_SEND_10_BIT_OPTION) {
c0018cb0:	fdc42783          	lw	a5,-36(s0)
c0018cb4:	0207a783          	lw	a5,32(a5)
c0018cb8:	0047f793          	andi	a5,a5,4
c0018cbc:	0e078463          	beqz	a5,c0018da4 <XIic_MasterRecv+0x334>
		/*
		 * Send the 1st and 2nd byte of the 10 bit address of a write
		 * operation, write because it's a 10 bit address.
		 */
		XIic_Send10BitAddrByte1(InstancePtr->AddrOfSlave,
c0018cc0:	fdc42783          	lw	a5,-36(s0)
c0018cc4:	01c7a783          	lw	a5,28(a5)
c0018cc8:	4077d793          	srai	a5,a5,0x7
c0018ccc:	fef404a3          	sb	a5,-23(s0)
c0018cd0:	fe940783          	lb	a5,-23(s0)
c0018cd4:	0067f793          	andi	a5,a5,6
c0018cd8:	01879793          	slli	a5,a5,0x18
c0018cdc:	4187d793          	srai	a5,a5,0x18
c0018ce0:	ff07e793          	ori	a5,a5,-16
c0018ce4:	01879793          	slli	a5,a5,0x18
c0018ce8:	4187d793          	srai	a5,a5,0x18
c0018cec:	fef404a3          	sb	a5,-23(s0)
c0018cf0:	fdc42783          	lw	a5,-36(s0)
c0018cf4:	00c7a783          	lw	a5,12(a5)
c0018cf8:	10878793          	addi	a5,a5,264
c0018cfc:	fe944703          	lbu	a4,-23(s0)
c0018d00:	00070593          	mv	a1,a4
c0018d04:	00078513          	mv	a0,a5
c0018d08:	9b9ff0ef          	jal	ra,c00186c0 <Xil_Out32>
					 XIIC_WRITE_OPERATION);
		XIic_Send10BitAddrByte2(InstancePtr->AddrOfSlave);
c0018d0c:	fdc42783          	lw	a5,-36(s0)
c0018d10:	00c7a783          	lw	a5,12(a5)
c0018d14:	10878713          	addi	a4,a5,264
c0018d18:	fdc42783          	lw	a5,-36(s0)
c0018d1c:	01c7a783          	lw	a5,28(a5)
c0018d20:	00078593          	mv	a1,a5
c0018d24:	00070513          	mv	a0,a4
c0018d28:	999ff0ef          	jal	ra,c00186c0 <Xil_Out32>

		/*
		 * Set flag to indicate the next byte of the address needs to be
		 * send, clear and enable Tx empty interrupt.
		 */
		InstancePtr->TxAddrMode = XIIC_TX_ADDR_MSTR_RECV_MASK;
c0018d2c:	fdc42783          	lw	a5,-36(s0)
c0018d30:	00200713          	li	a4,2
c0018d34:	02e78623          	sb	a4,44(a5)
		XIic_ClearEnableIntr(InstancePtr->BaseAddress,
c0018d38:	fdc42783          	lw	a5,-36(s0)
c0018d3c:	00c7a783          	lw	a5,12(a5)
c0018d40:	02078493          	addi	s1,a5,32
c0018d44:	fdc42783          	lw	a5,-36(s0)
c0018d48:	00c7a783          	lw	a5,12(a5)
c0018d4c:	02078793          	addi	a5,a5,32
c0018d50:	00078513          	mv	a0,a5
c0018d54:	945ff0ef          	jal	ra,c0018698 <Xil_In32>
c0018d58:	00050793          	mv	a5,a0
c0018d5c:	0047f793          	andi	a5,a5,4
c0018d60:	00078593          	mv	a1,a5
c0018d64:	00048513          	mv	a0,s1
c0018d68:	959ff0ef          	jal	ra,c00186c0 <Xil_Out32>
c0018d6c:	fdc42783          	lw	a5,-36(s0)
c0018d70:	00c7a783          	lw	a5,12(a5)
c0018d74:	02878493          	addi	s1,a5,40
c0018d78:	fdc42783          	lw	a5,-36(s0)
c0018d7c:	00c7a783          	lw	a5,12(a5)
c0018d80:	02878793          	addi	a5,a5,40
c0018d84:	00078513          	mv	a0,a5
c0018d88:	911ff0ef          	jal	ra,c0018698 <Xil_In32>
c0018d8c:	00050793          	mv	a5,a0
c0018d90:	0047e793          	ori	a5,a5,4
c0018d94:	00078593          	mv	a1,a5
c0018d98:	00048513          	mv	a0,s1
c0018d9c:	925ff0ef          	jal	ra,c00186c0 <Xil_Out32>
c0018da0:	0480006f          	j	c0018de8 <XIic_MasterRecv+0x378>
	} else {
		/*
		 * 7 bit slave address, send the address for a read operation
		 * and set the state to indicate the address has been sent.
		 */
		XIic_Send7BitAddr(InstancePtr->AddrOfSlave,
c0018da4:	fdc42783          	lw	a5,-36(s0)
c0018da8:	01c7a783          	lw	a5,28(a5)
c0018dac:	0ff7f793          	andi	a5,a5,255
c0018db0:	00179793          	slli	a5,a5,0x1
c0018db4:	fef40523          	sb	a5,-22(s0)
c0018db8:	fea44783          	lbu	a5,-22(s0)
c0018dbc:	0017e793          	ori	a5,a5,1
c0018dc0:	fef40523          	sb	a5,-22(s0)
c0018dc4:	fdc42783          	lw	a5,-36(s0)
c0018dc8:	00c7a783          	lw	a5,12(a5)
c0018dcc:	10878793          	addi	a5,a5,264
c0018dd0:	fea44703          	lbu	a4,-22(s0)
c0018dd4:	00070593          	mv	a1,a4
c0018dd8:	00078513          	mv	a0,a5
c0018ddc:	8e5ff0ef          	jal	ra,c00186c0 <Xil_Out32>
				   XIIC_READ_OPERATION);
		InstancePtr->TxAddrMode = XIIC_TX_ADDR_SENT;
c0018de0:	fdc42783          	lw	a5,-36(s0)
c0018de4:	02078623          	sb	zero,44(a5)
	 * address goes out therefore Tx error must not be enabled as it will
	 * go off immediately and the Rx full interrupt will be checked.
	 * If full, then the one byte was received and the Tx error will be
	 * disabled without sending an error callback msg.
	 */
	XIic_ClearEnableIntr(InstancePtr->BaseAddress,
c0018de8:	fdc42783          	lw	a5,-36(s0)
c0018dec:	00c7a783          	lw	a5,12(a5)
c0018df0:	02078493          	addi	s1,a5,32
c0018df4:	fdc42783          	lw	a5,-36(s0)
c0018df8:	00c7a783          	lw	a5,12(a5)
c0018dfc:	02078793          	addi	a5,a5,32
c0018e00:	00078513          	mv	a0,a5
c0018e04:	895ff0ef          	jal	ra,c0018698 <Xil_In32>
c0018e08:	00050793          	mv	a5,a0
c0018e0c:	0027f793          	andi	a5,a5,2
c0018e10:	00078593          	mv	a1,a5
c0018e14:	00048513          	mv	a0,s1
c0018e18:	8a9ff0ef          	jal	ra,c00186c0 <Xil_Out32>
c0018e1c:	fdc42783          	lw	a5,-36(s0)
c0018e20:	00c7a783          	lw	a5,12(a5)
c0018e24:	02878493          	addi	s1,a5,40
c0018e28:	fdc42783          	lw	a5,-36(s0)
c0018e2c:	00c7a783          	lw	a5,12(a5)
c0018e30:	02878793          	addi	a5,a5,40
c0018e34:	00078513          	mv	a0,a5
c0018e38:	861ff0ef          	jal	ra,c0018698 <Xil_In32>
c0018e3c:	00050793          	mv	a5,a0
c0018e40:	0027e793          	ori	a5,a5,2
c0018e44:	00078593          	mv	a1,a5
c0018e48:	00048513          	mv	a0,s1
c0018e4c:	875ff0ef          	jal	ra,c00186c0 <Xil_Out32>
	/*
	 * When repeated start not used, MSMS gets set after putting data
	 * in Tx reg. Start Master Rx by setting CR Bits MSMS to Master and
	 * msg direction.
	 */
	CntlReg = XIic_ReadReg(InstancePtr->BaseAddress, XIIC_CR_REG_OFFSET);
c0018e50:	fdc42783          	lw	a5,-36(s0)
c0018e54:	00c7a783          	lw	a5,12(a5)
c0018e58:	10078793          	addi	a5,a5,256
c0018e5c:	00078513          	mv	a0,a5
c0018e60:	839ff0ef          	jal	ra,c0018698 <Xil_In32>
c0018e64:	fea42623          	sw	a0,-20(s0)
	if ((CntlReg & XIIC_CR_MSMS_MASK) == 0) {
c0018e68:	fec42783          	lw	a5,-20(s0)
c0018e6c:	0047f793          	andi	a5,a5,4
c0018e70:	06079663          	bnez	a5,c0018edc <XIic_MasterRecv+0x46c>
		CntlReg |= XIIC_CR_MSMS_MASK;
c0018e74:	fec42783          	lw	a5,-20(s0)
c0018e78:	0047e793          	ori	a5,a5,4
c0018e7c:	fef42623          	sw	a5,-20(s0)
		XIic_SetControlRegister(InstancePtr, CntlReg, ByteCount);
c0018e80:	fec42783          	lw	a5,-20(s0)
c0018e84:	fe77f793          	andi	a5,a5,-25
c0018e88:	fef42623          	sw	a5,-20(s0)
c0018e8c:	fdc42783          	lw	a5,-36(s0)
c0018e90:	0207a783          	lw	a5,32(a5)
c0018e94:	0047f793          	andi	a5,a5,4
c0018e98:	00078a63          	beqz	a5,c0018eac <XIic_MasterRecv+0x43c>
c0018e9c:	fec42783          	lw	a5,-20(s0)
c0018ea0:	0087e793          	ori	a5,a5,8
c0018ea4:	fef42623          	sw	a5,-20(s0)
c0018ea8:	01c0006f          	j	c0018ec4 <XIic_MasterRecv+0x454>
c0018eac:	fd442703          	lw	a4,-44(s0)
c0018eb0:	00100793          	li	a5,1
c0018eb4:	00f71863          	bne	a4,a5,c0018ec4 <XIic_MasterRecv+0x454>
c0018eb8:	fec42783          	lw	a5,-20(s0)
c0018ebc:	0107e793          	ori	a5,a5,16
c0018ec0:	fef42623          	sw	a5,-20(s0)
		XIic_WriteReg(InstancePtr->BaseAddress, XIIC_CR_REG_OFFSET,
c0018ec4:	fdc42783          	lw	a5,-36(s0)
c0018ec8:	00c7a783          	lw	a5,12(a5)
c0018ecc:	10078793          	addi	a5,a5,256
c0018ed0:	fec42583          	lw	a1,-20(s0)
c0018ed4:	00078513          	mv	a0,a5
c0018ed8:	fe8ff0ef          	jal	ra,c00186c0 <Xil_Out32>
				CntlReg);
	}

	XIic_IntrGlobalEnable(InstancePtr->BaseAddress);
c0018edc:	fdc42783          	lw	a5,-36(s0)
c0018ee0:	00c7a783          	lw	a5,12(a5)
c0018ee4:	01c78793          	addi	a5,a5,28
c0018ee8:	800005b7          	lui	a1,0x80000
c0018eec:	00078513          	mv	a0,a5
c0018ef0:	fd0ff0ef          	jal	ra,c00186c0 <Xil_Out32>

	return XST_SUCCESS;
c0018ef4:	00000793          	li	a5,0
}
c0018ef8:	00078513          	mv	a0,a5
c0018efc:	02c12083          	lw	ra,44(sp)
c0018f00:	02812403          	lw	s0,40(sp)
c0018f04:	02412483          	lw	s1,36(sp)
c0018f08:	03010113          	addi	sp,sp,48
c0018f0c:	00008067          	ret

c0018f10 <IsBusBusy>:
*
* @note		None.
*
******************************************************************************/
static int IsBusBusy(XIic *InstancePtr)
{
c0018f10:	fd010113          	addi	sp,sp,-48
c0018f14:	02112623          	sw	ra,44(sp)
c0018f18:	02812423          	sw	s0,40(sp)
c0018f1c:	02912223          	sw	s1,36(sp)
c0018f20:	03010413          	addi	s0,sp,48
c0018f24:	fca42e23          	sw	a0,-36(s0)
	u32 CntlReg;
	u32 StatusReg;

	CntlReg = XIic_ReadReg(InstancePtr->BaseAddress, XIIC_CR_REG_OFFSET);
c0018f28:	fdc42783          	lw	a5,-36(s0)
c0018f2c:	00c7a783          	lw	a5,12(a5)
c0018f30:	10078793          	addi	a5,a5,256
c0018f34:	00078513          	mv	a0,a5
c0018f38:	f60ff0ef          	jal	ra,c0018698 <Xil_In32>
c0018f3c:	fea42623          	sw	a0,-20(s0)
	StatusReg = XIic_ReadReg(InstancePtr->BaseAddress, XIIC_SR_REG_OFFSET);
c0018f40:	fdc42783          	lw	a5,-36(s0)
c0018f44:	00c7a783          	lw	a5,12(a5)
c0018f48:	10478793          	addi	a5,a5,260
c0018f4c:	00078513          	mv	a0,a5
c0018f50:	f48ff0ef          	jal	ra,c0018698 <Xil_In32>
c0018f54:	fea42423          	sw	a0,-24(s0)
	/*
	 * If this device is already master of the bus as when using the
	 * repeated start and the bus is busy setup to wait for it to not be
	 * busy.
	 */
	if (((CntlReg & XIIC_CR_MSMS_MASK) == 0) &&	/* Not master */
c0018f58:	fec42783          	lw	a5,-20(s0)
c0018f5c:	0047f793          	andi	a5,a5,4
c0018f60:	0a079263          	bnez	a5,c0019004 <IsBusBusy+0xf4>
		(StatusReg & XIIC_SR_BUS_BUSY_MASK)) {	/* Is busy */
c0018f64:	fe842783          	lw	a5,-24(s0)
c0018f68:	0047f793          	andi	a5,a5,4
	if (((CntlReg & XIIC_CR_MSMS_MASK) == 0) &&	/* Not master */
c0018f6c:	08078c63          	beqz	a5,c0019004 <IsBusBusy+0xf4>
		/*
		 * The bus is busy, clear pending BNB interrupt incase
		 * previously set and then enable BusNotBusy interrupt.
		 */
		InstancePtr->BNBOnly = TRUE;
c0018f70:	fdc42783          	lw	a5,-36(s0)
c0018f74:	00100713          	li	a4,1
c0018f78:	02e7ac23          	sw	a4,56(a5)
		XIic_ClearEnableIntr(InstancePtr->BaseAddress,
c0018f7c:	fdc42783          	lw	a5,-36(s0)
c0018f80:	00c7a783          	lw	a5,12(a5)
c0018f84:	02078493          	addi	s1,a5,32
c0018f88:	fdc42783          	lw	a5,-36(s0)
c0018f8c:	00c7a783          	lw	a5,12(a5)
c0018f90:	02078793          	addi	a5,a5,32
c0018f94:	00078513          	mv	a0,a5
c0018f98:	f00ff0ef          	jal	ra,c0018698 <Xil_In32>
c0018f9c:	00050793          	mv	a5,a0
c0018fa0:	0107f793          	andi	a5,a5,16
c0018fa4:	00078593          	mv	a1,a5
c0018fa8:	00048513          	mv	a0,s1
c0018fac:	f14ff0ef          	jal	ra,c00186c0 <Xil_Out32>
c0018fb0:	fdc42783          	lw	a5,-36(s0)
c0018fb4:	00c7a783          	lw	a5,12(a5)
c0018fb8:	02878493          	addi	s1,a5,40
c0018fbc:	fdc42783          	lw	a5,-36(s0)
c0018fc0:	00c7a783          	lw	a5,12(a5)
c0018fc4:	02878793          	addi	a5,a5,40
c0018fc8:	00078513          	mv	a0,a5
c0018fcc:	eccff0ef          	jal	ra,c0018698 <Xil_In32>
c0018fd0:	00050793          	mv	a5,a0
c0018fd4:	0107e793          	ori	a5,a5,16
c0018fd8:	00078593          	mv	a1,a5
c0018fdc:	00048513          	mv	a0,s1
c0018fe0:	ee0ff0ef          	jal	ra,c00186c0 <Xil_Out32>
					XIIC_INTR_BNB_MASK);
		InstancePtr->Stats.BusBusy++;
c0018fe4:	fdc42783          	lw	a5,-36(s0)
c0018fe8:	0027c783          	lbu	a5,2(a5)
c0018fec:	00178793          	addi	a5,a5,1
c0018ff0:	0ff7f713          	andi	a4,a5,255
c0018ff4:	fdc42783          	lw	a5,-36(s0)
c0018ff8:	00e78123          	sb	a4,2(a5)

		return TRUE;
c0018ffc:	00100793          	li	a5,1
c0019000:	0080006f          	j	c0019008 <IsBusBusy+0xf8>
	}

	return FALSE;
c0019004:	00000793          	li	a5,0
}
c0019008:	00078513          	mv	a0,a5
c001900c:	02c12083          	lw	ra,44(sp)
c0019010:	02812403          	lw	s0,40(sp)
c0019014:	02412483          	lw	s1,36(sp)
c0019018:	03010113          	addi	sp,sp,48
c001901c:	00008067          	ret

c0019020 <SendSlaveAddr>:
* This function does read/modify/write to the device control register. Calling
* functions must ensure critical sections are used.
*
******************************************************************************/
static void SendSlaveAddr(XIic *InstancePtr)
{
c0019020:	fd010113          	addi	sp,sp,-48
c0019024:	02112623          	sw	ra,44(sp)
c0019028:	02812423          	sw	s0,40(sp)
c001902c:	02912223          	sw	s1,36(sp)
c0019030:	03010413          	addi	s0,sp,48
c0019034:	fca42e23          	sw	a0,-36(s0)
	 * Set the control register for Master Receive, repeated start must be
	 * set before writing the address, MSMS should be already set, don't
	 * set here so if arbitration is lost or some other reason we don't
	 * want MSMS set incase of error.
	 */
	CRreg = XIic_ReadReg(InstancePtr->BaseAddress, XIIC_CR_REG_OFFSET);
c0019038:	fdc42783          	lw	a5,-36(s0)
c001903c:	00c7a783          	lw	a5,12(a5)
c0019040:	10078793          	addi	a5,a5,256
c0019044:	00078513          	mv	a0,a5
c0019048:	e50ff0ef          	jal	ra,c0018698 <Xil_In32>
c001904c:	fea42623          	sw	a0,-20(s0)

	CRreg |= XIIC_CR_REPEATED_START_MASK;
c0019050:	fec42783          	lw	a5,-20(s0)
c0019054:	0207e793          	ori	a5,a5,32
c0019058:	fef42623          	sw	a5,-20(s0)
	CRreg &= ~XIIC_CR_DIR_IS_TX_MASK;
c001905c:	fec42783          	lw	a5,-20(s0)
c0019060:	ff77f793          	andi	a5,a5,-9
c0019064:	fef42623          	sw	a5,-20(s0)

	XIic_WriteReg(InstancePtr->BaseAddress, XIIC_CR_REG_OFFSET, CRreg);
c0019068:	fdc42783          	lw	a5,-36(s0)
c001906c:	00c7a783          	lw	a5,12(a5)
c0019070:	10078793          	addi	a5,a5,256
c0019074:	fec42583          	lw	a1,-20(s0)
c0019078:	00078513          	mv	a0,a5
c001907c:	e44ff0ef          	jal	ra,c00186c0 <Xil_Out32>
	/*
	 * Send the 1st byte of the 10 bit address as a read operation, enable
	 * the receive interrupt to know when data is received, assuming that
	 * the receive FIFO threshold has been previously set.
	 */
	XIic_Send10BitAddrByte1(InstancePtr->AddrOfSlave, XIIC_READ_OPERATION);
c0019080:	fdc42783          	lw	a5,-36(s0)
c0019084:	01c7a783          	lw	a5,28(a5)
c0019088:	4077d793          	srai	a5,a5,0x7
c001908c:	fef405a3          	sb	a5,-21(s0)
c0019090:	feb40783          	lb	a5,-21(s0)
c0019094:	0067f793          	andi	a5,a5,6
c0019098:	01879793          	slli	a5,a5,0x18
c001909c:	4187d793          	srai	a5,a5,0x18
c00190a0:	ff17e793          	ori	a5,a5,-15
c00190a4:	01879793          	slli	a5,a5,0x18
c00190a8:	4187d793          	srai	a5,a5,0x18
c00190ac:	fef405a3          	sb	a5,-21(s0)
c00190b0:	fdc42783          	lw	a5,-36(s0)
c00190b4:	00c7a783          	lw	a5,12(a5)
c00190b8:	10878793          	addi	a5,a5,264
c00190bc:	feb44703          	lbu	a4,-21(s0)
c00190c0:	00070593          	mv	a1,a4
c00190c4:	00078513          	mv	a0,a5
c00190c8:	df8ff0ef          	jal	ra,c00186c0 <Xil_Out32>

	XIic_ClearEnableIntr(InstancePtr->BaseAddress, XIIC_INTR_RX_FULL_MASK);
c00190cc:	fdc42783          	lw	a5,-36(s0)
c00190d0:	00c7a783          	lw	a5,12(a5)
c00190d4:	02078493          	addi	s1,a5,32
c00190d8:	fdc42783          	lw	a5,-36(s0)
c00190dc:	00c7a783          	lw	a5,12(a5)
c00190e0:	02078793          	addi	a5,a5,32
c00190e4:	00078513          	mv	a0,a5
c00190e8:	db0ff0ef          	jal	ra,c0018698 <Xil_In32>
c00190ec:	00050793          	mv	a5,a0
c00190f0:	0087f793          	andi	a5,a5,8
c00190f4:	00078593          	mv	a1,a5
c00190f8:	00048513          	mv	a0,s1
c00190fc:	dc4ff0ef          	jal	ra,c00186c0 <Xil_Out32>
c0019100:	fdc42783          	lw	a5,-36(s0)
c0019104:	00c7a783          	lw	a5,12(a5)
c0019108:	02878493          	addi	s1,a5,40
c001910c:	fdc42783          	lw	a5,-36(s0)
c0019110:	00c7a783          	lw	a5,12(a5)
c0019114:	02878793          	addi	a5,a5,40
c0019118:	00078513          	mv	a0,a5
c001911c:	d7cff0ef          	jal	ra,c0018698 <Xil_In32>
c0019120:	00050793          	mv	a5,a0
c0019124:	0087e793          	ori	a5,a5,8
c0019128:	00078593          	mv	a1,a5
c001912c:	00048513          	mv	a0,s1
c0019130:	d90ff0ef          	jal	ra,c00186c0 <Xil_Out32>
}
c0019134:	00000013          	nop
c0019138:	02c12083          	lw	ra,44(sp)
c001913c:	02812403          	lw	s0,40(sp)
c0019140:	02412483          	lw	s1,36(sp)
c0019144:	03010113          	addi	sp,sp,48
c0019148:	00008067          	ret

c001914c <SendMasterData>:
*
* @note		None.
*
******************************************************************************/
static void SendMasterData(XIic *InstancePtr)
{
c001914c:	fd010113          	addi	sp,sp,-48
c0019150:	02112623          	sw	ra,44(sp)
c0019154:	02812423          	sw	s0,40(sp)
c0019158:	02912223          	sw	s1,36(sp)
c001915c:	03010413          	addi	s0,sp,48
c0019160:	fca42e23          	sw	a0,-36(s0)
	 * bytes to send when in master receive operation and the slave device
	 * is 10 bit addressed.
	 * This requires the lower 7 bits of address to be resent when the mode
	 * switches to Read instead of write (while sending addresses).
	 */
	if (InstancePtr->TxAddrMode & XIIC_TX_ADDR_MSTR_RECV_MASK) {
c0019164:	fdc42783          	lw	a5,-36(s0)
c0019168:	02c7c783          	lbu	a5,44(a5)
c001916c:	0027f793          	andi	a5,a5,2
c0019170:	00078c63          	beqz	a5,c0019188 <SendMasterData+0x3c>
		/*
		 * Send the 1st byte of the slave address in the read operation
		 * and change the state to indicate this has been done
		 */
		SendSlaveAddr(InstancePtr);
c0019174:	fdc42503          	lw	a0,-36(s0)
c0019178:	ea9ff0ef          	jal	ra,c0019020 <SendSlaveAddr>
		InstancePtr->TxAddrMode = XIIC_TX_ADDR_SENT;
c001917c:	fdc42783          	lw	a5,-36(s0)
c0019180:	02078623          	sb	zero,44(a5)
			InstancePtr->SendHandler(InstancePtr->SendCallBackRef,
						 0);
		}
	}

	return;
c0019184:	2940006f          	j	c0019418 <SendMasterData+0x2cc>
	else if (InstancePtr->SendByteCount > 1) {
c0019188:	fdc42783          	lw	a5,-36(s0)
c001918c:	0307a703          	lw	a4,48(a5)
c0019190:	00100793          	li	a5,1
c0019194:	04e7dc63          	bge	a5,a4,c00191ec <SendMasterData+0xa0>
		XIic_TransmitFifoFill(InstancePtr, XIIC_MASTER_ROLE);
c0019198:	00100593          	li	a1,1
c001919c:	fdc42503          	lw	a0,-36(s0)
c00191a0:	1f9000ef          	jal	ra,c0019b98 <XIic_TransmitFifoFill>
		if (InstancePtr->SendByteCount < 2) {
c00191a4:	fdc42783          	lw	a5,-36(s0)
c00191a8:	0307a703          	lw	a4,48(a5)
c00191ac:	00100793          	li	a5,1
c00191b0:	26e7c463          	blt	a5,a4,c0019418 <SendMasterData+0x2cc>
			XIic_DisableIntr(InstancePtr->BaseAddress,
c00191b4:	fdc42783          	lw	a5,-36(s0)
c00191b8:	00c7a783          	lw	a5,12(a5)
c00191bc:	02878493          	addi	s1,a5,40
c00191c0:	fdc42783          	lw	a5,-36(s0)
c00191c4:	00c7a783          	lw	a5,12(a5)
c00191c8:	02878793          	addi	a5,a5,40
c00191cc:	00078513          	mv	a0,a5
c00191d0:	cc8ff0ef          	jal	ra,c0018698 <Xil_In32>
c00191d4:	00050793          	mv	a5,a0
c00191d8:	f7f7f793          	andi	a5,a5,-129
c00191dc:	00078593          	mv	a1,a5
c00191e0:	00048513          	mv	a0,s1
c00191e4:	cdcff0ef          	jal	ra,c00186c0 <Xil_Out32>
	return;
c00191e8:	2300006f          	j	c0019418 <SendMasterData+0x2cc>
	else if (InstancePtr->SendByteCount == 1) {
c00191ec:	fdc42783          	lw	a5,-36(s0)
c00191f0:	0307a703          	lw	a4,48(a5)
c00191f4:	00100793          	li	a5,1
c00191f8:	18f71063          	bne	a4,a5,c0019378 <SendMasterData+0x22c>
		if (InstancePtr->Options & XII_REPEATED_START_OPTION) {
c00191fc:	fdc42783          	lw	a5,-36(s0)
c0019200:	0207a783          	lw	a5,32(a5)
c0019204:	0027f793          	andi	a5,a5,2
c0019208:	06078263          	beqz	a5,c001926c <SendMasterData+0x120>
			XIic_WriteSendByte(InstancePtr);
c001920c:	fdc42783          	lw	a5,-36(s0)
c0019210:	00c7a783          	lw	a5,12(a5)
c0019214:	10878613          	addi	a2,a5,264
c0019218:	fdc42783          	lw	a5,-36(s0)
c001921c:	0247a783          	lw	a5,36(a5)
c0019220:	00178693          	addi	a3,a5,1
c0019224:	fdc42703          	lw	a4,-36(s0)
c0019228:	02d72223          	sw	a3,36(a4)
c001922c:	0007c783          	lbu	a5,0(a5)
c0019230:	00078593          	mv	a1,a5
c0019234:	00060513          	mv	a0,a2
c0019238:	c88ff0ef          	jal	ra,c00186c0 <Xil_Out32>
c001923c:	fdc42783          	lw	a5,-36(s0)
c0019240:	0307a783          	lw	a5,48(a5)
c0019244:	fff78713          	addi	a4,a5,-1
c0019248:	fdc42783          	lw	a5,-36(s0)
c001924c:	02e7a823          	sw	a4,48(a5)
c0019250:	fdc42783          	lw	a5,-36(s0)
c0019254:	0057c783          	lbu	a5,5(a5)
c0019258:	00178793          	addi	a5,a5,1
c001925c:	0ff7f713          	andi	a4,a5,255
c0019260:	fdc42783          	lw	a5,-36(s0)
c0019264:	00e782a3          	sb	a4,5(a5)
	return;
c0019268:	1b00006f          	j	c0019418 <SendMasterData+0x2cc>
			CntlReg = XIic_ReadReg(InstancePtr->BaseAddress,
c001926c:	fdc42783          	lw	a5,-36(s0)
c0019270:	00c7a783          	lw	a5,12(a5)
c0019274:	10078793          	addi	a5,a5,256
c0019278:	00078513          	mv	a0,a5
c001927c:	c1cff0ef          	jal	ra,c0018698 <Xil_In32>
c0019280:	fea42623          	sw	a0,-20(s0)
			CntlReg &= ~XIIC_CR_MSMS_MASK;
c0019284:	fec42783          	lw	a5,-20(s0)
c0019288:	ffb7f793          	andi	a5,a5,-5
c001928c:	fef42623          	sw	a5,-20(s0)
			XIic_WriteReg(InstancePtr->BaseAddress,
c0019290:	fdc42783          	lw	a5,-36(s0)
c0019294:	00c7a783          	lw	a5,12(a5)
c0019298:	10078793          	addi	a5,a5,256
c001929c:	fec42583          	lw	a1,-20(s0)
c00192a0:	00078513          	mv	a0,a5
c00192a4:	c1cff0ef          	jal	ra,c00186c0 <Xil_Out32>
			XIic_WriteSendByte(InstancePtr);
c00192a8:	fdc42783          	lw	a5,-36(s0)
c00192ac:	00c7a783          	lw	a5,12(a5)
c00192b0:	10878613          	addi	a2,a5,264
c00192b4:	fdc42783          	lw	a5,-36(s0)
c00192b8:	0247a783          	lw	a5,36(a5)
c00192bc:	00178693          	addi	a3,a5,1
c00192c0:	fdc42703          	lw	a4,-36(s0)
c00192c4:	02d72223          	sw	a3,36(a4)
c00192c8:	0007c783          	lbu	a5,0(a5)
c00192cc:	00078593          	mv	a1,a5
c00192d0:	00060513          	mv	a0,a2
c00192d4:	becff0ef          	jal	ra,c00186c0 <Xil_Out32>
c00192d8:	fdc42783          	lw	a5,-36(s0)
c00192dc:	0307a783          	lw	a5,48(a5)
c00192e0:	fff78713          	addi	a4,a5,-1
c00192e4:	fdc42783          	lw	a5,-36(s0)
c00192e8:	02e7a823          	sw	a4,48(a5)
c00192ec:	fdc42783          	lw	a5,-36(s0)
c00192f0:	0057c783          	lbu	a5,5(a5)
c00192f4:	00178793          	addi	a5,a5,1
c00192f8:	0ff7f713          	andi	a4,a5,255
c00192fc:	fdc42783          	lw	a5,-36(s0)
c0019300:	00e782a3          	sb	a4,5(a5)
			InstancePtr->BNBOnly = FALSE;
c0019304:	fdc42783          	lw	a5,-36(s0)
c0019308:	0207ac23          	sw	zero,56(a5)
			XIic_DisableIntr(InstancePtr->BaseAddress,
c001930c:	fdc42783          	lw	a5,-36(s0)
c0019310:	00c7a783          	lw	a5,12(a5)
c0019314:	02878493          	addi	s1,a5,40
c0019318:	fdc42783          	lw	a5,-36(s0)
c001931c:	00c7a783          	lw	a5,12(a5)
c0019320:	02878793          	addi	a5,a5,40
c0019324:	00078513          	mv	a0,a5
c0019328:	b70ff0ef          	jal	ra,c0018698 <Xil_In32>
c001932c:	00050793          	mv	a5,a0
c0019330:	f797f793          	andi	a5,a5,-135
c0019334:	00078593          	mv	a1,a5
c0019338:	00048513          	mv	a0,s1
c001933c:	b84ff0ef          	jal	ra,c00186c0 <Xil_Out32>
			XIic_EnableIntr(InstancePtr->BaseAddress,
c0019340:	fdc42783          	lw	a5,-36(s0)
c0019344:	00c7a783          	lw	a5,12(a5)
c0019348:	02878493          	addi	s1,a5,40
c001934c:	fdc42783          	lw	a5,-36(s0)
c0019350:	00c7a783          	lw	a5,12(a5)
c0019354:	02878793          	addi	a5,a5,40
c0019358:	00078513          	mv	a0,a5
c001935c:	b3cff0ef          	jal	ra,c0018698 <Xil_In32>
c0019360:	00050793          	mv	a5,a0
c0019364:	0107e793          	ori	a5,a5,16
c0019368:	00078593          	mv	a1,a5
c001936c:	00048513          	mv	a0,s1
c0019370:	b50ff0ef          	jal	ra,c00186c0 <Xil_Out32>
	return;
c0019374:	0a40006f          	j	c0019418 <SendMasterData+0x2cc>
		if (InstancePtr->Options & XII_REPEATED_START_OPTION) {
c0019378:	fdc42783          	lw	a5,-36(s0)
c001937c:	0207a783          	lw	a5,32(a5)
c0019380:	0027f793          	andi	a5,a5,2
c0019384:	08078a63          	beqz	a5,c0019418 <SendMasterData+0x2cc>
			CntlReg = XIic_ReadReg(InstancePtr->BaseAddress,
c0019388:	fdc42783          	lw	a5,-36(s0)
c001938c:	00c7a783          	lw	a5,12(a5)
c0019390:	10078793          	addi	a5,a5,256
c0019394:	00078513          	mv	a0,a5
c0019398:	b00ff0ef          	jal	ra,c0018698 <Xil_In32>
c001939c:	fea42623          	sw	a0,-20(s0)
			CntlReg |= XIIC_CR_REPEATED_START_MASK;
c00193a0:	fec42783          	lw	a5,-20(s0)
c00193a4:	0207e793          	ori	a5,a5,32
c00193a8:	fef42623          	sw	a5,-20(s0)
			XIic_WriteReg(InstancePtr->BaseAddress,
c00193ac:	fdc42783          	lw	a5,-36(s0)
c00193b0:	00c7a783          	lw	a5,12(a5)
c00193b4:	10078793          	addi	a5,a5,256
c00193b8:	fec42583          	lw	a1,-20(s0)
c00193bc:	00078513          	mv	a0,a5
c00193c0:	b00ff0ef          	jal	ra,c00186c0 <Xil_Out32>
			XIic_DisableIntr(InstancePtr->BaseAddress,
c00193c4:	fdc42783          	lw	a5,-36(s0)
c00193c8:	00c7a783          	lw	a5,12(a5)
c00193cc:	02878493          	addi	s1,a5,40
c00193d0:	fdc42783          	lw	a5,-36(s0)
c00193d4:	00c7a783          	lw	a5,12(a5)
c00193d8:	02878793          	addi	a5,a5,40
c00193dc:	00078513          	mv	a0,a5
c00193e0:	ab8ff0ef          	jal	ra,c0018698 <Xil_In32>
c00193e4:	00050793          	mv	a5,a0
c00193e8:	f797f793          	andi	a5,a5,-135
c00193ec:	00078593          	mv	a1,a5
c00193f0:	00048513          	mv	a0,s1
c00193f4:	accff0ef          	jal	ra,c00186c0 <Xil_Out32>
			InstancePtr->SendHandler(InstancePtr->SendCallBackRef,
c00193f8:	fdc42783          	lw	a5,-36(s0)
c00193fc:	0507a703          	lw	a4,80(a5)
c0019400:	fdc42783          	lw	a5,-36(s0)
c0019404:	0547a783          	lw	a5,84(a5)
c0019408:	00000593          	li	a1,0
c001940c:	00078513          	mv	a0,a5
c0019410:	000700e7          	jalr	a4
	return;
c0019414:	00000013          	nop
c0019418:	00000013          	nop
}
c001941c:	02c12083          	lw	ra,44(sp)
c0019420:	02812403          	lw	s0,40(sp)
c0019424:	02412483          	lw	s1,36(sp)
c0019428:	03010113          	addi	sp,sp,48
c001942c:	00008067          	ret

c0019430 <RecvMasterData>:
*
* @note		None.
*
******************************************************************************/
static void RecvMasterData(XIic *InstancePtr)
{
c0019430:	fd010113          	addi	sp,sp,-48
c0019434:	02112623          	sw	ra,44(sp)
c0019438:	02812423          	sw	s0,40(sp)
c001943c:	02912223          	sw	s1,36(sp)
c0019440:	03010413          	addi	s0,sp,48
c0019444:	fca42e23          	sw	a0,-36(s0)

	/*
	 * Device is a master receiving, get the contents of the control
	 * register and determine the number of bytes in fifo to be read out.
	 */
	CntlReg = XIic_ReadReg(InstancePtr->BaseAddress, XIIC_CR_REG_OFFSET);
c0019448:	fdc42783          	lw	a5,-36(s0)
c001944c:	00c7a783          	lw	a5,12(a5)
c0019450:	10078793          	addi	a5,a5,256
c0019454:	00078513          	mv	a0,a5
c0019458:	a40ff0ef          	jal	ra,c0018698 <Xil_In32>
c001945c:	fea42223          	sw	a0,-28(s0)
	BytesInFifo = XIic_ReadReg(InstancePtr->BaseAddress,
c0019460:	fdc42783          	lw	a5,-36(s0)
c0019464:	00c7a783          	lw	a5,12(a5)
c0019468:	11878793          	addi	a5,a5,280
c001946c:	00078513          	mv	a0,a5
c0019470:	a28ff0ef          	jal	ra,c0018698 <Xil_In32>
c0019474:	00050793          	mv	a5,a0
				XIIC_RFO_REG_OFFSET) + 1;
c0019478:	00178793          	addi	a5,a5,1
	BytesInFifo = XIic_ReadReg(InstancePtr->BaseAddress,
c001947c:	fef42023          	sw	a5,-32(s0)

	/*
	 * If data in FIFO holds all data to be retrieved - 1, set NOACK and
	 * disable the Tx error.
	 */
	if ((InstancePtr->RecvByteCount - BytesInFifo) == 1) {
c0019480:	fdc42783          	lw	a5,-36(s0)
c0019484:	0347a703          	lw	a4,52(a5)
c0019488:	fe042783          	lw	a5,-32(s0)
c001948c:	40f70733          	sub	a4,a4,a5
c0019490:	00100793          	li	a5,1
c0019494:	0ef71863          	bne	a4,a5,c0019584 <RecvMasterData+0x154>
		/*
		 * Disable Tx error interrupt to prevent interrupt
		 * as this device will cause it when it set NO ACK next.
		 */
		XIic_DisableIntr(InstancePtr->BaseAddress,
c0019498:	fdc42783          	lw	a5,-36(s0)
c001949c:	00c7a783          	lw	a5,12(a5)
c00194a0:	02878493          	addi	s1,a5,40
c00194a4:	fdc42783          	lw	a5,-36(s0)
c00194a8:	00c7a783          	lw	a5,12(a5)
c00194ac:	02878793          	addi	a5,a5,40
c00194b0:	00078513          	mv	a0,a5
c00194b4:	9e4ff0ef          	jal	ra,c0018698 <Xil_In32>
c00194b8:	00050793          	mv	a5,a0
c00194bc:	ffd7f793          	andi	a5,a5,-3
c00194c0:	00078593          	mv	a1,a5
c00194c4:	00048513          	mv	a0,s1
c00194c8:	9f8ff0ef          	jal	ra,c00186c0 <Xil_Out32>
				  XIIC_INTR_TX_ERROR_MASK);
		XIic_ClearIntr(InstancePtr->BaseAddress,
c00194cc:	fdc42783          	lw	a5,-36(s0)
c00194d0:	00c7a783          	lw	a5,12(a5)
c00194d4:	02078493          	addi	s1,a5,32
c00194d8:	fdc42783          	lw	a5,-36(s0)
c00194dc:	00c7a783          	lw	a5,12(a5)
c00194e0:	02078793          	addi	a5,a5,32
c00194e4:	00078513          	mv	a0,a5
c00194e8:	9b0ff0ef          	jal	ra,c0018698 <Xil_In32>
c00194ec:	00050793          	mv	a5,a0
c00194f0:	0027f793          	andi	a5,a5,2
c00194f4:	00078593          	mv	a1,a5
c00194f8:	00048513          	mv	a0,s1
c00194fc:	9c4ff0ef          	jal	ra,c00186c0 <Xil_Out32>

		/*
		 * Write control reg with NO ACK allowing last byte to
		 * have the No ack set to indicate to slave last byte read.
		 */
		XIic_WriteReg(InstancePtr->BaseAddress, XIIC_CR_REG_OFFSET,
c0019500:	fdc42783          	lw	a5,-36(s0)
c0019504:	00c7a783          	lw	a5,12(a5)
c0019508:	10078713          	addi	a4,a5,256
c001950c:	fe442783          	lw	a5,-28(s0)
c0019510:	0107e793          	ori	a5,a5,16
c0019514:	00078593          	mv	a1,a5
c0019518:	00070513          	mv	a0,a4
c001951c:	9a4ff0ef          	jal	ra,c00186c0 <Xil_Out32>

		/*
		 * Read one byte to clear a place for the last byte to be read
		 * which will set the NO ACK.
		 */
		XIic_ReadRecvByte(InstancePtr);
c0019520:	fdc42783          	lw	a5,-36(s0)
c0019524:	00c7a783          	lw	a5,12(a5)
c0019528:	10c78793          	addi	a5,a5,268
c001952c:	00078513          	mv	a0,a5
c0019530:	968ff0ef          	jal	ra,c0018698 <Xil_In32>
c0019534:	00050613          	mv	a2,a0
c0019538:	fdc42783          	lw	a5,-36(s0)
c001953c:	0287a783          	lw	a5,40(a5)
c0019540:	00178693          	addi	a3,a5,1
c0019544:	fdc42703          	lw	a4,-36(s0)
c0019548:	02d72423          	sw	a3,40(a4)
c001954c:	0ff67713          	andi	a4,a2,255
c0019550:	00e78023          	sb	a4,0(a5)
c0019554:	fdc42783          	lw	a5,-36(s0)
c0019558:	0347a783          	lw	a5,52(a5)
c001955c:	fff78713          	addi	a4,a5,-1
c0019560:	fdc42783          	lw	a5,-36(s0)
c0019564:	02e7aa23          	sw	a4,52(a5)
c0019568:	fdc42783          	lw	a5,-36(s0)
c001956c:	0037c783          	lbu	a5,3(a5)
c0019570:	00178793          	addi	a5,a5,1
c0019574:	0ff7f713          	andi	a4,a5,255
c0019578:	fdc42783          	lw	a5,-36(s0)
c001957c:	00e781a3          	sb	a4,3(a5)
		 */
		for (LoopCnt = 0; LoopCnt < BytesToRead; LoopCnt++) {
			XIic_ReadRecvByte(InstancePtr);
		}
	}
}
c0019580:	2100006f          	j	c0019790 <RecvMasterData+0x360>
	else if ((InstancePtr->RecvByteCount - BytesInFifo) == 0) {
c0019584:	fdc42783          	lw	a5,-36(s0)
c0019588:	0347a783          	lw	a5,52(a5)
c001958c:	fe042703          	lw	a4,-32(s0)
c0019590:	14f71a63          	bne	a4,a5,c00196e4 <RecvMasterData+0x2b4>
		if ((InstancePtr->Options & XII_REPEATED_START_OPTION) == 0) {
c0019594:	fdc42783          	lw	a5,-36(s0)
c0019598:	0207a783          	lw	a5,32(a5)
c001959c:	0027f793          	andi	a5,a5,2
c00195a0:	00079a63          	bnez	a5,c00195b4 <RecvMasterData+0x184>
			CntlReg &= ~XIIC_CR_MSMS_MASK;
c00195a4:	fe442783          	lw	a5,-28(s0)
c00195a8:	ffb7f793          	andi	a5,a5,-5
c00195ac:	fef42223          	sw	a5,-28(s0)
c00195b0:	0100006f          	j	c00195c0 <RecvMasterData+0x190>
			CntlReg |= XIIC_CR_REPEATED_START_MASK;
c00195b4:	fe442783          	lw	a5,-28(s0)
c00195b8:	0207e793          	ori	a5,a5,32
c00195bc:	fef42223          	sw	a5,-28(s0)
		XIic_WriteReg(InstancePtr->BaseAddress, XIIC_CR_REG_OFFSET,
c00195c0:	fdc42783          	lw	a5,-36(s0)
c00195c4:	00c7a783          	lw	a5,12(a5)
c00195c8:	10078793          	addi	a5,a5,256
c00195cc:	fe442583          	lw	a1,-28(s0)
c00195d0:	00078513          	mv	a0,a5
c00195d4:	8ecff0ef          	jal	ra,c00186c0 <Xil_Out32>
		for (LoopCnt = 0; LoopCnt < BytesInFifo; LoopCnt++) {
c00195d8:	fe0407a3          	sb	zero,-17(s0)
c00195dc:	0700006f          	j	c001964c <RecvMasterData+0x21c>
			XIic_ReadRecvByte(InstancePtr);
c00195e0:	fdc42783          	lw	a5,-36(s0)
c00195e4:	00c7a783          	lw	a5,12(a5)
c00195e8:	10c78793          	addi	a5,a5,268
c00195ec:	00078513          	mv	a0,a5
c00195f0:	8a8ff0ef          	jal	ra,c0018698 <Xil_In32>
c00195f4:	00050613          	mv	a2,a0
c00195f8:	fdc42783          	lw	a5,-36(s0)
c00195fc:	0287a783          	lw	a5,40(a5)
c0019600:	00178693          	addi	a3,a5,1
c0019604:	fdc42703          	lw	a4,-36(s0)
c0019608:	02d72423          	sw	a3,40(a4)
c001960c:	0ff67713          	andi	a4,a2,255
c0019610:	00e78023          	sb	a4,0(a5)
c0019614:	fdc42783          	lw	a5,-36(s0)
c0019618:	0347a783          	lw	a5,52(a5)
c001961c:	fff78713          	addi	a4,a5,-1
c0019620:	fdc42783          	lw	a5,-36(s0)
c0019624:	02e7aa23          	sw	a4,52(a5)
c0019628:	fdc42783          	lw	a5,-36(s0)
c001962c:	0037c783          	lbu	a5,3(a5)
c0019630:	00178793          	addi	a5,a5,1
c0019634:	0ff7f713          	andi	a4,a5,255
c0019638:	fdc42783          	lw	a5,-36(s0)
c001963c:	00e781a3          	sb	a4,3(a5)
		for (LoopCnt = 0; LoopCnt < BytesInFifo; LoopCnt++) {
c0019640:	fef44783          	lbu	a5,-17(s0)
c0019644:	00178793          	addi	a5,a5,1
c0019648:	fef407a3          	sb	a5,-17(s0)
c001964c:	fef44783          	lbu	a5,-17(s0)
c0019650:	fe042703          	lw	a4,-32(s0)
c0019654:	f8e7c6e3          	blt	a5,a4,c00195e0 <RecvMasterData+0x1b0>
		XIic_WriteReg(InstancePtr->BaseAddress,
c0019658:	fdc42783          	lw	a5,-36(s0)
c001965c:	00c7a783          	lw	a5,12(a5)
c0019660:	12078793          	addi	a5,a5,288
c0019664:	00000593          	li	a1,0
c0019668:	00078513          	mv	a0,a5
c001966c:	854ff0ef          	jal	ra,c00186c0 <Xil_Out32>
		XIic_DisableIntr(InstancePtr->BaseAddress,
c0019670:	fdc42783          	lw	a5,-36(s0)
c0019674:	00c7a783          	lw	a5,12(a5)
c0019678:	02878493          	addi	s1,a5,40
c001967c:	fdc42783          	lw	a5,-36(s0)
c0019680:	00c7a783          	lw	a5,12(a5)
c0019684:	02878793          	addi	a5,a5,40
c0019688:	00078513          	mv	a0,a5
c001968c:	80cff0ef          	jal	ra,c0018698 <Xil_In32>
c0019690:	00050793          	mv	a5,a0
c0019694:	ff77f793          	andi	a5,a5,-9
c0019698:	00078593          	mv	a1,a5
c001969c:	00048513          	mv	a0,s1
c00196a0:	820ff0ef          	jal	ra,c00186c0 <Xil_Out32>
		XIic_WriteReg(InstancePtr->BaseAddress, XIIC_CR_REG_OFFSET,
c00196a4:	fdc42783          	lw	a5,-36(s0)
c00196a8:	00c7a783          	lw	a5,12(a5)
c00196ac:	10078713          	addi	a4,a5,256
c00196b0:	fe442783          	lw	a5,-28(s0)
c00196b4:	fef7f793          	andi	a5,a5,-17
c00196b8:	00078593          	mv	a1,a5
c00196bc:	00070513          	mv	a0,a4
c00196c0:	800ff0ef          	jal	ra,c00186c0 <Xil_Out32>
		InstancePtr->RecvHandler(InstancePtr->RecvCallBackRef, 0);
c00196c4:	fdc42783          	lw	a5,-36(s0)
c00196c8:	0487a703          	lw	a4,72(a5)
c00196cc:	fdc42783          	lw	a5,-36(s0)
c00196d0:	04c7a783          	lw	a5,76(a5)
c00196d4:	00000593          	li	a1,0
c00196d8:	00078513          	mv	a0,a5
c00196dc:	000700e7          	jalr	a4
}
c00196e0:	0b00006f          	j	c0019790 <RecvMasterData+0x360>
		BytesToRead = InstancePtr->RecvByteCount - BytesInFifo - 1;
c00196e4:	fdc42783          	lw	a5,-36(s0)
c00196e8:	0347a703          	lw	a4,52(a5)
c00196ec:	fe042783          	lw	a5,-32(s0)
c00196f0:	40f707b3          	sub	a5,a4,a5
c00196f4:	fff78793          	addi	a5,a5,-1
c00196f8:	fef42423          	sw	a5,-24(s0)
		if (BytesToRead > IIC_RX_FIFO_DEPTH) {
c00196fc:	fe842703          	lw	a4,-24(s0)
c0019700:	01000793          	li	a5,16
c0019704:	00e7d663          	bge	a5,a4,c0019710 <RecvMasterData+0x2e0>
			BytesToRead = IIC_RX_FIFO_DEPTH;
c0019708:	01000793          	li	a5,16
c001970c:	fef42423          	sw	a5,-24(s0)
		for (LoopCnt = 0; LoopCnt < BytesToRead; LoopCnt++) {
c0019710:	fe0407a3          	sb	zero,-17(s0)
c0019714:	0700006f          	j	c0019784 <RecvMasterData+0x354>
			XIic_ReadRecvByte(InstancePtr);
c0019718:	fdc42783          	lw	a5,-36(s0)
c001971c:	00c7a783          	lw	a5,12(a5)
c0019720:	10c78793          	addi	a5,a5,268
c0019724:	00078513          	mv	a0,a5
c0019728:	f71fe0ef          	jal	ra,c0018698 <Xil_In32>
c001972c:	00050613          	mv	a2,a0
c0019730:	fdc42783          	lw	a5,-36(s0)
c0019734:	0287a783          	lw	a5,40(a5)
c0019738:	00178693          	addi	a3,a5,1
c001973c:	fdc42703          	lw	a4,-36(s0)
c0019740:	02d72423          	sw	a3,40(a4)
c0019744:	0ff67713          	andi	a4,a2,255
c0019748:	00e78023          	sb	a4,0(a5)
c001974c:	fdc42783          	lw	a5,-36(s0)
c0019750:	0347a783          	lw	a5,52(a5)
c0019754:	fff78713          	addi	a4,a5,-1
c0019758:	fdc42783          	lw	a5,-36(s0)
c001975c:	02e7aa23          	sw	a4,52(a5)
c0019760:	fdc42783          	lw	a5,-36(s0)
c0019764:	0037c783          	lbu	a5,3(a5)
c0019768:	00178793          	addi	a5,a5,1
c001976c:	0ff7f713          	andi	a4,a5,255
c0019770:	fdc42783          	lw	a5,-36(s0)
c0019774:	00e781a3          	sb	a4,3(a5)
		for (LoopCnt = 0; LoopCnt < BytesToRead; LoopCnt++) {
c0019778:	fef44783          	lbu	a5,-17(s0)
c001977c:	00178793          	addi	a5,a5,1
c0019780:	fef407a3          	sb	a5,-17(s0)
c0019784:	fef44783          	lbu	a5,-17(s0)
c0019788:	fe842703          	lw	a4,-24(s0)
c001978c:	f8e7c6e3          	blt	a5,a4,c0019718 <RecvMasterData+0x2e8>
}
c0019790:	00000013          	nop
c0019794:	02c12083          	lw	ra,44(sp)
c0019798:	02812403          	lw	s0,40(sp)
c001979c:	02412483          	lw	s1,36(sp)
c00197a0:	03010113          	addi	sp,sp,48
c00197a4:	00008067          	ret

c00197a8 <Xil_In32>:
{
c00197a8:	fe010113          	addi	sp,sp,-32
c00197ac:	00812e23          	sw	s0,28(sp)
c00197b0:	02010413          	addi	s0,sp,32
c00197b4:	fea42623          	sw	a0,-20(s0)
	return *(volatile u32 *) Addr;
c00197b8:	fec42783          	lw	a5,-20(s0)
c00197bc:	0007a783          	lw	a5,0(a5)
}
c00197c0:	00078513          	mv	a0,a5
c00197c4:	01c12403          	lw	s0,28(sp)
c00197c8:	02010113          	addi	sp,sp,32
c00197cc:	00008067          	ret

c00197d0 <Xil_Out32>:
{
c00197d0:	fd010113          	addi	sp,sp,-48
c00197d4:	02812623          	sw	s0,44(sp)
c00197d8:	03010413          	addi	s0,sp,48
c00197dc:	fca42e23          	sw	a0,-36(s0)
c00197e0:	fcb42c23          	sw	a1,-40(s0)
	volatile u32 *LocalAddr = (volatile u32 *)Addr;
c00197e4:	fdc42783          	lw	a5,-36(s0)
c00197e8:	fef42623          	sw	a5,-20(s0)
	*LocalAddr = Value;
c00197ec:	fec42783          	lw	a5,-20(s0)
c00197f0:	fd842703          	lw	a4,-40(s0)
c00197f4:	00e7a023          	sw	a4,0(a5)
}
c00197f8:	00000013          	nop
c00197fc:	02c12403          	lw	s0,44(sp)
c0019800:	03010113          	addi	sp,sp,48
c0019804:	00008067          	ret

c0019808 <XIic_InterruptHandler>:
* not get into a potentially confused state. The remaining interrupts may be
* rearranged with no harm.
*
******************************************************************************/
void XIic_InterruptHandler(void *InstancePtr)
{
c0019808:	fc010113          	addi	sp,sp,-64
c001980c:	02112e23          	sw	ra,60(sp)
c0019810:	02812c23          	sw	s0,56(sp)
c0019814:	02912a23          	sw	s1,52(sp)
c0019818:	04010413          	addi	s0,sp,64
c001981c:	fca42623          	sw	a0,-52(s0)
	u32 Status;
	u32 IntrStatus;
	u32 IntrPending;
	u32 IntrEnable;
	XIic *IicPtr = NULL;
c0019820:	fe042423          	sw	zero,-24(s0)
	u32 Clear = 0;
c0019824:	fe042623          	sw	zero,-20(s0)

	/*
	 * Verify that each of the inputs are valid.
	 */
	Xil_AssertVoid(InstancePtr != NULL);
c0019828:	fcc42783          	lw	a5,-52(s0)
c001982c:	06078263          	beqz	a5,c0019890 <XIic_InterruptHandler+0x88>
c0019830:	07fe9797          	auipc	a5,0x7fe9
c0019834:	0e478793          	addi	a5,a5,228 # c8002914 <Xil_AssertStatus>
c0019838:	0007a023          	sw	zero,0(a5)

	/*
	 * Convert the non-typed pointer to an IIC instance pointer
	 */
	IicPtr = (XIic *) InstancePtr;
c001983c:	fcc42783          	lw	a5,-52(s0)
c0019840:	fef42423          	sw	a5,-24(s0)

	/*
	 * Get the interrupt Status.
	 */
	IntrPending = XIic_ReadIisr(IicPtr->BaseAddress);
c0019844:	fe842783          	lw	a5,-24(s0)
c0019848:	00c7a783          	lw	a5,12(a5)
c001984c:	02078793          	addi	a5,a5,32
c0019850:	00078513          	mv	a0,a5
c0019854:	f55ff0ef          	jal	ra,c00197a8 <Xil_In32>
c0019858:	fea42223          	sw	a0,-28(s0)
	IntrEnable = XIic_ReadIier(IicPtr->BaseAddress);
c001985c:	fe842783          	lw	a5,-24(s0)
c0019860:	00c7a783          	lw	a5,12(a5)
c0019864:	02878793          	addi	a5,a5,40
c0019868:	00078513          	mv	a0,a5
c001986c:	f3dff0ef          	jal	ra,c00197a8 <Xil_In32>
c0019870:	fea42023          	sw	a0,-32(s0)
	IntrStatus = IntrPending & IntrEnable;
c0019874:	fe442703          	lw	a4,-28(s0)
c0019878:	fe042783          	lw	a5,-32(s0)
c001987c:	00f777b3          	and	a5,a4,a5
c0019880:	fcf42e23          	sw	a5,-36(s0)

	/*
	 * Do not processes a devices interrupts if the device has no
	 * interrupts pending or the global interrupts have been disabled.
	 */
	if ((IntrStatus == 0) ||
c0019884:	fdc42783          	lw	a5,-36(s0)
c0019888:	2e078c63          	beqz	a5,c0019b80 <XIic_InterruptHandler+0x378>
c001988c:	0280006f          	j	c00198b4 <XIic_InterruptHandler+0xac>
	Xil_AssertVoid(InstancePtr != NULL);
c0019890:	08800593          	li	a1,136
c0019894:	07fe8517          	auipc	a0,0x7fe8
c0019898:	07450513          	addi	a0,a0,116 # c8001908 <__rodata_start+0x1908>
c001989c:	220040ef          	jal	ra,c001dabc <Xil_Assert>
c00198a0:	07fe9797          	auipc	a5,0x7fe9
c00198a4:	07478793          	addi	a5,a5,116 # c8002914 <Xil_AssertStatus>
c00198a8:	00100713          	li	a4,1
c00198ac:	00e7a023          	sw	a4,0(a5)
c00198b0:	2d40006f          	j	c0019b84 <XIic_InterruptHandler+0x37c>
		(XIic_IsIntrGlobalEnabled(IicPtr->BaseAddress) == FALSE)) {
c00198b4:	fe842783          	lw	a5,-24(s0)
c00198b8:	00c7a783          	lw	a5,12(a5)
c00198bc:	01c78793          	addi	a5,a5,28
c00198c0:	00078513          	mv	a0,a5
c00198c4:	ee5ff0ef          	jal	ra,c00197a8 <Xil_In32>
c00198c8:	00050713          	mv	a4,a0
	if ((IntrStatus == 0) ||
c00198cc:	800007b7          	lui	a5,0x80000
c00198d0:	2af71863          	bne	a4,a5,c0019b80 <XIic_InterruptHandler+0x378>
	}

	/*
	 * Update interrupt stats and get the contents of the status register.
	 */
	IicPtr->Stats.IicInterrupts++;
c00198d4:	fe842783          	lw	a5,-24(s0)
c00198d8:	0087c783          	lbu	a5,8(a5) # 80000008 <_end+0xb7f7b788>
c00198dc:	00178793          	addi	a5,a5,1
c00198e0:	0ff7f713          	andi	a4,a5,255
c00198e4:	fe842783          	lw	a5,-24(s0)
c00198e8:	00e78423          	sb	a4,8(a5)
	Status = XIic_ReadReg(IicPtr->BaseAddress, XIIC_SR_REG_OFFSET);
c00198ec:	fe842783          	lw	a5,-24(s0)
c00198f0:	00c7a783          	lw	a5,12(a5)
c00198f4:	10478793          	addi	a5,a5,260
c00198f8:	00078513          	mv	a0,a5
c00198fc:	eadff0ef          	jal	ra,c00197a8 <Xil_In32>
c0019900:	fca42c23          	sw	a0,-40(s0)

	/*
	 * Service requesting interrupt.
	 */
	if (IntrStatus & XIIC_INTR_ARB_LOST_MASK) {
c0019904:	fdc42783          	lw	a5,-36(s0)
c0019908:	0017f793          	andi	a5,a5,1
c001990c:	02078e63          	beqz	a5,c0019948 <XIic_InterruptHandler+0x140>
		/* Bus Arbritration Lost */

		IicPtr->Stats.ArbitrationLost++;
c0019910:	fe842783          	lw	a5,-24(s0)
c0019914:	0007c783          	lbu	a5,0(a5)
c0019918:	00178793          	addi	a5,a5,1
c001991c:	0ff7f713          	andi	a4,a5,255
c0019920:	fe842783          	lw	a5,-24(s0)
c0019924:	00e78023          	sb	a4,0(a5)
		XIic_ArbLostFuncPtr(IicPtr);
c0019928:	07fe9797          	auipc	a5,0x7fe9
c001992c:	05078793          	addi	a5,a5,80 # c8002978 <XIic_ArbLostFuncPtr>
c0019930:	0007a783          	lw	a5,0(a5)
c0019934:	fe842503          	lw	a0,-24(s0)
c0019938:	000780e7          	jalr	a5

		Clear = XIIC_INTR_ARB_LOST_MASK;
c001993c:	00100793          	li	a5,1
c0019940:	fef42623          	sw	a5,-20(s0)
c0019944:	2200006f          	j	c0019b64 <XIic_InterruptHandler+0x35c>
	} else if (IntrStatus & XIIC_INTR_TX_ERROR_MASK) {
c0019948:	fdc42783          	lw	a5,-36(s0)
c001994c:	0027f793          	andi	a5,a5,2
c0019950:	02078863          	beqz	a5,c0019980 <XIic_InterruptHandler+0x178>
		/* Transmit errors (no acknowledge) received */
		IicPtr->Stats.TxErrors++;
c0019954:	fe842783          	lw	a5,-24(s0)
c0019958:	0077c783          	lbu	a5,7(a5)
c001995c:	00178793          	addi	a5,a5,1
c0019960:	0ff7f713          	andi	a4,a5,255
c0019964:	fe842783          	lw	a5,-24(s0)
c0019968:	00e783a3          	sb	a4,7(a5)
		TxErrorHandler(IicPtr);
c001996c:	fe842503          	lw	a0,-24(s0)
c0019970:	350000ef          	jal	ra,c0019cc0 <TxErrorHandler>

		Clear = XIIC_INTR_TX_ERROR_MASK;
c0019974:	00200793          	li	a5,2
c0019978:	fef42623          	sw	a5,-20(s0)
c001997c:	1e80006f          	j	c0019b64 <XIic_InterruptHandler+0x35c>
	} else if (IntrStatus & XIIC_INTR_NAAS_MASK) {
c0019980:	fdc42783          	lw	a5,-36(s0)
c0019984:	0407f793          	andi	a5,a5,64
c0019988:	02078263          	beqz	a5,c00199ac <XIic_InterruptHandler+0x1a4>
		/* Not Addressed As Slave */

		XIic_NotAddrAsSlaveFuncPtr(IicPtr);
c001998c:	07fe9797          	auipc	a5,0x7fe9
c0019990:	fd878793          	addi	a5,a5,-40 # c8002964 <XIic_NotAddrAsSlaveFuncPtr>
c0019994:	0007a783          	lw	a5,0(a5)
c0019998:	fe842503          	lw	a0,-24(s0)
c001999c:	000780e7          	jalr	a5
		Clear = XIIC_INTR_NAAS_MASK;
c00199a0:	04000793          	li	a5,64
c00199a4:	fef42623          	sw	a5,-20(s0)
c00199a8:	1bc0006f          	j	c0019b64 <XIic_InterruptHandler+0x35c>
	} else if (IntrStatus & XIIC_INTR_RX_FULL_MASK) {
c00199ac:	fdc42783          	lw	a5,-36(s0)
c00199b0:	0087f793          	andi	a5,a5,8
c00199b4:	06078063          	beqz	a5,c0019a14 <XIic_InterruptHandler+0x20c>
		/* Receive register/FIFO is full */

		IicPtr->Stats.RecvInterrupts++;
c00199b8:	fe842783          	lw	a5,-24(s0)
c00199bc:	0047c783          	lbu	a5,4(a5)
c00199c0:	00178793          	addi	a5,a5,1
c00199c4:	0ff7f713          	andi	a4,a5,255
c00199c8:	fe842783          	lw	a5,-24(s0)
c00199cc:	00e78223          	sb	a4,4(a5)

		if (Status & XIIC_SR_ADDR_AS_SLAVE_MASK) {
c00199d0:	fd842783          	lw	a5,-40(s0)
c00199d4:	0027f793          	andi	a5,a5,2
c00199d8:	00078e63          	beqz	a5,c00199f4 <XIic_InterruptHandler+0x1ec>
			XIic_RecvSlaveFuncPtr(IicPtr);
c00199dc:	07fe9797          	auipc	a5,0x7fe9
c00199e0:	f8c78793          	addi	a5,a5,-116 # c8002968 <XIic_RecvSlaveFuncPtr>
c00199e4:	0007a783          	lw	a5,0(a5)
c00199e8:	fe842503          	lw	a0,-24(s0)
c00199ec:	000780e7          	jalr	a5
c00199f0:	0180006f          	j	c0019a08 <XIic_InterruptHandler+0x200>
		} else {
			XIic_RecvMasterFuncPtr(IicPtr);
c00199f4:	07fe9797          	auipc	a5,0x7fe9
c00199f8:	f7c78793          	addi	a5,a5,-132 # c8002970 <XIic_RecvMasterFuncPtr>
c00199fc:	0007a783          	lw	a5,0(a5)
c0019a00:	fe842503          	lw	a0,-24(s0)
c0019a04:	000780e7          	jalr	a5
		}

		Clear = XIIC_INTR_RX_FULL_MASK;
c0019a08:	00800793          	li	a5,8
c0019a0c:	fef42623          	sw	a5,-20(s0)
c0019a10:	1540006f          	j	c0019b64 <XIic_InterruptHandler+0x35c>
	} else if (IntrStatus & XIIC_INTR_AAS_MASK) {
c0019a14:	fdc42783          	lw	a5,-36(s0)
c0019a18:	0207f793          	andi	a5,a5,32
c0019a1c:	02078263          	beqz	a5,c0019a40 <XIic_InterruptHandler+0x238>
		/* Addressed As Slave */

		XIic_AddrAsSlaveFuncPtr(IicPtr);
c0019a20:	07fe9797          	auipc	a5,0x7fe9
c0019a24:	f4078793          	addi	a5,a5,-192 # c8002960 <XIic_AddrAsSlaveFuncPtr>
c0019a28:	0007a783          	lw	a5,0(a5)
c0019a2c:	fe842503          	lw	a0,-24(s0)
c0019a30:	000780e7          	jalr	a5
		Clear = XIIC_INTR_AAS_MASK;
c0019a34:	02000793          	li	a5,32
c0019a38:	fef42623          	sw	a5,-20(s0)
c0019a3c:	1280006f          	j	c0019b64 <XIic_InterruptHandler+0x35c>
	} else if (IntrStatus & XIIC_INTR_BNB_MASK) {
c0019a40:	fdc42783          	lw	a5,-36(s0)
c0019a44:	0107f793          	andi	a5,a5,16
c0019a48:	08078863          	beqz	a5,c0019ad8 <XIic_InterruptHandler+0x2d0>
		/* IIC bus has transitioned to not busy */

		/* Check if send callback needs to run */
		if (IicPtr->BNBOnly == TRUE) {
c0019a4c:	fe842783          	lw	a5,-24(s0)
c0019a50:	0387a703          	lw	a4,56(a5)
c0019a54:	00100793          	li	a5,1
c0019a58:	02f71263          	bne	a4,a5,c0019a7c <XIic_InterruptHandler+0x274>
			XIic_BusNotBusyFuncPtr(IicPtr);
c0019a5c:	07fe9797          	auipc	a5,0x7fe9
c0019a60:	f2078793          	addi	a5,a5,-224 # c800297c <XIic_BusNotBusyFuncPtr>
c0019a64:	0007a783          	lw	a5,0(a5)
c0019a68:	fe842503          	lw	a0,-24(s0)
c0019a6c:	000780e7          	jalr	a5
			IicPtr->BNBOnly = FALSE;
c0019a70:	fe842783          	lw	a5,-24(s0)
c0019a74:	0207ac23          	sw	zero,56(a5)
c0019a78:	0200006f          	j	c0019a98 <XIic_InterruptHandler+0x290>
		} else {
			IicPtr->SendHandler(IicPtr->SendCallBackRef, 0);
c0019a7c:	fe842783          	lw	a5,-24(s0)
c0019a80:	0507a703          	lw	a4,80(a5)
c0019a84:	fe842783          	lw	a5,-24(s0)
c0019a88:	0547a783          	lw	a5,84(a5)
c0019a8c:	00000593          	li	a1,0
c0019a90:	00078513          	mv	a0,a5
c0019a94:	000700e7          	jalr	a4
		}

		Clear = XIIC_INTR_BNB_MASK;
c0019a98:	01000793          	li	a5,16
c0019a9c:	fef42623          	sw	a5,-20(s0)

		/* The bus is not busy, disable BusNotBusy interrupt */
		XIic_DisableIntr(IicPtr->BaseAddress, XIIC_INTR_BNB_MASK);
c0019aa0:	fe842783          	lw	a5,-24(s0)
c0019aa4:	00c7a783          	lw	a5,12(a5)
c0019aa8:	02878493          	addi	s1,a5,40
c0019aac:	fe842783          	lw	a5,-24(s0)
c0019ab0:	00c7a783          	lw	a5,12(a5)
c0019ab4:	02878793          	addi	a5,a5,40
c0019ab8:	00078513          	mv	a0,a5
c0019abc:	cedff0ef          	jal	ra,c00197a8 <Xil_In32>
c0019ac0:	00050793          	mv	a5,a0
c0019ac4:	fef7f793          	andi	a5,a5,-17
c0019ac8:	00078593          	mv	a1,a5
c0019acc:	00048513          	mv	a0,s1
c0019ad0:	d01ff0ef          	jal	ra,c00197d0 <Xil_Out32>
c0019ad4:	0900006f          	j	c0019b64 <XIic_InterruptHandler+0x35c>

	} else if ((IntrStatus & XIIC_INTR_TX_EMPTY_MASK) ||
c0019ad8:	fdc42783          	lw	a5,-36(s0)
c0019adc:	0047f793          	andi	a5,a5,4
c0019ae0:	00079863          	bnez	a5,c0019af0 <XIic_InterruptHandler+0x2e8>
		 (IntrStatus & XIIC_INTR_TX_HALF_MASK)) {
c0019ae4:	fdc42783          	lw	a5,-36(s0)
c0019ae8:	0807f793          	andi	a5,a5,128
	} else if ((IntrStatus & XIIC_INTR_TX_EMPTY_MASK) ||
c0019aec:	06078c63          	beqz	a5,c0019b64 <XIic_InterruptHandler+0x35c>
		/* Transmit register/FIFO is empty or  empty */
		IicPtr->Stats.SendInterrupts++;
c0019af0:	fe842783          	lw	a5,-24(s0)
c0019af4:	0067c783          	lbu	a5,6(a5)
c0019af8:	00178793          	addi	a5,a5,1
c0019afc:	0ff7f713          	andi	a4,a5,255
c0019b00:	fe842783          	lw	a5,-24(s0)
c0019b04:	00e78323          	sb	a4,6(a5)

		if (Status & XIIC_SR_ADDR_AS_SLAVE_MASK) {
c0019b08:	fd842783          	lw	a5,-40(s0)
c0019b0c:	0027f793          	andi	a5,a5,2
c0019b10:	00078e63          	beqz	a5,c0019b2c <XIic_InterruptHandler+0x324>
			XIic_SendSlaveFuncPtr(IicPtr);
c0019b14:	07fe9797          	auipc	a5,0x7fe9
c0019b18:	e5878793          	addi	a5,a5,-424 # c800296c <XIic_SendSlaveFuncPtr>
c0019b1c:	0007a783          	lw	a5,0(a5)
c0019b20:	fe842503          	lw	a0,-24(s0)
c0019b24:	000780e7          	jalr	a5
c0019b28:	0180006f          	j	c0019b40 <XIic_InterruptHandler+0x338>
		} else {
			XIic_SendMasterFuncPtr(IicPtr);
c0019b2c:	07fe9797          	auipc	a5,0x7fe9
c0019b30:	e4878793          	addi	a5,a5,-440 # c8002974 <XIic_SendMasterFuncPtr>
c0019b34:	0007a783          	lw	a5,0(a5)
c0019b38:	fe842503          	lw	a0,-24(s0)
c0019b3c:	000780e7          	jalr	a5
		}

		IntrStatus = XIic_ReadIisr(IicPtr->BaseAddress);
c0019b40:	fe842783          	lw	a5,-24(s0)
c0019b44:	00c7a783          	lw	a5,12(a5)
c0019b48:	02078793          	addi	a5,a5,32
c0019b4c:	00078513          	mv	a0,a5
c0019b50:	c59ff0ef          	jal	ra,c00197a8 <Xil_In32>
c0019b54:	fca42e23          	sw	a0,-36(s0)
		Clear = IntrStatus & (XIIC_INTR_TX_EMPTY_MASK |
c0019b58:	fdc42783          	lw	a5,-36(s0)
c0019b5c:	0847f793          	andi	a5,a5,132
c0019b60:	fef42623          	sw	a5,-20(s0)
	}

	/*
	 * Clear Interrupts.
	 */
	XIic_WriteIisr(IicPtr->BaseAddress, Clear);
c0019b64:	fe842783          	lw	a5,-24(s0)
c0019b68:	00c7a783          	lw	a5,12(a5)
c0019b6c:	02078793          	addi	a5,a5,32
c0019b70:	fec42583          	lw	a1,-20(s0)
c0019b74:	00078513          	mv	a0,a5
c0019b78:	c59ff0ef          	jal	ra,c00197d0 <Xil_Out32>
c0019b7c:	0080006f          	j	c0019b84 <XIic_InterruptHandler+0x37c>
		return;
c0019b80:	00000013          	nop
}
c0019b84:	03c12083          	lw	ra,60(sp)
c0019b88:	03812403          	lw	s0,56(sp)
c0019b8c:	03412483          	lw	s1,52(sp)
c0019b90:	04010113          	addi	sp,sp,64
c0019b94:	00008067          	ret

c0019b98 <XIic_TransmitFifoFill>:
*
* @note		None.
*
******************************************************************************/
void XIic_TransmitFifoFill(XIic *InstancePtr, int Role)
{
c0019b98:	fd010113          	addi	sp,sp,-48
c0019b9c:	02112623          	sw	ra,44(sp)
c0019ba0:	02812423          	sw	s0,40(sp)
c0019ba4:	03010413          	addi	s0,sp,48
c0019ba8:	fca42e23          	sw	a0,-36(s0)
c0019bac:	fcb42c23          	sw	a1,-40(s0)
	 * Determine number of bytes to write to FIFO. Number of bytes that
	 * can be put into the FIFO is (FIFO depth) - (current occupancy + 1)
	 * When more room in FIFO than msg bytes put all of message in the FIFO.
	 */
	AvailBytes = IIC_TX_FIFO_DEPTH -
			(u8) (XIic_ReadReg(InstancePtr->BaseAddress,
c0019bb0:	fdc42783          	lw	a5,-36(s0)
c0019bb4:	00c7a783          	lw	a5,12(a5)
c0019bb8:	11478793          	addi	a5,a5,276
c0019bbc:	00078513          	mv	a0,a5
c0019bc0:	be9ff0ef          	jal	ra,c00197a8 <Xil_In32>
c0019bc4:	00050793          	mv	a5,a0
c0019bc8:	0ff7f793          	andi	a5,a5,255
	AvailBytes = IIC_TX_FIFO_DEPTH -
c0019bcc:	00f00713          	li	a4,15
c0019bd0:	40f707b3          	sub	a5,a4,a5
c0019bd4:	fef403a3          	sb	a5,-25(s0)
					XIIC_TFO_REG_OFFSET) + 1);

	if (InstancePtr->SendByteCount > AvailBytes) {
c0019bd8:	fdc42783          	lw	a5,-36(s0)
c0019bdc:	0307a703          	lw	a4,48(a5)
c0019be0:	fe744783          	lbu	a5,-25(s0)
c0019be4:	00e7d863          	bge	a5,a4,c0019bf4 <XIic_TransmitFifoFill+0x5c>
		NumBytesToSend = AvailBytes;
c0019be8:	fe744783          	lbu	a5,-25(s0)
c0019bec:	fef42423          	sw	a5,-24(s0)
c0019bf0:	03c0006f          	j	c0019c2c <XIic_TransmitFifoFill+0x94>
	} else {
		/*
		 * More space in FIFO than bytes in message.
		 */
		if ((InstancePtr->Options & XII_REPEATED_START_OPTION) ||
c0019bf4:	fdc42783          	lw	a5,-36(s0)
c0019bf8:	0207a783          	lw	a5,32(a5)
c0019bfc:	0027f793          	andi	a5,a5,2
c0019c00:	00079663          	bnez	a5,c0019c0c <XIic_TransmitFifoFill+0x74>
c0019c04:	fd842783          	lw	a5,-40(s0)
c0019c08:	00079a63          	bnez	a5,c0019c1c <XIic_TransmitFifoFill+0x84>
			(Role == XIIC_SLAVE_ROLE)) {
			NumBytesToSend = InstancePtr->SendByteCount;
c0019c0c:	fdc42783          	lw	a5,-36(s0)
c0019c10:	0307a783          	lw	a5,48(a5)
c0019c14:	fef42423          	sw	a5,-24(s0)
c0019c18:	0140006f          	j	c0019c2c <XIic_TransmitFifoFill+0x94>
		} else {
			NumBytesToSend = InstancePtr->SendByteCount - 1;
c0019c1c:	fdc42783          	lw	a5,-36(s0)
c0019c20:	0307a783          	lw	a5,48(a5)
c0019c24:	fff78793          	addi	a5,a5,-1
c0019c28:	fef42423          	sw	a5,-24(s0)
	}

	/*
	 * Fill FIFO with amount determined above.
	 */
	for (LoopCnt = 0; LoopCnt < NumBytesToSend; LoopCnt++) {
c0019c2c:	fe042623          	sw	zero,-20(s0)
c0019c30:	06c0006f          	j	c0019c9c <XIic_TransmitFifoFill+0x104>
		XIic_WriteSendByte(InstancePtr);
c0019c34:	fdc42783          	lw	a5,-36(s0)
c0019c38:	00c7a783          	lw	a5,12(a5)
c0019c3c:	10878613          	addi	a2,a5,264
c0019c40:	fdc42783          	lw	a5,-36(s0)
c0019c44:	0247a783          	lw	a5,36(a5)
c0019c48:	00178693          	addi	a3,a5,1
c0019c4c:	fdc42703          	lw	a4,-36(s0)
c0019c50:	02d72223          	sw	a3,36(a4)
c0019c54:	0007c783          	lbu	a5,0(a5)
c0019c58:	00078593          	mv	a1,a5
c0019c5c:	00060513          	mv	a0,a2
c0019c60:	b71ff0ef          	jal	ra,c00197d0 <Xil_Out32>
c0019c64:	fdc42783          	lw	a5,-36(s0)
c0019c68:	0307a783          	lw	a5,48(a5)
c0019c6c:	fff78713          	addi	a4,a5,-1
c0019c70:	fdc42783          	lw	a5,-36(s0)
c0019c74:	02e7a823          	sw	a4,48(a5)
c0019c78:	fdc42783          	lw	a5,-36(s0)
c0019c7c:	0057c783          	lbu	a5,5(a5)
c0019c80:	00178793          	addi	a5,a5,1
c0019c84:	0ff7f713          	andi	a4,a5,255
c0019c88:	fdc42783          	lw	a5,-36(s0)
c0019c8c:	00e782a3          	sb	a4,5(a5)
	for (LoopCnt = 0; LoopCnt < NumBytesToSend; LoopCnt++) {
c0019c90:	fec42783          	lw	a5,-20(s0)
c0019c94:	00178793          	addi	a5,a5,1
c0019c98:	fef42623          	sw	a5,-20(s0)
c0019c9c:	fec42703          	lw	a4,-20(s0)
c0019ca0:	fe842783          	lw	a5,-24(s0)
c0019ca4:	f8f748e3          	blt	a4,a5,c0019c34 <XIic_TransmitFifoFill+0x9c>
	}
}
c0019ca8:	00000013          	nop
c0019cac:	00000013          	nop
c0019cb0:	02c12083          	lw	ra,44(sp)
c0019cb4:	02812403          	lw	s0,40(sp)
c0019cb8:	03010113          	addi	sp,sp,48
c0019cbc:	00008067          	ret

c0019cc0 <TxErrorHandler>:
*
* @return	None.
*
******************************************************************************/
static void TxErrorHandler(XIic *InstancePtr)
{
c0019cc0:	fd010113          	addi	sp,sp,-48
c0019cc4:	02112623          	sw	ra,44(sp)
c0019cc8:	02812423          	sw	s0,40(sp)
c0019ccc:	02912223          	sw	s1,36(sp)
c0019cd0:	03010413          	addi	s0,sp,48
c0019cd4:	fca42e23          	sw	a0,-36(s0)
	 * As Slave will handle the callbacks. this is used to only flush
	 * the Tx fifo. The addressed as slave bit is gone as soon as the bus
	 * has been released such that the buffer pointers are used to determine
	 * the direction of transfer (send or receive).
	 */
	if (InstancePtr->RecvBufferPtr == NULL) {
c0019cd8:	fdc42783          	lw	a5,-36(s0)
c0019cdc:	0287a783          	lw	a5,40(a5)
c0019ce0:	0e079463          	bnez	a5,c0019dc8 <TxErrorHandler+0x108>
		/*
		 * Master Receiver finished reading message. Flush Tx fifo to
		 * remove an 0xFF that was written to prevent bus throttling,
		 * and disable all transmit and receive interrupts.
		 */
		XIic_FlushTxFifo(InstancePtr);
c0019ce4:	fdc42783          	lw	a5,-36(s0)
c0019ce8:	00c7a783          	lw	a5,12(a5)
c0019cec:	10078793          	addi	a5,a5,256
c0019cf0:	00078513          	mv	a0,a5
c0019cf4:	ab5ff0ef          	jal	ra,c00197a8 <Xil_In32>
c0019cf8:	fea42023          	sw	a0,-32(s0)
c0019cfc:	fdc42783          	lw	a5,-36(s0)
c0019d00:	00c7a783          	lw	a5,12(a5)
c0019d04:	10078713          	addi	a4,a5,256
c0019d08:	fe042783          	lw	a5,-32(s0)
c0019d0c:	0027e793          	ori	a5,a5,2
c0019d10:	00078593          	mv	a1,a5
c0019d14:	00070513          	mv	a0,a4
c0019d18:	ab9ff0ef          	jal	ra,c00197d0 <Xil_Out32>
c0019d1c:	fdc42783          	lw	a5,-36(s0)
c0019d20:	00c7a783          	lw	a5,12(a5)
c0019d24:	10078793          	addi	a5,a5,256
c0019d28:	fe042583          	lw	a1,-32(s0)
c0019d2c:	00078513          	mv	a0,a5
c0019d30:	aa1ff0ef          	jal	ra,c00197d0 <Xil_Out32>
		XIic_DisableIntr(InstancePtr->BaseAddress,
c0019d34:	fdc42783          	lw	a5,-36(s0)
c0019d38:	00c7a783          	lw	a5,12(a5)
c0019d3c:	02878493          	addi	s1,a5,40
c0019d40:	fdc42783          	lw	a5,-36(s0)
c0019d44:	00c7a783          	lw	a5,12(a5)
c0019d48:	02878793          	addi	a5,a5,40
c0019d4c:	00078513          	mv	a0,a5
c0019d50:	a59ff0ef          	jal	ra,c00197a8 <Xil_In32>
c0019d54:	00050793          	mv	a5,a0
c0019d58:	f717f793          	andi	a5,a5,-143
c0019d5c:	00078593          	mv	a1,a5
c0019d60:	00048513          	mv	a0,s1
c0019d64:	a6dff0ef          	jal	ra,c00197d0 <Xil_Out32>

		/*
		 * If operating in Master mode, call status handler to indicate
		 * NOACK occured.
		 */
		IntrStatus = XIic_ReadIisr(InstancePtr->BaseAddress);
c0019d68:	fdc42783          	lw	a5,-36(s0)
c0019d6c:	00c7a783          	lw	a5,12(a5)
c0019d70:	02078793          	addi	a5,a5,32
c0019d74:	00078513          	mv	a0,a5
c0019d78:	a31ff0ef          	jal	ra,c00197a8 <Xil_In32>
c0019d7c:	fea42623          	sw	a0,-20(s0)
		if ((IntrStatus & XIIC_INTR_AAS_MASK) == 0) {
c0019d80:	fec42783          	lw	a5,-20(s0)
c0019d84:	0207f793          	andi	a5,a5,32
c0019d88:	02079263          	bnez	a5,c0019dac <TxErrorHandler+0xec>
			InstancePtr->StatusHandler(InstancePtr->
c0019d8c:	fdc42783          	lw	a5,-36(s0)
c0019d90:	0407a703          	lw	a4,64(a5)
c0019d94:	fdc42783          	lw	a5,-36(s0)
c0019d98:	0447a783          	lw	a5,68(a5)
c0019d9c:	00400593          	li	a1,4
c0019da0:	00078513          	mv	a0,a5
c0019da4:	000700e7          	jalr	a4
			 * implies transmit complete while sending as Slave
			 */
			 InstancePtr->Stats.TxErrors--;
		}

		return;
c0019da8:	1a40006f          	j	c0019f4c <TxErrorHandler+0x28c>
			 InstancePtr->Stats.TxErrors--;
c0019dac:	fdc42783          	lw	a5,-36(s0)
c0019db0:	0077c783          	lbu	a5,7(a5)
c0019db4:	fff78793          	addi	a5,a5,-1
c0019db8:	0ff7f713          	andi	a4,a5,255
c0019dbc:	fdc42783          	lw	a5,-36(s0)
c0019dc0:	00e783a3          	sb	a4,7(a5)
		return;
c0019dc4:	1880006f          	j	c0019f4c <TxErrorHandler+0x28c>
	 * When:master, indicates a master Receive with one byte received. When
	 * a byte is in Rx reg then the Tx error indicates the Rx data was
	 * recovered normally Tx errors are not enabled such that this should
	 * not occur.
	 */
	IntrStatus = XIic_ReadIisr(InstancePtr->BaseAddress);
c0019dc8:	fdc42783          	lw	a5,-36(s0)
c0019dcc:	00c7a783          	lw	a5,12(a5)
c0019dd0:	02078793          	addi	a5,a5,32
c0019dd4:	00078513          	mv	a0,a5
c0019dd8:	9d1ff0ef          	jal	ra,c00197a8 <Xil_In32>
c0019ddc:	fea42623          	sw	a0,-20(s0)
	if (IntrStatus & XIIC_INTR_RX_FULL_MASK) {
c0019de0:	fec42783          	lw	a5,-20(s0)
c0019de4:	0087f793          	andi	a5,a5,8
c0019de8:	02078e63          	beqz	a5,c0019e24 <TxErrorHandler+0x164>
		/* Rx Reg/FIFO has data,  Disable Tx error interrupts */

		XIic_DisableIntr(InstancePtr->BaseAddress,
c0019dec:	fdc42783          	lw	a5,-36(s0)
c0019df0:	00c7a783          	lw	a5,12(a5)
c0019df4:	02878493          	addi	s1,a5,40
c0019df8:	fdc42783          	lw	a5,-36(s0)
c0019dfc:	00c7a783          	lw	a5,12(a5)
c0019e00:	02878793          	addi	a5,a5,40
c0019e04:	00078513          	mv	a0,a5
c0019e08:	9a1ff0ef          	jal	ra,c00197a8 <Xil_In32>
c0019e0c:	00050793          	mv	a5,a0
c0019e10:	ffd7f793          	andi	a5,a5,-3
c0019e14:	00078593          	mv	a1,a5
c0019e18:	00048513          	mv	a0,s1
c0019e1c:	9b5ff0ef          	jal	ra,c00197d0 <Xil_Out32>
				  XIIC_INTR_TX_ERROR_MASK);
		return;
c0019e20:	12c0006f          	j	c0019f4c <TxErrorHandler+0x28c>
	}

	XIic_FlushTxFifo(InstancePtr);
c0019e24:	fdc42783          	lw	a5,-36(s0)
c0019e28:	00c7a783          	lw	a5,12(a5)
c0019e2c:	10078793          	addi	a5,a5,256
c0019e30:	00078513          	mv	a0,a5
c0019e34:	975ff0ef          	jal	ra,c00197a8 <Xil_In32>
c0019e38:	fea42423          	sw	a0,-24(s0)
c0019e3c:	fdc42783          	lw	a5,-36(s0)
c0019e40:	00c7a783          	lw	a5,12(a5)
c0019e44:	10078713          	addi	a4,a5,256
c0019e48:	fe842783          	lw	a5,-24(s0)
c0019e4c:	0027e793          	ori	a5,a5,2
c0019e50:	00078593          	mv	a1,a5
c0019e54:	00070513          	mv	a0,a4
c0019e58:	979ff0ef          	jal	ra,c00197d0 <Xil_Out32>
c0019e5c:	fdc42783          	lw	a5,-36(s0)
c0019e60:	00c7a783          	lw	a5,12(a5)
c0019e64:	10078793          	addi	a5,a5,256
c0019e68:	fe842583          	lw	a1,-24(s0)
c0019e6c:	00078513          	mv	a0,a5
c0019e70:	961ff0ef          	jal	ra,c00197d0 <Xil_Out32>

	/*
	 * Disable and clear Tx empty,  empty, Rx Full or Tx error interrupts.
	 */
	XIic_DisableIntr(InstancePtr->BaseAddress, XIIC_TX_RX_INTERRUPTS);
c0019e74:	fdc42783          	lw	a5,-36(s0)
c0019e78:	00c7a783          	lw	a5,12(a5)
c0019e7c:	02878493          	addi	s1,a5,40
c0019e80:	fdc42783          	lw	a5,-36(s0)
c0019e84:	00c7a783          	lw	a5,12(a5)
c0019e88:	02878793          	addi	a5,a5,40
c0019e8c:	00078513          	mv	a0,a5
c0019e90:	919ff0ef          	jal	ra,c00197a8 <Xil_In32>
c0019e94:	00050793          	mv	a5,a0
c0019e98:	f717f793          	andi	a5,a5,-143
c0019e9c:	00078593          	mv	a1,a5
c0019ea0:	00048513          	mv	a0,s1
c0019ea4:	92dff0ef          	jal	ra,c00197d0 <Xil_Out32>
	XIic_ClearIntr(InstancePtr->BaseAddress, XIIC_TX_RX_INTERRUPTS);
c0019ea8:	fdc42783          	lw	a5,-36(s0)
c0019eac:	00c7a783          	lw	a5,12(a5)
c0019eb0:	02078493          	addi	s1,a5,32
c0019eb4:	fdc42783          	lw	a5,-36(s0)
c0019eb8:	00c7a783          	lw	a5,12(a5)
c0019ebc:	02078793          	addi	a5,a5,32
c0019ec0:	00078513          	mv	a0,a5
c0019ec4:	8e5ff0ef          	jal	ra,c00197a8 <Xil_In32>
c0019ec8:	00050793          	mv	a5,a0
c0019ecc:	08e7f793          	andi	a5,a5,142
c0019ed0:	00078593          	mv	a1,a5
c0019ed4:	00048513          	mv	a0,s1
c0019ed8:	8f9ff0ef          	jal	ra,c00197d0 <Xil_Out32>

	/* Clear MSMS as on Tx error when Rxing, the bus will be
	 * stopped but MSMS bit is still set. Reset to proper state
	 */
	CntlReg = XIic_ReadReg(InstancePtr->BaseAddress, XIIC_CR_REG_OFFSET);
c0019edc:	fdc42783          	lw	a5,-36(s0)
c0019ee0:	00c7a783          	lw	a5,12(a5)
c0019ee4:	10078793          	addi	a5,a5,256
c0019ee8:	00078513          	mv	a0,a5
c0019eec:	8bdff0ef          	jal	ra,c00197a8 <Xil_In32>
c0019ef0:	fea42223          	sw	a0,-28(s0)
	CntlReg &= ~XIIC_CR_MSMS_MASK;
c0019ef4:	fe442783          	lw	a5,-28(s0)
c0019ef8:	ffb7f793          	andi	a5,a5,-5
c0019efc:	fef42223          	sw	a5,-28(s0)
	XIic_WriteReg(InstancePtr->BaseAddress, XIIC_CR_REG_OFFSET, CntlReg);
c0019f00:	fdc42783          	lw	a5,-36(s0)
c0019f04:	00c7a783          	lw	a5,12(a5)
c0019f08:	10078793          	addi	a5,a5,256
c0019f0c:	fe442583          	lw	a1,-28(s0)
c0019f10:	00078513          	mv	a0,a5
c0019f14:	8bdff0ef          	jal	ra,c00197d0 <Xil_Out32>

	/*
	 * Set FIFO occupancy depth = 1 so that the first byte will throttle
	 * next recieve msg.
	 */
	XIic_WriteReg(InstancePtr->BaseAddress, XIIC_RFD_REG_OFFSET, 0);
c0019f18:	fdc42783          	lw	a5,-36(s0)
c0019f1c:	00c7a783          	lw	a5,12(a5)
c0019f20:	12078793          	addi	a5,a5,288
c0019f24:	00000593          	li	a1,0
c0019f28:	00078513          	mv	a0,a5
c0019f2c:	8a5ff0ef          	jal	ra,c00197d0 <Xil_Out32>

	/*
	 * Call the event callback.
	 */
	InstancePtr->StatusHandler(InstancePtr->StatusCallBackRef,
c0019f30:	fdc42783          	lw	a5,-36(s0)
c0019f34:	0407a703          	lw	a4,64(a5)
c0019f38:	fdc42783          	lw	a5,-36(s0)
c0019f3c:	0447a783          	lw	a5,68(a5)
c0019f40:	00400593          	li	a1,4
c0019f44:	00078513          	mv	a0,a5
c0019f48:	000700e7          	jalr	a4
				   XII_SLAVE_NO_ACK_EVENT);
}
c0019f4c:	02c12083          	lw	ra,44(sp)
c0019f50:	02812403          	lw	s0,40(sp)
c0019f54:	02412483          	lw	s1,36(sp)
c0019f58:	03010113          	addi	sp,sp,48
c0019f5c:	00008067          	ret

c0019f60 <StubFunction>:
*
* @param	InstancePtr is a pointer to the XIic instance to be worked on.
*
******************************************************************************/
static void StubFunction(XIic *InstancePtr)
{
c0019f60:	fe010113          	addi	sp,sp,-32
c0019f64:	00112e23          	sw	ra,28(sp)
c0019f68:	00812c23          	sw	s0,24(sp)
c0019f6c:	02010413          	addi	s0,sp,32
c0019f70:	fea42623          	sw	a0,-20(s0)
	(void )InstancePtr;
	Xil_AssertVoidAlways();
c0019f74:	1b800593          	li	a1,440
c0019f78:	07fe8517          	auipc	a0,0x7fe8
c0019f7c:	99050513          	addi	a0,a0,-1648 # c8001908 <__rodata_start+0x1908>
c0019f80:	33d030ef          	jal	ra,c001dabc <Xil_Assert>
c0019f84:	07fe9797          	auipc	a5,0x7fe9
c0019f88:	99078793          	addi	a5,a5,-1648 # c8002914 <Xil_AssertStatus>
c0019f8c:	00100713          	li	a4,1
c0019f90:	00e7a023          	sw	a4,0(a5)
c0019f94:	00000013          	nop
}
c0019f98:	01c12083          	lw	ra,28(sp)
c0019f9c:	01812403          	lw	s0,24(sp)
c0019fa0:	02010113          	addi	sp,sp,32
c0019fa4:	00008067          	ret

c0019fa8 <XIic_GetStats>:
*
* @note		None.
*
****************************************************************************/
void XIic_GetStats(XIic *InstancePtr, XIicStats * StatsPtr)
{
c0019fa8:	fd010113          	addi	sp,sp,-48
c0019fac:	02112623          	sw	ra,44(sp)
c0019fb0:	02812423          	sw	s0,40(sp)
c0019fb4:	03010413          	addi	s0,sp,48
c0019fb8:	fca42e23          	sw	a0,-36(s0)
c0019fbc:	fcb42c23          	sw	a1,-40(s0)
	u8 NumBytes;
	u8 *SrcPtr;
	u8 *DestPtr;

	Xil_AssertVoid(InstancePtr->IsReady == XIL_COMPONENT_IS_READY);
c0019fc0:	fdc42783          	lw	a5,-36(s0)
c0019fc4:	0147a703          	lw	a4,20(a5)
c0019fc8:	111117b7          	lui	a5,0x11111
c0019fcc:	11178793          	addi	a5,a5,273 # 11111111 <_DMEM_LENGTH+0x10911111>
c0019fd0:	00f71e63          	bne	a4,a5,c0019fec <XIic_GetStats+0x44>
c0019fd4:	07fe9797          	auipc	a5,0x7fe9
c0019fd8:	94078793          	addi	a5,a5,-1728 # c8002914 <Xil_AssertStatus>
c0019fdc:	0007a023          	sw	zero,0(a5)
	Xil_AssertVoid(InstancePtr != NULL);
c0019fe0:	fdc42783          	lw	a5,-36(s0)
c0019fe4:	04078263          	beqz	a5,c001a028 <XIic_GetStats+0x80>
c0019fe8:	0280006f          	j	c001a010 <XIic_GetStats+0x68>
	Xil_AssertVoid(InstancePtr->IsReady == XIL_COMPONENT_IS_READY);
c0019fec:	05800593          	li	a1,88
c0019ff0:	07fe8517          	auipc	a0,0x7fe8
c0019ff4:	93450513          	addi	a0,a0,-1740 # c8001924 <__rodata_start+0x1924>
c0019ff8:	2c5030ef          	jal	ra,c001dabc <Xil_Assert>
c0019ffc:	07fe9797          	auipc	a5,0x7fe9
c001a000:	91878793          	addi	a5,a5,-1768 # c8002914 <Xil_AssertStatus>
c001a004:	00100713          	li	a4,1
c001a008:	00e7a023          	sw	a4,0(a5)
c001a00c:	0c00006f          	j	c001a0cc <XIic_GetStats+0x124>
	Xil_AssertVoid(InstancePtr != NULL);
c001a010:	07fe9797          	auipc	a5,0x7fe9
c001a014:	90478793          	addi	a5,a5,-1788 # c8002914 <Xil_AssertStatus>
c001a018:	0007a023          	sw	zero,0(a5)
	Xil_AssertVoid(StatsPtr != NULL);
c001a01c:	fd842783          	lw	a5,-40(s0)
c001a020:	04078863          	beqz	a5,c001a070 <XIic_GetStats+0xc8>
c001a024:	0280006f          	j	c001a04c <XIic_GetStats+0xa4>
	Xil_AssertVoid(InstancePtr != NULL);
c001a028:	05900593          	li	a1,89
c001a02c:	07fe8517          	auipc	a0,0x7fe8
c001a030:	8f850513          	addi	a0,a0,-1800 # c8001924 <__rodata_start+0x1924>
c001a034:	289030ef          	jal	ra,c001dabc <Xil_Assert>
c001a038:	07fe9797          	auipc	a5,0x7fe9
c001a03c:	8dc78793          	addi	a5,a5,-1828 # c8002914 <Xil_AssertStatus>
c001a040:	00100713          	li	a4,1
c001a044:	00e7a023          	sw	a4,0(a5)
c001a048:	0840006f          	j	c001a0cc <XIic_GetStats+0x124>
	Xil_AssertVoid(StatsPtr != NULL);
c001a04c:	07fe9797          	auipc	a5,0x7fe9
c001a050:	8c878793          	addi	a5,a5,-1848 # c8002914 <Xil_AssertStatus>
c001a054:	0007a023          	sw	zero,0(a5)

	/*
	 * Setup pointers to copy the stats structure
	 */
	SrcPtr = (u8 *) &InstancePtr->Stats;
c001a058:	fdc42783          	lw	a5,-36(s0)
c001a05c:	fef42423          	sw	a5,-24(s0)
	DestPtr = (u8 *) StatsPtr;
c001a060:	fd842783          	lw	a5,-40(s0)
c001a064:	fef42223          	sw	a5,-28(s0)

	/*
	 * Copy the current statistics to the structure passed in
	 */
	for (NumBytes = 0; NumBytes < sizeof(XIicStats); NumBytes++) {
c001a068:	fe0407a3          	sb	zero,-17(s0)
c001a06c:	0540006f          	j	c001a0c0 <XIic_GetStats+0x118>
	Xil_AssertVoid(StatsPtr != NULL);
c001a070:	05a00593          	li	a1,90
c001a074:	07fe8517          	auipc	a0,0x7fe8
c001a078:	8b050513          	addi	a0,a0,-1872 # c8001924 <__rodata_start+0x1924>
c001a07c:	241030ef          	jal	ra,c001dabc <Xil_Assert>
c001a080:	07fe9797          	auipc	a5,0x7fe9
c001a084:	89478793          	addi	a5,a5,-1900 # c8002914 <Xil_AssertStatus>
c001a088:	00100713          	li	a4,1
c001a08c:	00e7a023          	sw	a4,0(a5)
c001a090:	03c0006f          	j	c001a0cc <XIic_GetStats+0x124>
		*DestPtr++ = *SrcPtr++;
c001a094:	fe842703          	lw	a4,-24(s0)
c001a098:	00170793          	addi	a5,a4,1
c001a09c:	fef42423          	sw	a5,-24(s0)
c001a0a0:	fe442783          	lw	a5,-28(s0)
c001a0a4:	00178693          	addi	a3,a5,1
c001a0a8:	fed42223          	sw	a3,-28(s0)
c001a0ac:	00074703          	lbu	a4,0(a4)
c001a0b0:	00e78023          	sb	a4,0(a5)
	for (NumBytes = 0; NumBytes < sizeof(XIicStats); NumBytes++) {
c001a0b4:	fef44783          	lbu	a5,-17(s0)
c001a0b8:	00178793          	addi	a5,a5,1
c001a0bc:	fef407a3          	sb	a5,-17(s0)
c001a0c0:	fef44703          	lbu	a4,-17(s0)
c001a0c4:	00800793          	li	a5,8
c001a0c8:	fce7f6e3          	bgeu	a5,a4,c001a094 <XIic_GetStats+0xec>
	}
}
c001a0cc:	02c12083          	lw	ra,44(sp)
c001a0d0:	02812403          	lw	s0,40(sp)
c001a0d4:	03010113          	addi	sp,sp,48
c001a0d8:	00008067          	ret

c001a0dc <XIic_ClearStats>:
*
* @note		None.
*
****************************************************************************/
void XIic_ClearStats(XIic *InstancePtr)
{
c001a0dc:	fd010113          	addi	sp,sp,-48
c001a0e0:	02112623          	sw	ra,44(sp)
c001a0e4:	02812423          	sw	s0,40(sp)
c001a0e8:	03010413          	addi	s0,sp,48
c001a0ec:	fca42e23          	sw	a0,-36(s0)
	u8 NumBytes;
	u8 *DestPtr;

	Xil_AssertVoid(InstancePtr->IsReady == XIL_COMPONENT_IS_READY);
c001a0f0:	fdc42783          	lw	a5,-36(s0)
c001a0f4:	0147a703          	lw	a4,20(a5)
c001a0f8:	111117b7          	lui	a5,0x11111
c001a0fc:	11178793          	addi	a5,a5,273 # 11111111 <_DMEM_LENGTH+0x10911111>
c001a100:	00f71e63          	bne	a4,a5,c001a11c <XIic_ClearStats+0x40>
c001a104:	07fe9797          	auipc	a5,0x7fe9
c001a108:	81078793          	addi	a5,a5,-2032 # c8002914 <Xil_AssertStatus>
c001a10c:	0007a023          	sw	zero,0(a5)
	Xil_AssertVoid(InstancePtr != NULL);
c001a110:	fdc42783          	lw	a5,-36(s0)
c001a114:	04078463          	beqz	a5,c001a15c <XIic_ClearStats+0x80>
c001a118:	0280006f          	j	c001a140 <XIic_ClearStats+0x64>
	Xil_AssertVoid(InstancePtr->IsReady == XIL_COMPONENT_IS_READY);
c001a11c:	07b00593          	li	a1,123
c001a120:	07fe8517          	auipc	a0,0x7fe8
c001a124:	80450513          	addi	a0,a0,-2044 # c8001924 <__rodata_start+0x1924>
c001a128:	195030ef          	jal	ra,c001dabc <Xil_Assert>
c001a12c:	07fe8797          	auipc	a5,0x7fe8
c001a130:	7e878793          	addi	a5,a5,2024 # c8002914 <Xil_AssertStatus>
c001a134:	00100713          	li	a4,1
c001a138:	00e7a023          	sw	a4,0(a5)
c001a13c:	06c0006f          	j	c001a1a8 <XIic_ClearStats+0xcc>
	Xil_AssertVoid(InstancePtr != NULL);
c001a140:	07fe8797          	auipc	a5,0x7fe8
c001a144:	7d478793          	addi	a5,a5,2004 # c8002914 <Xil_AssertStatus>
c001a148:	0007a023          	sw	zero,0(a5)

	DestPtr = (u8 *)&InstancePtr->Stats;
c001a14c:	fdc42783          	lw	a5,-36(s0)
c001a150:	fef42423          	sw	a5,-24(s0)
	for (NumBytes = 0; NumBytes < sizeof(XIicStats); NumBytes++) {
c001a154:	fe0407a3          	sb	zero,-17(s0)
c001a158:	0440006f          	j	c001a19c <XIic_ClearStats+0xc0>
	Xil_AssertVoid(InstancePtr != NULL);
c001a15c:	07c00593          	li	a1,124
c001a160:	07fe7517          	auipc	a0,0x7fe7
c001a164:	7c450513          	addi	a0,a0,1988 # c8001924 <__rodata_start+0x1924>
c001a168:	155030ef          	jal	ra,c001dabc <Xil_Assert>
c001a16c:	07fe8797          	auipc	a5,0x7fe8
c001a170:	7a878793          	addi	a5,a5,1960 # c8002914 <Xil_AssertStatus>
c001a174:	00100713          	li	a4,1
c001a178:	00e7a023          	sw	a4,0(a5)
c001a17c:	02c0006f          	j	c001a1a8 <XIic_ClearStats+0xcc>
		*DestPtr++ = 0;
c001a180:	fe842783          	lw	a5,-24(s0)
c001a184:	00178713          	addi	a4,a5,1
c001a188:	fee42423          	sw	a4,-24(s0)
c001a18c:	00078023          	sb	zero,0(a5)
	for (NumBytes = 0; NumBytes < sizeof(XIicStats); NumBytes++) {
c001a190:	fef44783          	lbu	a5,-17(s0)
c001a194:	00178793          	addi	a5,a5,1
c001a198:	fef407a3          	sb	a5,-17(s0)
c001a19c:	fef44703          	lbu	a4,-17(s0)
c001a1a0:	00800793          	li	a5,8
c001a1a4:	fce7fee3          	bgeu	a5,a4,c001a180 <XIic_ClearStats+0xa4>
	}

}
c001a1a8:	02c12083          	lw	ra,44(sp)
c001a1ac:	02812403          	lw	s0,40(sp)
c001a1b0:	03010113          	addi	sp,sp,48
c001a1b4:	00008067          	ret

c001a1b8 <Xil_In32>:
{
c001a1b8:	fe010113          	addi	sp,sp,-32
c001a1bc:	00812e23          	sw	s0,28(sp)
c001a1c0:	02010413          	addi	s0,sp,32
c001a1c4:	fea42623          	sw	a0,-20(s0)
	return *(volatile u32 *) Addr;
c001a1c8:	fec42783          	lw	a5,-20(s0)
c001a1cc:	0007a783          	lw	a5,0(a5)
}
c001a1d0:	00078513          	mv	a0,a5
c001a1d4:	01c12403          	lw	s0,28(sp)
c001a1d8:	02010113          	addi	sp,sp,32
c001a1dc:	00008067          	ret

c001a1e0 <Xil_Out32>:
{
c001a1e0:	fd010113          	addi	sp,sp,-48
c001a1e4:	02812623          	sw	s0,44(sp)
c001a1e8:	03010413          	addi	s0,sp,48
c001a1ec:	fca42e23          	sw	a0,-36(s0)
c001a1f0:	fcb42c23          	sw	a1,-40(s0)
	volatile u32 *LocalAddr = (volatile u32 *)Addr;
c001a1f4:	fdc42783          	lw	a5,-36(s0)
c001a1f8:	fef42623          	sw	a5,-20(s0)
	*LocalAddr = Value;
c001a1fc:	fec42783          	lw	a5,-20(s0)
c001a200:	fd842703          	lw	a4,-40(s0)
c001a204:	00e7a023          	sw	a4,0(a5)
}
c001a208:	00000013          	nop
c001a20c:	02c12403          	lw	s0,44(sp)
c001a210:	03010113          	addi	sp,sp,48
c001a214:	00008067          	ret

c001a218 <XSpi_CfgInitialize>:
* @note		None.
*
******************************************************************************/
int XSpi_CfgInitialize(XSpi *InstancePtr, XSpi_Config *Config,
			UINTPTR EffectiveAddr)
{
c001a218:	fd010113          	addi	sp,sp,-48
c001a21c:	02112623          	sw	ra,44(sp)
c001a220:	02812423          	sw	s0,40(sp)
c001a224:	03010413          	addi	s0,sp,48
c001a228:	fca42e23          	sw	a0,-36(s0)
c001a22c:	fcb42c23          	sw	a1,-40(s0)
c001a230:	fcc42a23          	sw	a2,-44(s0)
	u8  Buffer[3];
	u32 ControlReg;
	u32 StatusReg;
	
	Xil_AssertNonvoid(InstancePtr != NULL);
c001a234:	fdc42783          	lw	a5,-36(s0)
c001a238:	02078463          	beqz	a5,c001a260 <XSpi_CfgInitialize+0x48>
c001a23c:	07fe8797          	auipc	a5,0x7fe8
c001a240:	6d878793          	addi	a5,a5,1752 # c8002914 <Xil_AssertStatus>
c001a244:	0007a023          	sw	zero,0(a5)
	 * If the device is started, disallow the initialize and return a status
	 * indicating it is started.  This allows the user to stop the device
	 * and reinitialize, but prevents a user from inadvertently
	 * initializing.
	 */
	if (InstancePtr->IsStarted == XIL_COMPONENT_IS_STARTED) {
c001a248:	fdc42783          	lw	a5,-36(s0)
c001a24c:	0207a703          	lw	a4,32(a5)
c001a250:	222227b7          	lui	a5,0x22222
c001a254:	22278793          	addi	a5,a5,546 # 22222222 <_DMEM_LENGTH+0x21a22222>
c001a258:	02f71c63          	bne	a4,a5,c001a290 <XSpi_CfgInitialize+0x78>
c001a25c:	02c0006f          	j	c001a288 <XSpi_CfgInitialize+0x70>
	Xil_AssertNonvoid(InstancePtr != NULL);
c001a260:	0a900593          	li	a1,169
c001a264:	07fe7517          	auipc	a0,0x7fe7
c001a268:	6dc50513          	addi	a0,a0,1756 # c8001940 <__rodata_start+0x1940>
c001a26c:	051030ef          	jal	ra,c001dabc <Xil_Assert>
c001a270:	07fe8797          	auipc	a5,0x7fe8
c001a274:	6a478793          	addi	a5,a5,1700 # c8002914 <Xil_AssertStatus>
c001a278:	00100713          	li	a4,1
c001a27c:	00e7a023          	sw	a4,0(a5)
c001a280:	00000793          	li	a5,0
c001a284:	2fc0006f          	j	c001a580 <XSpi_CfgInitialize+0x368>
		return XST_DEVICE_IS_STARTED;
c001a288:	00500793          	li	a5,5
c001a28c:	2f40006f          	j	c001a580 <XSpi_CfgInitialize+0x368>
	}

	/*
	 * Set some default values.
	 */
	InstancePtr->IsStarted = 0;
c001a290:	fdc42783          	lw	a5,-36(s0)
c001a294:	0207a023          	sw	zero,32(a5)
	InstancePtr->IsBusy = FALSE;
c001a298:	fdc42783          	lw	a5,-36(s0)
c001a29c:	0407a423          	sw	zero,72(a5)

	InstancePtr->StatusHandler = StubStatusHandler;
c001a2a0:	fdc42783          	lw	a5,-36(s0)
c001a2a4:	00001717          	auipc	a4,0x1
c001a2a8:	13870713          	addi	a4,a4,312 # c001b3dc <StubStatusHandler>
c001a2ac:	04e7a623          	sw	a4,76(a5)

	InstancePtr->SendBufferPtr = NULL;
c001a2b0:	fdc42783          	lw	a5,-36(s0)
c001a2b4:	0207ac23          	sw	zero,56(a5)
	InstancePtr->RecvBufferPtr = NULL;
c001a2b8:	fdc42783          	lw	a5,-36(s0)
c001a2bc:	0207ae23          	sw	zero,60(a5)
	InstancePtr->RequestedBytes = 0;
c001a2c0:	fdc42783          	lw	a5,-36(s0)
c001a2c4:	0407a023          	sw	zero,64(a5)
	InstancePtr->RemainingBytes = 0;
c001a2c8:	fdc42783          	lw	a5,-36(s0)
c001a2cc:	0407a223          	sw	zero,68(a5)
	InstancePtr->BaseAddr = EffectiveAddr;
c001a2d0:	fdc42783          	lw	a5,-36(s0)
c001a2d4:	fd442703          	lw	a4,-44(s0)
c001a2d8:	00e7ac23          	sw	a4,24(a5)
	InstancePtr->HasFifos = Config->HasFifos;
c001a2dc:	fd842783          	lw	a5,-40(s0)
c001a2e0:	0087a703          	lw	a4,8(a5)
c001a2e4:	fdc42783          	lw	a5,-36(s0)
c001a2e8:	02e7a223          	sw	a4,36(a5)
	InstancePtr->SlaveOnly = Config->SlaveOnly;
c001a2ec:	fd842783          	lw	a5,-40(s0)
c001a2f0:	00c7a703          	lw	a4,12(a5)
c001a2f4:	fdc42783          	lw	a5,-36(s0)
c001a2f8:	02e7a423          	sw	a4,40(a5)
	InstancePtr->NumSlaveBits = Config->NumSlaveBits;
c001a2fc:	fd842783          	lw	a5,-40(s0)
c001a300:	0107c703          	lbu	a4,16(a5)
c001a304:	fdc42783          	lw	a5,-36(s0)
c001a308:	02e78623          	sb	a4,44(a5)
	if (Config->DataWidth == 0) {
c001a30c:	fd842783          	lw	a5,-40(s0)
c001a310:	0117c783          	lbu	a5,17(a5)
c001a314:	00079a63          	bnez	a5,c001a328 <XSpi_CfgInitialize+0x110>
		InstancePtr->DataWidth = XSP_DATAWIDTH_BYTE;
c001a318:	fdc42783          	lw	a5,-36(s0)
c001a31c:	00800713          	li	a4,8
c001a320:	02e786a3          	sb	a4,45(a5)
c001a324:	0140006f          	j	c001a338 <XSpi_CfgInitialize+0x120>
	} else {
		InstancePtr->DataWidth = Config->DataWidth;
c001a328:	fd842783          	lw	a5,-40(s0)
c001a32c:	0117c703          	lbu	a4,17(a5)
c001a330:	fdc42783          	lw	a5,-36(s0)
c001a334:	02e786a3          	sb	a4,45(a5)
	}

	InstancePtr->SpiMode = Config->SpiMode;
c001a338:	fd842783          	lw	a5,-40(s0)
c001a33c:	0127c703          	lbu	a4,18(a5)
c001a340:	fdc42783          	lw	a5,-36(s0)
c001a344:	02e78723          	sb	a4,46(a5)

	InstancePtr->FlashBaseAddr = Config->AxiFullBaseAddress;
c001a348:	fd842783          	lw	a5,-40(s0)
c001a34c:	0147a703          	lw	a4,20(a5)
c001a350:	fdc42783          	lw	a5,-36(s0)
c001a354:	04e7aa23          	sw	a4,84(a5)
	InstancePtr->XipMode = Config->XipMode;
c001a358:	fd842783          	lw	a5,-40(s0)
c001a35c:	0187c703          	lbu	a4,24(a5)
c001a360:	fdc42783          	lw	a5,-36(s0)
c001a364:	04e78c23          	sb	a4,88(a5)

	InstancePtr->IsReady = XIL_COMPONENT_IS_READY;
c001a368:	fdc42783          	lw	a5,-36(s0)
c001a36c:	11111737          	lui	a4,0x11111
c001a370:	11170713          	addi	a4,a4,273 # 11111111 <_DMEM_LENGTH+0x10911111>
c001a374:	00e7ae23          	sw	a4,28(a5)
	/*
	 * Create a slave select mask based on the number of bits that can
	 * be used to deselect all slaves, initialize the value to put into
	 * the slave select register to this value.
	 */
	InstancePtr->SlaveSelectMask = (1 << InstancePtr->NumSlaveBits) - 1;
c001a378:	fdc42783          	lw	a5,-36(s0)
c001a37c:	02c7c783          	lbu	a5,44(a5)
c001a380:	00078713          	mv	a4,a5
c001a384:	00100793          	li	a5,1
c001a388:	00e797b3          	sll	a5,a5,a4
c001a38c:	fff78793          	addi	a5,a5,-1
c001a390:	00078713          	mv	a4,a5
c001a394:	fdc42783          	lw	a5,-36(s0)
c001a398:	02e7a823          	sw	a4,48(a5)
	InstancePtr->SlaveSelectReg = InstancePtr->SlaveSelectMask;
c001a39c:	fdc42783          	lw	a5,-36(s0)
c001a3a0:	0307a703          	lw	a4,48(a5)
c001a3a4:	fdc42783          	lw	a5,-36(s0)
c001a3a8:	02e7aa23          	sw	a4,52(a5)

	/*
	 * Clear the statistics for this driver.
	 */
	InstancePtr->Stats.ModeFaults = 0;
c001a3ac:	fdc42783          	lw	a5,-36(s0)
c001a3b0:	0007a023          	sw	zero,0(a5)
	InstancePtr->Stats.XmitUnderruns = 0;
c001a3b4:	fdc42783          	lw	a5,-36(s0)
c001a3b8:	0007a223          	sw	zero,4(a5)
	InstancePtr->Stats.RecvOverruns = 0;
c001a3bc:	fdc42783          	lw	a5,-36(s0)
c001a3c0:	0007a423          	sw	zero,8(a5)
	InstancePtr->Stats.SlaveModeFaults = 0;
c001a3c4:	fdc42783          	lw	a5,-36(s0)
c001a3c8:	0007a623          	sw	zero,12(a5)
	InstancePtr->Stats.BytesTransferred = 0;
c001a3cc:	fdc42783          	lw	a5,-36(s0)
c001a3d0:	0007a823          	sw	zero,16(a5)
	InstancePtr->Stats.NumInterrupts = 0;
c001a3d4:	fdc42783          	lw	a5,-36(s0)
c001a3d8:	0007aa23          	sw	zero,20(a5)
	
        if(Config->Use_Startup == 1) {
c001a3dc:	fd842783          	lw	a5,-40(s0)
c001a3e0:	0197c703          	lbu	a4,25(a5)
c001a3e4:	00100793          	li	a5,1
c001a3e8:	18f71663          	bne	a4,a5,c001a574 <XSpi_CfgInitialize+0x35c>
		/*  
		 * Perform a dummy read this is used when startup block is
		 * enabled in the hardware to fix CR #721229.
		 */
		ControlReg = XSpi_GetControlReg(InstancePtr);
c001a3ec:	fdc42783          	lw	a5,-36(s0)
c001a3f0:	0187a783          	lw	a5,24(a5)
c001a3f4:	06078793          	addi	a5,a5,96
c001a3f8:	00078513          	mv	a0,a5
c001a3fc:	dbdff0ef          	jal	ra,c001a1b8 <Xil_In32>
c001a400:	fea42623          	sw	a0,-20(s0)
		ControlReg |= XSP_CR_TXFIFO_RESET_MASK | XSP_CR_RXFIFO_RESET_MASK |
c001a404:	fec42783          	lw	a5,-20(s0)
c001a408:	0667e793          	ori	a5,a5,102
c001a40c:	fef42623          	sw	a5,-20(s0)
				XSP_CR_ENABLE_MASK | XSP_CR_MASTER_MODE_MASK ;
		XSpi_SetControlReg(InstancePtr, ControlReg);
c001a410:	fdc42783          	lw	a5,-36(s0)
c001a414:	0187a783          	lw	a5,24(a5)
c001a418:	06078793          	addi	a5,a5,96
c001a41c:	fec42583          	lw	a1,-20(s0)
c001a420:	00078513          	mv	a0,a5
c001a424:	dbdff0ef          	jal	ra,c001a1e0 <Xil_Out32>
		 *
		 * NOTE: If user interfaces different flash to the SPI controller 
		 * this command need to be changed according to target flash Read
		 * command.
		 */
		Buffer[0] = 0x9F;
c001a428:	f9f00793          	li	a5,-97
c001a42c:	fef40223          	sb	a5,-28(s0)
		Buffer[1] = 0x00;
c001a430:	fe0402a3          	sb	zero,-27(s0)
		Buffer[2] = 0x00;
c001a434:	fe040323          	sb	zero,-26(s0)
	
		/* Write dummy ReadId to the DTR register */
		XSpi_WriteReg(InstancePtr->BaseAddr, XSP_DTR_OFFSET, Buffer[0]);
c001a438:	fdc42783          	lw	a5,-36(s0)
c001a43c:	0187a783          	lw	a5,24(a5)
c001a440:	06878793          	addi	a5,a5,104
c001a444:	fe444703          	lbu	a4,-28(s0)
c001a448:	00070593          	mv	a1,a4
c001a44c:	00078513          	mv	a0,a5
c001a450:	d91ff0ef          	jal	ra,c001a1e0 <Xil_Out32>
		XSpi_WriteReg(InstancePtr->BaseAddr, XSP_DTR_OFFSET, Buffer[1]);
c001a454:	fdc42783          	lw	a5,-36(s0)
c001a458:	0187a783          	lw	a5,24(a5)
c001a45c:	06878793          	addi	a5,a5,104
c001a460:	fe544703          	lbu	a4,-27(s0)
c001a464:	00070593          	mv	a1,a4
c001a468:	00078513          	mv	a0,a5
c001a46c:	d75ff0ef          	jal	ra,c001a1e0 <Xil_Out32>
		XSpi_WriteReg(InstancePtr->BaseAddr, XSP_DTR_OFFSET, Buffer[2]);
c001a470:	fdc42783          	lw	a5,-36(s0)
c001a474:	0187a783          	lw	a5,24(a5)
c001a478:	06878793          	addi	a5,a5,104
c001a47c:	fe644703          	lbu	a4,-26(s0)
c001a480:	00070593          	mv	a1,a4
c001a484:	00078513          	mv	a0,a5
c001a488:	d59ff0ef          	jal	ra,c001a1e0 <Xil_Out32>
	
		/* Master Inhibit enable in the CR */
		ControlReg = XSpi_GetControlReg(InstancePtr);
c001a48c:	fdc42783          	lw	a5,-36(s0)
c001a490:	0187a783          	lw	a5,24(a5)
c001a494:	06078793          	addi	a5,a5,96
c001a498:	00078513          	mv	a0,a5
c001a49c:	d1dff0ef          	jal	ra,c001a1b8 <Xil_In32>
c001a4a0:	fea42623          	sw	a0,-20(s0)
		ControlReg &= ~XSP_CR_TRANS_INHIBIT_MASK;
c001a4a4:	fec42783          	lw	a5,-20(s0)
c001a4a8:	eff7f793          	andi	a5,a5,-257
c001a4ac:	fef42623          	sw	a5,-20(s0)
		XSpi_SetControlReg(InstancePtr, ControlReg);
c001a4b0:	fdc42783          	lw	a5,-36(s0)
c001a4b4:	0187a783          	lw	a5,24(a5)
c001a4b8:	06078793          	addi	a5,a5,96
c001a4bc:	fec42583          	lw	a1,-20(s0)
c001a4c0:	00078513          	mv	a0,a5
c001a4c4:	d1dff0ef          	jal	ra,c001a1e0 <Xil_Out32>
	
		/* Master Inhibit disable in the CR */
		ControlReg = XSpi_GetControlReg(InstancePtr);
c001a4c8:	fdc42783          	lw	a5,-36(s0)
c001a4cc:	0187a783          	lw	a5,24(a5)
c001a4d0:	06078793          	addi	a5,a5,96
c001a4d4:	00078513          	mv	a0,a5
c001a4d8:	ce1ff0ef          	jal	ra,c001a1b8 <Xil_In32>
c001a4dc:	fea42623          	sw	a0,-20(s0)
		ControlReg |= XSP_CR_TRANS_INHIBIT_MASK;
c001a4e0:	fec42783          	lw	a5,-20(s0)
c001a4e4:	1007e793          	ori	a5,a5,256
c001a4e8:	fef42623          	sw	a5,-20(s0)
		XSpi_SetControlReg(InstancePtr, ControlReg);
c001a4ec:	fdc42783          	lw	a5,-36(s0)
c001a4f0:	0187a783          	lw	a5,24(a5)
c001a4f4:	06078793          	addi	a5,a5,96
c001a4f8:	fec42583          	lw	a1,-20(s0)
c001a4fc:	00078513          	mv	a0,a5
c001a500:	ce1ff0ef          	jal	ra,c001a1e0 <Xil_Out32>
		
		/* Read the Rx Data Register */
		StatusReg = XSpi_GetStatusReg(InstancePtr);
c001a504:	fdc42783          	lw	a5,-36(s0)
c001a508:	0187a783          	lw	a5,24(a5)
c001a50c:	06478793          	addi	a5,a5,100
c001a510:	00078513          	mv	a0,a5
c001a514:	ca5ff0ef          	jal	ra,c001a1b8 <Xil_In32>
c001a518:	fea42423          	sw	a0,-24(s0)
		if ((StatusReg & XSP_SR_RX_EMPTY_MASK) == 0) {
c001a51c:	fe842783          	lw	a5,-24(s0)
c001a520:	0017f793          	andi	a5,a5,1
c001a524:	00079c63          	bnez	a5,c001a53c <XSpi_CfgInitialize+0x324>
			XSpi_ReadReg(InstancePtr->BaseAddr, XSP_DRR_OFFSET);
c001a528:	fdc42783          	lw	a5,-36(s0)
c001a52c:	0187a783          	lw	a5,24(a5)
c001a530:	06c78793          	addi	a5,a5,108
c001a534:	00078513          	mv	a0,a5
c001a538:	c81ff0ef          	jal	ra,c001a1b8 <Xil_In32>
		}
		StatusReg = XSpi_GetStatusReg(InstancePtr);
c001a53c:	fdc42783          	lw	a5,-36(s0)
c001a540:	0187a783          	lw	a5,24(a5)
c001a544:	06478793          	addi	a5,a5,100
c001a548:	00078513          	mv	a0,a5
c001a54c:	c6dff0ef          	jal	ra,c001a1b8 <Xil_In32>
c001a550:	fea42423          	sw	a0,-24(s0)
		if ((StatusReg & XSP_SR_RX_EMPTY_MASK) == 0) {
c001a554:	fe842783          	lw	a5,-24(s0)
c001a558:	0017f793          	andi	a5,a5,1
c001a55c:	00079c63          	bnez	a5,c001a574 <XSpi_CfgInitialize+0x35c>
			XSpi_ReadReg(InstancePtr->BaseAddr, XSP_DRR_OFFSET);
c001a560:	fdc42783          	lw	a5,-36(s0)
c001a564:	0187a783          	lw	a5,24(a5)
c001a568:	06c78793          	addi	a5,a5,108
c001a56c:	00078513          	mv	a0,a5
c001a570:	c49ff0ef          	jal	ra,c001a1b8 <Xil_In32>
	/*
	 * Reset the SPI device to get it into its initial state. It is expected
	 * that device configuration will take place after this initialization
	 * is done, but before the device is started.
	 */
	XSpi_Reset(InstancePtr);
c001a574:	fdc42503          	lw	a0,-36(s0)
c001a578:	2bc000ef          	jal	ra,c001a834 <XSpi_Reset>

	return XST_SUCCESS;
c001a57c:	00000793          	li	a5,0
}
c001a580:	00078513          	mv	a0,a5
c001a584:	02c12083          	lw	ra,44(sp)
c001a588:	02812403          	lw	s0,40(sp)
c001a58c:	03010113          	addi	sp,sp,48
c001a590:	00008067          	ret

c001a594 <XSpi_Start>:
*
* @note		None.
*
******************************************************************************/
int XSpi_Start(XSpi *InstancePtr)
{
c001a594:	fd010113          	addi	sp,sp,-48
c001a598:	02112623          	sw	ra,44(sp)
c001a59c:	02812423          	sw	s0,40(sp)
c001a5a0:	02912223          	sw	s1,36(sp)
c001a5a4:	03010413          	addi	s0,sp,48
c001a5a8:	fca42e23          	sw	a0,-36(s0)
	u32 ControlReg;

	Xil_AssertNonvoid(InstancePtr != NULL);
c001a5ac:	fdc42783          	lw	a5,-36(s0)
c001a5b0:	02078463          	beqz	a5,c001a5d8 <XSpi_Start+0x44>
c001a5b4:	07fe8797          	auipc	a5,0x7fe8
c001a5b8:	36078793          	addi	a5,a5,864 # c8002914 <Xil_AssertStatus>
c001a5bc:	0007a023          	sw	zero,0(a5)
	Xil_AssertNonvoid(InstancePtr->IsReady == XIL_COMPONENT_IS_READY);
c001a5c0:	fdc42783          	lw	a5,-36(s0)
c001a5c4:	01c7a703          	lw	a4,28(a5)
c001a5c8:	111117b7          	lui	a5,0x11111
c001a5cc:	11178793          	addi	a5,a5,273 # 11111111 <_DMEM_LENGTH+0x10911111>
c001a5d0:	04f71a63          	bne	a4,a5,c001a624 <XSpi_Start+0x90>
c001a5d4:	02c0006f          	j	c001a600 <XSpi_Start+0x6c>
	Xil_AssertNonvoid(InstancePtr != NULL);
c001a5d8:	13500593          	li	a1,309
c001a5dc:	07fe7517          	auipc	a0,0x7fe7
c001a5e0:	36450513          	addi	a0,a0,868 # c8001940 <__rodata_start+0x1940>
c001a5e4:	4d8030ef          	jal	ra,c001dabc <Xil_Assert>
c001a5e8:	07fe8797          	auipc	a5,0x7fe8
c001a5ec:	32c78793          	addi	a5,a5,812 # c8002914 <Xil_AssertStatus>
c001a5f0:	00100713          	li	a4,1
c001a5f4:	00e7a023          	sw	a4,0(a5)
c001a5f8:	00000793          	li	a5,0
c001a5fc:	0fc0006f          	j	c001a6f8 <XSpi_Start+0x164>
	Xil_AssertNonvoid(InstancePtr->IsReady == XIL_COMPONENT_IS_READY);
c001a600:	07fe8797          	auipc	a5,0x7fe8
c001a604:	31478793          	addi	a5,a5,788 # c8002914 <Xil_AssertStatus>
c001a608:	0007a023          	sw	zero,0(a5)

	/*
	 * If it is already started, return a status indicating so.
	 */
	if (InstancePtr->IsStarted == XIL_COMPONENT_IS_STARTED) {
c001a60c:	fdc42783          	lw	a5,-36(s0)
c001a610:	0207a703          	lw	a4,32(a5)
c001a614:	222227b7          	lui	a5,0x22222
c001a618:	22278793          	addi	a5,a5,546 # 22222222 <_DMEM_LENGTH+0x21a22222>
c001a61c:	02f71c63          	bne	a4,a5,c001a654 <XSpi_Start+0xc0>
c001a620:	02c0006f          	j	c001a64c <XSpi_Start+0xb8>
	Xil_AssertNonvoid(InstancePtr->IsReady == XIL_COMPONENT_IS_READY);
c001a624:	13600593          	li	a1,310
c001a628:	07fe7517          	auipc	a0,0x7fe7
c001a62c:	31850513          	addi	a0,a0,792 # c8001940 <__rodata_start+0x1940>
c001a630:	48c030ef          	jal	ra,c001dabc <Xil_Assert>
c001a634:	07fe8797          	auipc	a5,0x7fe8
c001a638:	2e078793          	addi	a5,a5,736 # c8002914 <Xil_AssertStatus>
c001a63c:	00100713          	li	a4,1
c001a640:	00e7a023          	sw	a4,0(a5)
c001a644:	00000793          	li	a5,0
c001a648:	0b00006f          	j	c001a6f8 <XSpi_Start+0x164>
		return XST_DEVICE_IS_STARTED;
c001a64c:	00500793          	li	a5,5
c001a650:	0a80006f          	j	c001a6f8 <XSpi_Start+0x164>
	}

	/*
	 * Enable the interrupts.
	 */
	XSpi_IntrEnable(InstancePtr, XSP_INTR_DFT_MASK);
c001a654:	fdc42783          	lw	a5,-36(s0)
c001a658:	0187a783          	lw	a5,24(a5)
c001a65c:	02878493          	addi	s1,a5,40
c001a660:	fdc42783          	lw	a5,-36(s0)
c001a664:	0187a783          	lw	a5,24(a5)
c001a668:	02878793          	addi	a5,a5,40
c001a66c:	00078513          	mv	a0,a5
c001a670:	b49ff0ef          	jal	ra,c001a1b8 <Xil_In32>
c001a674:	00050713          	mv	a4,a0
c001a678:	000027b7          	lui	a5,0x2
c001a67c:	02b78793          	addi	a5,a5,43 # 202b <_STACK_SIZE+0x102b>
c001a680:	00f767b3          	or	a5,a4,a5
c001a684:	00078593          	mv	a1,a5
c001a688:	00048513          	mv	a0,s1
c001a68c:	b55ff0ef          	jal	ra,c001a1e0 <Xil_Out32>

	/*
	 * Indicate that the device is started before we enable the transmitter
	 * or receiver or interrupts.
	 */
	InstancePtr->IsStarted = XIL_COMPONENT_IS_STARTED;
c001a690:	fdc42783          	lw	a5,-36(s0)
c001a694:	22222737          	lui	a4,0x22222
c001a698:	22270713          	addi	a4,a4,546 # 22222222 <_DMEM_LENGTH+0x21a22222>
c001a69c:	02e7a023          	sw	a4,32(a5)
	 * Reset the transmit and receive FIFOs if present. There is a critical
	 * section here since this register is also modified during interrupt
	 * context. So we wait until after the r/m/w of the control register to
	 * enable the Global Interrupt Enable.
	 */
	ControlReg = XSpi_GetControlReg(InstancePtr);
c001a6a0:	fdc42783          	lw	a5,-36(s0)
c001a6a4:	0187a783          	lw	a5,24(a5)
c001a6a8:	06078793          	addi	a5,a5,96
c001a6ac:	00078513          	mv	a0,a5
c001a6b0:	b09ff0ef          	jal	ra,c001a1b8 <Xil_In32>
c001a6b4:	fea42623          	sw	a0,-20(s0)
	ControlReg |= XSP_CR_TXFIFO_RESET_MASK | XSP_CR_RXFIFO_RESET_MASK |
c001a6b8:	fec42783          	lw	a5,-20(s0)
c001a6bc:	0627e793          	ori	a5,a5,98
c001a6c0:	fef42623          	sw	a5,-20(s0)
			XSP_CR_ENABLE_MASK;
	XSpi_SetControlReg(InstancePtr, ControlReg);
c001a6c4:	fdc42783          	lw	a5,-36(s0)
c001a6c8:	0187a783          	lw	a5,24(a5)
c001a6cc:	06078793          	addi	a5,a5,96
c001a6d0:	fec42583          	lw	a1,-20(s0)
c001a6d4:	00078513          	mv	a0,a5
c001a6d8:	b09ff0ef          	jal	ra,c001a1e0 <Xil_Out32>

	/*
	 * Enable the Global Interrupt Enable just after we start.
	 */
	XSpi_IntrGlobalEnable(InstancePtr);
c001a6dc:	fdc42783          	lw	a5,-36(s0)
c001a6e0:	0187a783          	lw	a5,24(a5)
c001a6e4:	01c78793          	addi	a5,a5,28
c001a6e8:	800005b7          	lui	a1,0x80000
c001a6ec:	00078513          	mv	a0,a5
c001a6f0:	af1ff0ef          	jal	ra,c001a1e0 <Xil_Out32>

	return XST_SUCCESS;
c001a6f4:	00000793          	li	a5,0
}
c001a6f8:	00078513          	mv	a0,a5
c001a6fc:	02c12083          	lw	ra,44(sp)
c001a700:	02812403          	lw	s0,40(sp)
c001a704:	02412483          	lw	s1,36(sp)
c001a708:	03010113          	addi	sp,sp,48
c001a70c:	00008067          	ret

c001a710 <XSpi_Stop>:
* is required to provide protection of this shared data (typically using a
* semaphore).
*
******************************************************************************/
int XSpi_Stop(XSpi *InstancePtr)
{
c001a710:	fd010113          	addi	sp,sp,-48
c001a714:	02112623          	sw	ra,44(sp)
c001a718:	02812423          	sw	s0,40(sp)
c001a71c:	03010413          	addi	s0,sp,48
c001a720:	fca42e23          	sw	a0,-36(s0)
	u32 ControlReg;

	Xil_AssertNonvoid(InstancePtr != NULL);
c001a724:	fdc42783          	lw	a5,-36(s0)
c001a728:	02078463          	beqz	a5,c001a750 <XSpi_Stop+0x40>
c001a72c:	07fe8797          	auipc	a5,0x7fe8
c001a730:	1e878793          	addi	a5,a5,488 # c8002914 <Xil_AssertStatus>
c001a734:	0007a023          	sw	zero,0(a5)
	Xil_AssertNonvoid(InstancePtr->IsReady == XIL_COMPONENT_IS_READY);
c001a738:	fdc42783          	lw	a5,-36(s0)
c001a73c:	01c7a703          	lw	a4,28(a5)
c001a740:	111117b7          	lui	a5,0x11111
c001a744:	11178793          	addi	a5,a5,273 # 11111111 <_DMEM_LENGTH+0x10911111>
c001a748:	04f71663          	bne	a4,a5,c001a794 <XSpi_Stop+0x84>
c001a74c:	02c0006f          	j	c001a778 <XSpi_Stop+0x68>
	Xil_AssertNonvoid(InstancePtr != NULL);
c001a750:	18300593          	li	a1,387
c001a754:	07fe7517          	auipc	a0,0x7fe7
c001a758:	1ec50513          	addi	a0,a0,492 # c8001940 <__rodata_start+0x1940>
c001a75c:	360030ef          	jal	ra,c001dabc <Xil_Assert>
c001a760:	07fe8797          	auipc	a5,0x7fe8
c001a764:	1b478793          	addi	a5,a5,436 # c8002914 <Xil_AssertStatus>
c001a768:	00100713          	li	a4,1
c001a76c:	00e7a023          	sw	a4,0(a5)
c001a770:	00000793          	li	a5,0
c001a774:	0ac0006f          	j	c001a820 <XSpi_Stop+0x110>
	Xil_AssertNonvoid(InstancePtr->IsReady == XIL_COMPONENT_IS_READY);
c001a778:	07fe8797          	auipc	a5,0x7fe8
c001a77c:	19c78793          	addi	a5,a5,412 # c8002914 <Xil_AssertStatus>
c001a780:	0007a023          	sw	zero,0(a5)

	/*
	 * Do not allow the user to stop the device while a transfer is in
	 * progress.
	 */
	if (InstancePtr->IsBusy) {
c001a784:	fdc42783          	lw	a5,-36(s0)
c001a788:	0487a783          	lw	a5,72(a5)
c001a78c:	02078c63          	beqz	a5,c001a7c4 <XSpi_Stop+0xb4>
c001a790:	02c0006f          	j	c001a7bc <XSpi_Stop+0xac>
	Xil_AssertNonvoid(InstancePtr->IsReady == XIL_COMPONENT_IS_READY);
c001a794:	18400593          	li	a1,388
c001a798:	07fe7517          	auipc	a0,0x7fe7
c001a79c:	1a850513          	addi	a0,a0,424 # c8001940 <__rodata_start+0x1940>
c001a7a0:	31c030ef          	jal	ra,c001dabc <Xil_Assert>
c001a7a4:	07fe8797          	auipc	a5,0x7fe8
c001a7a8:	17078793          	addi	a5,a5,368 # c8002914 <Xil_AssertStatus>
c001a7ac:	00100713          	li	a4,1
c001a7b0:	00e7a023          	sw	a4,0(a5)
c001a7b4:	00000793          	li	a5,0
c001a7b8:	0680006f          	j	c001a820 <XSpi_Stop+0x110>
		return XST_DEVICE_BUSY;
c001a7bc:	01500793          	li	a5,21
c001a7c0:	0600006f          	j	c001a820 <XSpi_Stop+0x110>
	 * Disable the device. First disable the interrupts since there is
	 * a critical section here because this register is also modified during
	 * interrupt context. The device is likely disabled already since there
	 * is no transfer in progress, but we do it again just to be sure.
	 */
	XSpi_IntrGlobalDisable(InstancePtr);
c001a7c4:	fdc42783          	lw	a5,-36(s0)
c001a7c8:	0187a783          	lw	a5,24(a5)
c001a7cc:	01c78793          	addi	a5,a5,28
c001a7d0:	00000593          	li	a1,0
c001a7d4:	00078513          	mv	a0,a5
c001a7d8:	a09ff0ef          	jal	ra,c001a1e0 <Xil_Out32>

	ControlReg = XSpi_GetControlReg(InstancePtr);
c001a7dc:	fdc42783          	lw	a5,-36(s0)
c001a7e0:	0187a783          	lw	a5,24(a5)
c001a7e4:	06078793          	addi	a5,a5,96
c001a7e8:	00078513          	mv	a0,a5
c001a7ec:	9cdff0ef          	jal	ra,c001a1b8 <Xil_In32>
c001a7f0:	fea42623          	sw	a0,-20(s0)
	XSpi_SetControlReg(InstancePtr, ControlReg & ~XSP_CR_ENABLE_MASK);
c001a7f4:	fdc42783          	lw	a5,-36(s0)
c001a7f8:	0187a783          	lw	a5,24(a5)
c001a7fc:	06078713          	addi	a4,a5,96
c001a800:	fec42783          	lw	a5,-20(s0)
c001a804:	ffd7f793          	andi	a5,a5,-3
c001a808:	00078593          	mv	a1,a5
c001a80c:	00070513          	mv	a0,a4
c001a810:	9d1ff0ef          	jal	ra,c001a1e0 <Xil_Out32>

	InstancePtr->IsStarted = 0;
c001a814:	fdc42783          	lw	a5,-36(s0)
c001a818:	0207a023          	sw	zero,32(a5)

	return XST_SUCCESS;
c001a81c:	00000793          	li	a5,0
}
c001a820:	00078513          	mv	a0,a5
c001a824:	02c12083          	lw	ra,44(sp)
c001a828:	02812403          	lw	s0,40(sp)
c001a82c:	03010113          	addi	sp,sp,48
c001a830:	00008067          	ret

c001a834 <XSpi_Reset>:
*
* @note		None.
*
******************************************************************************/
void XSpi_Reset(XSpi *InstancePtr)
{
c001a834:	fe010113          	addi	sp,sp,-32
c001a838:	00112e23          	sw	ra,28(sp)
c001a83c:	00812c23          	sw	s0,24(sp)
c001a840:	02010413          	addi	s0,sp,32
c001a844:	fea42623          	sw	a0,-20(s0)
	Xil_AssertVoid(InstancePtr != NULL);
c001a848:	fec42783          	lw	a5,-20(s0)
c001a84c:	02078463          	beqz	a5,c001a874 <XSpi_Reset+0x40>
c001a850:	07fe8797          	auipc	a5,0x7fe8
c001a854:	0c478793          	addi	a5,a5,196 # c8002914 <Xil_AssertStatus>
c001a858:	0007a023          	sw	zero,0(a5)
	Xil_AssertVoid(InstancePtr->IsReady == XIL_COMPONENT_IS_READY);
c001a85c:	fec42783          	lw	a5,-20(s0)
c001a860:	01c7a703          	lw	a4,28(a5)
c001a864:	111117b7          	lui	a5,0x11111
c001a868:	11178793          	addi	a5,a5,273 # 11111111 <_DMEM_LENGTH+0x10911111>
c001a86c:	06f71a63          	bne	a4,a5,c001a8e0 <XSpi_Reset+0xac>
c001a870:	0280006f          	j	c001a898 <XSpi_Reset+0x64>
	Xil_AssertVoid(InstancePtr != NULL);
c001a874:	1b300593          	li	a1,435
c001a878:	07fe7517          	auipc	a0,0x7fe7
c001a87c:	0c850513          	addi	a0,a0,200 # c8001940 <__rodata_start+0x1940>
c001a880:	23c030ef          	jal	ra,c001dabc <Xil_Assert>
c001a884:	07fe8797          	auipc	a5,0x7fe8
c001a888:	09078793          	addi	a5,a5,144 # c8002914 <Xil_AssertStatus>
c001a88c:	00100713          	li	a4,1
c001a890:	00e7a023          	sw	a4,0(a5)
c001a894:	0700006f          	j	c001a904 <XSpi_Reset+0xd0>
	Xil_AssertVoid(InstancePtr->IsReady == XIL_COMPONENT_IS_READY);
c001a898:	07fe8797          	auipc	a5,0x7fe8
c001a89c:	07c78793          	addi	a5,a5,124 # c8002914 <Xil_AssertStatus>
c001a8a0:	0007a023          	sw	zero,0(a5)

	/*
	 * Abort any transfer that is in progress.
	 */
	XSpi_Abort(InstancePtr);
c001a8a4:	fec42503          	lw	a0,-20(s0)
c001a8a8:	1d0010ef          	jal	ra,c001ba78 <XSpi_Abort>

	/*
	 * Reset any values that are not reset by the hardware reset such that
	 * the software state matches the hardware device.
	 */
	InstancePtr->IsStarted = 0;
c001a8ac:	fec42783          	lw	a5,-20(s0)
c001a8b0:	0207a023          	sw	zero,32(a5)
	InstancePtr->SlaveSelectReg = InstancePtr->SlaveSelectMask;
c001a8b4:	fec42783          	lw	a5,-20(s0)
c001a8b8:	0307a703          	lw	a4,48(a5)
c001a8bc:	fec42783          	lw	a5,-20(s0)
c001a8c0:	02e7aa23          	sw	a4,52(a5)

	/*
	 * Reset the device.
	 */
	XSpi_WriteReg(InstancePtr->BaseAddr, XSP_SRR_OFFSET,
c001a8c4:	fec42783          	lw	a5,-20(s0)
c001a8c8:	0187a783          	lw	a5,24(a5)
c001a8cc:	04078793          	addi	a5,a5,64
c001a8d0:	00a00593          	li	a1,10
c001a8d4:	00078513          	mv	a0,a5
c001a8d8:	909ff0ef          	jal	ra,c001a1e0 <Xil_Out32>
c001a8dc:	0280006f          	j	c001a904 <XSpi_Reset+0xd0>
	Xil_AssertVoid(InstancePtr->IsReady == XIL_COMPONENT_IS_READY);
c001a8e0:	1b400593          	li	a1,436
c001a8e4:	07fe7517          	auipc	a0,0x7fe7
c001a8e8:	05c50513          	addi	a0,a0,92 # c8001940 <__rodata_start+0x1940>
c001a8ec:	1d0030ef          	jal	ra,c001dabc <Xil_Assert>
c001a8f0:	07fe8797          	auipc	a5,0x7fe8
c001a8f4:	02478793          	addi	a5,a5,36 # c8002914 <Xil_AssertStatus>
c001a8f8:	00100713          	li	a4,1
c001a8fc:	00e7a023          	sw	a4,0(a5)
c001a900:	00000013          	nop
			XSP_SRR_RESET_MASK);
}
c001a904:	01c12083          	lw	ra,28(sp)
c001a908:	01812403          	lw	s0,24(sp)
c001a90c:	02010113          	addi	sp,sp,32
c001a910:	00008067          	ret

c001a914 <XSpi_Transfer>:
* no two threads are transferring data on the SPI bus at the same time.
*
******************************************************************************/
int XSpi_Transfer(XSpi *InstancePtr, u8 *SendBufPtr,
		  u8 *RecvBufPtr, unsigned int ByteCount)
{
c001a914:	fc010113          	addi	sp,sp,-64
c001a918:	02112e23          	sw	ra,60(sp)
c001a91c:	02812c23          	sw	s0,56(sp)
c001a920:	02912a23          	sw	s1,52(sp)
c001a924:	04010413          	addi	s0,sp,64
c001a928:	fca42623          	sw	a0,-52(s0)
c001a92c:	fcb42423          	sw	a1,-56(s0)
c001a930:	fcc42223          	sw	a2,-60(s0)
c001a934:	fcd42023          	sw	a3,-64(s0)
	u32 ControlReg;
	u32 GlobalIntrReg;
	u32 StatusReg;
	u32 Data = 0;
c001a938:	fe042423          	sw	zero,-24(s0)
	u8  DataWidth;

	/*
	 * The RecvBufPtr argument can be NULL.
	 */
	Xil_AssertNonvoid(InstancePtr != NULL);
c001a93c:	fcc42783          	lw	a5,-52(s0)
c001a940:	00078e63          	beqz	a5,c001a95c <XSpi_Transfer+0x48>
c001a944:	07fe8797          	auipc	a5,0x7fe8
c001a948:	fd078793          	addi	a5,a5,-48 # c8002914 <Xil_AssertStatus>
c001a94c:	0007a023          	sw	zero,0(a5)
	Xil_AssertNonvoid(SendBufPtr != NULL);
c001a950:	fc842783          	lw	a5,-56(s0)
c001a954:	04078463          	beqz	a5,c001a99c <XSpi_Transfer+0x88>
c001a958:	02c0006f          	j	c001a984 <XSpi_Transfer+0x70>
	Xil_AssertNonvoid(InstancePtr != NULL);
c001a95c:	22600593          	li	a1,550
c001a960:	07fe7517          	auipc	a0,0x7fe7
c001a964:	fe050513          	addi	a0,a0,-32 # c8001940 <__rodata_start+0x1940>
c001a968:	154030ef          	jal	ra,c001dabc <Xil_Assert>
c001a96c:	07fe8797          	auipc	a5,0x7fe8
c001a970:	fa878793          	addi	a5,a5,-88 # c8002914 <Xil_AssertStatus>
c001a974:	00100713          	li	a4,1
c001a978:	00e7a023          	sw	a4,0(a5)
c001a97c:	00000793          	li	a5,0
c001a980:	7440006f          	j	c001b0c4 <XSpi_Transfer+0x7b0>
	Xil_AssertNonvoid(SendBufPtr != NULL);
c001a984:	07fe8797          	auipc	a5,0x7fe8
c001a988:	f9078793          	addi	a5,a5,-112 # c8002914 <Xil_AssertStatus>
c001a98c:	0007a023          	sw	zero,0(a5)
	Xil_AssertNonvoid(ByteCount > 0);
c001a990:	fc042783          	lw	a5,-64(s0)
c001a994:	04078a63          	beqz	a5,c001a9e8 <XSpi_Transfer+0xd4>
c001a998:	02c0006f          	j	c001a9c4 <XSpi_Transfer+0xb0>
	Xil_AssertNonvoid(SendBufPtr != NULL);
c001a99c:	22700593          	li	a1,551
c001a9a0:	07fe7517          	auipc	a0,0x7fe7
c001a9a4:	fa050513          	addi	a0,a0,-96 # c8001940 <__rodata_start+0x1940>
c001a9a8:	114030ef          	jal	ra,c001dabc <Xil_Assert>
c001a9ac:	07fe8797          	auipc	a5,0x7fe8
c001a9b0:	f6878793          	addi	a5,a5,-152 # c8002914 <Xil_AssertStatus>
c001a9b4:	00100713          	li	a4,1
c001a9b8:	00e7a023          	sw	a4,0(a5)
c001a9bc:	00000793          	li	a5,0
c001a9c0:	7040006f          	j	c001b0c4 <XSpi_Transfer+0x7b0>
	Xil_AssertNonvoid(ByteCount > 0);
c001a9c4:	07fe8797          	auipc	a5,0x7fe8
c001a9c8:	f5078793          	addi	a5,a5,-176 # c8002914 <Xil_AssertStatus>
c001a9cc:	0007a023          	sw	zero,0(a5)
	Xil_AssertNonvoid(InstancePtr->IsReady == XIL_COMPONENT_IS_READY);
c001a9d0:	fcc42783          	lw	a5,-52(s0)
c001a9d4:	01c7a703          	lw	a4,28(a5)
c001a9d8:	111117b7          	lui	a5,0x11111
c001a9dc:	11178793          	addi	a5,a5,273 # 11111111 <_DMEM_LENGTH+0x10911111>
c001a9e0:	04f71a63          	bne	a4,a5,c001aa34 <XSpi_Transfer+0x120>
c001a9e4:	02c0006f          	j	c001aa10 <XSpi_Transfer+0xfc>
	Xil_AssertNonvoid(ByteCount > 0);
c001a9e8:	22800593          	li	a1,552
c001a9ec:	07fe7517          	auipc	a0,0x7fe7
c001a9f0:	f5450513          	addi	a0,a0,-172 # c8001940 <__rodata_start+0x1940>
c001a9f4:	0c8030ef          	jal	ra,c001dabc <Xil_Assert>
c001a9f8:	07fe8797          	auipc	a5,0x7fe8
c001a9fc:	f1c78793          	addi	a5,a5,-228 # c8002914 <Xil_AssertStatus>
c001aa00:	00100713          	li	a4,1
c001aa04:	00e7a023          	sw	a4,0(a5)
c001aa08:	00000793          	li	a5,0
c001aa0c:	6b80006f          	j	c001b0c4 <XSpi_Transfer+0x7b0>
	Xil_AssertNonvoid(InstancePtr->IsReady == XIL_COMPONENT_IS_READY);
c001aa10:	07fe8797          	auipc	a5,0x7fe8
c001aa14:	f0478793          	addi	a5,a5,-252 # c8002914 <Xil_AssertStatus>
c001aa18:	0007a023          	sw	zero,0(a5)

	if (InstancePtr->IsStarted != XIL_COMPONENT_IS_STARTED) {
c001aa1c:	fcc42783          	lw	a5,-52(s0)
c001aa20:	0207a703          	lw	a4,32(a5)
c001aa24:	222227b7          	lui	a5,0x22222
c001aa28:	22278793          	addi	a5,a5,546 # 22222222 <_DMEM_LENGTH+0x21a22222>
c001aa2c:	02f70c63          	beq	a4,a5,c001aa64 <XSpi_Transfer+0x150>
c001aa30:	02c0006f          	j	c001aa5c <XSpi_Transfer+0x148>
	Xil_AssertNonvoid(InstancePtr->IsReady == XIL_COMPONENT_IS_READY);
c001aa34:	22900593          	li	a1,553
c001aa38:	07fe7517          	auipc	a0,0x7fe7
c001aa3c:	f0850513          	addi	a0,a0,-248 # c8001940 <__rodata_start+0x1940>
c001aa40:	07c030ef          	jal	ra,c001dabc <Xil_Assert>
c001aa44:	07fe8797          	auipc	a5,0x7fe8
c001aa48:	ed078793          	addi	a5,a5,-304 # c8002914 <Xil_AssertStatus>
c001aa4c:	00100713          	li	a4,1
c001aa50:	00e7a023          	sw	a4,0(a5)
c001aa54:	00000793          	li	a5,0
c001aa58:	66c0006f          	j	c001b0c4 <XSpi_Transfer+0x7b0>
		return XST_DEVICE_IS_STOPPED;
c001aa5c:	00600793          	li	a5,6
c001aa60:	6640006f          	j	c001b0c4 <XSpi_Transfer+0x7b0>
	 * worry about a critical section here. Even if the Isr changes the bus
	 * flag just after we read it, a busy error is returned and the caller
	 * can retry when it gets the status handler callback indicating the
	 * transfer is done.
	 */
	if (InstancePtr->IsBusy) {
c001aa64:	fcc42783          	lw	a5,-52(s0)
c001aa68:	0487a783          	lw	a5,72(a5)
c001aa6c:	00078663          	beqz	a5,c001aa78 <XSpi_Transfer+0x164>
		return XST_DEVICE_BUSY;
c001aa70:	01500793          	li	a5,21
c001aa74:	6500006f          	j	c001b0c4 <XSpi_Transfer+0x7b0>
	}

	/*
	 * Save the Global Interrupt Enable Register.
	 */
	GlobalIntrReg = XSpi_IsIntrGlobalEnabled(InstancePtr);
c001aa78:	fcc42783          	lw	a5,-52(s0)
c001aa7c:	0187a783          	lw	a5,24(a5)
c001aa80:	01c78793          	addi	a5,a5,28
c001aa84:	00078513          	mv	a0,a5
c001aa88:	f30ff0ef          	jal	ra,c001a1b8 <Xil_In32>
c001aa8c:	00050713          	mv	a4,a0
c001aa90:	800007b7          	lui	a5,0x80000
c001aa94:	00f707b3          	add	a5,a4,a5
c001aa98:	0017b793          	seqz	a5,a5
c001aa9c:	0ff7f793          	andi	a5,a5,255
c001aaa0:	fef42223          	sw	a5,-28(s0)
	/*
	 * Enter a critical section from here to the end of the function since
	 * state is modified, an interrupt is enabled, and the control register
	 * is modified (r/m/w).
	 */
	XSpi_IntrGlobalDisable(InstancePtr);
c001aaa4:	fcc42783          	lw	a5,-52(s0)
c001aaa8:	0187a783          	lw	a5,24(a5) # 80000018 <_end+0xb7f7b798>
c001aaac:	01c78793          	addi	a5,a5,28
c001aab0:	00000593          	li	a1,0
c001aab4:	00078513          	mv	a0,a5
c001aab8:	f28ff0ef          	jal	ra,c001a1e0 <Xil_Out32>

	ControlReg = XSpi_GetControlReg(InstancePtr);
c001aabc:	fcc42783          	lw	a5,-52(s0)
c001aac0:	0187a783          	lw	a5,24(a5)
c001aac4:	06078793          	addi	a5,a5,96
c001aac8:	00078513          	mv	a0,a5
c001aacc:	eecff0ef          	jal	ra,c001a1b8 <Xil_In32>
c001aad0:	fea42023          	sw	a0,-32(s0)
	 * If configured as a master, be sure there is a slave select bit set
	 * in the slave select register. If no slaves have been selected, the
	 * value of the register will equal the mask.  When the device is in
	 * loopback mode, however, no slave selects need be set.
	 */
	if (ControlReg & XSP_CR_MASTER_MODE_MASK) {
c001aad4:	fe042783          	lw	a5,-32(s0)
c001aad8:	0047f793          	andi	a5,a5,4
c001aadc:	04078863          	beqz	a5,c001ab2c <XSpi_Transfer+0x218>
		if ((ControlReg & XSP_CR_LOOPBACK_MASK) == 0) {
c001aae0:	fe042783          	lw	a5,-32(s0)
c001aae4:	0017f793          	andi	a5,a5,1
c001aae8:	04079263          	bnez	a5,c001ab2c <XSpi_Transfer+0x218>
			if (InstancePtr->SlaveSelectReg ==
c001aaec:	fcc42783          	lw	a5,-52(s0)
c001aaf0:	0347a703          	lw	a4,52(a5)
				InstancePtr->SlaveSelectMask) {
c001aaf4:	fcc42783          	lw	a5,-52(s0)
c001aaf8:	0307a783          	lw	a5,48(a5)
			if (InstancePtr->SlaveSelectReg ==
c001aafc:	02f71863          	bne	a4,a5,c001ab2c <XSpi_Transfer+0x218>
				if (GlobalIntrReg == TRUE) {
c001ab00:	fe442703          	lw	a4,-28(s0)
c001ab04:	00100793          	li	a5,1
c001ab08:	00f71e63          	bne	a4,a5,c001ab24 <XSpi_Transfer+0x210>
					/* Interrupt Mode of operation */
					XSpi_IntrGlobalEnable(InstancePtr);
c001ab0c:	fcc42783          	lw	a5,-52(s0)
c001ab10:	0187a783          	lw	a5,24(a5)
c001ab14:	01c78793          	addi	a5,a5,28
c001ab18:	800005b7          	lui	a1,0x80000
c001ab1c:	00078513          	mv	a0,a5
c001ab20:	ec0ff0ef          	jal	ra,c001a1e0 <Xil_Out32>
				}
				return XST_SPI_NO_SLAVE;
c001ab24:	48300793          	li	a5,1155
c001ab28:	59c0006f          	j	c001b0c4 <XSpi_Transfer+0x7b0>

	/*
	 * Set the busy flag, which will be cleared when the transfer
	 * is completely done.
	 */
	InstancePtr->IsBusy = TRUE;
c001ab2c:	fcc42783          	lw	a5,-52(s0)
c001ab30:	00100713          	li	a4,1
c001ab34:	04e7a423          	sw	a4,72(a5)

	/*
	 * Set up buffer pointers.
	 */
	InstancePtr->SendBufferPtr = SendBufPtr;
c001ab38:	fcc42783          	lw	a5,-52(s0)
c001ab3c:	fc842703          	lw	a4,-56(s0)
c001ab40:	02e7ac23          	sw	a4,56(a5)
	InstancePtr->RecvBufferPtr = RecvBufPtr;
c001ab44:	fcc42783          	lw	a5,-52(s0)
c001ab48:	fc442703          	lw	a4,-60(s0)
c001ab4c:	02e7ae23          	sw	a4,60(a5)

	InstancePtr->RequestedBytes = ByteCount;
c001ab50:	fcc42783          	lw	a5,-52(s0)
c001ab54:	fc042703          	lw	a4,-64(s0)
c001ab58:	04e7a023          	sw	a4,64(a5)
	InstancePtr->RemainingBytes = ByteCount;
c001ab5c:	fcc42783          	lw	a5,-52(s0)
c001ab60:	fc042703          	lw	a4,-64(s0)
c001ab64:	04e7a223          	sw	a4,68(a5)

	DataWidth = InstancePtr->DataWidth;
c001ab68:	fcc42783          	lw	a5,-52(s0)
c001ab6c:	02d7c783          	lbu	a5,45(a5)
c001ab70:	fcf40fa3          	sb	a5,-33(s0)
	 * we have to send). We use the tx full status bit to know if the device
	 * can take more data. By doing this, the driver does not need to know
	 * the size of the FIFO or that there even is a FIFO. The downside is
	 * that the status register must be read each loop iteration.
	 */
	StatusReg = XSpi_GetStatusReg(InstancePtr);
c001ab74:	fcc42783          	lw	a5,-52(s0)
c001ab78:	0187a783          	lw	a5,24(a5)
c001ab7c:	06478793          	addi	a5,a5,100
c001ab80:	00078513          	mv	a0,a5
c001ab84:	e34ff0ef          	jal	ra,c001a1b8 <Xil_In32>
c001ab88:	fea42623          	sw	a0,-20(s0)

	while (((StatusReg & XSP_SR_TX_FULL_MASK) == 0) &&
c001ab8c:	0d00006f          	j	c001ac5c <XSpi_Transfer+0x348>
		(InstancePtr->RemainingBytes > 0)) {
		if (DataWidth == XSP_DATAWIDTH_BYTE) {
c001ab90:	fdf44703          	lbu	a4,-33(s0)
c001ab94:	00800793          	li	a5,8
c001ab98:	00f71c63          	bne	a4,a5,c001abb0 <XSpi_Transfer+0x29c>
			/*
			 * Data Transfer Width is Byte (8 bit).
			 */
			Data = *InstancePtr->SendBufferPtr;
c001ab9c:	fcc42783          	lw	a5,-52(s0)
c001aba0:	0387a783          	lw	a5,56(a5)
c001aba4:	0007c783          	lbu	a5,0(a5)
c001aba8:	fef42423          	sw	a5,-24(s0)
c001abac:	0400006f          	j	c001abec <XSpi_Transfer+0x2d8>
		} else if (DataWidth == XSP_DATAWIDTH_HALF_WORD) {
c001abb0:	fdf44703          	lbu	a4,-33(s0)
c001abb4:	01000793          	li	a5,16
c001abb8:	00f71c63          	bne	a4,a5,c001abd0 <XSpi_Transfer+0x2bc>
			/*
			 * Data Transfer Width is Half Word (16 bit).
			 */
			#pragma GCC diagnostic ignored "-Wcast-align" /* Silence this warning as the driver works normally */
			Data = *(u16 *)InstancePtr->SendBufferPtr;
c001abbc:	fcc42783          	lw	a5,-52(s0)
c001abc0:	0387a783          	lw	a5,56(a5)
c001abc4:	0007d783          	lhu	a5,0(a5)
c001abc8:	fef42423          	sw	a5,-24(s0)
c001abcc:	0200006f          	j	c001abec <XSpi_Transfer+0x2d8>
		} else if (DataWidth == XSP_DATAWIDTH_WORD){
c001abd0:	fdf44703          	lbu	a4,-33(s0)
c001abd4:	02000793          	li	a5,32
c001abd8:	00f71a63          	bne	a4,a5,c001abec <XSpi_Transfer+0x2d8>
			/*
			 * Data Transfer Width is Word (32 bit).
			 */
			Data = *(u32 *)InstancePtr->SendBufferPtr;
c001abdc:	fcc42783          	lw	a5,-52(s0)
c001abe0:	0387a783          	lw	a5,56(a5)
c001abe4:	0007a783          	lw	a5,0(a5)
c001abe8:	fef42423          	sw	a5,-24(s0)
		}

		XSpi_WriteReg(InstancePtr->BaseAddr, XSP_DTR_OFFSET, Data);
c001abec:	fcc42783          	lw	a5,-52(s0)
c001abf0:	0187a783          	lw	a5,24(a5)
c001abf4:	06878793          	addi	a5,a5,104
c001abf8:	fe842583          	lw	a1,-24(s0)
c001abfc:	00078513          	mv	a0,a5
c001ac00:	de0ff0ef          	jal	ra,c001a1e0 <Xil_Out32>
		InstancePtr->SendBufferPtr += (DataWidth >> 3);
c001ac04:	fcc42783          	lw	a5,-52(s0)
c001ac08:	0387a783          	lw	a5,56(a5)
c001ac0c:	fdf44703          	lbu	a4,-33(s0)
c001ac10:	00375713          	srli	a4,a4,0x3
c001ac14:	0ff77713          	andi	a4,a4,255
c001ac18:	00e78733          	add	a4,a5,a4
c001ac1c:	fcc42783          	lw	a5,-52(s0)
c001ac20:	02e7ac23          	sw	a4,56(a5)
		InstancePtr->RemainingBytes -= (DataWidth >> 3);
c001ac24:	fcc42783          	lw	a5,-52(s0)
c001ac28:	0447a783          	lw	a5,68(a5)
c001ac2c:	fdf44703          	lbu	a4,-33(s0)
c001ac30:	00375713          	srli	a4,a4,0x3
c001ac34:	0ff77713          	andi	a4,a4,255
c001ac38:	40e78733          	sub	a4,a5,a4
c001ac3c:	fcc42783          	lw	a5,-52(s0)
c001ac40:	04e7a223          	sw	a4,68(a5)
		StatusReg = XSpi_GetStatusReg(InstancePtr);
c001ac44:	fcc42783          	lw	a5,-52(s0)
c001ac48:	0187a783          	lw	a5,24(a5)
c001ac4c:	06478793          	addi	a5,a5,100
c001ac50:	00078513          	mv	a0,a5
c001ac54:	d64ff0ef          	jal	ra,c001a1b8 <Xil_In32>
c001ac58:	fea42623          	sw	a0,-20(s0)
	while (((StatusReg & XSP_SR_TX_FULL_MASK) == 0) &&
c001ac5c:	fec42783          	lw	a5,-20(s0)
c001ac60:	0087f793          	andi	a5,a5,8
c001ac64:	00079863          	bnez	a5,c001ac74 <XSpi_Transfer+0x360>
		(InstancePtr->RemainingBytes > 0)) {
c001ac68:	fcc42783          	lw	a5,-52(s0)
c001ac6c:	0447a783          	lw	a5,68(a5)
	while (((StatusReg & XSP_SR_TX_FULL_MASK) == 0) &&
c001ac70:	f20790e3          	bnez	a5,c001ab90 <XSpi_Transfer+0x27c>
	
	/*
	 * Set the slave select register to select the device on the SPI before
	 * starting the transfer of data.
	 */
	XSpi_SetSlaveSelectReg(InstancePtr,
c001ac74:	fcc42783          	lw	a5,-52(s0)
c001ac78:	0187a783          	lw	a5,24(a5)
c001ac7c:	07078713          	addi	a4,a5,112
c001ac80:	fcc42783          	lw	a5,-52(s0)
c001ac84:	0347a783          	lw	a5,52(a5)
c001ac88:	00078593          	mv	a1,a5
c001ac8c:	00070513          	mv	a0,a4
c001ac90:	d50ff0ef          	jal	ra,c001a1e0 <Xil_Out32>
	 * Start the transfer by no longer inhibiting the transmitter and
	 * enabling the device. For a master, this will in fact start the
	 * transfer, but for a slave it only prepares the device for a transfer
	 * that must be initiated by a master.
	 */
	ControlReg = XSpi_GetControlReg(InstancePtr);
c001ac94:	fcc42783          	lw	a5,-52(s0)
c001ac98:	0187a783          	lw	a5,24(a5)
c001ac9c:	06078793          	addi	a5,a5,96
c001aca0:	00078513          	mv	a0,a5
c001aca4:	d14ff0ef          	jal	ra,c001a1b8 <Xil_In32>
c001aca8:	fea42023          	sw	a0,-32(s0)
	ControlReg &= ~XSP_CR_TRANS_INHIBIT_MASK;
c001acac:	fe042783          	lw	a5,-32(s0)
c001acb0:	eff7f793          	andi	a5,a5,-257
c001acb4:	fef42023          	sw	a5,-32(s0)
	XSpi_SetControlReg(InstancePtr, ControlReg);
c001acb8:	fcc42783          	lw	a5,-52(s0)
c001acbc:	0187a783          	lw	a5,24(a5)
c001acc0:	06078793          	addi	a5,a5,96
c001acc4:	fe042583          	lw	a1,-32(s0)
c001acc8:	00078513          	mv	a0,a5
c001accc:	d14ff0ef          	jal	ra,c001a1e0 <Xil_Out32>
	/*
	 * If the interrupts are enabled as indicated by Global Interrupt
	 * Enable Register, then enable the transmit empty interrupt to operate
	 * in Interrupt mode of operation.
	 */
	if (GlobalIntrReg == TRUE) { /* Interrupt Mode of operation */
c001acd0:	fe442703          	lw	a4,-28(s0)
c001acd4:	00100793          	li	a5,1
c001acd8:	38f71063          	bne	a4,a5,c001b058 <XSpi_Transfer+0x744>

		/*
		 * Enable the transmit empty interrupt, which we use to
		 * determine progress on the transmission.
		 */
		XSpi_IntrEnable(InstancePtr, XSP_INTR_TX_EMPTY_MASK);
c001acdc:	fcc42783          	lw	a5,-52(s0)
c001ace0:	0187a783          	lw	a5,24(a5)
c001ace4:	02878493          	addi	s1,a5,40
c001ace8:	fcc42783          	lw	a5,-52(s0)
c001acec:	0187a783          	lw	a5,24(a5)
c001acf0:	02878793          	addi	a5,a5,40
c001acf4:	00078513          	mv	a0,a5
c001acf8:	cc0ff0ef          	jal	ra,c001a1b8 <Xil_In32>
c001acfc:	00050793          	mv	a5,a0
c001ad00:	0047e793          	ori	a5,a5,4
c001ad04:	00078593          	mv	a1,a5
c001ad08:	00048513          	mv	a0,s1
c001ad0c:	cd4ff0ef          	jal	ra,c001a1e0 <Xil_Out32>

		/*
		 * End critical section.
		 */
		XSpi_IntrGlobalEnable(InstancePtr);
c001ad10:	fcc42783          	lw	a5,-52(s0)
c001ad14:	0187a783          	lw	a5,24(a5)
c001ad18:	01c78793          	addi	a5,a5,28
c001ad1c:	800005b7          	lui	a1,0x80000
c001ad20:	00078513          	mv	a0,a5
c001ad24:	cbcff0ef          	jal	ra,c001a1e0 <Xil_Out32>
c001ad28:	3980006f          	j	c001b0c0 <XSpi_Transfer+0x7ac>
			/*
			 * Wait for the transfer to be done by polling the
			 * Transmit empty status bit
			 */
			do {
				StatusReg = XSpi_IntrGetStatus(InstancePtr);
c001ad2c:	fcc42783          	lw	a5,-52(s0)
c001ad30:	0187a783          	lw	a5,24(a5)
c001ad34:	02078793          	addi	a5,a5,32
c001ad38:	00078513          	mv	a0,a5
c001ad3c:	c7cff0ef          	jal	ra,c001a1b8 <Xil_In32>
c001ad40:	fea42623          	sw	a0,-20(s0)
			} while ((StatusReg & XSP_INTR_TX_EMPTY_MASK) == 0);
c001ad44:	fec42783          	lw	a5,-20(s0)
c001ad48:	0047f793          	andi	a5,a5,4
c001ad4c:	fe0780e3          	beqz	a5,c001ad2c <XSpi_Transfer+0x418>

			XSpi_IntrClear(InstancePtr,XSP_INTR_TX_EMPTY_MASK);
c001ad50:	fcc42783          	lw	a5,-52(s0)
c001ad54:	0187a783          	lw	a5,24(a5)
c001ad58:	02078493          	addi	s1,a5,32
c001ad5c:	fcc42783          	lw	a5,-52(s0)
c001ad60:	0187a783          	lw	a5,24(a5)
c001ad64:	02078793          	addi	a5,a5,32
c001ad68:	00078513          	mv	a0,a5
c001ad6c:	c4cff0ef          	jal	ra,c001a1b8 <Xil_In32>
c001ad70:	00050793          	mv	a5,a0
c001ad74:	0047e793          	ori	a5,a5,4
c001ad78:	00078593          	mv	a1,a5
c001ad7c:	00048513          	mv	a0,s1
c001ad80:	c60ff0ef          	jal	ra,c001a1e0 <Xil_Out32>
			 * and check for more data to transmit. Always inhibit
			 * the transmitter while the transmit register/FIFO is
			 * being filled, or make sure it is stopped if we're
			 * done.
			 */
			ControlReg = XSpi_GetControlReg(InstancePtr);
c001ad84:	fcc42783          	lw	a5,-52(s0)
c001ad88:	0187a783          	lw	a5,24(a5)
c001ad8c:	06078793          	addi	a5,a5,96
c001ad90:	00078513          	mv	a0,a5
c001ad94:	c24ff0ef          	jal	ra,c001a1b8 <Xil_In32>
c001ad98:	fea42023          	sw	a0,-32(s0)
			XSpi_SetControlReg(InstancePtr, ControlReg |
c001ad9c:	fcc42783          	lw	a5,-52(s0)
c001ada0:	0187a783          	lw	a5,24(a5)
c001ada4:	06078713          	addi	a4,a5,96
c001ada8:	fe042783          	lw	a5,-32(s0)
c001adac:	1007e793          	ori	a5,a5,256
c001adb0:	00078593          	mv	a1,a5
c001adb4:	00070513          	mv	a0,a4
c001adb8:	c28ff0ef          	jal	ra,c001a1e0 <Xil_Out32>
			 * when the Receive register/FIFO is empty. Always get
			 * the received data, but only fill the receive
			 * buffer if it points to something (the upper layer
			 * software may not care to receive data).
			 */
			StatusReg = XSpi_GetStatusReg(InstancePtr);
c001adbc:	fcc42783          	lw	a5,-52(s0)
c001adc0:	0187a783          	lw	a5,24(a5)
c001adc4:	06478793          	addi	a5,a5,100
c001adc8:	00078513          	mv	a0,a5
c001adcc:	becff0ef          	jal	ra,c001a1b8 <Xil_In32>
c001add0:	fea42623          	sw	a0,-20(s0)

			while ((StatusReg & XSP_SR_RX_EMPTY_MASK) == 0) {
c001add4:	1300006f          	j	c001af04 <XSpi_Transfer+0x5f0>

				Data = XSpi_ReadReg(InstancePtr->BaseAddr,
c001add8:	fcc42783          	lw	a5,-52(s0)
c001addc:	0187a783          	lw	a5,24(a5)
c001ade0:	06c78793          	addi	a5,a5,108
c001ade4:	00078513          	mv	a0,a5
c001ade8:	bd0ff0ef          	jal	ra,c001a1b8 <Xil_In32>
c001adec:	fea42423          	sw	a0,-24(s0)
								XSP_DRR_OFFSET);
				if (DataWidth == XSP_DATAWIDTH_BYTE) {
c001adf0:	fdf44703          	lbu	a4,-33(s0)
c001adf4:	00800793          	li	a5,8
c001adf8:	02f71a63          	bne	a4,a5,c001ae2c <XSpi_Transfer+0x518>
					/*
					 * Data Transfer Width is Byte (8 bit).
					 */
					if(InstancePtr->RecvBufferPtr != NULL) {
c001adfc:	fcc42783          	lw	a5,-52(s0)
c001ae00:	03c7a783          	lw	a5,60(a5)
c001ae04:	0a078663          	beqz	a5,c001aeb0 <XSpi_Transfer+0x59c>
						*InstancePtr->RecvBufferPtr++ =
c001ae08:	fcc42783          	lw	a5,-52(s0)
c001ae0c:	03c7a783          	lw	a5,60(a5)
c001ae10:	00178693          	addi	a3,a5,1
c001ae14:	fcc42703          	lw	a4,-52(s0)
c001ae18:	02d72e23          	sw	a3,60(a4)
							(u8)Data;
c001ae1c:	fe842703          	lw	a4,-24(s0)
c001ae20:	0ff77713          	andi	a4,a4,255
						*InstancePtr->RecvBufferPtr++ =
c001ae24:	00e78023          	sb	a4,0(a5)
c001ae28:	0880006f          	j	c001aeb0 <XSpi_Transfer+0x59c>
					}
				} else if (DataWidth ==
c001ae2c:	fdf44703          	lbu	a4,-33(s0)
c001ae30:	01000793          	li	a5,16
c001ae34:	04f71063          	bne	a4,a5,c001ae74 <XSpi_Transfer+0x560>
						XSP_DATAWIDTH_HALF_WORD) {
					/*
					 * Data Transfer Width is Half Word
					 * (16 bit).
					 */
					if (InstancePtr->RecvBufferPtr != NULL){
c001ae38:	fcc42783          	lw	a5,-52(s0)
c001ae3c:	03c7a783          	lw	a5,60(a5)
c001ae40:	06078863          	beqz	a5,c001aeb0 <XSpi_Transfer+0x59c>
					    *(u16 *)InstancePtr->RecvBufferPtr =
c001ae44:	fcc42783          	lw	a5,-52(s0)
c001ae48:	03c7a783          	lw	a5,60(a5)
							(u16)Data;
c001ae4c:	fe842703          	lw	a4,-24(s0)
c001ae50:	01071713          	slli	a4,a4,0x10
c001ae54:	01075713          	srli	a4,a4,0x10
					    *(u16 *)InstancePtr->RecvBufferPtr =
c001ae58:	00e79023          	sh	a4,0(a5)
						InstancePtr->RecvBufferPtr += 2;
c001ae5c:	fcc42783          	lw	a5,-52(s0)
c001ae60:	03c7a783          	lw	a5,60(a5)
c001ae64:	00278713          	addi	a4,a5,2
c001ae68:	fcc42783          	lw	a5,-52(s0)
c001ae6c:	02e7ae23          	sw	a4,60(a5)
c001ae70:	0400006f          	j	c001aeb0 <XSpi_Transfer+0x59c>
					}
				} else if (DataWidth == XSP_DATAWIDTH_WORD) {
c001ae74:	fdf44703          	lbu	a4,-33(s0)
c001ae78:	02000793          	li	a5,32
c001ae7c:	02f71a63          	bne	a4,a5,c001aeb0 <XSpi_Transfer+0x59c>
					/*
					 * Data Transfer Width is Word (32 bit).
					 */
					if (InstancePtr->RecvBufferPtr != NULL){
c001ae80:	fcc42783          	lw	a5,-52(s0)
c001ae84:	03c7a783          	lw	a5,60(a5)
c001ae88:	02078463          	beqz	a5,c001aeb0 <XSpi_Transfer+0x59c>
					    *(u32 *)InstancePtr->RecvBufferPtr =
c001ae8c:	fcc42783          	lw	a5,-52(s0)
c001ae90:	03c7a783          	lw	a5,60(a5)
c001ae94:	fe842703          	lw	a4,-24(s0)
c001ae98:	00e7a023          	sw	a4,0(a5)
							Data;
						InstancePtr->RecvBufferPtr += 4;
c001ae9c:	fcc42783          	lw	a5,-52(s0)
c001aea0:	03c7a783          	lw	a5,60(a5)
c001aea4:	00478713          	addi	a4,a5,4
c001aea8:	fcc42783          	lw	a5,-52(s0)
c001aeac:	02e7ae23          	sw	a4,60(a5)
					}
				}
				InstancePtr->Stats.BytesTransferred +=
c001aeb0:	fcc42783          	lw	a5,-52(s0)
c001aeb4:	0107a783          	lw	a5,16(a5)
						(DataWidth >> 3);
c001aeb8:	fdf44703          	lbu	a4,-33(s0)
c001aebc:	00375713          	srli	a4,a4,0x3
c001aec0:	0ff77713          	andi	a4,a4,255
				InstancePtr->Stats.BytesTransferred +=
c001aec4:	00e78733          	add	a4,a5,a4
c001aec8:	fcc42783          	lw	a5,-52(s0)
c001aecc:	00e7a823          	sw	a4,16(a5)
				ByteCount -= (DataWidth >> 3);
c001aed0:	fdf44783          	lbu	a5,-33(s0)
c001aed4:	0037d793          	srli	a5,a5,0x3
c001aed8:	0ff7f793          	andi	a5,a5,255
c001aedc:	00078713          	mv	a4,a5
c001aee0:	fc042783          	lw	a5,-64(s0)
c001aee4:	40e787b3          	sub	a5,a5,a4
c001aee8:	fcf42023          	sw	a5,-64(s0)
				StatusReg = XSpi_GetStatusReg(InstancePtr);
c001aeec:	fcc42783          	lw	a5,-52(s0)
c001aef0:	0187a783          	lw	a5,24(a5)
c001aef4:	06478793          	addi	a5,a5,100
c001aef8:	00078513          	mv	a0,a5
c001aefc:	abcff0ef          	jal	ra,c001a1b8 <Xil_In32>
c001af00:	fea42623          	sw	a0,-20(s0)
			while ((StatusReg & XSP_SR_RX_EMPTY_MASK) == 0) {
c001af04:	fec42783          	lw	a5,-20(s0)
c001af08:	0017f793          	andi	a5,a5,1
c001af0c:	ec0786e3          	beqz	a5,c001add8 <XSpi_Transfer+0x4c4>
			}

			if (InstancePtr->RemainingBytes > 0) {
c001af10:	fcc42783          	lw	a5,-52(s0)
c001af14:	0447a783          	lw	a5,68(a5)
c001af18:	14078063          	beqz	a5,c001b058 <XSpi_Transfer+0x744>
				 * know the size of the FIFO or that there even
				 * is a FIFO.
				 * The downside is that the status must be read
				 * each loop iteration.
				 */
				StatusReg = XSpi_GetStatusReg(InstancePtr);
c001af1c:	fcc42783          	lw	a5,-52(s0)
c001af20:	0187a783          	lw	a5,24(a5)
c001af24:	06478793          	addi	a5,a5,100
c001af28:	00078513          	mv	a0,a5
c001af2c:	a8cff0ef          	jal	ra,c001a1b8 <Xil_In32>
c001af30:	fea42623          	sw	a0,-20(s0)

				while(((StatusReg & XSP_SR_TX_FULL_MASK)== 0) &&
c001af34:	0d00006f          	j	c001b004 <XSpi_Transfer+0x6f0>
					(InstancePtr->RemainingBytes > 0)) {
					if (DataWidth == XSP_DATAWIDTH_BYTE) {
c001af38:	fdf44703          	lbu	a4,-33(s0)
c001af3c:	00800793          	li	a5,8
c001af40:	00f71c63          	bne	a4,a5,c001af58 <XSpi_Transfer+0x644>
						/*
						 * Data Transfer Width is Byte
						 * (8 bit).
						 */
						Data = *InstancePtr->
c001af44:	fcc42783          	lw	a5,-52(s0)
c001af48:	0387a783          	lw	a5,56(a5)
c001af4c:	0007c783          	lbu	a5,0(a5)
c001af50:	fef42423          	sw	a5,-24(s0)
c001af54:	0400006f          	j	c001af94 <XSpi_Transfer+0x680>
								SendBufferPtr;

					} else if (DataWidth ==
c001af58:	fdf44703          	lbu	a4,-33(s0)
c001af5c:	01000793          	li	a5,16
c001af60:	00f71c63          	bne	a4,a5,c001af78 <XSpi_Transfer+0x664>

						/*
						 * Data Transfer Width is Half
						 * Word (16 bit).
			 			 */
						Data = *(u16 *)InstancePtr->
c001af64:	fcc42783          	lw	a5,-52(s0)
c001af68:	0387a783          	lw	a5,56(a5)
c001af6c:	0007d783          	lhu	a5,0(a5)
c001af70:	fef42423          	sw	a5,-24(s0)
c001af74:	0200006f          	j	c001af94 <XSpi_Transfer+0x680>
								SendBufferPtr;
					} else if (DataWidth ==
c001af78:	fdf44703          	lbu	a4,-33(s0)
c001af7c:	02000793          	li	a5,32
c001af80:	00f71a63          	bne	a4,a5,c001af94 <XSpi_Transfer+0x680>
							XSP_DATAWIDTH_WORD) {
						/*
						 * Data Transfer Width is Word
						 * (32 bit).
			 			 */
						Data = *(u32 *)InstancePtr->
c001af84:	fcc42783          	lw	a5,-52(s0)
c001af88:	0387a783          	lw	a5,56(a5)
c001af8c:	0007a783          	lw	a5,0(a5)
c001af90:	fef42423          	sw	a5,-24(s0)
								SendBufferPtr;
					}
					XSpi_WriteReg(InstancePtr->BaseAddr,
c001af94:	fcc42783          	lw	a5,-52(s0)
c001af98:	0187a783          	lw	a5,24(a5)
c001af9c:	06878793          	addi	a5,a5,104
c001afa0:	fe842583          	lw	a1,-24(s0)
c001afa4:	00078513          	mv	a0,a5
c001afa8:	a38ff0ef          	jal	ra,c001a1e0 <Xil_Out32>
							XSP_DTR_OFFSET, Data);
					InstancePtr->SendBufferPtr +=
c001afac:	fcc42783          	lw	a5,-52(s0)
c001afb0:	0387a783          	lw	a5,56(a5)
							(DataWidth >> 3);
c001afb4:	fdf44703          	lbu	a4,-33(s0)
c001afb8:	00375713          	srli	a4,a4,0x3
c001afbc:	0ff77713          	andi	a4,a4,255
					InstancePtr->SendBufferPtr +=
c001afc0:	00e78733          	add	a4,a5,a4
c001afc4:	fcc42783          	lw	a5,-52(s0)
c001afc8:	02e7ac23          	sw	a4,56(a5)
					InstancePtr->RemainingBytes -=
c001afcc:	fcc42783          	lw	a5,-52(s0)
c001afd0:	0447a783          	lw	a5,68(a5)
							(DataWidth >> 3);
c001afd4:	fdf44703          	lbu	a4,-33(s0)
c001afd8:	00375713          	srli	a4,a4,0x3
c001afdc:	0ff77713          	andi	a4,a4,255
					InstancePtr->RemainingBytes -=
c001afe0:	40e78733          	sub	a4,a5,a4
c001afe4:	fcc42783          	lw	a5,-52(s0)
c001afe8:	04e7a223          	sw	a4,68(a5)
					StatusReg = XSpi_GetStatusReg(
c001afec:	fcc42783          	lw	a5,-52(s0)
c001aff0:	0187a783          	lw	a5,24(a5)
c001aff4:	06478793          	addi	a5,a5,100
c001aff8:	00078513          	mv	a0,a5
c001affc:	9bcff0ef          	jal	ra,c001a1b8 <Xil_In32>
c001b000:	fea42623          	sw	a0,-20(s0)
				while(((StatusReg & XSP_SR_TX_FULL_MASK)== 0) &&
c001b004:	fec42783          	lw	a5,-20(s0)
c001b008:	0087f793          	andi	a5,a5,8
c001b00c:	00079863          	bnez	a5,c001b01c <XSpi_Transfer+0x708>
					(InstancePtr->RemainingBytes > 0)) {
c001b010:	fcc42783          	lw	a5,-52(s0)
c001b014:	0447a783          	lw	a5,68(a5)
				while(((StatusReg & XSP_SR_TX_FULL_MASK)== 0) &&
c001b018:	f20790e3          	bnez	a5,c001af38 <XSpi_Transfer+0x624>

				/*
				 * Start the transfer by not inhibiting the
				 * transmitter any longer.
				 */
				ControlReg = XSpi_GetControlReg(InstancePtr);
c001b01c:	fcc42783          	lw	a5,-52(s0)
c001b020:	0187a783          	lw	a5,24(a5)
c001b024:	06078793          	addi	a5,a5,96
c001b028:	00078513          	mv	a0,a5
c001b02c:	98cff0ef          	jal	ra,c001a1b8 <Xil_In32>
c001b030:	fea42023          	sw	a0,-32(s0)
				ControlReg &= ~XSP_CR_TRANS_INHIBIT_MASK;
c001b034:	fe042783          	lw	a5,-32(s0)
c001b038:	eff7f793          	andi	a5,a5,-257
c001b03c:	fef42023          	sw	a5,-32(s0)
				XSpi_SetControlReg(InstancePtr, ControlReg);
c001b040:	fcc42783          	lw	a5,-52(s0)
c001b044:	0187a783          	lw	a5,24(a5)
c001b048:	06078793          	addi	a5,a5,96
c001b04c:	fe042583          	lw	a1,-32(s0)
c001b050:	00078513          	mv	a0,a5
c001b054:	98cff0ef          	jal	ra,c001a1e0 <Xil_Out32>
		while(ByteCount > 0) {
c001b058:	fc042783          	lw	a5,-64(s0)
c001b05c:	cc0798e3          	bnez	a5,c001ad2c <XSpi_Transfer+0x418>

		/*
		 * Stop the transfer (hold off automatic sending) by inhibiting
		 * the transmitter.
		 */
		ControlReg = XSpi_GetControlReg(InstancePtr);
c001b060:	fcc42783          	lw	a5,-52(s0)
c001b064:	0187a783          	lw	a5,24(a5)
c001b068:	06078793          	addi	a5,a5,96
c001b06c:	00078513          	mv	a0,a5
c001b070:	948ff0ef          	jal	ra,c001a1b8 <Xil_In32>
c001b074:	fea42023          	sw	a0,-32(s0)
		XSpi_SetControlReg(InstancePtr,
c001b078:	fcc42783          	lw	a5,-52(s0)
c001b07c:	0187a783          	lw	a5,24(a5)
c001b080:	06078713          	addi	a4,a5,96
c001b084:	fe042783          	lw	a5,-32(s0)
c001b088:	1007e793          	ori	a5,a5,256
c001b08c:	00078593          	mv	a1,a5
c001b090:	00070513          	mv	a0,a4
c001b094:	94cff0ef          	jal	ra,c001a1e0 <Xil_Out32>
		 * Select the slave on the SPI bus when the transfer is
		 * complete, this is necessary for some SPI devices,
		 * such as serial EEPROMs work correctly as chip enable
		 * may be connected to slave select
		 */
		XSpi_SetSlaveSelectReg(InstancePtr,
c001b098:	fcc42783          	lw	a5,-52(s0)
c001b09c:	0187a783          	lw	a5,24(a5)
c001b0a0:	07078713          	addi	a4,a5,112
c001b0a4:	fcc42783          	lw	a5,-52(s0)
c001b0a8:	0307a783          	lw	a5,48(a5)
c001b0ac:	00078593          	mv	a1,a5
c001b0b0:	00070513          	mv	a0,a4
c001b0b4:	92cff0ef          	jal	ra,c001a1e0 <Xil_Out32>
					InstancePtr->SlaveSelectMask);
		InstancePtr->IsBusy = FALSE;
c001b0b8:	fcc42783          	lw	a5,-52(s0)
c001b0bc:	0407a423          	sw	zero,72(a5)
	}

	return XST_SUCCESS;
c001b0c0:	00000793          	li	a5,0
}
c001b0c4:	00078513          	mv	a0,a5
c001b0c8:	03c12083          	lw	ra,60(sp)
c001b0cc:	03812403          	lw	s0,56(sp)
c001b0d0:	03412483          	lw	s1,52(sp)
c001b0d4:	04010113          	addi	sp,sp,64
c001b0d8:	00008067          	ret

c001b0dc <XSpi_SetSlaveSelect>:
* occurs. The slave is not selected when the SPI is idle. The slave select
* has no affect when the device is configured as a slave.
*
******************************************************************************/
int XSpi_SetSlaveSelect(XSpi *InstancePtr, u32 SlaveMask)
{
c001b0dc:	fd010113          	addi	sp,sp,-48
c001b0e0:	02112623          	sw	ra,44(sp)
c001b0e4:	02812423          	sw	s0,40(sp)
c001b0e8:	03010413          	addi	s0,sp,48
c001b0ec:	fca42e23          	sw	a0,-36(s0)
c001b0f0:	fcb42c23          	sw	a1,-40(s0)
	int NumAsserted;
	int Index;

	Xil_AssertNonvoid(InstancePtr != NULL);
c001b0f4:	fdc42783          	lw	a5,-36(s0)
c001b0f8:	02078463          	beqz	a5,c001b120 <XSpi_SetSlaveSelect+0x44>
c001b0fc:	07fe8797          	auipc	a5,0x7fe8
c001b100:	81878793          	addi	a5,a5,-2024 # c8002914 <Xil_AssertStatus>
c001b104:	0007a023          	sw	zero,0(a5)
	Xil_AssertNonvoid(InstancePtr->IsReady == XIL_COMPONENT_IS_READY);
c001b108:	fdc42783          	lw	a5,-36(s0)
c001b10c:	01c7a703          	lw	a4,28(a5)
c001b110:	111117b7          	lui	a5,0x11111
c001b114:	11178793          	addi	a5,a5,273 # 11111111 <_DMEM_LENGTH+0x10911111>
c001b118:	04f71663          	bne	a4,a5,c001b164 <XSpi_SetSlaveSelect+0x88>
c001b11c:	02c0006f          	j	c001b148 <XSpi_SetSlaveSelect+0x6c>
	Xil_AssertNonvoid(InstancePtr != NULL);
c001b120:	37d00593          	li	a1,893
c001b124:	07fe7517          	auipc	a0,0x7fe7
c001b128:	81c50513          	addi	a0,a0,-2020 # c8001940 <__rodata_start+0x1940>
c001b12c:	191020ef          	jal	ra,c001dabc <Xil_Assert>
c001b130:	07fe7797          	auipc	a5,0x7fe7
c001b134:	7e478793          	addi	a5,a5,2020 # c8002914 <Xil_AssertStatus>
c001b138:	00100713          	li	a4,1
c001b13c:	00e7a023          	sw	a4,0(a5)
c001b140:	00000793          	li	a5,0
c001b144:	0c40006f          	j	c001b208 <XSpi_SetSlaveSelect+0x12c>
	Xil_AssertNonvoid(InstancePtr->IsReady == XIL_COMPONENT_IS_READY);
c001b148:	07fe7797          	auipc	a5,0x7fe7
c001b14c:	7cc78793          	addi	a5,a5,1996 # c8002914 <Xil_AssertStatus>
c001b150:	0007a023          	sw	zero,0(a5)
	 * No need to worry about a critical section here since even if the Isr
	 * changes the busy flag just after we read it, the function will return
	 * busy and the caller can retry when notified that their current
	 * transfer is done.
	 */
	if (InstancePtr->IsBusy) {
c001b154:	fdc42783          	lw	a5,-36(s0)
c001b158:	0487a783          	lw	a5,72(a5)
c001b15c:	02078c63          	beqz	a5,c001b194 <XSpi_SetSlaveSelect+0xb8>
c001b160:	02c0006f          	j	c001b18c <XSpi_SetSlaveSelect+0xb0>
	Xil_AssertNonvoid(InstancePtr->IsReady == XIL_COMPONENT_IS_READY);
c001b164:	37e00593          	li	a1,894
c001b168:	07fe6517          	auipc	a0,0x7fe6
c001b16c:	7d850513          	addi	a0,a0,2008 # c8001940 <__rodata_start+0x1940>
c001b170:	14d020ef          	jal	ra,c001dabc <Xil_Assert>
c001b174:	07fe7797          	auipc	a5,0x7fe7
c001b178:	7a078793          	addi	a5,a5,1952 # c8002914 <Xil_AssertStatus>
c001b17c:	00100713          	li	a4,1
c001b180:	00e7a023          	sw	a4,0(a5)
c001b184:	00000793          	li	a5,0
c001b188:	0800006f          	j	c001b208 <XSpi_SetSlaveSelect+0x12c>
		return XST_DEVICE_BUSY;
c001b18c:	01500793          	li	a5,21
c001b190:	0780006f          	j	c001b208 <XSpi_SetSlaveSelect+0x12c>
	}

	/*
	 * Verify that only one bit in the incoming slave mask is set.
	 */
	NumAsserted = 0;
c001b194:	fe042623          	sw	zero,-20(s0)
	for (Index = (InstancePtr->NumSlaveBits - 1); Index >= 0; Index--) {
c001b198:	fdc42783          	lw	a5,-36(s0)
c001b19c:	02c7c783          	lbu	a5,44(a5)
c001b1a0:	fff78793          	addi	a5,a5,-1
c001b1a4:	fef42423          	sw	a5,-24(s0)
c001b1a8:	0300006f          	j	c001b1d8 <XSpi_SetSlaveSelect+0xfc>
		if ((SlaveMask >> Index) & 0x1) {
c001b1ac:	fe842783          	lw	a5,-24(s0)
c001b1b0:	fd842703          	lw	a4,-40(s0)
c001b1b4:	00f757b3          	srl	a5,a4,a5
c001b1b8:	0017f793          	andi	a5,a5,1
c001b1bc:	00078863          	beqz	a5,c001b1cc <XSpi_SetSlaveSelect+0xf0>
			/* this bit is asserted */
			NumAsserted++;
c001b1c0:	fec42783          	lw	a5,-20(s0)
c001b1c4:	00178793          	addi	a5,a5,1
c001b1c8:	fef42623          	sw	a5,-20(s0)
	for (Index = (InstancePtr->NumSlaveBits - 1); Index >= 0; Index--) {
c001b1cc:	fe842783          	lw	a5,-24(s0)
c001b1d0:	fff78793          	addi	a5,a5,-1
c001b1d4:	fef42423          	sw	a5,-24(s0)
c001b1d8:	fe842783          	lw	a5,-24(s0)
c001b1dc:	fc07d8e3          	bgez	a5,c001b1ac <XSpi_SetSlaveSelect+0xd0>
	}

	/*
	 * Return an error if more than one slave is selected.
	 */
	if (NumAsserted > 1) {
c001b1e0:	fec42703          	lw	a4,-20(s0)
c001b1e4:	00100793          	li	a5,1
c001b1e8:	00e7d663          	bge	a5,a4,c001b1f4 <XSpi_SetSlaveSelect+0x118>
		return XST_SPI_TOO_MANY_SLAVES;
c001b1ec:	48400793          	li	a5,1156
c001b1f0:	0180006f          	j	c001b208 <XSpi_SetSlaveSelect+0x12c>
	 * A single slave is either being selected or the incoming SlaveMask is
	 * zero, which means the slave is being deselected. Setup the value to
	 * be  written to the slave select register as the inverse of the slave
	 * mask.
	 */
	InstancePtr->SlaveSelectReg = ~SlaveMask;
c001b1f4:	fd842783          	lw	a5,-40(s0)
c001b1f8:	fff7c713          	not	a4,a5
c001b1fc:	fdc42783          	lw	a5,-36(s0)
c001b200:	02e7aa23          	sw	a4,52(a5)

	return XST_SUCCESS;
c001b204:	00000793          	li	a5,0
}
c001b208:	00078513          	mv	a0,a5
c001b20c:	02c12083          	lw	ra,44(sp)
c001b210:	02812403          	lw	s0,40(sp)
c001b214:	03010113          	addi	sp,sp,48
c001b218:	00008067          	ret

c001b21c <XSpi_GetSlaveSelect>:
*		This API deos not read the register from the core and returns
*		the slave select register stored in the instance pointer.
*
******************************************************************************/
u32 XSpi_GetSlaveSelect(XSpi *InstancePtr)
{
c001b21c:	fe010113          	addi	sp,sp,-32
c001b220:	00112e23          	sw	ra,28(sp)
c001b224:	00812c23          	sw	s0,24(sp)
c001b228:	02010413          	addi	s0,sp,32
c001b22c:	fea42623          	sw	a0,-20(s0)
	Xil_AssertNonvoid(InstancePtr != NULL);
c001b230:	fec42783          	lw	a5,-20(s0)
c001b234:	02078463          	beqz	a5,c001b25c <XSpi_GetSlaveSelect+0x40>
c001b238:	07fe7797          	auipc	a5,0x7fe7
c001b23c:	6dc78793          	addi	a5,a5,1756 # c8002914 <Xil_AssertStatus>
c001b240:	0007a023          	sw	zero,0(a5)
	Xil_AssertNonvoid(InstancePtr->IsReady == XIL_COMPONENT_IS_READY);
c001b244:	fec42783          	lw	a5,-20(s0)
c001b248:	01c7a703          	lw	a4,28(a5)
c001b24c:	111117b7          	lui	a5,0x11111
c001b250:	11178793          	addi	a5,a5,273 # 11111111 <_DMEM_LENGTH+0x10911111>
c001b254:	04f71663          	bne	a4,a5,c001b2a0 <XSpi_GetSlaveSelect+0x84>
c001b258:	02c0006f          	j	c001b284 <XSpi_GetSlaveSelect+0x68>
	Xil_AssertNonvoid(InstancePtr != NULL);
c001b25c:	3bc00593          	li	a1,956
c001b260:	07fe6517          	auipc	a0,0x7fe6
c001b264:	6e050513          	addi	a0,a0,1760 # c8001940 <__rodata_start+0x1940>
c001b268:	055020ef          	jal	ra,c001dabc <Xil_Assert>
c001b26c:	07fe7797          	auipc	a5,0x7fe7
c001b270:	6a878793          	addi	a5,a5,1704 # c8002914 <Xil_AssertStatus>
c001b274:	00100713          	li	a4,1
c001b278:	00e7a023          	sw	a4,0(a5)
c001b27c:	00000793          	li	a5,0
c001b280:	0440006f          	j	c001b2c4 <XSpi_GetSlaveSelect+0xa8>
	Xil_AssertNonvoid(InstancePtr->IsReady == XIL_COMPONENT_IS_READY);
c001b284:	07fe7797          	auipc	a5,0x7fe7
c001b288:	69078793          	addi	a5,a5,1680 # c8002914 <Xil_AssertStatus>
c001b28c:	0007a023          	sw	zero,0(a5)
	/*
	 * Return the inverse of the value contained in
	 * InstancePtr->SlaveSelectReg. This value is set using the API
	 * XSpi_SetSlaveSelect.
	 */
	return ~InstancePtr->SlaveSelectReg;
c001b290:	fec42783          	lw	a5,-20(s0)
c001b294:	0347a783          	lw	a5,52(a5)
c001b298:	fff7c793          	not	a5,a5
c001b29c:	0280006f          	j	c001b2c4 <XSpi_GetSlaveSelect+0xa8>
	Xil_AssertNonvoid(InstancePtr->IsReady == XIL_COMPONENT_IS_READY);
c001b2a0:	3bd00593          	li	a1,957
c001b2a4:	07fe6517          	auipc	a0,0x7fe6
c001b2a8:	69c50513          	addi	a0,a0,1692 # c8001940 <__rodata_start+0x1940>
c001b2ac:	011020ef          	jal	ra,c001dabc <Xil_Assert>
c001b2b0:	07fe7797          	auipc	a5,0x7fe7
c001b2b4:	66478793          	addi	a5,a5,1636 # c8002914 <Xil_AssertStatus>
c001b2b8:	00100713          	li	a4,1
c001b2bc:	00e7a023          	sw	a4,0(a5)
c001b2c0:	00000793          	li	a5,0
}
c001b2c4:	00078513          	mv	a0,a5
c001b2c8:	01c12083          	lw	ra,28(sp)
c001b2cc:	01812403          	lw	s0,24(sp)
c001b2d0:	02010113          	addi	sp,sp,32
c001b2d4:	00008067          	ret

c001b2d8 <XSpi_SetStatusHandler>:
* quickly and queue potentially time-consuming work to a task-level thread.
*
******************************************************************************/
void XSpi_SetStatusHandler(XSpi *InstancePtr, void *CallBackRef,
			   XSpi_StatusHandler FuncPtr)
{
c001b2d8:	fe010113          	addi	sp,sp,-32
c001b2dc:	00112e23          	sw	ra,28(sp)
c001b2e0:	00812c23          	sw	s0,24(sp)
c001b2e4:	02010413          	addi	s0,sp,32
c001b2e8:	fea42623          	sw	a0,-20(s0)
c001b2ec:	feb42423          	sw	a1,-24(s0)
c001b2f0:	fec42223          	sw	a2,-28(s0)
	Xil_AssertVoid(InstancePtr != NULL);
c001b2f4:	fec42783          	lw	a5,-20(s0)
c001b2f8:	00078e63          	beqz	a5,c001b314 <XSpi_SetStatusHandler+0x3c>
c001b2fc:	07fe7797          	auipc	a5,0x7fe7
c001b300:	61878793          	addi	a5,a5,1560 # c8002914 <Xil_AssertStatus>
c001b304:	0007a023          	sw	zero,0(a5)
	Xil_AssertVoid(FuncPtr != NULL);
c001b308:	fe442783          	lw	a5,-28(s0)
c001b30c:	04078863          	beqz	a5,c001b35c <XSpi_SetStatusHandler+0x84>
c001b310:	0280006f          	j	c001b338 <XSpi_SetStatusHandler+0x60>
	Xil_AssertVoid(InstancePtr != NULL);
c001b314:	3fa00593          	li	a1,1018
c001b318:	07fe6517          	auipc	a0,0x7fe6
c001b31c:	62850513          	addi	a0,a0,1576 # c8001940 <__rodata_start+0x1940>
c001b320:	79c020ef          	jal	ra,c001dabc <Xil_Assert>
c001b324:	07fe7797          	auipc	a5,0x7fe7
c001b328:	5f078793          	addi	a5,a5,1520 # c8002914 <Xil_AssertStatus>
c001b32c:	00100713          	li	a4,1
c001b330:	00e7a023          	sw	a4,0(a5)
c001b334:	0980006f          	j	c001b3cc <XSpi_SetStatusHandler+0xf4>
	Xil_AssertVoid(FuncPtr != NULL);
c001b338:	07fe7797          	auipc	a5,0x7fe7
c001b33c:	5dc78793          	addi	a5,a5,1500 # c8002914 <Xil_AssertStatus>
c001b340:	0007a023          	sw	zero,0(a5)
	Xil_AssertVoid(InstancePtr->IsReady == XIL_COMPONENT_IS_READY);
c001b344:	fec42783          	lw	a5,-20(s0)
c001b348:	01c7a703          	lw	a4,28(a5)
c001b34c:	111117b7          	lui	a5,0x11111
c001b350:	11178793          	addi	a5,a5,273 # 11111111 <_DMEM_LENGTH+0x10911111>
c001b354:	04f71a63          	bne	a4,a5,c001b3a8 <XSpi_SetStatusHandler+0xd0>
c001b358:	0280006f          	j	c001b380 <XSpi_SetStatusHandler+0xa8>
	Xil_AssertVoid(FuncPtr != NULL);
c001b35c:	3fb00593          	li	a1,1019
c001b360:	07fe6517          	auipc	a0,0x7fe6
c001b364:	5e050513          	addi	a0,a0,1504 # c8001940 <__rodata_start+0x1940>
c001b368:	754020ef          	jal	ra,c001dabc <Xil_Assert>
c001b36c:	07fe7797          	auipc	a5,0x7fe7
c001b370:	5a878793          	addi	a5,a5,1448 # c8002914 <Xil_AssertStatus>
c001b374:	00100713          	li	a4,1
c001b378:	00e7a023          	sw	a4,0(a5)
c001b37c:	0500006f          	j	c001b3cc <XSpi_SetStatusHandler+0xf4>
	Xil_AssertVoid(InstancePtr->IsReady == XIL_COMPONENT_IS_READY);
c001b380:	07fe7797          	auipc	a5,0x7fe7
c001b384:	59478793          	addi	a5,a5,1428 # c8002914 <Xil_AssertStatus>
c001b388:	0007a023          	sw	zero,0(a5)

	InstancePtr->StatusHandler = FuncPtr;
c001b38c:	fec42783          	lw	a5,-20(s0)
c001b390:	fe442703          	lw	a4,-28(s0)
c001b394:	04e7a623          	sw	a4,76(a5)
	InstancePtr->StatusRef = CallBackRef;
c001b398:	fec42783          	lw	a5,-20(s0)
c001b39c:	fe842703          	lw	a4,-24(s0)
c001b3a0:	04e7a823          	sw	a4,80(a5)
c001b3a4:	0280006f          	j	c001b3cc <XSpi_SetStatusHandler+0xf4>
	Xil_AssertVoid(InstancePtr->IsReady == XIL_COMPONENT_IS_READY);
c001b3a8:	3fc00593          	li	a1,1020
c001b3ac:	07fe6517          	auipc	a0,0x7fe6
c001b3b0:	59450513          	addi	a0,a0,1428 # c8001940 <__rodata_start+0x1940>
c001b3b4:	708020ef          	jal	ra,c001dabc <Xil_Assert>
c001b3b8:	07fe7797          	auipc	a5,0x7fe7
c001b3bc:	55c78793          	addi	a5,a5,1372 # c8002914 <Xil_AssertStatus>
c001b3c0:	00100713          	li	a4,1
c001b3c4:	00e7a023          	sw	a4,0(a5)
c001b3c8:	00000013          	nop
}
c001b3cc:	01c12083          	lw	ra,28(sp)
c001b3d0:	01812403          	lw	s0,24(sp)
c001b3d4:	02010113          	addi	sp,sp,32
c001b3d8:	00008067          	ret

c001b3dc <StubStatusHandler>:
* @note		None.
*
******************************************************************************/
static void StubStatusHandler(void *CallBackRef, u32 StatusEvent,
				unsigned int ByteCount)
{
c001b3dc:	fe010113          	addi	sp,sp,-32
c001b3e0:	00112e23          	sw	ra,28(sp)
c001b3e4:	00812c23          	sw	s0,24(sp)
c001b3e8:	02010413          	addi	s0,sp,32
c001b3ec:	fea42623          	sw	a0,-20(s0)
c001b3f0:	feb42423          	sw	a1,-24(s0)
c001b3f4:	fec42223          	sw	a2,-28(s0)
	(void )CallBackRef;
	(void )StatusEvent;
	(void ) ByteCount;
	Xil_AssertVoidAlways();
c001b3f8:	41800593          	li	a1,1048
c001b3fc:	07fe6517          	auipc	a0,0x7fe6
c001b400:	54450513          	addi	a0,a0,1348 # c8001940 <__rodata_start+0x1940>
c001b404:	6b8020ef          	jal	ra,c001dabc <Xil_Assert>
c001b408:	07fe7797          	auipc	a5,0x7fe7
c001b40c:	50c78793          	addi	a5,a5,1292 # c8002914 <Xil_AssertStatus>
c001b410:	00100713          	li	a4,1
c001b414:	00e7a023          	sw	a4,0(a5)
c001b418:	00000013          	nop
}
c001b41c:	01c12083          	lw	ra,28(sp)
c001b420:	01812403          	lw	s0,24(sp)
c001b424:	02010113          	addi	sp,sp,32
c001b428:	00008067          	ret

c001b42c <XSpi_InterruptHandler>:
* is complete.  This is being done regardless of whether it is a slave or a
* master since the hardware does not drive the slave select as a slave.
*
******************************************************************************/
void XSpi_InterruptHandler(void *InstancePtr)
{
c001b42c:	fc010113          	addi	sp,sp,-64
c001b430:	02112e23          	sw	ra,60(sp)
c001b434:	02812c23          	sw	s0,56(sp)
c001b438:	02912a23          	sw	s1,52(sp)
c001b43c:	04010413          	addi	s0,sp,64
c001b440:	fca42623          	sw	a0,-52(s0)
	XSpi *SpiPtr = (XSpi *)InstancePtr;
c001b444:	fcc42783          	lw	a5,-52(s0)
c001b448:	fef42223          	sw	a5,-28(s0)
	u32 IntrStatus;
	unsigned int BytesDone;	/* number of bytes done so far */
	u32 Data = 0;
c001b44c:	fe042623          	sw	zero,-20(s0)
	u32 ControlReg;
	u32 StatusReg;
	u8  DataWidth;

	Xil_AssertVoid(InstancePtr != NULL);
c001b450:	fcc42783          	lw	a5,-52(s0)
c001b454:	08078263          	beqz	a5,c001b4d8 <XSpi_InterruptHandler+0xac>
c001b458:	07fe7797          	auipc	a5,0x7fe7
c001b45c:	4bc78793          	addi	a5,a5,1212 # c8002914 <Xil_AssertStatus>
c001b460:	0007a023          	sw	zero,0(a5)

	/*
	 * Update the statistics for the number of interrupts.
	 */
	SpiPtr->Stats.NumInterrupts++;
c001b464:	fe442783          	lw	a5,-28(s0)
c001b468:	0147a783          	lw	a5,20(a5)
c001b46c:	00178713          	addi	a4,a5,1
c001b470:	fe442783          	lw	a5,-28(s0)
c001b474:	00e7aa23          	sw	a4,20(a5)
	 * this Isr causes another interrupt to be generated. If we clear at the
	 * end of the Isr, we may miss this newly generated interrupt. This
	 * occurs because we transmit from within the Isr, potentially causing
	 * another TX_EMPTY interrupt.
	 */
	IntrStatus = XSpi_IntrGetStatus(SpiPtr);
c001b478:	fe442783          	lw	a5,-28(s0)
c001b47c:	0187a783          	lw	a5,24(a5)
c001b480:	02078793          	addi	a5,a5,32
c001b484:	00078513          	mv	a0,a5
c001b488:	d31fe0ef          	jal	ra,c001a1b8 <Xil_In32>
c001b48c:	fea42023          	sw	a0,-32(s0)
	XSpi_IntrClear(SpiPtr, IntrStatus);
c001b490:	fe442783          	lw	a5,-28(s0)
c001b494:	0187a783          	lw	a5,24(a5)
c001b498:	02078493          	addi	s1,a5,32
c001b49c:	fe442783          	lw	a5,-28(s0)
c001b4a0:	0187a783          	lw	a5,24(a5)
c001b4a4:	02078793          	addi	a5,a5,32
c001b4a8:	00078513          	mv	a0,a5
c001b4ac:	d0dfe0ef          	jal	ra,c001a1b8 <Xil_In32>
c001b4b0:	00050713          	mv	a4,a0
c001b4b4:	fe042783          	lw	a5,-32(s0)
c001b4b8:	00f767b3          	or	a5,a4,a5
c001b4bc:	00078593          	mv	a1,a5
c001b4c0:	00048513          	mv	a0,s1
c001b4c4:	d1dfe0ef          	jal	ra,c001a1e0 <Xil_Out32>
	/*
	 * Check for mode fault error. We want to check for this error first,
	 * before checking for progress of a transfer, since this error needs
	 * to abort any operation in progress.
	 */
	if (IntrStatus & XSP_INTR_MODE_FAULT_MASK) {
c001b4c8:	fe042783          	lw	a5,-32(s0)
c001b4cc:	0017f793          	andi	a5,a5,1
c001b4d0:	08078c63          	beqz	a5,c001b568 <XSpi_InterruptHandler+0x13c>
c001b4d4:	0280006f          	j	c001b4fc <XSpi_InterruptHandler+0xd0>
	Xil_AssertVoid(InstancePtr != NULL);
c001b4d8:	45700593          	li	a1,1111
c001b4dc:	07fe6517          	auipc	a0,0x7fe6
c001b4e0:	46450513          	addi	a0,a0,1124 # c8001940 <__rodata_start+0x1940>
c001b4e4:	5d8020ef          	jal	ra,c001dabc <Xil_Assert>
c001b4e8:	07fe7797          	auipc	a5,0x7fe7
c001b4ec:	42c78793          	addi	a5,a5,1068 # c8002914 <Xil_AssertStatus>
c001b4f0:	00100713          	li	a4,1
c001b4f4:	00e7a023          	sw	a4,0(a5)
c001b4f8:	56c0006f          	j	c001ba64 <XSpi_InterruptHandler+0x638>
		BytesDone = SpiPtr->RequestedBytes - SpiPtr->RemainingBytes;
c001b4fc:	fe442783          	lw	a5,-28(s0)
c001b500:	0407a703          	lw	a4,64(a5)
c001b504:	fe442783          	lw	a5,-28(s0)
c001b508:	0447a783          	lw	a5,68(a5)
c001b50c:	40f707b3          	sub	a5,a4,a5
c001b510:	fcf42a23          	sw	a5,-44(s0)
		SpiPtr->Stats.ModeFaults++;
c001b514:	fe442783          	lw	a5,-28(s0)
c001b518:	0007a783          	lw	a5,0(a5)
c001b51c:	00178713          	addi	a4,a5,1
c001b520:	fe442783          	lw	a5,-28(s0)
c001b524:	00e7a023          	sw	a4,0(a5)
		 * Note that the status register should be read after the Abort
		 * since reading the status register clears the mode fault
		 * condition and would cause the device to restart any transfer
		 * that may be in progress.
		 */
		XSpi_Abort(SpiPtr);
c001b528:	fe442503          	lw	a0,-28(s0)
c001b52c:	54c000ef          	jal	ra,c001ba78 <XSpi_Abort>

		(void) XSpi_GetStatusReg(SpiPtr);
c001b530:	fe442783          	lw	a5,-28(s0)
c001b534:	0187a783          	lw	a5,24(a5)
c001b538:	06478793          	addi	a5,a5,100
c001b53c:	00078513          	mv	a0,a5
c001b540:	c79fe0ef          	jal	ra,c001a1b8 <Xil_In32>

		SpiPtr->StatusHandler(SpiPtr->StatusRef, XST_SPI_MODE_FAULT,
c001b544:	fe442783          	lw	a5,-28(s0)
c001b548:	04c7a703          	lw	a4,76(a5)
c001b54c:	fe442783          	lw	a5,-28(s0)
c001b550:	0507a783          	lw	a5,80(a5)
c001b554:	fd442603          	lw	a2,-44(s0)
c001b558:	47f00593          	li	a1,1151
c001b55c:	00078513          	mv	a0,a5
c001b560:	000700e7          	jalr	a4
					BytesDone);

		return;		/* Do not continue servicing other interrupts */
c001b564:	5000006f          	j	c001ba64 <XSpi_InterruptHandler+0x638>
	}

	DataWidth = SpiPtr->DataWidth;
c001b568:	fe442783          	lw	a5,-28(s0)
c001b56c:	02d7c783          	lbu	a5,45(a5)
c001b570:	fcf40fa3          	sb	a5,-33(s0)
	if ((IntrStatus & XSP_INTR_TX_EMPTY_MASK) ||
c001b574:	fe042783          	lw	a5,-32(s0)
c001b578:	0047f793          	andi	a5,a5,4
c001b57c:	00079863          	bnez	a5,c001b58c <XSpi_InterruptHandler+0x160>
	    (IntrStatus & XSP_INTR_TX_HALF_EMPTY_MASK)) {
c001b580:	fe042783          	lw	a5,-32(s0)
c001b584:	0407f793          	andi	a5,a5,64
	if ((IntrStatus & XSP_INTR_TX_EMPTY_MASK) ||
c001b588:	32078063          	beqz	a5,c001b8a8 <XSpi_InterruptHandler+0x47c>
		 * A transmit has just completed. Process received data and
		 * check for more data to transmit. Always inhibit the
		 * transmitter while the Isr re-fills the transmit
		 * register/FIFO, or make sure it is stopped if we're done.
		 */
		ControlReg = XSpi_GetControlReg(SpiPtr);
c001b58c:	fe442783          	lw	a5,-28(s0)
c001b590:	0187a783          	lw	a5,24(a5)
c001b594:	06078793          	addi	a5,a5,96
c001b598:	00078513          	mv	a0,a5
c001b59c:	c1dfe0ef          	jal	ra,c001a1b8 <Xil_In32>
c001b5a0:	fca42c23          	sw	a0,-40(s0)
		XSpi_SetControlReg(SpiPtr, ControlReg |
c001b5a4:	fe442783          	lw	a5,-28(s0)
c001b5a8:	0187a783          	lw	a5,24(a5)
c001b5ac:	06078713          	addi	a4,a5,96
c001b5b0:	fd842783          	lw	a5,-40(s0)
c001b5b4:	1007e793          	ori	a5,a5,256
c001b5b8:	00078593          	mv	a1,a5
c001b5bc:	00070513          	mv	a0,a4
c001b5c0:	c21fe0ef          	jal	ra,c001a1e0 <Xil_Out32>
		 * status register to determine when the receive register/FIFO
		 * is empty. Always get the received data, but only fill the
		 * receive buffer if it points to something (the upper layer
		 * software may not care to receive data).
		 */
		StatusReg = XSpi_GetStatusReg(SpiPtr);
c001b5c4:	fe442783          	lw	a5,-28(s0)
c001b5c8:	0187a783          	lw	a5,24(a5)
c001b5cc:	06478793          	addi	a5,a5,100
c001b5d0:	00078513          	mv	a0,a5
c001b5d4:	be5fe0ef          	jal	ra,c001a1b8 <Xil_In32>
c001b5d8:	fea42423          	sw	a0,-24(s0)

		while ((StatusReg & XSP_SR_RX_EMPTY_MASK) == 0) {
c001b5dc:	1140006f          	j	c001b6f0 <XSpi_InterruptHandler+0x2c4>

			Data = XSpi_ReadReg(SpiPtr->BaseAddr, XSP_DRR_OFFSET);
c001b5e0:	fe442783          	lw	a5,-28(s0)
c001b5e4:	0187a783          	lw	a5,24(a5)
c001b5e8:	06c78793          	addi	a5,a5,108
c001b5ec:	00078513          	mv	a0,a5
c001b5f0:	bc9fe0ef          	jal	ra,c001a1b8 <Xil_In32>
c001b5f4:	fea42623          	sw	a0,-20(s0)

			/*
			 * Data Transfer Width is Byte (8 bit).
			 */
			if (DataWidth == XSP_DATAWIDTH_BYTE) {
c001b5f8:	fdf44703          	lbu	a4,-33(s0)
c001b5fc:	00800793          	li	a5,8
c001b600:	02f71a63          	bne	a4,a5,c001b634 <XSpi_InterruptHandler+0x208>
				if (SpiPtr->RecvBufferPtr != NULL) {
c001b604:	fe442783          	lw	a5,-28(s0)
c001b608:	03c7a783          	lw	a5,60(a5)
c001b60c:	0a078663          	beqz	a5,c001b6b8 <XSpi_InterruptHandler+0x28c>
					*SpiPtr->RecvBufferPtr++ = (u8) Data;
c001b610:	fe442783          	lw	a5,-28(s0)
c001b614:	03c7a783          	lw	a5,60(a5)
c001b618:	00178693          	addi	a3,a5,1
c001b61c:	fe442703          	lw	a4,-28(s0)
c001b620:	02d72e23          	sw	a3,60(a4)
c001b624:	fec42703          	lw	a4,-20(s0)
c001b628:	0ff77713          	andi	a4,a4,255
c001b62c:	00e78023          	sb	a4,0(a5)
c001b630:	0880006f          	j	c001b6b8 <XSpi_InterruptHandler+0x28c>
				}
			} else if (DataWidth == XSP_DATAWIDTH_HALF_WORD) {
c001b634:	fdf44703          	lbu	a4,-33(s0)
c001b638:	01000793          	li	a5,16
c001b63c:	04f71063          	bne	a4,a5,c001b67c <XSpi_InterruptHandler+0x250>
				if (SpiPtr->RecvBufferPtr != NULL) {
c001b640:	fe442783          	lw	a5,-28(s0)
c001b644:	03c7a783          	lw	a5,60(a5)
c001b648:	06078863          	beqz	a5,c001b6b8 <XSpi_InterruptHandler+0x28c>
					*(u16 *) SpiPtr->RecvBufferPtr =
c001b64c:	fe442783          	lw	a5,-28(s0)
c001b650:	03c7a783          	lw	a5,60(a5)
							(u16) Data;
c001b654:	fec42703          	lw	a4,-20(s0)
c001b658:	01071713          	slli	a4,a4,0x10
c001b65c:	01075713          	srli	a4,a4,0x10
					*(u16 *) SpiPtr->RecvBufferPtr =
c001b660:	00e79023          	sh	a4,0(a5)
					SpiPtr->RecvBufferPtr +=2;
c001b664:	fe442783          	lw	a5,-28(s0)
c001b668:	03c7a783          	lw	a5,60(a5)
c001b66c:	00278713          	addi	a4,a5,2
c001b670:	fe442783          	lw	a5,-28(s0)
c001b674:	02e7ae23          	sw	a4,60(a5)
c001b678:	0400006f          	j	c001b6b8 <XSpi_InterruptHandler+0x28c>
				}
			} else if (DataWidth == XSP_DATAWIDTH_WORD) {
c001b67c:	fdf44703          	lbu	a4,-33(s0)
c001b680:	02000793          	li	a5,32
c001b684:	02f71a63          	bne	a4,a5,c001b6b8 <XSpi_InterruptHandler+0x28c>
				if (SpiPtr->RecvBufferPtr != NULL) {
c001b688:	fe442783          	lw	a5,-28(s0)
c001b68c:	03c7a783          	lw	a5,60(a5)
c001b690:	02078463          	beqz	a5,c001b6b8 <XSpi_InterruptHandler+0x28c>
					*(u32 *) SpiPtr->RecvBufferPtr =
c001b694:	fe442783          	lw	a5,-28(s0)
c001b698:	03c7a783          	lw	a5,60(a5)
c001b69c:	fec42703          	lw	a4,-20(s0)
c001b6a0:	00e7a023          	sw	a4,0(a5)
							Data;
					SpiPtr->RecvBufferPtr +=4;
c001b6a4:	fe442783          	lw	a5,-28(s0)
c001b6a8:	03c7a783          	lw	a5,60(a5)
c001b6ac:	00478713          	addi	a4,a5,4
c001b6b0:	fe442783          	lw	a5,-28(s0)
c001b6b4:	02e7ae23          	sw	a4,60(a5)
				}
			}

			SpiPtr->Stats.BytesTransferred += (DataWidth >> 3);
c001b6b8:	fe442783          	lw	a5,-28(s0)
c001b6bc:	0107a783          	lw	a5,16(a5)
c001b6c0:	fdf44703          	lbu	a4,-33(s0)
c001b6c4:	00375713          	srli	a4,a4,0x3
c001b6c8:	0ff77713          	andi	a4,a4,255
c001b6cc:	00e78733          	add	a4,a5,a4
c001b6d0:	fe442783          	lw	a5,-28(s0)
c001b6d4:	00e7a823          	sw	a4,16(a5)
			StatusReg = XSpi_GetStatusReg(SpiPtr);
c001b6d8:	fe442783          	lw	a5,-28(s0)
c001b6dc:	0187a783          	lw	a5,24(a5)
c001b6e0:	06478793          	addi	a5,a5,100
c001b6e4:	00078513          	mv	a0,a5
c001b6e8:	ad1fe0ef          	jal	ra,c001a1b8 <Xil_In32>
c001b6ec:	fea42423          	sw	a0,-24(s0)
		while ((StatusReg & XSP_SR_RX_EMPTY_MASK) == 0) {
c001b6f0:	fe842783          	lw	a5,-24(s0)
c001b6f4:	0017f793          	andi	a5,a5,1
c001b6f8:	ee0784e3          	beqz	a5,c001b5e0 <XSpi_InterruptHandler+0x1b4>
		}

		/*
		 * See if there is more data to send.
		 */
		if (SpiPtr->RemainingBytes > 0) {
c001b6fc:	fe442783          	lw	a5,-28(s0)
c001b700:	0447a783          	lw	a5,68(a5)
c001b704:	12078063          	beqz	a5,c001b824 <XSpi_InterruptHandler+0x3f8>
			 * By doing this, the driver does not need to know the
			 * size of the FIFO or that there even is a FIFO.
			 * The downside is that the status must be read each
			 * loop iteration.
			 */
			StatusReg = XSpi_GetStatusReg(SpiPtr);
c001b708:	fe442783          	lw	a5,-28(s0)
c001b70c:	0187a783          	lw	a5,24(a5)
c001b710:	06478793          	addi	a5,a5,100
c001b714:	00078513          	mv	a0,a5
c001b718:	aa1fe0ef          	jal	ra,c001a1b8 <Xil_In32>
c001b71c:	fea42423          	sw	a0,-24(s0)
			while (((StatusReg & XSP_SR_TX_FULL_MASK) == 0) &&
c001b720:	0d00006f          	j	c001b7f0 <XSpi_InterruptHandler+0x3c4>
				(SpiPtr->RemainingBytes > 0)) {
				if (DataWidth == XSP_DATAWIDTH_BYTE) {
c001b724:	fdf44703          	lbu	a4,-33(s0)
c001b728:	00800793          	li	a5,8
c001b72c:	00f71c63          	bne	a4,a5,c001b744 <XSpi_InterruptHandler+0x318>
					/*
					 * Data Transfer Width is Byte (8 bit).
					 */
					Data = *SpiPtr->SendBufferPtr;
c001b730:	fe442783          	lw	a5,-28(s0)
c001b734:	0387a783          	lw	a5,56(a5)
c001b738:	0007c783          	lbu	a5,0(a5)
c001b73c:	fef42623          	sw	a5,-20(s0)
c001b740:	0400006f          	j	c001b780 <XSpi_InterruptHandler+0x354>

				} else if (DataWidth ==
c001b744:	fdf44703          	lbu	a4,-33(s0)
c001b748:	01000793          	li	a5,16
c001b74c:	00f71c63          	bne	a4,a5,c001b764 <XSpi_InterruptHandler+0x338>
						XSP_DATAWIDTH_HALF_WORD) {
					/*
					 * Data Transfer Width is Half Word
					 * (16 bit).
					 */
					Data = *(u16 *) SpiPtr->SendBufferPtr;
c001b750:	fe442783          	lw	a5,-28(s0)
c001b754:	0387a783          	lw	a5,56(a5)
c001b758:	0007d783          	lhu	a5,0(a5)
c001b75c:	fef42623          	sw	a5,-20(s0)
c001b760:	0200006f          	j	c001b780 <XSpi_InterruptHandler+0x354>
				} else if (DataWidth ==
c001b764:	fdf44703          	lbu	a4,-33(s0)
c001b768:	02000793          	li	a5,32
c001b76c:	00f71a63          	bne	a4,a5,c001b780 <XSpi_InterruptHandler+0x354>
						XSP_DATAWIDTH_WORD) {
					/*
					 * Data Transfer Width is Word (32 bit).
					 */
					Data = *(u32 *) SpiPtr->SendBufferPtr;
c001b770:	fe442783          	lw	a5,-28(s0)
c001b774:	0387a783          	lw	a5,56(a5)
c001b778:	0007a783          	lw	a5,0(a5)
c001b77c:	fef42623          	sw	a5,-20(s0)
				}

				XSpi_WriteReg(SpiPtr->BaseAddr, XSP_DTR_OFFSET,
c001b780:	fe442783          	lw	a5,-28(s0)
c001b784:	0187a783          	lw	a5,24(a5)
c001b788:	06878793          	addi	a5,a5,104
c001b78c:	fec42583          	lw	a1,-20(s0)
c001b790:	00078513          	mv	a0,a5
c001b794:	a4dfe0ef          	jal	ra,c001a1e0 <Xil_Out32>
						Data);
				SpiPtr->SendBufferPtr += (DataWidth >> 3);
c001b798:	fe442783          	lw	a5,-28(s0)
c001b79c:	0387a783          	lw	a5,56(a5)
c001b7a0:	fdf44703          	lbu	a4,-33(s0)
c001b7a4:	00375713          	srli	a4,a4,0x3
c001b7a8:	0ff77713          	andi	a4,a4,255
c001b7ac:	00e78733          	add	a4,a5,a4
c001b7b0:	fe442783          	lw	a5,-28(s0)
c001b7b4:	02e7ac23          	sw	a4,56(a5)
				SpiPtr->RemainingBytes -= (DataWidth >> 3);
c001b7b8:	fe442783          	lw	a5,-28(s0)
c001b7bc:	0447a783          	lw	a5,68(a5)
c001b7c0:	fdf44703          	lbu	a4,-33(s0)
c001b7c4:	00375713          	srli	a4,a4,0x3
c001b7c8:	0ff77713          	andi	a4,a4,255
c001b7cc:	40e78733          	sub	a4,a5,a4
c001b7d0:	fe442783          	lw	a5,-28(s0)
c001b7d4:	04e7a223          	sw	a4,68(a5)
				StatusReg = XSpi_GetStatusReg(SpiPtr);
c001b7d8:	fe442783          	lw	a5,-28(s0)
c001b7dc:	0187a783          	lw	a5,24(a5)
c001b7e0:	06478793          	addi	a5,a5,100
c001b7e4:	00078513          	mv	a0,a5
c001b7e8:	9d1fe0ef          	jal	ra,c001a1b8 <Xil_In32>
c001b7ec:	fea42423          	sw	a0,-24(s0)
			while (((StatusReg & XSP_SR_TX_FULL_MASK) == 0) &&
c001b7f0:	fe842783          	lw	a5,-24(s0)
c001b7f4:	0087f793          	andi	a5,a5,8
c001b7f8:	00079863          	bnez	a5,c001b808 <XSpi_InterruptHandler+0x3dc>
				(SpiPtr->RemainingBytes > 0)) {
c001b7fc:	fe442783          	lw	a5,-28(s0)
c001b800:	0447a783          	lw	a5,68(a5)
			while (((StatusReg & XSP_SR_TX_FULL_MASK) == 0) &&
c001b804:	f20790e3          	bnez	a5,c001b724 <XSpi_InterruptHandler+0x2f8>

			/*
			 * Start the transfer by not inhibiting the transmitter
			 * any longer.
			 */
			XSpi_SetControlReg(SpiPtr, ControlReg);
c001b808:	fe442783          	lw	a5,-28(s0)
c001b80c:	0187a783          	lw	a5,24(a5)
c001b810:	06078793          	addi	a5,a5,96
c001b814:	fd842583          	lw	a1,-40(s0)
c001b818:	00078513          	mv	a0,a5
c001b81c:	9c5fe0ef          	jal	ra,c001a1e0 <Xil_Out32>
c001b820:	0880006f          	j	c001b8a8 <XSpi_InterruptHandler+0x47c>
			 * Select the slave on the SPI bus when the transfer is
			 * complete, this is necessary for some SPI devices,
			 * such as serial EEPROMs work correctly as chip enable
			 * may be connected to slave select.
			 */
			XSpi_SetSlaveSelectReg(SpiPtr,
c001b824:	fe442783          	lw	a5,-28(s0)
c001b828:	0187a783          	lw	a5,24(a5)
c001b82c:	07078713          	addi	a4,a5,112
c001b830:	fe442783          	lw	a5,-28(s0)
c001b834:	0307a783          	lw	a5,48(a5)
c001b838:	00078593          	mv	a1,a5
c001b83c:	00070513          	mv	a0,a4
c001b840:	9a1fe0ef          	jal	ra,c001a1e0 <Xil_Out32>
			 * No more data to send.  Disable the interrupt and
			 * inform the upper layer software that the transfer is
			 * done. The interrupt will be re-enabled when another
			 * transfer is initiated.
			 */
			XSpi_IntrDisable(SpiPtr, XSP_INTR_TX_EMPTY_MASK);
c001b844:	fe442783          	lw	a5,-28(s0)
c001b848:	0187a783          	lw	a5,24(a5)
c001b84c:	02878493          	addi	s1,a5,40
c001b850:	fe442783          	lw	a5,-28(s0)
c001b854:	0187a783          	lw	a5,24(a5)
c001b858:	02878793          	addi	a5,a5,40
c001b85c:	00078513          	mv	a0,a5
c001b860:	959fe0ef          	jal	ra,c001a1b8 <Xil_In32>
c001b864:	00050793          	mv	a5,a0
c001b868:	ffb7f793          	andi	a5,a5,-5
c001b86c:	00078593          	mv	a1,a5
c001b870:	00048513          	mv	a0,s1
c001b874:	96dfe0ef          	jal	ra,c001a1e0 <Xil_Out32>

			SpiPtr->IsBusy = FALSE;
c001b878:	fe442783          	lw	a5,-28(s0)
c001b87c:	0407a423          	sw	zero,72(a5)

			SpiPtr->StatusHandler(SpiPtr->StatusRef,
c001b880:	fe442783          	lw	a5,-28(s0)
c001b884:	04c7a683          	lw	a3,76(a5)
c001b888:	fe442783          	lw	a5,-28(s0)
c001b88c:	0507a703          	lw	a4,80(a5)
c001b890:	fe442783          	lw	a5,-28(s0)
c001b894:	0407a783          	lw	a5,64(a5)
c001b898:	00078613          	mv	a2,a5
c001b89c:	48000593          	li	a1,1152
c001b8a0:	00070513          	mv	a0,a4
c001b8a4:	000680e7          	jalr	a3

	/*
	 * Check if the device has been addressed as a slave. Report the status
	 * to the application layer.
	 */
	if (IntrStatus & XSP_INTR_SLAVE_MODE_MASK) {
c001b8a8:	fe042783          	lw	a5,-32(s0)
c001b8ac:	0807f793          	andi	a5,a5,128
c001b8b0:	02078263          	beqz	a5,c001b8d4 <XSpi_InterruptHandler+0x4a8>
		SpiPtr->StatusHandler(SpiPtr->StatusRef,
c001b8b4:	fe442783          	lw	a5,-28(s0)
c001b8b8:	04c7a703          	lw	a4,76(a5)
c001b8bc:	fe442783          	lw	a5,-28(s0)
c001b8c0:	0507a783          	lw	a5,80(a5)
c001b8c4:	00000613          	li	a2,0
c001b8c8:	48800593          	li	a1,1160
c001b8cc:	00078513          	mv	a0,a5
c001b8d0:	000700e7          	jalr	a4

	/*
	 * Check if the device has received data from the master. Report the
	 * status to the application layer.
	 */
	if (IntrStatus & XSP_INTR_RX_NOT_EMPTY_MASK) {
c001b8d4:	fe042783          	lw	a5,-32(s0)
c001b8d8:	1007f793          	andi	a5,a5,256
c001b8dc:	02078263          	beqz	a5,c001b900 <XSpi_InterruptHandler+0x4d4>
		SpiPtr->StatusHandler(SpiPtr->StatusRef,
c001b8e0:	fe442783          	lw	a5,-28(s0)
c001b8e4:	04c7a703          	lw	a4,76(a5)
c001b8e8:	fe442783          	lw	a5,-28(s0)
c001b8ec:	0507a783          	lw	a5,80(a5)
c001b8f0:	00000613          	li	a2,0
c001b8f4:	48900593          	li	a1,1161
c001b8f8:	00078513          	mv	a0,a5
c001b8fc:	000700e7          	jalr	a4

	/*
	 * Check for slave mode fault. Simply report the error and update the
	 * statistics.
	 */
	if (IntrStatus & XSP_INTR_SLAVE_MODE_FAULT_MASK) {
c001b900:	fe042783          	lw	a5,-32(s0)
c001b904:	0027f793          	andi	a5,a5,2
c001b908:	04078863          	beqz	a5,c001b958 <XSpi_InterruptHandler+0x52c>
		BytesDone = SpiPtr->RequestedBytes - SpiPtr->RemainingBytes;
c001b90c:	fe442783          	lw	a5,-28(s0)
c001b910:	0407a703          	lw	a4,64(a5)
c001b914:	fe442783          	lw	a5,-28(s0)
c001b918:	0447a783          	lw	a5,68(a5)
c001b91c:	40f707b3          	sub	a5,a4,a5
c001b920:	fcf42a23          	sw	a5,-44(s0)
		SpiPtr->Stats.SlaveModeFaults++;
c001b924:	fe442783          	lw	a5,-28(s0)
c001b928:	00c7a783          	lw	a5,12(a5)
c001b92c:	00178713          	addi	a4,a5,1
c001b930:	fe442783          	lw	a5,-28(s0)
c001b934:	00e7a623          	sw	a4,12(a5)
		SpiPtr->StatusHandler(SpiPtr->StatusRef,
c001b938:	fe442783          	lw	a5,-28(s0)
c001b93c:	04c7a703          	lw	a4,76(a5)
c001b940:	fe442783          	lw	a5,-28(s0)
c001b944:	0507a783          	lw	a5,80(a5)
c001b948:	fd442603          	lw	a2,-44(s0)
c001b94c:	48700593          	li	a1,1159
c001b950:	00078513          	mv	a0,a5
c001b954:	000700e7          	jalr	a4

	/*
	 * Check for overrun error. Simply report the error and update the
	 * statistics.
	 */
	if (IntrStatus & XSP_INTR_RX_OVERRUN_MASK) {
c001b958:	fe042783          	lw	a5,-32(s0)
c001b95c:	0207f793          	andi	a5,a5,32
c001b960:	04078863          	beqz	a5,c001b9b0 <XSpi_InterruptHandler+0x584>
		BytesDone = SpiPtr->RequestedBytes - SpiPtr->RemainingBytes;
c001b964:	fe442783          	lw	a5,-28(s0)
c001b968:	0407a703          	lw	a4,64(a5)
c001b96c:	fe442783          	lw	a5,-28(s0)
c001b970:	0447a783          	lw	a5,68(a5)
c001b974:	40f707b3          	sub	a5,a4,a5
c001b978:	fcf42a23          	sw	a5,-44(s0)
		SpiPtr->Stats.RecvOverruns++;
c001b97c:	fe442783          	lw	a5,-28(s0)
c001b980:	0087a783          	lw	a5,8(a5)
c001b984:	00178713          	addi	a4,a5,1
c001b988:	fe442783          	lw	a5,-28(s0)
c001b98c:	00e7a423          	sw	a4,8(a5)
		SpiPtr->StatusHandler(SpiPtr->StatusRef,
c001b990:	fe442783          	lw	a5,-28(s0)
c001b994:	04c7a703          	lw	a4,76(a5)
c001b998:	fe442783          	lw	a5,-28(s0)
c001b99c:	0507a783          	lw	a5,80(a5)
c001b9a0:	fd442603          	lw	a2,-44(s0)
c001b9a4:	48200593          	li	a1,1154
c001b9a8:	00078513          	mv	a0,a5
c001b9ac:	000700e7          	jalr	a4

	/*
	 * Check for underrun error. Simply report the error and update the
	 * statistics.
	 */
	if (IntrStatus & XSP_INTR_TX_UNDERRUN_MASK) {
c001b9b0:	fe042783          	lw	a5,-32(s0)
c001b9b4:	0087f793          	andi	a5,a5,8
c001b9b8:	04078863          	beqz	a5,c001ba08 <XSpi_InterruptHandler+0x5dc>
		BytesDone = SpiPtr->RequestedBytes - SpiPtr->RemainingBytes;
c001b9bc:	fe442783          	lw	a5,-28(s0)
c001b9c0:	0407a703          	lw	a4,64(a5)
c001b9c4:	fe442783          	lw	a5,-28(s0)
c001b9c8:	0447a783          	lw	a5,68(a5)
c001b9cc:	40f707b3          	sub	a5,a4,a5
c001b9d0:	fcf42a23          	sw	a5,-44(s0)
		SpiPtr->Stats.XmitUnderruns++;
c001b9d4:	fe442783          	lw	a5,-28(s0)
c001b9d8:	0047a783          	lw	a5,4(a5)
c001b9dc:	00178713          	addi	a4,a5,1
c001b9e0:	fe442783          	lw	a5,-28(s0)
c001b9e4:	00e7a223          	sw	a4,4(a5)
		SpiPtr->StatusHandler(SpiPtr->StatusRef,
c001b9e8:	fe442783          	lw	a5,-28(s0)
c001b9ec:	04c7a703          	lw	a4,76(a5)
c001b9f0:	fe442783          	lw	a5,-28(s0)
c001b9f4:	0507a783          	lw	a5,80(a5)
c001b9f8:	fd442603          	lw	a2,-44(s0)
c001b9fc:	48100593          	li	a1,1153
c001ba00:	00078513          	mv	a0,a5
c001ba04:	000700e7          	jalr	a4

	/*
	 * Check for command error. Simply report the error and update the
	 * statistics.
	 */
	if (IntrStatus & XSP_INTR_CMD_ERR_MASK) {
c001ba08:	fe042703          	lw	a4,-32(s0)
c001ba0c:	000027b7          	lui	a5,0x2
c001ba10:	00f777b3          	and	a5,a4,a5
c001ba14:	04078863          	beqz	a5,c001ba64 <XSpi_InterruptHandler+0x638>
		BytesDone = SpiPtr->RequestedBytes - SpiPtr->RemainingBytes;
c001ba18:	fe442783          	lw	a5,-28(s0)
c001ba1c:	0407a703          	lw	a4,64(a5) # 2040 <_STACK_SIZE+0x1040>
c001ba20:	fe442783          	lw	a5,-28(s0)
c001ba24:	0447a783          	lw	a5,68(a5)
c001ba28:	40f707b3          	sub	a5,a4,a5
c001ba2c:	fcf42a23          	sw	a5,-44(s0)
		SpiPtr->Stats.XmitUnderruns++;
c001ba30:	fe442783          	lw	a5,-28(s0)
c001ba34:	0047a783          	lw	a5,4(a5)
c001ba38:	00178713          	addi	a4,a5,1
c001ba3c:	fe442783          	lw	a5,-28(s0)
c001ba40:	00e7a223          	sw	a4,4(a5)
		SpiPtr->StatusHandler(SpiPtr->StatusRef,
c001ba44:	fe442783          	lw	a5,-28(s0)
c001ba48:	04c7a703          	lw	a4,76(a5)
c001ba4c:	fe442783          	lw	a5,-28(s0)
c001ba50:	0507a783          	lw	a5,80(a5)
c001ba54:	fd442603          	lw	a2,-44(s0)
c001ba58:	48a00593          	li	a1,1162
c001ba5c:	00078513          	mv	a0,a5
c001ba60:	000700e7          	jalr	a4
				XST_SPI_COMMAND_ERROR, BytesDone);
	}
}
c001ba64:	03c12083          	lw	ra,60(sp)
c001ba68:	03812403          	lw	s0,56(sp)
c001ba6c:	03412483          	lw	s1,52(sp)
c001ba70:	04010113          	addi	sp,sp,64
c001ba74:	00008067          	ret

c001ba78 <XSpi_Abort>:
* This function does a read/modify/write of the control register. The user of
* this function needs to take care of critical sections.
*
******************************************************************************/
void XSpi_Abort(XSpi *InstancePtr)
{
c001ba78:	fd010113          	addi	sp,sp,-48
c001ba7c:	02112623          	sw	ra,44(sp)
c001ba80:	02812423          	sw	s0,40(sp)
c001ba84:	03010413          	addi	s0,sp,48
c001ba88:	fca42e23          	sw	a0,-36(s0)
	/*
	 * Deselect the slave on the SPI bus to abort a transfer, this must be
	 * done before the device is disabled such that the signals which are
	 * driven by the device are changed without the device enabled.
	 */
	XSpi_SetSlaveSelectReg(InstancePtr,
c001ba8c:	fdc42783          	lw	a5,-36(s0)
c001ba90:	0187a783          	lw	a5,24(a5)
c001ba94:	07078713          	addi	a4,a5,112
c001ba98:	fdc42783          	lw	a5,-36(s0)
c001ba9c:	0307a783          	lw	a5,48(a5)
c001baa0:	00078593          	mv	a1,a5
c001baa4:	00070513          	mv	a0,a4
c001baa8:	f38fe0ef          	jal	ra,c001a1e0 <Xil_Out32>
	/*
	 * Abort the operation currently in progress. Clear the mode
	 * fault condition by reading the status register (done) then
	 * writing the control register.
	 */
	ControlReg = XSpi_GetControlReg(InstancePtr);
c001baac:	fdc42783          	lw	a5,-36(s0)
c001bab0:	0187a783          	lw	a5,24(a5)
c001bab4:	06078793          	addi	a5,a5,96
c001bab8:	00078513          	mv	a0,a5
c001babc:	efcfe0ef          	jal	ra,c001a1b8 <Xil_In32>
c001bac0:	00050793          	mv	a5,a0
c001bac4:	fef41723          	sh	a5,-18(s0)

	/*
	 * Stop any transmit in progress and reset the FIFOs if they exist,
	 * don't disable the device just inhibit any data from being sent.
	 */
	ControlReg |= XSP_CR_TRANS_INHIBIT_MASK;
c001bac8:	fee45783          	lhu	a5,-18(s0)
c001bacc:	1007e793          	ori	a5,a5,256
c001bad0:	fef41723          	sh	a5,-18(s0)

	if (InstancePtr->HasFifos) {
c001bad4:	fdc42783          	lw	a5,-36(s0)
c001bad8:	0247a783          	lw	a5,36(a5)
c001badc:	00078863          	beqz	a5,c001baec <XSpi_Abort+0x74>
		ControlReg |= (XSP_CR_TXFIFO_RESET_MASK |
c001bae0:	fee45783          	lhu	a5,-18(s0)
c001bae4:	0607e793          	ori	a5,a5,96
c001bae8:	fef41723          	sh	a5,-18(s0)
				XSP_CR_RXFIFO_RESET_MASK);
	}

	XSpi_SetControlReg(InstancePtr, ControlReg);
c001baec:	fdc42783          	lw	a5,-36(s0)
c001baf0:	0187a783          	lw	a5,24(a5)
c001baf4:	06078793          	addi	a5,a5,96
c001baf8:	fee45703          	lhu	a4,-18(s0)
c001bafc:	00070593          	mv	a1,a4
c001bb00:	00078513          	mv	a0,a5
c001bb04:	edcfe0ef          	jal	ra,c001a1e0 <Xil_Out32>

	InstancePtr->RemainingBytes = 0;
c001bb08:	fdc42783          	lw	a5,-36(s0)
c001bb0c:	0407a223          	sw	zero,68(a5)
	InstancePtr->RequestedBytes = 0;
c001bb10:	fdc42783          	lw	a5,-36(s0)
c001bb14:	0407a023          	sw	zero,64(a5)
	InstancePtr->IsBusy = FALSE;
c001bb18:	fdc42783          	lw	a5,-36(s0)
c001bb1c:	0407a423          	sw	zero,72(a5)
}
c001bb20:	00000013          	nop
c001bb24:	02c12083          	lw	ra,44(sp)
c001bb28:	02812403          	lw	s0,40(sp)
c001bb2c:	03010113          	addi	sp,sp,48
c001bb30:	00008067          	ret

c001bb34 <XSpi_LookupConfig>:
*
* @note		None.
*
******************************************************************************/
XSpi_Config *XSpi_LookupConfig(u16 DeviceId)
{
c001bb34:	fd010113          	addi	sp,sp,-48
c001bb38:	02812623          	sw	s0,44(sp)
c001bb3c:	03010413          	addi	s0,sp,48
c001bb40:	00050793          	mv	a5,a0
c001bb44:	fcf41f23          	sh	a5,-34(s0)
	XSpi_Config *CfgPtr = NULL;
c001bb48:	fe042623          	sw	zero,-20(s0)
	u32 Index;

	for (Index = 0; Index < XPAR_XSPI_NUM_INSTANCES; Index++) {
c001bb4c:	fe042423          	sw	zero,-24(s0)
c001bb50:	0640006f          	j	c001bbb4 <XSpi_LookupConfig+0x80>
		if (XSpi_ConfigTable[Index].DeviceId == DeviceId) {
c001bb54:	07fe7697          	auipc	a3,0x7fe7
c001bb58:	fa468693          	addi	a3,a3,-92 # c8002af8 <XSpi_ConfigTable>
c001bb5c:	fe842703          	lw	a4,-24(s0)
c001bb60:	00070793          	mv	a5,a4
c001bb64:	00379793          	slli	a5,a5,0x3
c001bb68:	40e787b3          	sub	a5,a5,a4
c001bb6c:	00279793          	slli	a5,a5,0x2
c001bb70:	00f687b3          	add	a5,a3,a5
c001bb74:	0007d783          	lhu	a5,0(a5)
c001bb78:	fde45703          	lhu	a4,-34(s0)
c001bb7c:	02f71663          	bne	a4,a5,c001bba8 <XSpi_LookupConfig+0x74>
			CfgPtr = &XSpi_ConfigTable[Index];
c001bb80:	fe842703          	lw	a4,-24(s0)
c001bb84:	00070793          	mv	a5,a4
c001bb88:	00379793          	slli	a5,a5,0x3
c001bb8c:	40e787b3          	sub	a5,a5,a4
c001bb90:	00279793          	slli	a5,a5,0x2
c001bb94:	07fe7717          	auipc	a4,0x7fe7
c001bb98:	f6470713          	addi	a4,a4,-156 # c8002af8 <XSpi_ConfigTable>
c001bb9c:	00e787b3          	add	a5,a5,a4
c001bba0:	fef42623          	sw	a5,-20(s0)
			break;
c001bba4:	01c0006f          	j	c001bbc0 <XSpi_LookupConfig+0x8c>
	for (Index = 0; Index < XPAR_XSPI_NUM_INSTANCES; Index++) {
c001bba8:	fe842783          	lw	a5,-24(s0)
c001bbac:	00178793          	addi	a5,a5,1
c001bbb0:	fef42423          	sw	a5,-24(s0)
c001bbb4:	fe842703          	lw	a4,-24(s0)
c001bbb8:	00100793          	li	a5,1
c001bbbc:	f8e7fce3          	bgeu	a5,a4,c001bb54 <XSpi_LookupConfig+0x20>
		}
	}

	return CfgPtr;
c001bbc0:	fec42783          	lw	a5,-20(s0)
}
c001bbc4:	00078513          	mv	a0,a5
c001bbc8:	02c12403          	lw	s0,44(sp)
c001bbcc:	03010113          	addi	sp,sp,48
c001bbd0:	00008067          	ret

c001bbd4 <XSpi_Initialize>:
*
* @note		None.
*
******************************************************************************/
int XSpi_Initialize(XSpi *InstancePtr, u16 DeviceId)
{
c001bbd4:	fd010113          	addi	sp,sp,-48
c001bbd8:	02112623          	sw	ra,44(sp)
c001bbdc:	02812423          	sw	s0,40(sp)
c001bbe0:	03010413          	addi	s0,sp,48
c001bbe4:	fca42e23          	sw	a0,-36(s0)
c001bbe8:	00058793          	mv	a5,a1
c001bbec:	fcf41d23          	sh	a5,-38(s0)
	XSpi_Config *ConfigPtr;	/* Pointer to Configuration ROM data */

	Xil_AssertNonvoid(InstancePtr != NULL);
c001bbf0:	fdc42783          	lw	a5,-36(s0)
c001bbf4:	02078663          	beqz	a5,c001bc20 <XSpi_Initialize+0x4c>
c001bbf8:	07fe7797          	auipc	a5,0x7fe7
c001bbfc:	d1c78793          	addi	a5,a5,-740 # c8002914 <Xil_AssertStatus>
c001bc00:	0007a023          	sw	zero,0(a5)

	/*
	 * Lookup the device configuration in the temporary CROM table. Use this
	 * configuration info down below when initializing this component.
	 */
	ConfigPtr = XSpi_LookupConfig(DeviceId);
c001bc04:	fda45783          	lhu	a5,-38(s0)
c001bc08:	00078513          	mv	a0,a5
c001bc0c:	f29ff0ef          	jal	ra,c001bb34 <XSpi_LookupConfig>
c001bc10:	fea42623          	sw	a0,-20(s0)
	if (ConfigPtr == NULL) {
c001bc14:	fec42783          	lw	a5,-20(s0)
c001bc18:	02079c63          	bnez	a5,c001bc50 <XSpi_Initialize+0x7c>
c001bc1c:	02c0006f          	j	c001bc48 <XSpi_Initialize+0x74>
	Xil_AssertNonvoid(InstancePtr != NULL);
c001bc20:	08700593          	li	a1,135
c001bc24:	07fe6517          	auipc	a0,0x7fe6
c001bc28:	d3450513          	addi	a0,a0,-716 # c8001958 <__rodata_start+0x1958>
c001bc2c:	691010ef          	jal	ra,c001dabc <Xil_Assert>
c001bc30:	07fe7797          	auipc	a5,0x7fe7
c001bc34:	ce478793          	addi	a5,a5,-796 # c8002914 <Xil_AssertStatus>
c001bc38:	00100713          	li	a4,1
c001bc3c:	00e7a023          	sw	a4,0(a5)
c001bc40:	00000793          	li	a5,0
c001bc44:	0280006f          	j	c001bc6c <XSpi_Initialize+0x98>
		return XST_DEVICE_NOT_FOUND;
c001bc48:	00200793          	li	a5,2
c001bc4c:	0200006f          	j	c001bc6c <XSpi_Initialize+0x98>
	}

	return XSpi_CfgInitialize(InstancePtr, ConfigPtr,
c001bc50:	fec42783          	lw	a5,-20(s0)
c001bc54:	0047a783          	lw	a5,4(a5)
c001bc58:	00078613          	mv	a2,a5
c001bc5c:	fec42583          	lw	a1,-20(s0)
c001bc60:	fdc42503          	lw	a0,-36(s0)
c001bc64:	db4fe0ef          	jal	ra,c001a218 <XSpi_CfgInitialize>
c001bc68:	00050793          	mv	a5,a0
				  ConfigPtr->BaseAddress);

}
c001bc6c:	00078513          	mv	a0,a5
c001bc70:	02c12083          	lw	ra,44(sp)
c001bc74:	02812403          	lw	s0,40(sp)
c001bc78:	03010113          	addi	sp,sp,48
c001bc7c:	00008067          	ret

c001bc80 <Xil_In32>:
{
c001bc80:	fe010113          	addi	sp,sp,-32
c001bc84:	00812e23          	sw	s0,28(sp)
c001bc88:	02010413          	addi	s0,sp,32
c001bc8c:	fea42623          	sw	a0,-20(s0)
	return *(volatile u32 *) Addr;
c001bc90:	fec42783          	lw	a5,-20(s0)
c001bc94:	0007a783          	lw	a5,0(a5)
}
c001bc98:	00078513          	mv	a0,a5
c001bc9c:	01c12403          	lw	s0,28(sp)
c001bca0:	02010113          	addi	sp,sp,32
c001bca4:	00008067          	ret

c001bca8 <Xil_Out32>:
{
c001bca8:	fd010113          	addi	sp,sp,-48
c001bcac:	02812623          	sw	s0,44(sp)
c001bcb0:	03010413          	addi	s0,sp,48
c001bcb4:	fca42e23          	sw	a0,-36(s0)
c001bcb8:	fcb42c23          	sw	a1,-40(s0)
	volatile u32 *LocalAddr = (volatile u32 *)Addr;
c001bcbc:	fdc42783          	lw	a5,-36(s0)
c001bcc0:	fef42623          	sw	a5,-20(s0)
	*LocalAddr = Value;
c001bcc4:	fec42783          	lw	a5,-20(s0)
c001bcc8:	fd842703          	lw	a4,-40(s0)
c001bccc:	00e7a023          	sw	a4,0(a5)
}
c001bcd0:	00000013          	nop
c001bcd4:	02c12403          	lw	s0,44(sp)
c001bcd8:	03010113          	addi	sp,sp,48
c001bcdc:	00008067          	ret

c001bce0 <XSpi_SelfTest>:
*
* @note		None.
*
******************************************************************************/
int XSpi_SelfTest(XSpi *InstancePtr)
{
c001bce0:	fd010113          	addi	sp,sp,-48
c001bce4:	02112623          	sw	ra,44(sp)
c001bce8:	02812423          	sw	s0,40(sp)
c001bcec:	03010413          	addi	s0,sp,48
c001bcf0:	fca42e23          	sw	a0,-36(s0)
	int Result;
	u32 Register;

	Xil_AssertNonvoid(InstancePtr != NULL);
c001bcf4:	fdc42783          	lw	a5,-36(s0)
c001bcf8:	02078463          	beqz	a5,c001bd20 <XSpi_SelfTest+0x40>
c001bcfc:	07fe7797          	auipc	a5,0x7fe7
c001bd00:	c1878793          	addi	a5,a5,-1000 # c8002914 <Xil_AssertStatus>
c001bd04:	0007a023          	sw	zero,0(a5)
	Xil_AssertNonvoid(InstancePtr->IsReady == XIL_COMPONENT_IS_READY);
c001bd08:	fdc42783          	lw	a5,-36(s0)
c001bd0c:	01c7a703          	lw	a4,28(a5)
c001bd10:	111117b7          	lui	a5,0x11111
c001bd14:	11178793          	addi	a5,a5,273 # 11111111 <_DMEM_LENGTH+0x10911111>
c001bd18:	04f71863          	bne	a4,a5,c001bd68 <XSpi_SelfTest+0x88>
c001bd1c:	02c0006f          	j	c001bd48 <XSpi_SelfTest+0x68>
	Xil_AssertNonvoid(InstancePtr != NULL);
c001bd20:	07100593          	li	a1,113
c001bd24:	07fe6517          	auipc	a0,0x7fe6
c001bd28:	c5050513          	addi	a0,a0,-944 # c8001974 <__rodata_start+0x1974>
c001bd2c:	591010ef          	jal	ra,c001dabc <Xil_Assert>
c001bd30:	07fe7797          	auipc	a5,0x7fe7
c001bd34:	be478793          	addi	a5,a5,-1052 # c8002914 <Xil_AssertStatus>
c001bd38:	00100713          	li	a4,1
c001bd3c:	00e7a023          	sw	a4,0(a5)
c001bd40:	00000793          	li	a5,0
c001bd44:	1e80006f          	j	c001bf2c <XSpi_SelfTest+0x24c>
	Xil_AssertNonvoid(InstancePtr->IsReady == XIL_COMPONENT_IS_READY);
c001bd48:	07fe7797          	auipc	a5,0x7fe7
c001bd4c:	bcc78793          	addi	a5,a5,-1076 # c8002914 <Xil_AssertStatus>
c001bd50:	0007a023          	sw	zero,0(a5)


	/* Return Success if XIP Mode */
	if((InstancePtr->XipMode) == 1) {
c001bd54:	fdc42783          	lw	a5,-36(s0)
c001bd58:	0587c703          	lbu	a4,88(a5)
c001bd5c:	00100793          	li	a5,1
c001bd60:	02f71c63          	bne	a4,a5,c001bd98 <XSpi_SelfTest+0xb8>
c001bd64:	02c0006f          	j	c001bd90 <XSpi_SelfTest+0xb0>
	Xil_AssertNonvoid(InstancePtr->IsReady == XIL_COMPONENT_IS_READY);
c001bd68:	07200593          	li	a1,114
c001bd6c:	07fe6517          	auipc	a0,0x7fe6
c001bd70:	c0850513          	addi	a0,a0,-1016 # c8001974 <__rodata_start+0x1974>
c001bd74:	549010ef          	jal	ra,c001dabc <Xil_Assert>
c001bd78:	07fe7797          	auipc	a5,0x7fe7
c001bd7c:	b9c78793          	addi	a5,a5,-1124 # c8002914 <Xil_AssertStatus>
c001bd80:	00100713          	li	a4,1
c001bd84:	00e7a023          	sw	a4,0(a5)
c001bd88:	00000793          	li	a5,0
c001bd8c:	1a00006f          	j	c001bf2c <XSpi_SelfTest+0x24c>
		return XST_SUCCESS;
c001bd90:	00000793          	li	a5,0
c001bd94:	1980006f          	j	c001bf2c <XSpi_SelfTest+0x24c>
	}

	/*
	 * Reset the SPI device to leave it in a known good state.
	 */
	XSpi_Reset(InstancePtr);
c001bd98:	fdc42503          	lw	a0,-36(s0)
c001bd9c:	a99fe0ef          	jal	ra,c001a834 <XSpi_Reset>

	if(InstancePtr->XipMode)
c001bda0:	fdc42783          	lw	a5,-36(s0)
c001bda4:	0587c783          	lbu	a5,88(a5)
c001bda8:	06078063          	beqz	a5,c001be08 <XSpi_SelfTest+0x128>
	{
		Register = XSpi_GetControlReg(InstancePtr);
c001bdac:	fdc42783          	lw	a5,-36(s0)
c001bdb0:	0187a783          	lw	a5,24(a5)
c001bdb4:	06078793          	addi	a5,a5,96
c001bdb8:	00078513          	mv	a0,a5
c001bdbc:	ec5ff0ef          	jal	ra,c001bc80 <Xil_In32>
c001bdc0:	fea42623          	sw	a0,-20(s0)
		if (Register != XSP_CR_RESET_STATE) {
c001bdc4:	fec42703          	lw	a4,-20(s0)
c001bdc8:	18000793          	li	a5,384
c001bdcc:	00f70663          	beq	a4,a5,c001bdd8 <XSpi_SelfTest+0xf8>
			return XST_REGISTER_ERROR;
c001bdd0:	00e00793          	li	a5,14
c001bdd4:	1580006f          	j	c001bf2c <XSpi_SelfTest+0x24c>
		}

		Register = XSpi_GetStatusReg(InstancePtr);
c001bdd8:	fdc42783          	lw	a5,-36(s0)
c001bddc:	0187a783          	lw	a5,24(a5)
c001bde0:	06478793          	addi	a5,a5,100
c001bde4:	00078513          	mv	a0,a5
c001bde8:	e99ff0ef          	jal	ra,c001bc80 <Xil_In32>
c001bdec:	fea42623          	sw	a0,-20(s0)
		if ((Register & XSP_SR_RESET_STATE) != XSP_SR_RESET_STATE) {
c001bdf0:	fec42783          	lw	a5,-20(s0)
c001bdf4:	0057f713          	andi	a4,a5,5
c001bdf8:	00500793          	li	a5,5
c001bdfc:	00f70663          	beq	a4,a5,c001be08 <XSpi_SelfTest+0x128>
			return XST_REGISTER_ERROR;
c001be00:	00e00793          	li	a5,14
c001be04:	1280006f          	j	c001bf2c <XSpi_SelfTest+0x24c>


	/*
	 * All the SPI registers should be in their default state right now.
	 */
	Register = XSpi_GetControlReg(InstancePtr);
c001be08:	fdc42783          	lw	a5,-36(s0)
c001be0c:	0187a783          	lw	a5,24(a5)
c001be10:	06078793          	addi	a5,a5,96
c001be14:	00078513          	mv	a0,a5
c001be18:	e69ff0ef          	jal	ra,c001bc80 <Xil_In32>
c001be1c:	fea42623          	sw	a0,-20(s0)
	if (Register != XSP_CR_RESET_STATE) {
c001be20:	fec42703          	lw	a4,-20(s0)
c001be24:	18000793          	li	a5,384
c001be28:	00f70663          	beq	a4,a5,c001be34 <XSpi_SelfTest+0x154>
		return XST_REGISTER_ERROR;
c001be2c:	00e00793          	li	a5,14
c001be30:	0fc0006f          	j	c001bf2c <XSpi_SelfTest+0x24c>
	}

	Register = XSpi_GetStatusReg(InstancePtr);
c001be34:	fdc42783          	lw	a5,-36(s0)
c001be38:	0187a783          	lw	a5,24(a5)
c001be3c:	06478793          	addi	a5,a5,100
c001be40:	00078513          	mv	a0,a5
c001be44:	e3dff0ef          	jal	ra,c001bc80 <Xil_In32>
c001be48:	fea42623          	sw	a0,-20(s0)
	if ((Register & XSP_SR_RESET_STATE) != XSP_SR_RESET_STATE) {
c001be4c:	fec42783          	lw	a5,-20(s0)
c001be50:	0057f713          	andi	a4,a5,5
c001be54:	00500793          	li	a5,5
c001be58:	00f70663          	beq	a4,a5,c001be64 <XSpi_SelfTest+0x184>
		return XST_REGISTER_ERROR;
c001be5c:	00e00793          	li	a5,14
c001be60:	0cc0006f          	j	c001bf2c <XSpi_SelfTest+0x24c>
	}

	/*
	 * Each supported slave select bit should be set to 1.
	 */
	Register = XSpi_GetSlaveSelectReg(InstancePtr);
c001be64:	fdc42783          	lw	a5,-36(s0)
c001be68:	0187a783          	lw	a5,24(a5)
c001be6c:	07078793          	addi	a5,a5,112
c001be70:	00078513          	mv	a0,a5
c001be74:	e0dff0ef          	jal	ra,c001bc80 <Xil_In32>
c001be78:	fea42623          	sw	a0,-20(s0)
	if (Register != InstancePtr->SlaveSelectMask) {
c001be7c:	fdc42783          	lw	a5,-36(s0)
c001be80:	0307a783          	lw	a5,48(a5)
c001be84:	fec42703          	lw	a4,-20(s0)
c001be88:	00f70663          	beq	a4,a5,c001be94 <XSpi_SelfTest+0x1b4>
		return XST_REGISTER_ERROR;
c001be8c:	00e00793          	li	a5,14
c001be90:	09c0006f          	j	c001bf2c <XSpi_SelfTest+0x24c>
	}

	/*
	 * If configured with FIFOs, the occupancy values should be 0.
	 */
	if (InstancePtr->HasFifos) {
c001be94:	fdc42783          	lw	a5,-36(s0)
c001be98:	0247a783          	lw	a5,36(a5)
c001be9c:	04078a63          	beqz	a5,c001bef0 <XSpi_SelfTest+0x210>
		Register = XSpi_ReadReg(InstancePtr->BaseAddr,
c001bea0:	fdc42783          	lw	a5,-36(s0)
c001bea4:	0187a783          	lw	a5,24(a5)
c001bea8:	07478793          	addi	a5,a5,116
c001beac:	00078513          	mv	a0,a5
c001beb0:	dd1ff0ef          	jal	ra,c001bc80 <Xil_In32>
c001beb4:	fea42623          	sw	a0,-20(s0)
					 XSP_TFO_OFFSET);
		if (Register != 0) {
c001beb8:	fec42783          	lw	a5,-20(s0)
c001bebc:	00078663          	beqz	a5,c001bec8 <XSpi_SelfTest+0x1e8>
			return XST_REGISTER_ERROR;
c001bec0:	00e00793          	li	a5,14
c001bec4:	0680006f          	j	c001bf2c <XSpi_SelfTest+0x24c>
		}
		Register = XSpi_ReadReg(InstancePtr->BaseAddr,
c001bec8:	fdc42783          	lw	a5,-36(s0)
c001becc:	0187a783          	lw	a5,24(a5)
c001bed0:	07878793          	addi	a5,a5,120
c001bed4:	00078513          	mv	a0,a5
c001bed8:	da9ff0ef          	jal	ra,c001bc80 <Xil_In32>
c001bedc:	fea42623          	sw	a0,-20(s0)
					 XSP_RFO_OFFSET);
		if (Register != 0) {
c001bee0:	fec42783          	lw	a5,-20(s0)
c001bee4:	00078663          	beqz	a5,c001bef0 <XSpi_SelfTest+0x210>
			return XST_REGISTER_ERROR;
c001bee8:	00e00793          	li	a5,14
c001beec:	0400006f          	j	c001bf2c <XSpi_SelfTest+0x24c>
	}

	/*
	 * Run loopback test only in case of standard SPI mode.
	 */
	if (InstancePtr->SpiMode != XSP_STANDARD_MODE) {
c001bef0:	fdc42783          	lw	a5,-36(s0)
c001bef4:	02e7c783          	lbu	a5,46(a5)
c001bef8:	00078663          	beqz	a5,c001bf04 <XSpi_SelfTest+0x224>
		return XST_SUCCESS;
c001befc:	00000793          	li	a5,0
c001bf00:	02c0006f          	j	c001bf2c <XSpi_SelfTest+0x24c>
	}

	/*
	 * Run an internal loopback test on the SPI.
	 */
	Result = LoopbackTest(InstancePtr);
c001bf04:	fdc42503          	lw	a0,-36(s0)
c001bf08:	038000ef          	jal	ra,c001bf40 <LoopbackTest>
c001bf0c:	fea42423          	sw	a0,-24(s0)
	if (Result != XST_SUCCESS) {
c001bf10:	fe842783          	lw	a5,-24(s0)
c001bf14:	00078663          	beqz	a5,c001bf20 <XSpi_SelfTest+0x240>
		return Result;
c001bf18:	fe842783          	lw	a5,-24(s0)
c001bf1c:	0100006f          	j	c001bf2c <XSpi_SelfTest+0x24c>
	}

	/*
	 * Reset the SPI device to leave it in a known good state.
	 */
	XSpi_Reset(InstancePtr);
c001bf20:	fdc42503          	lw	a0,-36(s0)
c001bf24:	911fe0ef          	jal	ra,c001a834 <XSpi_Reset>

	return XST_SUCCESS;
c001bf28:	00000793          	li	a5,0
}
c001bf2c:	00078513          	mv	a0,a5
c001bf30:	02c12083          	lw	ra,44(sp)
c001bf34:	02812403          	lw	s0,40(sp)
c001bf38:	03010113          	addi	sp,sp,48
c001bf3c:	00008067          	ret

c001bf40 <LoopbackTest>:
*
* @note		None.
*
******************************************************************************/
static int LoopbackTest(XSpi *InstancePtr)
{
c001bf40:	fc010113          	addi	sp,sp,-64
c001bf44:	02112e23          	sw	ra,60(sp)
c001bf48:	02812c23          	sw	s0,56(sp)
c001bf4c:	02912a23          	sw	s1,52(sp)
c001bf50:	04010413          	addi	s0,sp,64
c001bf54:	fca42623          	sw	a0,-52(s0)
	u32 StatusReg;
	u32 ControlReg;
	u32 Index;
	u32 Data;
	u32 RxData;
	u32 NumSent = 0;
c001bf58:	fe042023          	sw	zero,-32(s0)
	u32 NumRecvd = 0;
c001bf5c:	fc042e23          	sw	zero,-36(s0)

	/*
	 * Cannot run as a slave-only because we need to be master in order to
	 * initiate a transfer. Still return success, though.
	 */
	if (InstancePtr->SlaveOnly) {
c001bf60:	fcc42783          	lw	a5,-52(s0)
c001bf64:	0287a783          	lw	a5,40(a5)
c001bf68:	00078663          	beqz	a5,c001bf74 <LoopbackTest+0x34>
		return XST_SUCCESS;
c001bf6c:	00000793          	li	a5,0
c001bf70:	3340006f          	j	c001c2a4 <LoopbackTest+0x364>

	/*
	 * Setup the control register to enable master mode and the loopback so
	 * that data can be sent and received.
	 */
	ControlReg = XSpi_GetControlReg(InstancePtr);
c001bf74:	fcc42783          	lw	a5,-52(s0)
c001bf78:	0187a783          	lw	a5,24(a5)
c001bf7c:	06078793          	addi	a5,a5,96
c001bf80:	00078513          	mv	a0,a5
c001bf84:	cfdff0ef          	jal	ra,c001bc80 <Xil_In32>
c001bf88:	fca42c23          	sw	a0,-40(s0)
	XSpi_SetControlReg(InstancePtr, ControlReg |
c001bf8c:	fcc42783          	lw	a5,-52(s0)
c001bf90:	0187a783          	lw	a5,24(a5)
c001bf94:	06078713          	addi	a4,a5,96
c001bf98:	fd842783          	lw	a5,-40(s0)
c001bf9c:	0057e793          	ori	a5,a5,5
c001bfa0:	00078593          	mv	a1,a5
c001bfa4:	00070513          	mv	a0,a4
c001bfa8:	d01ff0ef          	jal	ra,c001bca8 <Xil_Out32>
			    XSP_CR_LOOPBACK_MASK | XSP_CR_MASTER_MODE_MASK);
	/*
	 * We do not need interrupts for this loopback test.
	 */
	XSpi_IntrGlobalDisable(InstancePtr);
c001bfac:	fcc42783          	lw	a5,-52(s0)
c001bfb0:	0187a783          	lw	a5,24(a5)
c001bfb4:	01c78793          	addi	a5,a5,28
c001bfb8:	00000593          	li	a1,0
c001bfbc:	00078513          	mv	a0,a5
c001bfc0:	ce9ff0ef          	jal	ra,c001bca8 <Xil_Out32>

	DataWidth = InstancePtr->DataWidth;
c001bfc4:	fcc42783          	lw	a5,-52(s0)
c001bfc8:	02d7c783          	lbu	a5,45(a5)
c001bfcc:	fcf40ba3          	sb	a5,-41(s0)
	/*
	 * Send data up to the maximum size of the transmit register, which is
	 * one byte without FIFOs.  We send data 4 times just to exercise the
	 * device through more than one iteration.
	 */
	for (Index = 0; Index < 4; Index++) {
c001bfd0:	fe042423          	sw	zero,-24(s0)
c001bfd4:	2ac0006f          	j	c001c280 <LoopbackTest+0x340>
		Data = 0;
c001bfd8:	fe042223          	sw	zero,-28(s0)

		/*
		 * Fill the transmit register.
		 */
		StatusReg = XSpi_GetStatusReg(InstancePtr);
c001bfdc:	fcc42783          	lw	a5,-52(s0)
c001bfe0:	0187a783          	lw	a5,24(a5)
c001bfe4:	06478793          	addi	a5,a5,100
c001bfe8:	00078513          	mv	a0,a5
c001bfec:	c95ff0ef          	jal	ra,c001bc80 <Xil_In32>
c001bff0:	fea42623          	sw	a0,-20(s0)
		while ((StatusReg & XSP_SR_TX_FULL_MASK) == 0) {
c001bff4:	0a40006f          	j	c001c098 <LoopbackTest+0x158>
			if (DataWidth == XSP_DATAWIDTH_BYTE) {
c001bff8:	fd744703          	lbu	a4,-41(s0)
c001bffc:	00800793          	li	a5,8
c001c000:	00f71663          	bne	a4,a5,c001c00c <LoopbackTest+0xcc>
				/*
				 * Data Transfer Width is Byte (8 bit).
				 */
				Data = 0;
c001c004:	fe042223          	sw	zero,-28(s0)
c001c008:	0380006f          	j	c001c040 <LoopbackTest+0x100>
			} else if (DataWidth == XSP_DATAWIDTH_HALF_WORD) {
c001c00c:	fd744703          	lbu	a4,-41(s0)
c001c010:	01000793          	li	a5,16
c001c014:	00f71a63          	bne	a4,a5,c001c028 <LoopbackTest+0xe8>
				/*
				 * Data Transfer Width is Half Word (16 bit).
				 */
				Data = XSP_HALF_WORD_TESTBYTE;
c001c018:	000027b7          	lui	a5,0x2
c001c01c:	20078793          	addi	a5,a5,512 # 2200 <_STACK_SIZE+0x1200>
c001c020:	fef42223          	sw	a5,-28(s0)
c001c024:	01c0006f          	j	c001c040 <LoopbackTest+0x100>
			} else if (DataWidth == XSP_DATAWIDTH_WORD){
c001c028:	fd744703          	lbu	a4,-41(s0)
c001c02c:	02000793          	li	a5,32
c001c030:	00f71863          	bne	a4,a5,c001c040 <LoopbackTest+0x100>
				/*
				 * Data Transfer Width is Word (32 bit).
				 */
				Data = XSP_WORD_TESTBYTE;
c001c034:	aa0057b7          	lui	a5,0xaa005
c001c038:	50078793          	addi	a5,a5,1280 # aa005500 <_end+0xe1f80c80>
c001c03c:	fef42223          	sw	a5,-28(s0)
			}

			XSpi_WriteReg(InstancePtr->BaseAddr, XSP_DTR_OFFSET,
c001c040:	fcc42783          	lw	a5,-52(s0)
c001c044:	0187a783          	lw	a5,24(a5)
c001c048:	06878693          	addi	a3,a5,104
c001c04c:	fe442703          	lw	a4,-28(s0)
c001c050:	fe842783          	lw	a5,-24(s0)
c001c054:	00f707b3          	add	a5,a4,a5
c001c058:	00078593          	mv	a1,a5
c001c05c:	00068513          	mv	a0,a3
c001c060:	c49ff0ef          	jal	ra,c001bca8 <Xil_Out32>
					Data + Index);
			NumSent += (DataWidth >> 3);
c001c064:	fd744783          	lbu	a5,-41(s0)
c001c068:	0037d793          	srli	a5,a5,0x3
c001c06c:	0ff7f793          	andi	a5,a5,255
c001c070:	00078713          	mv	a4,a5
c001c074:	fe042783          	lw	a5,-32(s0)
c001c078:	00e787b3          	add	a5,a5,a4
c001c07c:	fef42023          	sw	a5,-32(s0)
			StatusReg = XSpi_GetStatusReg(InstancePtr);
c001c080:	fcc42783          	lw	a5,-52(s0)
c001c084:	0187a783          	lw	a5,24(a5)
c001c088:	06478793          	addi	a5,a5,100
c001c08c:	00078513          	mv	a0,a5
c001c090:	bf1ff0ef          	jal	ra,c001bc80 <Xil_In32>
c001c094:	fea42623          	sw	a0,-20(s0)
		while ((StatusReg & XSP_SR_TX_FULL_MASK) == 0) {
c001c098:	fec42783          	lw	a5,-20(s0)
c001c09c:	0087f793          	andi	a5,a5,8
c001c0a0:	f4078ce3          	beqz	a5,c001bff8 <LoopbackTest+0xb8>

		/*
		 * Start the transfer by not inhibiting the transmitter and
		 * enabling the device.
		 */
		ControlReg = XSpi_GetControlReg(InstancePtr) &
c001c0a4:	fcc42783          	lw	a5,-52(s0)
c001c0a8:	0187a783          	lw	a5,24(a5)
c001c0ac:	06078793          	addi	a5,a5,96
c001c0b0:	00078513          	mv	a0,a5
c001c0b4:	bcdff0ef          	jal	ra,c001bc80 <Xil_In32>
c001c0b8:	00050793          	mv	a5,a0
c001c0bc:	eff7f793          	andi	a5,a5,-257
c001c0c0:	fcf42c23          	sw	a5,-40(s0)
						 (~XSP_CR_TRANS_INHIBIT_MASK);
		XSpi_SetControlReg(InstancePtr, ControlReg |
c001c0c4:	fcc42783          	lw	a5,-52(s0)
c001c0c8:	0187a783          	lw	a5,24(a5)
c001c0cc:	06078713          	addi	a4,a5,96
c001c0d0:	fd842783          	lw	a5,-40(s0)
c001c0d4:	0027e793          	ori	a5,a5,2
c001c0d8:	00078593          	mv	a1,a5
c001c0dc:	00070513          	mv	a0,a4
c001c0e0:	bc9ff0ef          	jal	ra,c001bca8 <Xil_Out32>
		/*
		 * Wait for the transfer to be done by polling the transmit
		 * empty status bit.
		 */
		do {
			StatusReg = XSpi_IntrGetStatus(InstancePtr);
c001c0e4:	fcc42783          	lw	a5,-52(s0)
c001c0e8:	0187a783          	lw	a5,24(a5)
c001c0ec:	02078793          	addi	a5,a5,32
c001c0f0:	00078513          	mv	a0,a5
c001c0f4:	b8dff0ef          	jal	ra,c001bc80 <Xil_In32>
c001c0f8:	fea42623          	sw	a0,-20(s0)
		} while ((StatusReg & XSP_INTR_TX_EMPTY_MASK) == 0);
c001c0fc:	fec42783          	lw	a5,-20(s0)
c001c100:	0047f793          	andi	a5,a5,4
c001c104:	fe0780e3          	beqz	a5,c001c0e4 <LoopbackTest+0x1a4>

		XSpi_IntrClear(InstancePtr, XSP_INTR_TX_EMPTY_MASK);
c001c108:	fcc42783          	lw	a5,-52(s0)
c001c10c:	0187a783          	lw	a5,24(a5)
c001c110:	02078493          	addi	s1,a5,32
c001c114:	fcc42783          	lw	a5,-52(s0)
c001c118:	0187a783          	lw	a5,24(a5)
c001c11c:	02078793          	addi	a5,a5,32
c001c120:	00078513          	mv	a0,a5
c001c124:	b5dff0ef          	jal	ra,c001bc80 <Xil_In32>
c001c128:	00050793          	mv	a5,a0
c001c12c:	0047e793          	ori	a5,a5,4
c001c130:	00078593          	mv	a1,a5
c001c134:	00048513          	mv	a0,s1
c001c138:	b71ff0ef          	jal	ra,c001bca8 <Xil_Out32>

		/*
		 * Receive and verify the data just transmitted.
		 */
		StatusReg = XSpi_GetStatusReg(InstancePtr);
c001c13c:	fcc42783          	lw	a5,-52(s0)
c001c140:	0187a783          	lw	a5,24(a5)
c001c144:	06478793          	addi	a5,a5,100
c001c148:	00078513          	mv	a0,a5
c001c14c:	b35ff0ef          	jal	ra,c001bc80 <Xil_In32>
c001c150:	fea42623          	sw	a0,-20(s0)
		while ((StatusReg & XSP_SR_RX_EMPTY_MASK) == 0) {
c001c154:	0e80006f          	j	c001c23c <LoopbackTest+0x2fc>

			RxData = XSpi_ReadReg(InstancePtr->BaseAddr,
c001c158:	fcc42783          	lw	a5,-52(s0)
c001c15c:	0187a783          	lw	a5,24(a5)
c001c160:	06c78793          	addi	a5,a5,108
c001c164:	00078513          	mv	a0,a5
c001c168:	b19ff0ef          	jal	ra,c001bc80 <Xil_In32>
c001c16c:	fca42823          	sw	a0,-48(s0)
						XSP_DRR_OFFSET);

			if (DataWidth == XSP_DATAWIDTH_BYTE) {
c001c170:	fd744703          	lbu	a4,-41(s0)
c001c174:	00800793          	li	a5,8
c001c178:	02f71063          	bne	a4,a5,c001c198 <LoopbackTest+0x258>
				if((u8)RxData != Index) {
c001c17c:	fd042783          	lw	a5,-48(s0)
c001c180:	0ff7f793          	andi	a5,a5,255
c001c184:	00078713          	mv	a4,a5
c001c188:	fe842783          	lw	a5,-24(s0)
c001c18c:	06e78e63          	beq	a5,a4,c001c208 <LoopbackTest+0x2c8>
					return XST_LOOPBACK_ERROR;
c001c190:	01100793          	li	a5,17
c001c194:	1100006f          	j	c001c2a4 <LoopbackTest+0x364>
				}
			} else if (DataWidth ==
c001c198:	fd744703          	lbu	a4,-41(s0)
c001c19c:	01000793          	li	a5,16
c001c1a0:	02f71e63          	bne	a4,a5,c001c1dc <LoopbackTest+0x29c>
					XSP_DATAWIDTH_HALF_WORD) {
				if((u16)RxData != (u16)(Index +
c001c1a4:	fd042783          	lw	a5,-48(s0)
c001c1a8:	01079713          	slli	a4,a5,0x10
c001c1ac:	01075713          	srli	a4,a4,0x10
c001c1b0:	fe842783          	lw	a5,-24(s0)
c001c1b4:	01079693          	slli	a3,a5,0x10
c001c1b8:	0106d693          	srli	a3,a3,0x10
c001c1bc:	000027b7          	lui	a5,0x2
c001c1c0:	20078793          	addi	a5,a5,512 # 2200 <_STACK_SIZE+0x1200>
c001c1c4:	00f687b3          	add	a5,a3,a5
c001c1c8:	01079793          	slli	a5,a5,0x10
c001c1cc:	0107d793          	srli	a5,a5,0x10
c001c1d0:	02f70c63          	beq	a4,a5,c001c208 <LoopbackTest+0x2c8>
						   XSP_HALF_WORD_TESTBYTE)) {
					return XST_LOOPBACK_ERROR;
c001c1d4:	01100793          	li	a5,17
c001c1d8:	0cc0006f          	j	c001c2a4 <LoopbackTest+0x364>
				}
			} else if (DataWidth == XSP_DATAWIDTH_WORD) {
c001c1dc:	fd744703          	lbu	a4,-41(s0)
c001c1e0:	02000793          	li	a5,32
c001c1e4:	02f71263          	bne	a4,a5,c001c208 <LoopbackTest+0x2c8>
				if(RxData != (u32)(Index + XSP_WORD_TESTBYTE)) {
c001c1e8:	fe842703          	lw	a4,-24(s0)
c001c1ec:	aa0057b7          	lui	a5,0xaa005
c001c1f0:	50078793          	addi	a5,a5,1280 # aa005500 <_end+0xe1f80c80>
c001c1f4:	00f707b3          	add	a5,a4,a5
c001c1f8:	fd042703          	lw	a4,-48(s0)
c001c1fc:	00f70663          	beq	a4,a5,c001c208 <LoopbackTest+0x2c8>
					return XST_LOOPBACK_ERROR;
c001c200:	01100793          	li	a5,17
c001c204:	0a00006f          	j	c001c2a4 <LoopbackTest+0x364>
				}
			}

			NumRecvd += (DataWidth >> 3);
c001c208:	fd744783          	lbu	a5,-41(s0)
c001c20c:	0037d793          	srli	a5,a5,0x3
c001c210:	0ff7f793          	andi	a5,a5,255
c001c214:	00078713          	mv	a4,a5
c001c218:	fdc42783          	lw	a5,-36(s0)
c001c21c:	00e787b3          	add	a5,a5,a4
c001c220:	fcf42e23          	sw	a5,-36(s0)
			StatusReg = XSpi_GetStatusReg(InstancePtr);
c001c224:	fcc42783          	lw	a5,-52(s0)
c001c228:	0187a783          	lw	a5,24(a5)
c001c22c:	06478793          	addi	a5,a5,100
c001c230:	00078513          	mv	a0,a5
c001c234:	a4dff0ef          	jal	ra,c001bc80 <Xil_In32>
c001c238:	fea42623          	sw	a0,-20(s0)
		while ((StatusReg & XSP_SR_RX_EMPTY_MASK) == 0) {
c001c23c:	fec42783          	lw	a5,-20(s0)
c001c240:	0017f793          	andi	a5,a5,1
c001c244:	f0078ae3          	beqz	a5,c001c158 <LoopbackTest+0x218>

		/*
		 * Stop the transfer (hold off automatic sending) by inhibiting
		 * the transmitter and disabling the device.
		 */
		ControlReg |= XSP_CR_TRANS_INHIBIT_MASK;
c001c248:	fd842783          	lw	a5,-40(s0)
c001c24c:	1007e793          	ori	a5,a5,256
c001c250:	fcf42c23          	sw	a5,-40(s0)
		XSpi_SetControlReg(InstancePtr ,
c001c254:	fcc42783          	lw	a5,-52(s0)
c001c258:	0187a783          	lw	a5,24(a5)
c001c25c:	06078713          	addi	a4,a5,96
c001c260:	fd842783          	lw	a5,-40(s0)
c001c264:	ffd7f793          	andi	a5,a5,-3
c001c268:	00078593          	mv	a1,a5
c001c26c:	00070513          	mv	a0,a4
c001c270:	a39ff0ef          	jal	ra,c001bca8 <Xil_Out32>
	for (Index = 0; Index < 4; Index++) {
c001c274:	fe842783          	lw	a5,-24(s0)
c001c278:	00178793          	addi	a5,a5,1
c001c27c:	fef42423          	sw	a5,-24(s0)
c001c280:	fe842703          	lw	a4,-24(s0)
c001c284:	00300793          	li	a5,3
c001c288:	d4e7f8e3          	bgeu	a5,a4,c001bfd8 <LoopbackTest+0x98>

	/*
	 * One final check to make sure the total number of bytes sent equals
	 * the total number of bytes received.
	 */
	if (NumSent != NumRecvd) {
c001c28c:	fe042703          	lw	a4,-32(s0)
c001c290:	fdc42783          	lw	a5,-36(s0)
c001c294:	00f70663          	beq	a4,a5,c001c2a0 <LoopbackTest+0x360>
		return XST_LOOPBACK_ERROR;
c001c298:	01100793          	li	a5,17
c001c29c:	0080006f          	j	c001c2a4 <LoopbackTest+0x364>
	}

	return XST_SUCCESS;
c001c2a0:	00000793          	li	a5,0
}
c001c2a4:	00078513          	mv	a0,a5
c001c2a8:	03c12083          	lw	ra,60(sp)
c001c2ac:	03812403          	lw	s0,56(sp)
c001c2b0:	03412483          	lw	s1,52(sp)
c001c2b4:	04010113          	addi	sp,sp,64
c001c2b8:	00008067          	ret

c001c2bc <Xil_In32>:
{
c001c2bc:	fe010113          	addi	sp,sp,-32
c001c2c0:	00812e23          	sw	s0,28(sp)
c001c2c4:	02010413          	addi	s0,sp,32
c001c2c8:	fea42623          	sw	a0,-20(s0)
	return *(volatile u32 *) Addr;
c001c2cc:	fec42783          	lw	a5,-20(s0)
c001c2d0:	0007a783          	lw	a5,0(a5)
}
c001c2d4:	00078513          	mv	a0,a5
c001c2d8:	01c12403          	lw	s0,28(sp)
c001c2dc:	02010113          	addi	sp,sp,32
c001c2e0:	00008067          	ret

c001c2e4 <Xil_Out32>:
{
c001c2e4:	fd010113          	addi	sp,sp,-48
c001c2e8:	02812623          	sw	s0,44(sp)
c001c2ec:	03010413          	addi	s0,sp,48
c001c2f0:	fca42e23          	sw	a0,-36(s0)
c001c2f4:	fcb42c23          	sw	a1,-40(s0)
	volatile u32 *LocalAddr = (volatile u32 *)Addr;
c001c2f8:	fdc42783          	lw	a5,-36(s0)
c001c2fc:	fef42623          	sw	a5,-20(s0)
	*LocalAddr = Value;
c001c300:	fec42783          	lw	a5,-20(s0)
c001c304:	fd842703          	lw	a4,-40(s0)
c001c308:	00e7a023          	sw	a4,0(a5)
}
c001c30c:	00000013          	nop
c001c310:	02c12403          	lw	s0,44(sp)
c001c314:	03010113          	addi	sp,sp,48
c001c318:	00008067          	ret

c001c31c <XSpi_SetOptions>:
* required to provide protection of this shared data (typically using a
* semaphore).
*
******************************************************************************/
int XSpi_SetOptions(XSpi *InstancePtr, u32 Options)
{
c001c31c:	fd010113          	addi	sp,sp,-48
c001c320:	02112623          	sw	ra,44(sp)
c001c324:	02812423          	sw	s0,40(sp)
c001c328:	03010413          	addi	s0,sp,48
c001c32c:	fca42e23          	sw	a0,-36(s0)
c001c330:	fcb42c23          	sw	a1,-40(s0)
	u32 ControlReg;
	u32 Index;

	Xil_AssertNonvoid(InstancePtr != NULL);
c001c334:	fdc42783          	lw	a5,-36(s0)
c001c338:	02078463          	beqz	a5,c001c360 <XSpi_SetOptions+0x44>
c001c33c:	07fe6797          	auipc	a5,0x7fe6
c001c340:	5d878793          	addi	a5,a5,1496 # c8002914 <Xil_AssertStatus>
c001c344:	0007a023          	sw	zero,0(a5)
	Xil_AssertNonvoid(InstancePtr->IsReady == XIL_COMPONENT_IS_READY);
c001c348:	fdc42783          	lw	a5,-36(s0)
c001c34c:	01c7a703          	lw	a4,28(a5)
c001c350:	111117b7          	lui	a5,0x11111
c001c354:	11178793          	addi	a5,a5,273 # 11111111 <_DMEM_LENGTH+0x10911111>
c001c358:	04f71663          	bne	a4,a5,c001c3a4 <XSpi_SetOptions+0x88>
c001c35c:	02c0006f          	j	c001c388 <XSpi_SetOptions+0x6c>
	Xil_AssertNonvoid(InstancePtr != NULL);
c001c360:	07e00593          	li	a1,126
c001c364:	07fe5517          	auipc	a0,0x7fe5
c001c368:	63050513          	addi	a0,a0,1584 # c8001994 <__rodata_start+0x1994>
c001c36c:	750010ef          	jal	ra,c001dabc <Xil_Assert>
c001c370:	07fe6797          	auipc	a5,0x7fe6
c001c374:	5a478793          	addi	a5,a5,1444 # c8002914 <Xil_AssertStatus>
c001c378:	00100713          	li	a4,1
c001c37c:	00e7a023          	sw	a4,0(a5)
c001c380:	00000793          	li	a5,0
c001c384:	1380006f          	j	c001c4bc <XSpi_SetOptions+0x1a0>
	Xil_AssertNonvoid(InstancePtr->IsReady == XIL_COMPONENT_IS_READY);
c001c388:	07fe6797          	auipc	a5,0x7fe6
c001c38c:	58c78793          	addi	a5,a5,1420 # c8002914 <Xil_AssertStatus>
c001c390:	0007a023          	sw	zero,0(a5)
	 * No need to worry about a critical section here since even if the Isr
	 * changes the busy flag just after we read it, the function will return
	 * busy and the caller can retry when notified that their current
	 * transfer is done.
	 */
	if (InstancePtr->IsBusy) {
c001c394:	fdc42783          	lw	a5,-36(s0)
c001c398:	0487a783          	lw	a5,72(a5)
c001c39c:	02078c63          	beqz	a5,c001c3d4 <XSpi_SetOptions+0xb8>
c001c3a0:	02c0006f          	j	c001c3cc <XSpi_SetOptions+0xb0>
	Xil_AssertNonvoid(InstancePtr->IsReady == XIL_COMPONENT_IS_READY);
c001c3a4:	07f00593          	li	a1,127
c001c3a8:	07fe5517          	auipc	a0,0x7fe5
c001c3ac:	5ec50513          	addi	a0,a0,1516 # c8001994 <__rodata_start+0x1994>
c001c3b0:	70c010ef          	jal	ra,c001dabc <Xil_Assert>
c001c3b4:	07fe6797          	auipc	a5,0x7fe6
c001c3b8:	56078793          	addi	a5,a5,1376 # c8002914 <Xil_AssertStatus>
c001c3bc:	00100713          	li	a4,1
c001c3c0:	00e7a023          	sw	a4,0(a5)
c001c3c4:	00000793          	li	a5,0
c001c3c8:	0f40006f          	j	c001c4bc <XSpi_SetOptions+0x1a0>
		return XST_DEVICE_BUSY;
c001c3cc:	01500793          	li	a5,21
c001c3d0:	0ec0006f          	j	c001c4bc <XSpi_SetOptions+0x1a0>
	}
	/*
	 * Do not allow master option to be set if the device is slave only.
	 */
	if ((Options & XSP_MASTER_OPTION) && (InstancePtr->SlaveOnly)) {
c001c3d4:	fd842783          	lw	a5,-40(s0)
c001c3d8:	0017f793          	andi	a5,a5,1
c001c3dc:	00078c63          	beqz	a5,c001c3f4 <XSpi_SetOptions+0xd8>
c001c3e0:	fdc42783          	lw	a5,-36(s0)
c001c3e4:	0287a783          	lw	a5,40(a5)
c001c3e8:	00078663          	beqz	a5,c001c3f4 <XSpi_SetOptions+0xd8>
		return XST_SPI_SLAVE_ONLY;
c001c3ec:	48600793          	li	a5,1158
c001c3f0:	0cc0006f          	j	c001c4bc <XSpi_SetOptions+0x1a0>
	}

	ControlReg = XSpi_GetControlReg(InstancePtr);
c001c3f4:	fdc42783          	lw	a5,-36(s0)
c001c3f8:	0187a783          	lw	a5,24(a5)
c001c3fc:	06078793          	addi	a5,a5,96
c001c400:	00078513          	mv	a0,a5
c001c404:	eb9ff0ef          	jal	ra,c001c2bc <Xil_In32>
c001c408:	fea42623          	sw	a0,-20(s0)

	/*
	 * Loop through the options table, turning the option on or off
	 * depending on whether the bit is set in the incoming options flag.
	 */
	for (Index = 0; Index < XSP_NUM_OPTIONS; Index++) {
c001c40c:	fe042423          	sw	zero,-24(s0)
c001c410:	0840006f          	j	c001c494 <XSpi_SetOptions+0x178>
		if (Options & OptionsTable[Index].Option) {
c001c414:	07fe6717          	auipc	a4,0x7fe6
c001c418:	71c70713          	addi	a4,a4,1820 # c8002b30 <OptionsTable>
c001c41c:	fe842783          	lw	a5,-24(s0)
c001c420:	00379793          	slli	a5,a5,0x3
c001c424:	00f707b3          	add	a5,a4,a5
c001c428:	0007a703          	lw	a4,0(a5)
c001c42c:	fd842783          	lw	a5,-40(s0)
c001c430:	00f777b3          	and	a5,a4,a5
c001c434:	02078663          	beqz	a5,c001c460 <XSpi_SetOptions+0x144>
			/*
			 *Turn it ON.
			 */
			ControlReg |= OptionsTable[Index].Mask;
c001c438:	07fe6717          	auipc	a4,0x7fe6
c001c43c:	6f870713          	addi	a4,a4,1784 # c8002b30 <OptionsTable>
c001c440:	fe842783          	lw	a5,-24(s0)
c001c444:	00379793          	slli	a5,a5,0x3
c001c448:	00f707b3          	add	a5,a4,a5
c001c44c:	0047a783          	lw	a5,4(a5)
c001c450:	fec42703          	lw	a4,-20(s0)
c001c454:	00f767b3          	or	a5,a4,a5
c001c458:	fef42623          	sw	a5,-20(s0)
c001c45c:	02c0006f          	j	c001c488 <XSpi_SetOptions+0x16c>
		}
		else {
			/*
			 *Turn it OFF.
			 */
			ControlReg &= ~OptionsTable[Index].Mask;
c001c460:	07fe6717          	auipc	a4,0x7fe6
c001c464:	6d070713          	addi	a4,a4,1744 # c8002b30 <OptionsTable>
c001c468:	fe842783          	lw	a5,-24(s0)
c001c46c:	00379793          	slli	a5,a5,0x3
c001c470:	00f707b3          	add	a5,a4,a5
c001c474:	0047a783          	lw	a5,4(a5)
c001c478:	fff7c793          	not	a5,a5
c001c47c:	fec42703          	lw	a4,-20(s0)
c001c480:	00f777b3          	and	a5,a4,a5
c001c484:	fef42623          	sw	a5,-20(s0)
	for (Index = 0; Index < XSP_NUM_OPTIONS; Index++) {
c001c488:	fe842783          	lw	a5,-24(s0)
c001c48c:	00178793          	addi	a5,a5,1
c001c490:	fef42423          	sw	a5,-24(s0)
c001c494:	fe842703          	lw	a4,-24(s0)
c001c498:	00400793          	li	a5,4
c001c49c:	f6e7fce3          	bgeu	a5,a4,c001c414 <XSpi_SetOptions+0xf8>

	/*
	 * Now write the control register. Leave it to the upper layers
	 * to restart the device.
	 */
	XSpi_SetControlReg(InstancePtr, ControlReg);
c001c4a0:	fdc42783          	lw	a5,-36(s0)
c001c4a4:	0187a783          	lw	a5,24(a5)
c001c4a8:	06078793          	addi	a5,a5,96
c001c4ac:	fec42583          	lw	a1,-20(s0)
c001c4b0:	00078513          	mv	a0,a5
c001c4b4:	e31ff0ef          	jal	ra,c001c2e4 <Xil_Out32>

	return XST_SUCCESS;
c001c4b8:	00000793          	li	a5,0
}
c001c4bc:	00078513          	mv	a0,a5
c001c4c0:	02c12083          	lw	ra,44(sp)
c001c4c4:	02812403          	lw	s0,40(sp)
c001c4c8:	03010113          	addi	sp,sp,48
c001c4cc:	00008067          	ret

c001c4d0 <XSpi_GetOptions>:
*
* @note		None.
*
******************************************************************************/
u32 XSpi_GetOptions(XSpi *InstancePtr)
{
c001c4d0:	fd010113          	addi	sp,sp,-48
c001c4d4:	02112623          	sw	ra,44(sp)
c001c4d8:	02812423          	sw	s0,40(sp)
c001c4dc:	03010413          	addi	s0,sp,48
c001c4e0:	fca42e23          	sw	a0,-36(s0)
	u32 OptionsFlag = 0;
c001c4e4:	fe042623          	sw	zero,-20(s0)
	u32 ControlReg;
	u32 Index;

	Xil_AssertNonvoid(InstancePtr != NULL);
c001c4e8:	fdc42783          	lw	a5,-36(s0)
c001c4ec:	02078463          	beqz	a5,c001c514 <XSpi_GetOptions+0x44>
c001c4f0:	07fe6797          	auipc	a5,0x7fe6
c001c4f4:	42478793          	addi	a5,a5,1060 # c8002914 <Xil_AssertStatus>
c001c4f8:	0007a023          	sw	zero,0(a5)
	Xil_AssertNonvoid(InstancePtr->IsReady == XIL_COMPONENT_IS_READY);
c001c4fc:	fdc42783          	lw	a5,-36(s0)
c001c500:	01c7a703          	lw	a4,28(a5)
c001c504:	111117b7          	lui	a5,0x11111
c001c508:	11178793          	addi	a5,a5,273 # 11111111 <_DMEM_LENGTH+0x10911111>
c001c50c:	04f71e63          	bne	a4,a5,c001c568 <XSpi_GetOptions+0x98>
c001c510:	02c0006f          	j	c001c53c <XSpi_GetOptions+0x6c>
	Xil_AssertNonvoid(InstancePtr != NULL);
c001c514:	0c900593          	li	a1,201
c001c518:	07fe5517          	auipc	a0,0x7fe5
c001c51c:	47c50513          	addi	a0,a0,1148 # c8001994 <__rodata_start+0x1994>
c001c520:	59c010ef          	jal	ra,c001dabc <Xil_Assert>
c001c524:	07fe6797          	auipc	a5,0x7fe6
c001c528:	3f078793          	addi	a5,a5,1008 # c8002914 <Xil_AssertStatus>
c001c52c:	00100713          	li	a4,1
c001c530:	00e7a023          	sw	a4,0(a5)
c001c534:	00000793          	li	a5,0
c001c538:	0bc0006f          	j	c001c5f4 <XSpi_GetOptions+0x124>
	Xil_AssertNonvoid(InstancePtr->IsReady == XIL_COMPONENT_IS_READY);
c001c53c:	07fe6797          	auipc	a5,0x7fe6
c001c540:	3d878793          	addi	a5,a5,984 # c8002914 <Xil_AssertStatus>
c001c544:	0007a023          	sw	zero,0(a5)

	/*
	 * Get the control register to determine which options are currently
	 * set.
	 */
	ControlReg = XSpi_GetControlReg(InstancePtr);
c001c548:	fdc42783          	lw	a5,-36(s0)
c001c54c:	0187a783          	lw	a5,24(a5)
c001c550:	06078793          	addi	a5,a5,96
c001c554:	00078513          	mv	a0,a5
c001c558:	d65ff0ef          	jal	ra,c001c2bc <Xil_In32>
c001c55c:	fea42223          	sw	a0,-28(s0)

	/*
	 * Loop through the options table to determine which options are set.
	 */
	for (Index = 0; Index < XSP_NUM_OPTIONS; Index++) {
c001c560:	fe042423          	sw	zero,-24(s0)
c001c564:	0800006f          	j	c001c5e4 <XSpi_GetOptions+0x114>
	Xil_AssertNonvoid(InstancePtr->IsReady == XIL_COMPONENT_IS_READY);
c001c568:	0ca00593          	li	a1,202
c001c56c:	07fe5517          	auipc	a0,0x7fe5
c001c570:	42850513          	addi	a0,a0,1064 # c8001994 <__rodata_start+0x1994>
c001c574:	548010ef          	jal	ra,c001dabc <Xil_Assert>
c001c578:	07fe6797          	auipc	a5,0x7fe6
c001c57c:	39c78793          	addi	a5,a5,924 # c8002914 <Xil_AssertStatus>
c001c580:	00100713          	li	a4,1
c001c584:	00e7a023          	sw	a4,0(a5)
c001c588:	00000793          	li	a5,0
c001c58c:	0680006f          	j	c001c5f4 <XSpi_GetOptions+0x124>
		if (ControlReg & OptionsTable[Index].Mask) {
c001c590:	07fe6717          	auipc	a4,0x7fe6
c001c594:	5a070713          	addi	a4,a4,1440 # c8002b30 <OptionsTable>
c001c598:	fe842783          	lw	a5,-24(s0)
c001c59c:	00379793          	slli	a5,a5,0x3
c001c5a0:	00f707b3          	add	a5,a4,a5
c001c5a4:	0047a703          	lw	a4,4(a5)
c001c5a8:	fe442783          	lw	a5,-28(s0)
c001c5ac:	00f777b3          	and	a5,a4,a5
c001c5b0:	02078463          	beqz	a5,c001c5d8 <XSpi_GetOptions+0x108>
			OptionsFlag |= OptionsTable[Index].Option;
c001c5b4:	07fe6717          	auipc	a4,0x7fe6
c001c5b8:	57c70713          	addi	a4,a4,1404 # c8002b30 <OptionsTable>
c001c5bc:	fe842783          	lw	a5,-24(s0)
c001c5c0:	00379793          	slli	a5,a5,0x3
c001c5c4:	00f707b3          	add	a5,a4,a5
c001c5c8:	0007a783          	lw	a5,0(a5)
c001c5cc:	fec42703          	lw	a4,-20(s0)
c001c5d0:	00f767b3          	or	a5,a4,a5
c001c5d4:	fef42623          	sw	a5,-20(s0)
	for (Index = 0; Index < XSP_NUM_OPTIONS; Index++) {
c001c5d8:	fe842783          	lw	a5,-24(s0)
c001c5dc:	00178793          	addi	a5,a5,1
c001c5e0:	fef42423          	sw	a5,-24(s0)
c001c5e4:	fe842703          	lw	a4,-24(s0)
c001c5e8:	00400793          	li	a5,4
c001c5ec:	fae7f2e3          	bgeu	a5,a4,c001c590 <XSpi_GetOptions+0xc0>
		}
	}

	return OptionsFlag;
c001c5f0:	fec42783          	lw	a5,-20(s0)
}
c001c5f4:	00078513          	mv	a0,a5
c001c5f8:	02c12083          	lw	ra,44(sp)
c001c5fc:	02812403          	lw	s0,40(sp)
c001c600:	03010113          	addi	sp,sp,48
c001c604:	00008067          	ret

c001c608 <Xil_In32>:
{
c001c608:	fe010113          	addi	sp,sp,-32
c001c60c:	00812e23          	sw	s0,28(sp)
c001c610:	02010413          	addi	s0,sp,32
c001c614:	fea42623          	sw	a0,-20(s0)
	return *(volatile u32 *) Addr;
c001c618:	fec42783          	lw	a5,-20(s0)
c001c61c:	0007a783          	lw	a5,0(a5)
}
c001c620:	00078513          	mv	a0,a5
c001c624:	01c12403          	lw	s0,28(sp)
c001c628:	02010113          	addi	sp,sp,32
c001c62c:	00008067          	ret

c001c630 <Xil_Out32>:
{
c001c630:	fd010113          	addi	sp,sp,-48
c001c634:	02812623          	sw	s0,44(sp)
c001c638:	03010413          	addi	s0,sp,48
c001c63c:	fca42e23          	sw	a0,-36(s0)
c001c640:	fcb42c23          	sw	a1,-40(s0)
	volatile u32 *LocalAddr = (volatile u32 *)Addr;
c001c644:	fdc42783          	lw	a5,-36(s0)
c001c648:	fef42623          	sw	a5,-20(s0)
	*LocalAddr = Value;
c001c64c:	fec42783          	lw	a5,-20(s0)
c001c650:	fd842703          	lw	a4,-40(s0)
c001c654:	00e7a023          	sw	a4,0(a5)
}
c001c658:	00000013          	nop
c001c65c:	02c12403          	lw	s0,44(sp)
c001c660:	03010113          	addi	sp,sp,48
c001c664:	00008067          	ret

c001c668 <XGpio_CfgInitialize>:
* @note		None.
*
*****************************************************************************/
int XGpio_CfgInitialize(XGpio * InstancePtr, XGpio_Config * Config,
			UINTPTR EffectiveAddr)
{
c001c668:	fe010113          	addi	sp,sp,-32
c001c66c:	00112e23          	sw	ra,28(sp)
c001c670:	00812c23          	sw	s0,24(sp)
c001c674:	02010413          	addi	s0,sp,32
c001c678:	fea42623          	sw	a0,-20(s0)
c001c67c:	feb42423          	sw	a1,-24(s0)
c001c680:	fec42223          	sw	a2,-28(s0)
	/* Assert arguments */
	Xil_AssertNonvoid(InstancePtr != NULL);
c001c684:	fec42783          	lw	a5,-20(s0)
c001c688:	04078a63          	beqz	a5,c001c6dc <XGpio_CfgInitialize+0x74>
c001c68c:	07fe6797          	auipc	a5,0x7fe6
c001c690:	28878793          	addi	a5,a5,648 # c8002914 <Xil_AssertStatus>
c001c694:	0007a023          	sw	zero,0(a5)

	/* Set some default values. */
	InstancePtr->BaseAddress = EffectiveAddr;
c001c698:	fec42783          	lw	a5,-20(s0)
c001c69c:	fe442703          	lw	a4,-28(s0)
c001c6a0:	00e7a023          	sw	a4,0(a5)

	InstancePtr->InterruptPresent = Config->InterruptPresent;
c001c6a4:	fe842783          	lw	a5,-24(s0)
c001c6a8:	0087a703          	lw	a4,8(a5)
c001c6ac:	fec42783          	lw	a5,-20(s0)
c001c6b0:	00e7a423          	sw	a4,8(a5)
	InstancePtr->IsDual = Config->IsDual;
c001c6b4:	fe842783          	lw	a5,-24(s0)
c001c6b8:	00c7a703          	lw	a4,12(a5)
c001c6bc:	fec42783          	lw	a5,-20(s0)
c001c6c0:	00e7a623          	sw	a4,12(a5)

	/*
	 * Indicate the instance is now ready to use, initialized without error
	 */
	InstancePtr->IsReady = XIL_COMPONENT_IS_READY;
c001c6c4:	fec42783          	lw	a5,-20(s0)
c001c6c8:	11111737          	lui	a4,0x11111
c001c6cc:	11170713          	addi	a4,a4,273 # 11111111 <_DMEM_LENGTH+0x10911111>
c001c6d0:	00e7a223          	sw	a4,4(a5)
	return (XST_SUCCESS);
c001c6d4:	00000793          	li	a5,0
c001c6d8:	0280006f          	j	c001c700 <XGpio_CfgInitialize+0x98>
	Xil_AssertNonvoid(InstancePtr != NULL);
c001c6dc:	07900593          	li	a1,121
c001c6e0:	07fe5517          	auipc	a0,0x7fe5
c001c6e4:	2d450513          	addi	a0,a0,724 # c80019b4 <__rodata_start+0x19b4>
c001c6e8:	3d4010ef          	jal	ra,c001dabc <Xil_Assert>
c001c6ec:	07fe6797          	auipc	a5,0x7fe6
c001c6f0:	22878793          	addi	a5,a5,552 # c8002914 <Xil_AssertStatus>
c001c6f4:	00100713          	li	a4,1
c001c6f8:	00e7a023          	sw	a4,0(a5)
c001c6fc:	00000793          	li	a5,0
}
c001c700:	00078513          	mv	a0,a5
c001c704:	01c12083          	lw	ra,28(sp)
c001c708:	01812403          	lw	s0,24(sp)
c001c70c:	02010113          	addi	sp,sp,32
c001c710:	00008067          	ret

c001c714 <XGpio_SetDataDirection>:
*		function will assert.
*
*****************************************************************************/
void XGpio_SetDataDirection(XGpio *InstancePtr, unsigned Channel,
			    u32 DirectionMask)
{
c001c714:	fe010113          	addi	sp,sp,-32
c001c718:	00112e23          	sw	ra,28(sp)
c001c71c:	00812c23          	sw	s0,24(sp)
c001c720:	02010413          	addi	s0,sp,32
c001c724:	fea42623          	sw	a0,-20(s0)
c001c728:	feb42423          	sw	a1,-24(s0)
c001c72c:	fec42223          	sw	a2,-28(s0)
	Xil_AssertVoid(InstancePtr != NULL);
c001c730:	fec42783          	lw	a5,-20(s0)
c001c734:	02078463          	beqz	a5,c001c75c <XGpio_SetDataDirection+0x48>
c001c738:	07fe6797          	auipc	a5,0x7fe6
c001c73c:	1dc78793          	addi	a5,a5,476 # c8002914 <Xil_AssertStatus>
c001c740:	0007a023          	sw	zero,0(a5)
	Xil_AssertVoid(InstancePtr->IsReady == XIL_COMPONENT_IS_READY);
c001c744:	fec42783          	lw	a5,-20(s0)
c001c748:	0047a703          	lw	a4,4(a5)
c001c74c:	111117b7          	lui	a5,0x11111
c001c750:	11178793          	addi	a5,a5,273 # 11111111 <_DMEM_LENGTH+0x10911111>
c001c754:	04f71463          	bne	a4,a5,c001c79c <XGpio_SetDataDirection+0x88>
c001c758:	0280006f          	j	c001c780 <XGpio_SetDataDirection+0x6c>
	Xil_AssertVoid(InstancePtr != NULL);
c001c75c:	09e00593          	li	a1,158
c001c760:	07fe5517          	auipc	a0,0x7fe5
c001c764:	25450513          	addi	a0,a0,596 # c80019b4 <__rodata_start+0x19b4>
c001c768:	354010ef          	jal	ra,c001dabc <Xil_Assert>
c001c76c:	07fe6797          	auipc	a5,0x7fe6
c001c770:	1a878793          	addi	a5,a5,424 # c8002914 <Xil_AssertStatus>
c001c774:	00100713          	li	a4,1
c001c778:	00e7a023          	sw	a4,0(a5)
c001c77c:	0bc0006f          	j	c001c838 <XGpio_SetDataDirection+0x124>
	Xil_AssertVoid(InstancePtr->IsReady == XIL_COMPONENT_IS_READY);
c001c780:	07fe6797          	auipc	a5,0x7fe6
c001c784:	19478793          	addi	a5,a5,404 # c8002914 <Xil_AssertStatus>
c001c788:	0007a023          	sw	zero,0(a5)
	Xil_AssertVoid((Channel == 1) ||
c001c78c:	fe842703          	lw	a4,-24(s0)
c001c790:	00100793          	li	a5,1
c001c794:	04f70463          	beq	a4,a5,c001c7dc <XGpio_SetDataDirection+0xc8>
c001c798:	0280006f          	j	c001c7c0 <XGpio_SetDataDirection+0xac>
	Xil_AssertVoid(InstancePtr->IsReady == XIL_COMPONENT_IS_READY);
c001c79c:	09f00593          	li	a1,159
c001c7a0:	07fe5517          	auipc	a0,0x7fe5
c001c7a4:	21450513          	addi	a0,a0,532 # c80019b4 <__rodata_start+0x19b4>
c001c7a8:	314010ef          	jal	ra,c001dabc <Xil_Assert>
c001c7ac:	07fe6797          	auipc	a5,0x7fe6
c001c7b0:	16878793          	addi	a5,a5,360 # c8002914 <Xil_AssertStatus>
c001c7b4:	00100713          	li	a4,1
c001c7b8:	00e7a023          	sw	a4,0(a5)
c001c7bc:	07c0006f          	j	c001c838 <XGpio_SetDataDirection+0x124>
	Xil_AssertVoid((Channel == 1) ||
c001c7c0:	fe842703          	lw	a4,-24(s0)
c001c7c4:	00200793          	li	a5,2
c001c7c8:	04f71663          	bne	a4,a5,c001c814 <XGpio_SetDataDirection+0x100>
c001c7cc:	fec42783          	lw	a5,-20(s0)
c001c7d0:	00c7a703          	lw	a4,12(a5)
c001c7d4:	00100793          	li	a5,1
c001c7d8:	02f71e63          	bne	a4,a5,c001c814 <XGpio_SetDataDirection+0x100>
c001c7dc:	07fe6797          	auipc	a5,0x7fe6
c001c7e0:	13878793          	addi	a5,a5,312 # c8002914 <Xil_AssertStatus>
c001c7e4:	0007a023          	sw	zero,0(a5)
		     ((Channel == 2) && (InstancePtr->IsDual == TRUE)));

	XGpio_WriteReg(InstancePtr->BaseAddress,
c001c7e8:	fec42783          	lw	a5,-20(s0)
c001c7ec:	0007a703          	lw	a4,0(a5)
c001c7f0:	fe842783          	lw	a5,-24(s0)
c001c7f4:	fff78793          	addi	a5,a5,-1
c001c7f8:	00379793          	slli	a5,a5,0x3
c001c7fc:	00f707b3          	add	a5,a4,a5
c001c800:	00478793          	addi	a5,a5,4
c001c804:	fe442583          	lw	a1,-28(s0)
c001c808:	00078513          	mv	a0,a5
c001c80c:	e25ff0ef          	jal	ra,c001c630 <Xil_Out32>
c001c810:	0280006f          	j	c001c838 <XGpio_SetDataDirection+0x124>
	Xil_AssertVoid((Channel == 1) ||
c001c814:	0a000593          	li	a1,160
c001c818:	07fe5517          	auipc	a0,0x7fe5
c001c81c:	19c50513          	addi	a0,a0,412 # c80019b4 <__rodata_start+0x19b4>
c001c820:	29c010ef          	jal	ra,c001dabc <Xil_Assert>
c001c824:	07fe6797          	auipc	a5,0x7fe6
c001c828:	0f078793          	addi	a5,a5,240 # c8002914 <Xil_AssertStatus>
c001c82c:	00100713          	li	a4,1
c001c830:	00e7a023          	sw	a4,0(a5)
c001c834:	00000013          	nop
			((Channel - 1) * XGPIO_CHAN_OFFSET) + XGPIO_TRI_OFFSET,
			DirectionMask);
}
c001c838:	01c12083          	lw	ra,28(sp)
c001c83c:	01812403          	lw	s0,24(sp)
c001c840:	02010113          	addi	sp,sp,32
c001c844:	00008067          	ret

c001c848 <XGpio_GetDataDirection>:
* The hardware must be built for dual channels if this function is used
* with any channel other than 1.  If it is not, this function will assert.
*
*****************************************************************************/
u32 XGpio_GetDataDirection(XGpio *InstancePtr, unsigned Channel)
{
c001c848:	fe010113          	addi	sp,sp,-32
c001c84c:	00112e23          	sw	ra,28(sp)
c001c850:	00812c23          	sw	s0,24(sp)
c001c854:	02010413          	addi	s0,sp,32
c001c858:	fea42623          	sw	a0,-20(s0)
c001c85c:	feb42423          	sw	a1,-24(s0)
	Xil_AssertNonvoid(InstancePtr != NULL);
c001c860:	fec42783          	lw	a5,-20(s0)
c001c864:	02078463          	beqz	a5,c001c88c <XGpio_GetDataDirection+0x44>
c001c868:	07fe6797          	auipc	a5,0x7fe6
c001c86c:	0ac78793          	addi	a5,a5,172 # c8002914 <Xil_AssertStatus>
c001c870:	0007a023          	sw	zero,0(a5)
	Xil_AssertNonvoid(InstancePtr->IsReady == XIL_COMPONENT_IS_READY);
c001c874:	fec42783          	lw	a5,-20(s0)
c001c878:	0047a703          	lw	a4,4(a5)
c001c87c:	111117b7          	lui	a5,0x11111
c001c880:	11178793          	addi	a5,a5,273 # 11111111 <_DMEM_LENGTH+0x10911111>
c001c884:	04f71663          	bne	a4,a5,c001c8d0 <XGpio_GetDataDirection+0x88>
c001c888:	02c0006f          	j	c001c8b4 <XGpio_GetDataDirection+0x6c>
	Xil_AssertNonvoid(InstancePtr != NULL);
c001c88c:	0bc00593          	li	a1,188
c001c890:	07fe5517          	auipc	a0,0x7fe5
c001c894:	12450513          	addi	a0,a0,292 # c80019b4 <__rodata_start+0x19b4>
c001c898:	224010ef          	jal	ra,c001dabc <Xil_Assert>
c001c89c:	07fe6797          	auipc	a5,0x7fe6
c001c8a0:	07878793          	addi	a5,a5,120 # c8002914 <Xil_AssertStatus>
c001c8a4:	00100713          	li	a4,1
c001c8a8:	00e7a023          	sw	a4,0(a5)
c001c8ac:	00000793          	li	a5,0
c001c8b0:	0c00006f          	j	c001c970 <XGpio_GetDataDirection+0x128>
	Xil_AssertNonvoid(InstancePtr->IsReady == XIL_COMPONENT_IS_READY);
c001c8b4:	07fe6797          	auipc	a5,0x7fe6
c001c8b8:	06078793          	addi	a5,a5,96 # c8002914 <Xil_AssertStatus>
c001c8bc:	0007a023          	sw	zero,0(a5)
	Xil_AssertNonvoid((Channel == 1)  ||
c001c8c0:	fe842703          	lw	a4,-24(s0)
c001c8c4:	00100793          	li	a5,1
c001c8c8:	04f70663          	beq	a4,a5,c001c914 <XGpio_GetDataDirection+0xcc>
c001c8cc:	02c0006f          	j	c001c8f8 <XGpio_GetDataDirection+0xb0>
	Xil_AssertNonvoid(InstancePtr->IsReady == XIL_COMPONENT_IS_READY);
c001c8d0:	0bd00593          	li	a1,189
c001c8d4:	07fe5517          	auipc	a0,0x7fe5
c001c8d8:	0e050513          	addi	a0,a0,224 # c80019b4 <__rodata_start+0x19b4>
c001c8dc:	1e0010ef          	jal	ra,c001dabc <Xil_Assert>
c001c8e0:	07fe6797          	auipc	a5,0x7fe6
c001c8e4:	03478793          	addi	a5,a5,52 # c8002914 <Xil_AssertStatus>
c001c8e8:	00100713          	li	a4,1
c001c8ec:	00e7a023          	sw	a4,0(a5)
c001c8f0:	00000793          	li	a5,0
c001c8f4:	07c0006f          	j	c001c970 <XGpio_GetDataDirection+0x128>
	Xil_AssertNonvoid((Channel == 1)  ||
c001c8f8:	fe842703          	lw	a4,-24(s0)
c001c8fc:	00200793          	li	a5,2
c001c900:	04f71663          	bne	a4,a5,c001c94c <XGpio_GetDataDirection+0x104>
c001c904:	fec42783          	lw	a5,-20(s0)
c001c908:	00c7a703          	lw	a4,12(a5)
c001c90c:	00100793          	li	a5,1
c001c910:	02f71e63          	bne	a4,a5,c001c94c <XGpio_GetDataDirection+0x104>
c001c914:	07fe6797          	auipc	a5,0x7fe6
c001c918:	00078793          	mv	a5,a5
c001c91c:	0007a023          	sw	zero,0(a5) # c8002914 <Xil_AssertStatus>
		((Channel == 2) &&
		(InstancePtr->IsDual == TRUE)));

	return XGpio_ReadReg(InstancePtr->BaseAddress,
c001c920:	fec42783          	lw	a5,-20(s0)
c001c924:	0007a703          	lw	a4,0(a5)
c001c928:	fe842783          	lw	a5,-24(s0)
c001c92c:	fff78793          	addi	a5,a5,-1
c001c930:	00379793          	slli	a5,a5,0x3
c001c934:	00f707b3          	add	a5,a4,a5
c001c938:	00478793          	addi	a5,a5,4
c001c93c:	00078513          	mv	a0,a5
c001c940:	cc9ff0ef          	jal	ra,c001c608 <Xil_In32>
c001c944:	00050793          	mv	a5,a0
c001c948:	0280006f          	j	c001c970 <XGpio_GetDataDirection+0x128>
	Xil_AssertNonvoid((Channel == 1)  ||
c001c94c:	0be00593          	li	a1,190
c001c950:	07fe5517          	auipc	a0,0x7fe5
c001c954:	06450513          	addi	a0,a0,100 # c80019b4 <__rodata_start+0x19b4>
c001c958:	164010ef          	jal	ra,c001dabc <Xil_Assert>
c001c95c:	07fe6797          	auipc	a5,0x7fe6
c001c960:	fb878793          	addi	a5,a5,-72 # c8002914 <Xil_AssertStatus>
c001c964:	00100713          	li	a4,1
c001c968:	00e7a023          	sw	a4,0(a5)
c001c96c:	00000793          	li	a5,0
		((Channel - 1) * XGPIO_CHAN_OFFSET) + XGPIO_TRI_OFFSET);
}
c001c970:	00078513          	mv	a0,a5
c001c974:	01c12083          	lw	ra,28(sp)
c001c978:	01812403          	lw	s0,24(sp)
c001c97c:	02010113          	addi	sp,sp,32
c001c980:	00008067          	ret

c001c984 <XGpio_DiscreteRead>:
*		is used with any channel other than 1.  If it is not, this
*		function will assert.
*
*****************************************************************************/
u32 XGpio_DiscreteRead(XGpio * InstancePtr, unsigned Channel)
{
c001c984:	fe010113          	addi	sp,sp,-32
c001c988:	00112e23          	sw	ra,28(sp)
c001c98c:	00812c23          	sw	s0,24(sp)
c001c990:	02010413          	addi	s0,sp,32
c001c994:	fea42623          	sw	a0,-20(s0)
c001c998:	feb42423          	sw	a1,-24(s0)
	Xil_AssertNonvoid(InstancePtr != NULL);
c001c99c:	fec42783          	lw	a5,-20(s0)
c001c9a0:	02078463          	beqz	a5,c001c9c8 <XGpio_DiscreteRead+0x44>
c001c9a4:	07fe6797          	auipc	a5,0x7fe6
c001c9a8:	f7078793          	addi	a5,a5,-144 # c8002914 <Xil_AssertStatus>
c001c9ac:	0007a023          	sw	zero,0(a5)
	Xil_AssertNonvoid(InstancePtr->IsReady == XIL_COMPONENT_IS_READY);
c001c9b0:	fec42783          	lw	a5,-20(s0)
c001c9b4:	0047a703          	lw	a4,4(a5)
c001c9b8:	111117b7          	lui	a5,0x11111
c001c9bc:	11178793          	addi	a5,a5,273 # 11111111 <_DMEM_LENGTH+0x10911111>
c001c9c0:	04f71663          	bne	a4,a5,c001ca0c <XGpio_DiscreteRead+0x88>
c001c9c4:	02c0006f          	j	c001c9f0 <XGpio_DiscreteRead+0x6c>
	Xil_AssertNonvoid(InstancePtr != NULL);
c001c9c8:	0d600593          	li	a1,214
c001c9cc:	07fe5517          	auipc	a0,0x7fe5
c001c9d0:	fe850513          	addi	a0,a0,-24 # c80019b4 <__rodata_start+0x19b4>
c001c9d4:	0e8010ef          	jal	ra,c001dabc <Xil_Assert>
c001c9d8:	07fe6797          	auipc	a5,0x7fe6
c001c9dc:	f3c78793          	addi	a5,a5,-196 # c8002914 <Xil_AssertStatus>
c001c9e0:	00100713          	li	a4,1
c001c9e4:	00e7a023          	sw	a4,0(a5)
c001c9e8:	00000793          	li	a5,0
c001c9ec:	0bc0006f          	j	c001caa8 <XGpio_DiscreteRead+0x124>
	Xil_AssertNonvoid(InstancePtr->IsReady == XIL_COMPONENT_IS_READY);
c001c9f0:	07fe6797          	auipc	a5,0x7fe6
c001c9f4:	f2478793          	addi	a5,a5,-220 # c8002914 <Xil_AssertStatus>
c001c9f8:	0007a023          	sw	zero,0(a5)
	Xil_AssertNonvoid((Channel == 1) ||
c001c9fc:	fe842703          	lw	a4,-24(s0)
c001ca00:	00100793          	li	a5,1
c001ca04:	04f70663          	beq	a4,a5,c001ca50 <XGpio_DiscreteRead+0xcc>
c001ca08:	02c0006f          	j	c001ca34 <XGpio_DiscreteRead+0xb0>
	Xil_AssertNonvoid(InstancePtr->IsReady == XIL_COMPONENT_IS_READY);
c001ca0c:	0d700593          	li	a1,215
c001ca10:	07fe5517          	auipc	a0,0x7fe5
c001ca14:	fa450513          	addi	a0,a0,-92 # c80019b4 <__rodata_start+0x19b4>
c001ca18:	0a4010ef          	jal	ra,c001dabc <Xil_Assert>
c001ca1c:	07fe6797          	auipc	a5,0x7fe6
c001ca20:	ef878793          	addi	a5,a5,-264 # c8002914 <Xil_AssertStatus>
c001ca24:	00100713          	li	a4,1
c001ca28:	00e7a023          	sw	a4,0(a5)
c001ca2c:	00000793          	li	a5,0
c001ca30:	0780006f          	j	c001caa8 <XGpio_DiscreteRead+0x124>
	Xil_AssertNonvoid((Channel == 1) ||
c001ca34:	fe842703          	lw	a4,-24(s0)
c001ca38:	00200793          	li	a5,2
c001ca3c:	04f71463          	bne	a4,a5,c001ca84 <XGpio_DiscreteRead+0x100>
c001ca40:	fec42783          	lw	a5,-20(s0)
c001ca44:	00c7a703          	lw	a4,12(a5)
c001ca48:	00100793          	li	a5,1
c001ca4c:	02f71c63          	bne	a4,a5,c001ca84 <XGpio_DiscreteRead+0x100>
c001ca50:	07fe6797          	auipc	a5,0x7fe6
c001ca54:	ec478793          	addi	a5,a5,-316 # c8002914 <Xil_AssertStatus>
c001ca58:	0007a023          	sw	zero,0(a5)
			((Channel == 2) && (InstancePtr->IsDual == TRUE)));

	return XGpio_ReadReg(InstancePtr->BaseAddress,
c001ca5c:	fec42783          	lw	a5,-20(s0)
c001ca60:	0007a703          	lw	a4,0(a5)
c001ca64:	fe842783          	lw	a5,-24(s0)
c001ca68:	fff78793          	addi	a5,a5,-1
c001ca6c:	00379793          	slli	a5,a5,0x3
c001ca70:	00f707b3          	add	a5,a4,a5
c001ca74:	00078513          	mv	a0,a5
c001ca78:	b91ff0ef          	jal	ra,c001c608 <Xil_In32>
c001ca7c:	00050793          	mv	a5,a0
c001ca80:	0280006f          	j	c001caa8 <XGpio_DiscreteRead+0x124>
	Xil_AssertNonvoid((Channel == 1) ||
c001ca84:	0d800593          	li	a1,216
c001ca88:	07fe5517          	auipc	a0,0x7fe5
c001ca8c:	f2c50513          	addi	a0,a0,-212 # c80019b4 <__rodata_start+0x19b4>
c001ca90:	02c010ef          	jal	ra,c001dabc <Xil_Assert>
c001ca94:	07fe6797          	auipc	a5,0x7fe6
c001ca98:	e8078793          	addi	a5,a5,-384 # c8002914 <Xil_AssertStatus>
c001ca9c:	00100713          	li	a4,1
c001caa0:	00e7a023          	sw	a4,0(a5)
c001caa4:	00000793          	li	a5,0
			      ((Channel - 1) * XGPIO_CHAN_OFFSET) +
			      XGPIO_DATA_OFFSET);
}
c001caa8:	00078513          	mv	a0,a5
c001caac:	01c12083          	lw	ra,28(sp)
c001cab0:	01812403          	lw	s0,24(sp)
c001cab4:	02010113          	addi	sp,sp,32
c001cab8:	00008067          	ret

c001cabc <XGpio_DiscreteWrite>:
*		function will assert. See also XGpio_DiscreteSet() and
*		XGpio_DiscreteClear().
*
*****************************************************************************/
void XGpio_DiscreteWrite(XGpio * InstancePtr, unsigned Channel, u32 Data)
{
c001cabc:	fe010113          	addi	sp,sp,-32
c001cac0:	00112e23          	sw	ra,28(sp)
c001cac4:	00812c23          	sw	s0,24(sp)
c001cac8:	02010413          	addi	s0,sp,32
c001cacc:	fea42623          	sw	a0,-20(s0)
c001cad0:	feb42423          	sw	a1,-24(s0)
c001cad4:	fec42223          	sw	a2,-28(s0)
	Xil_AssertVoid(InstancePtr != NULL);
c001cad8:	fec42783          	lw	a5,-20(s0)
c001cadc:	02078463          	beqz	a5,c001cb04 <XGpio_DiscreteWrite+0x48>
c001cae0:	07fe6797          	auipc	a5,0x7fe6
c001cae4:	e3478793          	addi	a5,a5,-460 # c8002914 <Xil_AssertStatus>
c001cae8:	0007a023          	sw	zero,0(a5)
	Xil_AssertVoid(InstancePtr->IsReady == XIL_COMPONENT_IS_READY);
c001caec:	fec42783          	lw	a5,-20(s0)
c001caf0:	0047a703          	lw	a4,4(a5)
c001caf4:	111117b7          	lui	a5,0x11111
c001caf8:	11178793          	addi	a5,a5,273 # 11111111 <_DMEM_LENGTH+0x10911111>
c001cafc:	04f71463          	bne	a4,a5,c001cb44 <XGpio_DiscreteWrite+0x88>
c001cb00:	0280006f          	j	c001cb28 <XGpio_DiscreteWrite+0x6c>
	Xil_AssertVoid(InstancePtr != NULL);
c001cb04:	0f200593          	li	a1,242
c001cb08:	07fe5517          	auipc	a0,0x7fe5
c001cb0c:	eac50513          	addi	a0,a0,-340 # c80019b4 <__rodata_start+0x19b4>
c001cb10:	7ad000ef          	jal	ra,c001dabc <Xil_Assert>
c001cb14:	07fe6797          	auipc	a5,0x7fe6
c001cb18:	e0078793          	addi	a5,a5,-512 # c8002914 <Xil_AssertStatus>
c001cb1c:	00100713          	li	a4,1
c001cb20:	00e7a023          	sw	a4,0(a5)
c001cb24:	0b80006f          	j	c001cbdc <XGpio_DiscreteWrite+0x120>
	Xil_AssertVoid(InstancePtr->IsReady == XIL_COMPONENT_IS_READY);
c001cb28:	07fe6797          	auipc	a5,0x7fe6
c001cb2c:	dec78793          	addi	a5,a5,-532 # c8002914 <Xil_AssertStatus>
c001cb30:	0007a023          	sw	zero,0(a5)
	Xil_AssertVoid((Channel == 1) ||
c001cb34:	fe842703          	lw	a4,-24(s0)
c001cb38:	00100793          	li	a5,1
c001cb3c:	04f70463          	beq	a4,a5,c001cb84 <XGpio_DiscreteWrite+0xc8>
c001cb40:	0280006f          	j	c001cb68 <XGpio_DiscreteWrite+0xac>
	Xil_AssertVoid(InstancePtr->IsReady == XIL_COMPONENT_IS_READY);
c001cb44:	0f300593          	li	a1,243
c001cb48:	07fe5517          	auipc	a0,0x7fe5
c001cb4c:	e6c50513          	addi	a0,a0,-404 # c80019b4 <__rodata_start+0x19b4>
c001cb50:	76d000ef          	jal	ra,c001dabc <Xil_Assert>
c001cb54:	07fe6797          	auipc	a5,0x7fe6
c001cb58:	dc078793          	addi	a5,a5,-576 # c8002914 <Xil_AssertStatus>
c001cb5c:	00100713          	li	a4,1
c001cb60:	00e7a023          	sw	a4,0(a5)
c001cb64:	0780006f          	j	c001cbdc <XGpio_DiscreteWrite+0x120>
	Xil_AssertVoid((Channel == 1) ||
c001cb68:	fe842703          	lw	a4,-24(s0)
c001cb6c:	00200793          	li	a5,2
c001cb70:	04f71463          	bne	a4,a5,c001cbb8 <XGpio_DiscreteWrite+0xfc>
c001cb74:	fec42783          	lw	a5,-20(s0)
c001cb78:	00c7a703          	lw	a4,12(a5)
c001cb7c:	00100793          	li	a5,1
c001cb80:	02f71c63          	bne	a4,a5,c001cbb8 <XGpio_DiscreteWrite+0xfc>
c001cb84:	07fe6797          	auipc	a5,0x7fe6
c001cb88:	d9078793          	addi	a5,a5,-624 # c8002914 <Xil_AssertStatus>
c001cb8c:	0007a023          	sw	zero,0(a5)
		     ((Channel == 2) && (InstancePtr->IsDual == TRUE)));

	XGpio_WriteReg(InstancePtr->BaseAddress,
c001cb90:	fec42783          	lw	a5,-20(s0)
c001cb94:	0007a703          	lw	a4,0(a5)
c001cb98:	fe842783          	lw	a5,-24(s0)
c001cb9c:	fff78793          	addi	a5,a5,-1
c001cba0:	00379793          	slli	a5,a5,0x3
c001cba4:	00f707b3          	add	a5,a4,a5
c001cba8:	fe442583          	lw	a1,-28(s0)
c001cbac:	00078513          	mv	a0,a5
c001cbb0:	a81ff0ef          	jal	ra,c001c630 <Xil_Out32>
c001cbb4:	0280006f          	j	c001cbdc <XGpio_DiscreteWrite+0x120>
	Xil_AssertVoid((Channel == 1) ||
c001cbb8:	0f400593          	li	a1,244
c001cbbc:	07fe5517          	auipc	a0,0x7fe5
c001cbc0:	df850513          	addi	a0,a0,-520 # c80019b4 <__rodata_start+0x19b4>
c001cbc4:	6f9000ef          	jal	ra,c001dabc <Xil_Assert>
c001cbc8:	07fe6797          	auipc	a5,0x7fe6
c001cbcc:	d4c78793          	addi	a5,a5,-692 # c8002914 <Xil_AssertStatus>
c001cbd0:	00100713          	li	a4,1
c001cbd4:	00e7a023          	sw	a4,0(a5)
c001cbd8:	00000013          	nop
			((Channel - 1) * XGPIO_CHAN_OFFSET) + XGPIO_DATA_OFFSET,
			Data);
}
c001cbdc:	01c12083          	lw	ra,28(sp)
c001cbe0:	01812403          	lw	s0,24(sp)
c001cbe4:	02010113          	addi	sp,sp,32
c001cbe8:	00008067          	ret

c001cbec <Xil_In32>:
{
c001cbec:	fe010113          	addi	sp,sp,-32
c001cbf0:	00812e23          	sw	s0,28(sp)
c001cbf4:	02010413          	addi	s0,sp,32
c001cbf8:	fea42623          	sw	a0,-20(s0)
	return *(volatile u32 *) Addr;
c001cbfc:	fec42783          	lw	a5,-20(s0)
c001cc00:	0007a783          	lw	a5,0(a5)
}
c001cc04:	00078513          	mv	a0,a5
c001cc08:	01c12403          	lw	s0,28(sp)
c001cc0c:	02010113          	addi	sp,sp,32
c001cc10:	00008067          	ret

c001cc14 <Xil_Out32>:
{
c001cc14:	fd010113          	addi	sp,sp,-48
c001cc18:	02812623          	sw	s0,44(sp)
c001cc1c:	03010413          	addi	s0,sp,48
c001cc20:	fca42e23          	sw	a0,-36(s0)
c001cc24:	fcb42c23          	sw	a1,-40(s0)
	volatile u32 *LocalAddr = (volatile u32 *)Addr;
c001cc28:	fdc42783          	lw	a5,-36(s0)
c001cc2c:	fef42623          	sw	a5,-20(s0)
	*LocalAddr = Value;
c001cc30:	fec42783          	lw	a5,-20(s0)
c001cc34:	fd842703          	lw	a4,-40(s0)
c001cc38:	00e7a023          	sw	a4,0(a5)
}
c001cc3c:	00000013          	nop
c001cc40:	02c12403          	lw	s0,44(sp)
c001cc44:	03010113          	addi	sp,sp,48
c001cc48:	00008067          	ret

c001cc4c <XGpio_DiscreteSet>:
* This API can only be used if the GPIO_IO ports in the IP are used for
* connecting to the external output ports.
*
*****************************************************************************/
void XGpio_DiscreteSet(XGpio * InstancePtr, unsigned Channel, u32 Mask)
{
c001cc4c:	fd010113          	addi	sp,sp,-48
c001cc50:	02112623          	sw	ra,44(sp)
c001cc54:	02812423          	sw	s0,40(sp)
c001cc58:	03010413          	addi	s0,sp,48
c001cc5c:	fca42e23          	sw	a0,-36(s0)
c001cc60:	fcb42c23          	sw	a1,-40(s0)
c001cc64:	fcc42a23          	sw	a2,-44(s0)
	u32 Current;
	unsigned DataOffset;

	Xil_AssertVoid(InstancePtr != NULL);
c001cc68:	fdc42783          	lw	a5,-36(s0)
c001cc6c:	02078463          	beqz	a5,c001cc94 <XGpio_DiscreteSet+0x48>
c001cc70:	07fe6797          	auipc	a5,0x7fe6
c001cc74:	ca478793          	addi	a5,a5,-860 # c8002914 <Xil_AssertStatus>
c001cc78:	0007a023          	sw	zero,0(a5)
	Xil_AssertVoid(InstancePtr->IsReady == XIL_COMPONENT_IS_READY);
c001cc7c:	fdc42783          	lw	a5,-36(s0)
c001cc80:	0047a703          	lw	a4,4(a5)
c001cc84:	111117b7          	lui	a5,0x11111
c001cc88:	11178793          	addi	a5,a5,273 # 11111111 <_DMEM_LENGTH+0x10911111>
c001cc8c:	04f71463          	bne	a4,a5,c001ccd4 <XGpio_DiscreteSet+0x88>
c001cc90:	0280006f          	j	c001ccb8 <XGpio_DiscreteSet+0x6c>
	Xil_AssertVoid(InstancePtr != NULL);
c001cc94:	06400593          	li	a1,100
c001cc98:	07fe5517          	auipc	a0,0x7fe5
c001cc9c:	d3450513          	addi	a0,a0,-716 # c80019cc <__rodata_start+0x19cc>
c001cca0:	61d000ef          	jal	ra,c001dabc <Xil_Assert>
c001cca4:	07fe6797          	auipc	a5,0x7fe6
c001cca8:	c7078793          	addi	a5,a5,-912 # c8002914 <Xil_AssertStatus>
c001ccac:	00100713          	li	a4,1
c001ccb0:	00e7a023          	sw	a4,0(a5)
c001ccb4:	0ec0006f          	j	c001cda0 <XGpio_DiscreteSet+0x154>
	Xil_AssertVoid(InstancePtr->IsReady == XIL_COMPONENT_IS_READY);
c001ccb8:	07fe6797          	auipc	a5,0x7fe6
c001ccbc:	c5c78793          	addi	a5,a5,-932 # c8002914 <Xil_AssertStatus>
c001ccc0:	0007a023          	sw	zero,0(a5)
	Xil_AssertVoid((Channel == 1) ||
c001ccc4:	fd842703          	lw	a4,-40(s0)
c001ccc8:	00100793          	li	a5,1
c001cccc:	04f70463          	beq	a4,a5,c001cd14 <XGpio_DiscreteSet+0xc8>
c001ccd0:	0280006f          	j	c001ccf8 <XGpio_DiscreteSet+0xac>
	Xil_AssertVoid(InstancePtr->IsReady == XIL_COMPONENT_IS_READY);
c001ccd4:	06500593          	li	a1,101
c001ccd8:	07fe5517          	auipc	a0,0x7fe5
c001ccdc:	cf450513          	addi	a0,a0,-780 # c80019cc <__rodata_start+0x19cc>
c001cce0:	5dd000ef          	jal	ra,c001dabc <Xil_Assert>
c001cce4:	07fe6797          	auipc	a5,0x7fe6
c001cce8:	c3078793          	addi	a5,a5,-976 # c8002914 <Xil_AssertStatus>
c001ccec:	00100713          	li	a4,1
c001ccf0:	00e7a023          	sw	a4,0(a5)
c001ccf4:	0ac0006f          	j	c001cda0 <XGpio_DiscreteSet+0x154>
	Xil_AssertVoid((Channel == 1) ||
c001ccf8:	fd842703          	lw	a4,-40(s0)
c001ccfc:	00200793          	li	a5,2
c001cd00:	06f71e63          	bne	a4,a5,c001cd7c <XGpio_DiscreteSet+0x130>
c001cd04:	fdc42783          	lw	a5,-36(s0)
c001cd08:	00c7a703          	lw	a4,12(a5)
c001cd0c:	00100793          	li	a5,1
c001cd10:	06f71663          	bne	a4,a5,c001cd7c <XGpio_DiscreteSet+0x130>
c001cd14:	07fe6797          	auipc	a5,0x7fe6
c001cd18:	c0078793          	addi	a5,a5,-1024 # c8002914 <Xil_AssertStatus>
c001cd1c:	0007a023          	sw	zero,0(a5)
		     ((Channel == 2) && (InstancePtr->IsDual == TRUE)));

	/* Calculate the offset to the data register of the GPIO  */
	DataOffset = ((Channel - 1) * XGPIO_CHAN_OFFSET) + XGPIO_DATA_OFFSET;
c001cd20:	fd842783          	lw	a5,-40(s0)
c001cd24:	fff78793          	addi	a5,a5,-1
c001cd28:	00379793          	slli	a5,a5,0x3
c001cd2c:	fef42623          	sw	a5,-20(s0)

	/*
	 * Read the contents of the data register, merge in Mask and write
	 * back results
	 */
	Current = XGpio_ReadReg(InstancePtr->BaseAddress, DataOffset);
c001cd30:	fdc42783          	lw	a5,-36(s0)
c001cd34:	0007a703          	lw	a4,0(a5)
c001cd38:	fec42783          	lw	a5,-20(s0)
c001cd3c:	00f707b3          	add	a5,a4,a5
c001cd40:	00078513          	mv	a0,a5
c001cd44:	ea9ff0ef          	jal	ra,c001cbec <Xil_In32>
c001cd48:	fea42423          	sw	a0,-24(s0)
	Current |= Mask;
c001cd4c:	fe842703          	lw	a4,-24(s0)
c001cd50:	fd442783          	lw	a5,-44(s0)
c001cd54:	00f767b3          	or	a5,a4,a5
c001cd58:	fef42423          	sw	a5,-24(s0)
	XGpio_WriteReg(InstancePtr->BaseAddress, DataOffset, Current);
c001cd5c:	fdc42783          	lw	a5,-36(s0)
c001cd60:	0007a703          	lw	a4,0(a5)
c001cd64:	fec42783          	lw	a5,-20(s0)
c001cd68:	00f707b3          	add	a5,a4,a5
c001cd6c:	fe842583          	lw	a1,-24(s0)
c001cd70:	00078513          	mv	a0,a5
c001cd74:	ea1ff0ef          	jal	ra,c001cc14 <Xil_Out32>
c001cd78:	0280006f          	j	c001cda0 <XGpio_DiscreteSet+0x154>
	Xil_AssertVoid((Channel == 1) ||
c001cd7c:	06600593          	li	a1,102
c001cd80:	07fe5517          	auipc	a0,0x7fe5
c001cd84:	c4c50513          	addi	a0,a0,-948 # c80019cc <__rodata_start+0x19cc>
c001cd88:	535000ef          	jal	ra,c001dabc <Xil_Assert>
c001cd8c:	07fe6797          	auipc	a5,0x7fe6
c001cd90:	b8878793          	addi	a5,a5,-1144 # c8002914 <Xil_AssertStatus>
c001cd94:	00100713          	li	a4,1
c001cd98:	00e7a023          	sw	a4,0(a5)
c001cd9c:	00000013          	nop
}
c001cda0:	02c12083          	lw	ra,44(sp)
c001cda4:	02812403          	lw	s0,40(sp)
c001cda8:	03010113          	addi	sp,sp,48
c001cdac:	00008067          	ret

c001cdb0 <XGpio_DiscreteClear>:
* This API can only be used if the GPIO_IO ports in the IP are used for
* connecting to the external output ports.
*
*****************************************************************************/
void XGpio_DiscreteClear(XGpio * InstancePtr, unsigned Channel, u32 Mask)
{
c001cdb0:	fd010113          	addi	sp,sp,-48
c001cdb4:	02112623          	sw	ra,44(sp)
c001cdb8:	02812423          	sw	s0,40(sp)
c001cdbc:	03010413          	addi	s0,sp,48
c001cdc0:	fca42e23          	sw	a0,-36(s0)
c001cdc4:	fcb42c23          	sw	a1,-40(s0)
c001cdc8:	fcc42a23          	sw	a2,-44(s0)
	u32 Current;
	unsigned DataOffset;

	Xil_AssertVoid(InstancePtr != NULL);
c001cdcc:	fdc42783          	lw	a5,-36(s0)
c001cdd0:	02078463          	beqz	a5,c001cdf8 <XGpio_DiscreteClear+0x48>
c001cdd4:	07fe6797          	auipc	a5,0x7fe6
c001cdd8:	b4078793          	addi	a5,a5,-1216 # c8002914 <Xil_AssertStatus>
c001cddc:	0007a023          	sw	zero,0(a5)
	Xil_AssertVoid(InstancePtr->IsReady == XIL_COMPONENT_IS_READY);
c001cde0:	fdc42783          	lw	a5,-36(s0)
c001cde4:	0047a703          	lw	a4,4(a5)
c001cde8:	111117b7          	lui	a5,0x11111
c001cdec:	11178793          	addi	a5,a5,273 # 11111111 <_DMEM_LENGTH+0x10911111>
c001cdf0:	04f71463          	bne	a4,a5,c001ce38 <XGpio_DiscreteClear+0x88>
c001cdf4:	0280006f          	j	c001ce1c <XGpio_DiscreteClear+0x6c>
	Xil_AssertVoid(InstancePtr != NULL);
c001cdf8:	09000593          	li	a1,144
c001cdfc:	07fe5517          	auipc	a0,0x7fe5
c001ce00:	bd050513          	addi	a0,a0,-1072 # c80019cc <__rodata_start+0x19cc>
c001ce04:	4b9000ef          	jal	ra,c001dabc <Xil_Assert>
c001ce08:	07fe6797          	auipc	a5,0x7fe6
c001ce0c:	b0c78793          	addi	a5,a5,-1268 # c8002914 <Xil_AssertStatus>
c001ce10:	00100713          	li	a4,1
c001ce14:	00e7a023          	sw	a4,0(a5)
c001ce18:	0f00006f          	j	c001cf08 <XGpio_DiscreteClear+0x158>
	Xil_AssertVoid(InstancePtr->IsReady == XIL_COMPONENT_IS_READY);
c001ce1c:	07fe6797          	auipc	a5,0x7fe6
c001ce20:	af878793          	addi	a5,a5,-1288 # c8002914 <Xil_AssertStatus>
c001ce24:	0007a023          	sw	zero,0(a5)
	Xil_AssertVoid((Channel == 1) ||
c001ce28:	fd842703          	lw	a4,-40(s0)
c001ce2c:	00100793          	li	a5,1
c001ce30:	04f70463          	beq	a4,a5,c001ce78 <XGpio_DiscreteClear+0xc8>
c001ce34:	0280006f          	j	c001ce5c <XGpio_DiscreteClear+0xac>
	Xil_AssertVoid(InstancePtr->IsReady == XIL_COMPONENT_IS_READY);
c001ce38:	09100593          	li	a1,145
c001ce3c:	07fe5517          	auipc	a0,0x7fe5
c001ce40:	b9050513          	addi	a0,a0,-1136 # c80019cc <__rodata_start+0x19cc>
c001ce44:	479000ef          	jal	ra,c001dabc <Xil_Assert>
c001ce48:	07fe6797          	auipc	a5,0x7fe6
c001ce4c:	acc78793          	addi	a5,a5,-1332 # c8002914 <Xil_AssertStatus>
c001ce50:	00100713          	li	a4,1
c001ce54:	00e7a023          	sw	a4,0(a5)
c001ce58:	0b00006f          	j	c001cf08 <XGpio_DiscreteClear+0x158>
	Xil_AssertVoid((Channel == 1) ||
c001ce5c:	fd842703          	lw	a4,-40(s0)
c001ce60:	00200793          	li	a5,2
c001ce64:	08f71063          	bne	a4,a5,c001cee4 <XGpio_DiscreteClear+0x134>
c001ce68:	fdc42783          	lw	a5,-36(s0)
c001ce6c:	00c7a703          	lw	a4,12(a5)
c001ce70:	00100793          	li	a5,1
c001ce74:	06f71863          	bne	a4,a5,c001cee4 <XGpio_DiscreteClear+0x134>
c001ce78:	07fe6797          	auipc	a5,0x7fe6
c001ce7c:	a9c78793          	addi	a5,a5,-1380 # c8002914 <Xil_AssertStatus>
c001ce80:	0007a023          	sw	zero,0(a5)
		     ((Channel == 2) && (InstancePtr->IsDual == TRUE)));

	/* Calculate the offset to the data register of the GPIO  */
	DataOffset = ((Channel - 1) * XGPIO_CHAN_OFFSET) + XGPIO_DATA_OFFSET;
c001ce84:	fd842783          	lw	a5,-40(s0)
c001ce88:	fff78793          	addi	a5,a5,-1
c001ce8c:	00379793          	slli	a5,a5,0x3
c001ce90:	fef42623          	sw	a5,-20(s0)

	/*
	 * Read the contents of the data register, merge in Mask and write
	 * back results
	 */
	Current = XGpio_ReadReg(InstancePtr->BaseAddress, DataOffset);
c001ce94:	fdc42783          	lw	a5,-36(s0)
c001ce98:	0007a703          	lw	a4,0(a5)
c001ce9c:	fec42783          	lw	a5,-20(s0)
c001cea0:	00f707b3          	add	a5,a4,a5
c001cea4:	00078513          	mv	a0,a5
c001cea8:	d45ff0ef          	jal	ra,c001cbec <Xil_In32>
c001ceac:	fea42423          	sw	a0,-24(s0)
	Current &= ~Mask;
c001ceb0:	fd442783          	lw	a5,-44(s0)
c001ceb4:	fff7c793          	not	a5,a5
c001ceb8:	fe842703          	lw	a4,-24(s0)
c001cebc:	00f777b3          	and	a5,a4,a5
c001cec0:	fef42423          	sw	a5,-24(s0)
	XGpio_WriteReg(InstancePtr->BaseAddress, DataOffset, Current);
c001cec4:	fdc42783          	lw	a5,-36(s0)
c001cec8:	0007a703          	lw	a4,0(a5)
c001cecc:	fec42783          	lw	a5,-20(s0)
c001ced0:	00f707b3          	add	a5,a4,a5
c001ced4:	fe842583          	lw	a1,-24(s0)
c001ced8:	00078513          	mv	a0,a5
c001cedc:	d39ff0ef          	jal	ra,c001cc14 <Xil_Out32>
c001cee0:	0280006f          	j	c001cf08 <XGpio_DiscreteClear+0x158>
	Xil_AssertVoid((Channel == 1) ||
c001cee4:	09200593          	li	a1,146
c001cee8:	07fe5517          	auipc	a0,0x7fe5
c001ceec:	ae450513          	addi	a0,a0,-1308 # c80019cc <__rodata_start+0x19cc>
c001cef0:	3cd000ef          	jal	ra,c001dabc <Xil_Assert>
c001cef4:	07fe6797          	auipc	a5,0x7fe6
c001cef8:	a2078793          	addi	a5,a5,-1504 # c8002914 <Xil_AssertStatus>
c001cefc:	00100713          	li	a4,1
c001cf00:	00e7a023          	sw	a4,0(a5)
c001cf04:	00000013          	nop
}
c001cf08:	02c12083          	lw	ra,44(sp)
c001cf0c:	02812403          	lw	s0,40(sp)
c001cf10:	03010113          	addi	sp,sp,48
c001cf14:	00008067          	ret

c001cf18 <Xil_In32>:
{
c001cf18:	fe010113          	addi	sp,sp,-32
c001cf1c:	00812e23          	sw	s0,28(sp)
c001cf20:	02010413          	addi	s0,sp,32
c001cf24:	fea42623          	sw	a0,-20(s0)
	return *(volatile u32 *) Addr;
c001cf28:	fec42783          	lw	a5,-20(s0)
c001cf2c:	0007a783          	lw	a5,0(a5)
}
c001cf30:	00078513          	mv	a0,a5
c001cf34:	01c12403          	lw	s0,28(sp)
c001cf38:	02010113          	addi	sp,sp,32
c001cf3c:	00008067          	ret

c001cf40 <Xil_Out32>:
{
c001cf40:	fd010113          	addi	sp,sp,-48
c001cf44:	02812623          	sw	s0,44(sp)
c001cf48:	03010413          	addi	s0,sp,48
c001cf4c:	fca42e23          	sw	a0,-36(s0)
c001cf50:	fcb42c23          	sw	a1,-40(s0)
	volatile u32 *LocalAddr = (volatile u32 *)Addr;
c001cf54:	fdc42783          	lw	a5,-36(s0)
c001cf58:	fef42623          	sw	a5,-20(s0)
	*LocalAddr = Value;
c001cf5c:	fec42783          	lw	a5,-20(s0)
c001cf60:	fd842703          	lw	a4,-40(s0)
c001cf64:	00e7a023          	sw	a4,0(a5)
}
c001cf68:	00000013          	nop
c001cf6c:	02c12403          	lw	s0,44(sp)
c001cf70:	03010113          	addi	sp,sp,48
c001cf74:	00008067          	ret

c001cf78 <XGpio_InterruptGlobalEnable>:
*
* @note		None.
*
*****************************************************************************/
void XGpio_InterruptGlobalEnable(XGpio *InstancePtr)
{
c001cf78:	fe010113          	addi	sp,sp,-32
c001cf7c:	00112e23          	sw	ra,28(sp)
c001cf80:	00812c23          	sw	s0,24(sp)
c001cf84:	02010413          	addi	s0,sp,32
c001cf88:	fea42623          	sw	a0,-20(s0)
	Xil_AssertVoid(InstancePtr != NULL);
c001cf8c:	fec42783          	lw	a5,-20(s0)
c001cf90:	02078463          	beqz	a5,c001cfb8 <XGpio_InterruptGlobalEnable+0x40>
c001cf94:	07fe6797          	auipc	a5,0x7fe6
c001cf98:	98078793          	addi	a5,a5,-1664 # c8002914 <Xil_AssertStatus>
c001cf9c:	0007a023          	sw	zero,0(a5)
	Xil_AssertVoid(InstancePtr->IsReady == XIL_COMPONENT_IS_READY);
c001cfa0:	fec42783          	lw	a5,-20(s0)
c001cfa4:	0047a703          	lw	a4,4(a5)
c001cfa8:	111117b7          	lui	a5,0x11111
c001cfac:	11178793          	addi	a5,a5,273 # 11111111 <_DMEM_LENGTH+0x10911111>
c001cfb0:	04f71663          	bne	a4,a5,c001cffc <XGpio_InterruptGlobalEnable+0x84>
c001cfb4:	0280006f          	j	c001cfdc <XGpio_InterruptGlobalEnable+0x64>
	Xil_AssertVoid(InstancePtr != NULL);
c001cfb8:	05b00593          	li	a1,91
c001cfbc:	07fe5517          	auipc	a0,0x7fe5
c001cfc0:	a3050513          	addi	a0,a0,-1488 # c80019ec <__rodata_start+0x19ec>
c001cfc4:	2f9000ef          	jal	ra,c001dabc <Xil_Assert>
c001cfc8:	07fe6797          	auipc	a5,0x7fe6
c001cfcc:	94c78793          	addi	a5,a5,-1716 # c8002914 <Xil_AssertStatus>
c001cfd0:	00100713          	li	a4,1
c001cfd4:	00e7a023          	sw	a4,0(a5)
c001cfd8:	0940006f          	j	c001d06c <XGpio_InterruptGlobalEnable+0xf4>
	Xil_AssertVoid(InstancePtr->IsReady == XIL_COMPONENT_IS_READY);
c001cfdc:	07fe6797          	auipc	a5,0x7fe6
c001cfe0:	93878793          	addi	a5,a5,-1736 # c8002914 <Xil_AssertStatus>
c001cfe4:	0007a023          	sw	zero,0(a5)
	Xil_AssertVoid(InstancePtr->InterruptPresent == TRUE);
c001cfe8:	fec42783          	lw	a5,-20(s0)
c001cfec:	0087a703          	lw	a4,8(a5)
c001cff0:	00100793          	li	a5,1
c001cff4:	04f71a63          	bne	a4,a5,c001d048 <XGpio_InterruptGlobalEnable+0xd0>
c001cff8:	0280006f          	j	c001d020 <XGpio_InterruptGlobalEnable+0xa8>
	Xil_AssertVoid(InstancePtr->IsReady == XIL_COMPONENT_IS_READY);
c001cffc:	05c00593          	li	a1,92
c001d000:	07fe5517          	auipc	a0,0x7fe5
c001d004:	9ec50513          	addi	a0,a0,-1556 # c80019ec <__rodata_start+0x19ec>
c001d008:	2b5000ef          	jal	ra,c001dabc <Xil_Assert>
c001d00c:	07fe6797          	auipc	a5,0x7fe6
c001d010:	90878793          	addi	a5,a5,-1784 # c8002914 <Xil_AssertStatus>
c001d014:	00100713          	li	a4,1
c001d018:	00e7a023          	sw	a4,0(a5)
c001d01c:	0500006f          	j	c001d06c <XGpio_InterruptGlobalEnable+0xf4>
	Xil_AssertVoid(InstancePtr->InterruptPresent == TRUE);
c001d020:	07fe6797          	auipc	a5,0x7fe6
c001d024:	8f478793          	addi	a5,a5,-1804 # c8002914 <Xil_AssertStatus>
c001d028:	0007a023          	sw	zero,0(a5)

	XGpio_WriteReg(InstancePtr->BaseAddress, XGPIO_GIE_OFFSET,
c001d02c:	fec42783          	lw	a5,-20(s0)
c001d030:	0007a783          	lw	a5,0(a5)
c001d034:	11c78793          	addi	a5,a5,284
c001d038:	800005b7          	lui	a1,0x80000
c001d03c:	00078513          	mv	a0,a5
c001d040:	f01ff0ef          	jal	ra,c001cf40 <Xil_Out32>
c001d044:	0280006f          	j	c001d06c <XGpio_InterruptGlobalEnable+0xf4>
	Xil_AssertVoid(InstancePtr->InterruptPresent == TRUE);
c001d048:	05d00593          	li	a1,93
c001d04c:	07fe5517          	auipc	a0,0x7fe5
c001d050:	9a050513          	addi	a0,a0,-1632 # c80019ec <__rodata_start+0x19ec>
c001d054:	269000ef          	jal	ra,c001dabc <Xil_Assert>
c001d058:	07fe6797          	auipc	a5,0x7fe6
c001d05c:	8bc78793          	addi	a5,a5,-1860 # c8002914 <Xil_AssertStatus>
c001d060:	00100713          	li	a4,1
c001d064:	00e7a023          	sw	a4,0(a5)
c001d068:	00000013          	nop
			XGPIO_GIE_GINTR_ENABLE_MASK);
}
c001d06c:	01c12083          	lw	ra,28(sp)
c001d070:	01812403          	lw	s0,24(sp)
c001d074:	02010113          	addi	sp,sp,32
c001d078:	00008067          	ret

c001d07c <XGpio_InterruptGlobalDisable>:
*
* @note		None.
*
*****************************************************************************/
void XGpio_InterruptGlobalDisable(XGpio *InstancePtr)
{
c001d07c:	fe010113          	addi	sp,sp,-32
c001d080:	00112e23          	sw	ra,28(sp)
c001d084:	00812c23          	sw	s0,24(sp)
c001d088:	02010413          	addi	s0,sp,32
c001d08c:	fea42623          	sw	a0,-20(s0)
	Xil_AssertVoid(InstancePtr != NULL);
c001d090:	fec42783          	lw	a5,-20(s0)
c001d094:	02078463          	beqz	a5,c001d0bc <XGpio_InterruptGlobalDisable+0x40>
c001d098:	07fe6797          	auipc	a5,0x7fe6
c001d09c:	87c78793          	addi	a5,a5,-1924 # c8002914 <Xil_AssertStatus>
c001d0a0:	0007a023          	sw	zero,0(a5)
	Xil_AssertVoid(InstancePtr->IsReady == XIL_COMPONENT_IS_READY);
c001d0a4:	fec42783          	lw	a5,-20(s0)
c001d0a8:	0047a703          	lw	a4,4(a5)
c001d0ac:	111117b7          	lui	a5,0x11111
c001d0b0:	11178793          	addi	a5,a5,273 # 11111111 <_DMEM_LENGTH+0x10911111>
c001d0b4:	04f71663          	bne	a4,a5,c001d100 <XGpio_InterruptGlobalDisable+0x84>
c001d0b8:	0280006f          	j	c001d0e0 <XGpio_InterruptGlobalDisable+0x64>
	Xil_AssertVoid(InstancePtr != NULL);
c001d0bc:	07600593          	li	a1,118
c001d0c0:	07fe5517          	auipc	a0,0x7fe5
c001d0c4:	92c50513          	addi	a0,a0,-1748 # c80019ec <__rodata_start+0x19ec>
c001d0c8:	1f5000ef          	jal	ra,c001dabc <Xil_Assert>
c001d0cc:	07fe6797          	auipc	a5,0x7fe6
c001d0d0:	84878793          	addi	a5,a5,-1976 # c8002914 <Xil_AssertStatus>
c001d0d4:	00100713          	li	a4,1
c001d0d8:	00e7a023          	sw	a4,0(a5)
c001d0dc:	0940006f          	j	c001d170 <XGpio_InterruptGlobalDisable+0xf4>
	Xil_AssertVoid(InstancePtr->IsReady == XIL_COMPONENT_IS_READY);
c001d0e0:	07fe6797          	auipc	a5,0x7fe6
c001d0e4:	83478793          	addi	a5,a5,-1996 # c8002914 <Xil_AssertStatus>
c001d0e8:	0007a023          	sw	zero,0(a5)
	Xil_AssertVoid(InstancePtr->InterruptPresent == TRUE);
c001d0ec:	fec42783          	lw	a5,-20(s0)
c001d0f0:	0087a703          	lw	a4,8(a5)
c001d0f4:	00100793          	li	a5,1
c001d0f8:	04f71a63          	bne	a4,a5,c001d14c <XGpio_InterruptGlobalDisable+0xd0>
c001d0fc:	0280006f          	j	c001d124 <XGpio_InterruptGlobalDisable+0xa8>
	Xil_AssertVoid(InstancePtr->IsReady == XIL_COMPONENT_IS_READY);
c001d100:	07700593          	li	a1,119
c001d104:	07fe5517          	auipc	a0,0x7fe5
c001d108:	8e850513          	addi	a0,a0,-1816 # c80019ec <__rodata_start+0x19ec>
c001d10c:	1b1000ef          	jal	ra,c001dabc <Xil_Assert>
c001d110:	07fe6797          	auipc	a5,0x7fe6
c001d114:	80478793          	addi	a5,a5,-2044 # c8002914 <Xil_AssertStatus>
c001d118:	00100713          	li	a4,1
c001d11c:	00e7a023          	sw	a4,0(a5)
c001d120:	0500006f          	j	c001d170 <XGpio_InterruptGlobalDisable+0xf4>
	Xil_AssertVoid(InstancePtr->InterruptPresent == TRUE);
c001d124:	07fe5797          	auipc	a5,0x7fe5
c001d128:	7f078793          	addi	a5,a5,2032 # c8002914 <Xil_AssertStatus>
c001d12c:	0007a023          	sw	zero,0(a5)


	XGpio_WriteReg(InstancePtr->BaseAddress, XGPIO_GIE_OFFSET, 0x0);
c001d130:	fec42783          	lw	a5,-20(s0)
c001d134:	0007a783          	lw	a5,0(a5)
c001d138:	11c78793          	addi	a5,a5,284
c001d13c:	00000593          	li	a1,0
c001d140:	00078513          	mv	a0,a5
c001d144:	dfdff0ef          	jal	ra,c001cf40 <Xil_Out32>
c001d148:	0280006f          	j	c001d170 <XGpio_InterruptGlobalDisable+0xf4>
	Xil_AssertVoid(InstancePtr->InterruptPresent == TRUE);
c001d14c:	07800593          	li	a1,120
c001d150:	07fe5517          	auipc	a0,0x7fe5
c001d154:	89c50513          	addi	a0,a0,-1892 # c80019ec <__rodata_start+0x19ec>
c001d158:	165000ef          	jal	ra,c001dabc <Xil_Assert>
c001d15c:	07fe5797          	auipc	a5,0x7fe5
c001d160:	7b878793          	addi	a5,a5,1976 # c8002914 <Xil_AssertStatus>
c001d164:	00100713          	li	a4,1
c001d168:	00e7a023          	sw	a4,0(a5)
c001d16c:	00000013          	nop

}
c001d170:	01c12083          	lw	ra,28(sp)
c001d174:	01812403          	lw	s0,24(sp)
c001d178:	02010113          	addi	sp,sp,32
c001d17c:	00008067          	ret

c001d180 <XGpio_InterruptEnable>:
*
* @note		None.
*
*****************************************************************************/
void XGpio_InterruptEnable(XGpio *InstancePtr, u32 Mask)
{
c001d180:	fd010113          	addi	sp,sp,-48
c001d184:	02112623          	sw	ra,44(sp)
c001d188:	02812423          	sw	s0,40(sp)
c001d18c:	03010413          	addi	s0,sp,48
c001d190:	fca42e23          	sw	a0,-36(s0)
c001d194:	fcb42c23          	sw	a1,-40(s0)
	u32 Register;

	Xil_AssertVoid(InstancePtr != NULL);
c001d198:	fdc42783          	lw	a5,-36(s0)
c001d19c:	02078463          	beqz	a5,c001d1c4 <XGpio_InterruptEnable+0x44>
c001d1a0:	07fe5797          	auipc	a5,0x7fe5
c001d1a4:	77478793          	addi	a5,a5,1908 # c8002914 <Xil_AssertStatus>
c001d1a8:	0007a023          	sw	zero,0(a5)
	Xil_AssertVoid(InstancePtr->IsReady == XIL_COMPONENT_IS_READY);
c001d1ac:	fdc42783          	lw	a5,-36(s0)
c001d1b0:	0047a703          	lw	a4,4(a5)
c001d1b4:	111117b7          	lui	a5,0x11111
c001d1b8:	11178793          	addi	a5,a5,273 # 11111111 <_DMEM_LENGTH+0x10911111>
c001d1bc:	04f71663          	bne	a4,a5,c001d208 <XGpio_InterruptEnable+0x88>
c001d1c0:	0280006f          	j	c001d1e8 <XGpio_InterruptEnable+0x68>
	Xil_AssertVoid(InstancePtr != NULL);
c001d1c4:	09400593          	li	a1,148
c001d1c8:	07fe5517          	auipc	a0,0x7fe5
c001d1cc:	82450513          	addi	a0,a0,-2012 # c80019ec <__rodata_start+0x19ec>
c001d1d0:	0ed000ef          	jal	ra,c001dabc <Xil_Assert>
c001d1d4:	07fe5797          	auipc	a5,0x7fe5
c001d1d8:	74078793          	addi	a5,a5,1856 # c8002914 <Xil_AssertStatus>
c001d1dc:	00100713          	li	a4,1
c001d1e0:	00e7a023          	sw	a4,0(a5)
c001d1e4:	0b80006f          	j	c001d29c <XGpio_InterruptEnable+0x11c>
	Xil_AssertVoid(InstancePtr->IsReady == XIL_COMPONENT_IS_READY);
c001d1e8:	07fe5797          	auipc	a5,0x7fe5
c001d1ec:	72c78793          	addi	a5,a5,1836 # c8002914 <Xil_AssertStatus>
c001d1f0:	0007a023          	sw	zero,0(a5)
	Xil_AssertVoid(InstancePtr->InterruptPresent == TRUE);
c001d1f4:	fdc42783          	lw	a5,-36(s0)
c001d1f8:	0087a703          	lw	a4,8(a5)
c001d1fc:	00100793          	li	a5,1
c001d200:	06f71c63          	bne	a4,a5,c001d278 <XGpio_InterruptEnable+0xf8>
c001d204:	0280006f          	j	c001d22c <XGpio_InterruptEnable+0xac>
	Xil_AssertVoid(InstancePtr->IsReady == XIL_COMPONENT_IS_READY);
c001d208:	09500593          	li	a1,149
c001d20c:	07fe4517          	auipc	a0,0x7fe4
c001d210:	7e050513          	addi	a0,a0,2016 # c80019ec <__rodata_start+0x19ec>
c001d214:	0a9000ef          	jal	ra,c001dabc <Xil_Assert>
c001d218:	07fe5797          	auipc	a5,0x7fe5
c001d21c:	6fc78793          	addi	a5,a5,1788 # c8002914 <Xil_AssertStatus>
c001d220:	00100713          	li	a4,1
c001d224:	00e7a023          	sw	a4,0(a5)
c001d228:	0740006f          	j	c001d29c <XGpio_InterruptEnable+0x11c>
	Xil_AssertVoid(InstancePtr->InterruptPresent == TRUE);
c001d22c:	07fe5797          	auipc	a5,0x7fe5
c001d230:	6e878793          	addi	a5,a5,1768 # c8002914 <Xil_AssertStatus>
c001d234:	0007a023          	sw	zero,0(a5)
	/*
	 * Read the interrupt enable register and only enable the specified
	 * interrupts without disabling or enabling any others.
	 */

	Register = XGpio_ReadReg(InstancePtr->BaseAddress, XGPIO_IER_OFFSET);
c001d238:	fdc42783          	lw	a5,-36(s0)
c001d23c:	0007a783          	lw	a5,0(a5)
c001d240:	12878793          	addi	a5,a5,296
c001d244:	00078513          	mv	a0,a5
c001d248:	cd1ff0ef          	jal	ra,c001cf18 <Xil_In32>
c001d24c:	fea42623          	sw	a0,-20(s0)
	XGpio_WriteReg(InstancePtr->BaseAddress, XGPIO_IER_OFFSET,
c001d250:	fdc42783          	lw	a5,-36(s0)
c001d254:	0007a783          	lw	a5,0(a5)
c001d258:	12878693          	addi	a3,a5,296
c001d25c:	fec42703          	lw	a4,-20(s0)
c001d260:	fd842783          	lw	a5,-40(s0)
c001d264:	00f767b3          	or	a5,a4,a5
c001d268:	00078593          	mv	a1,a5
c001d26c:	00068513          	mv	a0,a3
c001d270:	cd1ff0ef          	jal	ra,c001cf40 <Xil_Out32>
c001d274:	0280006f          	j	c001d29c <XGpio_InterruptEnable+0x11c>
	Xil_AssertVoid(InstancePtr->InterruptPresent == TRUE);
c001d278:	09600593          	li	a1,150
c001d27c:	07fe4517          	auipc	a0,0x7fe4
c001d280:	77050513          	addi	a0,a0,1904 # c80019ec <__rodata_start+0x19ec>
c001d284:	039000ef          	jal	ra,c001dabc <Xil_Assert>
c001d288:	07fe5797          	auipc	a5,0x7fe5
c001d28c:	68c78793          	addi	a5,a5,1676 # c8002914 <Xil_AssertStatus>
c001d290:	00100713          	li	a4,1
c001d294:	00e7a023          	sw	a4,0(a5)
c001d298:	00000013          	nop
			Register | Mask);

}
c001d29c:	02c12083          	lw	ra,44(sp)
c001d2a0:	02812403          	lw	s0,40(sp)
c001d2a4:	03010113          	addi	sp,sp,48
c001d2a8:	00008067          	ret

c001d2ac <XGpio_InterruptDisable>:
*
* @note		None.
*
*****************************************************************************/
void XGpio_InterruptDisable(XGpio *InstancePtr, u32 Mask)
{
c001d2ac:	fd010113          	addi	sp,sp,-48
c001d2b0:	02112623          	sw	ra,44(sp)
c001d2b4:	02812423          	sw	s0,40(sp)
c001d2b8:	03010413          	addi	s0,sp,48
c001d2bc:	fca42e23          	sw	a0,-36(s0)
c001d2c0:	fcb42c23          	sw	a1,-40(s0)
	u32 Register;

	Xil_AssertVoid(InstancePtr != NULL);
c001d2c4:	fdc42783          	lw	a5,-36(s0)
c001d2c8:	02078463          	beqz	a5,c001d2f0 <XGpio_InterruptDisable+0x44>
c001d2cc:	07fe5797          	auipc	a5,0x7fe5
c001d2d0:	64878793          	addi	a5,a5,1608 # c8002914 <Xil_AssertStatus>
c001d2d4:	0007a023          	sw	zero,0(a5)
	Xil_AssertVoid(InstancePtr->IsReady == XIL_COMPONENT_IS_READY);
c001d2d8:	fdc42783          	lw	a5,-36(s0)
c001d2dc:	0047a703          	lw	a4,4(a5)
c001d2e0:	111117b7          	lui	a5,0x11111
c001d2e4:	11178793          	addi	a5,a5,273 # 11111111 <_DMEM_LENGTH+0x10911111>
c001d2e8:	04f71663          	bne	a4,a5,c001d334 <XGpio_InterruptDisable+0x88>
c001d2ec:	0280006f          	j	c001d314 <XGpio_InterruptDisable+0x68>
	Xil_AssertVoid(InstancePtr != NULL);
c001d2f0:	0b800593          	li	a1,184
c001d2f4:	07fe4517          	auipc	a0,0x7fe4
c001d2f8:	6f850513          	addi	a0,a0,1784 # c80019ec <__rodata_start+0x19ec>
c001d2fc:	7c0000ef          	jal	ra,c001dabc <Xil_Assert>
c001d300:	07fe5797          	auipc	a5,0x7fe5
c001d304:	61478793          	addi	a5,a5,1556 # c8002914 <Xil_AssertStatus>
c001d308:	00100713          	li	a4,1
c001d30c:	00e7a023          	sw	a4,0(a5)
c001d310:	0bc0006f          	j	c001d3cc <XGpio_InterruptDisable+0x120>
	Xil_AssertVoid(InstancePtr->IsReady == XIL_COMPONENT_IS_READY);
c001d314:	07fe5797          	auipc	a5,0x7fe5
c001d318:	60078793          	addi	a5,a5,1536 # c8002914 <Xil_AssertStatus>
c001d31c:	0007a023          	sw	zero,0(a5)
	Xil_AssertVoid(InstancePtr->InterruptPresent == TRUE);
c001d320:	fdc42783          	lw	a5,-36(s0)
c001d324:	0087a703          	lw	a4,8(a5)
c001d328:	00100793          	li	a5,1
c001d32c:	06f71e63          	bne	a4,a5,c001d3a8 <XGpio_InterruptDisable+0xfc>
c001d330:	0280006f          	j	c001d358 <XGpio_InterruptDisable+0xac>
	Xil_AssertVoid(InstancePtr->IsReady == XIL_COMPONENT_IS_READY);
c001d334:	0b900593          	li	a1,185
c001d338:	07fe4517          	auipc	a0,0x7fe4
c001d33c:	6b450513          	addi	a0,a0,1716 # c80019ec <__rodata_start+0x19ec>
c001d340:	77c000ef          	jal	ra,c001dabc <Xil_Assert>
c001d344:	07fe5797          	auipc	a5,0x7fe5
c001d348:	5d078793          	addi	a5,a5,1488 # c8002914 <Xil_AssertStatus>
c001d34c:	00100713          	li	a4,1
c001d350:	00e7a023          	sw	a4,0(a5)
c001d354:	0780006f          	j	c001d3cc <XGpio_InterruptDisable+0x120>
	Xil_AssertVoid(InstancePtr->InterruptPresent == TRUE);
c001d358:	07fe5797          	auipc	a5,0x7fe5
c001d35c:	5bc78793          	addi	a5,a5,1468 # c8002914 <Xil_AssertStatus>
c001d360:	0007a023          	sw	zero,0(a5)

	/*
	 * Read the interrupt enable register and only disable the specified
	 * interrupts without enabling or disabling any others.
	 */
	Register = XGpio_ReadReg(InstancePtr->BaseAddress, XGPIO_IER_OFFSET);
c001d364:	fdc42783          	lw	a5,-36(s0)
c001d368:	0007a783          	lw	a5,0(a5)
c001d36c:	12878793          	addi	a5,a5,296
c001d370:	00078513          	mv	a0,a5
c001d374:	ba5ff0ef          	jal	ra,c001cf18 <Xil_In32>
c001d378:	fea42623          	sw	a0,-20(s0)
	XGpio_WriteReg(InstancePtr->BaseAddress, XGPIO_IER_OFFSET,
c001d37c:	fdc42783          	lw	a5,-36(s0)
c001d380:	0007a783          	lw	a5,0(a5)
c001d384:	12878693          	addi	a3,a5,296
c001d388:	fd842783          	lw	a5,-40(s0)
c001d38c:	fff7c713          	not	a4,a5
c001d390:	fec42783          	lw	a5,-20(s0)
c001d394:	00f777b3          	and	a5,a4,a5
c001d398:	00078593          	mv	a1,a5
c001d39c:	00068513          	mv	a0,a3
c001d3a0:	ba1ff0ef          	jal	ra,c001cf40 <Xil_Out32>
c001d3a4:	0280006f          	j	c001d3cc <XGpio_InterruptDisable+0x120>
	Xil_AssertVoid(InstancePtr->InterruptPresent == TRUE);
c001d3a8:	0ba00593          	li	a1,186
c001d3ac:	07fe4517          	auipc	a0,0x7fe4
c001d3b0:	64050513          	addi	a0,a0,1600 # c80019ec <__rodata_start+0x19ec>
c001d3b4:	708000ef          	jal	ra,c001dabc <Xil_Assert>
c001d3b8:	07fe5797          	auipc	a5,0x7fe5
c001d3bc:	55c78793          	addi	a5,a5,1372 # c8002914 <Xil_AssertStatus>
c001d3c0:	00100713          	li	a4,1
c001d3c4:	00e7a023          	sw	a4,0(a5)
c001d3c8:	00000013          	nop
			Register & (~Mask));

}
c001d3cc:	02c12083          	lw	ra,44(sp)
c001d3d0:	02812403          	lw	s0,40(sp)
c001d3d4:	03010113          	addi	sp,sp,48
c001d3d8:	00008067          	ret

c001d3dc <XGpio_InterruptClear>:
*
* @note		None.
*
*****************************************************************************/
void XGpio_InterruptClear(XGpio * InstancePtr, u32 Mask)
{
c001d3dc:	fd010113          	addi	sp,sp,-48
c001d3e0:	02112623          	sw	ra,44(sp)
c001d3e4:	02812423          	sw	s0,40(sp)
c001d3e8:	03010413          	addi	s0,sp,48
c001d3ec:	fca42e23          	sw	a0,-36(s0)
c001d3f0:	fcb42c23          	sw	a1,-40(s0)
	u32 Register;

	Xil_AssertVoid(InstancePtr != NULL);
c001d3f4:	fdc42783          	lw	a5,-36(s0)
c001d3f8:	02078463          	beqz	a5,c001d420 <XGpio_InterruptClear+0x44>
c001d3fc:	07fe5797          	auipc	a5,0x7fe5
c001d400:	51878793          	addi	a5,a5,1304 # c8002914 <Xil_AssertStatus>
c001d404:	0007a023          	sw	zero,0(a5)
	Xil_AssertVoid(InstancePtr->IsReady == XIL_COMPONENT_IS_READY);
c001d408:	fdc42783          	lw	a5,-36(s0)
c001d40c:	0047a703          	lw	a4,4(a5)
c001d410:	111117b7          	lui	a5,0x11111
c001d414:	11178793          	addi	a5,a5,273 # 11111111 <_DMEM_LENGTH+0x10911111>
c001d418:	04f71663          	bne	a4,a5,c001d464 <XGpio_InterruptClear+0x88>
c001d41c:	0280006f          	j	c001d444 <XGpio_InterruptClear+0x68>
	Xil_AssertVoid(InstancePtr != NULL);
c001d420:	0db00593          	li	a1,219
c001d424:	07fe4517          	auipc	a0,0x7fe4
c001d428:	5c850513          	addi	a0,a0,1480 # c80019ec <__rodata_start+0x19ec>
c001d42c:	690000ef          	jal	ra,c001dabc <Xil_Assert>
c001d430:	07fe5797          	auipc	a5,0x7fe5
c001d434:	4e478793          	addi	a5,a5,1252 # c8002914 <Xil_AssertStatus>
c001d438:	00100713          	li	a4,1
c001d43c:	00e7a023          	sw	a4,0(a5)
c001d440:	0b80006f          	j	c001d4f8 <XGpio_InterruptClear+0x11c>
	Xil_AssertVoid(InstancePtr->IsReady == XIL_COMPONENT_IS_READY);
c001d444:	07fe5797          	auipc	a5,0x7fe5
c001d448:	4d078793          	addi	a5,a5,1232 # c8002914 <Xil_AssertStatus>
c001d44c:	0007a023          	sw	zero,0(a5)
	Xil_AssertVoid(InstancePtr->InterruptPresent == TRUE);
c001d450:	fdc42783          	lw	a5,-36(s0)
c001d454:	0087a703          	lw	a4,8(a5)
c001d458:	00100793          	li	a5,1
c001d45c:	06f71c63          	bne	a4,a5,c001d4d4 <XGpio_InterruptClear+0xf8>
c001d460:	0280006f          	j	c001d488 <XGpio_InterruptClear+0xac>
	Xil_AssertVoid(InstancePtr->IsReady == XIL_COMPONENT_IS_READY);
c001d464:	0dc00593          	li	a1,220
c001d468:	07fe4517          	auipc	a0,0x7fe4
c001d46c:	58450513          	addi	a0,a0,1412 # c80019ec <__rodata_start+0x19ec>
c001d470:	64c000ef          	jal	ra,c001dabc <Xil_Assert>
c001d474:	07fe5797          	auipc	a5,0x7fe5
c001d478:	4a078793          	addi	a5,a5,1184 # c8002914 <Xil_AssertStatus>
c001d47c:	00100713          	li	a4,1
c001d480:	00e7a023          	sw	a4,0(a5)
c001d484:	0740006f          	j	c001d4f8 <XGpio_InterruptClear+0x11c>
	Xil_AssertVoid(InstancePtr->InterruptPresent == TRUE);
c001d488:	07fe5797          	auipc	a5,0x7fe5
c001d48c:	48c78793          	addi	a5,a5,1164 # c8002914 <Xil_AssertStatus>
c001d490:	0007a023          	sw	zero,0(a5)
	 * Read the interrupt status register and only clear the interrupts
	 * that are specified without affecting any others.  Since the register
	 * is a toggle on write, make sure any bits to be written are already
	 * set.
	 */
	Register = XGpio_ReadReg(InstancePtr->BaseAddress, XGPIO_ISR_OFFSET);
c001d494:	fdc42783          	lw	a5,-36(s0)
c001d498:	0007a783          	lw	a5,0(a5)
c001d49c:	12078793          	addi	a5,a5,288
c001d4a0:	00078513          	mv	a0,a5
c001d4a4:	a75ff0ef          	jal	ra,c001cf18 <Xil_In32>
c001d4a8:	fea42623          	sw	a0,-20(s0)
	XGpio_WriteReg(InstancePtr->BaseAddress, XGPIO_ISR_OFFSET,
c001d4ac:	fdc42783          	lw	a5,-36(s0)
c001d4b0:	0007a783          	lw	a5,0(a5)
c001d4b4:	12078693          	addi	a3,a5,288
c001d4b8:	fec42703          	lw	a4,-20(s0)
c001d4bc:	fd842783          	lw	a5,-40(s0)
c001d4c0:	00f777b3          	and	a5,a4,a5
c001d4c4:	00078593          	mv	a1,a5
c001d4c8:	00068513          	mv	a0,a3
c001d4cc:	a75ff0ef          	jal	ra,c001cf40 <Xil_Out32>
c001d4d0:	0280006f          	j	c001d4f8 <XGpio_InterruptClear+0x11c>
	Xil_AssertVoid(InstancePtr->InterruptPresent == TRUE);
c001d4d4:	0dd00593          	li	a1,221
c001d4d8:	07fe4517          	auipc	a0,0x7fe4
c001d4dc:	51450513          	addi	a0,a0,1300 # c80019ec <__rodata_start+0x19ec>
c001d4e0:	5dc000ef          	jal	ra,c001dabc <Xil_Assert>
c001d4e4:	07fe5797          	auipc	a5,0x7fe5
c001d4e8:	43078793          	addi	a5,a5,1072 # c8002914 <Xil_AssertStatus>
c001d4ec:	00100713          	li	a4,1
c001d4f0:	00e7a023          	sw	a4,0(a5)
c001d4f4:	00000013          	nop
			Register & Mask);


}
c001d4f8:	02c12083          	lw	ra,44(sp)
c001d4fc:	02812403          	lw	s0,40(sp)
c001d500:	03010113          	addi	sp,sp,48
c001d504:	00008067          	ret

c001d508 <XGpio_InterruptGetEnabled>:
*
* @note		None.
*
*****************************************************************************/
u32 XGpio_InterruptGetEnabled(XGpio * InstancePtr)
{
c001d508:	fe010113          	addi	sp,sp,-32
c001d50c:	00112e23          	sw	ra,28(sp)
c001d510:	00812c23          	sw	s0,24(sp)
c001d514:	02010413          	addi	s0,sp,32
c001d518:	fea42623          	sw	a0,-20(s0)
	Xil_AssertNonvoid(InstancePtr != NULL);
c001d51c:	fec42783          	lw	a5,-20(s0)
c001d520:	02078463          	beqz	a5,c001d548 <XGpio_InterruptGetEnabled+0x40>
c001d524:	07fe5797          	auipc	a5,0x7fe5
c001d528:	3f078793          	addi	a5,a5,1008 # c8002914 <Xil_AssertStatus>
c001d52c:	0007a023          	sw	zero,0(a5)
	Xil_AssertNonvoid(InstancePtr->IsReady == XIL_COMPONENT_IS_READY);
c001d530:	fec42783          	lw	a5,-20(s0)
c001d534:	0047a703          	lw	a4,4(a5)
c001d538:	111117b7          	lui	a5,0x11111
c001d53c:	11178793          	addi	a5,a5,273 # 11111111 <_DMEM_LENGTH+0x10911111>
c001d540:	04f71863          	bne	a4,a5,c001d590 <XGpio_InterruptGetEnabled+0x88>
c001d544:	02c0006f          	j	c001d570 <XGpio_InterruptGetEnabled+0x68>
	Xil_AssertNonvoid(InstancePtr != NULL);
c001d548:	0fe00593          	li	a1,254
c001d54c:	07fe4517          	auipc	a0,0x7fe4
c001d550:	4a050513          	addi	a0,a0,1184 # c80019ec <__rodata_start+0x19ec>
c001d554:	568000ef          	jal	ra,c001dabc <Xil_Assert>
c001d558:	07fe5797          	auipc	a5,0x7fe5
c001d55c:	3bc78793          	addi	a5,a5,956 # c8002914 <Xil_AssertStatus>
c001d560:	00100713          	li	a4,1
c001d564:	00e7a023          	sw	a4,0(a5)
c001d568:	00000793          	li	a5,0
c001d56c:	0980006f          	j	c001d604 <XGpio_InterruptGetEnabled+0xfc>
	Xil_AssertNonvoid(InstancePtr->IsReady == XIL_COMPONENT_IS_READY);
c001d570:	07fe5797          	auipc	a5,0x7fe5
c001d574:	3a478793          	addi	a5,a5,932 # c8002914 <Xil_AssertStatus>
c001d578:	0007a023          	sw	zero,0(a5)
	Xil_AssertNonvoid(InstancePtr->InterruptPresent == TRUE);
c001d57c:	fec42783          	lw	a5,-20(s0)
c001d580:	0087a703          	lw	a4,8(a5)
c001d584:	00100793          	li	a5,1
c001d588:	04f71c63          	bne	a4,a5,c001d5e0 <XGpio_InterruptGetEnabled+0xd8>
c001d58c:	02c0006f          	j	c001d5b8 <XGpio_InterruptGetEnabled+0xb0>
	Xil_AssertNonvoid(InstancePtr->IsReady == XIL_COMPONENT_IS_READY);
c001d590:	0ff00593          	li	a1,255
c001d594:	07fe4517          	auipc	a0,0x7fe4
c001d598:	45850513          	addi	a0,a0,1112 # c80019ec <__rodata_start+0x19ec>
c001d59c:	520000ef          	jal	ra,c001dabc <Xil_Assert>
c001d5a0:	07fe5797          	auipc	a5,0x7fe5
c001d5a4:	37478793          	addi	a5,a5,884 # c8002914 <Xil_AssertStatus>
c001d5a8:	00100713          	li	a4,1
c001d5ac:	00e7a023          	sw	a4,0(a5)
c001d5b0:	00000793          	li	a5,0
c001d5b4:	0500006f          	j	c001d604 <XGpio_InterruptGetEnabled+0xfc>
	Xil_AssertNonvoid(InstancePtr->InterruptPresent == TRUE);
c001d5b8:	07fe5797          	auipc	a5,0x7fe5
c001d5bc:	35c78793          	addi	a5,a5,860 # c8002914 <Xil_AssertStatus>
c001d5c0:	0007a023          	sw	zero,0(a5)

	return XGpio_ReadReg(InstancePtr->BaseAddress, XGPIO_IER_OFFSET);
c001d5c4:	fec42783          	lw	a5,-20(s0)
c001d5c8:	0007a783          	lw	a5,0(a5)
c001d5cc:	12878793          	addi	a5,a5,296
c001d5d0:	00078513          	mv	a0,a5
c001d5d4:	945ff0ef          	jal	ra,c001cf18 <Xil_In32>
c001d5d8:	00050793          	mv	a5,a0
c001d5dc:	0280006f          	j	c001d604 <XGpio_InterruptGetEnabled+0xfc>
	Xil_AssertNonvoid(InstancePtr->InterruptPresent == TRUE);
c001d5e0:	10000593          	li	a1,256
c001d5e4:	07fe4517          	auipc	a0,0x7fe4
c001d5e8:	40850513          	addi	a0,a0,1032 # c80019ec <__rodata_start+0x19ec>
c001d5ec:	4d0000ef          	jal	ra,c001dabc <Xil_Assert>
c001d5f0:	07fe5797          	auipc	a5,0x7fe5
c001d5f4:	32478793          	addi	a5,a5,804 # c8002914 <Xil_AssertStatus>
c001d5f8:	00100713          	li	a4,1
c001d5fc:	00e7a023          	sw	a4,0(a5)
c001d600:	00000793          	li	a5,0
}
c001d604:	00078513          	mv	a0,a5
c001d608:	01c12083          	lw	ra,28(sp)
c001d60c:	01812403          	lw	s0,24(sp)
c001d610:	02010113          	addi	sp,sp,32
c001d614:	00008067          	ret

c001d618 <XGpio_InterruptGetStatus>:
* the interrupts from the devices have been enabled or not through
* XGpio_InterruptEnable().
*
*****************************************************************************/
u32 XGpio_InterruptGetStatus(XGpio * InstancePtr)
{
c001d618:	fe010113          	addi	sp,sp,-32
c001d61c:	00112e23          	sw	ra,28(sp)
c001d620:	00812c23          	sw	s0,24(sp)
c001d624:	02010413          	addi	s0,sp,32
c001d628:	fea42623          	sw	a0,-20(s0)
	Xil_AssertNonvoid(InstancePtr != NULL);
c001d62c:	fec42783          	lw	a5,-20(s0)
c001d630:	02078463          	beqz	a5,c001d658 <XGpio_InterruptGetStatus+0x40>
c001d634:	07fe5797          	auipc	a5,0x7fe5
c001d638:	2e078793          	addi	a5,a5,736 # c8002914 <Xil_AssertStatus>
c001d63c:	0007a023          	sw	zero,0(a5)
	Xil_AssertNonvoid(InstancePtr->IsReady == XIL_COMPONENT_IS_READY);
c001d640:	fec42783          	lw	a5,-20(s0)
c001d644:	0047a703          	lw	a4,4(a5)
c001d648:	111117b7          	lui	a5,0x11111
c001d64c:	11178793          	addi	a5,a5,273 # 11111111 <_DMEM_LENGTH+0x10911111>
c001d650:	04f71863          	bne	a4,a5,c001d6a0 <XGpio_InterruptGetStatus+0x88>
c001d654:	02c0006f          	j	c001d680 <XGpio_InterruptGetStatus+0x68>
	Xil_AssertNonvoid(InstancePtr != NULL);
c001d658:	11b00593          	li	a1,283
c001d65c:	07fe4517          	auipc	a0,0x7fe4
c001d660:	39050513          	addi	a0,a0,912 # c80019ec <__rodata_start+0x19ec>
c001d664:	458000ef          	jal	ra,c001dabc <Xil_Assert>
c001d668:	07fe5797          	auipc	a5,0x7fe5
c001d66c:	2ac78793          	addi	a5,a5,684 # c8002914 <Xil_AssertStatus>
c001d670:	00100713          	li	a4,1
c001d674:	00e7a023          	sw	a4,0(a5)
c001d678:	00000793          	li	a5,0
c001d67c:	0980006f          	j	c001d714 <XGpio_InterruptGetStatus+0xfc>
	Xil_AssertNonvoid(InstancePtr->IsReady == XIL_COMPONENT_IS_READY);
c001d680:	07fe5797          	auipc	a5,0x7fe5
c001d684:	29478793          	addi	a5,a5,660 # c8002914 <Xil_AssertStatus>
c001d688:	0007a023          	sw	zero,0(a5)
	Xil_AssertNonvoid(InstancePtr->InterruptPresent == TRUE);
c001d68c:	fec42783          	lw	a5,-20(s0)
c001d690:	0087a703          	lw	a4,8(a5)
c001d694:	00100793          	li	a5,1
c001d698:	04f71c63          	bne	a4,a5,c001d6f0 <XGpio_InterruptGetStatus+0xd8>
c001d69c:	02c0006f          	j	c001d6c8 <XGpio_InterruptGetStatus+0xb0>
	Xil_AssertNonvoid(InstancePtr->IsReady == XIL_COMPONENT_IS_READY);
c001d6a0:	11c00593          	li	a1,284
c001d6a4:	07fe4517          	auipc	a0,0x7fe4
c001d6a8:	34850513          	addi	a0,a0,840 # c80019ec <__rodata_start+0x19ec>
c001d6ac:	410000ef          	jal	ra,c001dabc <Xil_Assert>
c001d6b0:	07fe5797          	auipc	a5,0x7fe5
c001d6b4:	26478793          	addi	a5,a5,612 # c8002914 <Xil_AssertStatus>
c001d6b8:	00100713          	li	a4,1
c001d6bc:	00e7a023          	sw	a4,0(a5)
c001d6c0:	00000793          	li	a5,0
c001d6c4:	0500006f          	j	c001d714 <XGpio_InterruptGetStatus+0xfc>
	Xil_AssertNonvoid(InstancePtr->InterruptPresent == TRUE);
c001d6c8:	07fe5797          	auipc	a5,0x7fe5
c001d6cc:	24c78793          	addi	a5,a5,588 # c8002914 <Xil_AssertStatus>
c001d6d0:	0007a023          	sw	zero,0(a5)


	return XGpio_ReadReg(InstancePtr->BaseAddress, XGPIO_ISR_OFFSET);
c001d6d4:	fec42783          	lw	a5,-20(s0)
c001d6d8:	0007a783          	lw	a5,0(a5)
c001d6dc:	12078793          	addi	a5,a5,288
c001d6e0:	00078513          	mv	a0,a5
c001d6e4:	835ff0ef          	jal	ra,c001cf18 <Xil_In32>
c001d6e8:	00050793          	mv	a5,a0
c001d6ec:	0280006f          	j	c001d714 <XGpio_InterruptGetStatus+0xfc>
	Xil_AssertNonvoid(InstancePtr->InterruptPresent == TRUE);
c001d6f0:	11d00593          	li	a1,285
c001d6f4:	07fe4517          	auipc	a0,0x7fe4
c001d6f8:	2f850513          	addi	a0,a0,760 # c80019ec <__rodata_start+0x19ec>
c001d6fc:	3c0000ef          	jal	ra,c001dabc <Xil_Assert>
c001d700:	07fe5797          	auipc	a5,0x7fe5
c001d704:	21478793          	addi	a5,a5,532 # c8002914 <Xil_AssertStatus>
c001d708:	00100713          	li	a4,1
c001d70c:	00e7a023          	sw	a4,0(a5)
c001d710:	00000793          	li	a5,0
}
c001d714:	00078513          	mv	a0,a5
c001d718:	01c12083          	lw	ra,28(sp)
c001d71c:	01812403          	lw	s0,24(sp)
c001d720:	02010113          	addi	sp,sp,32
c001d724:	00008067          	ret

c001d728 <XGpio_SelfTest>:
*
* @note		None.
*
******************************************************************************/
int XGpio_SelfTest(XGpio * InstancePtr)
{
c001d728:	fe010113          	addi	sp,sp,-32
c001d72c:	00112e23          	sw	ra,28(sp)
c001d730:	00812c23          	sw	s0,24(sp)
c001d734:	02010413          	addi	s0,sp,32
c001d738:	fea42623          	sw	a0,-20(s0)
	Xil_AssertNonvoid(InstancePtr != NULL);
c001d73c:	fec42783          	lw	a5,-20(s0)
c001d740:	02078463          	beqz	a5,c001d768 <XGpio_SelfTest+0x40>
c001d744:	07fe5797          	auipc	a5,0x7fe5
c001d748:	1d078793          	addi	a5,a5,464 # c8002914 <Xil_AssertStatus>
c001d74c:	0007a023          	sw	zero,0(a5)
	Xil_AssertNonvoid(InstancePtr->IsReady == XIL_COMPONENT_IS_READY);
c001d750:	fec42783          	lw	a5,-20(s0)
c001d754:	0047a703          	lw	a4,4(a5)
c001d758:	111117b7          	lui	a5,0x11111
c001d75c:	11178793          	addi	a5,a5,273 # 11111111 <_DMEM_LENGTH+0x10911111>
c001d760:	04f71863          	bne	a4,a5,c001d7b0 <XGpio_SelfTest+0x88>
c001d764:	02c0006f          	j	c001d790 <XGpio_SelfTest+0x68>
	Xil_AssertNonvoid(InstancePtr != NULL);
c001d768:	05d00593          	li	a1,93
c001d76c:	07fe4517          	auipc	a0,0x7fe4
c001d770:	2a050513          	addi	a0,a0,672 # c8001a0c <__rodata_start+0x1a0c>
c001d774:	348000ef          	jal	ra,c001dabc <Xil_Assert>
c001d778:	07fe5797          	auipc	a5,0x7fe5
c001d77c:	19c78793          	addi	a5,a5,412 # c8002914 <Xil_AssertStatus>
c001d780:	00100713          	li	a4,1
c001d784:	00e7a023          	sw	a4,0(a5)
c001d788:	00000793          	li	a5,0
c001d78c:	0480006f          	j	c001d7d4 <XGpio_SelfTest+0xac>
	Xil_AssertNonvoid(InstancePtr->IsReady == XIL_COMPONENT_IS_READY);
c001d790:	07fe5797          	auipc	a5,0x7fe5
c001d794:	18478793          	addi	a5,a5,388 # c8002914 <Xil_AssertStatus>
c001d798:	0007a023          	sw	zero,0(a5)
	 * Read from the data register of channel 1 which is always guaranteed
	 * to be in the hardware device. Since the data may be configured as
	 * all inputs, there is not way to guarantee the value read so don't
	 * test it.
	 */
	(void) XGpio_DiscreteRead(InstancePtr, 1);
c001d79c:	00100593          	li	a1,1
c001d7a0:	fec42503          	lw	a0,-20(s0)
c001d7a4:	9e0ff0ef          	jal	ra,c001c984 <XGpio_DiscreteRead>

	return (XST_SUCCESS);
c001d7a8:	00000793          	li	a5,0
c001d7ac:	0280006f          	j	c001d7d4 <XGpio_SelfTest+0xac>
	Xil_AssertNonvoid(InstancePtr->IsReady == XIL_COMPONENT_IS_READY);
c001d7b0:	05e00593          	li	a1,94
c001d7b4:	07fe4517          	auipc	a0,0x7fe4
c001d7b8:	25850513          	addi	a0,a0,600 # c8001a0c <__rodata_start+0x1a0c>
c001d7bc:	300000ef          	jal	ra,c001dabc <Xil_Assert>
c001d7c0:	07fe5797          	auipc	a5,0x7fe5
c001d7c4:	15478793          	addi	a5,a5,340 # c8002914 <Xil_AssertStatus>
c001d7c8:	00100713          	li	a4,1
c001d7cc:	00e7a023          	sw	a4,0(a5)
c001d7d0:	00000793          	li	a5,0
}
c001d7d4:	00078513          	mv	a0,a5
c001d7d8:	01c12083          	lw	ra,28(sp)
c001d7dc:	01812403          	lw	s0,24(sp)
c001d7e0:	02010113          	addi	sp,sp,32
c001d7e4:	00008067          	ret

c001d7e8 <XGpio_LookupConfig>:
*
* @note		None.
*
******************************************************************************/
XGpio_Config *XGpio_LookupConfig(u16 DeviceId)
{
c001d7e8:	fd010113          	addi	sp,sp,-48
c001d7ec:	02812623          	sw	s0,44(sp)
c001d7f0:	03010413          	addi	s0,sp,48
c001d7f4:	00050793          	mv	a5,a0
c001d7f8:	fcf41f23          	sh	a5,-34(s0)
	XGpio_Config *CfgPtr = NULL;
c001d7fc:	fe042623          	sw	zero,-20(s0)

	int Index;

	for (Index = 0; Index < XPAR_XGPIO_NUM_INSTANCES; Index++) {
c001d800:	fe042423          	sw	zero,-24(s0)
c001d804:	04c0006f          	j	c001d850 <XGpio_LookupConfig+0x68>
		if (XGpio_ConfigTable[Index].DeviceId == DeviceId) {
c001d808:	07fe5717          	auipc	a4,0x7fe5
c001d80c:	35070713          	addi	a4,a4,848 # c8002b58 <XGpio_ConfigTable>
c001d810:	fe842783          	lw	a5,-24(s0)
c001d814:	00479793          	slli	a5,a5,0x4
c001d818:	00f707b3          	add	a5,a4,a5
c001d81c:	0007d783          	lhu	a5,0(a5)
c001d820:	fde45703          	lhu	a4,-34(s0)
c001d824:	02f71063          	bne	a4,a5,c001d844 <XGpio_LookupConfig+0x5c>
			CfgPtr = &XGpio_ConfigTable[Index];
c001d828:	fe842783          	lw	a5,-24(s0)
c001d82c:	00479713          	slli	a4,a5,0x4
c001d830:	07fe5797          	auipc	a5,0x7fe5
c001d834:	32878793          	addi	a5,a5,808 # c8002b58 <XGpio_ConfigTable>
c001d838:	00f707b3          	add	a5,a4,a5
c001d83c:	fef42623          	sw	a5,-20(s0)
			break;
c001d840:	0180006f          	j	c001d858 <XGpio_LookupConfig+0x70>
	for (Index = 0; Index < XPAR_XGPIO_NUM_INSTANCES; Index++) {
c001d844:	fe842783          	lw	a5,-24(s0)
c001d848:	00178793          	addi	a5,a5,1
c001d84c:	fef42423          	sw	a5,-24(s0)
c001d850:	fe842783          	lw	a5,-24(s0)
c001d854:	faf05ae3          	blez	a5,c001d808 <XGpio_LookupConfig+0x20>
		}
	}

	return CfgPtr;
c001d858:	fec42783          	lw	a5,-20(s0)
}
c001d85c:	00078513          	mv	a0,a5
c001d860:	02c12403          	lw	s0,44(sp)
c001d864:	03010113          	addi	sp,sp,48
c001d868:	00008067          	ret

c001d86c <XGpio_Initialize>:
*
* @note		None.
*
*****************************************************************************/
int XGpio_Initialize(XGpio * InstancePtr, u16 DeviceId)
{
c001d86c:	fd010113          	addi	sp,sp,-48
c001d870:	02112623          	sw	ra,44(sp)
c001d874:	02812423          	sw	s0,40(sp)
c001d878:	03010413          	addi	s0,sp,48
c001d87c:	fca42e23          	sw	a0,-36(s0)
c001d880:	00058793          	mv	a5,a1
c001d884:	fcf41d23          	sh	a5,-38(s0)
	XGpio_Config *ConfigPtr;

	/*
	 * Assert arguments
	 */
	Xil_AssertNonvoid(InstancePtr != NULL);
c001d888:	fdc42783          	lw	a5,-36(s0)
c001d88c:	02078663          	beqz	a5,c001d8b8 <XGpio_Initialize+0x4c>
c001d890:	07fe5797          	auipc	a5,0x7fe5
c001d894:	08478793          	addi	a5,a5,132 # c8002914 <Xil_AssertStatus>
c001d898:	0007a023          	sw	zero,0(a5)
	/*
	 * Lookup configuration data in the device configuration table.
	 * Use this configuration info down below when initializing this
	 * driver.
	 */
	ConfigPtr = XGpio_LookupConfig(DeviceId);
c001d89c:	fda45783          	lhu	a5,-38(s0)
c001d8a0:	00078513          	mv	a0,a5
c001d8a4:	f45ff0ef          	jal	ra,c001d7e8 <XGpio_LookupConfig>
c001d8a8:	fea42623          	sw	a0,-20(s0)
	if (ConfigPtr == (XGpio_Config *) NULL) {
c001d8ac:	fec42783          	lw	a5,-20(s0)
c001d8b0:	04079063          	bnez	a5,c001d8f0 <XGpio_Initialize+0x84>
c001d8b4:	02c0006f          	j	c001d8e0 <XGpio_Initialize+0x74>
	Xil_AssertNonvoid(InstancePtr != NULL);
c001d8b8:	08b00593          	li	a1,139
c001d8bc:	07fe4517          	auipc	a0,0x7fe4
c001d8c0:	17450513          	addi	a0,a0,372 # c8001a30 <__rodata_start+0x1a30>
c001d8c4:	1f8000ef          	jal	ra,c001dabc <Xil_Assert>
c001d8c8:	07fe5797          	auipc	a5,0x7fe5
c001d8cc:	04c78793          	addi	a5,a5,76 # c8002914 <Xil_AssertStatus>
c001d8d0:	00100713          	li	a4,1
c001d8d4:	00e7a023          	sw	a4,0(a5)
c001d8d8:	00000793          	li	a5,0
c001d8dc:	0300006f          	j	c001d90c <XGpio_Initialize+0xa0>
		InstancePtr->IsReady = 0;
c001d8e0:	fdc42783          	lw	a5,-36(s0)
c001d8e4:	0007a223          	sw	zero,4(a5)
		return (XST_DEVICE_NOT_FOUND);
c001d8e8:	00200793          	li	a5,2
c001d8ec:	0200006f          	j	c001d90c <XGpio_Initialize+0xa0>
	}

	return XGpio_CfgInitialize(InstancePtr, ConfigPtr,
c001d8f0:	fec42783          	lw	a5,-20(s0)
c001d8f4:	0047a783          	lw	a5,4(a5)
c001d8f8:	00078613          	mv	a2,a5
c001d8fc:	fec42583          	lw	a1,-20(s0)
c001d900:	fdc42503          	lw	a0,-36(s0)
c001d904:	d65fe0ef          	jal	ra,c001c668 <XGpio_CfgInitialize>
c001d908:	00050793          	mv	a5,a0
				   ConfigPtr->BaseAddress);
}
c001d90c:	00078513          	mv	a0,a5
c001d910:	02c12083          	lw	ra,44(sp)
c001d914:	02812403          	lw	s0,40(sp)
c001d918:	03010113          	addi	sp,sp,48
c001d91c:	00008067          	ret

c001d920 <XAssert>:
*
* @note     None.
*
******************************************************************************/
void XAssert(char *File, int Line)
{
c001d920:	fe010113          	addi	sp,sp,-32
c001d924:	00112e23          	sw	ra,28(sp)
c001d928:	00812c23          	sw	s0,24(sp)
c001d92c:	02010413          	addi	s0,sp,32
c001d930:	fea42623          	sw	a0,-20(s0)
c001d934:	feb42423          	sw	a1,-24(s0)
	/* if the callback has been set then invoke it */
	if (XAssertCallbackRoutine != NULL) {
c001d938:	08026797          	auipc	a5,0x8026
c001d93c:	ef078793          	addi	a5,a5,-272 # c8043828 <XAssertCallbackRoutine>
c001d940:	0007a783          	lw	a5,0(a5)
c001d944:	00078e63          	beqz	a5,c001d960 <XAssert+0x40>
		(*XAssertCallbackRoutine) (File, Line);
c001d948:	08026797          	auipc	a5,0x8026
c001d94c:	ee078793          	addi	a5,a5,-288 # c8043828 <XAssertCallbackRoutine>
c001d950:	0007a783          	lw	a5,0(a5)
c001d954:	fe842583          	lw	a1,-24(s0)
c001d958:	fec42503          	lw	a0,-20(s0)
c001d95c:	000780e7          	jalr	a5
	}

	/* if specified, wait indefinitely such that the assert will show up
	 * in testing
	 */
	while (XWaitInAssert) {
c001d960:	00000013          	nop
c001d964:	07fe5797          	auipc	a5,0x7fe5
c001d968:	01c78793          	addi	a5,a5,28 # c8002980 <XWaitInAssert>
c001d96c:	0007a783          	lw	a5,0(a5)
c001d970:	fe079ae3          	bnez	a5,c001d964 <XAssert+0x44>
	}
}
c001d974:	00000013          	nop
c001d978:	00000013          	nop
c001d97c:	01c12083          	lw	ra,28(sp)
c001d980:	01812403          	lw	s0,24(sp)
c001d984:	02010113          	addi	sp,sp,32
c001d988:	00008067          	ret

c001d98c <XAssertSetCallback>:
*
* @note     This function has no effect if NDEBUG is set
*
******************************************************************************/
void XAssertSetCallback(XAssertCallback Routine)
{
c001d98c:	fe010113          	addi	sp,sp,-32
c001d990:	00812e23          	sw	s0,28(sp)
c001d994:	02010413          	addi	s0,sp,32
c001d998:	fea42623          	sw	a0,-20(s0)
	XAssertCallbackRoutine = Routine;
c001d99c:	08026797          	auipc	a5,0x8026
c001d9a0:	e8c78793          	addi	a5,a5,-372 # c8043828 <XAssertCallbackRoutine>
c001d9a4:	fec42703          	lw	a4,-20(s0)
c001d9a8:	00e7a023          	sw	a4,0(a5)
}
c001d9ac:	00000013          	nop
c001d9b0:	01c12403          	lw	s0,28(sp)
c001d9b4:	02010113          	addi	sp,sp,32
c001d9b8:	00008067          	ret

c001d9bc <Xil_EndianSwap16>:
*
* @return	16 bit Data with converted endianess
*
******************************************************************************/
u16 Xil_EndianSwap16(u16 Data)
{
c001d9bc:	fe010113          	addi	sp,sp,-32
c001d9c0:	00812e23          	sw	s0,28(sp)
c001d9c4:	02010413          	addi	s0,sp,32
c001d9c8:	00050793          	mv	a5,a0
c001d9cc:	fef41723          	sh	a5,-18(s0)
	return (u16) (((Data & 0xFF00U) >> 8U) | ((Data & 0x00FFU) << 8U));
c001d9d0:	fee45783          	lhu	a5,-18(s0)
c001d9d4:	00879713          	slli	a4,a5,0x8
c001d9d8:	01079793          	slli	a5,a5,0x10
c001d9dc:	0107d793          	srli	a5,a5,0x10
c001d9e0:	0087d793          	srli	a5,a5,0x8
c001d9e4:	00f767b3          	or	a5,a4,a5
c001d9e8:	01079793          	slli	a5,a5,0x10
c001d9ec:	0107d793          	srli	a5,a5,0x10
}
c001d9f0:	00078513          	mv	a0,a5
c001d9f4:	01c12403          	lw	s0,28(sp)
c001d9f8:	02010113          	addi	sp,sp,32
c001d9fc:	00008067          	ret

c001da00 <Xil_EndianSwap32>:
*
* @return	32 bit data with converted endianess
*
******************************************************************************/
u32 Xil_EndianSwap32(u32 Data)
{
c001da00:	fd010113          	addi	sp,sp,-48
c001da04:	02812623          	sw	s0,44(sp)
c001da08:	03010413          	addi	s0,sp,48
c001da0c:	fca42e23          	sw	a0,-36(s0)
	u16 LoWord;
	u16 HiWord;

	/* get each of the half words from the 32 bit word */

	LoWord = (u16) (Data & 0x0000FFFFU);
c001da10:	fdc42783          	lw	a5,-36(s0)
c001da14:	fef41723          	sh	a5,-18(s0)
	HiWord = (u16) ((Data & 0xFFFF0000U) >> 16U);
c001da18:	fdc42783          	lw	a5,-36(s0)
c001da1c:	0107d793          	srli	a5,a5,0x10
c001da20:	fef41623          	sh	a5,-20(s0)

	/* byte swap each of the 16 bit half words */

	LoWord = (((LoWord & 0xFF00U) >> 8U) | ((LoWord & 0x00FFU) << 8U));
c001da24:	fee45783          	lhu	a5,-18(s0)
c001da28:	00879713          	slli	a4,a5,0x8
c001da2c:	01079793          	slli	a5,a5,0x10
c001da30:	0107d793          	srli	a5,a5,0x10
c001da34:	0087d793          	srli	a5,a5,0x8
c001da38:	00f767b3          	or	a5,a4,a5
c001da3c:	fef41723          	sh	a5,-18(s0)
	HiWord = (((HiWord & 0xFF00U) >> 8U) | ((HiWord & 0x00FFU) << 8U));
c001da40:	fec45783          	lhu	a5,-20(s0)
c001da44:	00879713          	slli	a4,a5,0x8
c001da48:	01079793          	slli	a5,a5,0x10
c001da4c:	0107d793          	srli	a5,a5,0x10
c001da50:	0087d793          	srli	a5,a5,0x8
c001da54:	00f767b3          	or	a5,a4,a5
c001da58:	fef41623          	sh	a5,-20(s0)

	/* swap the half words before returning the value */

	return ((((u32)LoWord) << (u32)16U) | (u32)HiWord);
c001da5c:	fee45783          	lhu	a5,-18(s0)
c001da60:	01079713          	slli	a4,a5,0x10
c001da64:	fec45783          	lhu	a5,-20(s0)
c001da68:	00f767b3          	or	a5,a4,a5
}
c001da6c:	00078513          	mv	a0,a5
c001da70:	02c12403          	lw	s0,44(sp)
c001da74:	03010113          	addi	sp,sp,48
c001da78:	00008067          	ret

c001da7c <CustomCallback>:

/************************** Function Prototypes ******************************/



static void CustomCallback(const char8 *File, s32 Line) {
c001da7c:	fe010113          	addi	sp,sp,-32
c001da80:	00112e23          	sw	ra,28(sp)
c001da84:	00812c23          	sw	s0,24(sp)
c001da88:	02010413          	addi	s0,sp,32
c001da8c:	fea42623          	sw	a0,-20(s0)
c001da90:	feb42423          	sw	a1,-24(s0)
	#if defined(__clang__)
	printf("Xil assert failed! %s: %i\r\n", File, Line);
	#else
	printf("Xil assert failed! %s: %i\r\n", File, (int)Line);
c001da94:	fe842603          	lw	a2,-24(s0)
c001da98:	fec42583          	lw	a1,-20(s0)
c001da9c:	07fe4517          	auipc	a0,0x7fe4
c001daa0:	fb450513          	addi	a0,a0,-76 # c8001a50 <__rodata_start+0x1a50>
c001daa4:	300000ef          	jal	ra,c001dda4 <printf>
	#endif
}
c001daa8:	00000013          	nop
c001daac:	01c12083          	lw	ra,28(sp)
c001dab0:	01812403          	lw	s0,24(sp)
c001dab4:	02010113          	addi	sp,sp,32
c001dab8:	00008067          	ret

c001dabc <Xil_Assert>:
*
* @note     None.
*
******************************************************************************/
void Xil_Assert(const char8 *File, s32 Line)
{
c001dabc:	fe010113          	addi	sp,sp,-32
c001dac0:	00112e23          	sw	ra,28(sp)
c001dac4:	00812c23          	sw	s0,24(sp)
c001dac8:	02010413          	addi	s0,sp,32
c001dacc:	fea42623          	sw	a0,-20(s0)
c001dad0:	feb42423          	sw	a1,-24(s0)
	/* if the callback has been set then invoke it */
	if (Xil_AssertCallbackRoutine != 0) {
c001dad4:	07fe5797          	auipc	a5,0x7fe5
c001dad8:	eb478793          	addi	a5,a5,-332 # c8002988 <Xil_AssertCallbackRoutine>
c001dadc:	0007a783          	lw	a5,0(a5)
c001dae0:	00078e63          	beqz	a5,c001dafc <Xil_Assert+0x40>
		(*Xil_AssertCallbackRoutine)(File, Line);
c001dae4:	07fe5797          	auipc	a5,0x7fe5
c001dae8:	ea478793          	addi	a5,a5,-348 # c8002988 <Xil_AssertCallbackRoutine>
c001daec:	0007a783          	lw	a5,0(a5)
c001daf0:	fe842583          	lw	a1,-24(s0)
c001daf4:	fec42503          	lw	a0,-20(s0)
c001daf8:	000780e7          	jalr	a5
	}

	__asm volatile( "ebreak" ); for( ;; );
c001dafc:	00100073          	ebreak
c001db00:	0000006f          	j	c001db00 <Xil_Assert+0x44>

c001db04 <Xil_AssertSetCallback>:
*
* @note     This function has no effect if NDEBUG is set
*
******************************************************************************/
void Xil_AssertSetCallback(Xil_AssertCallback Routine)
{
c001db04:	fe010113          	addi	sp,sp,-32
c001db08:	00812e23          	sw	s0,28(sp)
c001db0c:	02010413          	addi	s0,sp,32
c001db10:	fea42623          	sw	a0,-20(s0)
	Xil_AssertCallbackRoutine = Routine;
c001db14:	07fe5797          	auipc	a5,0x7fe5
c001db18:	e7478793          	addi	a5,a5,-396 # c8002988 <Xil_AssertCallbackRoutine>
c001db1c:	fec42703          	lw	a4,-20(s0)
c001db20:	00e7a023          	sw	a4,0(a5)
}
c001db24:	00000013          	nop
c001db28:	01c12403          	lw	s0,28(sp)
c001db2c:	02010113          	addi	sp,sp,32
c001db30:	00008067          	ret

c001db34 <XNullHandler>:
*
* @note     None.
*
******************************************************************************/
void XNullHandler(void *NullParameter)
{
c001db34:	fe010113          	addi	sp,sp,-32
c001db38:	00812e23          	sw	s0,28(sp)
c001db3c:	02010413          	addi	s0,sp,32
c001db40:	fea42623          	sw	a0,-20(s0)
	(void) NullParameter;
}
c001db44:	00000013          	nop
c001db48:	01c12403          	lw	s0,28(sp)
c001db4c:	02010113          	addi	sp,sp,32
c001db50:	00008067          	ret

c001db54 <__errno>:
c001db54:	c80037b7          	lui	a5,0xc8003
c001db58:	98c7a503          	lw	a0,-1652(a5) # c800298c <_end+0xfff7e10c>
c001db5c:	00008067          	ret

c001db60 <memcpy>:
c001db60:	00a5c7b3          	xor	a5,a1,a0
c001db64:	0037f793          	andi	a5,a5,3
c001db68:	00c508b3          	add	a7,a0,a2
c001db6c:	06079663          	bnez	a5,c001dbd8 <memcpy+0x78>
c001db70:	00300793          	li	a5,3
c001db74:	06c7f263          	bgeu	a5,a2,c001dbd8 <memcpy+0x78>
c001db78:	00357793          	andi	a5,a0,3
c001db7c:	00050713          	mv	a4,a0
c001db80:	0c079a63          	bnez	a5,c001dc54 <memcpy+0xf4>
c001db84:	ffc8f613          	andi	a2,a7,-4
c001db88:	40e606b3          	sub	a3,a2,a4
c001db8c:	02000793          	li	a5,32
c001db90:	02000293          	li	t0,32
c001db94:	06d7c263          	blt	a5,a3,c001dbf8 <memcpy+0x98>
c001db98:	00058693          	mv	a3,a1
c001db9c:	00070793          	mv	a5,a4
c001dba0:	02c77863          	bgeu	a4,a2,c001dbd0 <memcpy+0x70>
c001dba4:	0006a803          	lw	a6,0(a3)
c001dba8:	00478793          	addi	a5,a5,4
c001dbac:	00468693          	addi	a3,a3,4
c001dbb0:	ff07ae23          	sw	a6,-4(a5)
c001dbb4:	fec7e8e3          	bltu	a5,a2,c001dba4 <memcpy+0x44>
c001dbb8:	fff60793          	addi	a5,a2,-1
c001dbbc:	40e787b3          	sub	a5,a5,a4
c001dbc0:	ffc7f793          	andi	a5,a5,-4
c001dbc4:	00478793          	addi	a5,a5,4
c001dbc8:	00f70733          	add	a4,a4,a5
c001dbcc:	00f585b3          	add	a1,a1,a5
c001dbd0:	01176863          	bltu	a4,a7,c001dbe0 <memcpy+0x80>
c001dbd4:	00008067          	ret
c001dbd8:	00050713          	mv	a4,a0
c001dbdc:	ff157ce3          	bgeu	a0,a7,c001dbd4 <memcpy+0x74>
c001dbe0:	0005c783          	lbu	a5,0(a1) # 80000000 <_end+0xb7f7b780>
c001dbe4:	00170713          	addi	a4,a4,1
c001dbe8:	00158593          	addi	a1,a1,1
c001dbec:	fef70fa3          	sb	a5,-1(a4)
c001dbf0:	ff1768e3          	bltu	a4,a7,c001dbe0 <memcpy+0x80>
c001dbf4:	00008067          	ret
c001dbf8:	0045a683          	lw	a3,4(a1)
c001dbfc:	01c5a783          	lw	a5,28(a1)
c001dc00:	0005af83          	lw	t6,0(a1)
c001dc04:	0085af03          	lw	t5,8(a1)
c001dc08:	00c5ae83          	lw	t4,12(a1)
c001dc0c:	0105ae03          	lw	t3,16(a1)
c001dc10:	0145a303          	lw	t1,20(a1)
c001dc14:	0185a803          	lw	a6,24(a1)
c001dc18:	00d72223          	sw	a3,4(a4)
c001dc1c:	0205a683          	lw	a3,32(a1)
c001dc20:	01f72023          	sw	t6,0(a4)
c001dc24:	01e72423          	sw	t5,8(a4)
c001dc28:	01d72623          	sw	t4,12(a4)
c001dc2c:	01c72823          	sw	t3,16(a4)
c001dc30:	00672a23          	sw	t1,20(a4)
c001dc34:	01072c23          	sw	a6,24(a4)
c001dc38:	00f72e23          	sw	a5,28(a4)
c001dc3c:	02470713          	addi	a4,a4,36
c001dc40:	40e607b3          	sub	a5,a2,a4
c001dc44:	fed72e23          	sw	a3,-4(a4)
c001dc48:	02458593          	addi	a1,a1,36
c001dc4c:	faf2c6e3          	blt	t0,a5,c001dbf8 <memcpy+0x98>
c001dc50:	f49ff06f          	j	c001db98 <memcpy+0x38>
c001dc54:	0005c683          	lbu	a3,0(a1)
c001dc58:	00170713          	addi	a4,a4,1
c001dc5c:	00377793          	andi	a5,a4,3
c001dc60:	fed70fa3          	sb	a3,-1(a4)
c001dc64:	00158593          	addi	a1,a1,1
c001dc68:	f0078ee3          	beqz	a5,c001db84 <memcpy+0x24>
c001dc6c:	0005c683          	lbu	a3,0(a1)
c001dc70:	00170713          	addi	a4,a4,1
c001dc74:	00377793          	andi	a5,a4,3
c001dc78:	fed70fa3          	sb	a3,-1(a4)
c001dc7c:	00158593          	addi	a1,a1,1
c001dc80:	fc079ae3          	bnez	a5,c001dc54 <memcpy+0xf4>
c001dc84:	f01ff06f          	j	c001db84 <memcpy+0x24>

c001dc88 <memset>:
c001dc88:	00f00313          	li	t1,15
c001dc8c:	00050713          	mv	a4,a0
c001dc90:	02c37e63          	bgeu	t1,a2,c001dccc <memset+0x44>
c001dc94:	00f77793          	andi	a5,a4,15
c001dc98:	0a079063          	bnez	a5,c001dd38 <memset+0xb0>
c001dc9c:	08059263          	bnez	a1,c001dd20 <memset+0x98>
c001dca0:	ff067693          	andi	a3,a2,-16
c001dca4:	00f67613          	andi	a2,a2,15
c001dca8:	00e686b3          	add	a3,a3,a4
c001dcac:	00b72023          	sw	a1,0(a4)
c001dcb0:	00b72223          	sw	a1,4(a4)
c001dcb4:	00b72423          	sw	a1,8(a4)
c001dcb8:	00b72623          	sw	a1,12(a4)
c001dcbc:	01070713          	addi	a4,a4,16
c001dcc0:	fed766e3          	bltu	a4,a3,c001dcac <memset+0x24>
c001dcc4:	00061463          	bnez	a2,c001dccc <memset+0x44>
c001dcc8:	00008067          	ret
c001dccc:	40c306b3          	sub	a3,t1,a2
c001dcd0:	00269693          	slli	a3,a3,0x2
c001dcd4:	00000297          	auipc	t0,0x0
c001dcd8:	005686b3          	add	a3,a3,t0
c001dcdc:	00c68067          	jr	12(a3)
c001dce0:	00b70723          	sb	a1,14(a4)
c001dce4:	00b706a3          	sb	a1,13(a4)
c001dce8:	00b70623          	sb	a1,12(a4)
c001dcec:	00b705a3          	sb	a1,11(a4)
c001dcf0:	00b70523          	sb	a1,10(a4)
c001dcf4:	00b704a3          	sb	a1,9(a4)
c001dcf8:	00b70423          	sb	a1,8(a4)
c001dcfc:	00b703a3          	sb	a1,7(a4)
c001dd00:	00b70323          	sb	a1,6(a4)
c001dd04:	00b702a3          	sb	a1,5(a4)
c001dd08:	00b70223          	sb	a1,4(a4)
c001dd0c:	00b701a3          	sb	a1,3(a4)
c001dd10:	00b70123          	sb	a1,2(a4)
c001dd14:	00b700a3          	sb	a1,1(a4)
c001dd18:	00b70023          	sb	a1,0(a4)
c001dd1c:	00008067          	ret
c001dd20:	0ff5f593          	andi	a1,a1,255
c001dd24:	00859693          	slli	a3,a1,0x8
c001dd28:	00d5e5b3          	or	a1,a1,a3
c001dd2c:	01059693          	slli	a3,a1,0x10
c001dd30:	00d5e5b3          	or	a1,a1,a3
c001dd34:	f6dff06f          	j	c001dca0 <memset+0x18>
c001dd38:	00279693          	slli	a3,a5,0x2
c001dd3c:	00000297          	auipc	t0,0x0
c001dd40:	005686b3          	add	a3,a3,t0
c001dd44:	00008293          	mv	t0,ra
c001dd48:	fa0680e7          	jalr	-96(a3)
c001dd4c:	00028093          	mv	ra,t0
c001dd50:	ff078793          	addi	a5,a5,-16
c001dd54:	40f70733          	sub	a4,a4,a5
c001dd58:	00f60633          	add	a2,a2,a5
c001dd5c:	f6c378e3          	bgeu	t1,a2,c001dccc <memset+0x44>
c001dd60:	f3dff06f          	j	c001dc9c <memset+0x14>

c001dd64 <_printf_r>:
c001dd64:	fc010113          	addi	sp,sp,-64
c001dd68:	02c12423          	sw	a2,40(sp)
c001dd6c:	02d12623          	sw	a3,44(sp)
c001dd70:	02e12823          	sw	a4,48(sp)
c001dd74:	02f12a23          	sw	a5,52(sp)
c001dd78:	03012c23          	sw	a6,56(sp)
c001dd7c:	03112e23          	sw	a7,60(sp)
c001dd80:	00058613          	mv	a2,a1
c001dd84:	00852583          	lw	a1,8(a0)
c001dd88:	02810693          	addi	a3,sp,40
c001dd8c:	00112e23          	sw	ra,28(sp)
c001dd90:	00d12623          	sw	a3,12(sp)
c001dd94:	4a5020ef          	jal	ra,c0020a38 <_vfprintf_r>
c001dd98:	01c12083          	lw	ra,28(sp)
c001dd9c:	04010113          	addi	sp,sp,64
c001dda0:	00008067          	ret

c001dda4 <printf>:
c001dda4:	c8003337          	lui	t1,0xc8003
c001dda8:	98c32303          	lw	t1,-1652(t1) # c800298c <_end+0xfff7e10c>
c001ddac:	fc010113          	addi	sp,sp,-64
c001ddb0:	02c12423          	sw	a2,40(sp)
c001ddb4:	02d12623          	sw	a3,44(sp)
c001ddb8:	02b12223          	sw	a1,36(sp)
c001ddbc:	02e12823          	sw	a4,48(sp)
c001ddc0:	02f12a23          	sw	a5,52(sp)
c001ddc4:	03012c23          	sw	a6,56(sp)
c001ddc8:	03112e23          	sw	a7,60(sp)
c001ddcc:	00832583          	lw	a1,8(t1)
c001ddd0:	02410693          	addi	a3,sp,36
c001ddd4:	00050613          	mv	a2,a0
c001ddd8:	00030513          	mv	a0,t1
c001dddc:	00112e23          	sw	ra,28(sp)
c001dde0:	00d12623          	sw	a3,12(sp)
c001dde4:	455020ef          	jal	ra,c0020a38 <_vfprintf_r>
c001dde8:	01c12083          	lw	ra,28(sp)
c001ddec:	04010113          	addi	sp,sp,64
c001ddf0:	00008067          	ret

c001ddf4 <_puts_r>:
c001ddf4:	fc010113          	addi	sp,sp,-64
c001ddf8:	02812c23          	sw	s0,56(sp)
c001ddfc:	00050413          	mv	s0,a0
c001de00:	00058513          	mv	a0,a1
c001de04:	02912a23          	sw	s1,52(sp)
c001de08:	02112e23          	sw	ra,60(sp)
c001de0c:	00058493          	mv	s1,a1
c001de10:	258000ef          	jal	ra,c001e068 <strlen>
c001de14:	c80027b7          	lui	a5,0xc8002
c001de18:	6d078793          	addi	a5,a5,1744 # c80026d0 <_end+0xfff7de50>
c001de1c:	02f12423          	sw	a5,40(sp)
c001de20:	00100793          	li	a5,1
c001de24:	02f12623          	sw	a5,44(sp)
c001de28:	03842703          	lw	a4,56(s0)
c001de2c:	02010793          	addi	a5,sp,32
c001de30:	00150693          	addi	a3,a0,1
c001de34:	00f12a23          	sw	a5,20(sp)
c001de38:	00200793          	li	a5,2
c001de3c:	02912023          	sw	s1,32(sp)
c001de40:	02a12223          	sw	a0,36(sp)
c001de44:	00d12e23          	sw	a3,28(sp)
c001de48:	00f12c23          	sw	a5,24(sp)
c001de4c:	00842583          	lw	a1,8(s0)
c001de50:	04070e63          	beqz	a4,c001deac <_puts_r+0xb8>
c001de54:	00c59783          	lh	a5,12(a1)
c001de58:	01279713          	slli	a4,a5,0x12
c001de5c:	02074263          	bltz	a4,c001de80 <_puts_r+0x8c>
c001de60:	0645a703          	lw	a4,100(a1)
c001de64:	000026b7          	lui	a3,0x2
c001de68:	00d7e7b3          	or	a5,a5,a3
c001de6c:	ffffe6b7          	lui	a3,0xffffe
c001de70:	fff68693          	addi	a3,a3,-1 # ffffdfff <_end+0x37f7977f>
c001de74:	00d77733          	and	a4,a4,a3
c001de78:	00f59623          	sh	a5,12(a1)
c001de7c:	06e5a223          	sw	a4,100(a1)
c001de80:	01410613          	addi	a2,sp,20
c001de84:	00040513          	mv	a0,s0
c001de88:	2e4060ef          	jal	ra,c002416c <__sfvwrite_r>
c001de8c:	03c12083          	lw	ra,60(sp)
c001de90:	03812403          	lw	s0,56(sp)
c001de94:	00a03533          	snez	a0,a0
c001de98:	40a00533          	neg	a0,a0
c001de9c:	03412483          	lw	s1,52(sp)
c001dea0:	00a56513          	ori	a0,a0,10
c001dea4:	04010113          	addi	sp,sp,64
c001dea8:	00008067          	ret
c001deac:	00040513          	mv	a0,s0
c001deb0:	00b12623          	sw	a1,12(sp)
c001deb4:	61d050ef          	jal	ra,c0023cd0 <__sinit>
c001deb8:	00c12583          	lw	a1,12(sp)
c001debc:	f99ff06f          	j	c001de54 <_puts_r+0x60>

c001dec0 <puts>:
c001dec0:	c80037b7          	lui	a5,0xc8003
c001dec4:	00050593          	mv	a1,a0
c001dec8:	98c7a503          	lw	a0,-1652(a5) # c800298c <_end+0xfff7e10c>
c001decc:	f29ff06f          	j	c001ddf4 <_puts_r>

c001ded0 <_sprintf_r>:
c001ded0:	f6010113          	addi	sp,sp,-160
c001ded4:	08c10e93          	addi	t4,sp,140
c001ded8:	08f12a23          	sw	a5,148(sp)
c001dedc:	80000337          	lui	t1,0x80000
c001dee0:	ffff07b7          	lui	a5,0xffff0
c001dee4:	00058e13          	mv	t3,a1
c001dee8:	fff34313          	not	t1,t1
c001deec:	08d12623          	sw	a3,140(sp)
c001def0:	20878793          	addi	a5,a5,520 # ffff0208 <_end+0x37f6b988>
c001def4:	00810593          	addi	a1,sp,8
c001def8:	000e8693          	mv	a3,t4
c001defc:	06112e23          	sw	ra,124(sp)
c001df00:	00f12a23          	sw	a5,20(sp)
c001df04:	08e12823          	sw	a4,144(sp)
c001df08:	09012c23          	sw	a6,152(sp)
c001df0c:	09112e23          	sw	a7,156(sp)
c001df10:	01c12423          	sw	t3,8(sp)
c001df14:	01c12c23          	sw	t3,24(sp)
c001df18:	00612e23          	sw	t1,28(sp)
c001df1c:	00612823          	sw	t1,16(sp)
c001df20:	01d12223          	sw	t4,4(sp)
c001df24:	1d0000ef          	jal	ra,c001e0f4 <_svfprintf_r>
c001df28:	00812783          	lw	a5,8(sp)
c001df2c:	00078023          	sb	zero,0(a5)
c001df30:	07c12083          	lw	ra,124(sp)
c001df34:	0a010113          	addi	sp,sp,160
c001df38:	00008067          	ret

c001df3c <sprintf>:
c001df3c:	00050e13          	mv	t3,a0
c001df40:	c8003537          	lui	a0,0xc8003
c001df44:	f6010113          	addi	sp,sp,-160
c001df48:	98c52503          	lw	a0,-1652(a0) # c800298c <_end+0xfff7e10c>
c001df4c:	08810e93          	addi	t4,sp,136
c001df50:	08f12a23          	sw	a5,148(sp)
c001df54:	80000337          	lui	t1,0x80000
c001df58:	ffff07b7          	lui	a5,0xffff0
c001df5c:	fff34313          	not	t1,t1
c001df60:	08c12423          	sw	a2,136(sp)
c001df64:	08d12623          	sw	a3,140(sp)
c001df68:	20878793          	addi	a5,a5,520 # ffff0208 <_end+0x37f6b988>
c001df6c:	00058613          	mv	a2,a1
c001df70:	000e8693          	mv	a3,t4
c001df74:	00810593          	addi	a1,sp,8
c001df78:	06112e23          	sw	ra,124(sp)
c001df7c:	00f12a23          	sw	a5,20(sp)
c001df80:	08e12823          	sw	a4,144(sp)
c001df84:	09012c23          	sw	a6,152(sp)
c001df88:	09112e23          	sw	a7,156(sp)
c001df8c:	01c12423          	sw	t3,8(sp)
c001df90:	01c12c23          	sw	t3,24(sp)
c001df94:	00612e23          	sw	t1,28(sp)
c001df98:	00612823          	sw	t1,16(sp)
c001df9c:	01d12223          	sw	t4,4(sp)
c001dfa0:	154000ef          	jal	ra,c001e0f4 <_svfprintf_r>
c001dfa4:	00812783          	lw	a5,8(sp)
c001dfa8:	00078023          	sb	zero,0(a5)
c001dfac:	07c12083          	lw	ra,124(sp)
c001dfb0:	0a010113          	addi	sp,sp,160
c001dfb4:	00008067          	ret

c001dfb8 <strcpy>:
c001dfb8:	00b567b3          	or	a5,a0,a1
c001dfbc:	0037f793          	andi	a5,a5,3
c001dfc0:	08079263          	bnez	a5,c001e044 <strcpy+0x8c>
c001dfc4:	0005a703          	lw	a4,0(a1)
c001dfc8:	7f7f86b7          	lui	a3,0x7f7f8
c001dfcc:	f7f68693          	addi	a3,a3,-129 # 7f7f7f7f <_DMEM_LENGTH+0x7eff7f7f>
c001dfd0:	00d777b3          	and	a5,a4,a3
c001dfd4:	00d787b3          	add	a5,a5,a3
c001dfd8:	00e7e7b3          	or	a5,a5,a4
c001dfdc:	00d7e7b3          	or	a5,a5,a3
c001dfe0:	fff00613          	li	a2,-1
c001dfe4:	06c79e63          	bne	a5,a2,c001e060 <strcpy+0xa8>
c001dfe8:	00050613          	mv	a2,a0
c001dfec:	fff00813          	li	a6,-1
c001dff0:	00e62023          	sw	a4,0(a2)
c001dff4:	0045a703          	lw	a4,4(a1)
c001dff8:	00458593          	addi	a1,a1,4
c001dffc:	00460613          	addi	a2,a2,4
c001e000:	00d777b3          	and	a5,a4,a3
c001e004:	00d787b3          	add	a5,a5,a3
c001e008:	00e7e7b3          	or	a5,a5,a4
c001e00c:	00d7e7b3          	or	a5,a5,a3
c001e010:	ff0780e3          	beq	a5,a6,c001dff0 <strcpy+0x38>
c001e014:	0005c783          	lbu	a5,0(a1)
c001e018:	0015c703          	lbu	a4,1(a1)
c001e01c:	0025c683          	lbu	a3,2(a1)
c001e020:	00f60023          	sb	a5,0(a2)
c001e024:	00078a63          	beqz	a5,c001e038 <strcpy+0x80>
c001e028:	00e600a3          	sb	a4,1(a2)
c001e02c:	00070663          	beqz	a4,c001e038 <strcpy+0x80>
c001e030:	00d60123          	sb	a3,2(a2)
c001e034:	00069463          	bnez	a3,c001e03c <strcpy+0x84>
c001e038:	00008067          	ret
c001e03c:	000601a3          	sb	zero,3(a2)
c001e040:	00008067          	ret
c001e044:	00050793          	mv	a5,a0
c001e048:	0005c703          	lbu	a4,0(a1)
c001e04c:	00178793          	addi	a5,a5,1
c001e050:	00158593          	addi	a1,a1,1
c001e054:	fee78fa3          	sb	a4,-1(a5)
c001e058:	fe0718e3          	bnez	a4,c001e048 <strcpy+0x90>
c001e05c:	00008067          	ret
c001e060:	00050613          	mv	a2,a0
c001e064:	fb1ff06f          	j	c001e014 <strcpy+0x5c>

c001e068 <strlen>:
c001e068:	00357793          	andi	a5,a0,3
c001e06c:	00050713          	mv	a4,a0
c001e070:	04079c63          	bnez	a5,c001e0c8 <strlen+0x60>
c001e074:	7f7f86b7          	lui	a3,0x7f7f8
c001e078:	f7f68693          	addi	a3,a3,-129 # 7f7f7f7f <_DMEM_LENGTH+0x7eff7f7f>
c001e07c:	fff00593          	li	a1,-1
c001e080:	00072603          	lw	a2,0(a4)
c001e084:	00470713          	addi	a4,a4,4
c001e088:	00d677b3          	and	a5,a2,a3
c001e08c:	00d787b3          	add	a5,a5,a3
c001e090:	00c7e7b3          	or	a5,a5,a2
c001e094:	00d7e7b3          	or	a5,a5,a3
c001e098:	feb784e3          	beq	a5,a1,c001e080 <strlen+0x18>
c001e09c:	ffc74683          	lbu	a3,-4(a4)
c001e0a0:	ffd74603          	lbu	a2,-3(a4)
c001e0a4:	ffe74783          	lbu	a5,-2(a4)
c001e0a8:	40a70733          	sub	a4,a4,a0
c001e0ac:	04068063          	beqz	a3,c001e0ec <strlen+0x84>
c001e0b0:	02060a63          	beqz	a2,c001e0e4 <strlen+0x7c>
c001e0b4:	00f03533          	snez	a0,a5
c001e0b8:	00e50533          	add	a0,a0,a4
c001e0bc:	ffe50513          	addi	a0,a0,-2
c001e0c0:	00008067          	ret
c001e0c4:	fa0688e3          	beqz	a3,c001e074 <strlen+0xc>
c001e0c8:	00074783          	lbu	a5,0(a4)
c001e0cc:	00170713          	addi	a4,a4,1
c001e0d0:	00377693          	andi	a3,a4,3
c001e0d4:	fe0798e3          	bnez	a5,c001e0c4 <strlen+0x5c>
c001e0d8:	40a70733          	sub	a4,a4,a0
c001e0dc:	fff70513          	addi	a0,a4,-1
c001e0e0:	00008067          	ret
c001e0e4:	ffd70513          	addi	a0,a4,-3
c001e0e8:	00008067          	ret
c001e0ec:	ffc70513          	addi	a0,a4,-4
c001e0f0:	00008067          	ret

c001e0f4 <_svfprintf_r>:
c001e0f4:	e1010113          	addi	sp,sp,-496
c001e0f8:	1e112623          	sw	ra,492(sp)
c001e0fc:	1f212023          	sw	s2,480(sp)
c001e100:	1d812423          	sw	s8,456(sp)
c001e104:	1da12023          	sw	s10,448(sp)
c001e108:	00058c13          	mv	s8,a1
c001e10c:	00060913          	mv	s2,a2
c001e110:	00d12a23          	sw	a3,20(sp)
c001e114:	1e812423          	sw	s0,488(sp)
c001e118:	1e912223          	sw	s1,484(sp)
c001e11c:	1d312e23          	sw	s3,476(sp)
c001e120:	1d412c23          	sw	s4,472(sp)
c001e124:	1d512a23          	sw	s5,468(sp)
c001e128:	1d612823          	sw	s6,464(sp)
c001e12c:	1d712623          	sw	s7,460(sp)
c001e130:	1d912223          	sw	s9,452(sp)
c001e134:	1bb12e23          	sw	s11,444(sp)
c001e138:	00050d13          	mv	s10,a0
c001e13c:	214090ef          	jal	ra,c0027350 <_localeconv_r>
c001e140:	00052783          	lw	a5,0(a0)
c001e144:	00078513          	mv	a0,a5
c001e148:	02f12823          	sw	a5,48(sp)
c001e14c:	f1dff0ef          	jal	ra,c001e068 <strlen>
c001e150:	00cc5783          	lhu	a5,12(s8)
c001e154:	0e012823          	sw	zero,240(sp)
c001e158:	0e012a23          	sw	zero,244(sp)
c001e15c:	0e012c23          	sw	zero,248(sp)
c001e160:	0e012e23          	sw	zero,252(sp)
c001e164:	0807f793          	andi	a5,a5,128
c001e168:	02a12623          	sw	a0,44(sp)
c001e16c:	00078863          	beqz	a5,c001e17c <_svfprintf_r+0x88>
c001e170:	010c2783          	lw	a5,16(s8)
c001e174:	00079463          	bnez	a5,c001e17c <_svfprintf_r+0x88>
c001e178:	5280106f          	j	c001f6a0 <_svfprintf_r+0x15ac>
c001e17c:	10c10793          	addi	a5,sp,268
c001e180:	0ef12223          	sw	a5,228(sp)
c001e184:	00078893          	mv	a7,a5
c001e188:	c80027b7          	lui	a5,0xc8002
c001e18c:	a6c78793          	addi	a5,a5,-1428 # c8001a6c <_end+0xfff7d1ec>
c001e190:	00f12c23          	sw	a5,24(sp)
c001e194:	c80027b7          	lui	a5,0xc8002
c001e198:	be878793          	addi	a5,a5,-1048 # c8001be8 <_end+0xfff7d368>
c001e19c:	00090b13          	mv	s6,s2
c001e1a0:	00f12423          	sw	a5,8(sp)
c001e1a4:	000b4783          	lbu	a5,0(s6)
c001e1a8:	0e012623          	sw	zero,236(sp)
c001e1ac:	0e012423          	sw	zero,232(sp)
c001e1b0:	02012023          	sw	zero,32(sp)
c001e1b4:	02012a23          	sw	zero,52(sp)
c001e1b8:	02012c23          	sw	zero,56(sp)
c001e1bc:	02012e23          	sw	zero,60(sp)
c001e1c0:	04012423          	sw	zero,72(sp)
c001e1c4:	04012623          	sw	zero,76(sp)
c001e1c8:	00012623          	sw	zero,12(sp)
c001e1cc:	22078463          	beqz	a5,c001e3f4 <_svfprintf_r+0x300>
c001e1d0:	000b0413          	mv	s0,s6
c001e1d4:	02500713          	li	a4,37
c001e1d8:	2ce78463          	beq	a5,a4,c001e4a0 <_svfprintf_r+0x3ac>
c001e1dc:	00144783          	lbu	a5,1(s0)
c001e1e0:	00140413          	addi	s0,s0,1
c001e1e4:	fe079ae3          	bnez	a5,c001e1d8 <_svfprintf_r+0xe4>
c001e1e8:	416404b3          	sub	s1,s0,s6
c001e1ec:	21640463          	beq	s0,s6,c001e3f4 <_svfprintf_r+0x300>
c001e1f0:	0ec12703          	lw	a4,236(sp)
c001e1f4:	0e812783          	lw	a5,232(sp)
c001e1f8:	0168a023          	sw	s6,0(a7)
c001e1fc:	00970733          	add	a4,a4,s1
c001e200:	00178793          	addi	a5,a5,1
c001e204:	0098a223          	sw	s1,4(a7)
c001e208:	0ee12623          	sw	a4,236(sp)
c001e20c:	0ef12423          	sw	a5,232(sp)
c001e210:	00700713          	li	a4,7
c001e214:	00888893          	addi	a7,a7,8
c001e218:	28f74c63          	blt	a4,a5,c001e4b0 <_svfprintf_r+0x3bc>
c001e21c:	00c12703          	lw	a4,12(sp)
c001e220:	00044783          	lbu	a5,0(s0)
c001e224:	00970733          	add	a4,a4,s1
c001e228:	00e12623          	sw	a4,12(sp)
c001e22c:	1c078463          	beqz	a5,c001e3f4 <_svfprintf_r+0x300>
c001e230:	00144483          	lbu	s1,1(s0)
c001e234:	0c0103a3          	sb	zero,199(sp)
c001e238:	00140413          	addi	s0,s0,1
c001e23c:	fff00d93          	li	s11,-1
c001e240:	00000993          	li	s3,0
c001e244:	00000a13          	li	s4,0
c001e248:	05a00913          	li	s2,90
c001e24c:	00900a93          	li	s5,9
c001e250:	02a00b93          	li	s7,42
c001e254:	00088c93          	mv	s9,a7
c001e258:	00140413          	addi	s0,s0,1
c001e25c:	fe048793          	addi	a5,s1,-32
c001e260:	04f96463          	bltu	s2,a5,c001e2a8 <_svfprintf_r+0x1b4>
c001e264:	01812703          	lw	a4,24(sp)
c001e268:	00279793          	slli	a5,a5,0x2
c001e26c:	00e787b3          	add	a5,a5,a4
c001e270:	0007a783          	lw	a5,0(a5)
c001e274:	00078067          	jr	a5
c001e278:	00000993          	li	s3,0
c001e27c:	fd048693          	addi	a3,s1,-48
c001e280:	00044483          	lbu	s1,0(s0)
c001e284:	00299793          	slli	a5,s3,0x2
c001e288:	013787b3          	add	a5,a5,s3
c001e28c:	00179793          	slli	a5,a5,0x1
c001e290:	00f689b3          	add	s3,a3,a5
c001e294:	fd048693          	addi	a3,s1,-48
c001e298:	00140413          	addi	s0,s0,1
c001e29c:	fedaf2e3          	bgeu	s5,a3,c001e280 <_svfprintf_r+0x18c>
c001e2a0:	fe048793          	addi	a5,s1,-32
c001e2a4:	fcf970e3          	bgeu	s2,a5,c001e264 <_svfprintf_r+0x170>
c001e2a8:	000c8893          	mv	a7,s9
c001e2ac:	14048463          	beqz	s1,c001e3f4 <_svfprintf_r+0x300>
c001e2b0:	14910623          	sb	s1,332(sp)
c001e2b4:	0c0103a3          	sb	zero,199(sp)
c001e2b8:	00100a93          	li	s5,1
c001e2bc:	00100c93          	li	s9,1
c001e2c0:	14c10b13          	addi	s6,sp,332
c001e2c4:	00012823          	sw	zero,16(sp)
c001e2c8:	00000d93          	li	s11,0
c001e2cc:	02012423          	sw	zero,40(sp)
c001e2d0:	02012223          	sw	zero,36(sp)
c001e2d4:	00012e23          	sw	zero,28(sp)
c001e2d8:	002a7b93          	andi	s7,s4,2
c001e2dc:	000b8463          	beqz	s7,c001e2e4 <_svfprintf_r+0x1f0>
c001e2e0:	002a8a93          	addi	s5,s5,2
c001e2e4:	084a7913          	andi	s2,s4,132
c001e2e8:	0ec12783          	lw	a5,236(sp)
c001e2ec:	00091663          	bnez	s2,c001e2f8 <_svfprintf_r+0x204>
c001e2f0:	415986b3          	sub	a3,s3,s5
c001e2f4:	5cd04ce3          	bgtz	a3,c001f0cc <_svfprintf_r+0xfd8>
c001e2f8:	0c714703          	lbu	a4,199(sp)
c001e2fc:	02070a63          	beqz	a4,c001e330 <_svfprintf_r+0x23c>
c001e300:	0e812703          	lw	a4,232(sp)
c001e304:	0c710693          	addi	a3,sp,199
c001e308:	00d8a023          	sw	a3,0(a7)
c001e30c:	00178793          	addi	a5,a5,1
c001e310:	00100693          	li	a3,1
c001e314:	00170713          	addi	a4,a4,1
c001e318:	00d8a223          	sw	a3,4(a7)
c001e31c:	0ef12623          	sw	a5,236(sp)
c001e320:	0ee12423          	sw	a4,232(sp)
c001e324:	00700693          	li	a3,7
c001e328:	00888893          	addi	a7,a7,8
c001e32c:	48e6c863          	blt	a3,a4,c001e7bc <_svfprintf_r+0x6c8>
c001e330:	020b8a63          	beqz	s7,c001e364 <_svfprintf_r+0x270>
c001e334:	0e812703          	lw	a4,232(sp)
c001e338:	0c810693          	addi	a3,sp,200
c001e33c:	00d8a023          	sw	a3,0(a7)
c001e340:	00278793          	addi	a5,a5,2
c001e344:	00200693          	li	a3,2
c001e348:	00170713          	addi	a4,a4,1
c001e34c:	00d8a223          	sw	a3,4(a7)
c001e350:	0ef12623          	sw	a5,236(sp)
c001e354:	0ee12423          	sw	a4,232(sp)
c001e358:	00700693          	li	a3,7
c001e35c:	00888893          	addi	a7,a7,8
c001e360:	64e6cee3          	blt	a3,a4,c001f1bc <_svfprintf_r+0x10c8>
c001e364:	08000713          	li	a4,128
c001e368:	3ce900e3          	beq	s2,a4,c001ef28 <_svfprintf_r+0xe34>
c001e36c:	419d8db3          	sub	s11,s11,s9
c001e370:	47b04ee3          	bgtz	s11,c001efec <_svfprintf_r+0xef8>
c001e374:	100a7713          	andi	a4,s4,256
c001e378:	26071ae3          	bnez	a4,c001edec <_svfprintf_r+0xcf8>
c001e37c:	0e812703          	lw	a4,232(sp)
c001e380:	019787b3          	add	a5,a5,s9
c001e384:	0168a023          	sw	s6,0(a7)
c001e388:	00170713          	addi	a4,a4,1
c001e38c:	0198a223          	sw	s9,4(a7)
c001e390:	0ef12623          	sw	a5,236(sp)
c001e394:	0ee12423          	sw	a4,232(sp)
c001e398:	00700693          	li	a3,7
c001e39c:	54e6cc63          	blt	a3,a4,c001e8f4 <_svfprintf_r+0x800>
c001e3a0:	00888893          	addi	a7,a7,8
c001e3a4:	004a7a13          	andi	s4,s4,4
c001e3a8:	000a0663          	beqz	s4,c001e3b4 <_svfprintf_r+0x2c0>
c001e3ac:	415984b3          	sub	s1,s3,s5
c001e3b0:	56904263          	bgtz	s1,c001e914 <_svfprintf_r+0x820>
c001e3b4:	0159d463          	bge	s3,s5,c001e3bc <_svfprintf_r+0x2c8>
c001e3b8:	000a8993          	mv	s3,s5
c001e3bc:	00c12703          	lw	a4,12(sp)
c001e3c0:	01370733          	add	a4,a4,s3
c001e3c4:	00e12623          	sw	a4,12(sp)
c001e3c8:	4c079ce3          	bnez	a5,c001f0a0 <_svfprintf_r+0xfac>
c001e3cc:	01012783          	lw	a5,16(sp)
c001e3d0:	0e012423          	sw	zero,232(sp)
c001e3d4:	00078863          	beqz	a5,c001e3e4 <_svfprintf_r+0x2f0>
c001e3d8:	01012583          	lw	a1,16(sp)
c001e3dc:	000d0513          	mv	a0,s10
c001e3e0:	279050ef          	jal	ra,c0023e58 <_free_r>
c001e3e4:	10c10893          	addi	a7,sp,268
c001e3e8:	00040b13          	mv	s6,s0
c001e3ec:	000b4783          	lbu	a5,0(s6)
c001e3f0:	de0790e3          	bnez	a5,c001e1d0 <_svfprintf_r+0xdc>
c001e3f4:	0ec12783          	lw	a5,236(sp)
c001e3f8:	00078463          	beqz	a5,c001e400 <_svfprintf_r+0x30c>
c001e3fc:	3090106f          	j	c001ff04 <_svfprintf_r+0x1e10>
c001e400:	00cc5783          	lhu	a5,12(s8)
c001e404:	0407f793          	andi	a5,a5,64
c001e408:	00078463          	beqz	a5,c001e410 <_svfprintf_r+0x31c>
c001e40c:	3840206f          	j	c0020790 <_svfprintf_r+0x269c>
c001e410:	1ec12083          	lw	ra,492(sp)
c001e414:	1e812403          	lw	s0,488(sp)
c001e418:	00c12503          	lw	a0,12(sp)
c001e41c:	1e412483          	lw	s1,484(sp)
c001e420:	1e012903          	lw	s2,480(sp)
c001e424:	1dc12983          	lw	s3,476(sp)
c001e428:	1d812a03          	lw	s4,472(sp)
c001e42c:	1d412a83          	lw	s5,468(sp)
c001e430:	1d012b03          	lw	s6,464(sp)
c001e434:	1cc12b83          	lw	s7,460(sp)
c001e438:	1c812c03          	lw	s8,456(sp)
c001e43c:	1c412c83          	lw	s9,452(sp)
c001e440:	1c012d03          	lw	s10,448(sp)
c001e444:	1bc12d83          	lw	s11,444(sp)
c001e448:	1f010113          	addi	sp,sp,496
c001e44c:	00008067          	ret
c001e450:	000d0513          	mv	a0,s10
c001e454:	6fd080ef          	jal	ra,c0027350 <_localeconv_r>
c001e458:	00452783          	lw	a5,4(a0)
c001e45c:	00078513          	mv	a0,a5
c001e460:	04f12623          	sw	a5,76(sp)
c001e464:	c05ff0ef          	jal	ra,c001e068 <strlen>
c001e468:	00050793          	mv	a5,a0
c001e46c:	000d0513          	mv	a0,s10
c001e470:	00078493          	mv	s1,a5
c001e474:	04f12423          	sw	a5,72(sp)
c001e478:	6d9080ef          	jal	ra,c0027350 <_localeconv_r>
c001e47c:	00852783          	lw	a5,8(a0)
c001e480:	02f12e23          	sw	a5,60(sp)
c001e484:	00048463          	beqz	s1,c001e48c <_svfprintf_r+0x398>
c001e488:	09c0106f          	j	c001f524 <_svfprintf_r+0x1430>
c001e48c:	00044483          	lbu	s1,0(s0)
c001e490:	dc9ff06f          	j	c001e258 <_svfprintf_r+0x164>
c001e494:	00044483          	lbu	s1,0(s0)
c001e498:	020a6a13          	ori	s4,s4,32
c001e49c:	dbdff06f          	j	c001e258 <_svfprintf_r+0x164>
c001e4a0:	416404b3          	sub	s1,s0,s6
c001e4a4:	d56416e3          	bne	s0,s6,c001e1f0 <_svfprintf_r+0xfc>
c001e4a8:	00044783          	lbu	a5,0(s0)
c001e4ac:	d81ff06f          	j	c001e22c <_svfprintf_r+0x138>
c001e4b0:	0e410613          	addi	a2,sp,228
c001e4b4:	000c0593          	mv	a1,s8
c001e4b8:	000d0513          	mv	a0,s10
c001e4bc:	0310b0ef          	jal	ra,c0029cec <__ssprint_r>
c001e4c0:	f40510e3          	bnez	a0,c001e400 <_svfprintf_r+0x30c>
c001e4c4:	10c10893          	addi	a7,sp,268
c001e4c8:	d55ff06f          	j	c001e21c <_svfprintf_r+0x128>
c001e4cc:	008a7793          	andi	a5,s4,8
c001e4d0:	000c8893          	mv	a7,s9
c001e4d4:	00078463          	beqz	a5,c001e4dc <_svfprintf_r+0x3e8>
c001e4d8:	0880106f          	j	c001f560 <_svfprintf_r+0x146c>
c001e4dc:	01412783          	lw	a5,20(sp)
c001e4e0:	0b010513          	addi	a0,sp,176
c001e4e4:	01912823          	sw	s9,16(sp)
c001e4e8:	00778793          	addi	a5,a5,7
c001e4ec:	ff87f793          	andi	a5,a5,-8
c001e4f0:	0007a583          	lw	a1,0(a5)
c001e4f4:	0047a603          	lw	a2,4(a5)
c001e4f8:	00878793          	addi	a5,a5,8
c001e4fc:	00f12a23          	sw	a5,20(sp)
c001e500:	12c130ef          	jal	ra,c003162c <__extenddftf2>
c001e504:	0b012783          	lw	a5,176(sp)
c001e508:	01012883          	lw	a7,16(sp)
c001e50c:	0ef12823          	sw	a5,240(sp)
c001e510:	0b412783          	lw	a5,180(sp)
c001e514:	0ef12a23          	sw	a5,244(sp)
c001e518:	0b812783          	lw	a5,184(sp)
c001e51c:	0ef12c23          	sw	a5,248(sp)
c001e520:	0bc12783          	lw	a5,188(sp)
c001e524:	0ef12e23          	sw	a5,252(sp)
c001e528:	0f010513          	addi	a0,sp,240
c001e52c:	01112823          	sw	a7,16(sp)
c001e530:	5a1080ef          	jal	ra,c00272d0 <_ldcheck>
c001e534:	0ca12623          	sw	a0,204(sp)
c001e538:	00200793          	li	a5,2
c001e53c:	01012883          	lw	a7,16(sp)
c001e540:	00f51463          	bne	a0,a5,c001e548 <_svfprintf_r+0x454>
c001e544:	6380106f          	j	c001fb7c <_svfprintf_r+0x1a88>
c001e548:	00100793          	li	a5,1
c001e54c:	00f51463          	bne	a0,a5,c001e554 <_svfprintf_r+0x460>
c001e550:	02d0106f          	j	c001fd7c <_svfprintf_r+0x1c88>
c001e554:	06100793          	li	a5,97
c001e558:	00f49463          	bne	s1,a5,c001e560 <_svfprintf_r+0x46c>
c001e55c:	20c0206f          	j	c0020768 <_svfprintf_r+0x2674>
c001e560:	04100793          	li	a5,65
c001e564:	00f49463          	bne	s1,a5,c001e56c <_svfprintf_r+0x478>
c001e568:	5090106f          	j	c0020270 <_svfprintf_r+0x217c>
c001e56c:	fdf4f713          	andi	a4,s1,-33
c001e570:	fff00793          	li	a5,-1
c001e574:	02e12423          	sw	a4,40(sp)
c001e578:	00fd9463          	bne	s11,a5,c001e580 <_svfprintf_r+0x48c>
c001e57c:	1cd0106f          	j	c001ff48 <_svfprintf_r+0x1e54>
c001e580:	04700793          	li	a5,71
c001e584:	00f71463          	bne	a4,a5,c001e58c <_svfprintf_r+0x498>
c001e588:	1f80206f          	j	c0020780 <_svfprintf_r+0x268c>
c001e58c:	0fc12b83          	lw	s7,252(sp)
c001e590:	05412823          	sw	s4,80(sp)
c001e594:	0f012e03          	lw	t3,240(sp)
c001e598:	0f412e83          	lw	t4,244(sp)
c001e59c:	0f812f03          	lw	t5,248(sp)
c001e5a0:	100a6793          	ori	a5,s4,256
c001e5a4:	000bd463          	bgez	s7,c001e5ac <_svfprintf_r+0x4b8>
c001e5a8:	0580206f          	j	c0020600 <_svfprintf_r+0x250c>
c001e5ac:	04012c23          	sw	zero,88(sp)
c001e5b0:	00078a13          	mv	s4,a5
c001e5b4:	00012823          	sw	zero,16(sp)
c001e5b8:	02812703          	lw	a4,40(sp)
c001e5bc:	04600793          	li	a5,70
c001e5c0:	00f71463          	bne	a4,a5,c001e5c8 <_svfprintf_r+0x4d4>
c001e5c4:	2a10106f          	j	c0020064 <_svfprintf_r+0x1f70>
c001e5c8:	04500793          	li	a5,69
c001e5cc:	05112023          	sw	a7,64(sp)
c001e5d0:	00f71463          	bne	a4,a5,c001e5d8 <_svfprintf_r+0x4e4>
c001e5d4:	0540206f          	j	c0020628 <_svfprintf_r+0x2534>
c001e5d8:	0b010a93          	addi	s5,sp,176
c001e5dc:	0d010793          	addi	a5,sp,208
c001e5e0:	0cc10713          	addi	a4,sp,204
c001e5e4:	0dc10813          	addi	a6,sp,220
c001e5e8:	000d8693          	mv	a3,s11
c001e5ec:	00200613          	li	a2,2
c001e5f0:	000a8593          	mv	a1,s5
c001e5f4:	000d0513          	mv	a0,s10
c001e5f8:	0bc12823          	sw	t3,176(sp)
c001e5fc:	03c12223          	sw	t3,36(sp)
c001e600:	0bd12a23          	sw	t4,180(sp)
c001e604:	03d12023          	sw	t4,32(sp)
c001e608:	0be12c23          	sw	t5,184(sp)
c001e60c:	01e12e23          	sw	t5,28(sp)
c001e610:	0b712e23          	sw	s7,188(sp)
c001e614:	22d070ef          	jal	ra,c0026040 <_ldtoa_r>
c001e618:	02812703          	lw	a4,40(sp)
c001e61c:	04700793          	li	a5,71
c001e620:	01c12f03          	lw	t5,28(sp)
c001e624:	02012e83          	lw	t4,32(sp)
c001e628:	02412e03          	lw	t3,36(sp)
c001e62c:	04012883          	lw	a7,64(sp)
c001e630:	00050b13          	mv	s6,a0
c001e634:	00f70463          	beq	a4,a5,c001e63c <_svfprintf_r+0x548>
c001e638:	3f80206f          	j	c0020a30 <_svfprintf_r+0x293c>
c001e63c:	05012783          	lw	a5,80(sp)
c001e640:	0017f793          	andi	a5,a5,1
c001e644:	00078463          	beqz	a5,c001e64c <_svfprintf_r+0x558>
c001e648:	0440206f          	j	c002068c <_svfprintf_r+0x2598>
c001e64c:	0dc12683          	lw	a3,220(sp)
c001e650:	416687b3          	sub	a5,a3,s6
c001e654:	02f12023          	sw	a5,32(sp)
c001e658:	0cc12703          	lw	a4,204(sp)
c001e65c:	04700793          	li	a5,71
c001e660:	00e12e23          	sw	a4,28(sp)
c001e664:	02812703          	lw	a4,40(sp)
c001e668:	00f71463          	bne	a4,a5,c001e670 <_svfprintf_r+0x57c>
c001e66c:	1150106f          	j	c001ff80 <_svfprintf_r+0x1e8c>
c001e670:	02812703          	lw	a4,40(sp)
c001e674:	04600793          	li	a5,70
c001e678:	00f71463          	bne	a4,a5,c001e680 <_svfprintf_r+0x58c>
c001e67c:	3d10106f          	j	c002024c <_svfprintf_r+0x2158>
c001e680:	01c12783          	lw	a5,28(sp)
c001e684:	02812583          	lw	a1,40(sp)
c001e688:	04100613          	li	a2,65
c001e68c:	fff78793          	addi	a5,a5,-1
c001e690:	0cf12623          	sw	a5,204(sp)
c001e694:	0ff4f713          	andi	a4,s1,255
c001e698:	00000693          	li	a3,0
c001e69c:	00c59863          	bne	a1,a2,c001e6ac <_svfprintf_r+0x5b8>
c001e6a0:	00f70713          	addi	a4,a4,15
c001e6a4:	0ff77713          	andi	a4,a4,255
c001e6a8:	00100693          	li	a3,1
c001e6ac:	0ce10a23          	sb	a4,212(sp)
c001e6b0:	02b00713          	li	a4,43
c001e6b4:	0007da63          	bgez	a5,c001e6c8 <_svfprintf_r+0x5d4>
c001e6b8:	01c12703          	lw	a4,28(sp)
c001e6bc:	00100793          	li	a5,1
c001e6c0:	40e787b3          	sub	a5,a5,a4
c001e6c4:	02d00713          	li	a4,45
c001e6c8:	0ce10aa3          	sb	a4,213(sp)
c001e6cc:	00900713          	li	a4,9
c001e6d0:	00f74463          	blt	a4,a5,c001e6d8 <_svfprintf_r+0x5e4>
c001e6d4:	0dc0206f          	j	c00207b0 <_svfprintf_r+0x26bc>
c001e6d8:	0e310513          	addi	a0,sp,227
c001e6dc:	00050593          	mv	a1,a0
c001e6e0:	00a00693          	li	a3,10
c001e6e4:	06300e13          	li	t3,99
c001e6e8:	02d7e733          	rem	a4,a5,a3
c001e6ec:	00058613          	mv	a2,a1
c001e6f0:	00078813          	mv	a6,a5
c001e6f4:	fff58593          	addi	a1,a1,-1
c001e6f8:	03070713          	addi	a4,a4,48
c001e6fc:	fee60fa3          	sb	a4,-1(a2)
c001e700:	02d7c7b3          	div	a5,a5,a3
c001e704:	ff0e42e3          	blt	t3,a6,c001e6e8 <_svfprintf_r+0x5f4>
c001e708:	03078793          	addi	a5,a5,48
c001e70c:	0ff7f693          	andi	a3,a5,255
c001e710:	fed58fa3          	sb	a3,-1(a1)
c001e714:	ffe60793          	addi	a5,a2,-2
c001e718:	00a7e463          	bltu	a5,a0,c001e720 <_svfprintf_r+0x62c>
c001e71c:	2fc0206f          	j	c0020a18 <_svfprintf_r+0x2924>
c001e720:	0d610713          	addi	a4,sp,214
c001e724:	0080006f          	j	c001e72c <_svfprintf_r+0x638>
c001e728:	0007c683          	lbu	a3,0(a5)
c001e72c:	00d70023          	sb	a3,0(a4)
c001e730:	00178793          	addi	a5,a5,1
c001e734:	00170713          	addi	a4,a4,1
c001e738:	fea798e3          	bne	a5,a0,c001e728 <_svfprintf_r+0x634>
c001e73c:	0e510793          	addi	a5,sp,229
c001e740:	0d610713          	addi	a4,sp,214
c001e744:	40c787b3          	sub	a5,a5,a2
c001e748:	00f707b3          	add	a5,a4,a5
c001e74c:	0d410713          	addi	a4,sp,212
c001e750:	40e787b3          	sub	a5,a5,a4
c001e754:	02f12c23          	sw	a5,56(sp)
c001e758:	03812683          	lw	a3,56(sp)
c001e75c:	02012703          	lw	a4,32(sp)
c001e760:	00100793          	li	a5,1
c001e764:	00e68cb3          	add	s9,a3,a4
c001e768:	00e7c463          	blt	a5,a4,c001e770 <_svfprintf_r+0x67c>
c001e76c:	2100206f          	j	c002097c <_svfprintf_r+0x2888>
c001e770:	02c12783          	lw	a5,44(sp)
c001e774:	00fc8cb3          	add	s9,s9,a5
c001e778:	05012783          	lw	a5,80(sp)
c001e77c:	fffcca93          	not	s5,s9
c001e780:	41fada93          	srai	s5,s5,0x1f
c001e784:	bff7fa13          	andi	s4,a5,-1025
c001e788:	100a6a13          	ori	s4,s4,256
c001e78c:	015cfab3          	and	s5,s9,s5
c001e790:	02012423          	sw	zero,40(sp)
c001e794:	02012223          	sw	zero,36(sp)
c001e798:	00012e23          	sw	zero,28(sp)
c001e79c:	05812783          	lw	a5,88(sp)
c001e7a0:	00079463          	bnez	a5,c001e7a8 <_svfprintf_r+0x6b4>
c001e7a4:	0510106f          	j	c001fff4 <_svfprintf_r+0x1f00>
c001e7a8:	02d00793          	li	a5,45
c001e7ac:	0cf103a3          	sb	a5,199(sp)
c001e7b0:	00000d93          	li	s11,0
c001e7b4:	001a8a93          	addi	s5,s5,1
c001e7b8:	b21ff06f          	j	c001e2d8 <_svfprintf_r+0x1e4>
c001e7bc:	0e410613          	addi	a2,sp,228
c001e7c0:	000c0593          	mv	a1,s8
c001e7c4:	000d0513          	mv	a0,s10
c001e7c8:	5240b0ef          	jal	ra,c0029cec <__ssprint_r>
c001e7cc:	0e0514e3          	bnez	a0,c001f0b4 <_svfprintf_r+0xfc0>
c001e7d0:	0ec12783          	lw	a5,236(sp)
c001e7d4:	10c10893          	addi	a7,sp,268
c001e7d8:	b59ff06f          	j	c001e330 <_svfprintf_r+0x23c>
c001e7dc:	0e812703          	lw	a4,232(sp)
c001e7e0:	00178c93          	addi	s9,a5,1
c001e7e4:	02012783          	lw	a5,32(sp)
c001e7e8:	00100693          	li	a3,1
c001e7ec:	0168a023          	sw	s6,0(a7)
c001e7f0:	00170493          	addi	s1,a4,1
c001e7f4:	00888913          	addi	s2,a7,8
c001e7f8:	36f6d8e3          	bge	a3,a5,c001f368 <_svfprintf_r+0x1274>
c001e7fc:	00100793          	li	a5,1
c001e800:	00f8a223          	sw	a5,4(a7)
c001e804:	0f912623          	sw	s9,236(sp)
c001e808:	0e912423          	sw	s1,232(sp)
c001e80c:	00700793          	li	a5,7
c001e810:	4a97c2e3          	blt	a5,s1,c001f4b4 <_svfprintf_r+0x13c0>
c001e814:	02c12783          	lw	a5,44(sp)
c001e818:	03012703          	lw	a4,48(sp)
c001e81c:	00148493          	addi	s1,s1,1
c001e820:	00fc8cb3          	add	s9,s9,a5
c001e824:	00f92223          	sw	a5,4(s2)
c001e828:	00e92023          	sw	a4,0(s2)
c001e82c:	0f912623          	sw	s9,236(sp)
c001e830:	0e912423          	sw	s1,232(sp)
c001e834:	00700793          	li	a5,7
c001e838:	00890913          	addi	s2,s2,8
c001e83c:	4897cee3          	blt	a5,s1,c001f4d8 <_svfprintf_r+0x13e4>
c001e840:	0f012783          	lw	a5,240(sp)
c001e844:	00148693          	addi	a3,s1,1
c001e848:	0a010593          	addi	a1,sp,160
c001e84c:	0af12823          	sw	a5,176(sp)
c001e850:	0f412783          	lw	a5,244(sp)
c001e854:	0b010513          	addi	a0,sp,176
c001e858:	00d12e23          	sw	a3,28(sp)
c001e85c:	0af12a23          	sw	a5,180(sp)
c001e860:	0f812783          	lw	a5,248(sp)
c001e864:	0a012023          	sw	zero,160(sp)
c001e868:	0a012223          	sw	zero,164(sp)
c001e86c:	0af12c23          	sw	a5,184(sp)
c001e870:	0fc12783          	lw	a5,252(sp)
c001e874:	0a012423          	sw	zero,168(sp)
c001e878:	0a012623          	sw	zero,172(sp)
c001e87c:	0af12e23          	sw	a5,188(sp)
c001e880:	2d8100ef          	jal	ra,c002eb58 <__eqtf2>
c001e884:	01c12683          	lw	a3,28(sp)
c001e888:	02012783          	lw	a5,32(sp)
c001e88c:	00890893          	addi	a7,s2,8
c001e890:	00068713          	mv	a4,a3
c001e894:	fff78d93          	addi	s11,a5,-1
c001e898:	2e050ce3          	beqz	a0,c001f390 <_svfprintf_r+0x129c>
c001e89c:	001b0813          	addi	a6,s6,1
c001e8a0:	01bc8cb3          	add	s9,s9,s11
c001e8a4:	01092023          	sw	a6,0(s2)
c001e8a8:	01b92223          	sw	s11,4(s2)
c001e8ac:	0f912623          	sw	s9,236(sp)
c001e8b0:	0ed12423          	sw	a3,232(sp)
c001e8b4:	00700793          	li	a5,7
c001e8b8:	00d7d463          	bge	a5,a3,c001e8c0 <_svfprintf_r+0x7cc>
c001e8bc:	0600106f          	j	c001f91c <_svfprintf_r+0x1828>
c001e8c0:	01090793          	addi	a5,s2,16
c001e8c4:	00248713          	addi	a4,s1,2
c001e8c8:	00088913          	mv	s2,a7
c001e8cc:	00078893          	mv	a7,a5
c001e8d0:	03812603          	lw	a2,56(sp)
c001e8d4:	0d410693          	addi	a3,sp,212
c001e8d8:	00d92023          	sw	a3,0(s2)
c001e8dc:	00cc87b3          	add	a5,s9,a2
c001e8e0:	00c92223          	sw	a2,4(s2)
c001e8e4:	0ef12623          	sw	a5,236(sp)
c001e8e8:	0ee12423          	sw	a4,232(sp)
c001e8ec:	00700693          	li	a3,7
c001e8f0:	aae6dae3          	bge	a3,a4,c001e3a4 <_svfprintf_r+0x2b0>
c001e8f4:	0e410613          	addi	a2,sp,228
c001e8f8:	000c0593          	mv	a1,s8
c001e8fc:	000d0513          	mv	a0,s10
c001e900:	3ec0b0ef          	jal	ra,c0029cec <__ssprint_r>
c001e904:	7a051863          	bnez	a0,c001f0b4 <_svfprintf_r+0xfc0>
c001e908:	0ec12783          	lw	a5,236(sp)
c001e90c:	10c10893          	addi	a7,sp,268
c001e910:	a95ff06f          	j	c001e3a4 <_svfprintf_r+0x2b0>
c001e914:	01000693          	li	a3,16
c001e918:	0e812703          	lw	a4,232(sp)
c001e91c:	0096c463          	blt	a3,s1,c001e924 <_svfprintf_r+0x830>
c001e920:	4fd0106f          	j	c002061c <_svfprintf_r+0x2528>
c001e924:	c80026b7          	lui	a3,0xc8002
c001e928:	bd868e93          	addi	t4,a3,-1064 # c8001bd8 <_end+0xfff7d358>
c001e92c:	01000913          	li	s2,16
c001e930:	00700a13          	li	s4,7
c001e934:	000e8b13          	mv	s6,t4
c001e938:	00c0006f          	j	c001e944 <_svfprintf_r+0x850>
c001e93c:	ff048493          	addi	s1,s1,-16
c001e940:	04995663          	bge	s2,s1,c001e98c <_svfprintf_r+0x898>
c001e944:	01078793          	addi	a5,a5,16
c001e948:	00170713          	addi	a4,a4,1
c001e94c:	0168a023          	sw	s6,0(a7)
c001e950:	0128a223          	sw	s2,4(a7)
c001e954:	0ef12623          	sw	a5,236(sp)
c001e958:	0ee12423          	sw	a4,232(sp)
c001e95c:	00888893          	addi	a7,a7,8
c001e960:	fcea5ee3          	bge	s4,a4,c001e93c <_svfprintf_r+0x848>
c001e964:	0e410613          	addi	a2,sp,228
c001e968:	000c0593          	mv	a1,s8
c001e96c:	000d0513          	mv	a0,s10
c001e970:	37c0b0ef          	jal	ra,c0029cec <__ssprint_r>
c001e974:	74051063          	bnez	a0,c001f0b4 <_svfprintf_r+0xfc0>
c001e978:	ff048493          	addi	s1,s1,-16
c001e97c:	0ec12783          	lw	a5,236(sp)
c001e980:	0e812703          	lw	a4,232(sp)
c001e984:	10c10893          	addi	a7,sp,268
c001e988:	fa994ee3          	blt	s2,s1,c001e944 <_svfprintf_r+0x850>
c001e98c:	000b0e93          	mv	t4,s6
c001e990:	009787b3          	add	a5,a5,s1
c001e994:	00170713          	addi	a4,a4,1
c001e998:	01d8a023          	sw	t4,0(a7)
c001e99c:	0098a223          	sw	s1,4(a7)
c001e9a0:	0ef12623          	sw	a5,236(sp)
c001e9a4:	0ee12423          	sw	a4,232(sp)
c001e9a8:	00700693          	li	a3,7
c001e9ac:	a0e6d4e3          	bge	a3,a4,c001e3b4 <_svfprintf_r+0x2c0>
c001e9b0:	0e410613          	addi	a2,sp,228
c001e9b4:	000c0593          	mv	a1,s8
c001e9b8:	000d0513          	mv	a0,s10
c001e9bc:	3300b0ef          	jal	ra,c0029cec <__ssprint_r>
c001e9c0:	6e051a63          	bnez	a0,c001f0b4 <_svfprintf_r+0xfc0>
c001e9c4:	0ec12783          	lw	a5,236(sp)
c001e9c8:	9edff06f          	j	c001e3b4 <_svfprintf_r+0x2c0>
c001e9cc:	01412783          	lw	a5,20(sp)
c001e9d0:	0c0103a3          	sb	zero,199(sp)
c001e9d4:	000c8893          	mv	a7,s9
c001e9d8:	0007ab03          	lw	s6,0(a5)
c001e9dc:	00478913          	addi	s2,a5,4
c001e9e0:	000b1463          	bnez	s6,c001e9e8 <_svfprintf_r+0x8f4>
c001e9e4:	22c0106f          	j	c001fc10 <_svfprintf_r+0x1b1c>
c001e9e8:	fff00793          	li	a5,-1
c001e9ec:	4cfd8ee3          	beq	s11,a5,c001f6c8 <_svfprintf_r+0x15d4>
c001e9f0:	000d8613          	mv	a2,s11
c001e9f4:	00000593          	li	a1,0
c001e9f8:	000b0513          	mv	a0,s6
c001e9fc:	01912a23          	sw	s9,20(sp)
c001ea00:	4f8090ef          	jal	ra,c0027ef8 <memchr>
c001ea04:	00a12823          	sw	a0,16(sp)
c001ea08:	01412883          	lw	a7,20(sp)
c001ea0c:	00051463          	bnez	a0,c001ea14 <_svfprintf_r+0x920>
c001ea10:	7a00106f          	j	c00201b0 <_svfprintf_r+0x20bc>
c001ea14:	01012783          	lw	a5,16(sp)
c001ea18:	01212a23          	sw	s2,20(sp)
c001ea1c:	00012823          	sw	zero,16(sp)
c001ea20:	41678cb3          	sub	s9,a5,s6
c001ea24:	0c714783          	lbu	a5,199(sp)
c001ea28:	fffcca93          	not	s5,s9
c001ea2c:	41fada93          	srai	s5,s5,0x1f
c001ea30:	02012423          	sw	zero,40(sp)
c001ea34:	02012223          	sw	zero,36(sp)
c001ea38:	00012e23          	sw	zero,28(sp)
c001ea3c:	015cfab3          	and	s5,s9,s5
c001ea40:	00000d93          	li	s11,0
c001ea44:	88078ae3          	beqz	a5,c001e2d8 <_svfprintf_r+0x1e4>
c001ea48:	001a8a93          	addi	s5,s5,1
c001ea4c:	88dff06f          	j	c001e2d8 <_svfprintf_r+0x1e4>
c001ea50:	01412703          	lw	a4,20(sp)
c001ea54:	000c8893          	mv	a7,s9
c001ea58:	0c0103a3          	sb	zero,199(sp)
c001ea5c:	00072783          	lw	a5,0(a4)
c001ea60:	00470713          	addi	a4,a4,4
c001ea64:	00e12a23          	sw	a4,20(sp)
c001ea68:	14f10623          	sb	a5,332(sp)
c001ea6c:	00100a93          	li	s5,1
c001ea70:	00100c93          	li	s9,1
c001ea74:	14c10b13          	addi	s6,sp,332
c001ea78:	84dff06f          	j	c001e2c4 <_svfprintf_r+0x1d0>
c001ea7c:	00044483          	lbu	s1,0(s0)
c001ea80:	06800793          	li	a5,104
c001ea84:	40f486e3          	beq	s1,a5,c001f690 <_svfprintf_r+0x159c>
c001ea88:	040a6a13          	ori	s4,s4,64
c001ea8c:	fccff06f          	j	c001e258 <_svfprintf_r+0x164>
c001ea90:	01412683          	lw	a3,20(sp)
c001ea94:	020a7793          	andi	a5,s4,32
c001ea98:	000c8893          	mv	a7,s9
c001ea9c:	0006a703          	lw	a4,0(a3)
c001eaa0:	00468693          	addi	a3,a3,4
c001eaa4:	00d12a23          	sw	a3,20(sp)
c001eaa8:	2a0790e3          	bnez	a5,c001f548 <_svfprintf_r+0x1454>
c001eaac:	010a7793          	andi	a5,s4,16
c001eab0:	00078463          	beqz	a5,c001eab8 <_svfprintf_r+0x9c4>
c001eab4:	14c0106f          	j	c001fc00 <_svfprintf_r+0x1b0c>
c001eab8:	040a7793          	andi	a5,s4,64
c001eabc:	00078463          	beqz	a5,c001eac4 <_svfprintf_r+0x9d0>
c001eac0:	3d00106f          	j	c001fe90 <_svfprintf_r+0x1d9c>
c001eac4:	200a7a13          	andi	s4,s4,512
c001eac8:	000a1463          	bnez	s4,c001ead0 <_svfprintf_r+0x9dc>
c001eacc:	1340106f          	j	c001fc00 <_svfprintf_r+0x1b0c>
c001ead0:	00c12783          	lw	a5,12(sp)
c001ead4:	00040b13          	mv	s6,s0
c001ead8:	00f70023          	sb	a5,0(a4)
c001eadc:	911ff06f          	j	c001e3ec <_svfprintf_r+0x2f8>
c001eae0:	00044483          	lbu	s1,0(s0)
c001eae4:	06c00793          	li	a5,108
c001eae8:	36f48ce3          	beq	s1,a5,c001f660 <_svfprintf_r+0x156c>
c001eaec:	010a6a13          	ori	s4,s4,16
c001eaf0:	f68ff06f          	j	c001e258 <_svfprintf_r+0x164>
c001eaf4:	01412703          	lw	a4,20(sp)
c001eaf8:	ffff87b7          	lui	a5,0xffff8
c001eafc:	8307c793          	xori	a5,a5,-2000
c001eb00:	0cf11423          	sh	a5,200(sp)
c001eb04:	00470793          	addi	a5,a4,4
c001eb08:	000c8893          	mv	a7,s9
c001eb0c:	00f12a23          	sw	a5,20(sp)
c001eb10:	00072c83          	lw	s9,0(a4)
c001eb14:	c80027b7          	lui	a5,0xc8002
c001eb18:	6e478793          	addi	a5,a5,1764 # c80026e4 <_end+0xfff7de64>
c001eb1c:	02f12a23          	sw	a5,52(sp)
c001eb20:	00000913          	li	s2,0
c001eb24:	002a6b93          	ori	s7,s4,2
c001eb28:	00200793          	li	a5,2
c001eb2c:	07800493          	li	s1,120
c001eb30:	0c0103a3          	sb	zero,199(sp)
c001eb34:	fff00693          	li	a3,-1
c001eb38:	1edd8663          	beq	s11,a3,c001ed24 <_svfprintf_r+0xc30>
c001eb3c:	012ce6b3          	or	a3,s9,s2
c001eb40:	f7fbfa13          	andi	s4,s7,-129
c001eb44:	1c069e63          	bnez	a3,c001ed20 <_svfprintf_r+0xc2c>
c001eb48:	240d9463          	bnez	s11,c001ed90 <_svfprintf_r+0xc9c>
c001eb4c:	000796e3          	bnez	a5,c001f358 <_svfprintf_r+0x1264>
c001eb50:	001bfc93          	andi	s9,s7,1
c001eb54:	1b010b13          	addi	s6,sp,432
c001eb58:	1a0c9ee3          	bnez	s9,c001f514 <_svfprintf_r+0x1420>
c001eb5c:	0c714783          	lbu	a5,199(sp)
c001eb60:	000d8a93          	mv	s5,s11
c001eb64:	019dd463          	bge	s11,s9,c001eb6c <_svfprintf_r+0xa78>
c001eb68:	000c8a93          	mv	s5,s9
c001eb6c:	00012823          	sw	zero,16(sp)
c001eb70:	02012423          	sw	zero,40(sp)
c001eb74:	02012223          	sw	zero,36(sp)
c001eb78:	00012e23          	sw	zero,28(sp)
c001eb7c:	ec0796e3          	bnez	a5,c001ea48 <_svfprintf_r+0x954>
c001eb80:	f58ff06f          	j	c001e2d8 <_svfprintf_r+0x1e4>
c001eb84:	000c8893          	mv	a7,s9
c001eb88:	010a6a13          	ori	s4,s4,16
c001eb8c:	020a7793          	andi	a5,s4,32
c001eb90:	06078ae3          	beqz	a5,c001f404 <_svfprintf_r+0x1310>
c001eb94:	01412783          	lw	a5,20(sp)
c001eb98:	00778b13          	addi	s6,a5,7
c001eb9c:	ff8b7b13          	andi	s6,s6,-8
c001eba0:	000b2c83          	lw	s9,0(s6)
c001eba4:	004b2903          	lw	s2,4(s6)
c001eba8:	008b0793          	addi	a5,s6,8
c001ebac:	00f12a23          	sw	a5,20(sp)
c001ebb0:	bffa7b93          	andi	s7,s4,-1025
c001ebb4:	00000793          	li	a5,0
c001ebb8:	f79ff06f          	j	c001eb30 <_svfprintf_r+0xa3c>
c001ebbc:	000c8893          	mv	a7,s9
c001ebc0:	010a6b93          	ori	s7,s4,16
c001ebc4:	020bf793          	andi	a5,s7,32
c001ebc8:	0a078ee3          	beqz	a5,c001f484 <_svfprintf_r+0x1390>
c001ebcc:	01412783          	lw	a5,20(sp)
c001ebd0:	00778b13          	addi	s6,a5,7
c001ebd4:	ff8b7b13          	andi	s6,s6,-8
c001ebd8:	008b0793          	addi	a5,s6,8
c001ebdc:	00f12a23          	sw	a5,20(sp)
c001ebe0:	000b2c83          	lw	s9,0(s6)
c001ebe4:	004b2903          	lw	s2,4(s6)
c001ebe8:	00100793          	li	a5,1
c001ebec:	f45ff06f          	j	c001eb30 <_svfprintf_r+0xa3c>
c001ebf0:	00044483          	lbu	s1,0(s0)
c001ebf4:	080a6a13          	ori	s4,s4,128
c001ebf8:	e60ff06f          	j	c001e258 <_svfprintf_r+0x164>
c001ebfc:	00044483          	lbu	s1,0(s0)
c001ec00:	008a6a13          	ori	s4,s4,8
c001ec04:	e54ff06f          	j	c001e258 <_svfprintf_r+0x164>
c001ec08:	000c8893          	mv	a7,s9
c001ec0c:	010a6a13          	ori	s4,s4,16
c001ec10:	020a7793          	andi	a5,s4,32
c001ec14:	00078ee3          	beqz	a5,c001f430 <_svfprintf_r+0x133c>
c001ec18:	01412783          	lw	a5,20(sp)
c001ec1c:	00778b13          	addi	s6,a5,7
c001ec20:	ff8b7b13          	andi	s6,s6,-8
c001ec24:	004b2783          	lw	a5,4(s6)
c001ec28:	000b2c83          	lw	s9,0(s6)
c001ec2c:	008b0713          	addi	a4,s6,8
c001ec30:	00e12a23          	sw	a4,20(sp)
c001ec34:	00078913          	mv	s2,a5
c001ec38:	0207c4e3          	bltz	a5,c001f460 <_svfprintf_r+0x136c>
c001ec3c:	fff00793          	li	a5,-1
c001ec40:	000a0b93          	mv	s7,s4
c001ec44:	00fd8863          	beq	s11,a5,c001ec54 <_svfprintf_r+0xb60>
c001ec48:	012ce7b3          	or	a5,s9,s2
c001ec4c:	f7fa7b93          	andi	s7,s4,-129
c001ec50:	70078063          	beqz	a5,c001f350 <_svfprintf_r+0x125c>
c001ec54:	4e091ae3          	bnez	s2,c001f948 <_svfprintf_r+0x1854>
c001ec58:	00900793          	li	a5,9
c001ec5c:	4f97e6e3          	bltu	a5,s9,c001f948 <_svfprintf_r+0x1854>
c001ec60:	030c8c93          	addi	s9,s9,48
c001ec64:	1b9107a3          	sb	s9,431(sp)
c001ec68:	000b8a13          	mv	s4,s7
c001ec6c:	00100c93          	li	s9,1
c001ec70:	1af10b13          	addi	s6,sp,431
c001ec74:	ee9ff06f          	j	c001eb5c <_svfprintf_r+0xa68>
c001ec78:	01412783          	lw	a5,20(sp)
c001ec7c:	00044483          	lbu	s1,0(s0)
c001ec80:	0007a983          	lw	s3,0(a5)
c001ec84:	00478793          	addi	a5,a5,4
c001ec88:	00f12a23          	sw	a5,20(sp)
c001ec8c:	dc09d663          	bgez	s3,c001e258 <_svfprintf_r+0x164>
c001ec90:	413009b3          	neg	s3,s3
c001ec94:	004a6a13          	ori	s4,s4,4
c001ec98:	dc0ff06f          	j	c001e258 <_svfprintf_r+0x164>
c001ec9c:	00044483          	lbu	s1,0(s0)
c001eca0:	001a6a13          	ori	s4,s4,1
c001eca4:	db4ff06f          	j	c001e258 <_svfprintf_r+0x164>
c001eca8:	0c714783          	lbu	a5,199(sp)
c001ecac:	00044483          	lbu	s1,0(s0)
c001ecb0:	da079463          	bnez	a5,c001e258 <_svfprintf_r+0x164>
c001ecb4:	02000793          	li	a5,32
c001ecb8:	0cf103a3          	sb	a5,199(sp)
c001ecbc:	d9cff06f          	j	c001e258 <_svfprintf_r+0x164>
c001ecc0:	00044483          	lbu	s1,0(s0)
c001ecc4:	004a6a13          	ori	s4,s4,4
c001ecc8:	d90ff06f          	j	c001e258 <_svfprintf_r+0x164>
c001eccc:	02b00793          	li	a5,43
c001ecd0:	00044483          	lbu	s1,0(s0)
c001ecd4:	0cf103a3          	sb	a5,199(sp)
c001ecd8:	d80ff06f          	j	c001e258 <_svfprintf_r+0x164>
c001ecdc:	00044483          	lbu	s1,0(s0)
c001ece0:	00140713          	addi	a4,s0,1
c001ece4:	01749463          	bne	s1,s7,c001ecec <_svfprintf_r+0xbf8>
c001ece8:	4e50106f          	j	c00209cc <_svfprintf_r+0x28d8>
c001ecec:	fd048693          	addi	a3,s1,-48
c001ecf0:	00070413          	mv	s0,a4
c001ecf4:	00000d93          	li	s11,0
c001ecf8:	d6dae263          	bltu	s5,a3,c001e25c <_svfprintf_r+0x168>
c001ecfc:	00044483          	lbu	s1,0(s0)
c001ed00:	002d9793          	slli	a5,s11,0x2
c001ed04:	01b787b3          	add	a5,a5,s11
c001ed08:	00179793          	slli	a5,a5,0x1
c001ed0c:	00d78db3          	add	s11,a5,a3
c001ed10:	fd048693          	addi	a3,s1,-48
c001ed14:	00140413          	addi	s0,s0,1
c001ed18:	fedaf2e3          	bgeu	s5,a3,c001ecfc <_svfprintf_r+0xc08>
c001ed1c:	d40ff06f          	j	c001e25c <_svfprintf_r+0x168>
c001ed20:	000a0b93          	mv	s7,s4
c001ed24:	00100693          	li	a3,1
c001ed28:	f2d786e3          	beq	a5,a3,c001ec54 <_svfprintf_r+0xb60>
c001ed2c:	00200693          	li	a3,2
c001ed30:	06d78c63          	beq	a5,a3,c001eda8 <_svfprintf_r+0xcb4>
c001ed34:	1b010b13          	addi	s6,sp,432
c001ed38:	01d91713          	slli	a4,s2,0x1d
c001ed3c:	007cf793          	andi	a5,s9,7
c001ed40:	003cdc93          	srli	s9,s9,0x3
c001ed44:	03078793          	addi	a5,a5,48
c001ed48:	01976cb3          	or	s9,a4,s9
c001ed4c:	00395913          	srli	s2,s2,0x3
c001ed50:	fefb0fa3          	sb	a5,-1(s6)
c001ed54:	012ce733          	or	a4,s9,s2
c001ed58:	000b0613          	mv	a2,s6
c001ed5c:	fffb0b13          	addi	s6,s6,-1
c001ed60:	fc071ce3          	bnez	a4,c001ed38 <_svfprintf_r+0xc44>
c001ed64:	001bf693          	andi	a3,s7,1
c001ed68:	06068a63          	beqz	a3,c001eddc <_svfprintf_r+0xce8>
c001ed6c:	03000693          	li	a3,48
c001ed70:	06d78663          	beq	a5,a3,c001eddc <_svfprintf_r+0xce8>
c001ed74:	ffe60613          	addi	a2,a2,-2
c001ed78:	1b010793          	addi	a5,sp,432
c001ed7c:	fedb0fa3          	sb	a3,-1(s6)
c001ed80:	40c78cb3          	sub	s9,a5,a2
c001ed84:	000b8a13          	mv	s4,s7
c001ed88:	00060b13          	mv	s6,a2
c001ed8c:	dd1ff06f          	j	c001eb5c <_svfprintf_r+0xa68>
c001ed90:	00100713          	li	a4,1
c001ed94:	00e79463          	bne	a5,a4,c001ed9c <_svfprintf_r+0xca8>
c001ed98:	1e10106f          	j	c0020778 <_svfprintf_r+0x2684>
c001ed9c:	00200713          	li	a4,2
c001eda0:	000a0b93          	mv	s7,s4
c001eda4:	f8e798e3          	bne	a5,a4,c001ed34 <_svfprintf_r+0xc40>
c001eda8:	03412683          	lw	a3,52(sp)
c001edac:	1b010b13          	addi	s6,sp,432
c001edb0:	00fcf793          	andi	a5,s9,15
c001edb4:	00f687b3          	add	a5,a3,a5
c001edb8:	0007c703          	lbu	a4,0(a5)
c001edbc:	004cdc93          	srli	s9,s9,0x4
c001edc0:	01c91793          	slli	a5,s2,0x1c
c001edc4:	0197ecb3          	or	s9,a5,s9
c001edc8:	00495913          	srli	s2,s2,0x4
c001edcc:	feeb0fa3          	sb	a4,-1(s6)
c001edd0:	012ce7b3          	or	a5,s9,s2
c001edd4:	fffb0b13          	addi	s6,s6,-1
c001edd8:	fc079ce3          	bnez	a5,c001edb0 <_svfprintf_r+0xcbc>
c001eddc:	1b010793          	addi	a5,sp,432
c001ede0:	41678cb3          	sub	s9,a5,s6
c001ede4:	000b8a13          	mv	s4,s7
c001ede8:	d75ff06f          	j	c001eb5c <_svfprintf_r+0xa68>
c001edec:	06500713          	li	a4,101
c001edf0:	9e9756e3          	bge	a4,s1,c001e7dc <_svfprintf_r+0x6e8>
c001edf4:	0f012703          	lw	a4,240(sp)
c001edf8:	0a010593          	addi	a1,sp,160
c001edfc:	0b010513          	addi	a0,sp,176
c001ee00:	0ae12823          	sw	a4,176(sp)
c001ee04:	0f412703          	lw	a4,244(sp)
c001ee08:	05112223          	sw	a7,68(sp)
c001ee0c:	04f12023          	sw	a5,64(sp)
c001ee10:	0ae12a23          	sw	a4,180(sp)
c001ee14:	0f812703          	lw	a4,248(sp)
c001ee18:	0a012023          	sw	zero,160(sp)
c001ee1c:	0a012223          	sw	zero,164(sp)
c001ee20:	0ae12c23          	sw	a4,184(sp)
c001ee24:	0fc12703          	lw	a4,252(sp)
c001ee28:	0a012423          	sw	zero,168(sp)
c001ee2c:	0a012623          	sw	zero,172(sp)
c001ee30:	0ae12e23          	sw	a4,188(sp)
c001ee34:	5250f0ef          	jal	ra,c002eb58 <__eqtf2>
c001ee38:	04012783          	lw	a5,64(sp)
c001ee3c:	04412883          	lw	a7,68(sp)
c001ee40:	38051e63          	bnez	a0,c001f1dc <_svfprintf_r+0x10e8>
c001ee44:	0e812703          	lw	a4,232(sp)
c001ee48:	c80026b7          	lui	a3,0xc8002
c001ee4c:	71468693          	addi	a3,a3,1812 # c8002714 <_end+0xfff7de94>
c001ee50:	00d8a023          	sw	a3,0(a7)
c001ee54:	00178793          	addi	a5,a5,1
c001ee58:	00100693          	li	a3,1
c001ee5c:	00170713          	addi	a4,a4,1
c001ee60:	00d8a223          	sw	a3,4(a7)
c001ee64:	0ef12623          	sw	a5,236(sp)
c001ee68:	0ee12423          	sw	a4,232(sp)
c001ee6c:	00700693          	li	a3,7
c001ee70:	00888893          	addi	a7,a7,8
c001ee74:	48e6cce3          	blt	a3,a4,c001fb0c <_svfprintf_r+0x1a18>
c001ee78:	0cc12703          	lw	a4,204(sp)
c001ee7c:	02012683          	lw	a3,32(sp)
c001ee80:	66d75e63          	bge	a4,a3,c001f4fc <_svfprintf_r+0x1408>
c001ee84:	03012703          	lw	a4,48(sp)
c001ee88:	02c12683          	lw	a3,44(sp)
c001ee8c:	00888893          	addi	a7,a7,8
c001ee90:	fee8ac23          	sw	a4,-8(a7)
c001ee94:	0e812703          	lw	a4,232(sp)
c001ee98:	00d787b3          	add	a5,a5,a3
c001ee9c:	fed8ae23          	sw	a3,-4(a7)
c001eea0:	00170713          	addi	a4,a4,1
c001eea4:	0ef12623          	sw	a5,236(sp)
c001eea8:	0ee12423          	sw	a4,232(sp)
c001eeac:	00700693          	li	a3,7
c001eeb0:	7ce6c063          	blt	a3,a4,c001f670 <_svfprintf_r+0x157c>
c001eeb4:	02012703          	lw	a4,32(sp)
c001eeb8:	fff70493          	addi	s1,a4,-1
c001eebc:	ce905463          	blez	s1,c001e3a4 <_svfprintf_r+0x2b0>
c001eec0:	01000693          	li	a3,16
c001eec4:	0e812703          	lw	a4,232(sp)
c001eec8:	4696d2e3          	bge	a3,s1,c001fb2c <_svfprintf_r+0x1a38>
c001eecc:	01000913          	li	s2,16
c001eed0:	00700c93          	li	s9,7
c001eed4:	00c0006f          	j	c001eee0 <_svfprintf_r+0xdec>
c001eed8:	ff048493          	addi	s1,s1,-16
c001eedc:	449958e3          	bge	s2,s1,c001fb2c <_svfprintf_r+0x1a38>
c001eee0:	00812683          	lw	a3,8(sp)
c001eee4:	01078793          	addi	a5,a5,16
c001eee8:	00170713          	addi	a4,a4,1
c001eeec:	00d8a023          	sw	a3,0(a7)
c001eef0:	0128a223          	sw	s2,4(a7)
c001eef4:	0ef12623          	sw	a5,236(sp)
c001eef8:	0ee12423          	sw	a4,232(sp)
c001eefc:	00888893          	addi	a7,a7,8
c001ef00:	fcecdce3          	bge	s9,a4,c001eed8 <_svfprintf_r+0xde4>
c001ef04:	0e410613          	addi	a2,sp,228
c001ef08:	000c0593          	mv	a1,s8
c001ef0c:	000d0513          	mv	a0,s10
c001ef10:	5dd0a0ef          	jal	ra,c0029cec <__ssprint_r>
c001ef14:	1a051063          	bnez	a0,c001f0b4 <_svfprintf_r+0xfc0>
c001ef18:	0ec12783          	lw	a5,236(sp)
c001ef1c:	0e812703          	lw	a4,232(sp)
c001ef20:	10c10893          	addi	a7,sp,268
c001ef24:	fb5ff06f          	j	c001eed8 <_svfprintf_r+0xde4>
c001ef28:	41598933          	sub	s2,s3,s5
c001ef2c:	c5205063          	blez	s2,c001e36c <_svfprintf_r+0x278>
c001ef30:	01000613          	li	a2,16
c001ef34:	0e812703          	lw	a4,232(sp)
c001ef38:	07265463          	bge	a2,s2,c001efa0 <_svfprintf_r+0xeac>
c001ef3c:	01000e13          	li	t3,16
c001ef40:	00700b93          	li	s7,7
c001ef44:	00c0006f          	j	c001ef50 <_svfprintf_r+0xe5c>
c001ef48:	ff090913          	addi	s2,s2,-16
c001ef4c:	052e5a63          	bge	t3,s2,c001efa0 <_svfprintf_r+0xeac>
c001ef50:	00812683          	lw	a3,8(sp)
c001ef54:	01078793          	addi	a5,a5,16
c001ef58:	00170713          	addi	a4,a4,1
c001ef5c:	00d8a023          	sw	a3,0(a7)
c001ef60:	01c8a223          	sw	t3,4(a7)
c001ef64:	0ef12623          	sw	a5,236(sp)
c001ef68:	0ee12423          	sw	a4,232(sp)
c001ef6c:	00888893          	addi	a7,a7,8
c001ef70:	fcebdce3          	bge	s7,a4,c001ef48 <_svfprintf_r+0xe54>
c001ef74:	0e410613          	addi	a2,sp,228
c001ef78:	000c0593          	mv	a1,s8
c001ef7c:	000d0513          	mv	a0,s10
c001ef80:	56d0a0ef          	jal	ra,c0029cec <__ssprint_r>
c001ef84:	12051863          	bnez	a0,c001f0b4 <_svfprintf_r+0xfc0>
c001ef88:	01000e13          	li	t3,16
c001ef8c:	ff090913          	addi	s2,s2,-16
c001ef90:	0ec12783          	lw	a5,236(sp)
c001ef94:	0e812703          	lw	a4,232(sp)
c001ef98:	10c10893          	addi	a7,sp,268
c001ef9c:	fb2e4ae3          	blt	t3,s2,c001ef50 <_svfprintf_r+0xe5c>
c001efa0:	00812683          	lw	a3,8(sp)
c001efa4:	012787b3          	add	a5,a5,s2
c001efa8:	00170713          	addi	a4,a4,1
c001efac:	00d8a023          	sw	a3,0(a7)
c001efb0:	0128a223          	sw	s2,4(a7)
c001efb4:	0ef12623          	sw	a5,236(sp)
c001efb8:	0ee12423          	sw	a4,232(sp)
c001efbc:	00700693          	li	a3,7
c001efc0:	00888893          	addi	a7,a7,8
c001efc4:	bae6d463          	bge	a3,a4,c001e36c <_svfprintf_r+0x278>
c001efc8:	0e410613          	addi	a2,sp,228
c001efcc:	000c0593          	mv	a1,s8
c001efd0:	000d0513          	mv	a0,s10
c001efd4:	5190a0ef          	jal	ra,c0029cec <__ssprint_r>
c001efd8:	0c051e63          	bnez	a0,c001f0b4 <_svfprintf_r+0xfc0>
c001efdc:	419d8db3          	sub	s11,s11,s9
c001efe0:	0ec12783          	lw	a5,236(sp)
c001efe4:	10c10893          	addi	a7,sp,268
c001efe8:	b9b05663          	blez	s11,c001e374 <_svfprintf_r+0x280>
c001efec:	01000613          	li	a2,16
c001eff0:	0e812703          	lw	a4,232(sp)
c001eff4:	07b65263          	bge	a2,s11,c001f058 <_svfprintf_r+0xf64>
c001eff8:	01000b93          	li	s7,16
c001effc:	00700913          	li	s2,7
c001f000:	00c0006f          	j	c001f00c <_svfprintf_r+0xf18>
c001f004:	ff0d8d93          	addi	s11,s11,-16
c001f008:	05bbd863          	bge	s7,s11,c001f058 <_svfprintf_r+0xf64>
c001f00c:	00812683          	lw	a3,8(sp)
c001f010:	01078793          	addi	a5,a5,16
c001f014:	00170713          	addi	a4,a4,1
c001f018:	00d8a023          	sw	a3,0(a7)
c001f01c:	0178a223          	sw	s7,4(a7)
c001f020:	0ef12623          	sw	a5,236(sp)
c001f024:	0ee12423          	sw	a4,232(sp)
c001f028:	00888893          	addi	a7,a7,8
c001f02c:	fce95ce3          	bge	s2,a4,c001f004 <_svfprintf_r+0xf10>
c001f030:	0e410613          	addi	a2,sp,228
c001f034:	000c0593          	mv	a1,s8
c001f038:	000d0513          	mv	a0,s10
c001f03c:	4b10a0ef          	jal	ra,c0029cec <__ssprint_r>
c001f040:	06051a63          	bnez	a0,c001f0b4 <_svfprintf_r+0xfc0>
c001f044:	ff0d8d93          	addi	s11,s11,-16
c001f048:	0ec12783          	lw	a5,236(sp)
c001f04c:	0e812703          	lw	a4,232(sp)
c001f050:	10c10893          	addi	a7,sp,268
c001f054:	fbbbcce3          	blt	s7,s11,c001f00c <_svfprintf_r+0xf18>
c001f058:	00812683          	lw	a3,8(sp)
c001f05c:	01b787b3          	add	a5,a5,s11
c001f060:	00170713          	addi	a4,a4,1
c001f064:	00d8a023          	sw	a3,0(a7)
c001f068:	01b8a223          	sw	s11,4(a7)
c001f06c:	0ef12623          	sw	a5,236(sp)
c001f070:	0ee12423          	sw	a4,232(sp)
c001f074:	00700693          	li	a3,7
c001f078:	00888893          	addi	a7,a7,8
c001f07c:	aee6dc63          	bge	a3,a4,c001e374 <_svfprintf_r+0x280>
c001f080:	0e410613          	addi	a2,sp,228
c001f084:	000c0593          	mv	a1,s8
c001f088:	000d0513          	mv	a0,s10
c001f08c:	4610a0ef          	jal	ra,c0029cec <__ssprint_r>
c001f090:	02051263          	bnez	a0,c001f0b4 <_svfprintf_r+0xfc0>
c001f094:	0ec12783          	lw	a5,236(sp)
c001f098:	10c10893          	addi	a7,sp,268
c001f09c:	ad8ff06f          	j	c001e374 <_svfprintf_r+0x280>
c001f0a0:	0e410613          	addi	a2,sp,228
c001f0a4:	000c0593          	mv	a1,s8
c001f0a8:	000d0513          	mv	a0,s10
c001f0ac:	4410a0ef          	jal	ra,c0029cec <__ssprint_r>
c001f0b0:	b0050e63          	beqz	a0,c001e3cc <_svfprintf_r+0x2d8>
c001f0b4:	01012b83          	lw	s7,16(sp)
c001f0b8:	b40b8463          	beqz	s7,c001e400 <_svfprintf_r+0x30c>
c001f0bc:	000b8593          	mv	a1,s7
c001f0c0:	000d0513          	mv	a0,s10
c001f0c4:	595040ef          	jal	ra,c0023e58 <_free_r>
c001f0c8:	b38ff06f          	j	c001e400 <_svfprintf_r+0x30c>
c001f0cc:	01000613          	li	a2,16
c001f0d0:	0e812703          	lw	a4,232(sp)
c001f0d4:	00d64463          	blt	a2,a3,c001f0dc <_svfprintf_r+0xfe8>
c001f0d8:	0cc0106f          	j	c00201a4 <_svfprintf_r+0x20b0>
c001f0dc:	c8002637          	lui	a2,0xc8002
c001f0e0:	bd860e93          	addi	t4,a2,-1064 # c8001bd8 <_end+0xfff7d358>
c001f0e4:	04812023          	sw	s0,64(sp)
c001f0e8:	04912223          	sw	s1,68(sp)
c001f0ec:	000d0413          	mv	s0,s10
c001f0f0:	000c0493          	mv	s1,s8
c001f0f4:	01000e13          	li	t3,16
c001f0f8:	00700293          	li	t0,7
c001f0fc:	00068c13          	mv	s8,a3
c001f100:	000e8d13          	mv	s10,t4
c001f104:	00c0006f          	j	c001f110 <_svfprintf_r+0x101c>
c001f108:	ff0c0c13          	addi	s8,s8,-16
c001f10c:	058e5a63          	bge	t3,s8,c001f160 <_svfprintf_r+0x106c>
c001f110:	01078793          	addi	a5,a5,16
c001f114:	00170713          	addi	a4,a4,1
c001f118:	01a8a023          	sw	s10,0(a7)
c001f11c:	01c8a223          	sw	t3,4(a7)
c001f120:	0ef12623          	sw	a5,236(sp)
c001f124:	0ee12423          	sw	a4,232(sp)
c001f128:	00888893          	addi	a7,a7,8
c001f12c:	fce2dee3          	bge	t0,a4,c001f108 <_svfprintf_r+0x1014>
c001f130:	0e410613          	addi	a2,sp,228
c001f134:	00048593          	mv	a1,s1
c001f138:	00040513          	mv	a0,s0
c001f13c:	3b10a0ef          	jal	ra,c0029cec <__ssprint_r>
c001f140:	1a0510e3          	bnez	a0,c001fae0 <_svfprintf_r+0x19ec>
c001f144:	01000e13          	li	t3,16
c001f148:	ff0c0c13          	addi	s8,s8,-16
c001f14c:	0ec12783          	lw	a5,236(sp)
c001f150:	0e812703          	lw	a4,232(sp)
c001f154:	10c10893          	addi	a7,sp,268
c001f158:	00700293          	li	t0,7
c001f15c:	fb8e4ae3          	blt	t3,s8,c001f110 <_svfprintf_r+0x101c>
c001f160:	000c0693          	mv	a3,s8
c001f164:	000d0e93          	mv	t4,s10
c001f168:	00048c13          	mv	s8,s1
c001f16c:	00040d13          	mv	s10,s0
c001f170:	04412483          	lw	s1,68(sp)
c001f174:	04012403          	lw	s0,64(sp)
c001f178:	00d787b3          	add	a5,a5,a3
c001f17c:	00170713          	addi	a4,a4,1
c001f180:	00d8a223          	sw	a3,4(a7)
c001f184:	01d8a023          	sw	t4,0(a7)
c001f188:	0ef12623          	sw	a5,236(sp)
c001f18c:	0ee12423          	sw	a4,232(sp)
c001f190:	00700693          	li	a3,7
c001f194:	00888893          	addi	a7,a7,8
c001f198:	96e6d063          	bge	a3,a4,c001e2f8 <_svfprintf_r+0x204>
c001f19c:	0e410613          	addi	a2,sp,228
c001f1a0:	000c0593          	mv	a1,s8
c001f1a4:	000d0513          	mv	a0,s10
c001f1a8:	3450a0ef          	jal	ra,c0029cec <__ssprint_r>
c001f1ac:	f00514e3          	bnez	a0,c001f0b4 <_svfprintf_r+0xfc0>
c001f1b0:	0ec12783          	lw	a5,236(sp)
c001f1b4:	10c10893          	addi	a7,sp,268
c001f1b8:	940ff06f          	j	c001e2f8 <_svfprintf_r+0x204>
c001f1bc:	0e410613          	addi	a2,sp,228
c001f1c0:	000c0593          	mv	a1,s8
c001f1c4:	000d0513          	mv	a0,s10
c001f1c8:	3250a0ef          	jal	ra,c0029cec <__ssprint_r>
c001f1cc:	ee0514e3          	bnez	a0,c001f0b4 <_svfprintf_r+0xfc0>
c001f1d0:	0ec12783          	lw	a5,236(sp)
c001f1d4:	10c10893          	addi	a7,sp,268
c001f1d8:	98cff06f          	j	c001e364 <_svfprintf_r+0x270>
c001f1dc:	0cc12603          	lw	a2,204(sp)
c001f1e0:	02c05ae3          	blez	a2,c001fa14 <_svfprintf_r+0x1920>
c001f1e4:	01c12703          	lw	a4,28(sp)
c001f1e8:	02012683          	lw	a3,32(sp)
c001f1ec:	00070493          	mv	s1,a4
c001f1f0:	3ce6ce63          	blt	a3,a4,c001f5cc <_svfprintf_r+0x14d8>
c001f1f4:	02905663          	blez	s1,c001f220 <_svfprintf_r+0x112c>
c001f1f8:	0e812703          	lw	a4,232(sp)
c001f1fc:	009787b3          	add	a5,a5,s1
c001f200:	0168a023          	sw	s6,0(a7)
c001f204:	00170713          	addi	a4,a4,1
c001f208:	0098a223          	sw	s1,4(a7)
c001f20c:	0ef12623          	sw	a5,236(sp)
c001f210:	0ee12423          	sw	a4,232(sp)
c001f214:	00700693          	li	a3,7
c001f218:	00888893          	addi	a7,a7,8
c001f21c:	42e6c6e3          	blt	a3,a4,c001fe48 <_svfprintf_r+0x1d54>
c001f220:	fff4c713          	not	a4,s1
c001f224:	41f75713          	srai	a4,a4,0x1f
c001f228:	00e4f4b3          	and	s1,s1,a4
c001f22c:	01c12703          	lw	a4,28(sp)
c001f230:	409704b3          	sub	s1,a4,s1
c001f234:	4c904c63          	bgtz	s1,c001f70c <_svfprintf_r+0x1618>
c001f238:	01c12683          	lw	a3,28(sp)
c001f23c:	400a7713          	andi	a4,s4,1024
c001f240:	00db0db3          	add	s11,s6,a3
c001f244:	52071863          	bnez	a4,c001f774 <_svfprintf_r+0x1680>
c001f248:	0cc12483          	lw	s1,204(sp)
c001f24c:	02012703          	lw	a4,32(sp)
c001f250:	00e4c663          	blt	s1,a4,c001f25c <_svfprintf_r+0x1168>
c001f254:	001a7713          	andi	a4,s4,1
c001f258:	40070ce3          	beqz	a4,c001fe70 <_svfprintf_r+0x1d7c>
c001f25c:	03012703          	lw	a4,48(sp)
c001f260:	02c12683          	lw	a3,44(sp)
c001f264:	00700613          	li	a2,7
c001f268:	00e8a023          	sw	a4,0(a7)
c001f26c:	0e812703          	lw	a4,232(sp)
c001f270:	00d787b3          	add	a5,a5,a3
c001f274:	00d8a223          	sw	a3,4(a7)
c001f278:	00170713          	addi	a4,a4,1
c001f27c:	0ef12623          	sw	a5,236(sp)
c001f280:	0ee12423          	sw	a4,232(sp)
c001f284:	00888893          	addi	a7,a7,8
c001f288:	5ae64ae3          	blt	a2,a4,c002003c <_svfprintf_r+0x1f48>
c001f28c:	02012683          	lw	a3,32(sp)
c001f290:	00db0733          	add	a4,s6,a3
c001f294:	409684b3          	sub	s1,a3,s1
c001f298:	41b70733          	sub	a4,a4,s11
c001f29c:	00048913          	mv	s2,s1
c001f2a0:	00975463          	bge	a4,s1,c001f2a8 <_svfprintf_r+0x11b4>
c001f2a4:	00070913          	mv	s2,a4
c001f2a8:	03205663          	blez	s2,c001f2d4 <_svfprintf_r+0x11e0>
c001f2ac:	0e812703          	lw	a4,232(sp)
c001f2b0:	012787b3          	add	a5,a5,s2
c001f2b4:	01b8a023          	sw	s11,0(a7)
c001f2b8:	00170713          	addi	a4,a4,1
c001f2bc:	0128a223          	sw	s2,4(a7)
c001f2c0:	0ef12623          	sw	a5,236(sp)
c001f2c4:	0ee12423          	sw	a4,232(sp)
c001f2c8:	00700693          	li	a3,7
c001f2cc:	00888893          	addi	a7,a7,8
c001f2d0:	70e6cce3          	blt	a3,a4,c00201e8 <_svfprintf_r+0x20f4>
c001f2d4:	fff94713          	not	a4,s2
c001f2d8:	41f75713          	srai	a4,a4,0x1f
c001f2dc:	00e97733          	and	a4,s2,a4
c001f2e0:	40e484b3          	sub	s1,s1,a4
c001f2e4:	8c905063          	blez	s1,c001e3a4 <_svfprintf_r+0x2b0>
c001f2e8:	01000693          	li	a3,16
c001f2ec:	0e812703          	lw	a4,232(sp)
c001f2f0:	0296dee3          	bge	a3,s1,c001fb2c <_svfprintf_r+0x1a38>
c001f2f4:	01000913          	li	s2,16
c001f2f8:	00700c93          	li	s9,7
c001f2fc:	00c0006f          	j	c001f308 <_svfprintf_r+0x1214>
c001f300:	ff048493          	addi	s1,s1,-16
c001f304:	029954e3          	bge	s2,s1,c001fb2c <_svfprintf_r+0x1a38>
c001f308:	00812683          	lw	a3,8(sp)
c001f30c:	01078793          	addi	a5,a5,16
c001f310:	00170713          	addi	a4,a4,1
c001f314:	00d8a023          	sw	a3,0(a7)
c001f318:	0128a223          	sw	s2,4(a7)
c001f31c:	0ef12623          	sw	a5,236(sp)
c001f320:	0ee12423          	sw	a4,232(sp)
c001f324:	00888893          	addi	a7,a7,8
c001f328:	fcecdce3          	bge	s9,a4,c001f300 <_svfprintf_r+0x120c>
c001f32c:	0e410613          	addi	a2,sp,228
c001f330:	000c0593          	mv	a1,s8
c001f334:	000d0513          	mv	a0,s10
c001f338:	1b50a0ef          	jal	ra,c0029cec <__ssprint_r>
c001f33c:	d6051ce3          	bnez	a0,c001f0b4 <_svfprintf_r+0xfc0>
c001f340:	0ec12783          	lw	a5,236(sp)
c001f344:	0e812703          	lw	a4,232(sp)
c001f348:	10c10893          	addi	a7,sp,268
c001f34c:	fb5ff06f          	j	c001f300 <_svfprintf_r+0x120c>
c001f350:	900d98e3          	bnez	s11,c001ec60 <_svfprintf_r+0xb6c>
c001f354:	000b8a13          	mv	s4,s7
c001f358:	00000d93          	li	s11,0
c001f35c:	00000c93          	li	s9,0
c001f360:	1b010b13          	addi	s6,sp,432
c001f364:	ff8ff06f          	j	c001eb5c <_svfprintf_r+0xa68>
c001f368:	001a7793          	andi	a5,s4,1
c001f36c:	c8079863          	bnez	a5,c001e7fc <_svfprintf_r+0x708>
c001f370:	00d8a223          	sw	a3,4(a7)
c001f374:	0f912623          	sw	s9,236(sp)
c001f378:	0e912423          	sw	s1,232(sp)
c001f37c:	00700793          	li	a5,7
c001f380:	5897ce63          	blt	a5,s1,c001f91c <_svfprintf_r+0x1828>
c001f384:	00270713          	addi	a4,a4,2
c001f388:	01088893          	addi	a7,a7,16
c001f38c:	d44ff06f          	j	c001e8d0 <_svfprintf_r+0x7dc>
c001f390:	d5b05063          	blez	s11,c001e8d0 <_svfprintf_r+0x7dc>
c001f394:	01000613          	li	a2,16
c001f398:	01b64463          	blt	a2,s11,c001f3a0 <_svfprintf_r+0x12ac>
c001f39c:	6280106f          	j	c00209c4 <_svfprintf_r+0x28d0>
c001f3a0:	01000713          	li	a4,16
c001f3a4:	00700b13          	li	s6,7
c001f3a8:	00068493          	mv	s1,a3
c001f3ac:	0100006f          	j	c001f3bc <_svfprintf_r+0x12c8>
c001f3b0:	ff0d8d93          	addi	s11,s11,-16
c001f3b4:	11b75ce3          	bge	a4,s11,c001fccc <_svfprintf_r+0x1bd8>
c001f3b8:	00148493          	addi	s1,s1,1
c001f3bc:	00812783          	lw	a5,8(sp)
c001f3c0:	010c8c93          	addi	s9,s9,16
c001f3c4:	00e92223          	sw	a4,4(s2)
c001f3c8:	00f92023          	sw	a5,0(s2)
c001f3cc:	0f912623          	sw	s9,236(sp)
c001f3d0:	0e912423          	sw	s1,232(sp)
c001f3d4:	00890913          	addi	s2,s2,8
c001f3d8:	fc9b5ce3          	bge	s6,s1,c001f3b0 <_svfprintf_r+0x12bc>
c001f3dc:	0e410613          	addi	a2,sp,228
c001f3e0:	000c0593          	mv	a1,s8
c001f3e4:	000d0513          	mv	a0,s10
c001f3e8:	1050a0ef          	jal	ra,c0029cec <__ssprint_r>
c001f3ec:	cc0514e3          	bnez	a0,c001f0b4 <_svfprintf_r+0xfc0>
c001f3f0:	0ec12c83          	lw	s9,236(sp)
c001f3f4:	0e812483          	lw	s1,232(sp)
c001f3f8:	10c10913          	addi	s2,sp,268
c001f3fc:	01000713          	li	a4,16
c001f400:	fb1ff06f          	j	c001f3b0 <_svfprintf_r+0x12bc>
c001f404:	01412683          	lw	a3,20(sp)
c001f408:	010a7793          	andi	a5,s4,16
c001f40c:	00468713          	addi	a4,a3,4
c001f410:	1a079663          	bnez	a5,c001f5bc <_svfprintf_r+0x14c8>
c001f414:	040a7793          	andi	a5,s4,64
c001f418:	0e0786e3          	beqz	a5,c001fd04 <_svfprintf_r+0x1c10>
c001f41c:	01412783          	lw	a5,20(sp)
c001f420:	00000913          	li	s2,0
c001f424:	00e12a23          	sw	a4,20(sp)
c001f428:	0007dc83          	lhu	s9,0(a5)
c001f42c:	f84ff06f          	j	c001ebb0 <_svfprintf_r+0xabc>
c001f430:	01412683          	lw	a3,20(sp)
c001f434:	010a7793          	andi	a5,s4,16
c001f438:	00468713          	addi	a4,a3,4
c001f43c:	16079663          	bnez	a5,c001f5a8 <_svfprintf_r+0x14b4>
c001f440:	040a7793          	andi	a5,s4,64
c001f444:	0e078ee3          	beqz	a5,c001fd40 <_svfprintf_r+0x1c4c>
c001f448:	01412783          	lw	a5,20(sp)
c001f44c:	00e12a23          	sw	a4,20(sp)
c001f450:	00079c83          	lh	s9,0(a5)
c001f454:	41fcd913          	srai	s2,s9,0x1f
c001f458:	00090793          	mv	a5,s2
c001f45c:	fe07d063          	bgez	a5,c001ec3c <_svfprintf_r+0xb48>
c001f460:	019037b3          	snez	a5,s9
c001f464:	41200933          	neg	s2,s2
c001f468:	40f90933          	sub	s2,s2,a5
c001f46c:	02d00793          	li	a5,45
c001f470:	0cf103a3          	sb	a5,199(sp)
c001f474:	41900cb3          	neg	s9,s9
c001f478:	000a0b93          	mv	s7,s4
c001f47c:	00100793          	li	a5,1
c001f480:	eb4ff06f          	j	c001eb34 <_svfprintf_r+0xa40>
c001f484:	01412703          	lw	a4,20(sp)
c001f488:	010bf793          	andi	a5,s7,16
c001f48c:	00470693          	addi	a3,a4,4
c001f490:	10079263          	bnez	a5,c001f594 <_svfprintf_r+0x14a0>
c001f494:	040bf793          	andi	a5,s7,64
c001f498:	080784e3          	beqz	a5,c001fd20 <_svfprintf_r+0x1c2c>
c001f49c:	01412783          	lw	a5,20(sp)
c001f4a0:	00000913          	li	s2,0
c001f4a4:	00d12a23          	sw	a3,20(sp)
c001f4a8:	0007dc83          	lhu	s9,0(a5)
c001f4ac:	00100793          	li	a5,1
c001f4b0:	e80ff06f          	j	c001eb30 <_svfprintf_r+0xa3c>
c001f4b4:	0e410613          	addi	a2,sp,228
c001f4b8:	000c0593          	mv	a1,s8
c001f4bc:	000d0513          	mv	a0,s10
c001f4c0:	02d0a0ef          	jal	ra,c0029cec <__ssprint_r>
c001f4c4:	be0518e3          	bnez	a0,c001f0b4 <_svfprintf_r+0xfc0>
c001f4c8:	0ec12c83          	lw	s9,236(sp)
c001f4cc:	0e812483          	lw	s1,232(sp)
c001f4d0:	10c10913          	addi	s2,sp,268
c001f4d4:	b40ff06f          	j	c001e814 <_svfprintf_r+0x720>
c001f4d8:	0e410613          	addi	a2,sp,228
c001f4dc:	000c0593          	mv	a1,s8
c001f4e0:	000d0513          	mv	a0,s10
c001f4e4:	0090a0ef          	jal	ra,c0029cec <__ssprint_r>
c001f4e8:	bc0516e3          	bnez	a0,c001f0b4 <_svfprintf_r+0xfc0>
c001f4ec:	0ec12c83          	lw	s9,236(sp)
c001f4f0:	0e812483          	lw	s1,232(sp)
c001f4f4:	10c10913          	addi	s2,sp,268
c001f4f8:	b48ff06f          	j	c001e840 <_svfprintf_r+0x74c>
c001f4fc:	001a7713          	andi	a4,s4,1
c001f500:	00071463          	bnez	a4,c001f508 <_svfprintf_r+0x1414>
c001f504:	ea1fe06f          	j	c001e3a4 <_svfprintf_r+0x2b0>
c001f508:	97dff06f          	j	c001ee84 <_svfprintf_r+0xd90>
c001f50c:	000c8893          	mv	a7,s9
c001f510:	f00ff06f          	j	c001ec10 <_svfprintf_r+0xb1c>
c001f514:	03000793          	li	a5,48
c001f518:	1af107a3          	sb	a5,431(sp)
c001f51c:	1af10b13          	addi	s6,sp,431
c001f520:	e3cff06f          	j	c001eb5c <_svfprintf_r+0xa68>
c001f524:	03c12783          	lw	a5,60(sp)
c001f528:	00044483          	lbu	s1,0(s0)
c001f52c:	00079463          	bnez	a5,c001f534 <_svfprintf_r+0x1440>
c001f530:	d29fe06f          	j	c001e258 <_svfprintf_r+0x164>
c001f534:	0007c783          	lbu	a5,0(a5)
c001f538:	00079463          	bnez	a5,c001f540 <_svfprintf_r+0x144c>
c001f53c:	d1dfe06f          	j	c001e258 <_svfprintf_r+0x164>
c001f540:	400a6a13          	ori	s4,s4,1024
c001f544:	d15fe06f          	j	c001e258 <_svfprintf_r+0x164>
c001f548:	00c12683          	lw	a3,12(sp)
c001f54c:	00040b13          	mv	s6,s0
c001f550:	41f6d793          	srai	a5,a3,0x1f
c001f554:	00d72023          	sw	a3,0(a4)
c001f558:	00f72223          	sw	a5,4(a4)
c001f55c:	e91fe06f          	j	c001e3ec <_svfprintf_r+0x2f8>
c001f560:	01412703          	lw	a4,20(sp)
c001f564:	00072783          	lw	a5,0(a4)
c001f568:	00470713          	addi	a4,a4,4
c001f56c:	00e12a23          	sw	a4,20(sp)
c001f570:	0007a603          	lw	a2,0(a5)
c001f574:	0047a683          	lw	a3,4(a5)
c001f578:	0087a703          	lw	a4,8(a5)
c001f57c:	00c7a783          	lw	a5,12(a5)
c001f580:	0ec12823          	sw	a2,240(sp)
c001f584:	0ed12a23          	sw	a3,244(sp)
c001f588:	0ee12c23          	sw	a4,248(sp)
c001f58c:	0ef12e23          	sw	a5,252(sp)
c001f590:	f99fe06f          	j	c001e528 <_svfprintf_r+0x434>
c001f594:	00072c83          	lw	s9,0(a4)
c001f598:	00000913          	li	s2,0
c001f59c:	00d12a23          	sw	a3,20(sp)
c001f5a0:	00100793          	li	a5,1
c001f5a4:	d8cff06f          	j	c001eb30 <_svfprintf_r+0xa3c>
c001f5a8:	0006ac83          	lw	s9,0(a3)
c001f5ac:	00e12a23          	sw	a4,20(sp)
c001f5b0:	41fcd913          	srai	s2,s9,0x1f
c001f5b4:	00090793          	mv	a5,s2
c001f5b8:	e80ff06f          	j	c001ec38 <_svfprintf_r+0xb44>
c001f5bc:	0006ac83          	lw	s9,0(a3)
c001f5c0:	00000913          	li	s2,0
c001f5c4:	00e12a23          	sw	a4,20(sp)
c001f5c8:	de8ff06f          	j	c001ebb0 <_svfprintf_r+0xabc>
c001f5cc:	00068493          	mv	s1,a3
c001f5d0:	c29044e3          	bgtz	s1,c001f1f8 <_svfprintf_r+0x1104>
c001f5d4:	c4dff06f          	j	c001f220 <_svfprintf_r+0x112c>
c001f5d8:	000c8893          	mv	a7,s9
c001f5dc:	000a0b93          	mv	s7,s4
c001f5e0:	de4ff06f          	j	c001ebc4 <_svfprintf_r+0xad0>
c001f5e4:	c80027b7          	lui	a5,0xc8002
c001f5e8:	6e478793          	addi	a5,a5,1764 # c80026e4 <_end+0xfff7de64>
c001f5ec:	000c8893          	mv	a7,s9
c001f5f0:	02f12a23          	sw	a5,52(sp)
c001f5f4:	020a7793          	andi	a5,s4,32
c001f5f8:	2e078263          	beqz	a5,c001f8dc <_svfprintf_r+0x17e8>
c001f5fc:	01412783          	lw	a5,20(sp)
c001f600:	00778b13          	addi	s6,a5,7
c001f604:	ff8b7b13          	andi	s6,s6,-8
c001f608:	000b2c83          	lw	s9,0(s6)
c001f60c:	004b2903          	lw	s2,4(s6)
c001f610:	008b0793          	addi	a5,s6,8
c001f614:	00f12a23          	sw	a5,20(sp)
c001f618:	001a7793          	andi	a5,s4,1
c001f61c:	00078e63          	beqz	a5,c001f638 <_svfprintf_r+0x1544>
c001f620:	012ce7b3          	or	a5,s9,s2
c001f624:	00078a63          	beqz	a5,c001f638 <_svfprintf_r+0x1544>
c001f628:	03000793          	li	a5,48
c001f62c:	0cf10423          	sb	a5,200(sp)
c001f630:	0c9104a3          	sb	s1,201(sp)
c001f634:	002a6a13          	ori	s4,s4,2
c001f638:	bffa7b93          	andi	s7,s4,-1025
c001f63c:	00200793          	li	a5,2
c001f640:	cf0ff06f          	j	c001eb30 <_svfprintf_r+0xa3c>
c001f644:	000c8893          	mv	a7,s9
c001f648:	d44ff06f          	j	c001eb8c <_svfprintf_r+0xa98>
c001f64c:	c80027b7          	lui	a5,0xc8002
c001f650:	6f878793          	addi	a5,a5,1784 # c80026f8 <_end+0xfff7de78>
c001f654:	000c8893          	mv	a7,s9
c001f658:	02f12a23          	sw	a5,52(sp)
c001f65c:	f99ff06f          	j	c001f5f4 <_svfprintf_r+0x1500>
c001f660:	00144483          	lbu	s1,1(s0)
c001f664:	020a6a13          	ori	s4,s4,32
c001f668:	00140413          	addi	s0,s0,1
c001f66c:	bedfe06f          	j	c001e258 <_svfprintf_r+0x164>
c001f670:	0e410613          	addi	a2,sp,228
c001f674:	000c0593          	mv	a1,s8
c001f678:	000d0513          	mv	a0,s10
c001f67c:	6700a0ef          	jal	ra,c0029cec <__ssprint_r>
c001f680:	a2051ae3          	bnez	a0,c001f0b4 <_svfprintf_r+0xfc0>
c001f684:	0ec12783          	lw	a5,236(sp)
c001f688:	10c10893          	addi	a7,sp,268
c001f68c:	829ff06f          	j	c001eeb4 <_svfprintf_r+0xdc0>
c001f690:	00144483          	lbu	s1,1(s0)
c001f694:	200a6a13          	ori	s4,s4,512
c001f698:	00140413          	addi	s0,s0,1
c001f69c:	bbdfe06f          	j	c001e258 <_svfprintf_r+0x164>
c001f6a0:	04000593          	li	a1,64
c001f6a4:	000d0513          	mv	a0,s10
c001f6a8:	024080ef          	jal	ra,c00276cc <_malloc_r>
c001f6ac:	00ac2023          	sw	a0,0(s8)
c001f6b0:	00ac2823          	sw	a0,16(s8)
c001f6b4:	00051463          	bnez	a0,c001f6bc <_svfprintf_r+0x15c8>
c001f6b8:	3380106f          	j	c00209f0 <_svfprintf_r+0x28fc>
c001f6bc:	04000793          	li	a5,64
c001f6c0:	00fc2a23          	sw	a5,20(s8)
c001f6c4:	ab9fe06f          	j	c001e17c <_svfprintf_r+0x88>
c001f6c8:	000b0513          	mv	a0,s6
c001f6cc:	05912023          	sw	s9,64(sp)
c001f6d0:	999fe0ef          	jal	ra,c001e068 <strlen>
c001f6d4:	0c714783          	lbu	a5,199(sp)
c001f6d8:	fff54a93          	not	s5,a0
c001f6dc:	41fada93          	srai	s5,s5,0x1f
c001f6e0:	01212a23          	sw	s2,20(sp)
c001f6e4:	00012823          	sw	zero,16(sp)
c001f6e8:	02012423          	sw	zero,40(sp)
c001f6ec:	02012223          	sw	zero,36(sp)
c001f6f0:	00012e23          	sw	zero,28(sp)
c001f6f4:	04012883          	lw	a7,64(sp)
c001f6f8:	00050c93          	mv	s9,a0
c001f6fc:	01557ab3          	and	s5,a0,s5
c001f700:	00000d93          	li	s11,0
c001f704:	b4079263          	bnez	a5,c001ea48 <_svfprintf_r+0x954>
c001f708:	bd1fe06f          	j	c001e2d8 <_svfprintf_r+0x1e4>
c001f70c:	01000693          	li	a3,16
c001f710:	0e812703          	lw	a4,232(sp)
c001f714:	6896d463          	bge	a3,s1,c001fd9c <_svfprintf_r+0x1ca8>
c001f718:	01000c93          	li	s9,16
c001f71c:	00700d93          	li	s11,7
c001f720:	00c0006f          	j	c001f72c <_svfprintf_r+0x1638>
c001f724:	ff048493          	addi	s1,s1,-16
c001f728:	669cda63          	bge	s9,s1,c001fd9c <_svfprintf_r+0x1ca8>
c001f72c:	00812683          	lw	a3,8(sp)
c001f730:	01078793          	addi	a5,a5,16
c001f734:	00170713          	addi	a4,a4,1
c001f738:	00d8a023          	sw	a3,0(a7)
c001f73c:	0198a223          	sw	s9,4(a7)
c001f740:	0ef12623          	sw	a5,236(sp)
c001f744:	0ee12423          	sw	a4,232(sp)
c001f748:	00888893          	addi	a7,a7,8
c001f74c:	fceddce3          	bge	s11,a4,c001f724 <_svfprintf_r+0x1630>
c001f750:	0e410613          	addi	a2,sp,228
c001f754:	000c0593          	mv	a1,s8
c001f758:	000d0513          	mv	a0,s10
c001f75c:	5900a0ef          	jal	ra,c0029cec <__ssprint_r>
c001f760:	94051ae3          	bnez	a0,c001f0b4 <_svfprintf_r+0xfc0>
c001f764:	0ec12783          	lw	a5,236(sp)
c001f768:	0e812703          	lw	a4,232(sp)
c001f76c:	10c10893          	addi	a7,sp,268
c001f770:	fb5ff06f          	j	c001f724 <_svfprintf_r+0x1630>
c001f774:	02012703          	lw	a4,32(sp)
c001f778:	02412c83          	lw	s9,36(sp)
c001f77c:	01412e23          	sw	s4,28(sp)
c001f780:	04812023          	sw	s0,64(sp)
c001f784:	05312223          	sw	s3,68(sp)
c001f788:	03512223          	sw	s5,36(sp)
c001f78c:	02812983          	lw	s3,40(sp)
c001f790:	03612423          	sw	s6,40(sp)
c001f794:	00eb0bb3          	add	s7,s6,a4
c001f798:	03c12403          	lw	s0,60(sp)
c001f79c:	04812a03          	lw	s4,72(sp)
c001f7a0:	04c12a83          	lw	s5,76(sp)
c001f7a4:	00700493          	li	s1,7
c001f7a8:	01000913          	li	s2,16
c001f7ac:	000c0b13          	mv	s6,s8
c001f7b0:	080c8863          	beqz	s9,c001f840 <_svfprintf_r+0x174c>
c001f7b4:	08099863          	bnez	s3,c001f844 <_svfprintf_r+0x1750>
c001f7b8:	fff40413          	addi	s0,s0,-1
c001f7bc:	fffc8c93          	addi	s9,s9,-1
c001f7c0:	0e812703          	lw	a4,232(sp)
c001f7c4:	014787b3          	add	a5,a5,s4
c001f7c8:	0158a023          	sw	s5,0(a7)
c001f7cc:	00170713          	addi	a4,a4,1
c001f7d0:	0148a223          	sw	s4,4(a7)
c001f7d4:	0ef12623          	sw	a5,236(sp)
c001f7d8:	0ee12423          	sw	a4,232(sp)
c001f7dc:	00888893          	addi	a7,a7,8
c001f7e0:	10e4ce63          	blt	s1,a4,c001f8fc <_svfprintf_r+0x1808>
c001f7e4:	00044683          	lbu	a3,0(s0)
c001f7e8:	41bb8633          	sub	a2,s7,s11
c001f7ec:	00068c13          	mv	s8,a3
c001f7f0:	00d65463          	bge	a2,a3,c001f7f8 <_svfprintf_r+0x1704>
c001f7f4:	00060c13          	mv	s8,a2
c001f7f8:	03805663          	blez	s8,c001f824 <_svfprintf_r+0x1730>
c001f7fc:	0e812683          	lw	a3,232(sp)
c001f800:	018787b3          	add	a5,a5,s8
c001f804:	01b8a023          	sw	s11,0(a7)
c001f808:	00168693          	addi	a3,a3,1
c001f80c:	0188a223          	sw	s8,4(a7)
c001f810:	0ef12623          	sw	a5,236(sp)
c001f814:	0ed12423          	sw	a3,232(sp)
c001f818:	34d4c063          	blt	s1,a3,c001fb58 <_svfprintf_r+0x1a64>
c001f81c:	00044683          	lbu	a3,0(s0)
c001f820:	00888893          	addi	a7,a7,8
c001f824:	fffc4613          	not	a2,s8
c001f828:	41f65613          	srai	a2,a2,0x1f
c001f82c:	00cc7733          	and	a4,s8,a2
c001f830:	40e68c33          	sub	s8,a3,a4
c001f834:	01804c63          	bgtz	s8,c001f84c <_svfprintf_r+0x1758>
c001f838:	00dd8db3          	add	s11,s11,a3
c001f83c:	f60c9ce3          	bnez	s9,c001f7b4 <_svfprintf_r+0x16c0>
c001f840:	70098863          	beqz	s3,c001ff50 <_svfprintf_r+0x1e5c>
c001f844:	fff98993          	addi	s3,s3,-1
c001f848:	f79ff06f          	j	c001f7c0 <_svfprintf_r+0x16cc>
c001f84c:	0e812683          	lw	a3,232(sp)
c001f850:	01894863          	blt	s2,s8,c001f860 <_svfprintf_r+0x176c>
c001f854:	0580006f          	j	c001f8ac <_svfprintf_r+0x17b8>
c001f858:	ff0c0c13          	addi	s8,s8,-16
c001f85c:	05895863          	bge	s2,s8,c001f8ac <_svfprintf_r+0x17b8>
c001f860:	00812703          	lw	a4,8(sp)
c001f864:	01078793          	addi	a5,a5,16
c001f868:	00168693          	addi	a3,a3,1
c001f86c:	00e8a023          	sw	a4,0(a7)
c001f870:	0128a223          	sw	s2,4(a7)
c001f874:	0ef12623          	sw	a5,236(sp)
c001f878:	0ed12423          	sw	a3,232(sp)
c001f87c:	00888893          	addi	a7,a7,8
c001f880:	fcd4dce3          	bge	s1,a3,c001f858 <_svfprintf_r+0x1764>
c001f884:	0e410613          	addi	a2,sp,228
c001f888:	000b0593          	mv	a1,s6
c001f88c:	000d0513          	mv	a0,s10
c001f890:	45c0a0ef          	jal	ra,c0029cec <__ssprint_r>
c001f894:	58051863          	bnez	a0,c001fe24 <_svfprintf_r+0x1d30>
c001f898:	ff0c0c13          	addi	s8,s8,-16
c001f89c:	0ec12783          	lw	a5,236(sp)
c001f8a0:	0e812683          	lw	a3,232(sp)
c001f8a4:	10c10893          	addi	a7,sp,268
c001f8a8:	fb894ce3          	blt	s2,s8,c001f860 <_svfprintf_r+0x176c>
c001f8ac:	00812703          	lw	a4,8(sp)
c001f8b0:	018787b3          	add	a5,a5,s8
c001f8b4:	00168693          	addi	a3,a3,1
c001f8b8:	00e8a023          	sw	a4,0(a7)
c001f8bc:	0188a223          	sw	s8,4(a7)
c001f8c0:	0ef12623          	sw	a5,236(sp)
c001f8c4:	0ed12423          	sw	a3,232(sp)
c001f8c8:	74d4c063          	blt	s1,a3,c0020008 <_svfprintf_r+0x1f14>
c001f8cc:	00044683          	lbu	a3,0(s0)
c001f8d0:	00888893          	addi	a7,a7,8
c001f8d4:	00dd8db3          	add	s11,s11,a3
c001f8d8:	f65ff06f          	j	c001f83c <_svfprintf_r+0x1748>
c001f8dc:	01412683          	lw	a3,20(sp)
c001f8e0:	010a7793          	andi	a5,s4,16
c001f8e4:	00468713          	addi	a4,a3,4
c001f8e8:	20078463          	beqz	a5,c001faf0 <_svfprintf_r+0x19fc>
c001f8ec:	0006ac83          	lw	s9,0(a3)
c001f8f0:	00000913          	li	s2,0
c001f8f4:	00e12a23          	sw	a4,20(sp)
c001f8f8:	d21ff06f          	j	c001f618 <_svfprintf_r+0x1524>
c001f8fc:	0e410613          	addi	a2,sp,228
c001f900:	000b0593          	mv	a1,s6
c001f904:	000d0513          	mv	a0,s10
c001f908:	3e40a0ef          	jal	ra,c0029cec <__ssprint_r>
c001f90c:	50051c63          	bnez	a0,c001fe24 <_svfprintf_r+0x1d30>
c001f910:	0ec12783          	lw	a5,236(sp)
c001f914:	10c10893          	addi	a7,sp,268
c001f918:	ecdff06f          	j	c001f7e4 <_svfprintf_r+0x16f0>
c001f91c:	0e410613          	addi	a2,sp,228
c001f920:	000c0593          	mv	a1,s8
c001f924:	000d0513          	mv	a0,s10
c001f928:	3c40a0ef          	jal	ra,c0029cec <__ssprint_r>
c001f92c:	f8051463          	bnez	a0,c001f0b4 <_svfprintf_r+0xfc0>
c001f930:	0e812703          	lw	a4,232(sp)
c001f934:	0ec12c83          	lw	s9,236(sp)
c001f938:	11410893          	addi	a7,sp,276
c001f93c:	00170713          	addi	a4,a4,1
c001f940:	10c10913          	addi	s2,sp,268
c001f944:	f8dfe06f          	j	c001e8d0 <_svfprintf_r+0x7dc>
c001f948:	1b010b13          	addi	s6,sp,432
c001f94c:	00000793          	li	a5,0
c001f950:	00812823          	sw	s0,16(sp)
c001f954:	00912e23          	sw	s1,28(sp)
c001f958:	000b0413          	mv	s0,s6
c001f95c:	03312223          	sw	s3,36(sp)
c001f960:	000c0b13          	mv	s6,s8
c001f964:	000c8493          	mv	s1,s9
c001f968:	00090993          	mv	s3,s2
c001f96c:	03c12c83          	lw	s9,60(sp)
c001f970:	400bfa13          	andi	s4,s7,1024
c001f974:	0ff00a93          	li	s5,255
c001f978:	00088c13          	mv	s8,a7
c001f97c:	00078913          	mv	s2,a5
c001f980:	0240006f          	j	c001f9a4 <_svfprintf_r+0x18b0>
c001f984:	00a00613          	li	a2,10
c001f988:	00000693          	li	a3,0
c001f98c:	00048513          	mv	a0,s1
c001f990:	00098593          	mv	a1,s3
c001f994:	4e50d0ef          	jal	ra,c002d678 <__udivdi3>
c001f998:	48098c63          	beqz	s3,c001fe30 <_svfprintf_r+0x1d3c>
c001f99c:	00050493          	mv	s1,a0
c001f9a0:	00058993          	mv	s3,a1
c001f9a4:	00a00613          	li	a2,10
c001f9a8:	00000693          	li	a3,0
c001f9ac:	00048513          	mv	a0,s1
c001f9b0:	00098593          	mv	a1,s3
c001f9b4:	0f80e0ef          	jal	ra,c002daac <__umoddi3>
c001f9b8:	03050513          	addi	a0,a0,48
c001f9bc:	fea40fa3          	sb	a0,-1(s0)
c001f9c0:	00190913          	addi	s2,s2,1
c001f9c4:	fff40413          	addi	s0,s0,-1
c001f9c8:	fa0a0ee3          	beqz	s4,c001f984 <_svfprintf_r+0x1890>
c001f9cc:	000cc683          	lbu	a3,0(s9)
c001f9d0:	fad91ae3          	bne	s2,a3,c001f984 <_svfprintf_r+0x1890>
c001f9d4:	fb5908e3          	beq	s2,s5,c001f984 <_svfprintf_r+0x1890>
c001f9d8:	40099663          	bnez	s3,c001fde4 <_svfprintf_r+0x1cf0>
c001f9dc:	00900793          	li	a5,9
c001f9e0:	4097e263          	bltu	a5,s1,c001fde4 <_svfprintf_r+0x1cf0>
c001f9e4:	000c0893          	mv	a7,s8
c001f9e8:	1b010793          	addi	a5,sp,432
c001f9ec:	000b0c13          	mv	s8,s6
c001f9f0:	00040b13          	mv	s6,s0
c001f9f4:	03912e23          	sw	s9,60(sp)
c001f9f8:	01c12483          	lw	s1,28(sp)
c001f9fc:	02412983          	lw	s3,36(sp)
c001fa00:	01012403          	lw	s0,16(sp)
c001fa04:	03212023          	sw	s2,32(sp)
c001fa08:	41678cb3          	sub	s9,a5,s6
c001fa0c:	000b8a13          	mv	s4,s7
c001fa10:	94cff06f          	j	c001eb5c <_svfprintf_r+0xa68>
c001fa14:	0e812703          	lw	a4,232(sp)
c001fa18:	c80026b7          	lui	a3,0xc8002
c001fa1c:	71468693          	addi	a3,a3,1812 # c8002714 <_end+0xfff7de94>
c001fa20:	00d8a023          	sw	a3,0(a7)
c001fa24:	00178793          	addi	a5,a5,1
c001fa28:	00100693          	li	a3,1
c001fa2c:	00170713          	addi	a4,a4,1
c001fa30:	00d8a223          	sw	a3,4(a7)
c001fa34:	0ef12623          	sw	a5,236(sp)
c001fa38:	0ee12423          	sw	a4,232(sp)
c001fa3c:	00700693          	li	a3,7
c001fa40:	00888893          	addi	a7,a7,8
c001fa44:	06e6cc63          	blt	a3,a4,c001fabc <_svfprintf_r+0x19c8>
c001fa48:	1e061463          	bnez	a2,c001fc30 <_svfprintf_r+0x1b3c>
c001fa4c:	02012683          	lw	a3,32(sp)
c001fa50:	001a7713          	andi	a4,s4,1
c001fa54:	00d76733          	or	a4,a4,a3
c001fa58:	00071463          	bnez	a4,c001fa60 <_svfprintf_r+0x196c>
c001fa5c:	949fe06f          	j	c001e3a4 <_svfprintf_r+0x2b0>
c001fa60:	03012703          	lw	a4,48(sp)
c001fa64:	02c12683          	lw	a3,44(sp)
c001fa68:	00e8a023          	sw	a4,0(a7)
c001fa6c:	0e812703          	lw	a4,232(sp)
c001fa70:	00f687b3          	add	a5,a3,a5
c001fa74:	00d8a223          	sw	a3,4(a7)
c001fa78:	00170713          	addi	a4,a4,1
c001fa7c:	0ef12623          	sw	a5,236(sp)
c001fa80:	0ee12423          	sw	a4,232(sp)
c001fa84:	00700693          	li	a3,7
c001fa88:	48e6ca63          	blt	a3,a4,c001ff1c <_svfprintf_r+0x1e28>
c001fa8c:	00888893          	addi	a7,a7,8
c001fa90:	02012683          	lw	a3,32(sp)
c001fa94:	00170713          	addi	a4,a4,1
c001fa98:	0168a023          	sw	s6,0(a7)
c001fa9c:	00f687b3          	add	a5,a3,a5
c001faa0:	00d8a223          	sw	a3,4(a7)
c001faa4:	0ef12623          	sw	a5,236(sp)
c001faa8:	0ee12423          	sw	a4,232(sp)
c001faac:	00700693          	li	a3,7
c001fab0:	00e6c463          	blt	a3,a4,c001fab8 <_svfprintf_r+0x19c4>
c001fab4:	8edfe06f          	j	c001e3a0 <_svfprintf_r+0x2ac>
c001fab8:	e3dfe06f          	j	c001e8f4 <_svfprintf_r+0x800>
c001fabc:	0e410613          	addi	a2,sp,228
c001fac0:	000c0593          	mv	a1,s8
c001fac4:	000d0513          	mv	a0,s10
c001fac8:	2240a0ef          	jal	ra,c0029cec <__ssprint_r>
c001facc:	de051463          	bnez	a0,c001f0b4 <_svfprintf_r+0xfc0>
c001fad0:	0cc12603          	lw	a2,204(sp)
c001fad4:	0ec12783          	lw	a5,236(sp)
c001fad8:	10c10893          	addi	a7,sp,268
c001fadc:	f6dff06f          	j	c001fa48 <_svfprintf_r+0x1954>
c001fae0:	01012b83          	lw	s7,16(sp)
c001fae4:	00040d13          	mv	s10,s0
c001fae8:	00048c13          	mv	s8,s1
c001faec:	dccff06f          	j	c001f0b8 <_svfprintf_r+0xfc4>
c001faf0:	040a7793          	andi	a5,s4,64
c001faf4:	26078663          	beqz	a5,c001fd60 <_svfprintf_r+0x1c6c>
c001faf8:	01412783          	lw	a5,20(sp)
c001fafc:	00000913          	li	s2,0
c001fb00:	00e12a23          	sw	a4,20(sp)
c001fb04:	0007dc83          	lhu	s9,0(a5)
c001fb08:	b11ff06f          	j	c001f618 <_svfprintf_r+0x1524>
c001fb0c:	0e410613          	addi	a2,sp,228
c001fb10:	000c0593          	mv	a1,s8
c001fb14:	000d0513          	mv	a0,s10
c001fb18:	1d40a0ef          	jal	ra,c0029cec <__ssprint_r>
c001fb1c:	d8051c63          	bnez	a0,c001f0b4 <_svfprintf_r+0xfc0>
c001fb20:	0ec12783          	lw	a5,236(sp)
c001fb24:	10c10893          	addi	a7,sp,268
c001fb28:	b50ff06f          	j	c001ee78 <_svfprintf_r+0xd84>
c001fb2c:	00812683          	lw	a3,8(sp)
c001fb30:	009787b3          	add	a5,a5,s1
c001fb34:	0098a223          	sw	s1,4(a7)
c001fb38:	00d8a023          	sw	a3,0(a7)
c001fb3c:	00170713          	addi	a4,a4,1
c001fb40:	0ef12623          	sw	a5,236(sp)
c001fb44:	0ee12423          	sw	a4,232(sp)
c001fb48:	00700693          	li	a3,7
c001fb4c:	00e6c463          	blt	a3,a4,c001fb54 <_svfprintf_r+0x1a60>
c001fb50:	851fe06f          	j	c001e3a0 <_svfprintf_r+0x2ac>
c001fb54:	da1fe06f          	j	c001e8f4 <_svfprintf_r+0x800>
c001fb58:	0e410613          	addi	a2,sp,228
c001fb5c:	000b0593          	mv	a1,s6
c001fb60:	000d0513          	mv	a0,s10
c001fb64:	1880a0ef          	jal	ra,c0029cec <__ssprint_r>
c001fb68:	2a051e63          	bnez	a0,c001fe24 <_svfprintf_r+0x1d30>
c001fb6c:	00044683          	lbu	a3,0(s0)
c001fb70:	0ec12783          	lw	a5,236(sp)
c001fb74:	10c10893          	addi	a7,sp,268
c001fb78:	cadff06f          	j	c001f824 <_svfprintf_r+0x1730>
c001fb7c:	0f012783          	lw	a5,240(sp)
c001fb80:	0a010593          	addi	a1,sp,160
c001fb84:	0b010513          	addi	a0,sp,176
c001fb88:	0af12823          	sw	a5,176(sp)
c001fb8c:	0f412783          	lw	a5,244(sp)
c001fb90:	0a012023          	sw	zero,160(sp)
c001fb94:	0a012223          	sw	zero,164(sp)
c001fb98:	0af12a23          	sw	a5,180(sp)
c001fb9c:	0f812783          	lw	a5,248(sp)
c001fba0:	0a012423          	sw	zero,168(sp)
c001fba4:	0a012623          	sw	zero,172(sp)
c001fba8:	0af12c23          	sw	a5,184(sp)
c001fbac:	0fc12783          	lw	a5,252(sp)
c001fbb0:	0af12e23          	sw	a5,188(sp)
c001fbb4:	1b40f0ef          	jal	ra,c002ed68 <__letf2>
c001fbb8:	01012883          	lw	a7,16(sp)
c001fbbc:	46054a63          	bltz	a0,c0020030 <_svfprintf_r+0x1f3c>
c001fbc0:	0c714783          	lbu	a5,199(sp)
c001fbc4:	04700713          	li	a4,71
c001fbc8:	26975a63          	bge	a4,s1,c001fe3c <_svfprintf_r+0x1d48>
c001fbcc:	c8002837          	lui	a6,0xc8002
c001fbd0:	6d880b13          	addi	s6,a6,1752 # c80026d8 <_end+0xfff7de58>
c001fbd4:	00012823          	sw	zero,16(sp)
c001fbd8:	02012423          	sw	zero,40(sp)
c001fbdc:	02012223          	sw	zero,36(sp)
c001fbe0:	00012e23          	sw	zero,28(sp)
c001fbe4:	f7fa7a13          	andi	s4,s4,-129
c001fbe8:	00300a93          	li	s5,3
c001fbec:	00300c93          	li	s9,3
c001fbf0:	00000d93          	li	s11,0
c001fbf4:	00078463          	beqz	a5,c001fbfc <_svfprintf_r+0x1b08>
c001fbf8:	e51fe06f          	j	c001ea48 <_svfprintf_r+0x954>
c001fbfc:	edcfe06f          	j	c001e2d8 <_svfprintf_r+0x1e4>
c001fc00:	00c12783          	lw	a5,12(sp)
c001fc04:	00040b13          	mv	s6,s0
c001fc08:	00f72023          	sw	a5,0(a4)
c001fc0c:	fe0fe06f          	j	c001e3ec <_svfprintf_r+0x2f8>
c001fc10:	00600793          	li	a5,6
c001fc14:	000d8c93          	mv	s9,s11
c001fc18:	25b7e863          	bltu	a5,s11,c001fe68 <_svfprintf_r+0x1d74>
c001fc1c:	c8002837          	lui	a6,0xc8002
c001fc20:	000c8a93          	mv	s5,s9
c001fc24:	01212a23          	sw	s2,20(sp)
c001fc28:	70c80b13          	addi	s6,a6,1804 # c800270c <_end+0xfff7de8c>
c001fc2c:	e98fe06f          	j	c001e2c4 <_svfprintf_r+0x1d0>
c001fc30:	03012703          	lw	a4,48(sp)
c001fc34:	02c12683          	lw	a3,44(sp)
c001fc38:	00888893          	addi	a7,a7,8
c001fc3c:	fee8ac23          	sw	a4,-8(a7)
c001fc40:	0e812703          	lw	a4,232(sp)
c001fc44:	00f687b3          	add	a5,a3,a5
c001fc48:	fed8ae23          	sw	a3,-4(a7)
c001fc4c:	00170713          	addi	a4,a4,1
c001fc50:	0ef12623          	sw	a5,236(sp)
c001fc54:	0ee12423          	sw	a4,232(sp)
c001fc58:	00700693          	li	a3,7
c001fc5c:	2ce6c063          	blt	a3,a4,c001ff1c <_svfprintf_r+0x1e28>
c001fc60:	e20658e3          	bgez	a2,c001fa90 <_svfprintf_r+0x199c>
c001fc64:	ff000693          	li	a3,-16
c001fc68:	40c004b3          	neg	s1,a2
c001fc6c:	2ad658e3          	bge	a2,a3,c002071c <_svfprintf_r+0x2628>
c001fc70:	01000913          	li	s2,16
c001fc74:	00700c93          	li	s9,7
c001fc78:	00c0006f          	j	c001fc84 <_svfprintf_r+0x1b90>
c001fc7c:	ff048493          	addi	s1,s1,-16
c001fc80:	28995ee3          	bge	s2,s1,c002071c <_svfprintf_r+0x2628>
c001fc84:	00812683          	lw	a3,8(sp)
c001fc88:	01078793          	addi	a5,a5,16
c001fc8c:	00170713          	addi	a4,a4,1
c001fc90:	00d8a023          	sw	a3,0(a7)
c001fc94:	0128a223          	sw	s2,4(a7)
c001fc98:	0ef12623          	sw	a5,236(sp)
c001fc9c:	0ee12423          	sw	a4,232(sp)
c001fca0:	00888893          	addi	a7,a7,8
c001fca4:	fcecdce3          	bge	s9,a4,c001fc7c <_svfprintf_r+0x1b88>
c001fca8:	0e410613          	addi	a2,sp,228
c001fcac:	000c0593          	mv	a1,s8
c001fcb0:	000d0513          	mv	a0,s10
c001fcb4:	0380a0ef          	jal	ra,c0029cec <__ssprint_r>
c001fcb8:	be051e63          	bnez	a0,c001f0b4 <_svfprintf_r+0xfc0>
c001fcbc:	0ec12783          	lw	a5,236(sp)
c001fcc0:	0e812703          	lw	a4,232(sp)
c001fcc4:	10c10893          	addi	a7,sp,268
c001fcc8:	fb5ff06f          	j	c001fc7c <_svfprintf_r+0x1b88>
c001fccc:	00148713          	addi	a4,s1,1
c001fcd0:	00890693          	addi	a3,s2,8
c001fcd4:	00812783          	lw	a5,8(sp)
c001fcd8:	01bc8cb3          	add	s9,s9,s11
c001fcdc:	01b92223          	sw	s11,4(s2)
c001fce0:	00f92023          	sw	a5,0(s2)
c001fce4:	0f912623          	sw	s9,236(sp)
c001fce8:	0ee12423          	sw	a4,232(sp)
c001fcec:	00700793          	li	a5,7
c001fcf0:	c2e7c6e3          	blt	a5,a4,c001f91c <_svfprintf_r+0x1828>
c001fcf4:	00170713          	addi	a4,a4,1
c001fcf8:	00868893          	addi	a7,a3,8
c001fcfc:	00068913          	mv	s2,a3
c001fd00:	bd1fe06f          	j	c001e8d0 <_svfprintf_r+0x7dc>
c001fd04:	200a7793          	andi	a5,s4,512
c001fd08:	1a078863          	beqz	a5,c001feb8 <_svfprintf_r+0x1dc4>
c001fd0c:	01412783          	lw	a5,20(sp)
c001fd10:	00000913          	li	s2,0
c001fd14:	00e12a23          	sw	a4,20(sp)
c001fd18:	0007cc83          	lbu	s9,0(a5)
c001fd1c:	e95fe06f          	j	c001ebb0 <_svfprintf_r+0xabc>
c001fd20:	200bf793          	andi	a5,s7,512
c001fd24:	16078e63          	beqz	a5,c001fea0 <_svfprintf_r+0x1dac>
c001fd28:	01412783          	lw	a5,20(sp)
c001fd2c:	00000913          	li	s2,0
c001fd30:	00d12a23          	sw	a3,20(sp)
c001fd34:	0007cc83          	lbu	s9,0(a5)
c001fd38:	00100793          	li	a5,1
c001fd3c:	df5fe06f          	j	c001eb30 <_svfprintf_r+0xa3c>
c001fd40:	200a7793          	andi	a5,s4,512
c001fd44:	18078e63          	beqz	a5,c001fee0 <_svfprintf_r+0x1dec>
c001fd48:	01412783          	lw	a5,20(sp)
c001fd4c:	00e12a23          	sw	a4,20(sp)
c001fd50:	00078c83          	lb	s9,0(a5)
c001fd54:	41fcd913          	srai	s2,s9,0x1f
c001fd58:	00090793          	mv	a5,s2
c001fd5c:	eddfe06f          	j	c001ec38 <_svfprintf_r+0xb44>
c001fd60:	200a7793          	andi	a5,s4,512
c001fd64:	16078463          	beqz	a5,c001fecc <_svfprintf_r+0x1dd8>
c001fd68:	01412783          	lw	a5,20(sp)
c001fd6c:	00000913          	li	s2,0
c001fd70:	00e12a23          	sw	a4,20(sp)
c001fd74:	0007cc83          	lbu	s9,0(a5)
c001fd78:	8a1ff06f          	j	c001f618 <_svfprintf_r+0x1524>
c001fd7c:	0fc12783          	lw	a5,252(sp)
c001fd80:	1607cc63          	bltz	a5,c001fef8 <_svfprintf_r+0x1e04>
c001fd84:	0c714783          	lbu	a5,199(sp)
c001fd88:	04700713          	li	a4,71
c001fd8c:	44975863          	bge	a4,s1,c00201dc <_svfprintf_r+0x20e8>
c001fd90:	c8002837          	lui	a6,0xc8002
c001fd94:	6e080b13          	addi	s6,a6,1760 # c80026e0 <_end+0xfff7de60>
c001fd98:	e3dff06f          	j	c001fbd4 <_svfprintf_r+0x1ae0>
c001fd9c:	00812683          	lw	a3,8(sp)
c001fda0:	009787b3          	add	a5,a5,s1
c001fda4:	00170713          	addi	a4,a4,1
c001fda8:	00d8a023          	sw	a3,0(a7)
c001fdac:	0098a223          	sw	s1,4(a7)
c001fdb0:	0ef12623          	sw	a5,236(sp)
c001fdb4:	0ee12423          	sw	a4,232(sp)
c001fdb8:	00700693          	li	a3,7
c001fdbc:	00888893          	addi	a7,a7,8
c001fdc0:	c6e6dc63          	bge	a3,a4,c001f238 <_svfprintf_r+0x1144>
c001fdc4:	0e410613          	addi	a2,sp,228
c001fdc8:	000c0593          	mv	a1,s8
c001fdcc:	000d0513          	mv	a0,s10
c001fdd0:	71d090ef          	jal	ra,c0029cec <__ssprint_r>
c001fdd4:	ae051063          	bnez	a0,c001f0b4 <_svfprintf_r+0xfc0>
c001fdd8:	0ec12783          	lw	a5,236(sp)
c001fddc:	10c10893          	addi	a7,sp,268
c001fde0:	c58ff06f          	j	c001f238 <_svfprintf_r+0x1144>
c001fde4:	04812783          	lw	a5,72(sp)
c001fde8:	04c12583          	lw	a1,76(sp)
c001fdec:	00000913          	li	s2,0
c001fdf0:	40f40433          	sub	s0,s0,a5
c001fdf4:	00078613          	mv	a2,a5
c001fdf8:	00040513          	mv	a0,s0
c001fdfc:	649090ef          	jal	ra,c0029c44 <strncpy>
c001fe00:	001cc583          	lbu	a1,1(s9)
c001fe04:	00a00613          	li	a2,10
c001fe08:	00000693          	li	a3,0
c001fe0c:	00b03833          	snez	a6,a1
c001fe10:	00048513          	mv	a0,s1
c001fe14:	00098593          	mv	a1,s3
c001fe18:	010c8cb3          	add	s9,s9,a6
c001fe1c:	05d0d0ef          	jal	ra,c002d678 <__udivdi3>
c001fe20:	b7dff06f          	j	c001f99c <_svfprintf_r+0x18a8>
c001fe24:	01012b83          	lw	s7,16(sp)
c001fe28:	000b0c13          	mv	s8,s6
c001fe2c:	a8cff06f          	j	c001f0b8 <_svfprintf_r+0xfc4>
c001fe30:	00900793          	li	a5,9
c001fe34:	b697e4e3          	bltu	a5,s1,c001f99c <_svfprintf_r+0x18a8>
c001fe38:	badff06f          	j	c001f9e4 <_svfprintf_r+0x18f0>
c001fe3c:	c8002837          	lui	a6,0xc8002
c001fe40:	6d480b13          	addi	s6,a6,1748 # c80026d4 <_end+0xfff7de54>
c001fe44:	d91ff06f          	j	c001fbd4 <_svfprintf_r+0x1ae0>
c001fe48:	0e410613          	addi	a2,sp,228
c001fe4c:	000c0593          	mv	a1,s8
c001fe50:	000d0513          	mv	a0,s10
c001fe54:	699090ef          	jal	ra,c0029cec <__ssprint_r>
c001fe58:	a4051e63          	bnez	a0,c001f0b4 <_svfprintf_r+0xfc0>
c001fe5c:	0ec12783          	lw	a5,236(sp)
c001fe60:	10c10893          	addi	a7,sp,268
c001fe64:	bbcff06f          	j	c001f220 <_svfprintf_r+0x112c>
c001fe68:	00600c93          	li	s9,6
c001fe6c:	db1ff06f          	j	c001fc1c <_svfprintf_r+0x1b28>
c001fe70:	02012703          	lw	a4,32(sp)
c001fe74:	00eb0833          	add	a6,s6,a4
c001fe78:	409704b3          	sub	s1,a4,s1
c001fe7c:	41b806b3          	sub	a3,a6,s11
c001fe80:	00048913          	mv	s2,s1
c001fe84:	c496d863          	bge	a3,s1,c001f2d4 <_svfprintf_r+0x11e0>
c001fe88:	00068913          	mv	s2,a3
c001fe8c:	c48ff06f          	j	c001f2d4 <_svfprintf_r+0x11e0>
c001fe90:	00c12783          	lw	a5,12(sp)
c001fe94:	00040b13          	mv	s6,s0
c001fe98:	00f71023          	sh	a5,0(a4)
c001fe9c:	d50fe06f          	j	c001e3ec <_svfprintf_r+0x2f8>
c001fea0:	01412783          	lw	a5,20(sp)
c001fea4:	00000913          	li	s2,0
c001fea8:	00d12a23          	sw	a3,20(sp)
c001feac:	0007ac83          	lw	s9,0(a5)
c001feb0:	00100793          	li	a5,1
c001feb4:	c7dfe06f          	j	c001eb30 <_svfprintf_r+0xa3c>
c001feb8:	01412783          	lw	a5,20(sp)
c001febc:	00000913          	li	s2,0
c001fec0:	00e12a23          	sw	a4,20(sp)
c001fec4:	0007ac83          	lw	s9,0(a5)
c001fec8:	ce9fe06f          	j	c001ebb0 <_svfprintf_r+0xabc>
c001fecc:	01412783          	lw	a5,20(sp)
c001fed0:	00000913          	li	s2,0
c001fed4:	00e12a23          	sw	a4,20(sp)
c001fed8:	0007ac83          	lw	s9,0(a5)
c001fedc:	f3cff06f          	j	c001f618 <_svfprintf_r+0x1524>
c001fee0:	01412783          	lw	a5,20(sp)
c001fee4:	00e12a23          	sw	a4,20(sp)
c001fee8:	0007ac83          	lw	s9,0(a5)
c001feec:	41fcd913          	srai	s2,s9,0x1f
c001fef0:	00090793          	mv	a5,s2
c001fef4:	d45fe06f          	j	c001ec38 <_svfprintf_r+0xb44>
c001fef8:	02d00793          	li	a5,45
c001fefc:	0cf103a3          	sb	a5,199(sp)
c001ff00:	e89ff06f          	j	c001fd88 <_svfprintf_r+0x1c94>
c001ff04:	0e410613          	addi	a2,sp,228
c001ff08:	000c0593          	mv	a1,s8
c001ff0c:	000d0513          	mv	a0,s10
c001ff10:	5dd090ef          	jal	ra,c0029cec <__ssprint_r>
c001ff14:	00cc5783          	lhu	a5,12(s8)
c001ff18:	cecfe06f          	j	c001e404 <_svfprintf_r+0x310>
c001ff1c:	0e410613          	addi	a2,sp,228
c001ff20:	000c0593          	mv	a1,s8
c001ff24:	000d0513          	mv	a0,s10
c001ff28:	5c5090ef          	jal	ra,c0029cec <__ssprint_r>
c001ff2c:	98051463          	bnez	a0,c001f0b4 <_svfprintf_r+0xfc0>
c001ff30:	0cc12603          	lw	a2,204(sp)
c001ff34:	0ec12783          	lw	a5,236(sp)
c001ff38:	0e812703          	lw	a4,232(sp)
c001ff3c:	10c10893          	addi	a7,sp,268
c001ff40:	b40658e3          	bgez	a2,c001fa90 <_svfprintf_r+0x199c>
c001ff44:	d21ff06f          	j	c001fc64 <_svfprintf_r+0x1b70>
c001ff48:	00600d93          	li	s11,6
c001ff4c:	e40fe06f          	j	c001e58c <_svfprintf_r+0x498>
c001ff50:	02012703          	lw	a4,32(sp)
c001ff54:	000b0c13          	mv	s8,s6
c001ff58:	02812b03          	lw	s6,40(sp)
c001ff5c:	02812e23          	sw	s0,60(sp)
c001ff60:	01c12a03          	lw	s4,28(sp)
c001ff64:	00eb0733          	add	a4,s6,a4
c001ff68:	04012403          	lw	s0,64(sp)
c001ff6c:	04412983          	lw	s3,68(sp)
c001ff70:	02412a83          	lw	s5,36(sp)
c001ff74:	adb77a63          	bgeu	a4,s11,c001f248 <_svfprintf_r+0x1154>
c001ff78:	00070d93          	mv	s11,a4
c001ff7c:	accff06f          	j	c001f248 <_svfprintf_r+0x1154>
c001ff80:	01c12703          	lw	a4,28(sp)
c001ff84:	ffd00793          	li	a5,-3
c001ff88:	00f74463          	blt	a4,a5,c001ff90 <_svfprintf_r+0x1e9c>
c001ff8c:	00edda63          	bge	s11,a4,c001ffa0 <_svfprintf_r+0x1eac>
c001ff90:	ffe48493          	addi	s1,s1,-2
c001ff94:	fdf4f793          	andi	a5,s1,-33
c001ff98:	02f12423          	sw	a5,40(sp)
c001ff9c:	ee4fe06f          	j	c001e680 <_svfprintf_r+0x58c>
c001ffa0:	02012783          	lw	a5,32(sp)
c001ffa4:	01c12703          	lw	a4,28(sp)
c001ffa8:	26f74863          	blt	a4,a5,c0020218 <_svfprintf_r+0x2124>
c001ffac:	05012783          	lw	a5,80(sp)
c001ffb0:	00070c93          	mv	s9,a4
c001ffb4:	0017f793          	andi	a5,a5,1
c001ffb8:	00078663          	beqz	a5,c001ffc4 <_svfprintf_r+0x1ed0>
c001ffbc:	02c12783          	lw	a5,44(sp)
c001ffc0:	00f70cb3          	add	s9,a4,a5
c001ffc4:	05012783          	lw	a5,80(sp)
c001ffc8:	4007f793          	andi	a5,a5,1024
c001ffcc:	00078663          	beqz	a5,c001ffd8 <_svfprintf_r+0x1ee4>
c001ffd0:	01c12783          	lw	a5,28(sp)
c001ffd4:	10f048e3          	bgtz	a5,c00208e4 <_svfprintf_r+0x27f0>
c001ffd8:	fffcca93          	not	s5,s9
c001ffdc:	41fada93          	srai	s5,s5,0x1f
c001ffe0:	015cfab3          	and	s5,s9,s5
c001ffe4:	06700493          	li	s1,103
c001ffe8:	02012423          	sw	zero,40(sp)
c001ffec:	02012223          	sw	zero,36(sp)
c001fff0:	facfe06f          	j	c001e79c <_svfprintf_r+0x6a8>
c001fff4:	0c714783          	lbu	a5,199(sp)
c001fff8:	00000d93          	li	s11,0
c001fffc:	00078463          	beqz	a5,c0020004 <_svfprintf_r+0x1f10>
c0020000:	a49fe06f          	j	c001ea48 <_svfprintf_r+0x954>
c0020004:	ad4fe06f          	j	c001e2d8 <_svfprintf_r+0x1e4>
c0020008:	0e410613          	addi	a2,sp,228
c002000c:	000b0593          	mv	a1,s6
c0020010:	000d0513          	mv	a0,s10
c0020014:	4d9090ef          	jal	ra,c0029cec <__ssprint_r>
c0020018:	e00516e3          	bnez	a0,c001fe24 <_svfprintf_r+0x1d30>
c002001c:	00044683          	lbu	a3,0(s0)
c0020020:	0ec12783          	lw	a5,236(sp)
c0020024:	10c10893          	addi	a7,sp,268
c0020028:	00dd8db3          	add	s11,s11,a3
c002002c:	811ff06f          	j	c001f83c <_svfprintf_r+0x1748>
c0020030:	02d00793          	li	a5,45
c0020034:	0cf103a3          	sb	a5,199(sp)
c0020038:	b8dff06f          	j	c001fbc4 <_svfprintf_r+0x1ad0>
c002003c:	0e410613          	addi	a2,sp,228
c0020040:	000c0593          	mv	a1,s8
c0020044:	000d0513          	mv	a0,s10
c0020048:	4a5090ef          	jal	ra,c0029cec <__ssprint_r>
c002004c:	00050463          	beqz	a0,c0020054 <_svfprintf_r+0x1f60>
c0020050:	864ff06f          	j	c001f0b4 <_svfprintf_r+0xfc0>
c0020054:	0cc12483          	lw	s1,204(sp)
c0020058:	0ec12783          	lw	a5,236(sp)
c002005c:	10c10893          	addi	a7,sp,268
c0020060:	a2cff06f          	j	c001f28c <_svfprintf_r+0x1198>
c0020064:	0b010a93          	addi	s5,sp,176
c0020068:	0d010793          	addi	a5,sp,208
c002006c:	0cc10713          	addi	a4,sp,204
c0020070:	0dc10813          	addi	a6,sp,220
c0020074:	000d8693          	mv	a3,s11
c0020078:	00300613          	li	a2,3
c002007c:	000a8593          	mv	a1,s5
c0020080:	000d0513          	mv	a0,s10
c0020084:	05112023          	sw	a7,64(sp)
c0020088:	0bc12823          	sw	t3,176(sp)
c002008c:	03c12223          	sw	t3,36(sp)
c0020090:	0bd12a23          	sw	t4,180(sp)
c0020094:	03d12023          	sw	t4,32(sp)
c0020098:	0be12c23          	sw	t5,184(sp)
c002009c:	01e12e23          	sw	t5,28(sp)
c00200a0:	0b712e23          	sw	s7,188(sp)
c00200a4:	79d050ef          	jal	ra,c0026040 <_ldtoa_r>
c00200a8:	00054703          	lbu	a4,0(a0)
c00200ac:	03000793          	li	a5,48
c00200b0:	01c12f03          	lw	t5,28(sp)
c00200b4:	02012e83          	lw	t4,32(sp)
c00200b8:	02412e03          	lw	t3,36(sp)
c00200bc:	04012883          	lw	a7,64(sp)
c00200c0:	00050b13          	mv	s6,a0
c00200c4:	0a010c93          	addi	s9,sp,160
c00200c8:	06f70c63          	beq	a4,a5,c0020140 <_svfprintf_r+0x204c>
c00200cc:	0cc12783          	lw	a5,204(sp)
c00200d0:	01b787b3          	add	a5,a5,s11
c00200d4:	00fb0933          	add	s2,s6,a5
c00200d8:	000c8593          	mv	a1,s9
c00200dc:	000a8513          	mv	a0,s5
c00200e0:	01112e23          	sw	a7,28(sp)
c00200e4:	0bc12823          	sw	t3,176(sp)
c00200e8:	0bd12a23          	sw	t4,180(sp)
c00200ec:	0be12c23          	sw	t5,184(sp)
c00200f0:	0b712e23          	sw	s7,188(sp)
c00200f4:	0a012023          	sw	zero,160(sp)
c00200f8:	0a012223          	sw	zero,164(sp)
c00200fc:	0a012423          	sw	zero,168(sp)
c0020100:	0a012623          	sw	zero,172(sp)
c0020104:	2550e0ef          	jal	ra,c002eb58 <__eqtf2>
c0020108:	01c12883          	lw	a7,28(sp)
c002010c:	00090693          	mv	a3,s2
c0020110:	00051463          	bnez	a0,c0020118 <_svfprintf_r+0x2024>
c0020114:	d3cfe06f          	j	c001e650 <_svfprintf_r+0x55c>
c0020118:	0dc12683          	lw	a3,220(sp)
c002011c:	0126e463          	bltu	a3,s2,c0020124 <_svfprintf_r+0x2030>
c0020120:	d30fe06f          	j	c001e650 <_svfprintf_r+0x55c>
c0020124:	03000713          	li	a4,48
c0020128:	00168793          	addi	a5,a3,1
c002012c:	0cf12e23          	sw	a5,220(sp)
c0020130:	00e68023          	sb	a4,0(a3)
c0020134:	0dc12683          	lw	a3,220(sp)
c0020138:	ff26e8e3          	bltu	a3,s2,c0020128 <_svfprintf_r+0x2034>
c002013c:	d14fe06f          	j	c001e650 <_svfprintf_r+0x55c>
c0020140:	0a010c93          	addi	s9,sp,160
c0020144:	000c8593          	mv	a1,s9
c0020148:	000a8513          	mv	a0,s5
c002014c:	05112023          	sw	a7,64(sp)
c0020150:	0bc12823          	sw	t3,176(sp)
c0020154:	03c12223          	sw	t3,36(sp)
c0020158:	0bd12a23          	sw	t4,180(sp)
c002015c:	03d12023          	sw	t4,32(sp)
c0020160:	0be12c23          	sw	t5,184(sp)
c0020164:	01e12e23          	sw	t5,28(sp)
c0020168:	0b712e23          	sw	s7,188(sp)
c002016c:	0a012023          	sw	zero,160(sp)
c0020170:	0a012223          	sw	zero,164(sp)
c0020174:	0a012423          	sw	zero,168(sp)
c0020178:	0a012623          	sw	zero,172(sp)
c002017c:	1dd0e0ef          	jal	ra,c002eb58 <__eqtf2>
c0020180:	01c12f03          	lw	t5,28(sp)
c0020184:	02012e83          	lw	t4,32(sp)
c0020188:	02412e03          	lw	t3,36(sp)
c002018c:	04012883          	lw	a7,64(sp)
c0020190:	f2050ee3          	beqz	a0,c00200cc <_svfprintf_r+0x1fd8>
c0020194:	00100793          	li	a5,1
c0020198:	41b787b3          	sub	a5,a5,s11
c002019c:	0cf12623          	sw	a5,204(sp)
c00201a0:	f31ff06f          	j	c00200d0 <_svfprintf_r+0x1fdc>
c00201a4:	c8002637          	lui	a2,0xc8002
c00201a8:	bd860e93          	addi	t4,a2,-1064 # c8001bd8 <_end+0xfff7d358>
c00201ac:	fcdfe06f          	j	c001f178 <_svfprintf_r+0x1084>
c00201b0:	0c714783          	lbu	a5,199(sp)
c00201b4:	01212a23          	sw	s2,20(sp)
c00201b8:	02012423          	sw	zero,40(sp)
c00201bc:	02012223          	sw	zero,36(sp)
c00201c0:	00012e23          	sw	zero,28(sp)
c00201c4:	000d8a93          	mv	s5,s11
c00201c8:	000d8c93          	mv	s9,s11
c00201cc:	00000d93          	li	s11,0
c00201d0:	00078463          	beqz	a5,c00201d8 <_svfprintf_r+0x20e4>
c00201d4:	875fe06f          	j	c001ea48 <_svfprintf_r+0x954>
c00201d8:	900fe06f          	j	c001e2d8 <_svfprintf_r+0x1e4>
c00201dc:	c8002837          	lui	a6,0xc8002
c00201e0:	6dc80b13          	addi	s6,a6,1756 # c80026dc <_end+0xfff7de5c>
c00201e4:	9f1ff06f          	j	c001fbd4 <_svfprintf_r+0x1ae0>
c00201e8:	0e410613          	addi	a2,sp,228
c00201ec:	000c0593          	mv	a1,s8
c00201f0:	000d0513          	mv	a0,s10
c00201f4:	2f9090ef          	jal	ra,c0029cec <__ssprint_r>
c00201f8:	00050463          	beqz	a0,c0020200 <_svfprintf_r+0x210c>
c00201fc:	eb9fe06f          	j	c001f0b4 <_svfprintf_r+0xfc0>
c0020200:	0cc12483          	lw	s1,204(sp)
c0020204:	02012703          	lw	a4,32(sp)
c0020208:	0ec12783          	lw	a5,236(sp)
c002020c:	10c10893          	addi	a7,sp,268
c0020210:	409704b3          	sub	s1,a4,s1
c0020214:	8c0ff06f          	j	c001f2d4 <_svfprintf_r+0x11e0>
c0020218:	02012783          	lw	a5,32(sp)
c002021c:	02c12703          	lw	a4,44(sp)
c0020220:	06700493          	li	s1,103
c0020224:	00e78cb3          	add	s9,a5,a4
c0020228:	01c12783          	lw	a5,28(sp)
c002022c:	72f05c63          	blez	a5,c0020964 <_svfprintf_r+0x2870>
c0020230:	05012783          	lw	a5,80(sp)
c0020234:	4007f793          	andi	a5,a5,1024
c0020238:	6a079863          	bnez	a5,c00208e8 <_svfprintf_r+0x27f4>
c002023c:	fffcca93          	not	s5,s9
c0020240:	41fada93          	srai	s5,s5,0x1f
c0020244:	015cfab3          	and	s5,s9,s5
c0020248:	da1ff06f          	j	c001ffe8 <_svfprintf_r+0x1ef4>
c002024c:	05012783          	lw	a5,80(sp)
c0020250:	01c12703          	lw	a4,28(sp)
c0020254:	0017f793          	andi	a5,a5,1
c0020258:	01b7e7b3          	or	a5,a5,s11
c002025c:	72e05a63          	blez	a4,c0020990 <_svfprintf_r+0x289c>
c0020260:	52079e63          	bnez	a5,c002079c <_svfprintf_r+0x26a8>
c0020264:	01c12c83          	lw	s9,28(sp)
c0020268:	06600493          	li	s1,102
c002026c:	fc5ff06f          	j	c0020230 <_svfprintf_r+0x213c>
c0020270:	03000793          	li	a5,48
c0020274:	0cf10423          	sb	a5,200(sp)
c0020278:	05800793          	li	a5,88
c002027c:	002a6713          	ori	a4,s4,2
c0020280:	0cf104a3          	sb	a5,201(sp)
c0020284:	04e12823          	sw	a4,80(sp)
c0020288:	06300793          	li	a5,99
c002028c:	00012823          	sw	zero,16(sp)
c0020290:	14c10b13          	addi	s6,sp,332
c0020294:	47b7c263          	blt	a5,s11,c00206f8 <_svfprintf_r+0x2604>
c0020298:	0fc12b83          	lw	s7,252(sp)
c002029c:	fdf4f793          	andi	a5,s1,-33
c00202a0:	02f12423          	sw	a5,40(sp)
c00202a4:	04012c23          	sw	zero,88(sp)
c00202a8:	0f012e03          	lw	t3,240(sp)
c00202ac:	0f412e83          	lw	t4,244(sp)
c00202b0:	0f812f03          	lw	t5,248(sp)
c00202b4:	102a6a13          	ori	s4,s4,258
c00202b8:	340bc863          	bltz	s7,c0020608 <_svfprintf_r+0x2514>
c00202bc:	06100793          	li	a5,97
c00202c0:	52f48063          	beq	s1,a5,c00207e0 <_svfprintf_r+0x26ec>
c00202c4:	04100793          	li	a5,65
c00202c8:	00f48463          	beq	s1,a5,c00202d0 <_svfprintf_r+0x21dc>
c00202cc:	aecfe06f          	j	c001e5b8 <_svfprintf_r+0x4c4>
c00202d0:	0b010a93          	addi	s5,sp,176
c00202d4:	000a8513          	mv	a0,s5
c00202d8:	05112a23          	sw	a7,84(sp)
c00202dc:	0bc12823          	sw	t3,176(sp)
c00202e0:	0bd12a23          	sw	t4,180(sp)
c00202e4:	0be12c23          	sw	t5,184(sp)
c00202e8:	0b712e23          	sw	s7,188(sp)
c00202ec:	538110ef          	jal	ra,c0031824 <__trunctfdf2>
c00202f0:	0cc10613          	addi	a2,sp,204
c00202f4:	5cc090ef          	jal	ra,c00298c0 <frexp>
c00202f8:	00058613          	mv	a2,a1
c00202fc:	00050593          	mv	a1,a0
c0020300:	000a8513          	mv	a0,s5
c0020304:	328110ef          	jal	ra,c003162c <__extenddftf2>
c0020308:	0b012783          	lw	a5,176(sp)
c002030c:	0a010c93          	addi	s9,sp,160
c0020310:	09010913          	addi	s2,sp,144
c0020314:	08f12823          	sw	a5,144(sp)
c0020318:	0b412783          	lw	a5,180(sp)
c002031c:	08010613          	addi	a2,sp,128
c0020320:	00090593          	mv	a1,s2
c0020324:	08f12a23          	sw	a5,148(sp)
c0020328:	0b812783          	lw	a5,184(sp)
c002032c:	000c8513          	mv	a0,s9
c0020330:	04c12023          	sw	a2,64(sp)
c0020334:	08f12c23          	sw	a5,152(sp)
c0020338:	0bc12783          	lw	a5,188(sp)
c002033c:	08012023          	sw	zero,128(sp)
c0020340:	08012223          	sw	zero,132(sp)
c0020344:	08f12e23          	sw	a5,156(sp)
c0020348:	3ffc07b7          	lui	a5,0x3ffc0
c002034c:	08f12623          	sw	a5,140(sp)
c0020350:	08012423          	sw	zero,136(sp)
c0020354:	3590e0ef          	jal	ra,c002eeac <__multf3>
c0020358:	0a012683          	lw	a3,160(sp)
c002035c:	0a412e03          	lw	t3,164(sp)
c0020360:	0a812e83          	lw	t4,168(sp)
c0020364:	0ac12f03          	lw	t5,172(sp)
c0020368:	000c8593          	mv	a1,s9
c002036c:	000a8513          	mv	a0,s5
c0020370:	0ad12823          	sw	a3,176(sp)
c0020374:	04d12223          	sw	a3,68(sp)
c0020378:	0bc12a23          	sw	t3,180(sp)
c002037c:	03c12223          	sw	t3,36(sp)
c0020380:	0bd12c23          	sw	t4,184(sp)
c0020384:	03d12023          	sw	t4,32(sp)
c0020388:	0be12e23          	sw	t5,188(sp)
c002038c:	01e12e23          	sw	t5,28(sp)
c0020390:	0a012023          	sw	zero,160(sp)
c0020394:	0a012223          	sw	zero,164(sp)
c0020398:	0a012423          	sw	zero,168(sp)
c002039c:	0a012623          	sw	zero,172(sp)
c00203a0:	7b80e0ef          	jal	ra,c002eb58 <__eqtf2>
c00203a4:	01c12f03          	lw	t5,28(sp)
c00203a8:	02012e83          	lw	t4,32(sp)
c00203ac:	02412e03          	lw	t3,36(sp)
c00203b0:	04412683          	lw	a3,68(sp)
c00203b4:	05412883          	lw	a7,84(sp)
c00203b8:	00051663          	bnez	a0,c00203c4 <_svfprintf_r+0x22d0>
c00203bc:	00100793          	li	a5,1
c00203c0:	0cf12623          	sw	a5,204(sp)
c00203c4:	c80027b7          	lui	a5,0xc8002
c00203c8:	6f878793          	addi	a5,a5,1784 # c80026f8 <_end+0xfff7de78>
c00203cc:	02f12223          	sw	a5,36(sp)
c00203d0:	fffd8713          	addi	a4,s11,-1
c00203d4:	05412e23          	sw	s4,92(sp)
c00203d8:	06912223          	sw	s1,100(sp)
c00203dc:	07b12623          	sw	s11,108(sp)
c00203e0:	07a12a23          	sw	s10,116(sp)
c00203e4:	07812c23          	sw	s8,120(sp)
c00203e8:	000b0b93          	mv	s7,s6
c00203ec:	06812023          	sw	s0,96(sp)
c00203f0:	07312423          	sw	s3,104(sp)
c00203f4:	07112823          	sw	a7,112(sp)
c00203f8:	00070c13          	mv	s8,a4
c00203fc:	07612e23          	sw	s6,124(sp)
c0020400:	00068d13          	mv	s10,a3
c0020404:	000e0d93          	mv	s11,t3
c0020408:	000e8493          	mv	s1,t4
c002040c:	000f0a13          	mv	s4,t5
c0020410:	0480006f          	j	c0020458 <_svfprintf_r+0x2364>
c0020414:	000c8593          	mv	a1,s9
c0020418:	000a8513          	mv	a0,s5
c002041c:	02c12023          	sw	a2,32(sp)
c0020420:	01f12e23          	sw	t6,28(sp)
c0020424:	0bf12c23          	sw	t6,184(sp)
c0020428:	0ac12e23          	sw	a2,188(sp)
c002042c:	0b612823          	sw	s6,176(sp)
c0020430:	0b312a23          	sw	s3,180(sp)
c0020434:	0a012023          	sw	zero,160(sp)
c0020438:	0a012223          	sw	zero,164(sp)
c002043c:	0a012423          	sw	zero,168(sp)
c0020440:	0a012623          	sw	zero,172(sp)
c0020444:	7140e0ef          	jal	ra,c002eb58 <__eqtf2>
c0020448:	fffc0c13          	addi	s8,s8,-1
c002044c:	00048f93          	mv	t6,s1
c0020450:	000a0613          	mv	a2,s4
c0020454:	0e050263          	beqz	a0,c0020538 <_svfprintf_r+0x2444>
c0020458:	400307b7          	lui	a5,0x40030
c002045c:	00090613          	mv	a2,s2
c0020460:	000c8593          	mv	a1,s9
c0020464:	000a8513          	mv	a0,s5
c0020468:	08f12e23          	sw	a5,156(sp)
c002046c:	0ba12023          	sw	s10,160(sp)
c0020470:	0bb12223          	sw	s11,164(sp)
c0020474:	0a912423          	sw	s1,168(sp)
c0020478:	0b412623          	sw	s4,172(sp)
c002047c:	08012823          	sw	zero,144(sp)
c0020480:	08012a23          	sw	zero,148(sp)
c0020484:	08012c23          	sw	zero,152(sp)
c0020488:	2250e0ef          	jal	ra,c002eeac <__multf3>
c002048c:	000a8513          	mv	a0,s5
c0020490:	735100ef          	jal	ra,c00313c4 <__fixtfsi>
c0020494:	00050593          	mv	a1,a0
c0020498:	00050413          	mv	s0,a0
c002049c:	000a8513          	mv	a0,s5
c00204a0:	0b012983          	lw	s3,176(sp)
c00204a4:	0b412483          	lw	s1,180(sp)
c00204a8:	0b812b03          	lw	s6,184(sp)
c00204ac:	0bc12a03          	lw	s4,188(sp)
c00204b0:	028110ef          	jal	ra,c00314d8 <__floatsitf>
c00204b4:	0b012683          	lw	a3,176(sp)
c00204b8:	04012603          	lw	a2,64(sp)
c00204bc:	00090593          	mv	a1,s2
c00204c0:	08d12023          	sw	a3,128(sp)
c00204c4:	0b412683          	lw	a3,180(sp)
c00204c8:	000c8513          	mv	a0,s9
c00204cc:	09312823          	sw	s3,144(sp)
c00204d0:	08d12223          	sw	a3,132(sp)
c00204d4:	0b812683          	lw	a3,184(sp)
c00204d8:	08912a23          	sw	s1,148(sp)
c00204dc:	09612c23          	sw	s6,152(sp)
c00204e0:	08d12423          	sw	a3,136(sp)
c00204e4:	0bc12683          	lw	a3,188(sp)
c00204e8:	09412e23          	sw	s4,156(sp)
c00204ec:	08d12623          	sw	a3,140(sp)
c00204f0:	1ad0f0ef          	jal	ra,c002fe9c <__subtf3>
c00204f4:	02412783          	lw	a5,36(sp)
c00204f8:	0a012b03          	lw	s6,160(sp)
c00204fc:	0a412983          	lw	s3,164(sp)
c0020500:	008786b3          	add	a3,a5,s0
c0020504:	0006c683          	lbu	a3,0(a3)
c0020508:	0a812f83          	lw	t6,168(sp)
c002050c:	0ac12603          	lw	a2,172(sp)
c0020510:	05712a23          	sw	s7,84(sp)
c0020514:	00db8023          	sb	a3,0(s7)
c0020518:	05812223          	sw	s8,68(sp)
c002051c:	fff00793          	li	a5,-1
c0020520:	001b8b93          	addi	s7,s7,1
c0020524:	000b0d13          	mv	s10,s6
c0020528:	00098d93          	mv	s11,s3
c002052c:	000f8493          	mv	s1,t6
c0020530:	00060a13          	mv	s4,a2
c0020534:	eefc10e3          	bne	s8,a5,c0020414 <_svfprintf_r+0x2320>
c0020538:	07012883          	lw	a7,112(sp)
c002053c:	000b0393          	mv	t2,s6
c0020540:	00098293          	mv	t0,s3
c0020544:	3ffe0937          	lui	s2,0x3ffe0
c0020548:	000c8593          	mv	a1,s9
c002054c:	000a8513          	mv	a0,s5
c0020550:	03112023          	sw	a7,32(sp)
c0020554:	00812e23          	sw	s0,28(sp)
c0020558:	05c12a03          	lw	s4,92(sp)
c002055c:	06412483          	lw	s1,100(sp)
c0020560:	06012403          	lw	s0,96(sp)
c0020564:	0a712823          	sw	t2,176(sp)
c0020568:	06712223          	sw	t2,100(sp)
c002056c:	0a512a23          	sw	t0,180(sp)
c0020570:	06512023          	sw	t0,96(sp)
c0020574:	0bf12c23          	sw	t6,184(sp)
c0020578:	05f12e23          	sw	t6,92(sp)
c002057c:	0ac12e23          	sw	a2,188(sp)
c0020580:	04c12023          	sw	a2,64(sp)
c0020584:	0a012023          	sw	zero,160(sp)
c0020588:	0a012223          	sw	zero,164(sp)
c002058c:	0a012423          	sw	zero,168(sp)
c0020590:	0b212623          	sw	s2,172(sp)
c0020594:	6900e0ef          	jal	ra,c002ec24 <__getf2>
c0020598:	06c12d83          	lw	s11,108(sp)
c002059c:	07412d03          	lw	s10,116(sp)
c00205a0:	07812c03          	lw	s8,120(sp)
c00205a4:	07c12b03          	lw	s6,124(sp)
c00205a8:	06812983          	lw	s3,104(sp)
c00205ac:	02012883          	lw	a7,32(sp)
c00205b0:	0ea04463          	bgtz	a0,c0020698 <_svfprintf_r+0x25a4>
c00205b4:	000c8593          	mv	a1,s9
c00205b8:	000a8513          	mv	a0,s5
c00205bc:	59c0e0ef          	jal	ra,c002eb58 <__eqtf2>
c00205c0:	02012883          	lw	a7,32(sp)
c00205c4:	00051863          	bnez	a0,c00205d4 <_svfprintf_r+0x24e0>
c00205c8:	01c12783          	lw	a5,28(sp)
c00205cc:	0017fc93          	andi	s9,a5,1
c00205d0:	0c0c9463          	bnez	s9,c0020698 <_svfprintf_r+0x25a4>
c00205d4:	04412783          	lw	a5,68(sp)
c00205d8:	03000693          	li	a3,48
c00205dc:	00178713          	addi	a4,a5,1 # 40030001 <_DMEM_LENGTH+0x3f830001>
c00205e0:	00eb8733          	add	a4,s7,a4
c00205e4:	0007c863          	bltz	a5,c00205f4 <_svfprintf_r+0x2500>
c00205e8:	001b8b93          	addi	s7,s7,1
c00205ec:	fedb8fa3          	sb	a3,-1(s7)
c00205f0:	feeb9ce3          	bne	s7,a4,c00205e8 <_svfprintf_r+0x24f4>
c00205f4:	416b87b3          	sub	a5,s7,s6
c00205f8:	02f12023          	sw	a5,32(sp)
c00205fc:	85cfe06f          	j	c001e658 <_svfprintf_r+0x564>
c0020600:	00012823          	sw	zero,16(sp)
c0020604:	00078a13          	mv	s4,a5
c0020608:	800007b7          	lui	a5,0x80000
c002060c:	0177cbb3          	xor	s7,a5,s7
c0020610:	02d00793          	li	a5,45
c0020614:	04f12c23          	sw	a5,88(sp)
c0020618:	ca5ff06f          	j	c00202bc <_svfprintf_r+0x21c8>
c002061c:	c80026b7          	lui	a3,0xc8002
c0020620:	bd868e93          	addi	t4,a3,-1064 # c8001bd8 <_end+0xfff7d358>
c0020624:	b6cfe06f          	j	c001e990 <_svfprintf_r+0x89c>
c0020628:	001d8913          	addi	s2,s11,1
c002062c:	0b010a93          	addi	s5,sp,176
c0020630:	0dc10813          	addi	a6,sp,220
c0020634:	0d010793          	addi	a5,sp,208
c0020638:	0cc10713          	addi	a4,sp,204
c002063c:	00090693          	mv	a3,s2
c0020640:	00200613          	li	a2,2
c0020644:	000a8593          	mv	a1,s5
c0020648:	000d0513          	mv	a0,s10
c002064c:	0bc12823          	sw	t3,176(sp)
c0020650:	03c12223          	sw	t3,36(sp)
c0020654:	0bd12a23          	sw	t4,180(sp)
c0020658:	03d12023          	sw	t4,32(sp)
c002065c:	0be12c23          	sw	t5,184(sp)
c0020660:	01e12e23          	sw	t5,28(sp)
c0020664:	0b712e23          	sw	s7,188(sp)
c0020668:	1d9050ef          	jal	ra,c0026040 <_ldtoa_r>
c002066c:	01c12f03          	lw	t5,28(sp)
c0020670:	02012e83          	lw	t4,32(sp)
c0020674:	02412e03          	lw	t3,36(sp)
c0020678:	04012883          	lw	a7,64(sp)
c002067c:	00050b13          	mv	s6,a0
c0020680:	012b0933          	add	s2,s6,s2
c0020684:	0a010c93          	addi	s9,sp,160
c0020688:	a51ff06f          	j	c00200d8 <_svfprintf_r+0x1fe4>
c002068c:	01bb0933          	add	s2,s6,s11
c0020690:	0a010c93          	addi	s9,sp,160
c0020694:	a45ff06f          	j	c00200d8 <_svfprintf_r+0x1fe4>
c0020698:	05412783          	lw	a5,84(sp)
c002069c:	000b8713          	mv	a4,s7
c00206a0:	0cf12e23          	sw	a5,220(sp)
c00206a4:	02412783          	lw	a5,36(sp)
c00206a8:	fffbc683          	lbu	a3,-1(s7)
c00206ac:	00f7c603          	lbu	a2,15(a5) # 8000000f <_end+0xb7f7b78f>
c00206b0:	02c69063          	bne	a3,a2,c00206d0 <_svfprintf_r+0x25dc>
c00206b4:	03000593          	li	a1,48
c00206b8:	feb70fa3          	sb	a1,-1(a4)
c00206bc:	0dc12703          	lw	a4,220(sp)
c00206c0:	fff70793          	addi	a5,a4,-1
c00206c4:	0cf12e23          	sw	a5,220(sp)
c00206c8:	fff74683          	lbu	a3,-1(a4)
c00206cc:	fed606e3          	beq	a2,a3,c00206b8 <_svfprintf_r+0x25c4>
c00206d0:	00168613          	addi	a2,a3,1
c00206d4:	03900593          	li	a1,57
c00206d8:	0ff67613          	andi	a2,a2,255
c00206dc:	00b68663          	beq	a3,a1,c00206e8 <_svfprintf_r+0x25f4>
c00206e0:	fec70fa3          	sb	a2,-1(a4)
c00206e4:	f11ff06f          	j	c00205f4 <_svfprintf_r+0x2500>
c00206e8:	02412783          	lw	a5,36(sp)
c00206ec:	00a7c603          	lbu	a2,10(a5)
c00206f0:	fec70fa3          	sb	a2,-1(a4)
c00206f4:	f01ff06f          	j	c00205f4 <_svfprintf_r+0x2500>
c00206f8:	001d8593          	addi	a1,s11,1
c00206fc:	000d0513          	mv	a0,s10
c0020700:	01112823          	sw	a7,16(sp)
c0020704:	7c9060ef          	jal	ra,c00276cc <_malloc_r>
c0020708:	01012883          	lw	a7,16(sp)
c002070c:	00050b13          	mv	s6,a0
c0020710:	2e050a63          	beqz	a0,c0020a04 <_svfprintf_r+0x2910>
c0020714:	00a12823          	sw	a0,16(sp)
c0020718:	b81ff06f          	j	c0020298 <_svfprintf_r+0x21a4>
c002071c:	00812683          	lw	a3,8(sp)
c0020720:	009787b3          	add	a5,a5,s1
c0020724:	00170713          	addi	a4,a4,1
c0020728:	00d8a023          	sw	a3,0(a7)
c002072c:	0098a223          	sw	s1,4(a7)
c0020730:	0ef12623          	sw	a5,236(sp)
c0020734:	0ee12423          	sw	a4,232(sp)
c0020738:	00700693          	li	a3,7
c002073c:	b4e6d863          	bge	a3,a4,c001fa8c <_svfprintf_r+0x1998>
c0020740:	0e410613          	addi	a2,sp,228
c0020744:	000c0593          	mv	a1,s8
c0020748:	000d0513          	mv	a0,s10
c002074c:	5a0090ef          	jal	ra,c0029cec <__ssprint_r>
c0020750:	00050463          	beqz	a0,c0020758 <_svfprintf_r+0x2664>
c0020754:	961fe06f          	j	c001f0b4 <_svfprintf_r+0xfc0>
c0020758:	0ec12783          	lw	a5,236(sp)
c002075c:	0e812703          	lw	a4,232(sp)
c0020760:	10c10893          	addi	a7,sp,268
c0020764:	b2cff06f          	j	c001fa90 <_svfprintf_r+0x199c>
c0020768:	03000793          	li	a5,48
c002076c:	0cf10423          	sb	a5,200(sp)
c0020770:	07800793          	li	a5,120
c0020774:	b09ff06f          	j	c002027c <_svfprintf_r+0x2188>
c0020778:	000a0b93          	mv	s7,s4
c002077c:	ce4fe06f          	j	c001ec60 <_svfprintf_r+0xb6c>
c0020780:	000d8463          	beqz	s11,c0020788 <_svfprintf_r+0x2694>
c0020784:	e09fd06f          	j	c001e58c <_svfprintf_r+0x498>
c0020788:	00100d93          	li	s11,1
c002078c:	e01fd06f          	j	c001e58c <_svfprintf_r+0x498>
c0020790:	fff00793          	li	a5,-1
c0020794:	00f12623          	sw	a5,12(sp)
c0020798:	c79fd06f          	j	c001e410 <_svfprintf_r+0x31c>
c002079c:	02c12783          	lw	a5,44(sp)
c00207a0:	06600493          	li	s1,102
c00207a4:	00f70cb3          	add	s9,a4,a5
c00207a8:	01bc8cb3          	add	s9,s9,s11
c00207ac:	a85ff06f          	j	c0020230 <_svfprintf_r+0x213c>
c00207b0:	0d610713          	addi	a4,sp,214
c00207b4:	00069863          	bnez	a3,c00207c4 <_svfprintf_r+0x26d0>
c00207b8:	03000713          	li	a4,48
c00207bc:	0ce10b23          	sb	a4,214(sp)
c00207c0:	0d710713          	addi	a4,sp,215
c00207c4:	1b010693          	addi	a3,sp,432
c00207c8:	03078793          	addi	a5,a5,48
c00207cc:	40d706b3          	sub	a3,a4,a3
c00207d0:	00f70023          	sb	a5,0(a4)
c00207d4:	0dd68793          	addi	a5,a3,221
c00207d8:	02f12c23          	sw	a5,56(sp)
c00207dc:	f7dfd06f          	j	c001e758 <_svfprintf_r+0x664>
c00207e0:	0b010a93          	addi	s5,sp,176
c00207e4:	000a8513          	mv	a0,s5
c00207e8:	05112a23          	sw	a7,84(sp)
c00207ec:	0bc12823          	sw	t3,176(sp)
c00207f0:	0bd12a23          	sw	t4,180(sp)
c00207f4:	0be12c23          	sw	t5,184(sp)
c00207f8:	0b712e23          	sw	s7,188(sp)
c00207fc:	028110ef          	jal	ra,c0031824 <__trunctfdf2>
c0020800:	0cc10613          	addi	a2,sp,204
c0020804:	0bc090ef          	jal	ra,c00298c0 <frexp>
c0020808:	00058613          	mv	a2,a1
c002080c:	00050593          	mv	a1,a0
c0020810:	000a8513          	mv	a0,s5
c0020814:	619100ef          	jal	ra,c003162c <__extenddftf2>
c0020818:	0b012783          	lw	a5,176(sp)
c002081c:	0a010c93          	addi	s9,sp,160
c0020820:	09010913          	addi	s2,sp,144
c0020824:	08f12823          	sw	a5,144(sp)
c0020828:	0b412783          	lw	a5,180(sp)
c002082c:	08010613          	addi	a2,sp,128
c0020830:	00090593          	mv	a1,s2
c0020834:	08f12a23          	sw	a5,148(sp)
c0020838:	0b812783          	lw	a5,184(sp)
c002083c:	000c8513          	mv	a0,s9
c0020840:	04c12023          	sw	a2,64(sp)
c0020844:	08f12c23          	sw	a5,152(sp)
c0020848:	0bc12783          	lw	a5,188(sp)
c002084c:	08012023          	sw	zero,128(sp)
c0020850:	08012223          	sw	zero,132(sp)
c0020854:	08f12e23          	sw	a5,156(sp)
c0020858:	3ffc07b7          	lui	a5,0x3ffc0
c002085c:	08f12623          	sw	a5,140(sp)
c0020860:	08012423          	sw	zero,136(sp)
c0020864:	6480e0ef          	jal	ra,c002eeac <__multf3>
c0020868:	0a012683          	lw	a3,160(sp)
c002086c:	0a412e03          	lw	t3,164(sp)
c0020870:	0a812e83          	lw	t4,168(sp)
c0020874:	0ac12f03          	lw	t5,172(sp)
c0020878:	000c8593          	mv	a1,s9
c002087c:	000a8513          	mv	a0,s5
c0020880:	0ad12823          	sw	a3,176(sp)
c0020884:	04d12223          	sw	a3,68(sp)
c0020888:	0bc12a23          	sw	t3,180(sp)
c002088c:	03c12223          	sw	t3,36(sp)
c0020890:	0bd12c23          	sw	t4,184(sp)
c0020894:	03d12023          	sw	t4,32(sp)
c0020898:	0be12e23          	sw	t5,188(sp)
c002089c:	01e12e23          	sw	t5,28(sp)
c00208a0:	0a012023          	sw	zero,160(sp)
c00208a4:	0a012223          	sw	zero,164(sp)
c00208a8:	0a012423          	sw	zero,168(sp)
c00208ac:	0a012623          	sw	zero,172(sp)
c00208b0:	2a80e0ef          	jal	ra,c002eb58 <__eqtf2>
c00208b4:	01c12f03          	lw	t5,28(sp)
c00208b8:	02012e83          	lw	t4,32(sp)
c00208bc:	02412e03          	lw	t3,36(sp)
c00208c0:	04412683          	lw	a3,68(sp)
c00208c4:	05412883          	lw	a7,84(sp)
c00208c8:	00051663          	bnez	a0,c00208d4 <_svfprintf_r+0x27e0>
c00208cc:	00100793          	li	a5,1
c00208d0:	0cf12623          	sw	a5,204(sp)
c00208d4:	c80027b7          	lui	a5,0xc8002
c00208d8:	6e478793          	addi	a5,a5,1764 # c80026e4 <_end+0xfff7de64>
c00208dc:	02f12223          	sw	a5,36(sp)
c00208e0:	af1ff06f          	j	c00203d0 <_svfprintf_r+0x22dc>
c00208e4:	06700493          	li	s1,103
c00208e8:	03c12603          	lw	a2,60(sp)
c00208ec:	0ff00713          	li	a4,255
c00208f0:	00064783          	lbu	a5,0(a2)
c00208f4:	12e78863          	beq	a5,a4,c0020a24 <_svfprintf_r+0x2930>
c00208f8:	01c12683          	lw	a3,28(sp)
c00208fc:	00000513          	li	a0,0
c0020900:	00000593          	li	a1,0
c0020904:	00d7de63          	bge	a5,a3,c0020920 <_svfprintf_r+0x282c>
c0020908:	40f686b3          	sub	a3,a3,a5
c002090c:	00164783          	lbu	a5,1(a2)
c0020910:	04078463          	beqz	a5,c0020958 <_svfprintf_r+0x2864>
c0020914:	00158593          	addi	a1,a1,1
c0020918:	00160613          	addi	a2,a2,1
c002091c:	fee794e3          	bne	a5,a4,c0020904 <_svfprintf_r+0x2810>
c0020920:	00d12e23          	sw	a3,28(sp)
c0020924:	02c12e23          	sw	a2,60(sp)
c0020928:	02b12223          	sw	a1,36(sp)
c002092c:	02a12423          	sw	a0,40(sp)
c0020930:	02812703          	lw	a4,40(sp)
c0020934:	02412783          	lw	a5,36(sp)
c0020938:	00e787b3          	add	a5,a5,a4
c002093c:	04812703          	lw	a4,72(sp)
c0020940:	02e787b3          	mul	a5,a5,a4
c0020944:	01978cb3          	add	s9,a5,s9
c0020948:	fffcca93          	not	s5,s9
c002094c:	41fada93          	srai	s5,s5,0x1f
c0020950:	015cfab3          	and	s5,s9,s5
c0020954:	e49fd06f          	j	c001e79c <_svfprintf_r+0x6a8>
c0020958:	00064783          	lbu	a5,0(a2)
c002095c:	00150513          	addi	a0,a0,1
c0020960:	fbdff06f          	j	c002091c <_svfprintf_r+0x2828>
c0020964:	40fc8cb3          	sub	s9,s9,a5
c0020968:	001c8c93          	addi	s9,s9,1
c002096c:	fffcca93          	not	s5,s9
c0020970:	41fada93          	srai	s5,s5,0x1f
c0020974:	015cfab3          	and	s5,s9,s5
c0020978:	e70ff06f          	j	c001ffe8 <_svfprintf_r+0x1ef4>
c002097c:	05012783          	lw	a5,80(sp)
c0020980:	0017f793          	andi	a5,a5,1
c0020984:	00079463          	bnez	a5,c002098c <_svfprintf_r+0x2898>
c0020988:	df1fd06f          	j	c001e778 <_svfprintf_r+0x684>
c002098c:	de5fd06f          	j	c001e770 <_svfprintf_r+0x67c>
c0020990:	00079a63          	bnez	a5,c00209a4 <_svfprintf_r+0x28b0>
c0020994:	00100a93          	li	s5,1
c0020998:	06600493          	li	s1,102
c002099c:	00100c93          	li	s9,1
c00209a0:	e48ff06f          	j	c001ffe8 <_svfprintf_r+0x1ef4>
c00209a4:	02c12783          	lw	a5,44(sp)
c00209a8:	06600493          	li	s1,102
c00209ac:	00178c93          	addi	s9,a5,1
c00209b0:	01bc8cb3          	add	s9,s9,s11
c00209b4:	fffcca93          	not	s5,s9
c00209b8:	41fada93          	srai	s5,s5,0x1f
c00209bc:	015cfab3          	and	s5,s9,s5
c00209c0:	e28ff06f          	j	c001ffe8 <_svfprintf_r+0x1ef4>
c00209c4:	00088693          	mv	a3,a7
c00209c8:	b0cff06f          	j	c001fcd4 <_svfprintf_r+0x1be0>
c00209cc:	01412783          	lw	a5,20(sp)
c00209d0:	0007ad83          	lw	s11,0(a5)
c00209d4:	00478793          	addi	a5,a5,4
c00209d8:	000dd463          	bgez	s11,c00209e0 <_svfprintf_r+0x28ec>
c00209dc:	fff00d93          	li	s11,-1
c00209e0:	00144483          	lbu	s1,1(s0)
c00209e4:	00f12a23          	sw	a5,20(sp)
c00209e8:	00070413          	mv	s0,a4
c00209ec:	86dfd06f          	j	c001e258 <_svfprintf_r+0x164>
c00209f0:	00c00793          	li	a5,12
c00209f4:	00fd2023          	sw	a5,0(s10)
c00209f8:	fff00793          	li	a5,-1
c00209fc:	00f12623          	sw	a5,12(sp)
c0020a00:	a11fd06f          	j	c001e410 <_svfprintf_r+0x31c>
c0020a04:	00cc5783          	lhu	a5,12(s8)
c0020a08:	0407e713          	ori	a4,a5,64
c0020a0c:	00070793          	mv	a5,a4
c0020a10:	00ec1623          	sh	a4,12(s8)
c0020a14:	9f1fd06f          	j	c001e404 <_svfprintf_r+0x310>
c0020a18:	00200793          	li	a5,2
c0020a1c:	02f12c23          	sw	a5,56(sp)
c0020a20:	d39fd06f          	j	c001e758 <_svfprintf_r+0x664>
c0020a24:	02012423          	sw	zero,40(sp)
c0020a28:	02012223          	sw	zero,36(sp)
c0020a2c:	f05ff06f          	j	c0020930 <_svfprintf_r+0x283c>
c0020a30:	000d8913          	mv	s2,s11
c0020a34:	c4dff06f          	j	c0020680 <_svfprintf_r+0x258c>

c0020a38 <_vfprintf_r>:
c0020a38:	e1010113          	addi	sp,sp,-496
c0020a3c:	1e112623          	sw	ra,492(sp)
c0020a40:	1f212023          	sw	s2,480(sp)
c0020a44:	1d812423          	sw	s8,456(sp)
c0020a48:	1da12023          	sw	s10,448(sp)
c0020a4c:	00058c13          	mv	s8,a1
c0020a50:	00060913          	mv	s2,a2
c0020a54:	00d12a23          	sw	a3,20(sp)
c0020a58:	1e812423          	sw	s0,488(sp)
c0020a5c:	1e912223          	sw	s1,484(sp)
c0020a60:	1d312e23          	sw	s3,476(sp)
c0020a64:	1d412c23          	sw	s4,472(sp)
c0020a68:	1d512a23          	sw	s5,468(sp)
c0020a6c:	1d612823          	sw	s6,464(sp)
c0020a70:	1d712623          	sw	s7,460(sp)
c0020a74:	1d912223          	sw	s9,452(sp)
c0020a78:	1bb12e23          	sw	s11,444(sp)
c0020a7c:	00050d13          	mv	s10,a0
c0020a80:	0d1060ef          	jal	ra,c0027350 <_localeconv_r>
c0020a84:	00052783          	lw	a5,0(a0)
c0020a88:	00078513          	mv	a0,a5
c0020a8c:	02f12823          	sw	a5,48(sp)
c0020a90:	dd8fd0ef          	jal	ra,c001e068 <strlen>
c0020a94:	02a12623          	sw	a0,44(sp)
c0020a98:	0e012823          	sw	zero,240(sp)
c0020a9c:	0e012a23          	sw	zero,244(sp)
c0020aa0:	0e012c23          	sw	zero,248(sp)
c0020aa4:	0e012e23          	sw	zero,252(sp)
c0020aa8:	000d0663          	beqz	s10,c0020ab4 <_vfprintf_r+0x7c>
c0020aac:	038d2783          	lw	a5,56(s10)
c0020ab0:	0e078ce3          	beqz	a5,c00213a8 <_vfprintf_r+0x970>
c0020ab4:	00cc1683          	lh	a3,12(s8)
c0020ab8:	00002637          	lui	a2,0x2
c0020abc:	01069793          	slli	a5,a3,0x10
c0020ac0:	0107d793          	srli	a5,a5,0x10
c0020ac4:	00c7f5b3          	and	a1,a5,a2
c0020ac8:	02059863          	bnez	a1,c0020af8 <_vfprintf_r+0xc0>
c0020acc:	064c2583          	lw	a1,100(s8)
c0020ad0:	00c6e7b3          	or	a5,a3,a2
c0020ad4:	01079793          	slli	a5,a5,0x10
c0020ad8:	ffffe6b7          	lui	a3,0xffffe
c0020adc:	4107d793          	srai	a5,a5,0x10
c0020ae0:	fff68693          	addi	a3,a3,-1 # ffffdfff <_end+0x37f7977f>
c0020ae4:	00d5f6b3          	and	a3,a1,a3
c0020ae8:	00fc1623          	sh	a5,12(s8)
c0020aec:	01079793          	slli	a5,a5,0x10
c0020af0:	06dc2223          	sw	a3,100(s8)
c0020af4:	0107d793          	srli	a5,a5,0x10
c0020af8:	0087f693          	andi	a3,a5,8
c0020afc:	2e068663          	beqz	a3,c0020de8 <_vfprintf_r+0x3b0>
c0020b00:	010c2683          	lw	a3,16(s8)
c0020b04:	2e068263          	beqz	a3,c0020de8 <_vfprintf_r+0x3b0>
c0020b08:	01a7f793          	andi	a5,a5,26
c0020b0c:	00a00693          	li	a3,10
c0020b10:	2ed78e63          	beq	a5,a3,c0020e0c <_vfprintf_r+0x3d4>
c0020b14:	10c10793          	addi	a5,sp,268
c0020b18:	0ef12223          	sw	a5,228(sp)
c0020b1c:	00078893          	mv	a7,a5
c0020b20:	c80027b7          	lui	a5,0xc8002
c0020b24:	bf878793          	addi	a5,a5,-1032 # c8001bf8 <_end+0xfff7d378>
c0020b28:	00f12c23          	sw	a5,24(sp)
c0020b2c:	c80027b7          	lui	a5,0xc8002
c0020b30:	d7478793          	addi	a5,a5,-652 # c8001d74 <_end+0xfff7d4f4>
c0020b34:	00090b13          	mv	s6,s2
c0020b38:	00f12423          	sw	a5,8(sp)
c0020b3c:	000b4783          	lbu	a5,0(s6)
c0020b40:	0e012623          	sw	zero,236(sp)
c0020b44:	0e012423          	sw	zero,232(sp)
c0020b48:	02012023          	sw	zero,32(sp)
c0020b4c:	02012a23          	sw	zero,52(sp)
c0020b50:	02012c23          	sw	zero,56(sp)
c0020b54:	02012e23          	sw	zero,60(sp)
c0020b58:	04012423          	sw	zero,72(sp)
c0020b5c:	04012623          	sw	zero,76(sp)
c0020b60:	00012623          	sw	zero,12(sp)
c0020b64:	22078463          	beqz	a5,c0020d8c <_vfprintf_r+0x354>
c0020b68:	000b0413          	mv	s0,s6
c0020b6c:	02500713          	li	a4,37
c0020b70:	30e78863          	beq	a5,a4,c0020e80 <_vfprintf_r+0x448>
c0020b74:	00144783          	lbu	a5,1(s0)
c0020b78:	00140413          	addi	s0,s0,1
c0020b7c:	fe079ae3          	bnez	a5,c0020b70 <_vfprintf_r+0x138>
c0020b80:	416404b3          	sub	s1,s0,s6
c0020b84:	21640463          	beq	s0,s6,c0020d8c <_vfprintf_r+0x354>
c0020b88:	0ec12703          	lw	a4,236(sp)
c0020b8c:	0e812783          	lw	a5,232(sp)
c0020b90:	0168a023          	sw	s6,0(a7)
c0020b94:	00970733          	add	a4,a4,s1
c0020b98:	00178793          	addi	a5,a5,1
c0020b9c:	0098a223          	sw	s1,4(a7)
c0020ba0:	0ee12623          	sw	a4,236(sp)
c0020ba4:	0ef12423          	sw	a5,232(sp)
c0020ba8:	00700713          	li	a4,7
c0020bac:	00888893          	addi	a7,a7,8
c0020bb0:	2ef74063          	blt	a4,a5,c0020e90 <_vfprintf_r+0x458>
c0020bb4:	00c12703          	lw	a4,12(sp)
c0020bb8:	00044783          	lbu	a5,0(s0)
c0020bbc:	00970733          	add	a4,a4,s1
c0020bc0:	00e12623          	sw	a4,12(sp)
c0020bc4:	1c078463          	beqz	a5,c0020d8c <_vfprintf_r+0x354>
c0020bc8:	00144483          	lbu	s1,1(s0)
c0020bcc:	0c0103a3          	sb	zero,199(sp)
c0020bd0:	00140413          	addi	s0,s0,1
c0020bd4:	fff00d93          	li	s11,-1
c0020bd8:	00000993          	li	s3,0
c0020bdc:	00000a13          	li	s4,0
c0020be0:	05a00913          	li	s2,90
c0020be4:	00900a93          	li	s5,9
c0020be8:	02a00b93          	li	s7,42
c0020bec:	00088c93          	mv	s9,a7
c0020bf0:	00140413          	addi	s0,s0,1
c0020bf4:	fe048793          	addi	a5,s1,-32
c0020bf8:	04f96463          	bltu	s2,a5,c0020c40 <_vfprintf_r+0x208>
c0020bfc:	01812703          	lw	a4,24(sp)
c0020c00:	00279793          	slli	a5,a5,0x2
c0020c04:	00e787b3          	add	a5,a5,a4
c0020c08:	0007a783          	lw	a5,0(a5)
c0020c0c:	00078067          	jr	a5
c0020c10:	00000993          	li	s3,0
c0020c14:	fd048693          	addi	a3,s1,-48
c0020c18:	00044483          	lbu	s1,0(s0)
c0020c1c:	00299793          	slli	a5,s3,0x2
c0020c20:	013787b3          	add	a5,a5,s3
c0020c24:	00179793          	slli	a5,a5,0x1
c0020c28:	00f689b3          	add	s3,a3,a5
c0020c2c:	fd048693          	addi	a3,s1,-48
c0020c30:	00140413          	addi	s0,s0,1
c0020c34:	fedaf2e3          	bgeu	s5,a3,c0020c18 <_vfprintf_r+0x1e0>
c0020c38:	fe048793          	addi	a5,s1,-32
c0020c3c:	fcf970e3          	bgeu	s2,a5,c0020bfc <_vfprintf_r+0x1c4>
c0020c40:	000c8893          	mv	a7,s9
c0020c44:	14048463          	beqz	s1,c0020d8c <_vfprintf_r+0x354>
c0020c48:	14910623          	sb	s1,332(sp)
c0020c4c:	0c0103a3          	sb	zero,199(sp)
c0020c50:	00100a93          	li	s5,1
c0020c54:	00100c93          	li	s9,1
c0020c58:	14c10b13          	addi	s6,sp,332
c0020c5c:	00012823          	sw	zero,16(sp)
c0020c60:	00000d93          	li	s11,0
c0020c64:	02012423          	sw	zero,40(sp)
c0020c68:	02012223          	sw	zero,36(sp)
c0020c6c:	00012e23          	sw	zero,28(sp)
c0020c70:	002a7b93          	andi	s7,s4,2
c0020c74:	000b8463          	beqz	s7,c0020c7c <_vfprintf_r+0x244>
c0020c78:	002a8a93          	addi	s5,s5,2
c0020c7c:	084a7913          	andi	s2,s4,132
c0020c80:	0ec12783          	lw	a5,236(sp)
c0020c84:	00091663          	bnez	s2,c0020c90 <_vfprintf_r+0x258>
c0020c88:	415986b3          	sub	a3,s3,s5
c0020c8c:	62d04ae3          	bgtz	a3,c0021ac0 <_vfprintf_r+0x1088>
c0020c90:	0c714703          	lbu	a4,199(sp)
c0020c94:	02070a63          	beqz	a4,c0020cc8 <_vfprintf_r+0x290>
c0020c98:	0e812703          	lw	a4,232(sp)
c0020c9c:	0c710693          	addi	a3,sp,199
c0020ca0:	00d8a023          	sw	a3,0(a7)
c0020ca4:	00178793          	addi	a5,a5,1
c0020ca8:	00100693          	li	a3,1
c0020cac:	00170713          	addi	a4,a4,1
c0020cb0:	00d8a223          	sw	a3,4(a7)
c0020cb4:	0ef12623          	sw	a5,236(sp)
c0020cb8:	0ee12423          	sw	a4,232(sp)
c0020cbc:	00700693          	li	a3,7
c0020cc0:	00888893          	addi	a7,a7,8
c0020cc4:	4ce6cc63          	blt	a3,a4,c002119c <_vfprintf_r+0x764>
c0020cc8:	020b8a63          	beqz	s7,c0020cfc <_vfprintf_r+0x2c4>
c0020ccc:	0e812703          	lw	a4,232(sp)
c0020cd0:	0c810693          	addi	a3,sp,200
c0020cd4:	00d8a023          	sw	a3,0(a7)
c0020cd8:	00278793          	addi	a5,a5,2
c0020cdc:	00200693          	li	a3,2
c0020ce0:	00170713          	addi	a4,a4,1
c0020ce4:	00d8a223          	sw	a3,4(a7)
c0020ce8:	0ef12623          	sw	a5,236(sp)
c0020cec:	0ee12423          	sw	a4,232(sp)
c0020cf0:	00700693          	li	a3,7
c0020cf4:	00888893          	addi	a7,a7,8
c0020cf8:	6ae6cce3          	blt	a3,a4,c0021bb0 <_vfprintf_r+0x1178>
c0020cfc:	08000713          	li	a4,128
c0020d00:	42e900e3          	beq	s2,a4,c0021920 <_vfprintf_r+0xee8>
c0020d04:	419d8db3          	sub	s11,s11,s9
c0020d08:	4db04ce3          	bgtz	s11,c00219e0 <_vfprintf_r+0xfa8>
c0020d0c:	100a7713          	andi	a4,s4,256
c0020d10:	2c071ae3          	bnez	a4,c00217e4 <_vfprintf_r+0xdac>
c0020d14:	0e812703          	lw	a4,232(sp)
c0020d18:	019787b3          	add	a5,a5,s9
c0020d1c:	0168a023          	sw	s6,0(a7)
c0020d20:	00170713          	addi	a4,a4,1
c0020d24:	0198a223          	sw	s9,4(a7)
c0020d28:	0ef12623          	sw	a5,236(sp)
c0020d2c:	0ee12423          	sw	a4,232(sp)
c0020d30:	00700693          	li	a3,7
c0020d34:	58e6ce63          	blt	a3,a4,c00212d0 <_vfprintf_r+0x898>
c0020d38:	00888893          	addi	a7,a7,8
c0020d3c:	004a7a13          	andi	s4,s4,4
c0020d40:	000a0663          	beqz	s4,c0020d4c <_vfprintf_r+0x314>
c0020d44:	415984b3          	sub	s1,s3,s5
c0020d48:	5a904463          	bgtz	s1,c00212f0 <_vfprintf_r+0x8b8>
c0020d4c:	0159d463          	bge	s3,s5,c0020d54 <_vfprintf_r+0x31c>
c0020d50:	000a8993          	mv	s3,s5
c0020d54:	00c12703          	lw	a4,12(sp)
c0020d58:	01370733          	add	a4,a4,s3
c0020d5c:	00e12623          	sw	a4,12(sp)
c0020d60:	52079ae3          	bnez	a5,c0021a94 <_vfprintf_r+0x105c>
c0020d64:	01012783          	lw	a5,16(sp)
c0020d68:	0e012423          	sw	zero,232(sp)
c0020d6c:	00078863          	beqz	a5,c0020d7c <_vfprintf_r+0x344>
c0020d70:	01012583          	lw	a1,16(sp)
c0020d74:	000d0513          	mv	a0,s10
c0020d78:	0e0030ef          	jal	ra,c0023e58 <_free_r>
c0020d7c:	10c10893          	addi	a7,sp,268
c0020d80:	00040b13          	mv	s6,s0
c0020d84:	000b4783          	lbu	a5,0(s6)
c0020d88:	de0790e3          	bnez	a5,c0020b68 <_vfprintf_r+0x130>
c0020d8c:	0ec12783          	lw	a5,236(sp)
c0020d90:	00078463          	beqz	a5,c0020d98 <_vfprintf_r+0x360>
c0020d94:	2c10106f          	j	c0022854 <_vfprintf_r+0x1e1c>
c0020d98:	00cc5783          	lhu	a5,12(s8)
c0020d9c:	0407f793          	andi	a5,a5,64
c0020da0:	00078463          	beqz	a5,c0020da8 <_vfprintf_r+0x370>
c0020da4:	2380206f          	j	c0022fdc <_vfprintf_r+0x25a4>
c0020da8:	1ec12083          	lw	ra,492(sp)
c0020dac:	1e812403          	lw	s0,488(sp)
c0020db0:	00c12503          	lw	a0,12(sp)
c0020db4:	1e412483          	lw	s1,484(sp)
c0020db8:	1e012903          	lw	s2,480(sp)
c0020dbc:	1dc12983          	lw	s3,476(sp)
c0020dc0:	1d812a03          	lw	s4,472(sp)
c0020dc4:	1d412a83          	lw	s5,468(sp)
c0020dc8:	1d012b03          	lw	s6,464(sp)
c0020dcc:	1cc12b83          	lw	s7,460(sp)
c0020dd0:	1c812c03          	lw	s8,456(sp)
c0020dd4:	1c412c83          	lw	s9,452(sp)
c0020dd8:	1c012d03          	lw	s10,448(sp)
c0020ddc:	1bc12d83          	lw	s11,444(sp)
c0020de0:	1f010113          	addi	sp,sp,496
c0020de4:	00008067          	ret
c0020de8:	000c0593          	mv	a1,s8
c0020dec:	000d0513          	mv	a0,s10
c0020df0:	6d4020ef          	jal	ra,c00234c4 <__swsetup_r>
c0020df4:	00050463          	beqz	a0,c0020dfc <_vfprintf_r+0x3c4>
c0020df8:	1e40206f          	j	c0022fdc <_vfprintf_r+0x25a4>
c0020dfc:	00cc5783          	lhu	a5,12(s8)
c0020e00:	00a00693          	li	a3,10
c0020e04:	01a7f793          	andi	a5,a5,26
c0020e08:	d0d796e3          	bne	a5,a3,c0020b14 <_vfprintf_r+0xdc>
c0020e0c:	00ec1783          	lh	a5,14(s8)
c0020e10:	d007c2e3          	bltz	a5,c0020b14 <_vfprintf_r+0xdc>
c0020e14:	01412683          	lw	a3,20(sp)
c0020e18:	00090613          	mv	a2,s2
c0020e1c:	000c0593          	mv	a1,s8
c0020e20:	000d0513          	mv	a0,s10
c0020e24:	5e0020ef          	jal	ra,c0023404 <__sbprintf>
c0020e28:	00a12623          	sw	a0,12(sp)
c0020e2c:	f7dff06f          	j	c0020da8 <_vfprintf_r+0x370>
c0020e30:	000d0513          	mv	a0,s10
c0020e34:	51c060ef          	jal	ra,c0027350 <_localeconv_r>
c0020e38:	00452783          	lw	a5,4(a0)
c0020e3c:	00078513          	mv	a0,a5
c0020e40:	04f12623          	sw	a5,76(sp)
c0020e44:	a24fd0ef          	jal	ra,c001e068 <strlen>
c0020e48:	00050793          	mv	a5,a0
c0020e4c:	000d0513          	mv	a0,s10
c0020e50:	00078493          	mv	s1,a5
c0020e54:	04f12423          	sw	a5,72(sp)
c0020e58:	4f8060ef          	jal	ra,c0027350 <_localeconv_r>
c0020e5c:	00852783          	lw	a5,8(a0)
c0020e60:	02f12e23          	sw	a5,60(sp)
c0020e64:	00048463          	beqz	s1,c0020e6c <_vfprintf_r+0x434>
c0020e68:	05c0106f          	j	c0021ec4 <_vfprintf_r+0x148c>
c0020e6c:	00044483          	lbu	s1,0(s0)
c0020e70:	d81ff06f          	j	c0020bf0 <_vfprintf_r+0x1b8>
c0020e74:	00044483          	lbu	s1,0(s0)
c0020e78:	020a6a13          	ori	s4,s4,32
c0020e7c:	d75ff06f          	j	c0020bf0 <_vfprintf_r+0x1b8>
c0020e80:	416404b3          	sub	s1,s0,s6
c0020e84:	d16412e3          	bne	s0,s6,c0020b88 <_vfprintf_r+0x150>
c0020e88:	00044783          	lbu	a5,0(s0)
c0020e8c:	d39ff06f          	j	c0020bc4 <_vfprintf_r+0x18c>
c0020e90:	0e410613          	addi	a2,sp,228
c0020e94:	000c0593          	mv	a1,s8
c0020e98:	000d0513          	mv	a0,s10
c0020e9c:	1c40a0ef          	jal	ra,c002b060 <__sprint_r>
c0020ea0:	ee051ce3          	bnez	a0,c0020d98 <_vfprintf_r+0x360>
c0020ea4:	10c10893          	addi	a7,sp,268
c0020ea8:	d0dff06f          	j	c0020bb4 <_vfprintf_r+0x17c>
c0020eac:	008a7793          	andi	a5,s4,8
c0020eb0:	000c8893          	mv	a7,s9
c0020eb4:	00078463          	beqz	a5,c0020ebc <_vfprintf_r+0x484>
c0020eb8:	05c0106f          	j	c0021f14 <_vfprintf_r+0x14dc>
c0020ebc:	01412783          	lw	a5,20(sp)
c0020ec0:	0b010513          	addi	a0,sp,176
c0020ec4:	01912823          	sw	s9,16(sp)
c0020ec8:	00778793          	addi	a5,a5,7
c0020ecc:	ff87f793          	andi	a5,a5,-8
c0020ed0:	0007a583          	lw	a1,0(a5)
c0020ed4:	0047a603          	lw	a2,4(a5)
c0020ed8:	00878793          	addi	a5,a5,8
c0020edc:	00f12a23          	sw	a5,20(sp)
c0020ee0:	74c100ef          	jal	ra,c003162c <__extenddftf2>
c0020ee4:	0b012783          	lw	a5,176(sp)
c0020ee8:	01012883          	lw	a7,16(sp)
c0020eec:	0ef12823          	sw	a5,240(sp)
c0020ef0:	0b412783          	lw	a5,180(sp)
c0020ef4:	0ef12a23          	sw	a5,244(sp)
c0020ef8:	0b812783          	lw	a5,184(sp)
c0020efc:	0ef12c23          	sw	a5,248(sp)
c0020f00:	0bc12783          	lw	a5,188(sp)
c0020f04:	0ef12e23          	sw	a5,252(sp)
c0020f08:	0f010513          	addi	a0,sp,240
c0020f0c:	01112823          	sw	a7,16(sp)
c0020f10:	3c0060ef          	jal	ra,c00272d0 <_ldcheck>
c0020f14:	0ca12623          	sw	a0,204(sp)
c0020f18:	00200793          	li	a5,2
c0020f1c:	01012883          	lw	a7,16(sp)
c0020f20:	00f51463          	bne	a0,a5,c0020f28 <_vfprintf_r+0x4f0>
c0020f24:	4240106f          	j	c0022348 <_vfprintf_r+0x1910>
c0020f28:	00100793          	li	a5,1
c0020f2c:	00f51463          	bne	a0,a5,c0020f34 <_vfprintf_r+0x4fc>
c0020f30:	5c80106f          	j	c00224f8 <_vfprintf_r+0x1ac0>
c0020f34:	06100793          	li	a5,97
c0020f38:	00f49463          	bne	s1,a5,c0020f40 <_vfprintf_r+0x508>
c0020f3c:	0c00206f          	j	c0022ffc <_vfprintf_r+0x25c4>
c0020f40:	04100793          	li	a5,65
c0020f44:	00f49463          	bne	s1,a5,c0020f4c <_vfprintf_r+0x514>
c0020f48:	1490106f          	j	c0022890 <_vfprintf_r+0x1e58>
c0020f4c:	fdf4f713          	andi	a4,s1,-33
c0020f50:	fff00793          	li	a5,-1
c0020f54:	02e12423          	sw	a4,40(sp)
c0020f58:	00fd9463          	bne	s11,a5,c0020f60 <_vfprintf_r+0x528>
c0020f5c:	2000206f          	j	c002315c <_vfprintf_r+0x2724>
c0020f60:	04700793          	li	a5,71
c0020f64:	00f71463          	bne	a4,a5,c0020f6c <_vfprintf_r+0x534>
c0020f68:	1e40206f          	j	c002314c <_vfprintf_r+0x2714>
c0020f6c:	0fc12b83          	lw	s7,252(sp)
c0020f70:	05412823          	sw	s4,80(sp)
c0020f74:	0f012e03          	lw	t3,240(sp)
c0020f78:	0f412e83          	lw	t4,244(sp)
c0020f7c:	0f812f03          	lw	t5,248(sp)
c0020f80:	100a6793          	ori	a5,s4,256
c0020f84:	000bd463          	bgez	s7,c0020f8c <_vfprintf_r+0x554>
c0020f88:	5650106f          	j	c0022cec <_vfprintf_r+0x22b4>
c0020f8c:	04012c23          	sw	zero,88(sp)
c0020f90:	00078a13          	mv	s4,a5
c0020f94:	00012823          	sw	zero,16(sp)
c0020f98:	02812703          	lw	a4,40(sp)
c0020f9c:	04600793          	li	a5,70
c0020fa0:	00f71463          	bne	a4,a5,c0020fa8 <_vfprintf_r+0x570>
c0020fa4:	58d0106f          	j	c0022d30 <_vfprintf_r+0x22f8>
c0020fa8:	04500793          	li	a5,69
c0020fac:	05112023          	sw	a7,64(sp)
c0020fb0:	00f71463          	bne	a4,a5,c0020fb8 <_vfprintf_r+0x580>
c0020fb4:	1280206f          	j	c00230dc <_vfprintf_r+0x26a4>
c0020fb8:	0b010a93          	addi	s5,sp,176
c0020fbc:	0d010793          	addi	a5,sp,208
c0020fc0:	0cc10713          	addi	a4,sp,204
c0020fc4:	0dc10813          	addi	a6,sp,220
c0020fc8:	000d8693          	mv	a3,s11
c0020fcc:	00200613          	li	a2,2
c0020fd0:	000a8593          	mv	a1,s5
c0020fd4:	000d0513          	mv	a0,s10
c0020fd8:	0bc12823          	sw	t3,176(sp)
c0020fdc:	03c12223          	sw	t3,36(sp)
c0020fe0:	0bd12a23          	sw	t4,180(sp)
c0020fe4:	03d12023          	sw	t4,32(sp)
c0020fe8:	0be12c23          	sw	t5,184(sp)
c0020fec:	01e12e23          	sw	t5,28(sp)
c0020ff0:	0b712e23          	sw	s7,188(sp)
c0020ff4:	04c050ef          	jal	ra,c0026040 <_ldtoa_r>
c0020ff8:	02812703          	lw	a4,40(sp)
c0020ffc:	04700793          	li	a5,71
c0021000:	01c12f03          	lw	t5,28(sp)
c0021004:	02012e83          	lw	t4,32(sp)
c0021008:	02412e03          	lw	t3,36(sp)
c002100c:	04012883          	lw	a7,64(sp)
c0021010:	00050b13          	mv	s6,a0
c0021014:	00f70463          	beq	a4,a5,c002101c <_vfprintf_r+0x5e4>
c0021018:	3b80206f          	j	c00233d0 <_vfprintf_r+0x2998>
c002101c:	05012783          	lw	a5,80(sp)
c0021020:	0017f793          	andi	a5,a5,1
c0021024:	00078463          	beqz	a5,c002102c <_vfprintf_r+0x5f4>
c0021028:	1180206f          	j	c0023140 <_vfprintf_r+0x2708>
c002102c:	0dc12683          	lw	a3,220(sp)
c0021030:	416687b3          	sub	a5,a3,s6
c0021034:	02f12023          	sw	a5,32(sp)
c0021038:	0cc12703          	lw	a4,204(sp)
c002103c:	04700793          	li	a5,71
c0021040:	00e12e23          	sw	a4,28(sp)
c0021044:	02812703          	lw	a4,40(sp)
c0021048:	00f71463          	bne	a4,a5,c0021050 <_vfprintf_r+0x618>
c002104c:	40d0106f          	j	c0022c58 <_vfprintf_r+0x2220>
c0021050:	02812703          	lw	a4,40(sp)
c0021054:	04600793          	li	a5,70
c0021058:	00f71463          	bne	a4,a5,c0021060 <_vfprintf_r+0x628>
c002105c:	6f10106f          	j	c0022f4c <_vfprintf_r+0x2514>
c0021060:	01c12783          	lw	a5,28(sp)
c0021064:	02812583          	lw	a1,40(sp)
c0021068:	04100613          	li	a2,65
c002106c:	fff78793          	addi	a5,a5,-1
c0021070:	0cf12623          	sw	a5,204(sp)
c0021074:	0ff4f713          	andi	a4,s1,255
c0021078:	00000693          	li	a3,0
c002107c:	00c59863          	bne	a1,a2,c002108c <_vfprintf_r+0x654>
c0021080:	00f70713          	addi	a4,a4,15
c0021084:	0ff77713          	andi	a4,a4,255
c0021088:	00100693          	li	a3,1
c002108c:	0ce10a23          	sb	a4,212(sp)
c0021090:	02b00713          	li	a4,43
c0021094:	0007da63          	bgez	a5,c00210a8 <_vfprintf_r+0x670>
c0021098:	01c12703          	lw	a4,28(sp)
c002109c:	00100793          	li	a5,1
c00210a0:	40e787b3          	sub	a5,a5,a4
c00210a4:	02d00713          	li	a4,45
c00210a8:	0ce10aa3          	sb	a4,213(sp)
c00210ac:	00900713          	li	a4,9
c00210b0:	00f74463          	blt	a4,a5,c00210b8 <_vfprintf_r+0x680>
c00210b4:	1440206f          	j	c00231f8 <_vfprintf_r+0x27c0>
c00210b8:	0e310513          	addi	a0,sp,227
c00210bc:	00050593          	mv	a1,a0
c00210c0:	00a00693          	li	a3,10
c00210c4:	06300e13          	li	t3,99
c00210c8:	02d7e733          	rem	a4,a5,a3
c00210cc:	00058613          	mv	a2,a1
c00210d0:	00078813          	mv	a6,a5
c00210d4:	fff58593          	addi	a1,a1,-1
c00210d8:	03070713          	addi	a4,a4,48
c00210dc:	fee60fa3          	sb	a4,-1(a2) # 1fff <_STACK_SIZE+0xfff>
c00210e0:	02d7c7b3          	div	a5,a5,a3
c00210e4:	ff0e42e3          	blt	t3,a6,c00210c8 <_vfprintf_r+0x690>
c00210e8:	03078793          	addi	a5,a5,48
c00210ec:	0ff7f693          	andi	a3,a5,255
c00210f0:	fed58fa3          	sb	a3,-1(a1)
c00210f4:	ffe60793          	addi	a5,a2,-2
c00210f8:	00a7e463          	bltu	a5,a0,c0021100 <_vfprintf_r+0x6c8>
c00210fc:	2c80206f          	j	c00233c4 <_vfprintf_r+0x298c>
c0021100:	0d610713          	addi	a4,sp,214
c0021104:	0080006f          	j	c002110c <_vfprintf_r+0x6d4>
c0021108:	0007c683          	lbu	a3,0(a5)
c002110c:	00d70023          	sb	a3,0(a4)
c0021110:	00178793          	addi	a5,a5,1
c0021114:	00170713          	addi	a4,a4,1
c0021118:	fea798e3          	bne	a5,a0,c0021108 <_vfprintf_r+0x6d0>
c002111c:	0e510793          	addi	a5,sp,229
c0021120:	0d610713          	addi	a4,sp,214
c0021124:	40c787b3          	sub	a5,a5,a2
c0021128:	00f707b3          	add	a5,a4,a5
c002112c:	0d410713          	addi	a4,sp,212
c0021130:	40e787b3          	sub	a5,a5,a4
c0021134:	02f12c23          	sw	a5,56(sp)
c0021138:	03812683          	lw	a3,56(sp)
c002113c:	02012703          	lw	a4,32(sp)
c0021140:	00100793          	li	a5,1
c0021144:	00e68cb3          	add	s9,a3,a4
c0021148:	00e7c463          	blt	a5,a4,c0021150 <_vfprintf_r+0x718>
c002114c:	1f80206f          	j	c0023344 <_vfprintf_r+0x290c>
c0021150:	02c12783          	lw	a5,44(sp)
c0021154:	00fc8cb3          	add	s9,s9,a5
c0021158:	05012783          	lw	a5,80(sp)
c002115c:	fffcca93          	not	s5,s9
c0021160:	41fada93          	srai	s5,s5,0x1f
c0021164:	bff7fa13          	andi	s4,a5,-1025
c0021168:	100a6a13          	ori	s4,s4,256
c002116c:	015cfab3          	and	s5,s9,s5
c0021170:	02012423          	sw	zero,40(sp)
c0021174:	02012223          	sw	zero,36(sp)
c0021178:	00012e23          	sw	zero,28(sp)
c002117c:	05812783          	lw	a5,88(sp)
c0021180:	00079463          	bnez	a5,c0021188 <_vfprintf_r+0x750>
c0021184:	2f50106f          	j	c0022c78 <_vfprintf_r+0x2240>
c0021188:	02d00793          	li	a5,45
c002118c:	0cf103a3          	sb	a5,199(sp)
c0021190:	00000d93          	li	s11,0
c0021194:	001a8a93          	addi	s5,s5,1
c0021198:	ad9ff06f          	j	c0020c70 <_vfprintf_r+0x238>
c002119c:	0e410613          	addi	a2,sp,228
c00211a0:	000c0593          	mv	a1,s8
c00211a4:	000d0513          	mv	a0,s10
c00211a8:	6b9090ef          	jal	ra,c002b060 <__sprint_r>
c00211ac:	0e051ee3          	bnez	a0,c0021aa8 <_vfprintf_r+0x1070>
c00211b0:	0ec12783          	lw	a5,236(sp)
c00211b4:	10c10893          	addi	a7,sp,268
c00211b8:	b11ff06f          	j	c0020cc8 <_vfprintf_r+0x290>
c00211bc:	0e812703          	lw	a4,232(sp)
c00211c0:	00178c93          	addi	s9,a5,1
c00211c4:	02012783          	lw	a5,32(sp)
c00211c8:	00100693          	li	a3,1
c00211cc:	0168a023          	sw	s6,0(a7)
c00211d0:	00170493          	addi	s1,a4,1
c00211d4:	00888913          	addi	s2,a7,8
c00211d8:	36f6dce3          	bge	a3,a5,c0021d50 <_vfprintf_r+0x1318>
c00211dc:	00100793          	li	a5,1
c00211e0:	00f8a223          	sw	a5,4(a7)
c00211e4:	0f912623          	sw	s9,236(sp)
c00211e8:	0e912423          	sw	s1,232(sp)
c00211ec:	00700793          	li	a5,7
c00211f0:	7497c6e3          	blt	a5,s1,c002213c <_vfprintf_r+0x1704>
c00211f4:	02c12783          	lw	a5,44(sp)
c00211f8:	03012703          	lw	a4,48(sp)
c00211fc:	00148493          	addi	s1,s1,1
c0021200:	00fc8cb3          	add	s9,s9,a5
c0021204:	00f92223          	sw	a5,4(s2) # 3ffe0004 <_DMEM_LENGTH+0x3f7e0004>
c0021208:	00e92023          	sw	a4,0(s2)
c002120c:	0f912623          	sw	s9,236(sp)
c0021210:	0e912423          	sw	s1,232(sp)
c0021214:	00700793          	li	a5,7
c0021218:	00890913          	addi	s2,s2,8
c002121c:	7497c2e3          	blt	a5,s1,c0022160 <_vfprintf_r+0x1728>
c0021220:	0f012783          	lw	a5,240(sp)
c0021224:	00148693          	addi	a3,s1,1
c0021228:	0a010593          	addi	a1,sp,160
c002122c:	0af12823          	sw	a5,176(sp)
c0021230:	0f412783          	lw	a5,244(sp)
c0021234:	0b010513          	addi	a0,sp,176
c0021238:	00d12e23          	sw	a3,28(sp)
c002123c:	0af12a23          	sw	a5,180(sp)
c0021240:	0f812783          	lw	a5,248(sp)
c0021244:	0a012023          	sw	zero,160(sp)
c0021248:	0a012223          	sw	zero,164(sp)
c002124c:	0af12c23          	sw	a5,184(sp)
c0021250:	0fc12783          	lw	a5,252(sp)
c0021254:	0a012423          	sw	zero,168(sp)
c0021258:	0a012623          	sw	zero,172(sp)
c002125c:	0af12e23          	sw	a5,188(sp)
c0021260:	0f90d0ef          	jal	ra,c002eb58 <__eqtf2>
c0021264:	01c12683          	lw	a3,28(sp)
c0021268:	02012783          	lw	a5,32(sp)
c002126c:	00890893          	addi	a7,s2,8
c0021270:	00068713          	mv	a4,a3
c0021274:	fff78d93          	addi	s11,a5,-1
c0021278:	300500e3          	beqz	a0,c0021d78 <_vfprintf_r+0x1340>
c002127c:	001b0813          	addi	a6,s6,1
c0021280:	01bc8cb3          	add	s9,s9,s11
c0021284:	01092023          	sw	a6,0(s2)
c0021288:	01b92223          	sw	s11,4(s2)
c002128c:	0f912623          	sw	s9,236(sp)
c0021290:	0ed12423          	sw	a3,232(sp)
c0021294:	00700793          	li	a5,7
c0021298:	50d7c4e3          	blt	a5,a3,c0021fa0 <_vfprintf_r+0x1568>
c002129c:	01090793          	addi	a5,s2,16
c00212a0:	00248713          	addi	a4,s1,2
c00212a4:	00088913          	mv	s2,a7
c00212a8:	00078893          	mv	a7,a5
c00212ac:	03812603          	lw	a2,56(sp)
c00212b0:	0d410693          	addi	a3,sp,212
c00212b4:	00d92023          	sw	a3,0(s2)
c00212b8:	019607b3          	add	a5,a2,s9
c00212bc:	00c92223          	sw	a2,4(s2)
c00212c0:	0ef12623          	sw	a5,236(sp)
c00212c4:	0ee12423          	sw	a4,232(sp)
c00212c8:	00700693          	li	a3,7
c00212cc:	a6e6d8e3          	bge	a3,a4,c0020d3c <_vfprintf_r+0x304>
c00212d0:	0e410613          	addi	a2,sp,228
c00212d4:	000c0593          	mv	a1,s8
c00212d8:	000d0513          	mv	a0,s10
c00212dc:	585090ef          	jal	ra,c002b060 <__sprint_r>
c00212e0:	7c051463          	bnez	a0,c0021aa8 <_vfprintf_r+0x1070>
c00212e4:	0ec12783          	lw	a5,236(sp)
c00212e8:	10c10893          	addi	a7,sp,268
c00212ec:	a51ff06f          	j	c0020d3c <_vfprintf_r+0x304>
c00212f0:	01000693          	li	a3,16
c00212f4:	0e812703          	lw	a4,232(sp)
c00212f8:	0096c463          	blt	a3,s1,c0021300 <_vfprintf_r+0x8c8>
c00212fc:	4ed0106f          	j	c0022fe8 <_vfprintf_r+0x25b0>
c0021300:	c80026b7          	lui	a3,0xc8002
c0021304:	d6468e93          	addi	t4,a3,-668 # c8001d64 <_end+0xfff7d4e4>
c0021308:	01000913          	li	s2,16
c002130c:	00700a13          	li	s4,7
c0021310:	000e8b13          	mv	s6,t4
c0021314:	00c0006f          	j	c0021320 <_vfprintf_r+0x8e8>
c0021318:	ff048493          	addi	s1,s1,-16
c002131c:	04995663          	bge	s2,s1,c0021368 <_vfprintf_r+0x930>
c0021320:	01078793          	addi	a5,a5,16
c0021324:	00170713          	addi	a4,a4,1
c0021328:	0168a023          	sw	s6,0(a7)
c002132c:	0128a223          	sw	s2,4(a7)
c0021330:	0ef12623          	sw	a5,236(sp)
c0021334:	0ee12423          	sw	a4,232(sp)
c0021338:	00888893          	addi	a7,a7,8
c002133c:	fcea5ee3          	bge	s4,a4,c0021318 <_vfprintf_r+0x8e0>
c0021340:	0e410613          	addi	a2,sp,228
c0021344:	000c0593          	mv	a1,s8
c0021348:	000d0513          	mv	a0,s10
c002134c:	515090ef          	jal	ra,c002b060 <__sprint_r>
c0021350:	74051c63          	bnez	a0,c0021aa8 <_vfprintf_r+0x1070>
c0021354:	ff048493          	addi	s1,s1,-16
c0021358:	0ec12783          	lw	a5,236(sp)
c002135c:	0e812703          	lw	a4,232(sp)
c0021360:	10c10893          	addi	a7,sp,268
c0021364:	fa994ee3          	blt	s2,s1,c0021320 <_vfprintf_r+0x8e8>
c0021368:	000b0e93          	mv	t4,s6
c002136c:	009787b3          	add	a5,a5,s1
c0021370:	00170713          	addi	a4,a4,1
c0021374:	01d8a023          	sw	t4,0(a7)
c0021378:	0098a223          	sw	s1,4(a7)
c002137c:	0ef12623          	sw	a5,236(sp)
c0021380:	0ee12423          	sw	a4,232(sp)
c0021384:	00700693          	li	a3,7
c0021388:	9ce6d2e3          	bge	a3,a4,c0020d4c <_vfprintf_r+0x314>
c002138c:	0e410613          	addi	a2,sp,228
c0021390:	000c0593          	mv	a1,s8
c0021394:	000d0513          	mv	a0,s10
c0021398:	4c9090ef          	jal	ra,c002b060 <__sprint_r>
c002139c:	70051663          	bnez	a0,c0021aa8 <_vfprintf_r+0x1070>
c00213a0:	0ec12783          	lw	a5,236(sp)
c00213a4:	9a9ff06f          	j	c0020d4c <_vfprintf_r+0x314>
c00213a8:	000d0513          	mv	a0,s10
c00213ac:	125020ef          	jal	ra,c0023cd0 <__sinit>
c00213b0:	f04ff06f          	j	c0020ab4 <_vfprintf_r+0x7c>
c00213b4:	01412703          	lw	a4,20(sp)
c00213b8:	000c8893          	mv	a7,s9
c00213bc:	0c0103a3          	sb	zero,199(sp)
c00213c0:	00072783          	lw	a5,0(a4)
c00213c4:	00470713          	addi	a4,a4,4
c00213c8:	00e12a23          	sw	a4,20(sp)
c00213cc:	14f10623          	sb	a5,332(sp)
c00213d0:	00100a93          	li	s5,1
c00213d4:	00100c93          	li	s9,1
c00213d8:	14c10b13          	addi	s6,sp,332
c00213dc:	881ff06f          	j	c0020c5c <_vfprintf_r+0x224>
c00213e0:	01412783          	lw	a5,20(sp)
c00213e4:	0c0103a3          	sb	zero,199(sp)
c00213e8:	000c8893          	mv	a7,s9
c00213ec:	0007ab03          	lw	s6,0(a5)
c00213f0:	00478913          	addi	s2,a5,4
c00213f4:	4a0b00e3          	beqz	s6,c0022094 <_vfprintf_r+0x165c>
c00213f8:	fff00793          	li	a5,-1
c00213fc:	00fd9463          	bne	s11,a5,c0021404 <_vfprintf_r+0x9cc>
c0021400:	0380106f          	j	c0022438 <_vfprintf_r+0x1a00>
c0021404:	000d8613          	mv	a2,s11
c0021408:	00000593          	li	a1,0
c002140c:	000b0513          	mv	a0,s6
c0021410:	01912a23          	sw	s9,20(sp)
c0021414:	2e5060ef          	jal	ra,c0027ef8 <memchr>
c0021418:	00a12823          	sw	a0,16(sp)
c002141c:	01412883          	lw	a7,20(sp)
c0021420:	00051463          	bnez	a0,c0021428 <_vfprintf_r+0x9f0>
c0021424:	28d0106f          	j	c0022eb0 <_vfprintf_r+0x2478>
c0021428:	01012783          	lw	a5,16(sp)
c002142c:	01212a23          	sw	s2,20(sp)
c0021430:	00012823          	sw	zero,16(sp)
c0021434:	41678cb3          	sub	s9,a5,s6
c0021438:	0c714783          	lbu	a5,199(sp)
c002143c:	fffcca93          	not	s5,s9
c0021440:	41fada93          	srai	s5,s5,0x1f
c0021444:	02012423          	sw	zero,40(sp)
c0021448:	02012223          	sw	zero,36(sp)
c002144c:	00012e23          	sw	zero,28(sp)
c0021450:	015cfab3          	and	s5,s9,s5
c0021454:	00000d93          	li	s11,0
c0021458:	80078ce3          	beqz	a5,c0020c70 <_vfprintf_r+0x238>
c002145c:	001a8a93          	addi	s5,s5,1
c0021460:	811ff06f          	j	c0020c70 <_vfprintf_r+0x238>
c0021464:	00044483          	lbu	s1,0(s0)
c0021468:	06800793          	li	a5,104
c002146c:	40f48ce3          	beq	s1,a5,c0022084 <_vfprintf_r+0x164c>
c0021470:	040a6a13          	ori	s4,s4,64
c0021474:	f7cff06f          	j	c0020bf0 <_vfprintf_r+0x1b8>
c0021478:	01412683          	lw	a3,20(sp)
c002147c:	020a7793          	andi	a5,s4,32
c0021480:	000c8893          	mv	a7,s9
c0021484:	0006a703          	lw	a4,0(a3)
c0021488:	00468693          	addi	a3,a3,4
c002148c:	00d12a23          	sw	a3,20(sp)
c0021490:	24079ce3          	bnez	a5,c0021ee8 <_vfprintf_r+0x14b0>
c0021494:	010a7793          	andi	a5,s4,16
c0021498:	720798e3          	bnez	a5,c00223c8 <_vfprintf_r+0x1990>
c002149c:	040a7793          	andi	a5,s4,64
c00214a0:	00078463          	beqz	a5,c00214a8 <_vfprintf_r+0xa70>
c00214a4:	33c0106f          	j	c00227e0 <_vfprintf_r+0x1da8>
c00214a8:	200a7a13          	andi	s4,s4,512
c00214ac:	700a0ee3          	beqz	s4,c00223c8 <_vfprintf_r+0x1990>
c00214b0:	00c12783          	lw	a5,12(sp)
c00214b4:	00040b13          	mv	s6,s0
c00214b8:	00f70023          	sb	a5,0(a4)
c00214bc:	8c9ff06f          	j	c0020d84 <_vfprintf_r+0x34c>
c00214c0:	00044483          	lbu	s1,0(s0)
c00214c4:	06c00793          	li	a5,108
c00214c8:	36f48ce3          	beq	s1,a5,c0022040 <_vfprintf_r+0x1608>
c00214cc:	010a6a13          	ori	s4,s4,16
c00214d0:	f20ff06f          	j	c0020bf0 <_vfprintf_r+0x1b8>
c00214d4:	01412703          	lw	a4,20(sp)
c00214d8:	ffff87b7          	lui	a5,0xffff8
c00214dc:	8307c793          	xori	a5,a5,-2000
c00214e0:	0cf11423          	sh	a5,200(sp)
c00214e4:	00470793          	addi	a5,a4,4
c00214e8:	000c8893          	mv	a7,s9
c00214ec:	00f12a23          	sw	a5,20(sp)
c00214f0:	00072c83          	lw	s9,0(a4)
c00214f4:	c80027b7          	lui	a5,0xc8002
c00214f8:	6e478793          	addi	a5,a5,1764 # c80026e4 <_end+0xfff7de64>
c00214fc:	02f12a23          	sw	a5,52(sp)
c0021500:	00000913          	li	s2,0
c0021504:	002a6b93          	ori	s7,s4,2
c0021508:	00200793          	li	a5,2
c002150c:	07800493          	li	s1,120
c0021510:	0c0103a3          	sb	zero,199(sp)
c0021514:	fff00693          	li	a3,-1
c0021518:	20dd8263          	beq	s11,a3,c002171c <_vfprintf_r+0xce4>
c002151c:	012ce6b3          	or	a3,s9,s2
c0021520:	f7fbfa13          	andi	s4,s7,-129
c0021524:	1e069a63          	bnez	a3,c0021718 <_vfprintf_r+0xce0>
c0021528:	260d9063          	bnez	s11,c0021788 <_vfprintf_r+0xd50>
c002152c:	10079863          	bnez	a5,c002163c <_vfprintf_r+0xc04>
c0021530:	001bfc93          	andi	s9,s7,1
c0021534:	1b010b13          	addi	s6,sp,432
c0021538:	160c9ee3          	bnez	s9,c0021eb4 <_vfprintf_r+0x147c>
c002153c:	0c714783          	lbu	a5,199(sp)
c0021540:	000d8a93          	mv	s5,s11
c0021544:	019dd463          	bge	s11,s9,c002154c <_vfprintf_r+0xb14>
c0021548:	000c8a93          	mv	s5,s9
c002154c:	00012823          	sw	zero,16(sp)
c0021550:	02012423          	sw	zero,40(sp)
c0021554:	02012223          	sw	zero,36(sp)
c0021558:	00012e23          	sw	zero,28(sp)
c002155c:	f00790e3          	bnez	a5,c002145c <_vfprintf_r+0xa24>
c0021560:	f10ff06f          	j	c0020c70 <_vfprintf_r+0x238>
c0021564:	000c8893          	mv	a7,s9
c0021568:	010a6a13          	ori	s4,s4,16
c002156c:	020a7793          	andi	a5,s4,32
c0021570:	06078ee3          	beqz	a5,c0021dec <_vfprintf_r+0x13b4>
c0021574:	01412783          	lw	a5,20(sp)
c0021578:	00778b13          	addi	s6,a5,7
c002157c:	ff8b7b13          	andi	s6,s6,-8
c0021580:	000b2c83          	lw	s9,0(s6)
c0021584:	004b2903          	lw	s2,4(s6)
c0021588:	008b0793          	addi	a5,s6,8
c002158c:	00f12a23          	sw	a5,20(sp)
c0021590:	bffa7b93          	andi	s7,s4,-1025
c0021594:	00000793          	li	a5,0
c0021598:	f79ff06f          	j	c0021510 <_vfprintf_r+0xad8>
c002159c:	000c8893          	mv	a7,s9
c00215a0:	010a6b93          	ori	s7,s4,16
c00215a4:	020bf793          	andi	a5,s7,32
c00215a8:	0c0782e3          	beqz	a5,c0021e6c <_vfprintf_r+0x1434>
c00215ac:	01412783          	lw	a5,20(sp)
c00215b0:	00778b13          	addi	s6,a5,7
c00215b4:	ff8b7b13          	andi	s6,s6,-8
c00215b8:	008b0793          	addi	a5,s6,8
c00215bc:	00f12a23          	sw	a5,20(sp)
c00215c0:	000b2c83          	lw	s9,0(s6)
c00215c4:	004b2903          	lw	s2,4(s6)
c00215c8:	00100793          	li	a5,1
c00215cc:	f45ff06f          	j	c0021510 <_vfprintf_r+0xad8>
c00215d0:	00044483          	lbu	s1,0(s0)
c00215d4:	080a6a13          	ori	s4,s4,128
c00215d8:	e18ff06f          	j	c0020bf0 <_vfprintf_r+0x1b8>
c00215dc:	00044483          	lbu	s1,0(s0)
c00215e0:	008a6a13          	ori	s4,s4,8
c00215e4:	e0cff06f          	j	c0020bf0 <_vfprintf_r+0x1b8>
c00215e8:	000c8893          	mv	a7,s9
c00215ec:	010a6a13          	ori	s4,s4,16
c00215f0:	020a7793          	andi	a5,s4,32
c00215f4:	020782e3          	beqz	a5,c0021e18 <_vfprintf_r+0x13e0>
c00215f8:	01412783          	lw	a5,20(sp)
c00215fc:	00778b13          	addi	s6,a5,7
c0021600:	ff8b7b13          	andi	s6,s6,-8
c0021604:	004b2783          	lw	a5,4(s6)
c0021608:	000b2c83          	lw	s9,0(s6)
c002160c:	008b0713          	addi	a4,s6,8
c0021610:	00e12a23          	sw	a4,20(sp)
c0021614:	00078913          	mv	s2,a5
c0021618:	0207c8e3          	bltz	a5,c0021e48 <_vfprintf_r+0x1410>
c002161c:	fff00793          	li	a5,-1
c0021620:	000a0b93          	mv	s7,s4
c0021624:	02fd8463          	beq	s11,a5,c002164c <_vfprintf_r+0xc14>
c0021628:	012ce7b3          	or	a5,s9,s2
c002162c:	f7fa7b93          	andi	s7,s4,-129
c0021630:	00079e63          	bnez	a5,c002164c <_vfprintf_r+0xc14>
c0021634:	020d9263          	bnez	s11,c0021658 <_vfprintf_r+0xc20>
c0021638:	000b8a13          	mv	s4,s7
c002163c:	00000d93          	li	s11,0
c0021640:	00000c93          	li	s9,0
c0021644:	1b010b13          	addi	s6,sp,432
c0021648:	ef5ff06f          	j	c002153c <_vfprintf_r+0xb04>
c002164c:	32091ce3          	bnez	s2,c0022184 <_vfprintf_r+0x174c>
c0021650:	00900793          	li	a5,9
c0021654:	3397e8e3          	bltu	a5,s9,c0022184 <_vfprintf_r+0x174c>
c0021658:	030c8c93          	addi	s9,s9,48
c002165c:	1b9107a3          	sb	s9,431(sp)
c0021660:	000b8a13          	mv	s4,s7
c0021664:	00100c93          	li	s9,1
c0021668:	1af10b13          	addi	s6,sp,431
c002166c:	ed1ff06f          	j	c002153c <_vfprintf_r+0xb04>
c0021670:	01412783          	lw	a5,20(sp)
c0021674:	00044483          	lbu	s1,0(s0)
c0021678:	0007a983          	lw	s3,0(a5)
c002167c:	00478793          	addi	a5,a5,4
c0021680:	00f12a23          	sw	a5,20(sp)
c0021684:	d609d663          	bgez	s3,c0020bf0 <_vfprintf_r+0x1b8>
c0021688:	413009b3          	neg	s3,s3
c002168c:	004a6a13          	ori	s4,s4,4
c0021690:	d60ff06f          	j	c0020bf0 <_vfprintf_r+0x1b8>
c0021694:	00044483          	lbu	s1,0(s0)
c0021698:	001a6a13          	ori	s4,s4,1
c002169c:	d54ff06f          	j	c0020bf0 <_vfprintf_r+0x1b8>
c00216a0:	0c714783          	lbu	a5,199(sp)
c00216a4:	00044483          	lbu	s1,0(s0)
c00216a8:	d4079463          	bnez	a5,c0020bf0 <_vfprintf_r+0x1b8>
c00216ac:	02000793          	li	a5,32
c00216b0:	0cf103a3          	sb	a5,199(sp)
c00216b4:	d3cff06f          	j	c0020bf0 <_vfprintf_r+0x1b8>
c00216b8:	00044483          	lbu	s1,0(s0)
c00216bc:	004a6a13          	ori	s4,s4,4
c00216c0:	d30ff06f          	j	c0020bf0 <_vfprintf_r+0x1b8>
c00216c4:	02b00793          	li	a5,43
c00216c8:	00044483          	lbu	s1,0(s0)
c00216cc:	0cf103a3          	sb	a5,199(sp)
c00216d0:	d20ff06f          	j	c0020bf0 <_vfprintf_r+0x1b8>
c00216d4:	00044483          	lbu	s1,0(s0)
c00216d8:	00140713          	addi	a4,s0,1
c00216dc:	01749463          	bne	s1,s7,c00216e4 <_vfprintf_r+0xcac>
c00216e0:	4b50106f          	j	c0023394 <_vfprintf_r+0x295c>
c00216e4:	fd048693          	addi	a3,s1,-48
c00216e8:	00070413          	mv	s0,a4
c00216ec:	00000d93          	li	s11,0
c00216f0:	d0dae263          	bltu	s5,a3,c0020bf4 <_vfprintf_r+0x1bc>
c00216f4:	00044483          	lbu	s1,0(s0)
c00216f8:	002d9793          	slli	a5,s11,0x2
c00216fc:	01b787b3          	add	a5,a5,s11
c0021700:	00179793          	slli	a5,a5,0x1
c0021704:	00d78db3          	add	s11,a5,a3
c0021708:	fd048693          	addi	a3,s1,-48
c002170c:	00140413          	addi	s0,s0,1
c0021710:	fedaf2e3          	bgeu	s5,a3,c00216f4 <_vfprintf_r+0xcbc>
c0021714:	ce0ff06f          	j	c0020bf4 <_vfprintf_r+0x1bc>
c0021718:	000a0b93          	mv	s7,s4
c002171c:	00100693          	li	a3,1
c0021720:	f2d786e3          	beq	a5,a3,c002164c <_vfprintf_r+0xc14>
c0021724:	00200693          	li	a3,2
c0021728:	06d78c63          	beq	a5,a3,c00217a0 <_vfprintf_r+0xd68>
c002172c:	1b010b13          	addi	s6,sp,432
c0021730:	01d91713          	slli	a4,s2,0x1d
c0021734:	007cf793          	andi	a5,s9,7
c0021738:	003cdc93          	srli	s9,s9,0x3
c002173c:	03078793          	addi	a5,a5,48
c0021740:	01976cb3          	or	s9,a4,s9
c0021744:	00395913          	srli	s2,s2,0x3
c0021748:	fefb0fa3          	sb	a5,-1(s6)
c002174c:	012ce733          	or	a4,s9,s2
c0021750:	000b0613          	mv	a2,s6
c0021754:	fffb0b13          	addi	s6,s6,-1
c0021758:	fc071ce3          	bnez	a4,c0021730 <_vfprintf_r+0xcf8>
c002175c:	001bf693          	andi	a3,s7,1
c0021760:	06068a63          	beqz	a3,c00217d4 <_vfprintf_r+0xd9c>
c0021764:	03000693          	li	a3,48
c0021768:	06d78663          	beq	a5,a3,c00217d4 <_vfprintf_r+0xd9c>
c002176c:	ffe60613          	addi	a2,a2,-2
c0021770:	1b010793          	addi	a5,sp,432
c0021774:	fedb0fa3          	sb	a3,-1(s6)
c0021778:	40c78cb3          	sub	s9,a5,a2
c002177c:	000b8a13          	mv	s4,s7
c0021780:	00060b13          	mv	s6,a2
c0021784:	db9ff06f          	j	c002153c <_vfprintf_r+0xb04>
c0021788:	00100713          	li	a4,1
c002178c:	00e79463          	bne	a5,a4,c0021794 <_vfprintf_r+0xd5c>
c0021790:	0650106f          	j	c0022ff4 <_vfprintf_r+0x25bc>
c0021794:	00200713          	li	a4,2
c0021798:	000a0b93          	mv	s7,s4
c002179c:	f8e798e3          	bne	a5,a4,c002172c <_vfprintf_r+0xcf4>
c00217a0:	03412683          	lw	a3,52(sp)
c00217a4:	1b010b13          	addi	s6,sp,432
c00217a8:	00fcf793          	andi	a5,s9,15
c00217ac:	00f687b3          	add	a5,a3,a5
c00217b0:	0007c703          	lbu	a4,0(a5)
c00217b4:	004cdc93          	srli	s9,s9,0x4
c00217b8:	01c91793          	slli	a5,s2,0x1c
c00217bc:	0197ecb3          	or	s9,a5,s9
c00217c0:	00495913          	srli	s2,s2,0x4
c00217c4:	feeb0fa3          	sb	a4,-1(s6)
c00217c8:	012ce7b3          	or	a5,s9,s2
c00217cc:	fffb0b13          	addi	s6,s6,-1
c00217d0:	fc079ce3          	bnez	a5,c00217a8 <_vfprintf_r+0xd70>
c00217d4:	1b010793          	addi	a5,sp,432
c00217d8:	41678cb3          	sub	s9,a5,s6
c00217dc:	000b8a13          	mv	s4,s7
c00217e0:	d5dff06f          	j	c002153c <_vfprintf_r+0xb04>
c00217e4:	06500713          	li	a4,101
c00217e8:	9c975ae3          	bge	a4,s1,c00211bc <_vfprintf_r+0x784>
c00217ec:	0f012703          	lw	a4,240(sp)
c00217f0:	0a010593          	addi	a1,sp,160
c00217f4:	0b010513          	addi	a0,sp,176
c00217f8:	0ae12823          	sw	a4,176(sp)
c00217fc:	0f412703          	lw	a4,244(sp)
c0021800:	05112223          	sw	a7,68(sp)
c0021804:	04f12023          	sw	a5,64(sp)
c0021808:	0ae12a23          	sw	a4,180(sp)
c002180c:	0f812703          	lw	a4,248(sp)
c0021810:	0a012023          	sw	zero,160(sp)
c0021814:	0a012223          	sw	zero,164(sp)
c0021818:	0ae12c23          	sw	a4,184(sp)
c002181c:	0fc12703          	lw	a4,252(sp)
c0021820:	0a012423          	sw	zero,168(sp)
c0021824:	0a012623          	sw	zero,172(sp)
c0021828:	0ae12e23          	sw	a4,188(sp)
c002182c:	32c0d0ef          	jal	ra,c002eb58 <__eqtf2>
c0021830:	04012783          	lw	a5,64(sp)
c0021834:	04412883          	lw	a7,68(sp)
c0021838:	38051c63          	bnez	a0,c0021bd0 <_vfprintf_r+0x1198>
c002183c:	0e812703          	lw	a4,232(sp)
c0021840:	c80026b7          	lui	a3,0xc8002
c0021844:	71468693          	addi	a3,a3,1812 # c8002714 <_end+0xfff7de94>
c0021848:	00d8a023          	sw	a3,0(a7)
c002184c:	00178793          	addi	a5,a5,1
c0021850:	00100693          	li	a3,1
c0021854:	00170713          	addi	a4,a4,1
c0021858:	00d8a223          	sw	a3,4(a7)
c002185c:	0ef12623          	sw	a5,236(sp)
c0021860:	0ee12423          	sw	a4,232(sp)
c0021864:	00700693          	li	a3,7
c0021868:	00888893          	addi	a7,a7,8
c002186c:	28e6c8e3          	blt	a3,a4,c00222fc <_vfprintf_r+0x18c4>
c0021870:	0cc12703          	lw	a4,204(sp)
c0021874:	02012683          	lw	a3,32(sp)
c0021878:	62d75263          	bge	a4,a3,c0021e9c <_vfprintf_r+0x1464>
c002187c:	03012703          	lw	a4,48(sp)
c0021880:	02c12683          	lw	a3,44(sp)
c0021884:	00888893          	addi	a7,a7,8
c0021888:	fee8ac23          	sw	a4,-8(a7)
c002188c:	0e812703          	lw	a4,232(sp)
c0021890:	00d787b3          	add	a5,a5,a3
c0021894:	fed8ae23          	sw	a3,-4(a7)
c0021898:	00170713          	addi	a4,a4,1
c002189c:	0ef12623          	sw	a5,236(sp)
c00218a0:	0ee12423          	sw	a4,232(sp)
c00218a4:	00700693          	li	a3,7
c00218a8:	7ae6c463          	blt	a3,a4,c0022050 <_vfprintf_r+0x1618>
c00218ac:	02012703          	lw	a4,32(sp)
c00218b0:	fff70493          	addi	s1,a4,-1
c00218b4:	c8905463          	blez	s1,c0020d3c <_vfprintf_r+0x304>
c00218b8:	01000693          	li	a3,16
c00218bc:	0e812703          	lw	a4,232(sp)
c00218c0:	2496dee3          	bge	a3,s1,c002231c <_vfprintf_r+0x18e4>
c00218c4:	01000913          	li	s2,16
c00218c8:	00700c93          	li	s9,7
c00218cc:	00c0006f          	j	c00218d8 <_vfprintf_r+0xea0>
c00218d0:	ff048493          	addi	s1,s1,-16
c00218d4:	249954e3          	bge	s2,s1,c002231c <_vfprintf_r+0x18e4>
c00218d8:	00812683          	lw	a3,8(sp)
c00218dc:	01078793          	addi	a5,a5,16
c00218e0:	00170713          	addi	a4,a4,1
c00218e4:	00d8a023          	sw	a3,0(a7)
c00218e8:	0128a223          	sw	s2,4(a7)
c00218ec:	0ef12623          	sw	a5,236(sp)
c00218f0:	0ee12423          	sw	a4,232(sp)
c00218f4:	00888893          	addi	a7,a7,8
c00218f8:	fcecdce3          	bge	s9,a4,c00218d0 <_vfprintf_r+0xe98>
c00218fc:	0e410613          	addi	a2,sp,228
c0021900:	000c0593          	mv	a1,s8
c0021904:	000d0513          	mv	a0,s10
c0021908:	758090ef          	jal	ra,c002b060 <__sprint_r>
c002190c:	18051e63          	bnez	a0,c0021aa8 <_vfprintf_r+0x1070>
c0021910:	0ec12783          	lw	a5,236(sp)
c0021914:	0e812703          	lw	a4,232(sp)
c0021918:	10c10893          	addi	a7,sp,268
c002191c:	fb5ff06f          	j	c00218d0 <_vfprintf_r+0xe98>
c0021920:	41598933          	sub	s2,s3,s5
c0021924:	bf205063          	blez	s2,c0020d04 <_vfprintf_r+0x2cc>
c0021928:	01000613          	li	a2,16
c002192c:	0e812703          	lw	a4,232(sp)
c0021930:	07265463          	bge	a2,s2,c0021998 <_vfprintf_r+0xf60>
c0021934:	01000e13          	li	t3,16
c0021938:	00700b93          	li	s7,7
c002193c:	00c0006f          	j	c0021948 <_vfprintf_r+0xf10>
c0021940:	ff090913          	addi	s2,s2,-16
c0021944:	052e5a63          	bge	t3,s2,c0021998 <_vfprintf_r+0xf60>
c0021948:	00812683          	lw	a3,8(sp)
c002194c:	01078793          	addi	a5,a5,16
c0021950:	00170713          	addi	a4,a4,1
c0021954:	00d8a023          	sw	a3,0(a7)
c0021958:	01c8a223          	sw	t3,4(a7)
c002195c:	0ef12623          	sw	a5,236(sp)
c0021960:	0ee12423          	sw	a4,232(sp)
c0021964:	00888893          	addi	a7,a7,8
c0021968:	fcebdce3          	bge	s7,a4,c0021940 <_vfprintf_r+0xf08>
c002196c:	0e410613          	addi	a2,sp,228
c0021970:	000c0593          	mv	a1,s8
c0021974:	000d0513          	mv	a0,s10
c0021978:	6e8090ef          	jal	ra,c002b060 <__sprint_r>
c002197c:	12051663          	bnez	a0,c0021aa8 <_vfprintf_r+0x1070>
c0021980:	01000e13          	li	t3,16
c0021984:	ff090913          	addi	s2,s2,-16
c0021988:	0ec12783          	lw	a5,236(sp)
c002198c:	0e812703          	lw	a4,232(sp)
c0021990:	10c10893          	addi	a7,sp,268
c0021994:	fb2e4ae3          	blt	t3,s2,c0021948 <_vfprintf_r+0xf10>
c0021998:	00812683          	lw	a3,8(sp)
c002199c:	012787b3          	add	a5,a5,s2
c00219a0:	00170713          	addi	a4,a4,1
c00219a4:	00d8a023          	sw	a3,0(a7)
c00219a8:	0128a223          	sw	s2,4(a7)
c00219ac:	0ef12623          	sw	a5,236(sp)
c00219b0:	0ee12423          	sw	a4,232(sp)
c00219b4:	00700693          	li	a3,7
c00219b8:	00888893          	addi	a7,a7,8
c00219bc:	b4e6d463          	bge	a3,a4,c0020d04 <_vfprintf_r+0x2cc>
c00219c0:	0e410613          	addi	a2,sp,228
c00219c4:	000c0593          	mv	a1,s8
c00219c8:	000d0513          	mv	a0,s10
c00219cc:	694090ef          	jal	ra,c002b060 <__sprint_r>
c00219d0:	0c051c63          	bnez	a0,c0021aa8 <_vfprintf_r+0x1070>
c00219d4:	0ec12783          	lw	a5,236(sp)
c00219d8:	10c10893          	addi	a7,sp,268
c00219dc:	b28ff06f          	j	c0020d04 <_vfprintf_r+0x2cc>
c00219e0:	01000613          	li	a2,16
c00219e4:	0e812703          	lw	a4,232(sp)
c00219e8:	07b65263          	bge	a2,s11,c0021a4c <_vfprintf_r+0x1014>
c00219ec:	01000b93          	li	s7,16
c00219f0:	00700913          	li	s2,7
c00219f4:	00c0006f          	j	c0021a00 <_vfprintf_r+0xfc8>
c00219f8:	ff0d8d93          	addi	s11,s11,-16
c00219fc:	05bbd863          	bge	s7,s11,c0021a4c <_vfprintf_r+0x1014>
c0021a00:	00812683          	lw	a3,8(sp)
c0021a04:	01078793          	addi	a5,a5,16
c0021a08:	00170713          	addi	a4,a4,1
c0021a0c:	00d8a023          	sw	a3,0(a7)
c0021a10:	0178a223          	sw	s7,4(a7)
c0021a14:	0ef12623          	sw	a5,236(sp)
c0021a18:	0ee12423          	sw	a4,232(sp)
c0021a1c:	00888893          	addi	a7,a7,8
c0021a20:	fce95ce3          	bge	s2,a4,c00219f8 <_vfprintf_r+0xfc0>
c0021a24:	0e410613          	addi	a2,sp,228
c0021a28:	000c0593          	mv	a1,s8
c0021a2c:	000d0513          	mv	a0,s10
c0021a30:	630090ef          	jal	ra,c002b060 <__sprint_r>
c0021a34:	06051a63          	bnez	a0,c0021aa8 <_vfprintf_r+0x1070>
c0021a38:	ff0d8d93          	addi	s11,s11,-16
c0021a3c:	0ec12783          	lw	a5,236(sp)
c0021a40:	0e812703          	lw	a4,232(sp)
c0021a44:	10c10893          	addi	a7,sp,268
c0021a48:	fbbbcce3          	blt	s7,s11,c0021a00 <_vfprintf_r+0xfc8>
c0021a4c:	00812683          	lw	a3,8(sp)
c0021a50:	01b787b3          	add	a5,a5,s11
c0021a54:	00170713          	addi	a4,a4,1
c0021a58:	00d8a023          	sw	a3,0(a7)
c0021a5c:	01b8a223          	sw	s11,4(a7)
c0021a60:	0ef12623          	sw	a5,236(sp)
c0021a64:	0ee12423          	sw	a4,232(sp)
c0021a68:	00700693          	li	a3,7
c0021a6c:	00888893          	addi	a7,a7,8
c0021a70:	a8e6de63          	bge	a3,a4,c0020d0c <_vfprintf_r+0x2d4>
c0021a74:	0e410613          	addi	a2,sp,228
c0021a78:	000c0593          	mv	a1,s8
c0021a7c:	000d0513          	mv	a0,s10
c0021a80:	5e0090ef          	jal	ra,c002b060 <__sprint_r>
c0021a84:	02051263          	bnez	a0,c0021aa8 <_vfprintf_r+0x1070>
c0021a88:	0ec12783          	lw	a5,236(sp)
c0021a8c:	10c10893          	addi	a7,sp,268
c0021a90:	a7cff06f          	j	c0020d0c <_vfprintf_r+0x2d4>
c0021a94:	0e410613          	addi	a2,sp,228
c0021a98:	000c0593          	mv	a1,s8
c0021a9c:	000d0513          	mv	a0,s10
c0021aa0:	5c0090ef          	jal	ra,c002b060 <__sprint_r>
c0021aa4:	ac050063          	beqz	a0,c0020d64 <_vfprintf_r+0x32c>
c0021aa8:	01012b83          	lw	s7,16(sp)
c0021aac:	ae0b8663          	beqz	s7,c0020d98 <_vfprintf_r+0x360>
c0021ab0:	000b8593          	mv	a1,s7
c0021ab4:	000d0513          	mv	a0,s10
c0021ab8:	3a0020ef          	jal	ra,c0023e58 <_free_r>
c0021abc:	adcff06f          	j	c0020d98 <_vfprintf_r+0x360>
c0021ac0:	01000613          	li	a2,16
c0021ac4:	0e812703          	lw	a4,232(sp)
c0021ac8:	00d64463          	blt	a2,a3,c0021ad0 <_vfprintf_r+0x1098>
c0021acc:	3d80106f          	j	c0022ea4 <_vfprintf_r+0x246c>
c0021ad0:	c8002637          	lui	a2,0xc8002
c0021ad4:	d6460e93          	addi	t4,a2,-668 # c8001d64 <_end+0xfff7d4e4>
c0021ad8:	04812023          	sw	s0,64(sp)
c0021adc:	04912223          	sw	s1,68(sp)
c0021ae0:	000d0413          	mv	s0,s10
c0021ae4:	000c0493          	mv	s1,s8
c0021ae8:	01000e13          	li	t3,16
c0021aec:	00700293          	li	t0,7
c0021af0:	00068c13          	mv	s8,a3
c0021af4:	000e8d13          	mv	s10,t4
c0021af8:	00c0006f          	j	c0021b04 <_vfprintf_r+0x10cc>
c0021afc:	ff0c0c13          	addi	s8,s8,-16
c0021b00:	058e5a63          	bge	t3,s8,c0021b54 <_vfprintf_r+0x111c>
c0021b04:	01078793          	addi	a5,a5,16
c0021b08:	00170713          	addi	a4,a4,1
c0021b0c:	01a8a023          	sw	s10,0(a7)
c0021b10:	01c8a223          	sw	t3,4(a7)
c0021b14:	0ef12623          	sw	a5,236(sp)
c0021b18:	0ee12423          	sw	a4,232(sp)
c0021b1c:	00888893          	addi	a7,a7,8
c0021b20:	fce2dee3          	bge	t0,a4,c0021afc <_vfprintf_r+0x10c4>
c0021b24:	0e410613          	addi	a2,sp,228
c0021b28:	00048593          	mv	a1,s1
c0021b2c:	00040513          	mv	a0,s0
c0021b30:	530090ef          	jal	ra,c002b060 <__sprint_r>
c0021b34:	78051e63          	bnez	a0,c00222d0 <_vfprintf_r+0x1898>
c0021b38:	01000e13          	li	t3,16
c0021b3c:	ff0c0c13          	addi	s8,s8,-16
c0021b40:	0ec12783          	lw	a5,236(sp)
c0021b44:	0e812703          	lw	a4,232(sp)
c0021b48:	10c10893          	addi	a7,sp,268
c0021b4c:	00700293          	li	t0,7
c0021b50:	fb8e4ae3          	blt	t3,s8,c0021b04 <_vfprintf_r+0x10cc>
c0021b54:	000c0693          	mv	a3,s8
c0021b58:	000d0e93          	mv	t4,s10
c0021b5c:	00048c13          	mv	s8,s1
c0021b60:	00040d13          	mv	s10,s0
c0021b64:	04412483          	lw	s1,68(sp)
c0021b68:	04012403          	lw	s0,64(sp)
c0021b6c:	00d787b3          	add	a5,a5,a3
c0021b70:	00170713          	addi	a4,a4,1
c0021b74:	00d8a223          	sw	a3,4(a7)
c0021b78:	01d8a023          	sw	t4,0(a7)
c0021b7c:	0ef12623          	sw	a5,236(sp)
c0021b80:	0ee12423          	sw	a4,232(sp)
c0021b84:	00700693          	li	a3,7
c0021b88:	00888893          	addi	a7,a7,8
c0021b8c:	90e6d263          	bge	a3,a4,c0020c90 <_vfprintf_r+0x258>
c0021b90:	0e410613          	addi	a2,sp,228
c0021b94:	000c0593          	mv	a1,s8
c0021b98:	000d0513          	mv	a0,s10
c0021b9c:	4c4090ef          	jal	ra,c002b060 <__sprint_r>
c0021ba0:	f00514e3          	bnez	a0,c0021aa8 <_vfprintf_r+0x1070>
c0021ba4:	0ec12783          	lw	a5,236(sp)
c0021ba8:	10c10893          	addi	a7,sp,268
c0021bac:	8e4ff06f          	j	c0020c90 <_vfprintf_r+0x258>
c0021bb0:	0e410613          	addi	a2,sp,228
c0021bb4:	000c0593          	mv	a1,s8
c0021bb8:	000d0513          	mv	a0,s10
c0021bbc:	4a4090ef          	jal	ra,c002b060 <__sprint_r>
c0021bc0:	ee0514e3          	bnez	a0,c0021aa8 <_vfprintf_r+0x1070>
c0021bc4:	0ec12783          	lw	a5,236(sp)
c0021bc8:	10c10893          	addi	a7,sp,268
c0021bcc:	930ff06f          	j	c0020cfc <_vfprintf_r+0x2c4>
c0021bd0:	0cc12603          	lw	a2,204(sp)
c0021bd4:	66c05e63          	blez	a2,c0022250 <_vfprintf_r+0x1818>
c0021bd8:	01c12703          	lw	a4,28(sp)
c0021bdc:	02012683          	lw	a3,32(sp)
c0021be0:	00070493          	mv	s1,a4
c0021be4:	38e6c463          	blt	a3,a4,c0021f6c <_vfprintf_r+0x1534>
c0021be8:	02905663          	blez	s1,c0021c14 <_vfprintf_r+0x11dc>
c0021bec:	0e812703          	lw	a4,232(sp)
c0021bf0:	009787b3          	add	a5,a5,s1
c0021bf4:	0168a023          	sw	s6,0(a7)
c0021bf8:	00170713          	addi	a4,a4,1
c0021bfc:	0098a223          	sw	s1,4(a7)
c0021c00:	0ef12623          	sw	a5,236(sp)
c0021c04:	0ee12423          	sw	a4,232(sp)
c0021c08:	00700693          	li	a3,7
c0021c0c:	00888893          	addi	a7,a7,8
c0021c10:	38e6c4e3          	blt	a3,a4,c0022798 <_vfprintf_r+0x1d60>
c0021c14:	fff4c713          	not	a4,s1
c0021c18:	41f75713          	srai	a4,a4,0x1f
c0021c1c:	00e4f4b3          	and	s1,s1,a4
c0021c20:	01c12703          	lw	a4,28(sp)
c0021c24:	409704b3          	sub	s1,a4,s1
c0021c28:	48904663          	bgtz	s1,c00220b4 <_vfprintf_r+0x167c>
c0021c2c:	01c12683          	lw	a3,28(sp)
c0021c30:	400a7713          	andi	a4,s4,1024
c0021c34:	00db0db3          	add	s11,s6,a3
c0021c38:	120714e3          	bnez	a4,c0022560 <_vfprintf_r+0x1b28>
c0021c3c:	0cc12483          	lw	s1,204(sp)
c0021c40:	02012703          	lw	a4,32(sp)
c0021c44:	00e4c663          	blt	s1,a4,c0021c50 <_vfprintf_r+0x1218>
c0021c48:	001a7713          	andi	a4,s4,1
c0021c4c:	36070ae3          	beqz	a4,c00227c0 <_vfprintf_r+0x1d88>
c0021c50:	03012703          	lw	a4,48(sp)
c0021c54:	02c12683          	lw	a3,44(sp)
c0021c58:	00700613          	li	a2,7
c0021c5c:	00e8a023          	sw	a4,0(a7)
c0021c60:	0e812703          	lw	a4,232(sp)
c0021c64:	00d787b3          	add	a5,a5,a3
c0021c68:	00d8a223          	sw	a3,4(a7)
c0021c6c:	00170713          	addi	a4,a4,1
c0021c70:	0ef12623          	sw	a5,236(sp)
c0021c74:	0ee12423          	sw	a4,232(sp)
c0021c78:	00888893          	addi	a7,a7,8
c0021c7c:	00e65463          	bge	a2,a4,c0021c84 <_vfprintf_r+0x124c>
c0021c80:	1fc0106f          	j	c0022e7c <_vfprintf_r+0x2444>
c0021c84:	02012683          	lw	a3,32(sp)
c0021c88:	00db0733          	add	a4,s6,a3
c0021c8c:	409684b3          	sub	s1,a3,s1
c0021c90:	41b70733          	sub	a4,a4,s11
c0021c94:	00048913          	mv	s2,s1
c0021c98:	00975463          	bge	a4,s1,c0021ca0 <_vfprintf_r+0x1268>
c0021c9c:	00070913          	mv	s2,a4
c0021ca0:	03205863          	blez	s2,c0021cd0 <_vfprintf_r+0x1298>
c0021ca4:	0e812703          	lw	a4,232(sp)
c0021ca8:	012787b3          	add	a5,a5,s2
c0021cac:	01b8a023          	sw	s11,0(a7)
c0021cb0:	00170713          	addi	a4,a4,1
c0021cb4:	0128a223          	sw	s2,4(a7)
c0021cb8:	0ef12623          	sw	a5,236(sp)
c0021cbc:	0ee12423          	sw	a4,232(sp)
c0021cc0:	00700693          	li	a3,7
c0021cc4:	00888893          	addi	a7,a7,8
c0021cc8:	00e6d463          	bge	a3,a4,c0021cd0 <_vfprintf_r+0x1298>
c0021ccc:	2100106f          	j	c0022edc <_vfprintf_r+0x24a4>
c0021cd0:	fff94713          	not	a4,s2
c0021cd4:	41f75713          	srai	a4,a4,0x1f
c0021cd8:	00e97733          	and	a4,s2,a4
c0021cdc:	40e484b3          	sub	s1,s1,a4
c0021ce0:	00904463          	bgtz	s1,c0021ce8 <_vfprintf_r+0x12b0>
c0021ce4:	858ff06f          	j	c0020d3c <_vfprintf_r+0x304>
c0021ce8:	01000693          	li	a3,16
c0021cec:	0e812703          	lw	a4,232(sp)
c0021cf0:	6296d663          	bge	a3,s1,c002231c <_vfprintf_r+0x18e4>
c0021cf4:	01000913          	li	s2,16
c0021cf8:	00700c93          	li	s9,7
c0021cfc:	00c0006f          	j	c0021d08 <_vfprintf_r+0x12d0>
c0021d00:	ff048493          	addi	s1,s1,-16
c0021d04:	60995c63          	bge	s2,s1,c002231c <_vfprintf_r+0x18e4>
c0021d08:	00812683          	lw	a3,8(sp)
c0021d0c:	01078793          	addi	a5,a5,16
c0021d10:	00170713          	addi	a4,a4,1
c0021d14:	00d8a023          	sw	a3,0(a7)
c0021d18:	0128a223          	sw	s2,4(a7)
c0021d1c:	0ef12623          	sw	a5,236(sp)
c0021d20:	0ee12423          	sw	a4,232(sp)
c0021d24:	00888893          	addi	a7,a7,8
c0021d28:	fcecdce3          	bge	s9,a4,c0021d00 <_vfprintf_r+0x12c8>
c0021d2c:	0e410613          	addi	a2,sp,228
c0021d30:	000c0593          	mv	a1,s8
c0021d34:	000d0513          	mv	a0,s10
c0021d38:	328090ef          	jal	ra,c002b060 <__sprint_r>
c0021d3c:	d60516e3          	bnez	a0,c0021aa8 <_vfprintf_r+0x1070>
c0021d40:	0ec12783          	lw	a5,236(sp)
c0021d44:	0e812703          	lw	a4,232(sp)
c0021d48:	10c10893          	addi	a7,sp,268
c0021d4c:	fb5ff06f          	j	c0021d00 <_vfprintf_r+0x12c8>
c0021d50:	001a7793          	andi	a5,s4,1
c0021d54:	c8079463          	bnez	a5,c00211dc <_vfprintf_r+0x7a4>
c0021d58:	00d8a223          	sw	a3,4(a7)
c0021d5c:	0f912623          	sw	s9,236(sp)
c0021d60:	0e912423          	sw	s1,232(sp)
c0021d64:	00700793          	li	a5,7
c0021d68:	2297cc63          	blt	a5,s1,c0021fa0 <_vfprintf_r+0x1568>
c0021d6c:	00270713          	addi	a4,a4,2
c0021d70:	01088893          	addi	a7,a7,16
c0021d74:	d38ff06f          	j	c00212ac <_vfprintf_r+0x874>
c0021d78:	d3b05a63          	blez	s11,c00212ac <_vfprintf_r+0x874>
c0021d7c:	01000613          	li	a2,16
c0021d80:	01b64463          	blt	a2,s11,c0021d88 <_vfprintf_r+0x1350>
c0021d84:	6080106f          	j	c002338c <_vfprintf_r+0x2954>
c0021d88:	01000713          	li	a4,16
c0021d8c:	00700b13          	li	s6,7
c0021d90:	00068493          	mv	s1,a3
c0021d94:	0100006f          	j	c0021da4 <_vfprintf_r+0x136c>
c0021d98:	ff0d8d93          	addi	s11,s11,-16
c0021d9c:	1db75e63          	bge	a4,s11,c0021f78 <_vfprintf_r+0x1540>
c0021da0:	00148493          	addi	s1,s1,1
c0021da4:	00812783          	lw	a5,8(sp)
c0021da8:	010c8c93          	addi	s9,s9,16
c0021dac:	00e92223          	sw	a4,4(s2)
c0021db0:	00f92023          	sw	a5,0(s2)
c0021db4:	0f912623          	sw	s9,236(sp)
c0021db8:	0e912423          	sw	s1,232(sp)
c0021dbc:	00890913          	addi	s2,s2,8
c0021dc0:	fc9b5ce3          	bge	s6,s1,c0021d98 <_vfprintf_r+0x1360>
c0021dc4:	0e410613          	addi	a2,sp,228
c0021dc8:	000c0593          	mv	a1,s8
c0021dcc:	000d0513          	mv	a0,s10
c0021dd0:	290090ef          	jal	ra,c002b060 <__sprint_r>
c0021dd4:	cc051ae3          	bnez	a0,c0021aa8 <_vfprintf_r+0x1070>
c0021dd8:	0ec12c83          	lw	s9,236(sp)
c0021ddc:	0e812483          	lw	s1,232(sp)
c0021de0:	10c10913          	addi	s2,sp,268
c0021de4:	01000713          	li	a4,16
c0021de8:	fb1ff06f          	j	c0021d98 <_vfprintf_r+0x1360>
c0021dec:	01412683          	lw	a3,20(sp)
c0021df0:	010a7793          	andi	a5,s4,16
c0021df4:	00468713          	addi	a4,a3,4
c0021df8:	14079863          	bnez	a5,c0021f48 <_vfprintf_r+0x1510>
c0021dfc:	040a7793          	andi	a5,s4,64
c0021e00:	6a078063          	beqz	a5,c00224a0 <_vfprintf_r+0x1a68>
c0021e04:	01412783          	lw	a5,20(sp)
c0021e08:	00000913          	li	s2,0
c0021e0c:	00e12a23          	sw	a4,20(sp)
c0021e10:	0007dc83          	lhu	s9,0(a5)
c0021e14:	f7cff06f          	j	c0021590 <_vfprintf_r+0xb58>
c0021e18:	01412683          	lw	a3,20(sp)
c0021e1c:	010a7793          	andi	a5,s4,16
c0021e20:	00468713          	addi	a4,a3,4
c0021e24:	0c079e63          	bnez	a5,c0021f00 <_vfprintf_r+0x14c8>
c0021e28:	040a7793          	andi	a5,s4,64
c0021e2c:	68078863          	beqz	a5,c00224bc <_vfprintf_r+0x1a84>
c0021e30:	01412783          	lw	a5,20(sp)
c0021e34:	00e12a23          	sw	a4,20(sp)
c0021e38:	00079c83          	lh	s9,0(a5)
c0021e3c:	41fcd913          	srai	s2,s9,0x1f
c0021e40:	00090793          	mv	a5,s2
c0021e44:	fc07dc63          	bgez	a5,c002161c <_vfprintf_r+0xbe4>
c0021e48:	019037b3          	snez	a5,s9
c0021e4c:	41200933          	neg	s2,s2
c0021e50:	40f90933          	sub	s2,s2,a5
c0021e54:	02d00793          	li	a5,45
c0021e58:	0cf103a3          	sb	a5,199(sp)
c0021e5c:	41900cb3          	neg	s9,s9
c0021e60:	000a0b93          	mv	s7,s4
c0021e64:	00100793          	li	a5,1
c0021e68:	eacff06f          	j	c0021514 <_vfprintf_r+0xadc>
c0021e6c:	01412703          	lw	a4,20(sp)
c0021e70:	010bf793          	andi	a5,s7,16
c0021e74:	00470693          	addi	a3,a4,4
c0021e78:	0e079063          	bnez	a5,c0021f58 <_vfprintf_r+0x1520>
c0021e7c:	040bf793          	andi	a5,s7,64
c0021e80:	60078063          	beqz	a5,c0022480 <_vfprintf_r+0x1a48>
c0021e84:	01412783          	lw	a5,20(sp)
c0021e88:	00000913          	li	s2,0
c0021e8c:	00d12a23          	sw	a3,20(sp)
c0021e90:	0007dc83          	lhu	s9,0(a5)
c0021e94:	00100793          	li	a5,1
c0021e98:	e78ff06f          	j	c0021510 <_vfprintf_r+0xad8>
c0021e9c:	001a7713          	andi	a4,s4,1
c0021ea0:	00071463          	bnez	a4,c0021ea8 <_vfprintf_r+0x1470>
c0021ea4:	e99fe06f          	j	c0020d3c <_vfprintf_r+0x304>
c0021ea8:	9d5ff06f          	j	c002187c <_vfprintf_r+0xe44>
c0021eac:	000c8893          	mv	a7,s9
c0021eb0:	f40ff06f          	j	c00215f0 <_vfprintf_r+0xbb8>
c0021eb4:	03000793          	li	a5,48
c0021eb8:	1af107a3          	sb	a5,431(sp)
c0021ebc:	1af10b13          	addi	s6,sp,431
c0021ec0:	e7cff06f          	j	c002153c <_vfprintf_r+0xb04>
c0021ec4:	03c12783          	lw	a5,60(sp)
c0021ec8:	00044483          	lbu	s1,0(s0)
c0021ecc:	00079463          	bnez	a5,c0021ed4 <_vfprintf_r+0x149c>
c0021ed0:	d21fe06f          	j	c0020bf0 <_vfprintf_r+0x1b8>
c0021ed4:	0007c783          	lbu	a5,0(a5)
c0021ed8:	00079463          	bnez	a5,c0021ee0 <_vfprintf_r+0x14a8>
c0021edc:	d15fe06f          	j	c0020bf0 <_vfprintf_r+0x1b8>
c0021ee0:	400a6a13          	ori	s4,s4,1024
c0021ee4:	d0dfe06f          	j	c0020bf0 <_vfprintf_r+0x1b8>
c0021ee8:	00c12683          	lw	a3,12(sp)
c0021eec:	00040b13          	mv	s6,s0
c0021ef0:	41f6d793          	srai	a5,a3,0x1f
c0021ef4:	00d72023          	sw	a3,0(a4)
c0021ef8:	00f72223          	sw	a5,4(a4)
c0021efc:	e89fe06f          	j	c0020d84 <_vfprintf_r+0x34c>
c0021f00:	0006ac83          	lw	s9,0(a3)
c0021f04:	00e12a23          	sw	a4,20(sp)
c0021f08:	41fcd913          	srai	s2,s9,0x1f
c0021f0c:	00090793          	mv	a5,s2
c0021f10:	f08ff06f          	j	c0021618 <_vfprintf_r+0xbe0>
c0021f14:	01412703          	lw	a4,20(sp)
c0021f18:	00072783          	lw	a5,0(a4)
c0021f1c:	00470713          	addi	a4,a4,4
c0021f20:	00e12a23          	sw	a4,20(sp)
c0021f24:	0007a603          	lw	a2,0(a5)
c0021f28:	0047a683          	lw	a3,4(a5)
c0021f2c:	0087a703          	lw	a4,8(a5)
c0021f30:	00c7a783          	lw	a5,12(a5)
c0021f34:	0ec12823          	sw	a2,240(sp)
c0021f38:	0ed12a23          	sw	a3,244(sp)
c0021f3c:	0ee12c23          	sw	a4,248(sp)
c0021f40:	0ef12e23          	sw	a5,252(sp)
c0021f44:	fc5fe06f          	j	c0020f08 <_vfprintf_r+0x4d0>
c0021f48:	0006ac83          	lw	s9,0(a3)
c0021f4c:	00000913          	li	s2,0
c0021f50:	00e12a23          	sw	a4,20(sp)
c0021f54:	e3cff06f          	j	c0021590 <_vfprintf_r+0xb58>
c0021f58:	00072c83          	lw	s9,0(a4)
c0021f5c:	00000913          	li	s2,0
c0021f60:	00d12a23          	sw	a3,20(sp)
c0021f64:	00100793          	li	a5,1
c0021f68:	da8ff06f          	j	c0021510 <_vfprintf_r+0xad8>
c0021f6c:	00068493          	mv	s1,a3
c0021f70:	c6904ee3          	bgtz	s1,c0021bec <_vfprintf_r+0x11b4>
c0021f74:	ca1ff06f          	j	c0021c14 <_vfprintf_r+0x11dc>
c0021f78:	00148713          	addi	a4,s1,1
c0021f7c:	00890693          	addi	a3,s2,8
c0021f80:	00812783          	lw	a5,8(sp)
c0021f84:	01bc8cb3          	add	s9,s9,s11
c0021f88:	01b92223          	sw	s11,4(s2)
c0021f8c:	00f92023          	sw	a5,0(s2)
c0021f90:	0f912623          	sw	s9,236(sp)
c0021f94:	0ee12423          	sw	a4,232(sp)
c0021f98:	00700793          	li	a5,7
c0021f9c:	7ae7de63          	bge	a5,a4,c0022758 <_vfprintf_r+0x1d20>
c0021fa0:	0e410613          	addi	a2,sp,228
c0021fa4:	000c0593          	mv	a1,s8
c0021fa8:	000d0513          	mv	a0,s10
c0021fac:	0b4090ef          	jal	ra,c002b060 <__sprint_r>
c0021fb0:	ae051ce3          	bnez	a0,c0021aa8 <_vfprintf_r+0x1070>
c0021fb4:	0e812703          	lw	a4,232(sp)
c0021fb8:	0ec12c83          	lw	s9,236(sp)
c0021fbc:	11410893          	addi	a7,sp,276
c0021fc0:	00170713          	addi	a4,a4,1
c0021fc4:	10c10913          	addi	s2,sp,268
c0021fc8:	ae4ff06f          	j	c00212ac <_vfprintf_r+0x874>
c0021fcc:	000c8893          	mv	a7,s9
c0021fd0:	000a0b93          	mv	s7,s4
c0021fd4:	dd0ff06f          	j	c00215a4 <_vfprintf_r+0xb6c>
c0021fd8:	c80027b7          	lui	a5,0xc8002
c0021fdc:	6e478793          	addi	a5,a5,1764 # c80026e4 <_end+0xfff7de64>
c0021fe0:	000c8893          	mv	a7,s9
c0021fe4:	02f12a23          	sw	a5,52(sp)
c0021fe8:	020a7793          	andi	a5,s4,32
c0021fec:	12078863          	beqz	a5,c002211c <_vfprintf_r+0x16e4>
c0021ff0:	01412783          	lw	a5,20(sp)
c0021ff4:	00778b13          	addi	s6,a5,7
c0021ff8:	ff8b7b13          	andi	s6,s6,-8
c0021ffc:	000b2c83          	lw	s9,0(s6)
c0022000:	004b2903          	lw	s2,4(s6)
c0022004:	008b0793          	addi	a5,s6,8
c0022008:	00f12a23          	sw	a5,20(sp)
c002200c:	001a7793          	andi	a5,s4,1
c0022010:	00078e63          	beqz	a5,c002202c <_vfprintf_r+0x15f4>
c0022014:	012ce7b3          	or	a5,s9,s2
c0022018:	00078a63          	beqz	a5,c002202c <_vfprintf_r+0x15f4>
c002201c:	03000793          	li	a5,48
c0022020:	0cf10423          	sb	a5,200(sp)
c0022024:	0c9104a3          	sb	s1,201(sp)
c0022028:	002a6a13          	ori	s4,s4,2
c002202c:	bffa7b93          	andi	s7,s4,-1025
c0022030:	00200793          	li	a5,2
c0022034:	cdcff06f          	j	c0021510 <_vfprintf_r+0xad8>
c0022038:	000c8893          	mv	a7,s9
c002203c:	d30ff06f          	j	c002156c <_vfprintf_r+0xb34>
c0022040:	00144483          	lbu	s1,1(s0)
c0022044:	020a6a13          	ori	s4,s4,32
c0022048:	00140413          	addi	s0,s0,1
c002204c:	ba5fe06f          	j	c0020bf0 <_vfprintf_r+0x1b8>
c0022050:	0e410613          	addi	a2,sp,228
c0022054:	000c0593          	mv	a1,s8
c0022058:	000d0513          	mv	a0,s10
c002205c:	004090ef          	jal	ra,c002b060 <__sprint_r>
c0022060:	a40514e3          	bnez	a0,c0021aa8 <_vfprintf_r+0x1070>
c0022064:	0ec12783          	lw	a5,236(sp)
c0022068:	10c10893          	addi	a7,sp,268
c002206c:	841ff06f          	j	c00218ac <_vfprintf_r+0xe74>
c0022070:	c80027b7          	lui	a5,0xc8002
c0022074:	6f878793          	addi	a5,a5,1784 # c80026f8 <_end+0xfff7de78>
c0022078:	000c8893          	mv	a7,s9
c002207c:	02f12a23          	sw	a5,52(sp)
c0022080:	f69ff06f          	j	c0021fe8 <_vfprintf_r+0x15b0>
c0022084:	00144483          	lbu	s1,1(s0)
c0022088:	200a6a13          	ori	s4,s4,512
c002208c:	00140413          	addi	s0,s0,1
c0022090:	b61fe06f          	j	c0020bf0 <_vfprintf_r+0x1b8>
c0022094:	00600793          	li	a5,6
c0022098:	000d8c93          	mv	s9,s11
c002209c:	71b7ee63          	bltu	a5,s11,c00227b8 <_vfprintf_r+0x1d80>
c00220a0:	c8002837          	lui	a6,0xc8002
c00220a4:	000c8a93          	mv	s5,s9
c00220a8:	01212a23          	sw	s2,20(sp)
c00220ac:	70c80b13          	addi	s6,a6,1804 # c800270c <_end+0xfff7de8c>
c00220b0:	badfe06f          	j	c0020c5c <_vfprintf_r+0x224>
c00220b4:	01000693          	li	a3,16
c00220b8:	0e812703          	lw	a4,232(sp)
c00220bc:	4496de63          	bge	a3,s1,c0022518 <_vfprintf_r+0x1ae0>
c00220c0:	01000c93          	li	s9,16
c00220c4:	00700d93          	li	s11,7
c00220c8:	00c0006f          	j	c00220d4 <_vfprintf_r+0x169c>
c00220cc:	ff048493          	addi	s1,s1,-16
c00220d0:	449cd463          	bge	s9,s1,c0022518 <_vfprintf_r+0x1ae0>
c00220d4:	00812683          	lw	a3,8(sp)
c00220d8:	01078793          	addi	a5,a5,16
c00220dc:	00170713          	addi	a4,a4,1
c00220e0:	00d8a023          	sw	a3,0(a7)
c00220e4:	0198a223          	sw	s9,4(a7)
c00220e8:	0ef12623          	sw	a5,236(sp)
c00220ec:	0ee12423          	sw	a4,232(sp)
c00220f0:	00888893          	addi	a7,a7,8
c00220f4:	fceddce3          	bge	s11,a4,c00220cc <_vfprintf_r+0x1694>
c00220f8:	0e410613          	addi	a2,sp,228
c00220fc:	000c0593          	mv	a1,s8
c0022100:	000d0513          	mv	a0,s10
c0022104:	75d080ef          	jal	ra,c002b060 <__sprint_r>
c0022108:	9a0510e3          	bnez	a0,c0021aa8 <_vfprintf_r+0x1070>
c002210c:	0ec12783          	lw	a5,236(sp)
c0022110:	0e812703          	lw	a4,232(sp)
c0022114:	10c10893          	addi	a7,sp,268
c0022118:	fb5ff06f          	j	c00220cc <_vfprintf_r+0x1694>
c002211c:	01412683          	lw	a3,20(sp)
c0022120:	010a7793          	andi	a5,s4,16
c0022124:	00468713          	addi	a4,a3,4
c0022128:	1a078c63          	beqz	a5,c00222e0 <_vfprintf_r+0x18a8>
c002212c:	0006ac83          	lw	s9,0(a3)
c0022130:	00000913          	li	s2,0
c0022134:	00e12a23          	sw	a4,20(sp)
c0022138:	ed5ff06f          	j	c002200c <_vfprintf_r+0x15d4>
c002213c:	0e410613          	addi	a2,sp,228
c0022140:	000c0593          	mv	a1,s8
c0022144:	000d0513          	mv	a0,s10
c0022148:	719080ef          	jal	ra,c002b060 <__sprint_r>
c002214c:	94051ee3          	bnez	a0,c0021aa8 <_vfprintf_r+0x1070>
c0022150:	0ec12c83          	lw	s9,236(sp)
c0022154:	0e812483          	lw	s1,232(sp)
c0022158:	10c10913          	addi	s2,sp,268
c002215c:	898ff06f          	j	c00211f4 <_vfprintf_r+0x7bc>
c0022160:	0e410613          	addi	a2,sp,228
c0022164:	000c0593          	mv	a1,s8
c0022168:	000d0513          	mv	a0,s10
c002216c:	6f5080ef          	jal	ra,c002b060 <__sprint_r>
c0022170:	92051ce3          	bnez	a0,c0021aa8 <_vfprintf_r+0x1070>
c0022174:	0ec12c83          	lw	s9,236(sp)
c0022178:	0e812483          	lw	s1,232(sp)
c002217c:	10c10913          	addi	s2,sp,268
c0022180:	8a0ff06f          	j	c0021220 <_vfprintf_r+0x7e8>
c0022184:	1b010b13          	addi	s6,sp,432
c0022188:	00000793          	li	a5,0
c002218c:	00812823          	sw	s0,16(sp)
c0022190:	00912e23          	sw	s1,28(sp)
c0022194:	000b0413          	mv	s0,s6
c0022198:	03312223          	sw	s3,36(sp)
c002219c:	000c0b13          	mv	s6,s8
c00221a0:	000c8493          	mv	s1,s9
c00221a4:	00090993          	mv	s3,s2
c00221a8:	03c12c83          	lw	s9,60(sp)
c00221ac:	400bfa13          	andi	s4,s7,1024
c00221b0:	0ff00a93          	li	s5,255
c00221b4:	00088c13          	mv	s8,a7
c00221b8:	00078913          	mv	s2,a5
c00221bc:	0240006f          	j	c00221e0 <_vfprintf_r+0x17a8>
c00221c0:	00a00613          	li	a2,10
c00221c4:	00000693          	li	a3,0
c00221c8:	00048513          	mv	a0,s1
c00221cc:	00098593          	mv	a1,s3
c00221d0:	4a80b0ef          	jal	ra,c002d678 <__udivdi3>
c00221d4:	56098c63          	beqz	s3,c002274c <_vfprintf_r+0x1d14>
c00221d8:	00050493          	mv	s1,a0
c00221dc:	00058993          	mv	s3,a1
c00221e0:	00a00613          	li	a2,10
c00221e4:	00000693          	li	a3,0
c00221e8:	00048513          	mv	a0,s1
c00221ec:	00098593          	mv	a1,s3
c00221f0:	0bd0b0ef          	jal	ra,c002daac <__umoddi3>
c00221f4:	03050513          	addi	a0,a0,48
c00221f8:	fea40fa3          	sb	a0,-1(s0)
c00221fc:	00190913          	addi	s2,s2,1
c0022200:	fff40413          	addi	s0,s0,-1
c0022204:	fa0a0ee3          	beqz	s4,c00221c0 <_vfprintf_r+0x1788>
c0022208:	000cc683          	lbu	a3,0(s9)
c002220c:	fad91ae3          	bne	s2,a3,c00221c0 <_vfprintf_r+0x1788>
c0022210:	fb5908e3          	beq	s2,s5,c00221c0 <_vfprintf_r+0x1788>
c0022214:	4e099c63          	bnez	s3,c002270c <_vfprintf_r+0x1cd4>
c0022218:	00900793          	li	a5,9
c002221c:	4e97e863          	bltu	a5,s1,c002270c <_vfprintf_r+0x1cd4>
c0022220:	000c0893          	mv	a7,s8
c0022224:	1b010793          	addi	a5,sp,432
c0022228:	000b0c13          	mv	s8,s6
c002222c:	00040b13          	mv	s6,s0
c0022230:	03912e23          	sw	s9,60(sp)
c0022234:	01c12483          	lw	s1,28(sp)
c0022238:	02412983          	lw	s3,36(sp)
c002223c:	01012403          	lw	s0,16(sp)
c0022240:	03212023          	sw	s2,32(sp)
c0022244:	41678cb3          	sub	s9,a5,s6
c0022248:	000b8a13          	mv	s4,s7
c002224c:	af0ff06f          	j	c002153c <_vfprintf_r+0xb04>
c0022250:	0e812703          	lw	a4,232(sp)
c0022254:	c80026b7          	lui	a3,0xc8002
c0022258:	71468693          	addi	a3,a3,1812 # c8002714 <_end+0xfff7de94>
c002225c:	00d8a023          	sw	a3,0(a7)
c0022260:	00178793          	addi	a5,a5,1
c0022264:	00100693          	li	a3,1
c0022268:	00170713          	addi	a4,a4,1
c002226c:	00d8a223          	sw	a3,4(a7)
c0022270:	0ef12623          	sw	a5,236(sp)
c0022274:	0ee12423          	sw	a4,232(sp)
c0022278:	00700693          	li	a3,7
c002227c:	00888893          	addi	a7,a7,8
c0022280:	4ee6c463          	blt	a3,a4,c0022768 <_vfprintf_r+0x1d30>
c0022284:	14061a63          	bnez	a2,c00223d8 <_vfprintf_r+0x19a0>
c0022288:	02012683          	lw	a3,32(sp)
c002228c:	001a7713          	andi	a4,s4,1
c0022290:	00d76733          	or	a4,a4,a3
c0022294:	00071463          	bnez	a4,c002229c <_vfprintf_r+0x1864>
c0022298:	aa5fe06f          	j	c0020d3c <_vfprintf_r+0x304>
c002229c:	03012703          	lw	a4,48(sp)
c00222a0:	02c12683          	lw	a3,44(sp)
c00222a4:	00e8a023          	sw	a4,0(a7)
c00222a8:	0e812703          	lw	a4,232(sp)
c00222ac:	00f687b3          	add	a5,a3,a5
c00222b0:	00d8a223          	sw	a3,4(a7)
c00222b4:	00170713          	addi	a4,a4,1
c00222b8:	0ef12623          	sw	a5,236(sp)
c00222bc:	0ee12423          	sw	a4,232(sp)
c00222c0:	00700693          	li	a3,7
c00222c4:	5ae6c263          	blt	a3,a4,c0022868 <_vfprintf_r+0x1e30>
c00222c8:	00888893          	addi	a7,a7,8
c00222cc:	1400006f          	j	c002240c <_vfprintf_r+0x19d4>
c00222d0:	01012b83          	lw	s7,16(sp)
c00222d4:	00040d13          	mv	s10,s0
c00222d8:	00048c13          	mv	s8,s1
c00222dc:	fd0ff06f          	j	c0021aac <_vfprintf_r+0x1074>
c00222e0:	040a7793          	andi	a5,s4,64
c00222e4:	1e078c63          	beqz	a5,c00224dc <_vfprintf_r+0x1aa4>
c00222e8:	01412783          	lw	a5,20(sp)
c00222ec:	00000913          	li	s2,0
c00222f0:	00e12a23          	sw	a4,20(sp)
c00222f4:	0007dc83          	lhu	s9,0(a5)
c00222f8:	d15ff06f          	j	c002200c <_vfprintf_r+0x15d4>
c00222fc:	0e410613          	addi	a2,sp,228
c0022300:	000c0593          	mv	a1,s8
c0022304:	000d0513          	mv	a0,s10
c0022308:	559080ef          	jal	ra,c002b060 <__sprint_r>
c002230c:	f8051e63          	bnez	a0,c0021aa8 <_vfprintf_r+0x1070>
c0022310:	0ec12783          	lw	a5,236(sp)
c0022314:	10c10893          	addi	a7,sp,268
c0022318:	d58ff06f          	j	c0021870 <_vfprintf_r+0xe38>
c002231c:	00812683          	lw	a3,8(sp)
c0022320:	009787b3          	add	a5,a5,s1
c0022324:	0098a223          	sw	s1,4(a7)
c0022328:	00d8a023          	sw	a3,0(a7)
c002232c:	00170713          	addi	a4,a4,1
c0022330:	0ef12623          	sw	a5,236(sp)
c0022334:	0ee12423          	sw	a4,232(sp)
c0022338:	00700693          	li	a3,7
c002233c:	00e6c463          	blt	a3,a4,c0022344 <_vfprintf_r+0x190c>
c0022340:	9f9fe06f          	j	c0020d38 <_vfprintf_r+0x300>
c0022344:	f8dfe06f          	j	c00212d0 <_vfprintf_r+0x898>
c0022348:	0f012783          	lw	a5,240(sp)
c002234c:	0a010593          	addi	a1,sp,160
c0022350:	0b010513          	addi	a0,sp,176
c0022354:	0af12823          	sw	a5,176(sp)
c0022358:	0f412783          	lw	a5,244(sp)
c002235c:	0a012023          	sw	zero,160(sp)
c0022360:	0a012223          	sw	zero,164(sp)
c0022364:	0af12a23          	sw	a5,180(sp)
c0022368:	0f812783          	lw	a5,248(sp)
c002236c:	0a012423          	sw	zero,168(sp)
c0022370:	0a012623          	sw	zero,172(sp)
c0022374:	0af12c23          	sw	a5,184(sp)
c0022378:	0fc12783          	lw	a5,252(sp)
c002237c:	0af12e23          	sw	a5,188(sp)
c0022380:	1e90c0ef          	jal	ra,c002ed68 <__letf2>
c0022384:	01012883          	lw	a7,16(sp)
c0022388:	2e0544e3          	bltz	a0,c0022e70 <_vfprintf_r+0x2438>
c002238c:	0c714783          	lbu	a5,199(sp)
c0022390:	04700713          	li	a4,71
c0022394:	3e975c63          	bge	a4,s1,c002278c <_vfprintf_r+0x1d54>
c0022398:	c8002837          	lui	a6,0xc8002
c002239c:	6d880b13          	addi	s6,a6,1752 # c80026d8 <_end+0xfff7de58>
c00223a0:	00012823          	sw	zero,16(sp)
c00223a4:	02012423          	sw	zero,40(sp)
c00223a8:	02012223          	sw	zero,36(sp)
c00223ac:	00012e23          	sw	zero,28(sp)
c00223b0:	f7fa7a13          	andi	s4,s4,-129
c00223b4:	00300a93          	li	s5,3
c00223b8:	00300c93          	li	s9,3
c00223bc:	00000d93          	li	s11,0
c00223c0:	88079e63          	bnez	a5,c002145c <_vfprintf_r+0xa24>
c00223c4:	8adfe06f          	j	c0020c70 <_vfprintf_r+0x238>
c00223c8:	00c12783          	lw	a5,12(sp)
c00223cc:	00040b13          	mv	s6,s0
c00223d0:	00f72023          	sw	a5,0(a4)
c00223d4:	9b1fe06f          	j	c0020d84 <_vfprintf_r+0x34c>
c00223d8:	03012703          	lw	a4,48(sp)
c00223dc:	02c12683          	lw	a3,44(sp)
c00223e0:	00888893          	addi	a7,a7,8
c00223e4:	fee8ac23          	sw	a4,-8(a7)
c00223e8:	0e812703          	lw	a4,232(sp)
c00223ec:	00f687b3          	add	a5,a3,a5
c00223f0:	fed8ae23          	sw	a3,-4(a7)
c00223f4:	00170713          	addi	a4,a4,1
c00223f8:	0ef12623          	sw	a5,236(sp)
c00223fc:	0ee12423          	sw	a4,232(sp)
c0022400:	00700693          	li	a3,7
c0022404:	46e6c263          	blt	a3,a4,c0022868 <_vfprintf_r+0x1e30>
c0022408:	360644e3          	bltz	a2,c0022f70 <_vfprintf_r+0x2538>
c002240c:	02012683          	lw	a3,32(sp)
c0022410:	00170713          	addi	a4,a4,1
c0022414:	0168a023          	sw	s6,0(a7)
c0022418:	00f687b3          	add	a5,a3,a5
c002241c:	00d8a223          	sw	a3,4(a7)
c0022420:	0ef12623          	sw	a5,236(sp)
c0022424:	0ee12423          	sw	a4,232(sp)
c0022428:	00700693          	li	a3,7
c002242c:	00e6c463          	blt	a3,a4,c0022434 <_vfprintf_r+0x19fc>
c0022430:	909fe06f          	j	c0020d38 <_vfprintf_r+0x300>
c0022434:	e9dfe06f          	j	c00212d0 <_vfprintf_r+0x898>
c0022438:	000b0513          	mv	a0,s6
c002243c:	05912023          	sw	s9,64(sp)
c0022440:	c29fb0ef          	jal	ra,c001e068 <strlen>
c0022444:	0c714783          	lbu	a5,199(sp)
c0022448:	fff54a93          	not	s5,a0
c002244c:	41fada93          	srai	s5,s5,0x1f
c0022450:	01212a23          	sw	s2,20(sp)
c0022454:	00012823          	sw	zero,16(sp)
c0022458:	02012423          	sw	zero,40(sp)
c002245c:	02012223          	sw	zero,36(sp)
c0022460:	00012e23          	sw	zero,28(sp)
c0022464:	04012883          	lw	a7,64(sp)
c0022468:	00050c93          	mv	s9,a0
c002246c:	01557ab3          	and	s5,a0,s5
c0022470:	00000d93          	li	s11,0
c0022474:	00078463          	beqz	a5,c002247c <_vfprintf_r+0x1a44>
c0022478:	fe5fe06f          	j	c002145c <_vfprintf_r+0xa24>
c002247c:	ff4fe06f          	j	c0020c70 <_vfprintf_r+0x238>
c0022480:	200bf793          	andi	a5,s7,512
c0022484:	3a078663          	beqz	a5,c0022830 <_vfprintf_r+0x1df8>
c0022488:	01412783          	lw	a5,20(sp)
c002248c:	00000913          	li	s2,0
c0022490:	00d12a23          	sw	a3,20(sp)
c0022494:	0007cc83          	lbu	s9,0(a5)
c0022498:	00100793          	li	a5,1
c002249c:	874ff06f          	j	c0021510 <_vfprintf_r+0xad8>
c00224a0:	200a7793          	andi	a5,s4,512
c00224a4:	36078c63          	beqz	a5,c002281c <_vfprintf_r+0x1de4>
c00224a8:	01412783          	lw	a5,20(sp)
c00224ac:	00000913          	li	s2,0
c00224b0:	00e12a23          	sw	a4,20(sp)
c00224b4:	0007cc83          	lbu	s9,0(a5)
c00224b8:	8d8ff06f          	j	c0021590 <_vfprintf_r+0xb58>
c00224bc:	200a7793          	andi	a5,s4,512
c00224c0:	34078263          	beqz	a5,c0022804 <_vfprintf_r+0x1dcc>
c00224c4:	01412783          	lw	a5,20(sp)
c00224c8:	00e12a23          	sw	a4,20(sp)
c00224cc:	00078c83          	lb	s9,0(a5)
c00224d0:	41fcd913          	srai	s2,s9,0x1f
c00224d4:	00090793          	mv	a5,s2
c00224d8:	940ff06f          	j	c0021618 <_vfprintf_r+0xbe0>
c00224dc:	200a7793          	andi	a5,s4,512
c00224e0:	30078863          	beqz	a5,c00227f0 <_vfprintf_r+0x1db8>
c00224e4:	01412783          	lw	a5,20(sp)
c00224e8:	00000913          	li	s2,0
c00224ec:	00e12a23          	sw	a4,20(sp)
c00224f0:	0007cc83          	lbu	s9,0(a5)
c00224f4:	b19ff06f          	j	c002200c <_vfprintf_r+0x15d4>
c00224f8:	0fc12783          	lw	a5,252(sp)
c00224fc:	3407c663          	bltz	a5,c0022848 <_vfprintf_r+0x1e10>
c0022500:	0c714783          	lbu	a5,199(sp)
c0022504:	04700713          	li	a4,71
c0022508:	22975ce3          	bge	a4,s1,c0022f40 <_vfprintf_r+0x2508>
c002250c:	c8002837          	lui	a6,0xc8002
c0022510:	6e080b13          	addi	s6,a6,1760 # c80026e0 <_end+0xfff7de60>
c0022514:	e8dff06f          	j	c00223a0 <_vfprintf_r+0x1968>
c0022518:	00812683          	lw	a3,8(sp)
c002251c:	009787b3          	add	a5,a5,s1
c0022520:	00170713          	addi	a4,a4,1
c0022524:	00d8a023          	sw	a3,0(a7)
c0022528:	0098a223          	sw	s1,4(a7)
c002252c:	0ef12623          	sw	a5,236(sp)
c0022530:	0ee12423          	sw	a4,232(sp)
c0022534:	00700693          	li	a3,7
c0022538:	00888893          	addi	a7,a7,8
c002253c:	eee6d863          	bge	a3,a4,c0021c2c <_vfprintf_r+0x11f4>
c0022540:	0e410613          	addi	a2,sp,228
c0022544:	000c0593          	mv	a1,s8
c0022548:	000d0513          	mv	a0,s10
c002254c:	315080ef          	jal	ra,c002b060 <__sprint_r>
c0022550:	d4051c63          	bnez	a0,c0021aa8 <_vfprintf_r+0x1070>
c0022554:	0ec12783          	lw	a5,236(sp)
c0022558:	10c10893          	addi	a7,sp,268
c002255c:	ed0ff06f          	j	c0021c2c <_vfprintf_r+0x11f4>
c0022560:	02012703          	lw	a4,32(sp)
c0022564:	02412c83          	lw	s9,36(sp)
c0022568:	01412e23          	sw	s4,28(sp)
c002256c:	04812023          	sw	s0,64(sp)
c0022570:	05312223          	sw	s3,68(sp)
c0022574:	03512223          	sw	s5,36(sp)
c0022578:	02812983          	lw	s3,40(sp)
c002257c:	03612423          	sw	s6,40(sp)
c0022580:	00eb0bb3          	add	s7,s6,a4
c0022584:	03c12403          	lw	s0,60(sp)
c0022588:	04812a03          	lw	s4,72(sp)
c002258c:	04c12a83          	lw	s5,76(sp)
c0022590:	00700493          	li	s1,7
c0022594:	01000913          	li	s2,16
c0022598:	000c0b13          	mv	s6,s8
c002259c:	080c8863          	beqz	s9,c002262c <_vfprintf_r+0x1bf4>
c00225a0:	08099863          	bnez	s3,c0022630 <_vfprintf_r+0x1bf8>
c00225a4:	fff40413          	addi	s0,s0,-1
c00225a8:	fffc8c93          	addi	s9,s9,-1
c00225ac:	0e812703          	lw	a4,232(sp)
c00225b0:	014787b3          	add	a5,a5,s4
c00225b4:	0158a023          	sw	s5,0(a7)
c00225b8:	00170713          	addi	a4,a4,1
c00225bc:	0148a223          	sw	s4,4(a7)
c00225c0:	0ef12623          	sw	a5,236(sp)
c00225c4:	0ee12423          	sw	a4,232(sp)
c00225c8:	00888893          	addi	a7,a7,8
c00225cc:	0ee4ce63          	blt	s1,a4,c00226c8 <_vfprintf_r+0x1c90>
c00225d0:	00044683          	lbu	a3,0(s0)
c00225d4:	41bb8633          	sub	a2,s7,s11
c00225d8:	00068c13          	mv	s8,a3
c00225dc:	00d65463          	bge	a2,a3,c00225e4 <_vfprintf_r+0x1bac>
c00225e0:	00060c13          	mv	s8,a2
c00225e4:	03805663          	blez	s8,c0022610 <_vfprintf_r+0x1bd8>
c00225e8:	0e812683          	lw	a3,232(sp)
c00225ec:	018787b3          	add	a5,a5,s8
c00225f0:	01b8a023          	sw	s11,0(a7)
c00225f4:	00168693          	addi	a3,a3,1
c00225f8:	0188a223          	sw	s8,4(a7)
c00225fc:	0ef12623          	sw	a5,236(sp)
c0022600:	0ed12423          	sw	a3,232(sp)
c0022604:	0ed4c263          	blt	s1,a3,c00226e8 <_vfprintf_r+0x1cb0>
c0022608:	00044683          	lbu	a3,0(s0)
c002260c:	00888893          	addi	a7,a7,8
c0022610:	fffc4613          	not	a2,s8
c0022614:	41f65613          	srai	a2,a2,0x1f
c0022618:	00cc7733          	and	a4,s8,a2
c002261c:	40e68c33          	sub	s8,a3,a4
c0022620:	01804c63          	bgtz	s8,c0022638 <_vfprintf_r+0x1c00>
c0022624:	00dd8db3          	add	s11,s11,a3
c0022628:	f60c9ce3          	bnez	s9,c00225a0 <_vfprintf_r+0x1b68>
c002262c:	5e098c63          	beqz	s3,c0022c24 <_vfprintf_r+0x21ec>
c0022630:	fff98993          	addi	s3,s3,-1
c0022634:	f79ff06f          	j	c00225ac <_vfprintf_r+0x1b74>
c0022638:	0e812683          	lw	a3,232(sp)
c002263c:	01894863          	blt	s2,s8,c002264c <_vfprintf_r+0x1c14>
c0022640:	0580006f          	j	c0022698 <_vfprintf_r+0x1c60>
c0022644:	ff0c0c13          	addi	s8,s8,-16
c0022648:	05895863          	bge	s2,s8,c0022698 <_vfprintf_r+0x1c60>
c002264c:	00812703          	lw	a4,8(sp)
c0022650:	01078793          	addi	a5,a5,16
c0022654:	00168693          	addi	a3,a3,1
c0022658:	00e8a023          	sw	a4,0(a7)
c002265c:	0128a223          	sw	s2,4(a7)
c0022660:	0ef12623          	sw	a5,236(sp)
c0022664:	0ed12423          	sw	a3,232(sp)
c0022668:	00888893          	addi	a7,a7,8
c002266c:	fcd4dce3          	bge	s1,a3,c0022644 <_vfprintf_r+0x1c0c>
c0022670:	0e410613          	addi	a2,sp,228
c0022674:	000b0593          	mv	a1,s6
c0022678:	000d0513          	mv	a0,s10
c002267c:	1e5080ef          	jal	ra,c002b060 <__sprint_r>
c0022680:	66051063          	bnez	a0,c0022ce0 <_vfprintf_r+0x22a8>
c0022684:	ff0c0c13          	addi	s8,s8,-16
c0022688:	0ec12783          	lw	a5,236(sp)
c002268c:	0e812683          	lw	a3,232(sp)
c0022690:	10c10893          	addi	a7,sp,268
c0022694:	fb894ce3          	blt	s2,s8,c002264c <_vfprintf_r+0x1c14>
c0022698:	00812703          	lw	a4,8(sp)
c002269c:	018787b3          	add	a5,a5,s8
c00226a0:	00168693          	addi	a3,a3,1
c00226a4:	00e8a023          	sw	a4,0(a7)
c00226a8:	0188a223          	sw	s8,4(a7)
c00226ac:	0ef12623          	sw	a5,236(sp)
c00226b0:	0ed12423          	sw	a3,232(sp)
c00226b4:	64d4ca63          	blt	s1,a3,c0022d08 <_vfprintf_r+0x22d0>
c00226b8:	00044683          	lbu	a3,0(s0)
c00226bc:	00888893          	addi	a7,a7,8
c00226c0:	00dd8db3          	add	s11,s11,a3
c00226c4:	f65ff06f          	j	c0022628 <_vfprintf_r+0x1bf0>
c00226c8:	0e410613          	addi	a2,sp,228
c00226cc:	000b0593          	mv	a1,s6
c00226d0:	000d0513          	mv	a0,s10
c00226d4:	18d080ef          	jal	ra,c002b060 <__sprint_r>
c00226d8:	60051463          	bnez	a0,c0022ce0 <_vfprintf_r+0x22a8>
c00226dc:	0ec12783          	lw	a5,236(sp)
c00226e0:	10c10893          	addi	a7,sp,268
c00226e4:	eedff06f          	j	c00225d0 <_vfprintf_r+0x1b98>
c00226e8:	0e410613          	addi	a2,sp,228
c00226ec:	000b0593          	mv	a1,s6
c00226f0:	000d0513          	mv	a0,s10
c00226f4:	16d080ef          	jal	ra,c002b060 <__sprint_r>
c00226f8:	5e051463          	bnez	a0,c0022ce0 <_vfprintf_r+0x22a8>
c00226fc:	00044683          	lbu	a3,0(s0)
c0022700:	0ec12783          	lw	a5,236(sp)
c0022704:	10c10893          	addi	a7,sp,268
c0022708:	f09ff06f          	j	c0022610 <_vfprintf_r+0x1bd8>
c002270c:	04812783          	lw	a5,72(sp)
c0022710:	04c12583          	lw	a1,76(sp)
c0022714:	00000913          	li	s2,0
c0022718:	40f40433          	sub	s0,s0,a5
c002271c:	00078613          	mv	a2,a5
c0022720:	00040513          	mv	a0,s0
c0022724:	520070ef          	jal	ra,c0029c44 <strncpy>
c0022728:	001cc583          	lbu	a1,1(s9)
c002272c:	00a00613          	li	a2,10
c0022730:	00000693          	li	a3,0
c0022734:	00b03833          	snez	a6,a1
c0022738:	00048513          	mv	a0,s1
c002273c:	00098593          	mv	a1,s3
c0022740:	010c8cb3          	add	s9,s9,a6
c0022744:	7350a0ef          	jal	ra,c002d678 <__udivdi3>
c0022748:	a91ff06f          	j	c00221d8 <_vfprintf_r+0x17a0>
c002274c:	00900793          	li	a5,9
c0022750:	a897e4e3          	bltu	a5,s1,c00221d8 <_vfprintf_r+0x17a0>
c0022754:	acdff06f          	j	c0022220 <_vfprintf_r+0x17e8>
c0022758:	00170713          	addi	a4,a4,1
c002275c:	00868893          	addi	a7,a3,8
c0022760:	00068913          	mv	s2,a3
c0022764:	b49fe06f          	j	c00212ac <_vfprintf_r+0x874>
c0022768:	0e410613          	addi	a2,sp,228
c002276c:	000c0593          	mv	a1,s8
c0022770:	000d0513          	mv	a0,s10
c0022774:	0ed080ef          	jal	ra,c002b060 <__sprint_r>
c0022778:	b2051863          	bnez	a0,c0021aa8 <_vfprintf_r+0x1070>
c002277c:	0cc12603          	lw	a2,204(sp)
c0022780:	0ec12783          	lw	a5,236(sp)
c0022784:	10c10893          	addi	a7,sp,268
c0022788:	afdff06f          	j	c0022284 <_vfprintf_r+0x184c>
c002278c:	c8002837          	lui	a6,0xc8002
c0022790:	6d480b13          	addi	s6,a6,1748 # c80026d4 <_end+0xfff7de54>
c0022794:	c0dff06f          	j	c00223a0 <_vfprintf_r+0x1968>
c0022798:	0e410613          	addi	a2,sp,228
c002279c:	000c0593          	mv	a1,s8
c00227a0:	000d0513          	mv	a0,s10
c00227a4:	0bd080ef          	jal	ra,c002b060 <__sprint_r>
c00227a8:	b0051063          	bnez	a0,c0021aa8 <_vfprintf_r+0x1070>
c00227ac:	0ec12783          	lw	a5,236(sp)
c00227b0:	10c10893          	addi	a7,sp,268
c00227b4:	c60ff06f          	j	c0021c14 <_vfprintf_r+0x11dc>
c00227b8:	00600c93          	li	s9,6
c00227bc:	8e5ff06f          	j	c00220a0 <_vfprintf_r+0x1668>
c00227c0:	02012703          	lw	a4,32(sp)
c00227c4:	00eb0833          	add	a6,s6,a4
c00227c8:	409704b3          	sub	s1,a4,s1
c00227cc:	41b806b3          	sub	a3,a6,s11
c00227d0:	00048913          	mv	s2,s1
c00227d4:	ce96de63          	bge	a3,s1,c0021cd0 <_vfprintf_r+0x1298>
c00227d8:	00068913          	mv	s2,a3
c00227dc:	cf4ff06f          	j	c0021cd0 <_vfprintf_r+0x1298>
c00227e0:	00c12783          	lw	a5,12(sp)
c00227e4:	00040b13          	mv	s6,s0
c00227e8:	00f71023          	sh	a5,0(a4)
c00227ec:	d98fe06f          	j	c0020d84 <_vfprintf_r+0x34c>
c00227f0:	01412783          	lw	a5,20(sp)
c00227f4:	00000913          	li	s2,0
c00227f8:	00e12a23          	sw	a4,20(sp)
c00227fc:	0007ac83          	lw	s9,0(a5)
c0022800:	80dff06f          	j	c002200c <_vfprintf_r+0x15d4>
c0022804:	01412783          	lw	a5,20(sp)
c0022808:	00e12a23          	sw	a4,20(sp)
c002280c:	0007ac83          	lw	s9,0(a5)
c0022810:	41fcd913          	srai	s2,s9,0x1f
c0022814:	00090793          	mv	a5,s2
c0022818:	e01fe06f          	j	c0021618 <_vfprintf_r+0xbe0>
c002281c:	01412783          	lw	a5,20(sp)
c0022820:	00000913          	li	s2,0
c0022824:	00e12a23          	sw	a4,20(sp)
c0022828:	0007ac83          	lw	s9,0(a5)
c002282c:	d65fe06f          	j	c0021590 <_vfprintf_r+0xb58>
c0022830:	01412783          	lw	a5,20(sp)
c0022834:	00000913          	li	s2,0
c0022838:	00d12a23          	sw	a3,20(sp)
c002283c:	0007ac83          	lw	s9,0(a5)
c0022840:	00100793          	li	a5,1
c0022844:	ccdfe06f          	j	c0021510 <_vfprintf_r+0xad8>
c0022848:	02d00793          	li	a5,45
c002284c:	0cf103a3          	sb	a5,199(sp)
c0022850:	cb5ff06f          	j	c0022504 <_vfprintf_r+0x1acc>
c0022854:	0e410613          	addi	a2,sp,228
c0022858:	000c0593          	mv	a1,s8
c002285c:	000d0513          	mv	a0,s10
c0022860:	001080ef          	jal	ra,c002b060 <__sprint_r>
c0022864:	d34fe06f          	j	c0020d98 <_vfprintf_r+0x360>
c0022868:	0e410613          	addi	a2,sp,228
c002286c:	000c0593          	mv	a1,s8
c0022870:	000d0513          	mv	a0,s10
c0022874:	7ec080ef          	jal	ra,c002b060 <__sprint_r>
c0022878:	a2051863          	bnez	a0,c0021aa8 <_vfprintf_r+0x1070>
c002287c:	0cc12603          	lw	a2,204(sp)
c0022880:	0ec12783          	lw	a5,236(sp)
c0022884:	0e812703          	lw	a4,232(sp)
c0022888:	10c10893          	addi	a7,sp,268
c002288c:	b7dff06f          	j	c0022408 <_vfprintf_r+0x19d0>
c0022890:	03000793          	li	a5,48
c0022894:	0cf10423          	sb	a5,200(sp)
c0022898:	05800793          	li	a5,88
c002289c:	002a6713          	ori	a4,s4,2
c00228a0:	0cf104a3          	sb	a5,201(sp)
c00228a4:	04e12823          	sw	a4,80(sp)
c00228a8:	06300793          	li	a5,99
c00228ac:	00012823          	sw	zero,16(sp)
c00228b0:	14c10b13          	addi	s6,sp,332
c00228b4:	7bb7c263          	blt	a5,s11,c0023058 <_vfprintf_r+0x2620>
c00228b8:	0fc12b83          	lw	s7,252(sp)
c00228bc:	fdf4f793          	andi	a5,s1,-33
c00228c0:	02f12423          	sw	a5,40(sp)
c00228c4:	04012c23          	sw	zero,88(sp)
c00228c8:	0f012e03          	lw	t3,240(sp)
c00228cc:	0f412e83          	lw	t4,244(sp)
c00228d0:	0f812f03          	lw	t5,248(sp)
c00228d4:	102a6a13          	ori	s4,s4,258
c00228d8:	400bce63          	bltz	s7,c0022cf4 <_vfprintf_r+0x22bc>
c00228dc:	06100793          	li	a5,97
c00228e0:	14f484e3          	beq	s1,a5,c0023228 <_vfprintf_r+0x27f0>
c00228e4:	04100793          	li	a5,65
c00228e8:	00f48463          	beq	s1,a5,c00228f0 <_vfprintf_r+0x1eb8>
c00228ec:	eacfe06f          	j	c0020f98 <_vfprintf_r+0x560>
c00228f0:	0b010a93          	addi	s5,sp,176
c00228f4:	000a8513          	mv	a0,s5
c00228f8:	05112a23          	sw	a7,84(sp)
c00228fc:	0bc12823          	sw	t3,176(sp)
c0022900:	0bd12a23          	sw	t4,180(sp)
c0022904:	0be12c23          	sw	t5,184(sp)
c0022908:	0b712e23          	sw	s7,188(sp)
c002290c:	7190e0ef          	jal	ra,c0031824 <__trunctfdf2>
c0022910:	0cc10613          	addi	a2,sp,204
c0022914:	7ad060ef          	jal	ra,c00298c0 <frexp>
c0022918:	00058613          	mv	a2,a1
c002291c:	00050593          	mv	a1,a0
c0022920:	000a8513          	mv	a0,s5
c0022924:	5090e0ef          	jal	ra,c003162c <__extenddftf2>
c0022928:	0b012783          	lw	a5,176(sp)
c002292c:	0a010c93          	addi	s9,sp,160
c0022930:	09010913          	addi	s2,sp,144
c0022934:	08f12823          	sw	a5,144(sp)
c0022938:	0b412783          	lw	a5,180(sp)
c002293c:	08010613          	addi	a2,sp,128
c0022940:	00090593          	mv	a1,s2
c0022944:	08f12a23          	sw	a5,148(sp)
c0022948:	0b812783          	lw	a5,184(sp)
c002294c:	000c8513          	mv	a0,s9
c0022950:	04c12023          	sw	a2,64(sp)
c0022954:	08f12c23          	sw	a5,152(sp)
c0022958:	0bc12783          	lw	a5,188(sp)
c002295c:	08012023          	sw	zero,128(sp)
c0022960:	08012223          	sw	zero,132(sp)
c0022964:	08f12e23          	sw	a5,156(sp)
c0022968:	3ffc07b7          	lui	a5,0x3ffc0
c002296c:	08f12623          	sw	a5,140(sp)
c0022970:	08012423          	sw	zero,136(sp)
c0022974:	5380c0ef          	jal	ra,c002eeac <__multf3>
c0022978:	0a012683          	lw	a3,160(sp)
c002297c:	0a412e03          	lw	t3,164(sp)
c0022980:	0a812e83          	lw	t4,168(sp)
c0022984:	0ac12f03          	lw	t5,172(sp)
c0022988:	000c8593          	mv	a1,s9
c002298c:	000a8513          	mv	a0,s5
c0022990:	0ad12823          	sw	a3,176(sp)
c0022994:	04d12223          	sw	a3,68(sp)
c0022998:	0bc12a23          	sw	t3,180(sp)
c002299c:	03c12223          	sw	t3,36(sp)
c00229a0:	0bd12c23          	sw	t4,184(sp)
c00229a4:	03d12023          	sw	t4,32(sp)
c00229a8:	0be12e23          	sw	t5,188(sp)
c00229ac:	01e12e23          	sw	t5,28(sp)
c00229b0:	0a012023          	sw	zero,160(sp)
c00229b4:	0a012223          	sw	zero,164(sp)
c00229b8:	0a012423          	sw	zero,168(sp)
c00229bc:	0a012623          	sw	zero,172(sp)
c00229c0:	1980c0ef          	jal	ra,c002eb58 <__eqtf2>
c00229c4:	01c12f03          	lw	t5,28(sp)
c00229c8:	02012e83          	lw	t4,32(sp)
c00229cc:	02412e03          	lw	t3,36(sp)
c00229d0:	04412683          	lw	a3,68(sp)
c00229d4:	05412883          	lw	a7,84(sp)
c00229d8:	00051663          	bnez	a0,c00229e4 <_vfprintf_r+0x1fac>
c00229dc:	00100793          	li	a5,1
c00229e0:	0cf12623          	sw	a5,204(sp)
c00229e4:	c80027b7          	lui	a5,0xc8002
c00229e8:	6f878793          	addi	a5,a5,1784 # c80026f8 <_end+0xfff7de78>
c00229ec:	02f12223          	sw	a5,36(sp)
c00229f0:	fffd8713          	addi	a4,s11,-1
c00229f4:	05412e23          	sw	s4,92(sp)
c00229f8:	06912223          	sw	s1,100(sp)
c00229fc:	07b12623          	sw	s11,108(sp)
c0022a00:	07a12a23          	sw	s10,116(sp)
c0022a04:	07812c23          	sw	s8,120(sp)
c0022a08:	06812023          	sw	s0,96(sp)
c0022a0c:	07312423          	sw	s3,104(sp)
c0022a10:	07112823          	sw	a7,112(sp)
c0022a14:	000b0c13          	mv	s8,s6
c0022a18:	00070b93          	mv	s7,a4
c0022a1c:	07612e23          	sw	s6,124(sp)
c0022a20:	00068d13          	mv	s10,a3
c0022a24:	000e0d93          	mv	s11,t3
c0022a28:	000e8493          	mv	s1,t4
c0022a2c:	000f0a13          	mv	s4,t5
c0022a30:	0480006f          	j	c0022a78 <_vfprintf_r+0x2040>
c0022a34:	000c8593          	mv	a1,s9
c0022a38:	000a8513          	mv	a0,s5
c0022a3c:	02c12023          	sw	a2,32(sp)
c0022a40:	01f12e23          	sw	t6,28(sp)
c0022a44:	0bf12c23          	sw	t6,184(sp)
c0022a48:	0ac12e23          	sw	a2,188(sp)
c0022a4c:	0b612823          	sw	s6,176(sp)
c0022a50:	0b312a23          	sw	s3,180(sp)
c0022a54:	0a012023          	sw	zero,160(sp)
c0022a58:	0a012223          	sw	zero,164(sp)
c0022a5c:	0a012423          	sw	zero,168(sp)
c0022a60:	0a012623          	sw	zero,172(sp)
c0022a64:	0f40c0ef          	jal	ra,c002eb58 <__eqtf2>
c0022a68:	fffb8b93          	addi	s7,s7,-1
c0022a6c:	00048f93          	mv	t6,s1
c0022a70:	000a0613          	mv	a2,s4
c0022a74:	0e050263          	beqz	a0,c0022b58 <_vfprintf_r+0x2120>
c0022a78:	400307b7          	lui	a5,0x40030
c0022a7c:	00090613          	mv	a2,s2
c0022a80:	000c8593          	mv	a1,s9
c0022a84:	000a8513          	mv	a0,s5
c0022a88:	08f12e23          	sw	a5,156(sp)
c0022a8c:	0ba12023          	sw	s10,160(sp)
c0022a90:	0bb12223          	sw	s11,164(sp)
c0022a94:	0a912423          	sw	s1,168(sp)
c0022a98:	0b412623          	sw	s4,172(sp)
c0022a9c:	08012823          	sw	zero,144(sp)
c0022aa0:	08012a23          	sw	zero,148(sp)
c0022aa4:	08012c23          	sw	zero,152(sp)
c0022aa8:	4040c0ef          	jal	ra,c002eeac <__multf3>
c0022aac:	000a8513          	mv	a0,s5
c0022ab0:	1150e0ef          	jal	ra,c00313c4 <__fixtfsi>
c0022ab4:	00050593          	mv	a1,a0
c0022ab8:	00050413          	mv	s0,a0
c0022abc:	000a8513          	mv	a0,s5
c0022ac0:	0b012983          	lw	s3,176(sp)
c0022ac4:	0b412483          	lw	s1,180(sp)
c0022ac8:	0b812b03          	lw	s6,184(sp)
c0022acc:	0bc12a03          	lw	s4,188(sp)
c0022ad0:	2090e0ef          	jal	ra,c00314d8 <__floatsitf>
c0022ad4:	0b012683          	lw	a3,176(sp)
c0022ad8:	04012603          	lw	a2,64(sp)
c0022adc:	00090593          	mv	a1,s2
c0022ae0:	08d12023          	sw	a3,128(sp)
c0022ae4:	0b412683          	lw	a3,180(sp)
c0022ae8:	000c8513          	mv	a0,s9
c0022aec:	09312823          	sw	s3,144(sp)
c0022af0:	08d12223          	sw	a3,132(sp)
c0022af4:	0b812683          	lw	a3,184(sp)
c0022af8:	08912a23          	sw	s1,148(sp)
c0022afc:	09612c23          	sw	s6,152(sp)
c0022b00:	08d12423          	sw	a3,136(sp)
c0022b04:	0bc12683          	lw	a3,188(sp)
c0022b08:	09412e23          	sw	s4,156(sp)
c0022b0c:	08d12623          	sw	a3,140(sp)
c0022b10:	38c0d0ef          	jal	ra,c002fe9c <__subtf3>
c0022b14:	02412783          	lw	a5,36(sp)
c0022b18:	0a012b03          	lw	s6,160(sp)
c0022b1c:	0a412983          	lw	s3,164(sp)
c0022b20:	008786b3          	add	a3,a5,s0
c0022b24:	0006c683          	lbu	a3,0(a3)
c0022b28:	0a812f83          	lw	t6,168(sp)
c0022b2c:	0ac12603          	lw	a2,172(sp)
c0022b30:	05812a23          	sw	s8,84(sp)
c0022b34:	00dc0023          	sb	a3,0(s8)
c0022b38:	05712223          	sw	s7,68(sp)
c0022b3c:	fff00793          	li	a5,-1
c0022b40:	001c0c13          	addi	s8,s8,1
c0022b44:	000b0d13          	mv	s10,s6
c0022b48:	00098d93          	mv	s11,s3
c0022b4c:	000f8493          	mv	s1,t6
c0022b50:	00060a13          	mv	s4,a2
c0022b54:	eefb90e3          	bne	s7,a5,c0022a34 <_vfprintf_r+0x1ffc>
c0022b58:	07012883          	lw	a7,112(sp)
c0022b5c:	000b0393          	mv	t2,s6
c0022b60:	00098293          	mv	t0,s3
c0022b64:	3ffe0937          	lui	s2,0x3ffe0
c0022b68:	000c8593          	mv	a1,s9
c0022b6c:	000a8513          	mv	a0,s5
c0022b70:	03112023          	sw	a7,32(sp)
c0022b74:	00812e23          	sw	s0,28(sp)
c0022b78:	05c12a03          	lw	s4,92(sp)
c0022b7c:	06412483          	lw	s1,100(sp)
c0022b80:	06012403          	lw	s0,96(sp)
c0022b84:	0a712823          	sw	t2,176(sp)
c0022b88:	06712223          	sw	t2,100(sp)
c0022b8c:	0a512a23          	sw	t0,180(sp)
c0022b90:	06512023          	sw	t0,96(sp)
c0022b94:	0bf12c23          	sw	t6,184(sp)
c0022b98:	05f12e23          	sw	t6,92(sp)
c0022b9c:	0ac12e23          	sw	a2,188(sp)
c0022ba0:	04c12023          	sw	a2,64(sp)
c0022ba4:	0a012023          	sw	zero,160(sp)
c0022ba8:	0a012223          	sw	zero,164(sp)
c0022bac:	0a012423          	sw	zero,168(sp)
c0022bb0:	0b212623          	sw	s2,172(sp)
c0022bb4:	0700c0ef          	jal	ra,c002ec24 <__getf2>
c0022bb8:	000c0b93          	mv	s7,s8
c0022bbc:	06c12d83          	lw	s11,108(sp)
c0022bc0:	07412d03          	lw	s10,116(sp)
c0022bc4:	07812c03          	lw	s8,120(sp)
c0022bc8:	07c12b03          	lw	s6,124(sp)
c0022bcc:	06812983          	lw	s3,104(sp)
c0022bd0:	02012883          	lw	a7,32(sp)
c0022bd4:	4aa04463          	bgtz	a0,c002307c <_vfprintf_r+0x2644>
c0022bd8:	000c8593          	mv	a1,s9
c0022bdc:	000a8513          	mv	a0,s5
c0022be0:	7790b0ef          	jal	ra,c002eb58 <__eqtf2>
c0022be4:	02012883          	lw	a7,32(sp)
c0022be8:	00051863          	bnez	a0,c0022bf8 <_vfprintf_r+0x21c0>
c0022bec:	01c12783          	lw	a5,28(sp)
c0022bf0:	0017fc93          	andi	s9,a5,1
c0022bf4:	480c9463          	bnez	s9,c002307c <_vfprintf_r+0x2644>
c0022bf8:	04412783          	lw	a5,68(sp)
c0022bfc:	03000693          	li	a3,48
c0022c00:	00178713          	addi	a4,a5,1 # 40030001 <_DMEM_LENGTH+0x3f830001>
c0022c04:	00eb8733          	add	a4,s7,a4
c0022c08:	0007c863          	bltz	a5,c0022c18 <_vfprintf_r+0x21e0>
c0022c0c:	001b8b93          	addi	s7,s7,1
c0022c10:	fedb8fa3          	sb	a3,-1(s7)
c0022c14:	ff771ce3          	bne	a4,s7,c0022c0c <_vfprintf_r+0x21d4>
c0022c18:	416b87b3          	sub	a5,s7,s6
c0022c1c:	02f12023          	sw	a5,32(sp)
c0022c20:	c18fe06f          	j	c0021038 <_vfprintf_r+0x600>
c0022c24:	02012703          	lw	a4,32(sp)
c0022c28:	000b0c13          	mv	s8,s6
c0022c2c:	02812b03          	lw	s6,40(sp)
c0022c30:	02812e23          	sw	s0,60(sp)
c0022c34:	01c12a03          	lw	s4,28(sp)
c0022c38:	00eb0733          	add	a4,s6,a4
c0022c3c:	04012403          	lw	s0,64(sp)
c0022c40:	04412983          	lw	s3,68(sp)
c0022c44:	02412a83          	lw	s5,36(sp)
c0022c48:	01b76463          	bltu	a4,s11,c0022c50 <_vfprintf_r+0x2218>
c0022c4c:	ff1fe06f          	j	c0021c3c <_vfprintf_r+0x1204>
c0022c50:	00070d93          	mv	s11,a4
c0022c54:	fe9fe06f          	j	c0021c3c <_vfprintf_r+0x1204>
c0022c58:	01c12703          	lw	a4,28(sp)
c0022c5c:	ffd00793          	li	a5,-3
c0022c60:	00f74463          	blt	a4,a5,c0022c68 <_vfprintf_r+0x2230>
c0022c64:	02edd463          	bge	s11,a4,c0022c8c <_vfprintf_r+0x2254>
c0022c68:	ffe48493          	addi	s1,s1,-2
c0022c6c:	fdf4f793          	andi	a5,s1,-33
c0022c70:	02f12423          	sw	a5,40(sp)
c0022c74:	becfe06f          	j	c0021060 <_vfprintf_r+0x628>
c0022c78:	0c714783          	lbu	a5,199(sp)
c0022c7c:	00000d93          	li	s11,0
c0022c80:	00078463          	beqz	a5,c0022c88 <_vfprintf_r+0x2250>
c0022c84:	fd8fe06f          	j	c002145c <_vfprintf_r+0xa24>
c0022c88:	fe9fd06f          	j	c0020c70 <_vfprintf_r+0x238>
c0022c8c:	01c12703          	lw	a4,28(sp)
c0022c90:	02012783          	lw	a5,32(sp)
c0022c94:	26f74c63          	blt	a4,a5,c0022f0c <_vfprintf_r+0x24d4>
c0022c98:	05012783          	lw	a5,80(sp)
c0022c9c:	00070c93          	mv	s9,a4
c0022ca0:	0017f793          	andi	a5,a5,1
c0022ca4:	00078663          	beqz	a5,c0022cb0 <_vfprintf_r+0x2278>
c0022ca8:	02c12783          	lw	a5,44(sp)
c0022cac:	00f70cb3          	add	s9,a4,a5
c0022cb0:	05012783          	lw	a5,80(sp)
c0022cb4:	4007f793          	andi	a5,a5,1024
c0022cb8:	00078663          	beqz	a5,c0022cc4 <_vfprintf_r+0x228c>
c0022cbc:	01c12783          	lw	a5,28(sp)
c0022cc0:	4af04c63          	bgtz	a5,c0023178 <_vfprintf_r+0x2740>
c0022cc4:	fffcca93          	not	s5,s9
c0022cc8:	41fada93          	srai	s5,s5,0x1f
c0022ccc:	015cfab3          	and	s5,s9,s5
c0022cd0:	06700493          	li	s1,103
c0022cd4:	02012423          	sw	zero,40(sp)
c0022cd8:	02012223          	sw	zero,36(sp)
c0022cdc:	ca0fe06f          	j	c002117c <_vfprintf_r+0x744>
c0022ce0:	01012b83          	lw	s7,16(sp)
c0022ce4:	000b0c13          	mv	s8,s6
c0022ce8:	dc5fe06f          	j	c0021aac <_vfprintf_r+0x1074>
c0022cec:	00012823          	sw	zero,16(sp)
c0022cf0:	00078a13          	mv	s4,a5
c0022cf4:	800007b7          	lui	a5,0x80000
c0022cf8:	0177cbb3          	xor	s7,a5,s7
c0022cfc:	02d00793          	li	a5,45
c0022d00:	04f12c23          	sw	a5,88(sp)
c0022d04:	bd9ff06f          	j	c00228dc <_vfprintf_r+0x1ea4>
c0022d08:	0e410613          	addi	a2,sp,228
c0022d0c:	000b0593          	mv	a1,s6
c0022d10:	000d0513          	mv	a0,s10
c0022d14:	34c080ef          	jal	ra,c002b060 <__sprint_r>
c0022d18:	fc0514e3          	bnez	a0,c0022ce0 <_vfprintf_r+0x22a8>
c0022d1c:	00044683          	lbu	a3,0(s0)
c0022d20:	0ec12783          	lw	a5,236(sp)
c0022d24:	10c10893          	addi	a7,sp,268
c0022d28:	00dd8db3          	add	s11,s11,a3
c0022d2c:	8fdff06f          	j	c0022628 <_vfprintf_r+0x1bf0>
c0022d30:	0b010a93          	addi	s5,sp,176
c0022d34:	0d010793          	addi	a5,sp,208
c0022d38:	0cc10713          	addi	a4,sp,204
c0022d3c:	0dc10813          	addi	a6,sp,220
c0022d40:	000d8693          	mv	a3,s11
c0022d44:	00300613          	li	a2,3
c0022d48:	000a8593          	mv	a1,s5
c0022d4c:	000d0513          	mv	a0,s10
c0022d50:	05112023          	sw	a7,64(sp)
c0022d54:	0bc12823          	sw	t3,176(sp)
c0022d58:	03c12223          	sw	t3,36(sp)
c0022d5c:	0bd12a23          	sw	t4,180(sp)
c0022d60:	03d12023          	sw	t4,32(sp)
c0022d64:	0be12c23          	sw	t5,184(sp)
c0022d68:	01e12e23          	sw	t5,28(sp)
c0022d6c:	0b712e23          	sw	s7,188(sp)
c0022d70:	2d0030ef          	jal	ra,c0026040 <_ldtoa_r>
c0022d74:	00054703          	lbu	a4,0(a0)
c0022d78:	03000793          	li	a5,48
c0022d7c:	01c12f03          	lw	t5,28(sp)
c0022d80:	02012e83          	lw	t4,32(sp)
c0022d84:	02412e03          	lw	t3,36(sp)
c0022d88:	04012883          	lw	a7,64(sp)
c0022d8c:	00050b13          	mv	s6,a0
c0022d90:	0a010c93          	addi	s9,sp,160
c0022d94:	06f70c63          	beq	a4,a5,c0022e0c <_vfprintf_r+0x23d4>
c0022d98:	0cc12783          	lw	a5,204(sp)
c0022d9c:	01b787b3          	add	a5,a5,s11
c0022da0:	00fb0933          	add	s2,s6,a5
c0022da4:	000c8593          	mv	a1,s9
c0022da8:	000a8513          	mv	a0,s5
c0022dac:	01112e23          	sw	a7,28(sp)
c0022db0:	0bc12823          	sw	t3,176(sp)
c0022db4:	0bd12a23          	sw	t4,180(sp)
c0022db8:	0be12c23          	sw	t5,184(sp)
c0022dbc:	0b712e23          	sw	s7,188(sp)
c0022dc0:	0a012023          	sw	zero,160(sp)
c0022dc4:	0a012223          	sw	zero,164(sp)
c0022dc8:	0a012423          	sw	zero,168(sp)
c0022dcc:	0a012623          	sw	zero,172(sp)
c0022dd0:	5890b0ef          	jal	ra,c002eb58 <__eqtf2>
c0022dd4:	01c12883          	lw	a7,28(sp)
c0022dd8:	00090693          	mv	a3,s2
c0022ddc:	00051463          	bnez	a0,c0022de4 <_vfprintf_r+0x23ac>
c0022de0:	a50fe06f          	j	c0021030 <_vfprintf_r+0x5f8>
c0022de4:	0dc12683          	lw	a3,220(sp)
c0022de8:	0126e463          	bltu	a3,s2,c0022df0 <_vfprintf_r+0x23b8>
c0022dec:	a44fe06f          	j	c0021030 <_vfprintf_r+0x5f8>
c0022df0:	03000713          	li	a4,48
c0022df4:	00168793          	addi	a5,a3,1
c0022df8:	0cf12e23          	sw	a5,220(sp)
c0022dfc:	00e68023          	sb	a4,0(a3)
c0022e00:	0dc12683          	lw	a3,220(sp)
c0022e04:	ff26e8e3          	bltu	a3,s2,c0022df4 <_vfprintf_r+0x23bc>
c0022e08:	a28fe06f          	j	c0021030 <_vfprintf_r+0x5f8>
c0022e0c:	0a010c93          	addi	s9,sp,160
c0022e10:	000c8593          	mv	a1,s9
c0022e14:	000a8513          	mv	a0,s5
c0022e18:	05112023          	sw	a7,64(sp)
c0022e1c:	0bc12823          	sw	t3,176(sp)
c0022e20:	03c12223          	sw	t3,36(sp)
c0022e24:	0bd12a23          	sw	t4,180(sp)
c0022e28:	03d12023          	sw	t4,32(sp)
c0022e2c:	0be12c23          	sw	t5,184(sp)
c0022e30:	01e12e23          	sw	t5,28(sp)
c0022e34:	0b712e23          	sw	s7,188(sp)
c0022e38:	0a012023          	sw	zero,160(sp)
c0022e3c:	0a012223          	sw	zero,164(sp)
c0022e40:	0a012423          	sw	zero,168(sp)
c0022e44:	0a012623          	sw	zero,172(sp)
c0022e48:	5110b0ef          	jal	ra,c002eb58 <__eqtf2>
c0022e4c:	01c12f03          	lw	t5,28(sp)
c0022e50:	02012e83          	lw	t4,32(sp)
c0022e54:	02412e03          	lw	t3,36(sp)
c0022e58:	04012883          	lw	a7,64(sp)
c0022e5c:	f2050ee3          	beqz	a0,c0022d98 <_vfprintf_r+0x2360>
c0022e60:	00100793          	li	a5,1
c0022e64:	41b787b3          	sub	a5,a5,s11
c0022e68:	0cf12623          	sw	a5,204(sp)
c0022e6c:	f31ff06f          	j	c0022d9c <_vfprintf_r+0x2364>
c0022e70:	02d00793          	li	a5,45
c0022e74:	0cf103a3          	sb	a5,199(sp)
c0022e78:	d18ff06f          	j	c0022390 <_vfprintf_r+0x1958>
c0022e7c:	0e410613          	addi	a2,sp,228
c0022e80:	000c0593          	mv	a1,s8
c0022e84:	000d0513          	mv	a0,s10
c0022e88:	1d8080ef          	jal	ra,c002b060 <__sprint_r>
c0022e8c:	00050463          	beqz	a0,c0022e94 <_vfprintf_r+0x245c>
c0022e90:	c19fe06f          	j	c0021aa8 <_vfprintf_r+0x1070>
c0022e94:	0cc12483          	lw	s1,204(sp)
c0022e98:	0ec12783          	lw	a5,236(sp)
c0022e9c:	10c10893          	addi	a7,sp,268
c0022ea0:	de5fe06f          	j	c0021c84 <_vfprintf_r+0x124c>
c0022ea4:	c8002637          	lui	a2,0xc8002
c0022ea8:	d6460e93          	addi	t4,a2,-668 # c8001d64 <_end+0xfff7d4e4>
c0022eac:	cc1fe06f          	j	c0021b6c <_vfprintf_r+0x1134>
c0022eb0:	0c714783          	lbu	a5,199(sp)
c0022eb4:	01212a23          	sw	s2,20(sp)
c0022eb8:	02012423          	sw	zero,40(sp)
c0022ebc:	02012223          	sw	zero,36(sp)
c0022ec0:	00012e23          	sw	zero,28(sp)
c0022ec4:	000d8a93          	mv	s5,s11
c0022ec8:	000d8c93          	mv	s9,s11
c0022ecc:	00000d93          	li	s11,0
c0022ed0:	00078463          	beqz	a5,c0022ed8 <_vfprintf_r+0x24a0>
c0022ed4:	d88fe06f          	j	c002145c <_vfprintf_r+0xa24>
c0022ed8:	d99fd06f          	j	c0020c70 <_vfprintf_r+0x238>
c0022edc:	0e410613          	addi	a2,sp,228
c0022ee0:	000c0593          	mv	a1,s8
c0022ee4:	000d0513          	mv	a0,s10
c0022ee8:	178080ef          	jal	ra,c002b060 <__sprint_r>
c0022eec:	00050463          	beqz	a0,c0022ef4 <_vfprintf_r+0x24bc>
c0022ef0:	bb9fe06f          	j	c0021aa8 <_vfprintf_r+0x1070>
c0022ef4:	0cc12483          	lw	s1,204(sp)
c0022ef8:	02012703          	lw	a4,32(sp)
c0022efc:	0ec12783          	lw	a5,236(sp)
c0022f00:	10c10893          	addi	a7,sp,268
c0022f04:	409704b3          	sub	s1,a4,s1
c0022f08:	dc9fe06f          	j	c0021cd0 <_vfprintf_r+0x1298>
c0022f0c:	02012783          	lw	a5,32(sp)
c0022f10:	02c12703          	lw	a4,44(sp)
c0022f14:	06700493          	li	s1,103
c0022f18:	00e78cb3          	add	s9,a5,a4
c0022f1c:	01c12783          	lw	a5,28(sp)
c0022f20:	40f05663          	blez	a5,c002332c <_vfprintf_r+0x28f4>
c0022f24:	05012783          	lw	a5,80(sp)
c0022f28:	4007f793          	andi	a5,a5,1024
c0022f2c:	24079863          	bnez	a5,c002317c <_vfprintf_r+0x2744>
c0022f30:	fffcca93          	not	s5,s9
c0022f34:	41fada93          	srai	s5,s5,0x1f
c0022f38:	015cfab3          	and	s5,s9,s5
c0022f3c:	d99ff06f          	j	c0022cd4 <_vfprintf_r+0x229c>
c0022f40:	c8002837          	lui	a6,0xc8002
c0022f44:	6dc80b13          	addi	s6,a6,1756 # c80026dc <_end+0xfff7de5c>
c0022f48:	c58ff06f          	j	c00223a0 <_vfprintf_r+0x1968>
c0022f4c:	05012783          	lw	a5,80(sp)
c0022f50:	01c12703          	lw	a4,28(sp)
c0022f54:	0017f793          	andi	a5,a5,1
c0022f58:	01b7e7b3          	or	a5,a5,s11
c0022f5c:	3ee05e63          	blez	a4,c0023358 <_vfprintf_r+0x2920>
c0022f60:	20079263          	bnez	a5,c0023164 <_vfprintf_r+0x272c>
c0022f64:	01c12c83          	lw	s9,28(sp)
c0022f68:	06600493          	li	s1,102
c0022f6c:	fb9ff06f          	j	c0022f24 <_vfprintf_r+0x24ec>
c0022f70:	ff000693          	li	a3,-16
c0022f74:	40c004b3          	neg	s1,a2
c0022f78:	08d65a63          	bge	a2,a3,c002300c <_vfprintf_r+0x25d4>
c0022f7c:	01000913          	li	s2,16
c0022f80:	00700c93          	li	s9,7
c0022f84:	00c0006f          	j	c0022f90 <_vfprintf_r+0x2558>
c0022f88:	ff048493          	addi	s1,s1,-16
c0022f8c:	08995063          	bge	s2,s1,c002300c <_vfprintf_r+0x25d4>
c0022f90:	00812683          	lw	a3,8(sp)
c0022f94:	01078793          	addi	a5,a5,16 # 80000010 <_end+0xb7f7b790>
c0022f98:	00170713          	addi	a4,a4,1
c0022f9c:	00d8a023          	sw	a3,0(a7)
c0022fa0:	0128a223          	sw	s2,4(a7)
c0022fa4:	0ef12623          	sw	a5,236(sp)
c0022fa8:	0ee12423          	sw	a4,232(sp)
c0022fac:	00888893          	addi	a7,a7,8
c0022fb0:	fcecdce3          	bge	s9,a4,c0022f88 <_vfprintf_r+0x2550>
c0022fb4:	0e410613          	addi	a2,sp,228
c0022fb8:	000c0593          	mv	a1,s8
c0022fbc:	000d0513          	mv	a0,s10
c0022fc0:	0a0080ef          	jal	ra,c002b060 <__sprint_r>
c0022fc4:	00050463          	beqz	a0,c0022fcc <_vfprintf_r+0x2594>
c0022fc8:	ae1fe06f          	j	c0021aa8 <_vfprintf_r+0x1070>
c0022fcc:	0ec12783          	lw	a5,236(sp)
c0022fd0:	0e812703          	lw	a4,232(sp)
c0022fd4:	10c10893          	addi	a7,sp,268
c0022fd8:	fb1ff06f          	j	c0022f88 <_vfprintf_r+0x2550>
c0022fdc:	fff00793          	li	a5,-1
c0022fe0:	00f12623          	sw	a5,12(sp)
c0022fe4:	dc5fd06f          	j	c0020da8 <_vfprintf_r+0x370>
c0022fe8:	c80026b7          	lui	a3,0xc8002
c0022fec:	d6468e93          	addi	t4,a3,-668 # c8001d64 <_end+0xfff7d4e4>
c0022ff0:	b7cfe06f          	j	c002136c <_vfprintf_r+0x934>
c0022ff4:	000a0b93          	mv	s7,s4
c0022ff8:	e60fe06f          	j	c0021658 <_vfprintf_r+0xc20>
c0022ffc:	03000793          	li	a5,48
c0023000:	0cf10423          	sb	a5,200(sp)
c0023004:	07800793          	li	a5,120
c0023008:	895ff06f          	j	c002289c <_vfprintf_r+0x1e64>
c002300c:	00812683          	lw	a3,8(sp)
c0023010:	009787b3          	add	a5,a5,s1
c0023014:	00170713          	addi	a4,a4,1
c0023018:	00d8a023          	sw	a3,0(a7)
c002301c:	0098a223          	sw	s1,4(a7)
c0023020:	0ef12623          	sw	a5,236(sp)
c0023024:	0ee12423          	sw	a4,232(sp)
c0023028:	00700693          	li	a3,7
c002302c:	a8e6de63          	bge	a3,a4,c00222c8 <_vfprintf_r+0x1890>
c0023030:	0e410613          	addi	a2,sp,228
c0023034:	000c0593          	mv	a1,s8
c0023038:	000d0513          	mv	a0,s10
c002303c:	024080ef          	jal	ra,c002b060 <__sprint_r>
c0023040:	00050463          	beqz	a0,c0023048 <_vfprintf_r+0x2610>
c0023044:	a65fe06f          	j	c0021aa8 <_vfprintf_r+0x1070>
c0023048:	0ec12783          	lw	a5,236(sp)
c002304c:	0e812703          	lw	a4,232(sp)
c0023050:	10c10893          	addi	a7,sp,268
c0023054:	bb8ff06f          	j	c002240c <_vfprintf_r+0x19d4>
c0023058:	001d8593          	addi	a1,s11,1
c002305c:	000d0513          	mv	a0,s10
c0023060:	01112823          	sw	a7,16(sp)
c0023064:	668040ef          	jal	ra,c00276cc <_malloc_r>
c0023068:	01012883          	lw	a7,16(sp)
c002306c:	00050b13          	mv	s6,a0
c0023070:	36050463          	beqz	a0,c00233d8 <_vfprintf_r+0x29a0>
c0023074:	00a12823          	sw	a0,16(sp)
c0023078:	841ff06f          	j	c00228b8 <_vfprintf_r+0x1e80>
c002307c:	05412783          	lw	a5,84(sp)
c0023080:	000b8713          	mv	a4,s7
c0023084:	0cf12e23          	sw	a5,220(sp)
c0023088:	02412783          	lw	a5,36(sp)
c002308c:	fffbc683          	lbu	a3,-1(s7)
c0023090:	00f7c603          	lbu	a2,15(a5)
c0023094:	02c69063          	bne	a3,a2,c00230b4 <_vfprintf_r+0x267c>
c0023098:	03000593          	li	a1,48
c002309c:	feb70fa3          	sb	a1,-1(a4)
c00230a0:	0dc12703          	lw	a4,220(sp)
c00230a4:	fff70793          	addi	a5,a4,-1
c00230a8:	0cf12e23          	sw	a5,220(sp)
c00230ac:	fff74683          	lbu	a3,-1(a4)
c00230b0:	fed606e3          	beq	a2,a3,c002309c <_vfprintf_r+0x2664>
c00230b4:	00168613          	addi	a2,a3,1
c00230b8:	03900593          	li	a1,57
c00230bc:	0ff67613          	andi	a2,a2,255
c00230c0:	00b68663          	beq	a3,a1,c00230cc <_vfprintf_r+0x2694>
c00230c4:	fec70fa3          	sb	a2,-1(a4)
c00230c8:	b51ff06f          	j	c0022c18 <_vfprintf_r+0x21e0>
c00230cc:	02412783          	lw	a5,36(sp)
c00230d0:	00a7c603          	lbu	a2,10(a5)
c00230d4:	fec70fa3          	sb	a2,-1(a4)
c00230d8:	b41ff06f          	j	c0022c18 <_vfprintf_r+0x21e0>
c00230dc:	001d8913          	addi	s2,s11,1
c00230e0:	0b010a93          	addi	s5,sp,176
c00230e4:	0dc10813          	addi	a6,sp,220
c00230e8:	0d010793          	addi	a5,sp,208
c00230ec:	0cc10713          	addi	a4,sp,204
c00230f0:	00090693          	mv	a3,s2
c00230f4:	00200613          	li	a2,2
c00230f8:	000a8593          	mv	a1,s5
c00230fc:	000d0513          	mv	a0,s10
c0023100:	0bc12823          	sw	t3,176(sp)
c0023104:	03c12223          	sw	t3,36(sp)
c0023108:	0bd12a23          	sw	t4,180(sp)
c002310c:	03d12023          	sw	t4,32(sp)
c0023110:	0be12c23          	sw	t5,184(sp)
c0023114:	01e12e23          	sw	t5,28(sp)
c0023118:	0b712e23          	sw	s7,188(sp)
c002311c:	725020ef          	jal	ra,c0026040 <_ldtoa_r>
c0023120:	01c12f03          	lw	t5,28(sp)
c0023124:	02012e83          	lw	t4,32(sp)
c0023128:	02412e03          	lw	t3,36(sp)
c002312c:	04012883          	lw	a7,64(sp)
c0023130:	00050b13          	mv	s6,a0
c0023134:	012b0933          	add	s2,s6,s2
c0023138:	0a010c93          	addi	s9,sp,160
c002313c:	c69ff06f          	j	c0022da4 <_vfprintf_r+0x236c>
c0023140:	01bb0933          	add	s2,s6,s11
c0023144:	0a010c93          	addi	s9,sp,160
c0023148:	c5dff06f          	j	c0022da4 <_vfprintf_r+0x236c>
c002314c:	000d8463          	beqz	s11,c0023154 <_vfprintf_r+0x271c>
c0023150:	e1dfd06f          	j	c0020f6c <_vfprintf_r+0x534>
c0023154:	00100d93          	li	s11,1
c0023158:	e15fd06f          	j	c0020f6c <_vfprintf_r+0x534>
c002315c:	00600d93          	li	s11,6
c0023160:	e0dfd06f          	j	c0020f6c <_vfprintf_r+0x534>
c0023164:	02c12783          	lw	a5,44(sp)
c0023168:	06600493          	li	s1,102
c002316c:	00f70cb3          	add	s9,a4,a5
c0023170:	01bc8cb3          	add	s9,s9,s11
c0023174:	db1ff06f          	j	c0022f24 <_vfprintf_r+0x24ec>
c0023178:	06700493          	li	s1,103
c002317c:	03c12603          	lw	a2,60(sp)
c0023180:	0ff00713          	li	a4,255
c0023184:	00064783          	lbu	a5,0(a2)
c0023188:	22e78863          	beq	a5,a4,c00233b8 <_vfprintf_r+0x2980>
c002318c:	01c12683          	lw	a3,28(sp)
c0023190:	00000513          	li	a0,0
c0023194:	00000593          	li	a1,0
c0023198:	00d7de63          	bge	a5,a3,c00231b4 <_vfprintf_r+0x277c>
c002319c:	40f686b3          	sub	a3,a3,a5
c00231a0:	00164783          	lbu	a5,1(a2)
c00231a4:	04078463          	beqz	a5,c00231ec <_vfprintf_r+0x27b4>
c00231a8:	00158593          	addi	a1,a1,1
c00231ac:	00160613          	addi	a2,a2,1
c00231b0:	fee794e3          	bne	a5,a4,c0023198 <_vfprintf_r+0x2760>
c00231b4:	00d12e23          	sw	a3,28(sp)
c00231b8:	02c12e23          	sw	a2,60(sp)
c00231bc:	02b12223          	sw	a1,36(sp)
c00231c0:	02a12423          	sw	a0,40(sp)
c00231c4:	02812703          	lw	a4,40(sp)
c00231c8:	02412783          	lw	a5,36(sp)
c00231cc:	00e787b3          	add	a5,a5,a4
c00231d0:	04812703          	lw	a4,72(sp)
c00231d4:	02e787b3          	mul	a5,a5,a4
c00231d8:	01978cb3          	add	s9,a5,s9
c00231dc:	fffcca93          	not	s5,s9
c00231e0:	41fada93          	srai	s5,s5,0x1f
c00231e4:	015cfab3          	and	s5,s9,s5
c00231e8:	f95fd06f          	j	c002117c <_vfprintf_r+0x744>
c00231ec:	00064783          	lbu	a5,0(a2)
c00231f0:	00150513          	addi	a0,a0,1
c00231f4:	fbdff06f          	j	c00231b0 <_vfprintf_r+0x2778>
c00231f8:	0d610713          	addi	a4,sp,214
c00231fc:	00069863          	bnez	a3,c002320c <_vfprintf_r+0x27d4>
c0023200:	03000713          	li	a4,48
c0023204:	0ce10b23          	sb	a4,214(sp)
c0023208:	0d710713          	addi	a4,sp,215
c002320c:	1b010693          	addi	a3,sp,432
c0023210:	03078793          	addi	a5,a5,48
c0023214:	40d706b3          	sub	a3,a4,a3
c0023218:	00f70023          	sb	a5,0(a4)
c002321c:	0dd68793          	addi	a5,a3,221
c0023220:	02f12c23          	sw	a5,56(sp)
c0023224:	f15fd06f          	j	c0021138 <_vfprintf_r+0x700>
c0023228:	0b010a93          	addi	s5,sp,176
c002322c:	000a8513          	mv	a0,s5
c0023230:	05112a23          	sw	a7,84(sp)
c0023234:	0bc12823          	sw	t3,176(sp)
c0023238:	0bd12a23          	sw	t4,180(sp)
c002323c:	0be12c23          	sw	t5,184(sp)
c0023240:	0b712e23          	sw	s7,188(sp)
c0023244:	5e00e0ef          	jal	ra,c0031824 <__trunctfdf2>
c0023248:	0cc10613          	addi	a2,sp,204
c002324c:	674060ef          	jal	ra,c00298c0 <frexp>
c0023250:	00058613          	mv	a2,a1
c0023254:	00050593          	mv	a1,a0
c0023258:	000a8513          	mv	a0,s5
c002325c:	3d00e0ef          	jal	ra,c003162c <__extenddftf2>
c0023260:	0b012783          	lw	a5,176(sp)
c0023264:	0a010c93          	addi	s9,sp,160
c0023268:	09010913          	addi	s2,sp,144
c002326c:	08f12823          	sw	a5,144(sp)
c0023270:	0b412783          	lw	a5,180(sp)
c0023274:	08010613          	addi	a2,sp,128
c0023278:	00090593          	mv	a1,s2
c002327c:	08f12a23          	sw	a5,148(sp)
c0023280:	0b812783          	lw	a5,184(sp)
c0023284:	000c8513          	mv	a0,s9
c0023288:	04c12023          	sw	a2,64(sp)
c002328c:	08f12c23          	sw	a5,152(sp)
c0023290:	0bc12783          	lw	a5,188(sp)
c0023294:	08012023          	sw	zero,128(sp)
c0023298:	08012223          	sw	zero,132(sp)
c002329c:	08f12e23          	sw	a5,156(sp)
c00232a0:	3ffc07b7          	lui	a5,0x3ffc0
c00232a4:	08f12623          	sw	a5,140(sp)
c00232a8:	08012423          	sw	zero,136(sp)
c00232ac:	4010b0ef          	jal	ra,c002eeac <__multf3>
c00232b0:	0a012683          	lw	a3,160(sp)
c00232b4:	0a412e03          	lw	t3,164(sp)
c00232b8:	0a812e83          	lw	t4,168(sp)
c00232bc:	0ac12f03          	lw	t5,172(sp)
c00232c0:	000c8593          	mv	a1,s9
c00232c4:	000a8513          	mv	a0,s5
c00232c8:	0ad12823          	sw	a3,176(sp)
c00232cc:	04d12223          	sw	a3,68(sp)
c00232d0:	0bc12a23          	sw	t3,180(sp)
c00232d4:	03c12223          	sw	t3,36(sp)
c00232d8:	0bd12c23          	sw	t4,184(sp)
c00232dc:	03d12023          	sw	t4,32(sp)
c00232e0:	0be12e23          	sw	t5,188(sp)
c00232e4:	01e12e23          	sw	t5,28(sp)
c00232e8:	0a012023          	sw	zero,160(sp)
c00232ec:	0a012223          	sw	zero,164(sp)
c00232f0:	0a012423          	sw	zero,168(sp)
c00232f4:	0a012623          	sw	zero,172(sp)
c00232f8:	0610b0ef          	jal	ra,c002eb58 <__eqtf2>
c00232fc:	01c12f03          	lw	t5,28(sp)
c0023300:	02012e83          	lw	t4,32(sp)
c0023304:	02412e03          	lw	t3,36(sp)
c0023308:	04412683          	lw	a3,68(sp)
c002330c:	05412883          	lw	a7,84(sp)
c0023310:	00051663          	bnez	a0,c002331c <_vfprintf_r+0x28e4>
c0023314:	00100793          	li	a5,1
c0023318:	0cf12623          	sw	a5,204(sp)
c002331c:	c80027b7          	lui	a5,0xc8002
c0023320:	6e478793          	addi	a5,a5,1764 # c80026e4 <_end+0xfff7de64>
c0023324:	02f12223          	sw	a5,36(sp)
c0023328:	ec8ff06f          	j	c00229f0 <_vfprintf_r+0x1fb8>
c002332c:	40fc8cb3          	sub	s9,s9,a5
c0023330:	001c8c93          	addi	s9,s9,1
c0023334:	fffcca93          	not	s5,s9
c0023338:	41fada93          	srai	s5,s5,0x1f
c002333c:	015cfab3          	and	s5,s9,s5
c0023340:	995ff06f          	j	c0022cd4 <_vfprintf_r+0x229c>
c0023344:	05012783          	lw	a5,80(sp)
c0023348:	0017f793          	andi	a5,a5,1
c002334c:	00079463          	bnez	a5,c0023354 <_vfprintf_r+0x291c>
c0023350:	e09fd06f          	j	c0021158 <_vfprintf_r+0x720>
c0023354:	dfdfd06f          	j	c0021150 <_vfprintf_r+0x718>
c0023358:	00079a63          	bnez	a5,c002336c <_vfprintf_r+0x2934>
c002335c:	00100a93          	li	s5,1
c0023360:	06600493          	li	s1,102
c0023364:	00100c93          	li	s9,1
c0023368:	96dff06f          	j	c0022cd4 <_vfprintf_r+0x229c>
c002336c:	02c12783          	lw	a5,44(sp)
c0023370:	06600493          	li	s1,102
c0023374:	00178c93          	addi	s9,a5,1
c0023378:	01bc8cb3          	add	s9,s9,s11
c002337c:	fffcca93          	not	s5,s9
c0023380:	41fada93          	srai	s5,s5,0x1f
c0023384:	015cfab3          	and	s5,s9,s5
c0023388:	94dff06f          	j	c0022cd4 <_vfprintf_r+0x229c>
c002338c:	00088693          	mv	a3,a7
c0023390:	bf1fe06f          	j	c0021f80 <_vfprintf_r+0x1548>
c0023394:	01412783          	lw	a5,20(sp)
c0023398:	0007ad83          	lw	s11,0(a5)
c002339c:	00478793          	addi	a5,a5,4
c00233a0:	000dd463          	bgez	s11,c00233a8 <_vfprintf_r+0x2970>
c00233a4:	fff00d93          	li	s11,-1
c00233a8:	00144483          	lbu	s1,1(s0)
c00233ac:	00f12a23          	sw	a5,20(sp)
c00233b0:	00070413          	mv	s0,a4
c00233b4:	83dfd06f          	j	c0020bf0 <_vfprintf_r+0x1b8>
c00233b8:	02012423          	sw	zero,40(sp)
c00233bc:	02012223          	sw	zero,36(sp)
c00233c0:	e05ff06f          	j	c00231c4 <_vfprintf_r+0x278c>
c00233c4:	00200793          	li	a5,2
c00233c8:	02f12c23          	sw	a5,56(sp)
c00233cc:	d6dfd06f          	j	c0021138 <_vfprintf_r+0x700>
c00233d0:	000d8913          	mv	s2,s11
c00233d4:	d61ff06f          	j	c0023134 <_vfprintf_r+0x26fc>
c00233d8:	00cc5783          	lhu	a5,12(s8)
c00233dc:	0407e793          	ori	a5,a5,64
c00233e0:	00fc1623          	sh	a5,12(s8)
c00233e4:	9b5fd06f          	j	c0020d98 <_vfprintf_r+0x360>

c00233e8 <vfprintf>:
c00233e8:	c8003737          	lui	a4,0xc8003
c00233ec:	00050793          	mv	a5,a0
c00233f0:	98c72503          	lw	a0,-1652(a4) # c800298c <_end+0xfff7e10c>
c00233f4:	00060693          	mv	a3,a2
c00233f8:	00058613          	mv	a2,a1
c00233fc:	00078593          	mv	a1,a5
c0023400:	e38fd06f          	j	c0020a38 <_vfprintf_r>

c0023404 <__sbprintf>:
c0023404:	00c5d783          	lhu	a5,12(a1)
c0023408:	0645ae03          	lw	t3,100(a1)
c002340c:	00e5d303          	lhu	t1,14(a1)
c0023410:	01c5a883          	lw	a7,28(a1)
c0023414:	0245a803          	lw	a6,36(a1)
c0023418:	b8010113          	addi	sp,sp,-1152
c002341c:	ffd7f793          	andi	a5,a5,-3
c0023420:	40000713          	li	a4,1024
c0023424:	46812c23          	sw	s0,1144(sp)
c0023428:	00f11a23          	sh	a5,20(sp)
c002342c:	00058413          	mv	s0,a1
c0023430:	07010793          	addi	a5,sp,112
c0023434:	00810593          	addi	a1,sp,8
c0023438:	46912a23          	sw	s1,1140(sp)
c002343c:	47212823          	sw	s2,1136(sp)
c0023440:	46112e23          	sw	ra,1148(sp)
c0023444:	00050913          	mv	s2,a0
c0023448:	07c12623          	sw	t3,108(sp)
c002344c:	00611b23          	sh	t1,22(sp)
c0023450:	03112223          	sw	a7,36(sp)
c0023454:	03012623          	sw	a6,44(sp)
c0023458:	00f12423          	sw	a5,8(sp)
c002345c:	00f12c23          	sw	a5,24(sp)
c0023460:	00e12823          	sw	a4,16(sp)
c0023464:	00e12e23          	sw	a4,28(sp)
c0023468:	02012023          	sw	zero,32(sp)
c002346c:	dccfd0ef          	jal	ra,c0020a38 <_vfprintf_r>
c0023470:	00050493          	mv	s1,a0
c0023474:	02055c63          	bgez	a0,c00234ac <__sbprintf+0xa8>
c0023478:	01415783          	lhu	a5,20(sp)
c002347c:	0407f793          	andi	a5,a5,64
c0023480:	00078863          	beqz	a5,c0023490 <__sbprintf+0x8c>
c0023484:	00c45783          	lhu	a5,12(s0)
c0023488:	0407e793          	ori	a5,a5,64
c002348c:	00f41623          	sh	a5,12(s0)
c0023490:	47c12083          	lw	ra,1148(sp)
c0023494:	47812403          	lw	s0,1144(sp)
c0023498:	47012903          	lw	s2,1136(sp)
c002349c:	00048513          	mv	a0,s1
c00234a0:	47412483          	lw	s1,1140(sp)
c00234a4:	48010113          	addi	sp,sp,1152
c00234a8:	00008067          	ret
c00234ac:	00810593          	addi	a1,sp,8
c00234b0:	00090513          	mv	a0,s2
c00234b4:	3e0000ef          	jal	ra,c0023894 <_fflush_r>
c00234b8:	fc0500e3          	beqz	a0,c0023478 <__sbprintf+0x74>
c00234bc:	fff00493          	li	s1,-1
c00234c0:	fb9ff06f          	j	c0023478 <__sbprintf+0x74>

c00234c4 <__swsetup_r>:
c00234c4:	c80037b7          	lui	a5,0xc8003
c00234c8:	98c7a783          	lw	a5,-1652(a5) # c800298c <_end+0xfff7e10c>
c00234cc:	ff010113          	addi	sp,sp,-16
c00234d0:	00812423          	sw	s0,8(sp)
c00234d4:	00912223          	sw	s1,4(sp)
c00234d8:	00112623          	sw	ra,12(sp)
c00234dc:	00050493          	mv	s1,a0
c00234e0:	00058413          	mv	s0,a1
c00234e4:	00078663          	beqz	a5,c00234f0 <__swsetup_r+0x2c>
c00234e8:	0387a703          	lw	a4,56(a5)
c00234ec:	08070463          	beqz	a4,c0023574 <__swsetup_r+0xb0>
c00234f0:	00c41703          	lh	a4,12(s0)
c00234f4:	01071793          	slli	a5,a4,0x10
c00234f8:	00877693          	andi	a3,a4,8
c00234fc:	0107d793          	srli	a5,a5,0x10
c0023500:	08068863          	beqz	a3,c0023590 <__swsetup_r+0xcc>
c0023504:	01042683          	lw	a3,16(s0)
c0023508:	0a068863          	beqz	a3,c00235b8 <__swsetup_r+0xf4>
c002350c:	0017f613          	andi	a2,a5,1
c0023510:	02060863          	beqz	a2,c0023540 <__swsetup_r+0x7c>
c0023514:	01442603          	lw	a2,20(s0)
c0023518:	00042423          	sw	zero,8(s0)
c002351c:	00000513          	li	a0,0
c0023520:	40c00633          	neg	a2,a2
c0023524:	00c42c23          	sw	a2,24(s0)
c0023528:	02068a63          	beqz	a3,c002355c <__swsetup_r+0x98>
c002352c:	00c12083          	lw	ra,12(sp)
c0023530:	00812403          	lw	s0,8(sp)
c0023534:	00412483          	lw	s1,4(sp)
c0023538:	01010113          	addi	sp,sp,16
c002353c:	00008067          	ret
c0023540:	0027f613          	andi	a2,a5,2
c0023544:	00000593          	li	a1,0
c0023548:	00061463          	bnez	a2,c0023550 <__swsetup_r+0x8c>
c002354c:	01442583          	lw	a1,20(s0)
c0023550:	00b42423          	sw	a1,8(s0)
c0023554:	00000513          	li	a0,0
c0023558:	fc069ae3          	bnez	a3,c002352c <__swsetup_r+0x68>
c002355c:	0807f793          	andi	a5,a5,128
c0023560:	fc0786e3          	beqz	a5,c002352c <__swsetup_r+0x68>
c0023564:	04076713          	ori	a4,a4,64
c0023568:	00e41623          	sh	a4,12(s0)
c002356c:	fff00513          	li	a0,-1
c0023570:	fbdff06f          	j	c002352c <__swsetup_r+0x68>
c0023574:	00078513          	mv	a0,a5
c0023578:	758000ef          	jal	ra,c0023cd0 <__sinit>
c002357c:	00c41703          	lh	a4,12(s0)
c0023580:	01071793          	slli	a5,a4,0x10
c0023584:	00877693          	andi	a3,a4,8
c0023588:	0107d793          	srli	a5,a5,0x10
c002358c:	f6069ce3          	bnez	a3,c0023504 <__swsetup_r+0x40>
c0023590:	0107f693          	andi	a3,a5,16
c0023594:	08068263          	beqz	a3,c0023618 <__swsetup_r+0x154>
c0023598:	0047f793          	andi	a5,a5,4
c002359c:	04079463          	bnez	a5,c00235e4 <__swsetup_r+0x120>
c00235a0:	01042683          	lw	a3,16(s0)
c00235a4:	00876713          	ori	a4,a4,8
c00235a8:	01071793          	slli	a5,a4,0x10
c00235ac:	00e41623          	sh	a4,12(s0)
c00235b0:	0107d793          	srli	a5,a5,0x10
c00235b4:	f4069ce3          	bnez	a3,c002350c <__swsetup_r+0x48>
c00235b8:	2807f613          	andi	a2,a5,640
c00235bc:	20000593          	li	a1,512
c00235c0:	f4b606e3          	beq	a2,a1,c002350c <__swsetup_r+0x48>
c00235c4:	00040593          	mv	a1,s0
c00235c8:	00048513          	mv	a0,s1
c00235cc:	6a1030ef          	jal	ra,c002746c <__smakebuf_r>
c00235d0:	00c41703          	lh	a4,12(s0)
c00235d4:	01042683          	lw	a3,16(s0)
c00235d8:	01071793          	slli	a5,a4,0x10
c00235dc:	0107d793          	srli	a5,a5,0x10
c00235e0:	f2dff06f          	j	c002350c <__swsetup_r+0x48>
c00235e4:	03042583          	lw	a1,48(s0)
c00235e8:	00058e63          	beqz	a1,c0023604 <__swsetup_r+0x140>
c00235ec:	04040793          	addi	a5,s0,64
c00235f0:	00f58863          	beq	a1,a5,c0023600 <__swsetup_r+0x13c>
c00235f4:	00048513          	mv	a0,s1
c00235f8:	061000ef          	jal	ra,c0023e58 <_free_r>
c00235fc:	00c41703          	lh	a4,12(s0)
c0023600:	02042823          	sw	zero,48(s0)
c0023604:	01042683          	lw	a3,16(s0)
c0023608:	fdb77713          	andi	a4,a4,-37
c002360c:	00042223          	sw	zero,4(s0)
c0023610:	00d42023          	sw	a3,0(s0)
c0023614:	f91ff06f          	j	c00235a4 <__swsetup_r+0xe0>
c0023618:	00900793          	li	a5,9
c002361c:	00f4a023          	sw	a5,0(s1)
c0023620:	04076713          	ori	a4,a4,64
c0023624:	00e41623          	sh	a4,12(s0)
c0023628:	fff00513          	li	a0,-1
c002362c:	f01ff06f          	j	c002352c <__swsetup_r+0x68>

c0023630 <__sflush_r>:
c0023630:	00c59783          	lh	a5,12(a1)
c0023634:	fe010113          	addi	sp,sp,-32
c0023638:	00812c23          	sw	s0,24(sp)
c002363c:	01312623          	sw	s3,12(sp)
c0023640:	00112e23          	sw	ra,28(sp)
c0023644:	00912a23          	sw	s1,20(sp)
c0023648:	01212823          	sw	s2,16(sp)
c002364c:	0087f693          	andi	a3,a5,8
c0023650:	00058413          	mv	s0,a1
c0023654:	00050993          	mv	s3,a0
c0023658:	10069c63          	bnez	a3,c0023770 <__sflush_r+0x140>
c002365c:	00001737          	lui	a4,0x1
c0023660:	80070713          	addi	a4,a4,-2048 # 800 <_STACK_SIZE-0x800>
c0023664:	0045a683          	lw	a3,4(a1)
c0023668:	00e7e7b3          	or	a5,a5,a4
c002366c:	00f59623          	sh	a5,12(a1)
c0023670:	18d05663          	blez	a3,c00237fc <__sflush_r+0x1cc>
c0023674:	02842703          	lw	a4,40(s0)
c0023678:	0c070c63          	beqz	a4,c0023750 <__sflush_r+0x120>
c002367c:	01079793          	slli	a5,a5,0x10
c0023680:	0107d793          	srli	a5,a5,0x10
c0023684:	000016b7          	lui	a3,0x1
c0023688:	0009a483          	lw	s1,0(s3)
c002368c:	00d7f6b3          	and	a3,a5,a3
c0023690:	0009a023          	sw	zero,0(s3)
c0023694:	01c42583          	lw	a1,28(s0)
c0023698:	16069863          	bnez	a3,c0023808 <__sflush_r+0x1d8>
c002369c:	00100693          	li	a3,1
c00236a0:	00000613          	li	a2,0
c00236a4:	00098513          	mv	a0,s3
c00236a8:	000700e7          	jalr	a4
c00236ac:	fff00793          	li	a5,-1
c00236b0:	18f50e63          	beq	a0,a5,c002384c <__sflush_r+0x21c>
c00236b4:	00c45783          	lhu	a5,12(s0)
c00236b8:	02842703          	lw	a4,40(s0)
c00236bc:	01c42583          	lw	a1,28(s0)
c00236c0:	0047f793          	andi	a5,a5,4
c00236c4:	00078e63          	beqz	a5,c00236e0 <__sflush_r+0xb0>
c00236c8:	00442683          	lw	a3,4(s0)
c00236cc:	03042783          	lw	a5,48(s0)
c00236d0:	40d50533          	sub	a0,a0,a3
c00236d4:	00078663          	beqz	a5,c00236e0 <__sflush_r+0xb0>
c00236d8:	03c42783          	lw	a5,60(s0)
c00236dc:	40f50533          	sub	a0,a0,a5
c00236e0:	00050613          	mv	a2,a0
c00236e4:	00000693          	li	a3,0
c00236e8:	00098513          	mv	a0,s3
c00236ec:	000700e7          	jalr	a4
c00236f0:	fff00793          	li	a5,-1
c00236f4:	10f51e63          	bne	a0,a5,c0023810 <__sflush_r+0x1e0>
c00236f8:	0009a703          	lw	a4,0(s3)
c00236fc:	00c41783          	lh	a5,12(s0)
c0023700:	16070a63          	beqz	a4,c0023874 <__sflush_r+0x244>
c0023704:	01d00693          	li	a3,29
c0023708:	00d70663          	beq	a4,a3,c0023714 <__sflush_r+0xe4>
c002370c:	01600693          	li	a3,22
c0023710:	0cd71463          	bne	a4,a3,c00237d8 <__sflush_r+0x1a8>
c0023714:	01042683          	lw	a3,16(s0)
c0023718:	fffff737          	lui	a4,0xfffff
c002371c:	7ff70713          	addi	a4,a4,2047 # fffff7ff <_end+0x37f7af7f>
c0023720:	00e7f7b3          	and	a5,a5,a4
c0023724:	00f41623          	sh	a5,12(s0)
c0023728:	00042223          	sw	zero,4(s0)
c002372c:	00d42023          	sw	a3,0(s0)
c0023730:	03042583          	lw	a1,48(s0)
c0023734:	0099a023          	sw	s1,0(s3)
c0023738:	00058c63          	beqz	a1,c0023750 <__sflush_r+0x120>
c002373c:	04040793          	addi	a5,s0,64
c0023740:	00f58663          	beq	a1,a5,c002374c <__sflush_r+0x11c>
c0023744:	00098513          	mv	a0,s3
c0023748:	710000ef          	jal	ra,c0023e58 <_free_r>
c002374c:	02042823          	sw	zero,48(s0)
c0023750:	00000513          	li	a0,0
c0023754:	01c12083          	lw	ra,28(sp)
c0023758:	01812403          	lw	s0,24(sp)
c002375c:	01412483          	lw	s1,20(sp)
c0023760:	01012903          	lw	s2,16(sp)
c0023764:	00c12983          	lw	s3,12(sp)
c0023768:	02010113          	addi	sp,sp,32
c002376c:	00008067          	ret
c0023770:	0105a903          	lw	s2,16(a1)
c0023774:	fc090ee3          	beqz	s2,c0023750 <__sflush_r+0x120>
c0023778:	0005a483          	lw	s1,0(a1)
c002377c:	01079713          	slli	a4,a5,0x10
c0023780:	01075713          	srli	a4,a4,0x10
c0023784:	00377713          	andi	a4,a4,3
c0023788:	0125a023          	sw	s2,0(a1)
c002378c:	412484b3          	sub	s1,s1,s2
c0023790:	00000793          	li	a5,0
c0023794:	00071463          	bnez	a4,c002379c <__sflush_r+0x16c>
c0023798:	0145a783          	lw	a5,20(a1)
c002379c:	00f42423          	sw	a5,8(s0)
c00237a0:	00904863          	bgtz	s1,c00237b0 <__sflush_r+0x180>
c00237a4:	fadff06f          	j	c0023750 <__sflush_r+0x120>
c00237a8:	00a90933          	add	s2,s2,a0
c00237ac:	fa9052e3          	blez	s1,c0023750 <__sflush_r+0x120>
c00237b0:	02442783          	lw	a5,36(s0)
c00237b4:	01c42583          	lw	a1,28(s0)
c00237b8:	00048693          	mv	a3,s1
c00237bc:	00090613          	mv	a2,s2
c00237c0:	00098513          	mv	a0,s3
c00237c4:	000780e7          	jalr	a5
c00237c8:	40a484b3          	sub	s1,s1,a0
c00237cc:	fca04ee3          	bgtz	a0,c00237a8 <__sflush_r+0x178>
c00237d0:	00c45783          	lhu	a5,12(s0)
c00237d4:	fff00513          	li	a0,-1
c00237d8:	0407e793          	ori	a5,a5,64
c00237dc:	01c12083          	lw	ra,28(sp)
c00237e0:	00f41623          	sh	a5,12(s0)
c00237e4:	01812403          	lw	s0,24(sp)
c00237e8:	01412483          	lw	s1,20(sp)
c00237ec:	01012903          	lw	s2,16(sp)
c00237f0:	00c12983          	lw	s3,12(sp)
c00237f4:	02010113          	addi	sp,sp,32
c00237f8:	00008067          	ret
c00237fc:	03c5a703          	lw	a4,60(a1)
c0023800:	e6e04ae3          	bgtz	a4,c0023674 <__sflush_r+0x44>
c0023804:	f4dff06f          	j	c0023750 <__sflush_r+0x120>
c0023808:	05042503          	lw	a0,80(s0)
c002380c:	eb5ff06f          	j	c00236c0 <__sflush_r+0x90>
c0023810:	00c45783          	lhu	a5,12(s0)
c0023814:	fffff737          	lui	a4,0xfffff
c0023818:	7ff70713          	addi	a4,a4,2047 # fffff7ff <_end+0x37f7af7f>
c002381c:	00e7f7b3          	and	a5,a5,a4
c0023820:	01042683          	lw	a3,16(s0)
c0023824:	01079793          	slli	a5,a5,0x10
c0023828:	4107d793          	srai	a5,a5,0x10
c002382c:	00c7d713          	srli	a4,a5,0xc
c0023830:	00f41623          	sh	a5,12(s0)
c0023834:	00042223          	sw	zero,4(s0)
c0023838:	00d42023          	sw	a3,0(s0)
c002383c:	00177793          	andi	a5,a4,1
c0023840:	ee0788e3          	beqz	a5,c0023730 <__sflush_r+0x100>
c0023844:	04a42823          	sw	a0,80(s0)
c0023848:	ee9ff06f          	j	c0023730 <__sflush_r+0x100>
c002384c:	0009a783          	lw	a5,0(s3)
c0023850:	e60782e3          	beqz	a5,c00236b4 <__sflush_r+0x84>
c0023854:	01d00713          	li	a4,29
c0023858:	02e78863          	beq	a5,a4,c0023888 <__sflush_r+0x258>
c002385c:	01600713          	li	a4,22
c0023860:	02e78463          	beq	a5,a4,c0023888 <__sflush_r+0x258>
c0023864:	00c45783          	lhu	a5,12(s0)
c0023868:	0407e793          	ori	a5,a5,64
c002386c:	00f41623          	sh	a5,12(s0)
c0023870:	ee5ff06f          	j	c0023754 <__sflush_r+0x124>
c0023874:	fffff737          	lui	a4,0xfffff
c0023878:	7ff70713          	addi	a4,a4,2047 # fffff7ff <_end+0x37f7af7f>
c002387c:	01042683          	lw	a3,16(s0)
c0023880:	00e7f7b3          	and	a5,a5,a4
c0023884:	fa9ff06f          	j	c002382c <__sflush_r+0x1fc>
c0023888:	0099a023          	sw	s1,0(s3)
c002388c:	00000513          	li	a0,0
c0023890:	ec5ff06f          	j	c0023754 <__sflush_r+0x124>

c0023894 <_fflush_r>:
c0023894:	fe010113          	addi	sp,sp,-32
c0023898:	00812c23          	sw	s0,24(sp)
c002389c:	00112e23          	sw	ra,28(sp)
c00238a0:	00050413          	mv	s0,a0
c00238a4:	00050663          	beqz	a0,c00238b0 <_fflush_r+0x1c>
c00238a8:	03852783          	lw	a5,56(a0)
c00238ac:	02078063          	beqz	a5,c00238cc <_fflush_r+0x38>
c00238b0:	00c59783          	lh	a5,12(a1)
c00238b4:	02079663          	bnez	a5,c00238e0 <_fflush_r+0x4c>
c00238b8:	01c12083          	lw	ra,28(sp)
c00238bc:	01812403          	lw	s0,24(sp)
c00238c0:	00000513          	li	a0,0
c00238c4:	02010113          	addi	sp,sp,32
c00238c8:	00008067          	ret
c00238cc:	00b12623          	sw	a1,12(sp)
c00238d0:	400000ef          	jal	ra,c0023cd0 <__sinit>
c00238d4:	00c12583          	lw	a1,12(sp)
c00238d8:	00c59783          	lh	a5,12(a1)
c00238dc:	fc078ee3          	beqz	a5,c00238b8 <_fflush_r+0x24>
c00238e0:	00040513          	mv	a0,s0
c00238e4:	01812403          	lw	s0,24(sp)
c00238e8:	01c12083          	lw	ra,28(sp)
c00238ec:	02010113          	addi	sp,sp,32
c00238f0:	d41ff06f          	j	c0023630 <__sflush_r>

c00238f4 <fflush>:
c00238f4:	06050863          	beqz	a0,c0023964 <fflush+0x70>
c00238f8:	fe010113          	addi	sp,sp,-32
c00238fc:	c80037b7          	lui	a5,0xc8003
c0023900:	00812c23          	sw	s0,24(sp)
c0023904:	00050413          	mv	s0,a0
c0023908:	98c7a503          	lw	a0,-1652(a5) # c800298c <_end+0xfff7e10c>
c002390c:	00112e23          	sw	ra,28(sp)
c0023910:	00050663          	beqz	a0,c002391c <fflush+0x28>
c0023914:	03852783          	lw	a5,56(a0)
c0023918:	02078a63          	beqz	a5,c002394c <fflush+0x58>
c002391c:	00c41783          	lh	a5,12(s0)
c0023920:	00079c63          	bnez	a5,c0023938 <fflush+0x44>
c0023924:	01c12083          	lw	ra,28(sp)
c0023928:	01812403          	lw	s0,24(sp)
c002392c:	00000513          	li	a0,0
c0023930:	02010113          	addi	sp,sp,32
c0023934:	00008067          	ret
c0023938:	00040593          	mv	a1,s0
c002393c:	01812403          	lw	s0,24(sp)
c0023940:	01c12083          	lw	ra,28(sp)
c0023944:	02010113          	addi	sp,sp,32
c0023948:	ce9ff06f          	j	c0023630 <__sflush_r>
c002394c:	00a12623          	sw	a0,12(sp)
c0023950:	380000ef          	jal	ra,c0023cd0 <__sinit>
c0023954:	00c41783          	lh	a5,12(s0)
c0023958:	00c12503          	lw	a0,12(sp)
c002395c:	fc0784e3          	beqz	a5,c0023924 <fflush+0x30>
c0023960:	fd9ff06f          	j	c0023938 <fflush+0x44>
c0023964:	c80037b7          	lui	a5,0xc8003
c0023968:	9587a503          	lw	a0,-1704(a5) # c8002958 <_end+0xfff7e0d8>
c002396c:	c00245b7          	lui	a1,0xc0024
c0023970:	89458593          	addi	a1,a1,-1900 # c0023894 <_end+0xf7f9f014>
c0023974:	5350006f          	j	c00246a8 <_fwalk_reent>

c0023978 <__fp_lock>:
c0023978:	00000513          	li	a0,0
c002397c:	00008067          	ret

c0023980 <_cleanup_r>:
c0023980:	c002c5b7          	lui	a1,0xc002c
c0023984:	6d058593          	addi	a1,a1,1744 # c002c6d0 <_end+0xf7fa7e50>
c0023988:	5210006f          	j	c00246a8 <_fwalk_reent>

c002398c <__fp_unlock>:
c002398c:	00000513          	li	a0,0
c0023990:	00008067          	ret

c0023994 <__sinit.part.0>:
c0023994:	fe010113          	addi	sp,sp,-32
c0023998:	c00247b7          	lui	a5,0xc0024
c002399c:	00112e23          	sw	ra,28(sp)
c00239a0:	00812c23          	sw	s0,24(sp)
c00239a4:	00912a23          	sw	s1,20(sp)
c00239a8:	01212823          	sw	s2,16(sp)
c00239ac:	01312623          	sw	s3,12(sp)
c00239b0:	01412423          	sw	s4,8(sp)
c00239b4:	01512223          	sw	s5,4(sp)
c00239b8:	01612023          	sw	s6,0(sp)
c00239bc:	00452403          	lw	s0,4(a0)
c00239c0:	98078793          	addi	a5,a5,-1664 # c0023980 <_end+0xf7f9f100>
c00239c4:	02f52e23          	sw	a5,60(a0)
c00239c8:	2ec50713          	addi	a4,a0,748
c00239cc:	00300793          	li	a5,3
c00239d0:	2ee52423          	sw	a4,744(a0)
c00239d4:	2ef52223          	sw	a5,740(a0)
c00239d8:	2e052023          	sw	zero,736(a0)
c00239dc:	00400793          	li	a5,4
c00239e0:	00050913          	mv	s2,a0
c00239e4:	00f42623          	sw	a5,12(s0)
c00239e8:	00800613          	li	a2,8
c00239ec:	00000593          	li	a1,0
c00239f0:	06042223          	sw	zero,100(s0)
c00239f4:	00042023          	sw	zero,0(s0)
c00239f8:	00042223          	sw	zero,4(s0)
c00239fc:	00042423          	sw	zero,8(s0)
c0023a00:	00042823          	sw	zero,16(s0)
c0023a04:	00042a23          	sw	zero,20(s0)
c0023a08:	00042c23          	sw	zero,24(s0)
c0023a0c:	05c40513          	addi	a0,s0,92
c0023a10:	a78fa0ef          	jal	ra,c001dc88 <memset>
c0023a14:	c002ab37          	lui	s6,0xc002a
c0023a18:	00892483          	lw	s1,8(s2) # 3ffe0008 <_DMEM_LENGTH+0x3f7e0008>
c0023a1c:	c002aab7          	lui	s5,0xc002a
c0023a20:	c002aa37          	lui	s4,0xc002a
c0023a24:	c002a9b7          	lui	s3,0xc002a
c0023a28:	96cb0b13          	addi	s6,s6,-1684 # c002996c <_end+0xf7fa50ec>
c0023a2c:	9d0a8a93          	addi	s5,s5,-1584 # c00299d0 <_end+0xf7fa5150>
c0023a30:	a58a0a13          	addi	s4,s4,-1448 # c0029a58 <_end+0xf7fa51d8>
c0023a34:	ac098993          	addi	s3,s3,-1344 # c0029ac0 <_end+0xf7fa5240>
c0023a38:	000107b7          	lui	a5,0x10
c0023a3c:	03642023          	sw	s6,32(s0)
c0023a40:	03542223          	sw	s5,36(s0)
c0023a44:	03442423          	sw	s4,40(s0)
c0023a48:	03342623          	sw	s3,44(s0)
c0023a4c:	00842e23          	sw	s0,28(s0)
c0023a50:	00978793          	addi	a5,a5,9 # 10009 <_STACK_SIZE+0xf009>
c0023a54:	00f4a623          	sw	a5,12(s1)
c0023a58:	00800613          	li	a2,8
c0023a5c:	00000593          	li	a1,0
c0023a60:	0604a223          	sw	zero,100(s1)
c0023a64:	0004a023          	sw	zero,0(s1)
c0023a68:	0004a223          	sw	zero,4(s1)
c0023a6c:	0004a423          	sw	zero,8(s1)
c0023a70:	0004a823          	sw	zero,16(s1)
c0023a74:	0004aa23          	sw	zero,20(s1)
c0023a78:	0004ac23          	sw	zero,24(s1)
c0023a7c:	05c48513          	addi	a0,s1,92
c0023a80:	a08fa0ef          	jal	ra,c001dc88 <memset>
c0023a84:	00c92403          	lw	s0,12(s2)
c0023a88:	000207b7          	lui	a5,0x20
c0023a8c:	0364a023          	sw	s6,32(s1)
c0023a90:	0354a223          	sw	s5,36(s1)
c0023a94:	0344a423          	sw	s4,40(s1)
c0023a98:	0334a623          	sw	s3,44(s1)
c0023a9c:	0094ae23          	sw	s1,28(s1)
c0023aa0:	01278793          	addi	a5,a5,18 # 20012 <_STACK_SIZE+0x1f012>
c0023aa4:	00f42623          	sw	a5,12(s0)
c0023aa8:	06042223          	sw	zero,100(s0)
c0023aac:	00042023          	sw	zero,0(s0)
c0023ab0:	00042223          	sw	zero,4(s0)
c0023ab4:	00042423          	sw	zero,8(s0)
c0023ab8:	00042823          	sw	zero,16(s0)
c0023abc:	00042a23          	sw	zero,20(s0)
c0023ac0:	00042c23          	sw	zero,24(s0)
c0023ac4:	05c40513          	addi	a0,s0,92
c0023ac8:	00800613          	li	a2,8
c0023acc:	00000593          	li	a1,0
c0023ad0:	9b8fa0ef          	jal	ra,c001dc88 <memset>
c0023ad4:	01c12083          	lw	ra,28(sp)
c0023ad8:	03642023          	sw	s6,32(s0)
c0023adc:	03542223          	sw	s5,36(s0)
c0023ae0:	03442423          	sw	s4,40(s0)
c0023ae4:	03342623          	sw	s3,44(s0)
c0023ae8:	00842e23          	sw	s0,28(s0)
c0023aec:	01812403          	lw	s0,24(sp)
c0023af0:	00100793          	li	a5,1
c0023af4:	02f92c23          	sw	a5,56(s2)
c0023af8:	01412483          	lw	s1,20(sp)
c0023afc:	01012903          	lw	s2,16(sp)
c0023b00:	00c12983          	lw	s3,12(sp)
c0023b04:	00812a03          	lw	s4,8(sp)
c0023b08:	00412a83          	lw	s5,4(sp)
c0023b0c:	00012b03          	lw	s6,0(sp)
c0023b10:	02010113          	addi	sp,sp,32
c0023b14:	00008067          	ret

c0023b18 <__sfmoreglue>:
c0023b18:	ff010113          	addi	sp,sp,-16
c0023b1c:	00912223          	sw	s1,4(sp)
c0023b20:	06800613          	li	a2,104
c0023b24:	fff58493          	addi	s1,a1,-1
c0023b28:	02c484b3          	mul	s1,s1,a2
c0023b2c:	01212023          	sw	s2,0(sp)
c0023b30:	00058913          	mv	s2,a1
c0023b34:	00812423          	sw	s0,8(sp)
c0023b38:	00112623          	sw	ra,12(sp)
c0023b3c:	07448593          	addi	a1,s1,116
c0023b40:	38d030ef          	jal	ra,c00276cc <_malloc_r>
c0023b44:	00050413          	mv	s0,a0
c0023b48:	02050063          	beqz	a0,c0023b68 <__sfmoreglue+0x50>
c0023b4c:	00c50513          	addi	a0,a0,12
c0023b50:	00042023          	sw	zero,0(s0)
c0023b54:	01242223          	sw	s2,4(s0)
c0023b58:	00a42423          	sw	a0,8(s0)
c0023b5c:	06848613          	addi	a2,s1,104
c0023b60:	00000593          	li	a1,0
c0023b64:	924fa0ef          	jal	ra,c001dc88 <memset>
c0023b68:	00c12083          	lw	ra,12(sp)
c0023b6c:	00040513          	mv	a0,s0
c0023b70:	00812403          	lw	s0,8(sp)
c0023b74:	00412483          	lw	s1,4(sp)
c0023b78:	00012903          	lw	s2,0(sp)
c0023b7c:	01010113          	addi	sp,sp,16
c0023b80:	00008067          	ret

c0023b84 <__sfp>:
c0023b84:	fe010113          	addi	sp,sp,-32
c0023b88:	c80037b7          	lui	a5,0xc8003
c0023b8c:	01212823          	sw	s2,16(sp)
c0023b90:	9587a903          	lw	s2,-1704(a5) # c8002958 <_end+0xfff7e0d8>
c0023b94:	01312623          	sw	s3,12(sp)
c0023b98:	00112e23          	sw	ra,28(sp)
c0023b9c:	03892783          	lw	a5,56(s2)
c0023ba0:	00812c23          	sw	s0,24(sp)
c0023ba4:	00912a23          	sw	s1,20(sp)
c0023ba8:	01412423          	sw	s4,8(sp)
c0023bac:	00050993          	mv	s3,a0
c0023bb0:	0a078a63          	beqz	a5,c0023c64 <__sfp+0xe0>
c0023bb4:	2e090913          	addi	s2,s2,736
c0023bb8:	fff00493          	li	s1,-1
c0023bbc:	00400a13          	li	s4,4
c0023bc0:	00492783          	lw	a5,4(s2)
c0023bc4:	00892403          	lw	s0,8(s2)
c0023bc8:	fff78793          	addi	a5,a5,-1
c0023bcc:	0007d863          	bgez	a5,c0023bdc <__sfp+0x58>
c0023bd0:	0840006f          	j	c0023c54 <__sfp+0xd0>
c0023bd4:	06840413          	addi	s0,s0,104
c0023bd8:	06978e63          	beq	a5,s1,c0023c54 <__sfp+0xd0>
c0023bdc:	00c41703          	lh	a4,12(s0)
c0023be0:	fff78793          	addi	a5,a5,-1
c0023be4:	fe0718e3          	bnez	a4,c0023bd4 <__sfp+0x50>
c0023be8:	ffff07b7          	lui	a5,0xffff0
c0023bec:	00178793          	addi	a5,a5,1 # ffff0001 <_end+0x37f6b781>
c0023bf0:	06042223          	sw	zero,100(s0)
c0023bf4:	00042023          	sw	zero,0(s0)
c0023bf8:	00042223          	sw	zero,4(s0)
c0023bfc:	00042423          	sw	zero,8(s0)
c0023c00:	00f42623          	sw	a5,12(s0)
c0023c04:	00042823          	sw	zero,16(s0)
c0023c08:	00042a23          	sw	zero,20(s0)
c0023c0c:	00042c23          	sw	zero,24(s0)
c0023c10:	00800613          	li	a2,8
c0023c14:	00000593          	li	a1,0
c0023c18:	05c40513          	addi	a0,s0,92
c0023c1c:	86cfa0ef          	jal	ra,c001dc88 <memset>
c0023c20:	02042823          	sw	zero,48(s0)
c0023c24:	02042a23          	sw	zero,52(s0)
c0023c28:	04042223          	sw	zero,68(s0)
c0023c2c:	04042423          	sw	zero,72(s0)
c0023c30:	01c12083          	lw	ra,28(sp)
c0023c34:	00040513          	mv	a0,s0
c0023c38:	01812403          	lw	s0,24(sp)
c0023c3c:	01412483          	lw	s1,20(sp)
c0023c40:	01012903          	lw	s2,16(sp)
c0023c44:	00c12983          	lw	s3,12(sp)
c0023c48:	00812a03          	lw	s4,8(sp)
c0023c4c:	02010113          	addi	sp,sp,32
c0023c50:	00008067          	ret
c0023c54:	00092403          	lw	s0,0(s2)
c0023c58:	00040c63          	beqz	s0,c0023c70 <__sfp+0xec>
c0023c5c:	00040913          	mv	s2,s0
c0023c60:	f61ff06f          	j	c0023bc0 <__sfp+0x3c>
c0023c64:	00090513          	mv	a0,s2
c0023c68:	d2dff0ef          	jal	ra,c0023994 <__sinit.part.0>
c0023c6c:	f49ff06f          	j	c0023bb4 <__sfp+0x30>
c0023c70:	1ac00593          	li	a1,428
c0023c74:	00098513          	mv	a0,s3
c0023c78:	255030ef          	jal	ra,c00276cc <_malloc_r>
c0023c7c:	00050413          	mv	s0,a0
c0023c80:	02050663          	beqz	a0,c0023cac <__sfp+0x128>
c0023c84:	00c50513          	addi	a0,a0,12
c0023c88:	00042023          	sw	zero,0(s0)
c0023c8c:	01442223          	sw	s4,4(s0)
c0023c90:	00a42423          	sw	a0,8(s0)
c0023c94:	1a000613          	li	a2,416
c0023c98:	00000593          	li	a1,0
c0023c9c:	fedf90ef          	jal	ra,c001dc88 <memset>
c0023ca0:	00892023          	sw	s0,0(s2)
c0023ca4:	00040913          	mv	s2,s0
c0023ca8:	f19ff06f          	j	c0023bc0 <__sfp+0x3c>
c0023cac:	00092023          	sw	zero,0(s2)
c0023cb0:	00c00793          	li	a5,12
c0023cb4:	00f9a023          	sw	a5,0(s3)
c0023cb8:	f79ff06f          	j	c0023c30 <__sfp+0xac>

c0023cbc <_cleanup>:
c0023cbc:	c80037b7          	lui	a5,0xc8003
c0023cc0:	9587a503          	lw	a0,-1704(a5) # c8002958 <_end+0xfff7e0d8>
c0023cc4:	c002c5b7          	lui	a1,0xc002c
c0023cc8:	6d058593          	addi	a1,a1,1744 # c002c6d0 <_end+0xf7fa7e50>
c0023ccc:	1dd0006f          	j	c00246a8 <_fwalk_reent>

c0023cd0 <__sinit>:
c0023cd0:	03852783          	lw	a5,56(a0)
c0023cd4:	00078463          	beqz	a5,c0023cdc <__sinit+0xc>
c0023cd8:	00008067          	ret
c0023cdc:	cb9ff06f          	j	c0023994 <__sinit.part.0>

c0023ce0 <__sfp_lock_acquire>:
c0023ce0:	00008067          	ret

c0023ce4 <__sfp_lock_release>:
c0023ce4:	00008067          	ret

c0023ce8 <__sinit_lock_acquire>:
c0023ce8:	00008067          	ret

c0023cec <__sinit_lock_release>:
c0023cec:	00008067          	ret

c0023cf0 <__fp_lock_all>:
c0023cf0:	c80037b7          	lui	a5,0xc8003
c0023cf4:	98c7a503          	lw	a0,-1652(a5) # c800298c <_end+0xfff7e10c>
c0023cf8:	c00245b7          	lui	a1,0xc0024
c0023cfc:	97858593          	addi	a1,a1,-1672 # c0023978 <_end+0xf7f9f0f8>
c0023d00:	1050006f          	j	c0024604 <_fwalk>

c0023d04 <__fp_unlock_all>:
c0023d04:	c80037b7          	lui	a5,0xc8003
c0023d08:	98c7a503          	lw	a0,-1652(a5) # c800298c <_end+0xfff7e10c>
c0023d0c:	c00245b7          	lui	a1,0xc0024
c0023d10:	98c58593          	addi	a1,a1,-1652 # c002398c <_end+0xf7f9f10c>
c0023d14:	0f10006f          	j	c0024604 <_fwalk>

c0023d18 <_malloc_trim_r>:
c0023d18:	fe010113          	addi	sp,sp,-32
c0023d1c:	01312623          	sw	s3,12(sp)
c0023d20:	c80039b7          	lui	s3,0xc8003
c0023d24:	00812c23          	sw	s0,24(sp)
c0023d28:	00912a23          	sw	s1,20(sp)
c0023d2c:	01212823          	sw	s2,16(sp)
c0023d30:	01412423          	sw	s4,8(sp)
c0023d34:	00112e23          	sw	ra,28(sp)
c0023d38:	00058a13          	mv	s4,a1
c0023d3c:	00050913          	mv	s2,a0
c0023d40:	0fc98993          	addi	s3,s3,252 # c80030fc <_end+0xfff7e87c>
c0023d44:	39c040ef          	jal	ra,c00280e0 <__malloc_lock>
c0023d48:	0089a703          	lw	a4,8(s3)
c0023d4c:	000017b7          	lui	a5,0x1
c0023d50:	fef78413          	addi	s0,a5,-17 # fef <_STACK_SIZE-0x11>
c0023d54:	00472483          	lw	s1,4(a4)
c0023d58:	41440433          	sub	s0,s0,s4
c0023d5c:	ffc4f493          	andi	s1,s1,-4
c0023d60:	00940433          	add	s0,s0,s1
c0023d64:	00c45413          	srli	s0,s0,0xc
c0023d68:	fff40413          	addi	s0,s0,-1
c0023d6c:	00c41413          	slli	s0,s0,0xc
c0023d70:	00f44e63          	blt	s0,a5,c0023d8c <_malloc_trim_r+0x74>
c0023d74:	00000593          	li	a1,0
c0023d78:	00090513          	mv	a0,s2
c0023d7c:	2e5050ef          	jal	ra,c0029860 <_sbrk_r>
c0023d80:	0089a783          	lw	a5,8(s3)
c0023d84:	009787b3          	add	a5,a5,s1
c0023d88:	02f50863          	beq	a0,a5,c0023db8 <_malloc_trim_r+0xa0>
c0023d8c:	00090513          	mv	a0,s2
c0023d90:	354040ef          	jal	ra,c00280e4 <__malloc_unlock>
c0023d94:	01c12083          	lw	ra,28(sp)
c0023d98:	01812403          	lw	s0,24(sp)
c0023d9c:	01412483          	lw	s1,20(sp)
c0023da0:	01012903          	lw	s2,16(sp)
c0023da4:	00c12983          	lw	s3,12(sp)
c0023da8:	00812a03          	lw	s4,8(sp)
c0023dac:	00000513          	li	a0,0
c0023db0:	02010113          	addi	sp,sp,32
c0023db4:	00008067          	ret
c0023db8:	408005b3          	neg	a1,s0
c0023dbc:	00090513          	mv	a0,s2
c0023dc0:	2a1050ef          	jal	ra,c0029860 <_sbrk_r>
c0023dc4:	fff00793          	li	a5,-1
c0023dc8:	04f50a63          	beq	a0,a5,c0023e1c <_malloc_trim_r+0x104>
c0023dcc:	c80447b7          	lui	a5,0xc8044
c0023dd0:	82c78793          	addi	a5,a5,-2004 # c804382c <_end+0xfffbefac>
c0023dd4:	0007a703          	lw	a4,0(a5)
c0023dd8:	0089a683          	lw	a3,8(s3)
c0023ddc:	408484b3          	sub	s1,s1,s0
c0023de0:	0014e493          	ori	s1,s1,1
c0023de4:	40870433          	sub	s0,a4,s0
c0023de8:	00090513          	mv	a0,s2
c0023dec:	0096a223          	sw	s1,4(a3) # 1004 <_STACK_SIZE+0x4>
c0023df0:	0087a023          	sw	s0,0(a5)
c0023df4:	2f0040ef          	jal	ra,c00280e4 <__malloc_unlock>
c0023df8:	01c12083          	lw	ra,28(sp)
c0023dfc:	01812403          	lw	s0,24(sp)
c0023e00:	01412483          	lw	s1,20(sp)
c0023e04:	01012903          	lw	s2,16(sp)
c0023e08:	00c12983          	lw	s3,12(sp)
c0023e0c:	00812a03          	lw	s4,8(sp)
c0023e10:	00100513          	li	a0,1
c0023e14:	02010113          	addi	sp,sp,32
c0023e18:	00008067          	ret
c0023e1c:	00000593          	li	a1,0
c0023e20:	00090513          	mv	a0,s2
c0023e24:	23d050ef          	jal	ra,c0029860 <_sbrk_r>
c0023e28:	0089a703          	lw	a4,8(s3)
c0023e2c:	00f00693          	li	a3,15
c0023e30:	40e507b3          	sub	a5,a0,a4
c0023e34:	f4f6dce3          	bge	a3,a5,c0023d8c <_malloc_trim_r+0x74>
c0023e38:	c80036b7          	lui	a3,0xc8003
c0023e3c:	9906a683          	lw	a3,-1648(a3) # c8002990 <_end+0xfff7e110>
c0023e40:	0017e793          	ori	a5,a5,1
c0023e44:	00f72223          	sw	a5,4(a4)
c0023e48:	40d50533          	sub	a0,a0,a3
c0023e4c:	c80446b7          	lui	a3,0xc8044
c0023e50:	82a6a623          	sw	a0,-2004(a3) # c804382c <_end+0xfffbefac>
c0023e54:	f39ff06f          	j	c0023d8c <_malloc_trim_r+0x74>

c0023e58 <_free_r>:
c0023e58:	12058a63          	beqz	a1,c0023f8c <_free_r+0x134>
c0023e5c:	ff010113          	addi	sp,sp,-16
c0023e60:	00812423          	sw	s0,8(sp)
c0023e64:	00912223          	sw	s1,4(sp)
c0023e68:	00058413          	mv	s0,a1
c0023e6c:	00050493          	mv	s1,a0
c0023e70:	00112623          	sw	ra,12(sp)
c0023e74:	26c040ef          	jal	ra,c00280e0 <__malloc_lock>
c0023e78:	ffc42803          	lw	a6,-4(s0)
c0023e7c:	ff840713          	addi	a4,s0,-8
c0023e80:	c80035b7          	lui	a1,0xc8003
c0023e84:	ffe87793          	andi	a5,a6,-2
c0023e88:	00f70633          	add	a2,a4,a5
c0023e8c:	0fc58593          	addi	a1,a1,252 # c80030fc <_end+0xfff7e87c>
c0023e90:	00462683          	lw	a3,4(a2)
c0023e94:	0085a503          	lw	a0,8(a1)
c0023e98:	ffc6f693          	andi	a3,a3,-4
c0023e9c:	1ac50a63          	beq	a0,a2,c0024050 <_free_r+0x1f8>
c0023ea0:	00d62223          	sw	a3,4(a2)
c0023ea4:	00187813          	andi	a6,a6,1
c0023ea8:	00d60533          	add	a0,a2,a3
c0023eac:	0a081063          	bnez	a6,c0023f4c <_free_r+0xf4>
c0023eb0:	ff842303          	lw	t1,-8(s0)
c0023eb4:	00452803          	lw	a6,4(a0)
c0023eb8:	c8003537          	lui	a0,0xc8003
c0023ebc:	40670733          	sub	a4,a4,t1
c0023ec0:	00872883          	lw	a7,8(a4)
c0023ec4:	10450513          	addi	a0,a0,260 # c8003104 <_end+0xfff7e884>
c0023ec8:	006787b3          	add	a5,a5,t1
c0023ecc:	00187813          	andi	a6,a6,1
c0023ed0:	14a88063          	beq	a7,a0,c0024010 <_free_r+0x1b8>
c0023ed4:	00c72303          	lw	t1,12(a4)
c0023ed8:	0068a623          	sw	t1,12(a7)
c0023edc:	01132423          	sw	a7,8(t1) # 80000008 <_end+0xb7f7b788>
c0023ee0:	1e080463          	beqz	a6,c00240c8 <_free_r+0x270>
c0023ee4:	0017e693          	ori	a3,a5,1
c0023ee8:	00d72223          	sw	a3,4(a4)
c0023eec:	00f62023          	sw	a5,0(a2)
c0023ef0:	1ff00693          	li	a3,511
c0023ef4:	0af6e863          	bltu	a3,a5,c0023fa4 <_free_r+0x14c>
c0023ef8:	ff87f693          	andi	a3,a5,-8
c0023efc:	00868693          	addi	a3,a3,8
c0023f00:	0045a503          	lw	a0,4(a1)
c0023f04:	00d586b3          	add	a3,a1,a3
c0023f08:	0006a603          	lw	a2,0(a3)
c0023f0c:	0057d813          	srli	a6,a5,0x5
c0023f10:	00100793          	li	a5,1
c0023f14:	010797b3          	sll	a5,a5,a6
c0023f18:	00a7e7b3          	or	a5,a5,a0
c0023f1c:	ff868513          	addi	a0,a3,-8
c0023f20:	00a72623          	sw	a0,12(a4)
c0023f24:	00c72423          	sw	a2,8(a4)
c0023f28:	00f5a223          	sw	a5,4(a1)
c0023f2c:	00e6a023          	sw	a4,0(a3)
c0023f30:	00e62623          	sw	a4,12(a2)
c0023f34:	00812403          	lw	s0,8(sp)
c0023f38:	00c12083          	lw	ra,12(sp)
c0023f3c:	00048513          	mv	a0,s1
c0023f40:	00412483          	lw	s1,4(sp)
c0023f44:	01010113          	addi	sp,sp,16
c0023f48:	19c0406f          	j	c00280e4 <__malloc_unlock>
c0023f4c:	00452503          	lw	a0,4(a0)
c0023f50:	00157513          	andi	a0,a0,1
c0023f54:	02051e63          	bnez	a0,c0023f90 <_free_r+0x138>
c0023f58:	c8003537          	lui	a0,0xc8003
c0023f5c:	00d787b3          	add	a5,a5,a3
c0023f60:	10450513          	addi	a0,a0,260 # c8003104 <_end+0xfff7e884>
c0023f64:	00862683          	lw	a3,8(a2)
c0023f68:	0017e893          	ori	a7,a5,1
c0023f6c:	00f70833          	add	a6,a4,a5
c0023f70:	16a68863          	beq	a3,a0,c00240e0 <_free_r+0x288>
c0023f74:	00c62603          	lw	a2,12(a2)
c0023f78:	00c6a623          	sw	a2,12(a3)
c0023f7c:	00d62423          	sw	a3,8(a2)
c0023f80:	01172223          	sw	a7,4(a4)
c0023f84:	00f82023          	sw	a5,0(a6)
c0023f88:	f69ff06f          	j	c0023ef0 <_free_r+0x98>
c0023f8c:	00008067          	ret
c0023f90:	0017e693          	ori	a3,a5,1
c0023f94:	fed42e23          	sw	a3,-4(s0)
c0023f98:	00f62023          	sw	a5,0(a2)
c0023f9c:	1ff00693          	li	a3,511
c0023fa0:	f4f6fce3          	bgeu	a3,a5,c0023ef8 <_free_r+0xa0>
c0023fa4:	0097d693          	srli	a3,a5,0x9
c0023fa8:	00400613          	li	a2,4
c0023fac:	0ed66c63          	bltu	a2,a3,c00240a4 <_free_r+0x24c>
c0023fb0:	0067d693          	srli	a3,a5,0x6
c0023fb4:	03968813          	addi	a6,a3,57
c0023fb8:	03868613          	addi	a2,a3,56
c0023fbc:	00381813          	slli	a6,a6,0x3
c0023fc0:	01058833          	add	a6,a1,a6
c0023fc4:	00082683          	lw	a3,0(a6)
c0023fc8:	ff880813          	addi	a6,a6,-8
c0023fcc:	12d80863          	beq	a6,a3,c00240fc <_free_r+0x2a4>
c0023fd0:	0046a603          	lw	a2,4(a3)
c0023fd4:	ffc67613          	andi	a2,a2,-4
c0023fd8:	00c7f663          	bgeu	a5,a2,c0023fe4 <_free_r+0x18c>
c0023fdc:	0086a683          	lw	a3,8(a3)
c0023fe0:	fed818e3          	bne	a6,a3,c0023fd0 <_free_r+0x178>
c0023fe4:	00c6a803          	lw	a6,12(a3)
c0023fe8:	01072623          	sw	a6,12(a4)
c0023fec:	00d72423          	sw	a3,8(a4)
c0023ff0:	00812403          	lw	s0,8(sp)
c0023ff4:	00c12083          	lw	ra,12(sp)
c0023ff8:	00e82423          	sw	a4,8(a6)
c0023ffc:	00048513          	mv	a0,s1
c0024000:	00412483          	lw	s1,4(sp)
c0024004:	00e6a623          	sw	a4,12(a3)
c0024008:	01010113          	addi	sp,sp,16
c002400c:	0d80406f          	j	c00280e4 <__malloc_unlock>
c0024010:	14081663          	bnez	a6,c002415c <_free_r+0x304>
c0024014:	00c62583          	lw	a1,12(a2)
c0024018:	00862603          	lw	a2,8(a2)
c002401c:	00f687b3          	add	a5,a3,a5
c0024020:	00812403          	lw	s0,8(sp)
c0024024:	00b62623          	sw	a1,12(a2)
c0024028:	00c5a423          	sw	a2,8(a1)
c002402c:	0017e693          	ori	a3,a5,1
c0024030:	00c12083          	lw	ra,12(sp)
c0024034:	00d72223          	sw	a3,4(a4)
c0024038:	00048513          	mv	a0,s1
c002403c:	00f70733          	add	a4,a4,a5
c0024040:	00412483          	lw	s1,4(sp)
c0024044:	00f72023          	sw	a5,0(a4)
c0024048:	01010113          	addi	sp,sp,16
c002404c:	0980406f          	j	c00280e4 <__malloc_unlock>
c0024050:	00187813          	andi	a6,a6,1
c0024054:	00d787b3          	add	a5,a5,a3
c0024058:	02081063          	bnez	a6,c0024078 <_free_r+0x220>
c002405c:	ff842503          	lw	a0,-8(s0)
c0024060:	40a70733          	sub	a4,a4,a0
c0024064:	00c72683          	lw	a3,12(a4)
c0024068:	00872603          	lw	a2,8(a4)
c002406c:	00a787b3          	add	a5,a5,a0
c0024070:	00d62623          	sw	a3,12(a2)
c0024074:	00c6a423          	sw	a2,8(a3)
c0024078:	c80036b7          	lui	a3,0xc8003
c002407c:	0017e613          	ori	a2,a5,1
c0024080:	9946a683          	lw	a3,-1644(a3) # c8002994 <_end+0xfff7e114>
c0024084:	00c72223          	sw	a2,4(a4)
c0024088:	00e5a423          	sw	a4,8(a1)
c002408c:	ead7e4e3          	bltu	a5,a3,c0023f34 <_free_r+0xdc>
c0024090:	c80037b7          	lui	a5,0xc8003
c0024094:	9247a583          	lw	a1,-1756(a5) # c8002924 <_end+0xfff7e0a4>
c0024098:	00048513          	mv	a0,s1
c002409c:	c7dff0ef          	jal	ra,c0023d18 <_malloc_trim_r>
c00240a0:	e95ff06f          	j	c0023f34 <_free_r+0xdc>
c00240a4:	01400613          	li	a2,20
c00240a8:	02d67463          	bgeu	a2,a3,c00240d0 <_free_r+0x278>
c00240ac:	05400613          	li	a2,84
c00240b0:	06d66463          	bltu	a2,a3,c0024118 <_free_r+0x2c0>
c00240b4:	00c7d693          	srli	a3,a5,0xc
c00240b8:	06f68813          	addi	a6,a3,111
c00240bc:	06e68613          	addi	a2,a3,110
c00240c0:	00381813          	slli	a6,a6,0x3
c00240c4:	efdff06f          	j	c0023fc0 <_free_r+0x168>
c00240c8:	00d787b3          	add	a5,a5,a3
c00240cc:	e99ff06f          	j	c0023f64 <_free_r+0x10c>
c00240d0:	05c68813          	addi	a6,a3,92
c00240d4:	05b68613          	addi	a2,a3,91
c00240d8:	00381813          	slli	a6,a6,0x3
c00240dc:	ee5ff06f          	j	c0023fc0 <_free_r+0x168>
c00240e0:	00e5aa23          	sw	a4,20(a1)
c00240e4:	00e5a823          	sw	a4,16(a1)
c00240e8:	00a72623          	sw	a0,12(a4)
c00240ec:	00a72423          	sw	a0,8(a4)
c00240f0:	01172223          	sw	a7,4(a4)
c00240f4:	00f82023          	sw	a5,0(a6)
c00240f8:	e3dff06f          	j	c0023f34 <_free_r+0xdc>
c00240fc:	0045a503          	lw	a0,4(a1)
c0024100:	40265613          	srai	a2,a2,0x2
c0024104:	00100793          	li	a5,1
c0024108:	00c79633          	sll	a2,a5,a2
c002410c:	00a66633          	or	a2,a2,a0
c0024110:	00c5a223          	sw	a2,4(a1)
c0024114:	ed5ff06f          	j	c0023fe8 <_free_r+0x190>
c0024118:	15400613          	li	a2,340
c002411c:	00d66c63          	bltu	a2,a3,c0024134 <_free_r+0x2dc>
c0024120:	00f7d693          	srli	a3,a5,0xf
c0024124:	07868813          	addi	a6,a3,120
c0024128:	07768613          	addi	a2,a3,119
c002412c:	00381813          	slli	a6,a6,0x3
c0024130:	e91ff06f          	j	c0023fc0 <_free_r+0x168>
c0024134:	55400613          	li	a2,1364
c0024138:	00d66c63          	bltu	a2,a3,c0024150 <_free_r+0x2f8>
c002413c:	0127d693          	srli	a3,a5,0x12
c0024140:	07d68813          	addi	a6,a3,125
c0024144:	07c68613          	addi	a2,a3,124
c0024148:	00381813          	slli	a6,a6,0x3
c002414c:	e75ff06f          	j	c0023fc0 <_free_r+0x168>
c0024150:	3f800813          	li	a6,1016
c0024154:	07e00613          	li	a2,126
c0024158:	e69ff06f          	j	c0023fc0 <_free_r+0x168>
c002415c:	0017e693          	ori	a3,a5,1
c0024160:	00d72223          	sw	a3,4(a4)
c0024164:	00f62023          	sw	a5,0(a2)
c0024168:	dcdff06f          	j	c0023f34 <_free_r+0xdc>

c002416c <__sfvwrite_r>:
c002416c:	00862783          	lw	a5,8(a2)
c0024170:	30078863          	beqz	a5,c0024480 <__sfvwrite_r+0x314>
c0024174:	00c5d783          	lhu	a5,12(a1)
c0024178:	fd010113          	addi	sp,sp,-48
c002417c:	02812423          	sw	s0,40(sp)
c0024180:	01412c23          	sw	s4,24(sp)
c0024184:	01512a23          	sw	s5,20(sp)
c0024188:	02112623          	sw	ra,44(sp)
c002418c:	02912223          	sw	s1,36(sp)
c0024190:	03212023          	sw	s2,32(sp)
c0024194:	01312e23          	sw	s3,28(sp)
c0024198:	01612823          	sw	s6,16(sp)
c002419c:	01712623          	sw	s7,12(sp)
c00241a0:	01812423          	sw	s8,8(sp)
c00241a4:	01912223          	sw	s9,4(sp)
c00241a8:	01a12023          	sw	s10,0(sp)
c00241ac:	0087f713          	andi	a4,a5,8
c00241b0:	00060a13          	mv	s4,a2
c00241b4:	00050a93          	mv	s5,a0
c00241b8:	00058413          	mv	s0,a1
c00241bc:	08070663          	beqz	a4,c0024248 <__sfvwrite_r+0xdc>
c00241c0:	0105a703          	lw	a4,16(a1)
c00241c4:	08070263          	beqz	a4,c0024248 <__sfvwrite_r+0xdc>
c00241c8:	0027f713          	andi	a4,a5,2
c00241cc:	000a2483          	lw	s1,0(s4)
c00241d0:	08070c63          	beqz	a4,c0024268 <__sfvwrite_r+0xfc>
c00241d4:	02442783          	lw	a5,36(s0)
c00241d8:	01c42583          	lw	a1,28(s0)
c00241dc:	80000b37          	lui	s6,0x80000
c00241e0:	00000993          	li	s3,0
c00241e4:	00000913          	li	s2,0
c00241e8:	c00b4b13          	xori	s6,s6,-1024
c00241ec:	00098613          	mv	a2,s3
c00241f0:	000a8513          	mv	a0,s5
c00241f4:	04090263          	beqz	s2,c0024238 <__sfvwrite_r+0xcc>
c00241f8:	00090693          	mv	a3,s2
c00241fc:	012b7463          	bgeu	s6,s2,c0024204 <__sfvwrite_r+0x98>
c0024200:	000b0693          	mv	a3,s6
c0024204:	000780e7          	jalr	a5
c0024208:	26a05263          	blez	a0,c002446c <__sfvwrite_r+0x300>
c002420c:	008a2783          	lw	a5,8(s4)
c0024210:	00a989b3          	add	s3,s3,a0
c0024214:	40a90933          	sub	s2,s2,a0
c0024218:	40a78533          	sub	a0,a5,a0
c002421c:	00aa2423          	sw	a0,8(s4)
c0024220:	20050063          	beqz	a0,c0024420 <__sfvwrite_r+0x2b4>
c0024224:	02442783          	lw	a5,36(s0)
c0024228:	01c42583          	lw	a1,28(s0)
c002422c:	00098613          	mv	a2,s3
c0024230:	000a8513          	mv	a0,s5
c0024234:	fc0912e3          	bnez	s2,c00241f8 <__sfvwrite_r+0x8c>
c0024238:	0004a983          	lw	s3,0(s1)
c002423c:	0044a903          	lw	s2,4(s1)
c0024240:	00848493          	addi	s1,s1,8
c0024244:	fa9ff06f          	j	c00241ec <__sfvwrite_r+0x80>
c0024248:	00040593          	mv	a1,s0
c002424c:	000a8513          	mv	a0,s5
c0024250:	a74ff0ef          	jal	ra,c00234c4 <__swsetup_r>
c0024254:	3a051463          	bnez	a0,c00245fc <__sfvwrite_r+0x490>
c0024258:	00c45783          	lhu	a5,12(s0)
c002425c:	000a2483          	lw	s1,0(s4)
c0024260:	0027f713          	andi	a4,a5,2
c0024264:	f60718e3          	bnez	a4,c00241d4 <__sfvwrite_r+0x68>
c0024268:	0017f713          	andi	a4,a5,1
c002426c:	12071663          	bnez	a4,c0024398 <__sfvwrite_r+0x22c>
c0024270:	00842c83          	lw	s9,8(s0)
c0024274:	00042503          	lw	a0,0(s0)
c0024278:	80000b37          	lui	s6,0x80000
c002427c:	ffeb4b93          	xori	s7,s6,-2
c0024280:	00000c13          	li	s8,0
c0024284:	00000913          	li	s2,0
c0024288:	fffb4b13          	not	s6,s6
c002428c:	0e090e63          	beqz	s2,c0024388 <__sfvwrite_r+0x21c>
c0024290:	2007f713          	andi	a4,a5,512
c0024294:	24070863          	beqz	a4,c00244e4 <__sfvwrite_r+0x378>
c0024298:	000c8d13          	mv	s10,s9
c002429c:	2d996e63          	bltu	s2,s9,c0024578 <__sfvwrite_r+0x40c>
c00242a0:	4807f713          	andi	a4,a5,1152
c00242a4:	08070a63          	beqz	a4,c0024338 <__sfvwrite_r+0x1cc>
c00242a8:	01442983          	lw	s3,20(s0)
c00242ac:	01042583          	lw	a1,16(s0)
c00242b0:	00190713          	addi	a4,s2,1
c00242b4:	00199693          	slli	a3,s3,0x1
c00242b8:	013686b3          	add	a3,a3,s3
c00242bc:	01f6d993          	srli	s3,a3,0x1f
c00242c0:	40b50d33          	sub	s10,a0,a1
c00242c4:	00d989b3          	add	s3,s3,a3
c00242c8:	4019d993          	srai	s3,s3,0x1
c00242cc:	01a70733          	add	a4,a4,s10
c00242d0:	00098613          	mv	a2,s3
c00242d4:	00e9f663          	bgeu	s3,a4,c00242e0 <__sfvwrite_r+0x174>
c00242d8:	00070993          	mv	s3,a4
c00242dc:	00070613          	mv	a2,a4
c00242e0:	4007f793          	andi	a5,a5,1024
c00242e4:	2c078663          	beqz	a5,c00245b0 <__sfvwrite_r+0x444>
c00242e8:	00060593          	mv	a1,a2
c00242ec:	000a8513          	mv	a0,s5
c00242f0:	3dc030ef          	jal	ra,c00276cc <_malloc_r>
c00242f4:	00050c93          	mv	s9,a0
c00242f8:	2e050a63          	beqz	a0,c00245ec <__sfvwrite_r+0x480>
c00242fc:	01042583          	lw	a1,16(s0)
c0024300:	000d0613          	mv	a2,s10
c0024304:	85df90ef          	jal	ra,c001db60 <memcpy>
c0024308:	00c45783          	lhu	a5,12(s0)
c002430c:	b7f7f793          	andi	a5,a5,-1153
c0024310:	0807e793          	ori	a5,a5,128
c0024314:	00f41623          	sh	a5,12(s0)
c0024318:	01ac8533          	add	a0,s9,s10
c002431c:	41a987b3          	sub	a5,s3,s10
c0024320:	01942823          	sw	s9,16(s0)
c0024324:	00a42023          	sw	a0,0(s0)
c0024328:	01342a23          	sw	s3,20(s0)
c002432c:	00090c93          	mv	s9,s2
c0024330:	00f42423          	sw	a5,8(s0)
c0024334:	00090d13          	mv	s10,s2
c0024338:	000d0613          	mv	a2,s10
c002433c:	000c0593          	mv	a1,s8
c0024340:	481030ef          	jal	ra,c0027fc0 <memmove>
c0024344:	00842703          	lw	a4,8(s0)
c0024348:	00042783          	lw	a5,0(s0)
c002434c:	00090993          	mv	s3,s2
c0024350:	41970cb3          	sub	s9,a4,s9
c0024354:	01a787b3          	add	a5,a5,s10
c0024358:	01942423          	sw	s9,8(s0)
c002435c:	00f42023          	sw	a5,0(s0)
c0024360:	00000913          	li	s2,0
c0024364:	008a2603          	lw	a2,8(s4)
c0024368:	013c0c33          	add	s8,s8,s3
c002436c:	413609b3          	sub	s3,a2,s3
c0024370:	013a2423          	sw	s3,8(s4)
c0024374:	0a098663          	beqz	s3,c0024420 <__sfvwrite_r+0x2b4>
c0024378:	00842c83          	lw	s9,8(s0)
c002437c:	00042503          	lw	a0,0(s0)
c0024380:	00c45783          	lhu	a5,12(s0)
c0024384:	f00916e3          	bnez	s2,c0024290 <__sfvwrite_r+0x124>
c0024388:	0004ac03          	lw	s8,0(s1)
c002438c:	0044a903          	lw	s2,4(s1)
c0024390:	00848493          	addi	s1,s1,8
c0024394:	ef9ff06f          	j	c002428c <__sfvwrite_r+0x120>
c0024398:	00000b13          	li	s6,0
c002439c:	00000513          	li	a0,0
c00243a0:	00000c13          	li	s8,0
c00243a4:	00000993          	li	s3,0
c00243a8:	0e098063          	beqz	s3,c0024488 <__sfvwrite_r+0x31c>
c00243ac:	0e050663          	beqz	a0,c0024498 <__sfvwrite_r+0x32c>
c00243b0:	000b0793          	mv	a5,s6
c00243b4:	00098b93          	mv	s7,s3
c00243b8:	0137f463          	bgeu	a5,s3,c00243c0 <__sfvwrite_r+0x254>
c00243bc:	00078b93          	mv	s7,a5
c00243c0:	00042503          	lw	a0,0(s0)
c00243c4:	01042783          	lw	a5,16(s0)
c00243c8:	01442683          	lw	a3,20(s0)
c00243cc:	00a7f863          	bgeu	a5,a0,c00243dc <__sfvwrite_r+0x270>
c00243d0:	00842903          	lw	s2,8(s0)
c00243d4:	01268933          	add	s2,a3,s2
c00243d8:	0f794063          	blt	s2,s7,c00244b8 <__sfvwrite_r+0x34c>
c00243dc:	1adbc463          	blt	s7,a3,c0024584 <__sfvwrite_r+0x418>
c00243e0:	02442783          	lw	a5,36(s0)
c00243e4:	01c42583          	lw	a1,28(s0)
c00243e8:	000c0613          	mv	a2,s8
c00243ec:	000a8513          	mv	a0,s5
c00243f0:	000780e7          	jalr	a5
c00243f4:	00050913          	mv	s2,a0
c00243f8:	06a05a63          	blez	a0,c002446c <__sfvwrite_r+0x300>
c00243fc:	412b0b33          	sub	s6,s6,s2
c0024400:	00100513          	li	a0,1
c0024404:	040b0c63          	beqz	s6,c002445c <__sfvwrite_r+0x2f0>
c0024408:	008a2603          	lw	a2,8(s4)
c002440c:	012c0c33          	add	s8,s8,s2
c0024410:	412989b3          	sub	s3,s3,s2
c0024414:	41260933          	sub	s2,a2,s2
c0024418:	012a2423          	sw	s2,8(s4)
c002441c:	f80916e3          	bnez	s2,c00243a8 <__sfvwrite_r+0x23c>
c0024420:	00000513          	li	a0,0
c0024424:	02c12083          	lw	ra,44(sp)
c0024428:	02812403          	lw	s0,40(sp)
c002442c:	02412483          	lw	s1,36(sp)
c0024430:	02012903          	lw	s2,32(sp)
c0024434:	01c12983          	lw	s3,28(sp)
c0024438:	01812a03          	lw	s4,24(sp)
c002443c:	01412a83          	lw	s5,20(sp)
c0024440:	01012b03          	lw	s6,16(sp)
c0024444:	00c12b83          	lw	s7,12(sp)
c0024448:	00812c03          	lw	s8,8(sp)
c002444c:	00412c83          	lw	s9,4(sp)
c0024450:	00012d03          	lw	s10,0(sp)
c0024454:	03010113          	addi	sp,sp,48
c0024458:	00008067          	ret
c002445c:	00040593          	mv	a1,s0
c0024460:	000a8513          	mv	a0,s5
c0024464:	c30ff0ef          	jal	ra,c0023894 <_fflush_r>
c0024468:	fa0500e3          	beqz	a0,c0024408 <__sfvwrite_r+0x29c>
c002446c:	00c41783          	lh	a5,12(s0)
c0024470:	0407e793          	ori	a5,a5,64
c0024474:	00f41623          	sh	a5,12(s0)
c0024478:	fff00513          	li	a0,-1
c002447c:	fa9ff06f          	j	c0024424 <__sfvwrite_r+0x2b8>
c0024480:	00000513          	li	a0,0
c0024484:	00008067          	ret
c0024488:	0044a983          	lw	s3,4(s1)
c002448c:	0004ac03          	lw	s8,0(s1)
c0024490:	00848493          	addi	s1,s1,8
c0024494:	fe098ae3          	beqz	s3,c0024488 <__sfvwrite_r+0x31c>
c0024498:	00098613          	mv	a2,s3
c002449c:	00a00593          	li	a1,10
c00244a0:	000c0513          	mv	a0,s8
c00244a4:	255030ef          	jal	ra,c0027ef8 <memchr>
c00244a8:	12050c63          	beqz	a0,c00245e0 <__sfvwrite_r+0x474>
c00244ac:	00150513          	addi	a0,a0,1
c00244b0:	41850b33          	sub	s6,a0,s8
c00244b4:	efdff06f          	j	c00243b0 <__sfvwrite_r+0x244>
c00244b8:	000c0593          	mv	a1,s8
c00244bc:	00090613          	mv	a2,s2
c00244c0:	301030ef          	jal	ra,c0027fc0 <memmove>
c00244c4:	00042783          	lw	a5,0(s0)
c00244c8:	00040593          	mv	a1,s0
c00244cc:	000a8513          	mv	a0,s5
c00244d0:	012787b3          	add	a5,a5,s2
c00244d4:	00f42023          	sw	a5,0(s0)
c00244d8:	bbcff0ef          	jal	ra,c0023894 <_fflush_r>
c00244dc:	f20500e3          	beqz	a0,c00243fc <__sfvwrite_r+0x290>
c00244e0:	f8dff06f          	j	c002446c <__sfvwrite_r+0x300>
c00244e4:	01042783          	lw	a5,16(s0)
c00244e8:	04a7e263          	bltu	a5,a0,c002452c <__sfvwrite_r+0x3c0>
c00244ec:	01442783          	lw	a5,20(s0)
c00244f0:	02f96e63          	bltu	s2,a5,c002452c <__sfvwrite_r+0x3c0>
c00244f4:	00090693          	mv	a3,s2
c00244f8:	012bf463          	bgeu	s7,s2,c0024500 <__sfvwrite_r+0x394>
c00244fc:	000b0693          	mv	a3,s6
c0024500:	02f6c6b3          	div	a3,a3,a5
c0024504:	02442703          	lw	a4,36(s0)
c0024508:	01c42583          	lw	a1,28(s0)
c002450c:	000c0613          	mv	a2,s8
c0024510:	000a8513          	mv	a0,s5
c0024514:	02f686b3          	mul	a3,a3,a5
c0024518:	000700e7          	jalr	a4
c002451c:	00050993          	mv	s3,a0
c0024520:	f4a056e3          	blez	a0,c002446c <__sfvwrite_r+0x300>
c0024524:	41390933          	sub	s2,s2,s3
c0024528:	e3dff06f          	j	c0024364 <__sfvwrite_r+0x1f8>
c002452c:	000c8993          	mv	s3,s9
c0024530:	01997463          	bgeu	s2,s9,c0024538 <__sfvwrite_r+0x3cc>
c0024534:	00090993          	mv	s3,s2
c0024538:	00098613          	mv	a2,s3
c002453c:	000c0593          	mv	a1,s8
c0024540:	281030ef          	jal	ra,c0027fc0 <memmove>
c0024544:	00842783          	lw	a5,8(s0)
c0024548:	00042703          	lw	a4,0(s0)
c002454c:	413787b3          	sub	a5,a5,s3
c0024550:	01370733          	add	a4,a4,s3
c0024554:	00f42423          	sw	a5,8(s0)
c0024558:	00e42023          	sw	a4,0(s0)
c002455c:	fc0794e3          	bnez	a5,c0024524 <__sfvwrite_r+0x3b8>
c0024560:	00040593          	mv	a1,s0
c0024564:	000a8513          	mv	a0,s5
c0024568:	b2cff0ef          	jal	ra,c0023894 <_fflush_r>
c002456c:	f00510e3          	bnez	a0,c002446c <__sfvwrite_r+0x300>
c0024570:	41390933          	sub	s2,s2,s3
c0024574:	df1ff06f          	j	c0024364 <__sfvwrite_r+0x1f8>
c0024578:	00090c93          	mv	s9,s2
c002457c:	00090d13          	mv	s10,s2
c0024580:	db9ff06f          	j	c0024338 <__sfvwrite_r+0x1cc>
c0024584:	000b8613          	mv	a2,s7
c0024588:	000c0593          	mv	a1,s8
c002458c:	235030ef          	jal	ra,c0027fc0 <memmove>
c0024590:	00842703          	lw	a4,8(s0)
c0024594:	00042783          	lw	a5,0(s0)
c0024598:	000b8913          	mv	s2,s7
c002459c:	41770733          	sub	a4,a4,s7
c00245a0:	017787b3          	add	a5,a5,s7
c00245a4:	00e42423          	sw	a4,8(s0)
c00245a8:	00f42023          	sw	a5,0(s0)
c00245ac:	e51ff06f          	j	c00243fc <__sfvwrite_r+0x290>
c00245b0:	000a8513          	mv	a0,s5
c00245b4:	535040ef          	jal	ra,c00292e8 <_realloc_r>
c00245b8:	00050c93          	mv	s9,a0
c00245bc:	d4051ee3          	bnez	a0,c0024318 <__sfvwrite_r+0x1ac>
c00245c0:	01042583          	lw	a1,16(s0)
c00245c4:	000a8513          	mv	a0,s5
c00245c8:	891ff0ef          	jal	ra,c0023e58 <_free_r>
c00245cc:	00c41783          	lh	a5,12(s0)
c00245d0:	00c00713          	li	a4,12
c00245d4:	00eaa023          	sw	a4,0(s5)
c00245d8:	f7f7f793          	andi	a5,a5,-129
c00245dc:	e95ff06f          	j	c0024470 <__sfvwrite_r+0x304>
c00245e0:	00198793          	addi	a5,s3,1
c00245e4:	00078b13          	mv	s6,a5
c00245e8:	dcdff06f          	j	c00243b4 <__sfvwrite_r+0x248>
c00245ec:	00c00713          	li	a4,12
c00245f0:	00c41783          	lh	a5,12(s0)
c00245f4:	00eaa023          	sw	a4,0(s5)
c00245f8:	e79ff06f          	j	c0024470 <__sfvwrite_r+0x304>
c00245fc:	fff00513          	li	a0,-1
c0024600:	e25ff06f          	j	c0024424 <__sfvwrite_r+0x2b8>

c0024604 <_fwalk>:
c0024604:	fe010113          	addi	sp,sp,-32
c0024608:	01212823          	sw	s2,16(sp)
c002460c:	01312623          	sw	s3,12(sp)
c0024610:	01412423          	sw	s4,8(sp)
c0024614:	01512223          	sw	s5,4(sp)
c0024618:	01612023          	sw	s6,0(sp)
c002461c:	00112e23          	sw	ra,28(sp)
c0024620:	00812c23          	sw	s0,24(sp)
c0024624:	00912a23          	sw	s1,20(sp)
c0024628:	00058b13          	mv	s6,a1
c002462c:	2e050a93          	addi	s5,a0,736
c0024630:	00000a13          	li	s4,0
c0024634:	00100993          	li	s3,1
c0024638:	fff00913          	li	s2,-1
c002463c:	004aa483          	lw	s1,4(s5)
c0024640:	008aa403          	lw	s0,8(s5)
c0024644:	fff48493          	addi	s1,s1,-1
c0024648:	0204c663          	bltz	s1,c0024674 <_fwalk+0x70>
c002464c:	00c45783          	lhu	a5,12(s0)
c0024650:	fff48493          	addi	s1,s1,-1
c0024654:	00f9fc63          	bgeu	s3,a5,c002466c <_fwalk+0x68>
c0024658:	00e41783          	lh	a5,14(s0)
c002465c:	00040513          	mv	a0,s0
c0024660:	01278663          	beq	a5,s2,c002466c <_fwalk+0x68>
c0024664:	000b00e7          	jalr	s6 # 80000000 <_end+0xb7f7b780>
c0024668:	00aa6a33          	or	s4,s4,a0
c002466c:	06840413          	addi	s0,s0,104
c0024670:	fd249ee3          	bne	s1,s2,c002464c <_fwalk+0x48>
c0024674:	000aaa83          	lw	s5,0(s5)
c0024678:	fc0a92e3          	bnez	s5,c002463c <_fwalk+0x38>
c002467c:	01c12083          	lw	ra,28(sp)
c0024680:	01812403          	lw	s0,24(sp)
c0024684:	01412483          	lw	s1,20(sp)
c0024688:	01012903          	lw	s2,16(sp)
c002468c:	00c12983          	lw	s3,12(sp)
c0024690:	00412a83          	lw	s5,4(sp)
c0024694:	00012b03          	lw	s6,0(sp)
c0024698:	000a0513          	mv	a0,s4
c002469c:	00812a03          	lw	s4,8(sp)
c00246a0:	02010113          	addi	sp,sp,32
c00246a4:	00008067          	ret

c00246a8 <_fwalk_reent>:
c00246a8:	fd010113          	addi	sp,sp,-48
c00246ac:	03212023          	sw	s2,32(sp)
c00246b0:	01312e23          	sw	s3,28(sp)
c00246b4:	01412c23          	sw	s4,24(sp)
c00246b8:	01512a23          	sw	s5,20(sp)
c00246bc:	01612823          	sw	s6,16(sp)
c00246c0:	01712623          	sw	s7,12(sp)
c00246c4:	02112623          	sw	ra,44(sp)
c00246c8:	02812423          	sw	s0,40(sp)
c00246cc:	02912223          	sw	s1,36(sp)
c00246d0:	00050a93          	mv	s5,a0
c00246d4:	00058b93          	mv	s7,a1
c00246d8:	2e050b13          	addi	s6,a0,736
c00246dc:	00000a13          	li	s4,0
c00246e0:	00100993          	li	s3,1
c00246e4:	fff00913          	li	s2,-1
c00246e8:	004b2483          	lw	s1,4(s6)
c00246ec:	008b2403          	lw	s0,8(s6)
c00246f0:	fff48493          	addi	s1,s1,-1
c00246f4:	0204c863          	bltz	s1,c0024724 <_fwalk_reent+0x7c>
c00246f8:	00c45783          	lhu	a5,12(s0)
c00246fc:	fff48493          	addi	s1,s1,-1
c0024700:	00f9fe63          	bgeu	s3,a5,c002471c <_fwalk_reent+0x74>
c0024704:	00e41783          	lh	a5,14(s0)
c0024708:	00040593          	mv	a1,s0
c002470c:	000a8513          	mv	a0,s5
c0024710:	01278663          	beq	a5,s2,c002471c <_fwalk_reent+0x74>
c0024714:	000b80e7          	jalr	s7
c0024718:	00aa6a33          	or	s4,s4,a0
c002471c:	06840413          	addi	s0,s0,104
c0024720:	fd249ce3          	bne	s1,s2,c00246f8 <_fwalk_reent+0x50>
c0024724:	000b2b03          	lw	s6,0(s6)
c0024728:	fc0b10e3          	bnez	s6,c00246e8 <_fwalk_reent+0x40>
c002472c:	02c12083          	lw	ra,44(sp)
c0024730:	02812403          	lw	s0,40(sp)
c0024734:	02412483          	lw	s1,36(sp)
c0024738:	02012903          	lw	s2,32(sp)
c002473c:	01c12983          	lw	s3,28(sp)
c0024740:	01412a83          	lw	s5,20(sp)
c0024744:	01012b03          	lw	s6,16(sp)
c0024748:	00c12b83          	lw	s7,12(sp)
c002474c:	000a0513          	mv	a0,s4
c0024750:	01812a03          	lw	s4,24(sp)
c0024754:	03010113          	addi	sp,sp,48
c0024758:	00008067          	ret

c002475c <eshdn1>:
c002475c:	00450693          	addi	a3,a0,4
c0024760:	00000793          	li	a5,0
c0024764:	01a50513          	addi	a0,a0,26
c0024768:	ffff8837          	lui	a6,0xffff8
c002476c:	01c0006f          	j	c0024788 <eshdn1+0x2c>
c0024770:	00179793          	slli	a5,a5,0x1
c0024774:	00e69023          	sh	a4,0(a3)
c0024778:	01079793          	slli	a5,a5,0x10
c002477c:	00268693          	addi	a3,a3,2
c0024780:	0107d793          	srli	a5,a5,0x10
c0024784:	02d50e63          	beq	a0,a3,c00247c0 <eshdn1+0x64>
c0024788:	0006d703          	lhu	a4,0(a3)
c002478c:	00177613          	andi	a2,a4,1
c0024790:	00060463          	beqz	a2,c0024798 <eshdn1+0x3c>
c0024794:	0017e793          	ori	a5,a5,1
c0024798:	00175713          	srli	a4,a4,0x1
c002479c:	0027f613          	andi	a2,a5,2
c00247a0:	010765b3          	or	a1,a4,a6
c00247a4:	fc0606e3          	beqz	a2,c0024770 <eshdn1+0x14>
c00247a8:	00179793          	slli	a5,a5,0x1
c00247ac:	00b69023          	sh	a1,0(a3)
c00247b0:	01079793          	slli	a5,a5,0x10
c00247b4:	00268693          	addi	a3,a3,2
c00247b8:	0107d793          	srli	a5,a5,0x10
c00247bc:	fcd516e3          	bne	a0,a3,c0024788 <eshdn1+0x2c>
c00247c0:	00008067          	ret

c00247c4 <eshup1>:
c00247c4:	01850693          	addi	a3,a0,24
c00247c8:	00000713          	li	a4,0
c00247cc:	00250513          	addi	a0,a0,2
c00247d0:	01c0006f          	j	c00247ec <eshup1+0x28>
c00247d4:	00171713          	slli	a4,a4,0x1
c00247d8:	00f69023          	sh	a5,0(a3)
c00247dc:	01071713          	slli	a4,a4,0x10
c00247e0:	ffe68693          	addi	a3,a3,-2
c00247e4:	01075713          	srli	a4,a4,0x10
c00247e8:	04d50463          	beq	a0,a3,c0024830 <eshup1+0x6c>
c00247ec:	0006d783          	lhu	a5,0(a3)
c00247f0:	01079613          	slli	a2,a5,0x10
c00247f4:	41065613          	srai	a2,a2,0x10
c00247f8:	00179793          	slli	a5,a5,0x1
c00247fc:	00065463          	bgez	a2,c0024804 <eshup1+0x40>
c0024800:	00176713          	ori	a4,a4,1
c0024804:	01079793          	slli	a5,a5,0x10
c0024808:	0107d793          	srli	a5,a5,0x10
c002480c:	00277613          	andi	a2,a4,2
c0024810:	0017e593          	ori	a1,a5,1
c0024814:	fc0600e3          	beqz	a2,c00247d4 <eshup1+0x10>
c0024818:	00171713          	slli	a4,a4,0x1
c002481c:	00b69023          	sh	a1,0(a3)
c0024820:	01071713          	slli	a4,a4,0x10
c0024824:	ffe68693          	addi	a3,a3,-2
c0024828:	01075713          	srli	a4,a4,0x10
c002482c:	fcd510e3          	bne	a0,a3,c00247ec <eshup1+0x28>
c0024830:	00008067          	ret

c0024834 <m16m>:
c0024834:	fe010113          	addi	sp,sp,-32
c0024838:	00010e37          	lui	t3,0x10
c002483c:	00011d23          	sh	zero,26(sp)
c0024840:	00011e23          	sh	zero,28(sp)
c0024844:	01858593          	addi	a1,a1,24
c0024848:	01c10793          	addi	a5,sp,28
c002484c:	00810813          	addi	a6,sp,8
c0024850:	fffe0e13          	addi	t3,t3,-1 # ffff <_STACK_SIZE+0xefff>
c0024854:	0005d703          	lhu	a4,0(a1)
c0024858:	ffe78793          	addi	a5,a5,-2
c002485c:	ffe58593          	addi	a1,a1,-2
c0024860:	02071863          	bnez	a4,c0024890 <m16m+0x5c>
c0024864:	fe079f23          	sh	zero,-2(a5)
c0024868:	ff0796e3          	bne	a5,a6,c0024854 <m16m+0x20>
c002486c:	00460613          	addi	a2,a2,4
c0024870:	01e10693          	addi	a3,sp,30
c0024874:	0007d703          	lhu	a4,0(a5)
c0024878:	00278793          	addi	a5,a5,2
c002487c:	00260613          	addi	a2,a2,2
c0024880:	fee61f23          	sh	a4,-2(a2)
c0024884:	fed798e3          	bne	a5,a3,c0024874 <m16m+0x40>
c0024888:	02010113          	addi	sp,sp,32
c002488c:	00008067          	ret
c0024890:	02a70733          	mul	a4,a4,a0
c0024894:	0027d883          	lhu	a7,2(a5)
c0024898:	0007d303          	lhu	t1,0(a5)
c002489c:	01c776b3          	and	a3,a4,t3
c00248a0:	011686b3          	add	a3,a3,a7
c00248a4:	01075713          	srli	a4,a4,0x10
c00248a8:	0106d893          	srli	a7,a3,0x10
c00248ac:	00670733          	add	a4,a4,t1
c00248b0:	01170733          	add	a4,a4,a7
c00248b4:	01075893          	srli	a7,a4,0x10
c00248b8:	00d79123          	sh	a3,2(a5)
c00248bc:	00e79023          	sh	a4,0(a5)
c00248c0:	ff179f23          	sh	a7,-2(a5)
c00248c4:	f90798e3          	bne	a5,a6,c0024854 <m16m+0x20>
c00248c8:	fa5ff06f          	j	c002486c <m16m+0x38>

c00248cc <emovo.constprop.0>:
c00248cc:	00055703          	lhu	a4,0(a0)
c00248d0:	00255783          	lhu	a5,2(a0)
c00248d4:	00070663          	beqz	a4,c00248e0 <emovo.constprop.0+0x14>
c00248d8:	00008737          	lui	a4,0x8
c00248dc:	00e7e7b3          	or	a5,a5,a4
c00248e0:	00f59923          	sh	a5,18(a1)
c00248e4:	00255703          	lhu	a4,2(a0)
c00248e8:	000087b7          	lui	a5,0x8
c00248ec:	fff78793          	addi	a5,a5,-1 # 7fff <_STACK_SIZE+0x6fff>
c00248f0:	02f70463          	beq	a4,a5,c0024918 <emovo.constprop.0+0x4c>
c00248f4:	00650793          	addi	a5,a0,6
c00248f8:	01058593          	addi	a1,a1,16
c00248fc:	01850513          	addi	a0,a0,24
c0024900:	0007d703          	lhu	a4,0(a5)
c0024904:	00278793          	addi	a5,a5,2
c0024908:	ffe58593          	addi	a1,a1,-2
c002490c:	00e59123          	sh	a4,2(a1)
c0024910:	fea798e3          	bne	a5,a0,c0024900 <emovo.constprop.0+0x34>
c0024914:	00008067          	ret
c0024918:	00650793          	addi	a5,a0,6
c002491c:	01a50513          	addi	a0,a0,26
c0024920:	0007d703          	lhu	a4,0(a5)
c0024924:	00278793          	addi	a5,a5,2
c0024928:	02071a63          	bnez	a4,c002495c <emovo.constprop.0+0x90>
c002492c:	fea79ae3          	bne	a5,a0,c0024920 <emovo.constprop.0+0x54>
c0024930:	01258713          	addi	a4,a1,18
c0024934:	00058793          	mv	a5,a1
c0024938:	00278793          	addi	a5,a5,2
c002493c:	fe079f23          	sh	zero,-2(a5)
c0024940:	fef71ce3          	bne	a4,a5,c0024938 <emovo.constprop.0+0x6c>
c0024944:	0125d783          	lhu	a5,18(a1)
c0024948:	00008737          	lui	a4,0x8
c002494c:	fff70713          	addi	a4,a4,-1 # 7fff <_STACK_SIZE+0x6fff>
c0024950:	00e7e7b3          	or	a5,a5,a4
c0024954:	00f59923          	sh	a5,18(a1)
c0024958:	00008067          	ret
c002495c:	01058713          	addi	a4,a1,16
c0024960:	00058793          	mv	a5,a1
c0024964:	00278793          	addi	a5,a5,2
c0024968:	fe079f23          	sh	zero,-2(a5)
c002496c:	fef71ce3          	bne	a4,a5,c0024964 <emovo.constprop.0+0x98>
c0024970:	ffffc7b7          	lui	a5,0xffffc
c0024974:	00f59823          	sh	a5,16(a1)
c0024978:	ffff87b7          	lui	a5,0xffff8
c002497c:	fff7c793          	not	a5,a5
c0024980:	00f59923          	sh	a5,18(a1)
c0024984:	00008067          	ret

c0024988 <enormlz>:
c0024988:	00455783          	lhu	a5,4(a0)
c002498c:	ff010113          	addi	sp,sp,-16
c0024990:	00912223          	sw	s1,4(sp)
c0024994:	00112623          	sw	ra,12(sp)
c0024998:	00812423          	sw	s0,8(sp)
c002499c:	01212023          	sw	s2,0(sp)
c00249a0:	00050493          	mv	s1,a0
c00249a4:	0c079c63          	bnez	a5,c0024a7c <enormlz+0xf4>
c00249a8:	00655703          	lhu	a4,6(a0)
c00249ac:	00000413          	li	s0,0
c00249b0:	01071793          	slli	a5,a4,0x10
c00249b4:	4107d793          	srai	a5,a5,0x10
c00249b8:	0a07c463          	bltz	a5,c0024a60 <enormlz+0xd8>
c00249bc:	01a50693          	addi	a3,a0,26
c00249c0:	0a000613          	li	a2,160
c00249c4:	02071863          	bnez	a4,c00249f4 <enormlz+0x6c>
c00249c8:	00648793          	addi	a5,s1,6
c00249cc:	0080006f          	j	c00249d4 <enormlz+0x4c>
c00249d0:	0007d703          	lhu	a4,0(a5) # ffff8000 <_end+0x37f73780>
c00249d4:	00278793          	addi	a5,a5,2
c00249d8:	fee79e23          	sh	a4,-4(a5)
c00249dc:	fed79ae3          	bne	a5,a3,c00249d0 <enormlz+0x48>
c00249e0:	00049c23          	sh	zero,24(s1)
c00249e4:	01040413          	addi	s0,s0,16
c00249e8:	06c40c63          	beq	s0,a2,c0024a60 <enormlz+0xd8>
c00249ec:	0064d703          	lhu	a4,6(s1)
c00249f0:	fc070ce3          	beqz	a4,c00249c8 <enormlz+0x40>
c00249f4:	f0077793          	andi	a5,a4,-256
c00249f8:	04079063          	bnez	a5,c0024a38 <enormlz+0xb0>
c00249fc:	01848513          	addi	a0,s1,24
c0024a00:	00248593          	addi	a1,s1,2
c0024a04:	00000793          	li	a5,0
c0024a08:	00050713          	mv	a4,a0
c0024a0c:	00075683          	lhu	a3,0(a4)
c0024a10:	ffe70713          	addi	a4,a4,-2
c0024a14:	00869613          	slli	a2,a3,0x8
c0024a18:	00c7e7b3          	or	a5,a5,a2
c0024a1c:	00f71123          	sh	a5,2(a4)
c0024a20:	0086d793          	srli	a5,a3,0x8
c0024a24:	fee594e3          	bne	a1,a4,c0024a0c <enormlz+0x84>
c0024a28:	0064d703          	lhu	a4,6(s1)
c0024a2c:	00840413          	addi	s0,s0,8
c0024a30:	f0077793          	andi	a5,a4,-256
c0024a34:	fc0788e3          	beqz	a5,c0024a04 <enormlz+0x7c>
c0024a38:	0a000913          	li	s2,160
c0024a3c:	0140006f          	j	c0024a50 <enormlz+0xc8>
c0024a40:	00140413          	addi	s0,s0,1
c0024a44:	d81ff0ef          	jal	ra,c00247c4 <eshup1>
c0024a48:	00894c63          	blt	s2,s0,c0024a60 <enormlz+0xd8>
c0024a4c:	0064d703          	lhu	a4,6(s1)
c0024a50:	01071713          	slli	a4,a4,0x10
c0024a54:	41075713          	srai	a4,a4,0x10
c0024a58:	00048513          	mv	a0,s1
c0024a5c:	fe0752e3          	bgez	a4,c0024a40 <enormlz+0xb8>
c0024a60:	00c12083          	lw	ra,12(sp)
c0024a64:	00040513          	mv	a0,s0
c0024a68:	00812403          	lw	s0,8(sp)
c0024a6c:	00412483          	lw	s1,4(sp)
c0024a70:	00012903          	lw	s2,0(sp)
c0024a74:	01010113          	addi	sp,sp,16
c0024a78:	00008067          	ret
c0024a7c:	f007f713          	andi	a4,a5,-256
c0024a80:	00000413          	li	s0,0
c0024a84:	04071063          	bnez	a4,c0024ac4 <enormlz+0x13c>
c0024a88:	f6f00913          	li	s2,-145
c0024a8c:	0140006f          	j	c0024aa0 <enormlz+0x118>
c0024a90:	fff40413          	addi	s0,s0,-1
c0024a94:	cc9ff0ef          	jal	ra,c002475c <eshdn1>
c0024a98:	fd2404e3          	beq	s0,s2,c0024a60 <enormlz+0xd8>
c0024a9c:	0044d783          	lhu	a5,4(s1)
c0024aa0:	00048513          	mv	a0,s1
c0024aa4:	fe0796e3          	bnez	a5,c0024a90 <enormlz+0x108>
c0024aa8:	00c12083          	lw	ra,12(sp)
c0024aac:	00040513          	mv	a0,s0
c0024ab0:	00812403          	lw	s0,8(sp)
c0024ab4:	00412483          	lw	s1,4(sp)
c0024ab8:	00012903          	lw	s2,0(sp)
c0024abc:	01010113          	addi	sp,sp,16
c0024ac0:	00008067          	ret
c0024ac4:	00450693          	addi	a3,a0,4
c0024ac8:	01a50593          	addi	a1,a0,26
c0024acc:	00000713          	li	a4,0
c0024ad0:	0080006f          	j	c0024ad8 <enormlz+0x150>
c0024ad4:	0006d783          	lhu	a5,0(a3)
c0024ad8:	0087d613          	srli	a2,a5,0x8
c0024adc:	00c76733          	or	a4,a4,a2
c0024ae0:	00879793          	slli	a5,a5,0x8
c0024ae4:	00e69023          	sh	a4,0(a3)
c0024ae8:	01079713          	slli	a4,a5,0x10
c0024aec:	00268693          	addi	a3,a3,2
c0024af0:	01075713          	srli	a4,a4,0x10
c0024af4:	fed590e3          	bne	a1,a3,c0024ad4 <enormlz+0x14c>
c0024af8:	0044d783          	lhu	a5,4(s1)
c0024afc:	ff800413          	li	s0,-8
c0024b00:	f89ff06f          	j	c0024a88 <enormlz+0x100>

c0024b04 <eshift.part.0>:
c0024b04:	fe010113          	addi	sp,sp,-32
c0024b08:	00812c23          	sw	s0,24(sp)
c0024b0c:	00912a23          	sw	s1,20(sp)
c0024b10:	00112e23          	sw	ra,28(sp)
c0024b14:	01212823          	sw	s2,16(sp)
c0024b18:	01312623          	sw	s3,12(sp)
c0024b1c:	00058493          	mv	s1,a1
c0024b20:	00050413          	mv	s0,a0
c0024b24:	0a05c463          	bltz	a1,c0024bcc <eshift.part.0+0xc8>
c0024b28:	00f00793          	li	a5,15
c0024b2c:	00058613          	mv	a2,a1
c0024b30:	00450513          	addi	a0,a0,4
c0024b34:	01840693          	addi	a3,s0,24
c0024b38:	00f00593          	li	a1,15
c0024b3c:	0297d463          	bge	a5,s1,c0024b64 <eshift.part.0+0x60>
c0024b40:	00050793          	mv	a5,a0
c0024b44:	0027d703          	lhu	a4,2(a5)
c0024b48:	00278793          	addi	a5,a5,2
c0024b4c:	fee79f23          	sh	a4,-2(a5)
c0024b50:	fef69ae3          	bne	a3,a5,c0024b44 <eshift.part.0+0x40>
c0024b54:	00041c23          	sh	zero,24(s0)
c0024b58:	ff060613          	addi	a2,a2,-16
c0024b5c:	fec5c2e3          	blt	a1,a2,c0024b40 <eshift.part.0+0x3c>
c0024b60:	00f4f493          	andi	s1,s1,15
c0024b64:	00700793          	li	a5,7
c0024b68:	0297d863          	bge	a5,s1,c0024b98 <eshift.part.0+0x94>
c0024b6c:	01840713          	addi	a4,s0,24
c0024b70:	00240593          	addi	a1,s0,2
c0024b74:	00000793          	li	a5,0
c0024b78:	00075683          	lhu	a3,0(a4)
c0024b7c:	ffe70713          	addi	a4,a4,-2
c0024b80:	00869613          	slli	a2,a3,0x8
c0024b84:	00c7e7b3          	or	a5,a5,a2
c0024b88:	00f71123          	sh	a5,2(a4)
c0024b8c:	0086d793          	srli	a5,a3,0x8
c0024b90:	fee594e3          	bne	a1,a4,c0024b78 <eshift.part.0+0x74>
c0024b94:	ff848493          	addi	s1,s1,-8
c0024b98:	00048a63          	beqz	s1,c0024bac <eshift.part.0+0xa8>
c0024b9c:	fff48493          	addi	s1,s1,-1
c0024ba0:	00040513          	mv	a0,s0
c0024ba4:	c21ff0ef          	jal	ra,c00247c4 <eshup1>
c0024ba8:	fe049ae3          	bnez	s1,c0024b9c <eshift.part.0+0x98>
c0024bac:	00000513          	li	a0,0
c0024bb0:	01c12083          	lw	ra,28(sp)
c0024bb4:	01812403          	lw	s0,24(sp)
c0024bb8:	01412483          	lw	s1,20(sp)
c0024bbc:	01012903          	lw	s2,16(sp)
c0024bc0:	00c12983          	lw	s3,12(sp)
c0024bc4:	02010113          	addi	sp,sp,32
c0024bc8:	00008067          	ret
c0024bcc:	ff100793          	li	a5,-15
c0024bd0:	40b00933          	neg	s2,a1
c0024bd4:	12f5de63          	bge	a1,a5,c0024d10 <eshift.part.0+0x20c>
c0024bd8:	01850593          	addi	a1,a0,24
c0024bdc:	00000993          	li	s3,0
c0024be0:	00450693          	addi	a3,a0,4
c0024be4:	00f00613          	li	a2,15
c0024be8:	01845703          	lhu	a4,24(s0)
c0024bec:	00058793          	mv	a5,a1
c0024bf0:	00e9e9b3          	or	s3,s3,a4
c0024bf4:	ffe7d703          	lhu	a4,-2(a5)
c0024bf8:	ffe78793          	addi	a5,a5,-2
c0024bfc:	00e79123          	sh	a4,2(a5)
c0024c00:	fed79ae3          	bne	a5,a3,c0024bf4 <eshift.part.0+0xf0>
c0024c04:	00041223          	sh	zero,4(s0)
c0024c08:	ff090913          	addi	s2,s2,-16
c0024c0c:	fd264ee3          	blt	a2,s2,c0024be8 <eshift.part.0+0xe4>
c0024c10:	ff000913          	li	s2,-16
c0024c14:	ff100713          	li	a4,-15
c0024c18:	40990933          	sub	s2,s2,s1
c0024c1c:	00000793          	li	a5,0
c0024c20:	0ae4c663          	blt	s1,a4,c0024ccc <eshift.part.0+0x1c8>
c0024c24:	00f90933          	add	s2,s2,a5
c0024c28:	00700793          	li	a5,7
c0024c2c:	0527ca63          	blt	a5,s2,c0024c80 <eshift.part.0+0x17c>
c0024c30:	0c090263          	beqz	s2,c0024cf4 <eshift.part.0+0x1f0>
c0024c34:	01845783          	lhu	a5,24(s0)
c0024c38:	fff90913          	addi	s2,s2,-1
c0024c3c:	00040513          	mv	a0,s0
c0024c40:	0017f793          	andi	a5,a5,1
c0024c44:	0137e9b3          	or	s3,a5,s3
c0024c48:	b15ff0ef          	jal	ra,c002475c <eshdn1>
c0024c4c:	fe0914e3          	bnez	s2,c0024c34 <eshift.part.0+0x130>
c0024c50:	01099793          	slli	a5,s3,0x10
c0024c54:	4107d793          	srai	a5,a5,0x10
c0024c58:	08079663          	bnez	a5,c0024ce4 <eshift.part.0+0x1e0>
c0024c5c:	01099513          	slli	a0,s3,0x10
c0024c60:	01055513          	srli	a0,a0,0x10
c0024c64:	01c12083          	lw	ra,28(sp)
c0024c68:	01812403          	lw	s0,24(sp)
c0024c6c:	01412483          	lw	s1,20(sp)
c0024c70:	01012903          	lw	s2,16(sp)
c0024c74:	00c12983          	lw	s3,12(sp)
c0024c78:	02010113          	addi	sp,sp,32
c0024c7c:	00008067          	ret
c0024c80:	01099993          	slli	s3,s3,0x10
c0024c84:	4109d993          	srai	s3,s3,0x10
c0024c88:	01844783          	lbu	a5,24(s0)
c0024c8c:	01a40593          	addi	a1,s0,26
c0024c90:	00f9e9b3          	or	s3,s3,a5
c0024c94:	01099993          	slli	s3,s3,0x10
c0024c98:	0109d993          	srli	s3,s3,0x10
c0024c9c:	00000793          	li	a5,0
c0024ca0:	0006d703          	lhu	a4,0(a3)
c0024ca4:	00268693          	addi	a3,a3,2
c0024ca8:	00875613          	srli	a2,a4,0x8
c0024cac:	00c7e7b3          	or	a5,a5,a2
c0024cb0:	00871713          	slli	a4,a4,0x8
c0024cb4:	fef69f23          	sh	a5,-2(a3)
c0024cb8:	01071793          	slli	a5,a4,0x10
c0024cbc:	0107d793          	srli	a5,a5,0x10
c0024cc0:	fed590e3          	bne	a1,a3,c0024ca0 <eshift.part.0+0x19c>
c0024cc4:	ff890913          	addi	s2,s2,-8
c0024cc8:	f69ff06f          	j	c0024c30 <eshift.part.0+0x12c>
c0024ccc:	ff097793          	andi	a5,s2,-16
c0024cd0:	40f007b3          	neg	a5,a5
c0024cd4:	00f90933          	add	s2,s2,a5
c0024cd8:	00700793          	li	a5,7
c0024cdc:	f527dae3          	bge	a5,s2,c0024c30 <eshift.part.0+0x12c>
c0024ce0:	fa1ff06f          	j	c0024c80 <eshift.part.0+0x17c>
c0024ce4:	00100993          	li	s3,1
c0024ce8:	01099513          	slli	a0,s3,0x10
c0024cec:	01055513          	srli	a0,a0,0x10
c0024cf0:	f75ff06f          	j	c0024c64 <eshift.part.0+0x160>
c0024cf4:	00098513          	mv	a0,s3
c0024cf8:	00099863          	bnez	s3,c0024d08 <eshift.part.0+0x204>
c0024cfc:	01051513          	slli	a0,a0,0x10
c0024d00:	01055513          	srli	a0,a0,0x10
c0024d04:	eadff06f          	j	c0024bb0 <eshift.part.0+0xac>
c0024d08:	00100513          	li	a0,1
c0024d0c:	ff1ff06f          	j	c0024cfc <eshift.part.0+0x1f8>
c0024d10:	ff900793          	li	a5,-7
c0024d14:	00000993          	li	s3,0
c0024d18:	00450693          	addi	a3,a0,4
c0024d1c:	f6f5c6e3          	blt	a1,a5,c0024c88 <eshift.part.0+0x184>
c0024d20:	f15ff06f          	j	c0024c34 <eshift.part.0+0x130>

c0024d24 <emovi>:
c0024d24:	01255783          	lhu	a5,18(a0)
c0024d28:	00008637          	lui	a2,0x8
c0024d2c:	fff60613          	addi	a2,a2,-1 # 7fff <_STACK_SIZE+0x6fff>
c0024d30:	00f7d793          	srli	a5,a5,0xf
c0024d34:	40f007b3          	neg	a5,a5
c0024d38:	00f59023          	sh	a5,0(a1)
c0024d3c:	01255683          	lhu	a3,18(a0)
c0024d40:	01050793          	addi	a5,a0,16
c0024d44:	00458713          	addi	a4,a1,4
c0024d48:	00d676b3          	and	a3,a2,a3
c0024d4c:	00d59123          	sh	a3,2(a1)
c0024d50:	02c68663          	beq	a3,a2,c0024d7c <emovi+0x58>
c0024d54:	00658713          	addi	a4,a1,6
c0024d58:	00059223          	sh	zero,4(a1)
c0024d5c:	ffe50513          	addi	a0,a0,-2
c0024d60:	0007d683          	lhu	a3,0(a5)
c0024d64:	ffe78793          	addi	a5,a5,-2
c0024d68:	00270713          	addi	a4,a4,2
c0024d6c:	fed71f23          	sh	a3,-2(a4)
c0024d70:	fef518e3          	bne	a0,a5,c0024d60 <emovi+0x3c>
c0024d74:	00059c23          	sh	zero,24(a1)
c0024d78:	00008067          	ret
c0024d7c:	01255603          	lhu	a2,18(a0)
c0024d80:	00c6f633          	and	a2,a3,a2
c0024d84:	00d61e63          	bne	a2,a3,c0024da0 <emovi+0x7c>
c0024d88:	01250813          	addi	a6,a0,18
c0024d8c:	00050693          	mv	a3,a0
c0024d90:	0006d603          	lhu	a2,0(a3)
c0024d94:	00268693          	addi	a3,a3,2
c0024d98:	00061e63          	bnez	a2,c0024db4 <emovi+0x90>
c0024d9c:	ff069ae3          	bne	a3,a6,c0024d90 <emovi+0x6c>
c0024da0:	01a58593          	addi	a1,a1,26
c0024da4:	00270713          	addi	a4,a4,2
c0024da8:	fe071f23          	sh	zero,-2(a4)
c0024dac:	fee59ce3          	bne	a1,a4,c0024da4 <emovi+0x80>
c0024db0:	00008067          	ret
c0024db4:	00658713          	addi	a4,a1,6
c0024db8:	00059223          	sh	zero,4(a1)
c0024dbc:	ffc50513          	addi	a0,a0,-4
c0024dc0:	0007d683          	lhu	a3,0(a5)
c0024dc4:	ffe78793          	addi	a5,a5,-2
c0024dc8:	00270713          	addi	a4,a4,2
c0024dcc:	fed71f23          	sh	a3,-2(a4)
c0024dd0:	fea798e3          	bne	a5,a0,c0024dc0 <emovi+0x9c>
c0024dd4:	00008067          	ret

c0024dd8 <ecmp>:
c0024dd8:	01255783          	lhu	a5,18(a0)
c0024ddc:	fb010113          	addi	sp,sp,-80
c0024de0:	04812423          	sw	s0,72(sp)
c0024de4:	fff7c793          	not	a5,a5
c0024de8:	04112623          	sw	ra,76(sp)
c0024dec:	01179713          	slli	a4,a5,0x11
c0024df0:	00058413          	mv	s0,a1
c0024df4:	00071e63          	bnez	a4,c0024e10 <ecmp+0x38>
c0024df8:	01250693          	addi	a3,a0,18
c0024dfc:	00050793          	mv	a5,a0
c0024e00:	0007d703          	lhu	a4,0(a5)
c0024e04:	00278793          	addi	a5,a5,2
c0024e08:	08071c63          	bnez	a4,c0024ea0 <ecmp+0xc8>
c0024e0c:	fed79ae3          	bne	a5,a3,c0024e00 <ecmp+0x28>
c0024e10:	01245783          	lhu	a5,18(s0)
c0024e14:	fff7c793          	not	a5,a5
c0024e18:	01179713          	slli	a4,a5,0x11
c0024e1c:	06070063          	beqz	a4,c0024e7c <ecmp+0xa4>
c0024e20:	00810593          	addi	a1,sp,8
c0024e24:	f01ff0ef          	jal	ra,c0024d24 <emovi>
c0024e28:	02410593          	addi	a1,sp,36
c0024e2c:	00040513          	mv	a0,s0
c0024e30:	ef5ff0ef          	jal	ra,c0024d24 <emovi>
c0024e34:	00815583          	lhu	a1,8(sp)
c0024e38:	02415503          	lhu	a0,36(sp)
c0024e3c:	06b50c63          	beq	a0,a1,c0024eb4 <ecmp+0xdc>
c0024e40:	00a10793          	addi	a5,sp,10
c0024e44:	02610713          	addi	a4,sp,38
c0024e48:	02010613          	addi	a2,sp,32
c0024e4c:	0007d683          	lhu	a3,0(a5)
c0024e50:	00278793          	addi	a5,a5,2
c0024e54:	0a069863          	bnez	a3,c0024f04 <ecmp+0x12c>
c0024e58:	00075683          	lhu	a3,0(a4)
c0024e5c:	00270713          	addi	a4,a4,2
c0024e60:	0a069263          	bnez	a3,c0024f04 <ecmp+0x12c>
c0024e64:	fef614e3          	bne	a2,a5,c0024e4c <ecmp+0x74>
c0024e68:	00000513          	li	a0,0
c0024e6c:	04c12083          	lw	ra,76(sp)
c0024e70:	04812403          	lw	s0,72(sp)
c0024e74:	05010113          	addi	sp,sp,80
c0024e78:	00008067          	ret
c0024e7c:	00040793          	mv	a5,s0
c0024e80:	0007d703          	lhu	a4,0(a5)
c0024e84:	01240693          	addi	a3,s0,18
c0024e88:	00278793          	addi	a5,a5,2
c0024e8c:	00071a63          	bnez	a4,c0024ea0 <ecmp+0xc8>
c0024e90:	f8d788e3          	beq	a5,a3,c0024e20 <ecmp+0x48>
c0024e94:	0007d703          	lhu	a4,0(a5)
c0024e98:	00278793          	addi	a5,a5,2
c0024e9c:	fe070ae3          	beqz	a4,c0024e90 <ecmp+0xb8>
c0024ea0:	04c12083          	lw	ra,76(sp)
c0024ea4:	04812403          	lw	s0,72(sp)
c0024ea8:	ffe00513          	li	a0,-2
c0024eac:	05010113          	addi	sp,sp,80
c0024eb0:	00008067          	ret
c0024eb4:	00a15603          	lhu	a2,10(sp)
c0024eb8:	02615683          	lhu	a3,38(sp)
c0024ebc:	00153513          	seqz	a0,a0
c0024ec0:	00a10713          	addi	a4,sp,10
c0024ec4:	02610793          	addi	a5,sp,38
c0024ec8:	00151513          	slli	a0,a0,0x1
c0024ecc:	fff50513          	addi	a0,a0,-1
c0024ed0:	03c10593          	addi	a1,sp,60
c0024ed4:	00278793          	addi	a5,a5,2
c0024ed8:	00270713          	addi	a4,a4,2
c0024edc:	00d61e63          	bne	a2,a3,c0024ef8 <ecmp+0x120>
c0024ee0:	f8b784e3          	beq	a5,a1,c0024e68 <ecmp+0x90>
c0024ee4:	00075603          	lhu	a2,0(a4)
c0024ee8:	0007d683          	lhu	a3,0(a5)
c0024eec:	00270713          	addi	a4,a4,2
c0024ef0:	00278793          	addi	a5,a5,2
c0024ef4:	fed606e3          	beq	a2,a3,c0024ee0 <ecmp+0x108>
c0024ef8:	f6c6eae3          	bltu	a3,a2,c0024e6c <ecmp+0x94>
c0024efc:	40a00533          	neg	a0,a0
c0024f00:	f6dff06f          	j	c0024e6c <ecmp+0x94>
c0024f04:	00100513          	li	a0,1
c0024f08:	f60582e3          	beqz	a1,c0024e6c <ecmp+0x94>
c0024f0c:	fff00513          	li	a0,-1
c0024f10:	f5dff06f          	j	c0024e6c <ecmp+0x94>

c0024f14 <emdnorm>:
c0024f14:	fe010113          	addi	sp,sp,-32
c0024f18:	00812c23          	sw	s0,24(sp)
c0024f1c:	00912a23          	sw	s1,20(sp)
c0024f20:	01212823          	sw	s2,16(sp)
c0024f24:	01312623          	sw	s3,12(sp)
c0024f28:	01412423          	sw	s4,8(sp)
c0024f2c:	01512223          	sw	s5,4(sp)
c0024f30:	00068913          	mv	s2,a3
c0024f34:	00078493          	mv	s1,a5
c0024f38:	00112e23          	sw	ra,28(sp)
c0024f3c:	00050413          	mv	s0,a0
c0024f40:	00058993          	mv	s3,a1
c0024f44:	00060a13          	mv	s4,a2
c0024f48:	00070a93          	mv	s5,a4
c0024f4c:	a3dff0ef          	jal	ra,c0024988 <enormlz>
c0024f50:	09000793          	li	a5,144
c0024f54:	40a90933          	sub	s2,s2,a0
c0024f58:	18a7dc63          	bge	a5,a0,c00250f0 <emdnorm+0x1dc>
c0024f5c:	000087b7          	lui	a5,0x8
c0024f60:	ffe78793          	addi	a5,a5,-2 # 7ffe <_STACK_SIZE+0x6ffe>
c0024f64:	2127da63          	bge	a5,s2,c0025178 <emdnorm+0x264>
c0024f68:	1e0a8463          	beqz	s5,c0025150 <emdnorm+0x23c>
c0024f6c:	0044a503          	lw	a0,4(s1)
c0024f70:	0004a783          	lw	a5,0(s1)
c0024f74:	06f50a63          	beq	a0,a5,c0024fe8 <emdnorm+0xd4>
c0024f78:	01a48713          	addi	a4,s1,26
c0024f7c:	03448793          	addi	a5,s1,52
c0024f80:	00270713          	addi	a4,a4,2
c0024f84:	fe071f23          	sh	zero,-2(a4)
c0024f88:	fef71ce3          	bne	a4,a5,c0024f80 <emdnorm+0x6c>
c0024f8c:	03800793          	li	a5,56
c0024f90:	36f50063          	beq	a0,a5,c00252f0 <emdnorm+0x3dc>
c0024f94:	18a7d063          	bge	a5,a0,c0025114 <emdnorm+0x200>
c0024f98:	04000793          	li	a5,64
c0024f9c:	2ef50e63          	beq	a0,a5,c0025298 <emdnorm+0x384>
c0024fa0:	07100793          	li	a5,113
c0024fa4:	32f51063          	bne	a0,a5,c00252c4 <emdnorm+0x3b0>
c0024fa8:	400087b7          	lui	a5,0x40008
c0024fac:	fff78793          	addi	a5,a5,-1 # 40007fff <_DMEM_LENGTH+0x3f807fff>
c0024fb0:	00a00713          	li	a4,10
c0024fb4:	00f4aa23          	sw	a5,20(s1)
c0024fb8:	ffff87b7          	lui	a5,0xffff8
c0024fbc:	00e4a423          	sw	a4,8(s1)
c0024fc0:	00f49c23          	sh	a5,24(s1)
c0024fc4:	00e4a623          	sw	a4,12(s1)
c0024fc8:	00a00793          	li	a5,10
c0024fcc:	00008737          	lui	a4,0x8
c0024fd0:	00878793          	addi	a5,a5,8 # ffff8008 <_end+0x37f73788>
c0024fd4:	00179793          	slli	a5,a5,0x1
c0024fd8:	00f487b3          	add	a5,s1,a5
c0024fdc:	00e79523          	sh	a4,10(a5)
c0024fe0:	00a4a023          	sw	a0,0(s1)
c0024fe4:	1d205863          	blez	s2,c00251b4 <emdnorm+0x2a0>
c0024fe8:	0084a583          	lw	a1,8(s1)
c0024fec:	0144d783          	lhu	a5,20(s1)
c0024ff0:	08f00813          	li	a6,143
c0024ff4:	00159613          	slli	a2,a1,0x1
c0024ff8:	00c40633          	add	a2,s0,a2
c0024ffc:	00065703          	lhu	a4,0(a2)
c0025000:	00f776b3          	and	a3,a4,a5
c0025004:	02a84a63          	blt	a6,a0,c0025038 <emdnorm+0x124>
c0025008:	00b00813          	li	a6,11
c002500c:	02b84663          	blt	a6,a1,c0025038 <emdnorm+0x124>
c0025010:	00060793          	mv	a5,a2
c0025014:	01840593          	addi	a1,s0,24
c0025018:	0027d703          	lhu	a4,2(a5)
c002501c:	00070463          	beqz	a4,c0025024 <emdnorm+0x110>
c0025020:	0016e693          	ori	a3,a3,1
c0025024:	00079123          	sh	zero,2(a5)
c0025028:	00278793          	addi	a5,a5,2
c002502c:	fef596e3          	bne	a1,a5,c0025018 <emdnorm+0x104>
c0025030:	00065703          	lhu	a4,0(a2)
c0025034:	0144d783          	lhu	a5,20(s1)
c0025038:	fff7c793          	not	a5,a5
c002503c:	00e7f7b3          	and	a5,a5,a4
c0025040:	00f61023          	sh	a5,0(a2)
c0025044:	0164d783          	lhu	a5,22(s1)
c0025048:	00d7f733          	and	a4,a5,a3
c002504c:	06070063          	beqz	a4,c00250ac <emdnorm+0x198>
c0025050:	02d79263          	bne	a5,a3,c0025074 <emdnorm+0x160>
c0025054:	20099863          	bnez	s3,c0025264 <emdnorm+0x350>
c0025058:	00c4a783          	lw	a5,12(s1)
c002505c:	0184d703          	lhu	a4,24(s1)
c0025060:	00179793          	slli	a5,a5,0x1
c0025064:	00f407b3          	add	a5,s0,a5
c0025068:	0007d783          	lhu	a5,0(a5)
c002506c:	00e7f7b3          	and	a5,a5,a4
c0025070:	02078e63          	beqz	a5,c00250ac <emdnorm+0x198>
c0025074:	03248613          	addi	a2,s1,50
c0025078:	01840693          	addi	a3,s0,24
c002507c:	01c48493          	addi	s1,s1,28
c0025080:	00000713          	li	a4,0
c0025084:	00065783          	lhu	a5,0(a2)
c0025088:	0006d583          	lhu	a1,0(a3)
c002508c:	ffe68693          	addi	a3,a3,-2
c0025090:	ffe60613          	addi	a2,a2,-2
c0025094:	00b787b3          	add	a5,a5,a1
c0025098:	00e787b3          	add	a5,a5,a4
c002509c:	0107d713          	srli	a4,a5,0x10
c00250a0:	00f69123          	sh	a5,2(a3)
c00250a4:	00177713          	andi	a4,a4,1
c00250a8:	fc961ee3          	bne	a2,s1,c0025084 <emdnorm+0x170>
c00250ac:	17205663          	blez	s2,c0025218 <emdnorm+0x304>
c00250b0:	00445783          	lhu	a5,4(s0)
c00250b4:	12079e63          	bnez	a5,c00251f0 <emdnorm+0x2dc>
c00250b8:	000087b7          	lui	a5,0x8
c00250bc:	00041c23          	sh	zero,24(s0)
c00250c0:	ffe78793          	addi	a5,a5,-2 # 7ffe <_STACK_SIZE+0x6ffe>
c00250c4:	0927c863          	blt	a5,s2,c0025154 <emdnorm+0x240>
c00250c8:	01241123          	sh	s2,2(s0)
c00250cc:	01c12083          	lw	ra,28(sp)
c00250d0:	01812403          	lw	s0,24(sp)
c00250d4:	01412483          	lw	s1,20(sp)
c00250d8:	01012903          	lw	s2,16(sp)
c00250dc:	00c12983          	lw	s3,12(sp)
c00250e0:	00812a03          	lw	s4,8(sp)
c00250e4:	00412a83          	lw	s5,4(sp)
c00250e8:	02010113          	addi	sp,sp,32
c00250ec:	00008067          	ret
c00250f0:	0e095463          	bgez	s2,c00251d8 <emdnorm+0x2c4>
c00250f4:	f7000793          	li	a5,-144
c00250f8:	08f95c63          	bge	s2,a5,c0025190 <emdnorm+0x27c>
c00250fc:	00240793          	addi	a5,s0,2
c0025100:	01a40413          	addi	s0,s0,26
c0025104:	00278793          	addi	a5,a5,2
c0025108:	fe079f23          	sh	zero,-2(a5)
c002510c:	fe879ce3          	bne	a5,s0,c0025104 <emdnorm+0x1f0>
c0025110:	fbdff06f          	j	c00250cc <emdnorm+0x1b8>
c0025114:	01800793          	li	a5,24
c0025118:	14f50a63          	beq	a0,a5,c002526c <emdnorm+0x358>
c002511c:	03500793          	li	a5,53
c0025120:	1af51263          	bne	a0,a5,c00252c4 <emdnorm+0x3b0>
c0025124:	00001737          	lui	a4,0x1
c0025128:	040007b7          	lui	a5,0x4000
c002512c:	00600693          	li	a3,6
c0025130:	7ff78793          	addi	a5,a5,2047 # 40007ff <_DMEM_LENGTH+0x38007ff>
c0025134:	80070713          	addi	a4,a4,-2048 # 800 <_STACK_SIZE-0x800>
c0025138:	00f4aa23          	sw	a5,20(s1)
c002513c:	00d4a423          	sw	a3,8(s1)
c0025140:	00e49c23          	sh	a4,24(s1)
c0025144:	00d4a623          	sw	a3,12(s1)
c0025148:	00600793          	li	a5,6
c002514c:	e85ff06f          	j	c0024fd0 <emdnorm+0xbc>
c0025150:	00041c23          	sh	zero,24(s0)
c0025154:	ffff87b7          	lui	a5,0xffff8
c0025158:	fff7c793          	not	a5,a5
c002515c:	00f41123          	sh	a5,2(s0)
c0025160:	00440793          	addi	a5,s0,4
c0025164:	01840413          	addi	s0,s0,24
c0025168:	00079023          	sh	zero,0(a5) # ffff8000 <_end+0x37f73780>
c002516c:	00278793          	addi	a5,a5,2
c0025170:	fef41ce3          	bne	s0,a5,c0025168 <emdnorm+0x254>
c0025174:	f59ff06f          	j	c00250cc <emdnorm+0x1b8>
c0025178:	00240793          	addi	a5,s0,2
c002517c:	01a40413          	addi	s0,s0,26
c0025180:	00278793          	addi	a5,a5,2
c0025184:	fe079f23          	sh	zero,-2(a5)
c0025188:	fe879ce3          	bne	a5,s0,c0025180 <emdnorm+0x26c>
c002518c:	f41ff06f          	j	c00250cc <emdnorm+0x1b8>
c0025190:	00090593          	mv	a1,s2
c0025194:	00040513          	mv	a0,s0
c0025198:	96dff0ef          	jal	ra,c0024b04 <eshift.part.0>
c002519c:	00050463          	beqz	a0,c00251a4 <emdnorm+0x290>
c00251a0:	00100993          	li	s3,1
c00251a4:	0a0a8a63          	beqz	s5,c0025258 <emdnorm+0x344>
c00251a8:	0044a503          	lw	a0,4(s1)
c00251ac:	0004a783          	lw	a5,0(s1)
c00251b0:	dcf514e3          	bne	a0,a5,c0024f78 <emdnorm+0x64>
c00251b4:	09000793          	li	a5,144
c00251b8:	08f50263          	beq	a0,a5,c002523c <emdnorm+0x328>
c00251bc:	01845783          	lhu	a5,24(s0)
c00251c0:	00040513          	mv	a0,s0
c00251c4:	0017f793          	andi	a5,a5,1
c00251c8:	00f9e9b3          	or	s3,s3,a5
c00251cc:	d90ff0ef          	jal	ra,c002475c <eshdn1>
c00251d0:	0044a503          	lw	a0,4(s1)
c00251d4:	e15ff06f          	j	c0024fe8 <emdnorm+0xd4>
c00251d8:	ee0a80e3          	beqz	s5,c00250b8 <emdnorm+0x1a4>
c00251dc:	0044a503          	lw	a0,4(s1)
c00251e0:	0004a783          	lw	a5,0(s1)
c00251e4:	d8f51ae3          	bne	a0,a5,c0024f78 <emdnorm+0x64>
c00251e8:	e12040e3          	bgtz	s2,c0024fe8 <emdnorm+0xd4>
c00251ec:	fc9ff06f          	j	c00251b4 <emdnorm+0x2a0>
c00251f0:	00040513          	mv	a0,s0
c00251f4:	d68ff0ef          	jal	ra,c002475c <eshdn1>
c00251f8:	000087b7          	lui	a5,0x8
c00251fc:	00190913          	addi	s2,s2,1
c0025200:	00041c23          	sh	zero,24(s0)
c0025204:	ffe78793          	addi	a5,a5,-2 # 7ffe <_STACK_SIZE+0x6ffe>
c0025208:	f527c6e3          	blt	a5,s2,c0025154 <emdnorm+0x240>
c002520c:	ea095ee3          	bgez	s2,c00250c8 <emdnorm+0x1b4>
c0025210:	00041123          	sh	zero,2(s0)
c0025214:	eb9ff06f          	j	c00250cc <emdnorm+0x1b8>
c0025218:	09000793          	li	a5,144
c002521c:	00f50663          	beq	a0,a5,c0025228 <emdnorm+0x314>
c0025220:	00040513          	mv	a0,s0
c0025224:	da0ff0ef          	jal	ra,c00247c4 <eshup1>
c0025228:	00445783          	lhu	a5,4(s0)
c002522c:	fc0792e3          	bnez	a5,c00251f0 <emdnorm+0x2dc>
c0025230:	00041c23          	sh	zero,24(s0)
c0025234:	fc094ee3          	bltz	s2,c0025210 <emdnorm+0x2fc>
c0025238:	e91ff06f          	j	c00250c8 <emdnorm+0x1b4>
c002523c:	0084a603          	lw	a2,8(s1)
c0025240:	0144d783          	lhu	a5,20(s1)
c0025244:	00161613          	slli	a2,a2,0x1
c0025248:	00c40633          	add	a2,s0,a2
c002524c:	00065703          	lhu	a4,0(a2)
c0025250:	00e7f6b3          	and	a3,a5,a4
c0025254:	de5ff06f          	j	c0025038 <emdnorm+0x124>
c0025258:	00041c23          	sh	zero,24(s0)
c002525c:	00041123          	sh	zero,2(s0)
c0025260:	e6dff06f          	j	c00250cc <emdnorm+0x1b8>
c0025264:	e00a08e3          	beqz	s4,c0025074 <emdnorm+0x160>
c0025268:	e45ff06f          	j	c00250ac <emdnorm+0x198>
c002526c:	008007b7          	lui	a5,0x800
c0025270:	0ff78793          	addi	a5,a5,255 # 8000ff <_DMEM_LENGTH+0xff>
c0025274:	00400713          	li	a4,4
c0025278:	00f4aa23          	sw	a5,20(s1)
c002527c:	10000793          	li	a5,256
c0025280:	00e4a423          	sw	a4,8(s1)
c0025284:	00f49c23          	sh	a5,24(s1)
c0025288:	00e4a623          	sw	a4,12(s1)
c002528c:	00400793          	li	a5,4
c0025290:	10000713          	li	a4,256
c0025294:	d3dff06f          	j	c0024fd0 <emdnorm+0xbc>
c0025298:	00700793          	li	a5,7
c002529c:	00f4a423          	sw	a5,8(s1)
c00252a0:	800107b7          	lui	a5,0x80010
c00252a4:	fff78793          	addi	a5,a5,-1 # 8000ffff <_end+0xb7f8b77f>
c00252a8:	00f4aa23          	sw	a5,20(s1)
c00252ac:	00100793          	li	a5,1
c00252b0:	00f49c23          	sh	a5,24(s1)
c00252b4:	00600793          	li	a5,6
c00252b8:	00f4a623          	sw	a5,12(s1)
c00252bc:	00100713          	li	a4,1
c00252c0:	d11ff06f          	j	c0024fd0 <emdnorm+0xbc>
c00252c4:	00c00793          	li	a5,12
c00252c8:	00f4a423          	sw	a5,8(s1)
c00252cc:	800107b7          	lui	a5,0x80010
c00252d0:	fff78793          	addi	a5,a5,-1 # 8000ffff <_end+0xb7f8b77f>
c00252d4:	00f4aa23          	sw	a5,20(s1)
c00252d8:	00100793          	li	a5,1
c00252dc:	00f49c23          	sh	a5,24(s1)
c00252e0:	00b00793          	li	a5,11
c00252e4:	00f4a623          	sw	a5,12(s1)
c00252e8:	00100713          	li	a4,1
c00252ec:	ce5ff06f          	j	c0024fd0 <emdnorm+0xbc>
c00252f0:	008007b7          	lui	a5,0x800
c00252f4:	0ff78793          	addi	a5,a5,255 # 8000ff <_DMEM_LENGTH+0xff>
c00252f8:	00600713          	li	a4,6
c00252fc:	00f4aa23          	sw	a5,20(s1)
c0025300:	10000793          	li	a5,256
c0025304:	00e4a423          	sw	a4,8(s1)
c0025308:	00f49c23          	sh	a5,24(s1)
c002530c:	00e4a623          	sw	a4,12(s1)
c0025310:	00600793          	li	a5,6
c0025314:	10000713          	li	a4,256
c0025318:	cb9ff06f          	j	c0024fd0 <emdnorm+0xbc>

c002531c <eiremain>:
c002531c:	fd010113          	addi	sp,sp,-48
c0025320:	03212023          	sw	s2,32(sp)
c0025324:	01312e23          	sw	s3,28(sp)
c0025328:	00058913          	mv	s2,a1
c002532c:	00255983          	lhu	s3,2(a0)
c0025330:	02112623          	sw	ra,44(sp)
c0025334:	02812423          	sw	s0,40(sp)
c0025338:	02912223          	sw	s1,36(sp)
c002533c:	01412c23          	sw	s4,24(sp)
c0025340:	00060493          	mv	s1,a2
c0025344:	01712623          	sw	s7,12(sp)
c0025348:	01512a23          	sw	s5,20(sp)
c002534c:	01612823          	sw	s6,16(sp)
c0025350:	01812423          	sw	s8,8(sp)
c0025354:	01912223          	sw	s9,4(sp)
c0025358:	01a12023          	sw	s10,0(sp)
c002535c:	00050b93          	mv	s7,a0
c0025360:	e28ff0ef          	jal	ra,c0024988 <enormlz>
c0025364:	00295403          	lhu	s0,2(s2)
c0025368:	00050793          	mv	a5,a0
c002536c:	00090513          	mv	a0,s2
c0025370:	40f989b3          	sub	s3,s3,a5
c0025374:	03448a13          	addi	s4,s1,52
c0025378:	e10ff0ef          	jal	ra,c0024988 <enormlz>
c002537c:	40a40433          	sub	s0,s0,a0
c0025380:	04e48713          	addi	a4,s1,78
c0025384:	000a0793          	mv	a5,s4
c0025388:	00278793          	addi	a5,a5,2
c002538c:	fe079f23          	sh	zero,-2(a5)
c0025390:	fee79ce3          	bne	a5,a4,c0025388 <eiremain+0x6c>
c0025394:	09344863          	blt	s0,s3,c0025424 <eiremain+0x108>
c0025398:	004b8b13          	addi	s6,s7,4
c002539c:	00490a93          	addi	s5,s2,4
c00253a0:	01ab8c13          	addi	s8,s7,26
c00253a4:	00290d13          	addi	s10,s2,2
c00253a8:	000a8713          	mv	a4,s5
c00253ac:	000b0793          	mv	a5,s6
c00253b0:	0007d603          	lhu	a2,0(a5)
c00253b4:	00075683          	lhu	a3,0(a4)
c00253b8:	00278793          	addi	a5,a5,2
c00253bc:	00270713          	addi	a4,a4,2
c00253c0:	0ad61a63          	bne	a2,a3,c0025474 <eiremain+0x158>
c00253c4:	ff8796e3          	bne	a5,s8,c00253b0 <eiremain+0x94>
c00253c8:	018b8613          	addi	a2,s7,24
c00253cc:	01890713          	addi	a4,s2,24
c00253d0:	00000693          	li	a3,0
c00253d4:	00075783          	lhu	a5,0(a4)
c00253d8:	00065583          	lhu	a1,0(a2)
c00253dc:	ffe70713          	addi	a4,a4,-2
c00253e0:	40d787b3          	sub	a5,a5,a3
c00253e4:	40b787b3          	sub	a5,a5,a1
c00253e8:	0107d693          	srli	a3,a5,0x10
c00253ec:	00f71123          	sh	a5,2(a4)
c00253f0:	0016f693          	andi	a3,a3,1
c00253f4:	ffe60613          	addi	a2,a2,-2
c00253f8:	fced1ee3          	bne	s10,a4,c00253d4 <eiremain+0xb8>
c00253fc:	00100c93          	li	s9,1
c0025400:	000a0513          	mv	a0,s4
c0025404:	bc0ff0ef          	jal	ra,c00247c4 <eshup1>
c0025408:	04c4d783          	lhu	a5,76(s1)
c002540c:	fff40413          	addi	s0,s0,-1
c0025410:	00090513          	mv	a0,s2
c0025414:	00fce7b3          	or	a5,s9,a5
c0025418:	04f49623          	sh	a5,76(s1)
c002541c:	ba8ff0ef          	jal	ra,c00247c4 <eshup1>
c0025420:	f93454e3          	bge	s0,s3,c00253a8 <eiremain+0x8c>
c0025424:	00040693          	mv	a3,s0
c0025428:	02812403          	lw	s0,40(sp)
c002542c:	02c12083          	lw	ra,44(sp)
c0025430:	01c12983          	lw	s3,28(sp)
c0025434:	01812a03          	lw	s4,24(sp)
c0025438:	01412a83          	lw	s5,20(sp)
c002543c:	01012b03          	lw	s6,16(sp)
c0025440:	00c12b83          	lw	s7,12(sp)
c0025444:	00812c03          	lw	s8,8(sp)
c0025448:	00412c83          	lw	s9,4(sp)
c002544c:	00012d03          	lw	s10,0(sp)
c0025450:	00048793          	mv	a5,s1
c0025454:	00090513          	mv	a0,s2
c0025458:	02412483          	lw	s1,36(sp)
c002545c:	02012903          	lw	s2,32(sp)
c0025460:	00000713          	li	a4,0
c0025464:	00000613          	li	a2,0
c0025468:	00000593          	li	a1,0
c002546c:	03010113          	addi	sp,sp,48
c0025470:	aa5ff06f          	j	c0024f14 <emdnorm>
c0025474:	00000c93          	li	s9,0
c0025478:	f8c6e4e3          	bltu	a3,a2,c0025400 <eiremain+0xe4>
c002547c:	f4dff06f          	j	c00253c8 <eiremain+0xac>

c0025480 <emul>:
c0025480:	f7010113          	addi	sp,sp,-144
c0025484:	08912223          	sw	s1,132(sp)
c0025488:	00050493          	mv	s1,a0
c002548c:	01255503          	lhu	a0,18(a0)
c0025490:	00008737          	lui	a4,0x8
c0025494:	fff70713          	addi	a4,a4,-1 # 7fff <_STACK_SIZE+0x6fff>
c0025498:	08812423          	sw	s0,136(sp)
c002549c:	09212023          	sw	s2,128(sp)
c00254a0:	07412c23          	sw	s4,120(sp)
c00254a4:	08112623          	sw	ra,140(sp)
c00254a8:	07312e23          	sw	s3,124(sp)
c00254ac:	07512a23          	sw	s5,116(sp)
c00254b0:	07612823          	sw	s6,112(sp)
c00254b4:	07712623          	sw	s7,108(sp)
c00254b8:	07812423          	sw	s8,104(sp)
c00254bc:	07912223          	sw	s9,100(sp)
c00254c0:	00a77533          	and	a0,a4,a0
c00254c4:	00058913          	mv	s2,a1
c00254c8:	00060413          	mv	s0,a2
c00254cc:	00068a13          	mv	s4,a3
c00254d0:	00e51e63          	bne	a0,a4,c00254ec <emul+0x6c>
c00254d4:	01248993          	addi	s3,s1,18
c00254d8:	00048713          	mv	a4,s1
c00254dc:	00075603          	lhu	a2,0(a4)
c00254e0:	00270713          	addi	a4,a4,2
c00254e4:	22061e63          	bnez	a2,c0025720 <emul+0x2a0>
c00254e8:	ff371ae3          	bne	a4,s3,c00254dc <emul+0x5c>
c00254ec:	01295603          	lhu	a2,18(s2)
c00254f0:	000087b7          	lui	a5,0x8
c00254f4:	fff78793          	addi	a5,a5,-1 # 7fff <_STACK_SIZE+0x6fff>
c00254f8:	00f675b3          	and	a1,a2,a5
c00254fc:	12f59463          	bne	a1,a5,c0025624 <emul+0x1a4>
c0025500:	01290693          	addi	a3,s2,18
c0025504:	00090713          	mv	a4,s2
c0025508:	00075783          	lhu	a5,0(a4)
c002550c:	00270713          	addi	a4,a4,2
c0025510:	22079663          	bnez	a5,c002573c <emul+0x2bc>
c0025514:	fee69ae3          	bne	a3,a4,c0025508 <emul+0x88>
c0025518:	000087b7          	lui	a5,0x8
c002551c:	fff78793          	addi	a5,a5,-1 # 7fff <_STACK_SIZE+0x6fff>
c0025520:	10f50463          	beq	a0,a5,c0025628 <emul+0x1a8>
c0025524:	00090793          	mv	a5,s2
c0025528:	0007d703          	lhu	a4,0(a5)
c002552c:	00278793          	addi	a5,a5,2
c0025530:	1c071863          	bnez	a4,c0025700 <emul+0x280>
c0025534:	fef69ae3          	bne	a3,a5,c0025528 <emul+0xa8>
c0025538:	c80025b7          	lui	a1,0xc8002
c002553c:	d8458593          	addi	a1,a1,-636 # c8001d84 <_end+0xfff7d504>
c0025540:	00048513          	mv	a0,s1
c0025544:	895ff0ef          	jal	ra,c0024dd8 <ecmp>
c0025548:	20050863          	beqz	a0,c0025758 <emul+0x2d8>
c002554c:	0124d503          	lhu	a0,18(s1)
c0025550:	01295603          	lhu	a2,18(s2)
c0025554:	000087b7          	lui	a5,0x8
c0025558:	fff78793          	addi	a5,a5,-1 # 7fff <_STACK_SIZE+0x6fff>
c002555c:	00f57833          	and	a6,a0,a5
c0025560:	00f675b3          	and	a1,a2,a5
c0025564:	1af80a63          	beq	a6,a5,c0025718 <emul+0x298>
c0025568:	000087b7          	lui	a5,0x8
c002556c:	fff78793          	addi	a5,a5,-1 # 7fff <_STACK_SIZE+0x6fff>
c0025570:	14f59063          	bne	a1,a5,c00256b0 <emul+0x230>
c0025574:	01290693          	addi	a3,s2,18
c0025578:	00090793          	mv	a5,s2
c002557c:	0007d703          	lhu	a4,0(a5)
c0025580:	00278793          	addi	a5,a5,2
c0025584:	12071663          	bnez	a4,c00256b0 <emul+0x230>
c0025588:	fed79ae3          	bne	a5,a3,c002557c <emul+0xfc>
c002558c:	00008737          	lui	a4,0x8
c0025590:	fff70713          	addi	a4,a4,-1 # 7fff <_STACK_SIZE+0x6fff>
c0025594:	00f55893          	srli	a7,a0,0xf
c0025598:	00080593          	mv	a1,a6
c002559c:	01248993          	addi	s3,s1,18
c00255a0:	0ee80463          	beq	a6,a4,c0025688 <emul+0x208>
c00255a4:	00095703          	lhu	a4,0(s2)
c00255a8:	00290913          	addi	s2,s2,2
c00255ac:	32071863          	bnez	a4,c00258dc <emul+0x45c>
c00255b0:	fed91ae3          	bne	s2,a3,c00255a4 <emul+0x124>
c00255b4:	00f65793          	srli	a5,a2,0xf
c00255b8:	411787b3          	sub	a5,a5,a7
c00255bc:	00f037b3          	snez	a5,a5
c00255c0:	00f79793          	slli	a5,a5,0xf
c00255c4:	00f41923          	sh	a5,18(s0)
c00255c8:	01240713          	addi	a4,s0,18
c00255cc:	00040793          	mv	a5,s0
c00255d0:	00278793          	addi	a5,a5,2
c00255d4:	fe079f23          	sh	zero,-2(a5)
c00255d8:	fee79ce3          	bne	a5,a4,c00255d0 <emul+0x150>
c00255dc:	01245783          	lhu	a5,18(s0)
c00255e0:	00008737          	lui	a4,0x8
c00255e4:	fff70713          	addi	a4,a4,-1 # 7fff <_STACK_SIZE+0x6fff>
c00255e8:	00e7e7b3          	or	a5,a5,a4
c00255ec:	00f41923          	sh	a5,18(s0)
c00255f0:	08c12083          	lw	ra,140(sp)
c00255f4:	08812403          	lw	s0,136(sp)
c00255f8:	08412483          	lw	s1,132(sp)
c00255fc:	08012903          	lw	s2,128(sp)
c0025600:	07c12983          	lw	s3,124(sp)
c0025604:	07812a03          	lw	s4,120(sp)
c0025608:	07412a83          	lw	s5,116(sp)
c002560c:	07012b03          	lw	s6,112(sp)
c0025610:	06c12b83          	lw	s7,108(sp)
c0025614:	06812c03          	lw	s8,104(sp)
c0025618:	06412c83          	lw	s9,100(sp)
c002561c:	09010113          	addi	sp,sp,144
c0025620:	00008067          	ret
c0025624:	08f51663          	bne	a0,a5,c00256b0 <emul+0x230>
c0025628:	01248993          	addi	s3,s1,18
c002562c:	00048793          	mv	a5,s1
c0025630:	0007d703          	lhu	a4,0(a5)
c0025634:	00278793          	addi	a5,a5,2
c0025638:	2a071a63          	bnez	a4,c00258ec <emul+0x46c>
c002563c:	fef99ae3          	bne	s3,a5,c0025630 <emul+0x1b0>
c0025640:	c80025b7          	lui	a1,0xc8002
c0025644:	d8458593          	addi	a1,a1,-636 # c8001d84 <_end+0xfff7d504>
c0025648:	00090513          	mv	a0,s2
c002564c:	f8cff0ef          	jal	ra,c0024dd8 <ecmp>
c0025650:	10050463          	beqz	a0,c0025758 <emul+0x2d8>
c0025654:	01295603          	lhu	a2,18(s2)
c0025658:	000087b7          	lui	a5,0x8
c002565c:	fff78793          	addi	a5,a5,-1 # 7fff <_STACK_SIZE+0x6fff>
c0025660:	00f675b3          	and	a1,a2,a5
c0025664:	12f58063          	beq	a1,a5,c0025784 <emul+0x304>
c0025668:	0124d503          	lhu	a0,18(s1)
c002566c:	00f57733          	and	a4,a0,a5
c0025670:	04f71063          	bne	a4,a5,c00256b0 <emul+0x230>
c0025674:	00048793          	mv	a5,s1
c0025678:	0007d703          	lhu	a4,0(a5)
c002567c:	00278793          	addi	a5,a5,2
c0025680:	2a071463          	bnez	a4,c0025928 <emul+0x4a8>
c0025684:	fef99ae3          	bne	s3,a5,c0025678 <emul+0x1f8>
c0025688:	0004d783          	lhu	a5,0(s1)
c002568c:	00248493          	addi	s1,s1,2
c0025690:	24079a63          	bnez	a5,c00258e4 <emul+0x464>
c0025694:	ff349ae3          	bne	s1,s3,c0025688 <emul+0x208>
c0025698:	00f55893          	srli	a7,a0,0xf
c002569c:	00008737          	lui	a4,0x8
c00256a0:	fff70713          	addi	a4,a4,-1 # 7fff <_STACK_SIZE+0x6fff>
c00256a4:	f0e598e3          	bne	a1,a4,c00255b4 <emul+0x134>
c00256a8:	01290693          	addi	a3,s2,18
c00256ac:	ef9ff06f          	j	c00255a4 <emul+0x124>
c00256b0:	00048513          	mv	a0,s1
c00256b4:	00c10593          	addi	a1,sp,12
c00256b8:	e6cff0ef          	jal	ra,c0024d24 <emovi>
c00256bc:	02810593          	addi	a1,sp,40
c00256c0:	00090513          	mv	a0,s2
c00256c4:	e60ff0ef          	jal	ra,c0024d24 <emovi>
c00256c8:	00e15483          	lhu	s1,14(sp)
c00256cc:	02a15983          	lhu	s3,42(sp)
c00256d0:	0a049e63          	bnez	s1,c002578c <emul+0x30c>
c00256d4:	01010793          	addi	a5,sp,16
c00256d8:	02410693          	addi	a3,sp,36
c00256dc:	22d78263          	beq	a5,a3,c0025900 <emul+0x480>
c00256e0:	0007d703          	lhu	a4,0(a5)
c00256e4:	00278793          	addi	a5,a5,2
c00256e8:	fe070ae3          	beqz	a4,c00256dc <emul+0x25c>
c00256ec:	00c10513          	addi	a0,sp,12
c00256f0:	a98ff0ef          	jal	ra,c0024988 <enormlz>
c00256f4:	02a15703          	lhu	a4,42(sp)
c00256f8:	40a004b3          	neg	s1,a0
c00256fc:	0940006f          	j	c0025790 <emul+0x310>
c0025700:	0124d503          	lhu	a0,18(s1)
c0025704:	000087b7          	lui	a5,0x8
c0025708:	fff78793          	addi	a5,a5,-1 # 7fff <_STACK_SIZE+0x6fff>
c002570c:	00f575b3          	and	a1,a0,a5
c0025710:	00058813          	mv	a6,a1
c0025714:	e6f592e3          	bne	a1,a5,c0025578 <emul+0xf8>
c0025718:	01248993          	addi	s3,s1,18
c002571c:	f59ff06f          	j	c0025674 <emul+0x1f4>
c0025720:	01448713          	addi	a4,s1,20
c0025724:	0004d783          	lhu	a5,0(s1)
c0025728:	00248493          	addi	s1,s1,2
c002572c:	00240413          	addi	s0,s0,2
c0025730:	fef41f23          	sh	a5,-2(s0)
c0025734:	fee498e3          	bne	s1,a4,c0025724 <emul+0x2a4>
c0025738:	eb9ff06f          	j	c00255f0 <emul+0x170>
c002573c:	01440713          	addi	a4,s0,20
c0025740:	00095783          	lhu	a5,0(s2)
c0025744:	00240413          	addi	s0,s0,2
c0025748:	00290913          	addi	s2,s2,2
c002574c:	fef41f23          	sh	a5,-2(s0)
c0025750:	fee418e3          	bne	s0,a4,c0025740 <emul+0x2c0>
c0025754:	e9dff06f          	j	c00255f0 <emul+0x170>
c0025758:	01040713          	addi	a4,s0,16
c002575c:	00040793          	mv	a5,s0
c0025760:	00278793          	addi	a5,a5,2
c0025764:	fe079f23          	sh	zero,-2(a5)
c0025768:	fee79ce3          	bne	a5,a4,c0025760 <emul+0x2e0>
c002576c:	ffffc7b7          	lui	a5,0xffffc
c0025770:	00f41823          	sh	a5,16(s0)
c0025774:	ffff87b7          	lui	a5,0xffff8
c0025778:	fff7c793          	not	a5,a5
c002577c:	00f41923          	sh	a5,18(s0)
c0025780:	e71ff06f          	j	c00255f0 <emul+0x170>
c0025784:	01290693          	addi	a3,s2,18
c0025788:	d9dff06f          	j	c0025524 <emul+0xa4>
c002578c:	00098713          	mv	a4,s3
c0025790:	00098913          	mv	s2,s3
c0025794:	02c10793          	addi	a5,sp,44
c0025798:	04010693          	addi	a3,sp,64
c002579c:	02071263          	bnez	a4,c00257c0 <emul+0x340>
c00257a0:	16f68a63          	beq	a3,a5,c0025914 <emul+0x494>
c00257a4:	0007d703          	lhu	a4,0(a5) # ffff8000 <_end+0x37f73780>
c00257a8:	00278793          	addi	a5,a5,2
c00257ac:	fe070ae3          	beqz	a4,c00257a0 <emul+0x320>
c00257b0:	02810513          	addi	a0,sp,40
c00257b4:	9d4ff0ef          	jal	ra,c0024988 <enormlz>
c00257b8:	02a15703          	lhu	a4,42(sp)
c00257bc:	40a98933          	sub	s2,s3,a0
c00257c0:	02815783          	lhu	a5,40(sp)
c00257c4:	038a0993          	addi	s3,s4,56
c00257c8:	02ea1b23          	sh	a4,54(s4)
c00257cc:	02fa1a23          	sh	a5,52(s4)
c00257d0:	04ea0713          	addi	a4,s4,78
c00257d4:	00098793          	mv	a5,s3
c00257d8:	00079023          	sh	zero,0(a5)
c00257dc:	00278793          	addi	a5,a5,2
c00257e0:	fef71ce3          	bne	a4,a5,c00257d8 <emul+0x358>
c00257e4:	04ca0c13          	addi	s8,s4,76
c00257e8:	00000b93          	li	s7,0
c00257ec:	02410a93          	addi	s5,sp,36
c00257f0:	01010c93          	addi	s9,sp,16
c00257f4:	04610b13          	addi	s6,sp,70
c00257f8:	000ad503          	lhu	a0,0(s5)
c00257fc:	ffea8a93          	addi	s5,s5,-2
c0025800:	08051c63          	bnez	a0,c0025898 <emul+0x418>
c0025804:	04ca5783          	lhu	a5,76(s4)
c0025808:	000c0713          	mv	a4,s8
c002580c:	00fbebb3          	or	s7,s7,a5
c0025810:	ffe75603          	lhu	a2,-2(a4)
c0025814:	ffe70713          	addi	a4,a4,-2
c0025818:	00c71123          	sh	a2,2(a4)
c002581c:	fee99ae3          	bne	s3,a4,c0025810 <emul+0x390>
c0025820:	020a1c23          	sh	zero,56(s4)
c0025824:	fd9a9ae3          	bne	s5,s9,c00257f8 <emul+0x378>
c0025828:	034a0713          	addi	a4,s4,52
c002582c:	02810793          	addi	a5,sp,40
c0025830:	04210613          	addi	a2,sp,66
c0025834:	00075683          	lhu	a3,0(a4)
c0025838:	00278793          	addi	a5,a5,2
c002583c:	00270713          	addi	a4,a4,2
c0025840:	fed79f23          	sh	a3,-2(a5)
c0025844:	fef618e3          	bne	a2,a5,c0025834 <emul+0x3b4>
c0025848:	ffffc6b7          	lui	a3,0xffffc
c002584c:	012484b3          	add	s1,s1,s2
c0025850:	00268693          	addi	a3,a3,2 # ffffc002 <_end+0x37f77782>
c0025854:	000b8593          	mv	a1,s7
c0025858:	02810513          	addi	a0,sp,40
c002585c:	000a0793          	mv	a5,s4
c0025860:	04000713          	li	a4,64
c0025864:	00d486b3          	add	a3,s1,a3
c0025868:	00000613          	li	a2,0
c002586c:	ea8ff0ef          	jal	ra,c0024f14 <emdnorm>
c0025870:	02815703          	lhu	a4,40(sp)
c0025874:	00c15783          	lhu	a5,12(sp)
c0025878:	00040593          	mv	a1,s0
c002587c:	02810513          	addi	a0,sp,40
c0025880:	40e787b3          	sub	a5,a5,a4
c0025884:	00f037b3          	snez	a5,a5
c0025888:	40f007b3          	neg	a5,a5
c002588c:	02f11423          	sh	a5,40(sp)
c0025890:	83cff0ef          	jal	ra,c00248cc <emovo.constprop.0>
c0025894:	d5dff06f          	j	c00255f0 <emul+0x170>
c0025898:	04410613          	addi	a2,sp,68
c002589c:	02810593          	addi	a1,sp,40
c00258a0:	f95fe0ef          	jal	ra,c0024834 <m16m>
c00258a4:	000c0513          	mv	a0,s8
c00258a8:	00000593          	li	a1,0
c00258ac:	05c10613          	addi	a2,sp,92
c00258b0:	00055783          	lhu	a5,0(a0)
c00258b4:	00065703          	lhu	a4,0(a2)
c00258b8:	ffe50513          	addi	a0,a0,-2
c00258bc:	ffe60613          	addi	a2,a2,-2
c00258c0:	00f70733          	add	a4,a4,a5
c00258c4:	00b70733          	add	a4,a4,a1
c00258c8:	01075593          	srli	a1,a4,0x10
c00258cc:	00e51123          	sh	a4,2(a0)
c00258d0:	0015f593          	andi	a1,a1,1
c00258d4:	fd661ee3          	bne	a2,s6,c00258b0 <emul+0x430>
c00258d8:	f2dff06f          	j	c0025804 <emul+0x384>
c00258dc:	00000793          	li	a5,0
c00258e0:	cd9ff06f          	j	c00255b8 <emul+0x138>
c00258e4:	00000893          	li	a7,0
c00258e8:	db5ff06f          	j	c002569c <emul+0x21c>
c00258ec:	000087b7          	lui	a5,0x8
c00258f0:	fff78793          	addi	a5,a5,-1 # 7fff <_STACK_SIZE+0x6fff>
c00258f4:	e8f588e3          	beq	a1,a5,c0025784 <emul+0x304>
c00258f8:	0124d503          	lhu	a0,18(s1)
c00258fc:	d79ff06f          	j	c0025674 <emul+0x1f4>
c0025900:	01440793          	addi	a5,s0,20
c0025904:	00240413          	addi	s0,s0,2
c0025908:	fe041f23          	sh	zero,-2(s0)
c002590c:	fef41ce3          	bne	s0,a5,c0025904 <emul+0x484>
c0025910:	ce1ff06f          	j	c00255f0 <emul+0x170>
c0025914:	01440793          	addi	a5,s0,20
c0025918:	00240413          	addi	s0,s0,2
c002591c:	fe041f23          	sh	zero,-2(s0)
c0025920:	fef41ce3          	bne	s0,a5,c0025918 <emul+0x498>
c0025924:	ccdff06f          	j	c00255f0 <emul+0x170>
c0025928:	00008837          	lui	a6,0x8
c002592c:	fff80813          	addi	a6,a6,-1 # 7fff <_STACK_SIZE+0x6fff>
c0025930:	c39ff06f          	j	c0025568 <emul+0xe8>

c0025934 <ediv>:
c0025934:	01255783          	lhu	a5,18(a0)
c0025938:	f5010113          	addi	sp,sp,-176
c002593c:	0a812423          	sw	s0,168(sp)
c0025940:	fff7c793          	not	a5,a5
c0025944:	0a912223          	sw	s1,164(sp)
c0025948:	0b212023          	sw	s2,160(sp)
c002594c:	09312e23          	sw	s3,156(sp)
c0025950:	0a112623          	sw	ra,172(sp)
c0025954:	09412c23          	sw	s4,152(sp)
c0025958:	09512a23          	sw	s5,148(sp)
c002595c:	09612823          	sw	s6,144(sp)
c0025960:	09712623          	sw	s7,140(sp)
c0025964:	09812423          	sw	s8,136(sp)
c0025968:	09912223          	sw	s9,132(sp)
c002596c:	09a12023          	sw	s10,128(sp)
c0025970:	07b12e23          	sw	s11,124(sp)
c0025974:	01179713          	slli	a4,a5,0x11
c0025978:	00050493          	mv	s1,a0
c002597c:	00058913          	mv	s2,a1
c0025980:	00060413          	mv	s0,a2
c0025984:	00068993          	mv	s3,a3
c0025988:	00071e63          	bnez	a4,c00259a4 <ediv+0x70>
c002598c:	01250693          	addi	a3,a0,18
c0025990:	00050793          	mv	a5,a0
c0025994:	0007d703          	lhu	a4,0(a5)
c0025998:	00278793          	addi	a5,a5,2
c002599c:	30071263          	bnez	a4,c0025ca0 <ediv+0x36c>
c00259a0:	fed79ae3          	bne	a5,a3,c0025994 <ediv+0x60>
c00259a4:	01295783          	lhu	a5,18(s2)
c00259a8:	fff7c793          	not	a5,a5
c00259ac:	01179713          	slli	a4,a5,0x11
c00259b0:	00071e63          	bnez	a4,c00259cc <ediv+0x98>
c00259b4:	01290693          	addi	a3,s2,18
c00259b8:	00090793          	mv	a5,s2
c00259bc:	0007d703          	lhu	a4,0(a5)
c00259c0:	00278793          	addi	a5,a5,2
c00259c4:	2e071c63          	bnez	a4,c0025cbc <ediv+0x388>
c00259c8:	fef69ae3          	bne	a3,a5,c00259bc <ediv+0x88>
c00259cc:	c8002a37          	lui	s4,0xc8002
c00259d0:	d84a0593          	addi	a1,s4,-636 # c8001d84 <_end+0xfff7d504>
c00259d4:	00048513          	mv	a0,s1
c00259d8:	c00ff0ef          	jal	ra,c0024dd8 <ecmp>
c00259dc:	2e050e63          	beqz	a0,c0025cd8 <ediv+0x3a4>
c00259e0:	0124d603          	lhu	a2,18(s1)
c00259e4:	01295583          	lhu	a1,18(s2)
c00259e8:	000087b7          	lui	a5,0x8
c00259ec:	fff78793          	addi	a5,a5,-1 # 7fff <_STACK_SIZE+0x6fff>
c00259f0:	00f67533          	and	a0,a2,a5
c00259f4:	00f5f6b3          	and	a3,a1,a5
c00259f8:	0af51663          	bne	a0,a5,c0025aa4 <ediv+0x170>
c00259fc:	01248813          	addi	a6,s1,18
c0025a00:	00048793          	mv	a5,s1
c0025a04:	0007d703          	lhu	a4,0(a5)
c0025a08:	00278793          	addi	a5,a5,2
c0025a0c:	08071863          	bnez	a4,c0025a9c <ediv+0x168>
c0025a10:	ff079ae3          	bne	a5,a6,c0025a04 <ediv+0xd0>
c0025a14:	000087b7          	lui	a5,0x8
c0025a18:	fff78793          	addi	a5,a5,-1 # 7fff <_STACK_SIZE+0x6fff>
c0025a1c:	2cf69a63          	bne	a3,a5,c0025cf0 <ediv+0x3bc>
c0025a20:	01290693          	addi	a3,s2,18
c0025a24:	00090793          	mv	a5,s2
c0025a28:	0007d703          	lhu	a4,0(a5)
c0025a2c:	00278793          	addi	a5,a5,2
c0025a30:	48071c63          	bnez	a4,c0025ec8 <ediv+0x594>
c0025a34:	fed79ae3          	bne	a5,a3,c0025a28 <ediv+0xf4>
c0025a38:	01040713          	addi	a4,s0,16
c0025a3c:	00040793          	mv	a5,s0
c0025a40:	00278793          	addi	a5,a5,2
c0025a44:	fe079f23          	sh	zero,-2(a5)
c0025a48:	fee79ce3          	bne	a5,a4,c0025a40 <ediv+0x10c>
c0025a4c:	ffffc7b7          	lui	a5,0xffffc
c0025a50:	00f41823          	sh	a5,16(s0)
c0025a54:	ffff87b7          	lui	a5,0xffff8
c0025a58:	fff7c793          	not	a5,a5
c0025a5c:	00f41923          	sh	a5,18(s0)
c0025a60:	0ac12083          	lw	ra,172(sp)
c0025a64:	0a812403          	lw	s0,168(sp)
c0025a68:	0a412483          	lw	s1,164(sp)
c0025a6c:	0a012903          	lw	s2,160(sp)
c0025a70:	09c12983          	lw	s3,156(sp)
c0025a74:	09812a03          	lw	s4,152(sp)
c0025a78:	09412a83          	lw	s5,148(sp)
c0025a7c:	09012b03          	lw	s6,144(sp)
c0025a80:	08c12b83          	lw	s7,140(sp)
c0025a84:	08812c03          	lw	s8,136(sp)
c0025a88:	08412c83          	lw	s9,132(sp)
c0025a8c:	08012d03          	lw	s10,128(sp)
c0025a90:	07c12d83          	lw	s11,124(sp)
c0025a94:	0b010113          	addi	sp,sp,176
c0025a98:	00008067          	ret
c0025a9c:	000087b7          	lui	a5,0x8
c0025aa0:	fff78793          	addi	a5,a5,-1 # 7fff <_STACK_SIZE+0x6fff>
c0025aa4:	26f68063          	beq	a3,a5,c0025d04 <ediv+0x3d0>
c0025aa8:	00048513          	mv	a0,s1
c0025aac:	01c10593          	addi	a1,sp,28
c0025ab0:	a74ff0ef          	jal	ra,c0024d24 <emovi>
c0025ab4:	03810593          	addi	a1,sp,56
c0025ab8:	00090513          	mv	a0,s2
c0025abc:	a68ff0ef          	jal	ra,c0024d24 <emovi>
c0025ac0:	03a15a83          	lhu	s5,58(sp)
c0025ac4:	01e15483          	lhu	s1,30(sp)
c0025ac8:	2c0a8663          	beqz	s5,c0025d94 <ediv+0x460>
c0025acc:	01512623          	sw	s5,12(sp)
c0025ad0:	00048613          	mv	a2,s1
c0025ad4:	00912423          	sw	s1,8(sp)
c0025ad8:	02010793          	addi	a5,sp,32
c0025adc:	03410693          	addi	a3,sp,52
c0025ae0:	02061263          	bnez	a2,c0025b04 <ediv+0x1d0>
c0025ae4:	3af68463          	beq	a3,a5,c0025e8c <ediv+0x558>
c0025ae8:	0007d703          	lhu	a4,0(a5)
c0025aec:	00278793          	addi	a5,a5,2
c0025af0:	fe070ae3          	beqz	a4,c0025ae4 <ediv+0x1b0>
c0025af4:	01c10513          	addi	a0,sp,28
c0025af8:	e91fe0ef          	jal	ra,c0024988 <enormlz>
c0025afc:	40a487b3          	sub	a5,s1,a0
c0025b00:	00f12423          	sw	a5,8(sp)
c0025b04:	03812703          	lw	a4,56(sp)
c0025b08:	03898a93          	addi	s5,s3,56
c0025b0c:	000a8793          	mv	a5,s5
c0025b10:	02e9aa23          	sw	a4,52(s3)
c0025b14:	04e98493          	addi	s1,s3,78
c0025b18:	00278793          	addi	a5,a5,2
c0025b1c:	fe079f23          	sh	zero,-2(a5)
c0025b20:	fe979ce3          	bne	a5,s1,c0025b18 <ediv+0x1e4>
c0025b24:	03810513          	addi	a0,sp,56
c0025b28:	c35fe0ef          	jal	ra,c002475c <eshdn1>
c0025b2c:	02215b03          	lhu	s6,34(sp)
c0025b30:	00010937          	lui	s2,0x10
c0025b34:	05010c13          	addi	s8,sp,80
c0025b38:	010b1a13          	slli	s4,s6,0x10
c0025b3c:	416a0a33          	sub	s4,s4,s6
c0025b40:	03a10c93          	addi	s9,sp,58
c0025b44:	fff90913          	addi	s2,s2,-1 # ffff <_STACK_SIZE+0xefff>
c0025b48:	06e10d13          	addi	s10,sp,110
c0025b4c:	05610d93          	addi	s11,sp,86
c0025b50:	03c15783          	lhu	a5,60(sp)
c0025b54:	03e15703          	lhu	a4,62(sp)
c0025b58:	00090b93          	mv	s7,s2
c0025b5c:	01079793          	slli	a5,a5,0x10
c0025b60:	00e787b3          	add	a5,a5,a4
c0025b64:	00fa6863          	bltu	s4,a5,c0025b74 <ediv+0x240>
c0025b68:	0367d533          	divu	a0,a5,s6
c0025b6c:	01051b93          	slli	s7,a0,0x10
c0025b70:	010bdb93          	srli	s7,s7,0x10
c0025b74:	05410613          	addi	a2,sp,84
c0025b78:	01c10593          	addi	a1,sp,28
c0025b7c:	000b8513          	mv	a0,s7
c0025b80:	cb5fe0ef          	jal	ra,c0024834 <m16m>
c0025b84:	03c10713          	addi	a4,sp,60
c0025b88:	05810793          	addi	a5,sp,88
c0025b8c:	0007d603          	lhu	a2,0(a5)
c0025b90:	00075683          	lhu	a3,0(a4)
c0025b94:	00278793          	addi	a5,a5,2
c0025b98:	00270713          	addi	a4,a4,2
c0025b9c:	22d61463          	bne	a2,a3,c0025dc4 <ediv+0x490>
c0025ba0:	ffa796e3          	bne	a5,s10,c0025b8c <ediv+0x258>
c0025ba4:	00000793          	li	a5,0
c0025ba8:	06c10693          	addi	a3,sp,108
c0025bac:	000c0613          	mv	a2,s8
c0025bb0:	00065703          	lhu	a4,0(a2)
c0025bb4:	0006d583          	lhu	a1,0(a3)
c0025bb8:	ffe60613          	addi	a2,a2,-2
c0025bbc:	40f70733          	sub	a4,a4,a5
c0025bc0:	40b70733          	sub	a4,a4,a1
c0025bc4:	01075793          	srli	a5,a4,0x10
c0025bc8:	00e61123          	sh	a4,2(a2)
c0025bcc:	0017f793          	andi	a5,a5,1
c0025bd0:	ffe68693          	addi	a3,a3,-2
c0025bd4:	fd961ee3          	bne	a2,s9,c0025bb0 <ediv+0x27c>
c0025bd8:	017a9023          	sh	s7,0(s5)
c0025bdc:	03c10793          	addi	a5,sp,60
c0025be0:	0027d703          	lhu	a4,2(a5)
c0025be4:	00278793          	addi	a5,a5,2
c0025be8:	fee79f23          	sh	a4,-2(a5)
c0025bec:	ff879ae3          	bne	a5,s8,c0025be0 <ediv+0x2ac>
c0025bf0:	04011823          	sh	zero,80(sp)
c0025bf4:	002a8a93          	addi	s5,s5,2
c0025bf8:	f5549ce3          	bne	s1,s5,c0025b50 <ediv+0x21c>
c0025bfc:	00000713          	li	a4,0
c0025c00:	03c10793          	addi	a5,sp,60
c0025c04:	05210613          	addi	a2,sp,82
c0025c08:	0007d683          	lhu	a3,0(a5)
c0025c0c:	00278793          	addi	a5,a5,2
c0025c10:	00d76733          	or	a4,a4,a3
c0025c14:	fec79ae3          	bne	a5,a2,c0025c08 <ediv+0x2d4>
c0025c18:	01071793          	slli	a5,a4,0x10
c0025c1c:	4107d793          	srai	a5,a5,0x10
c0025c20:	00078463          	beqz	a5,c0025c28 <ediv+0x2f4>
c0025c24:	00100713          	li	a4,1
c0025c28:	01071593          	slli	a1,a4,0x10
c0025c2c:	0105d593          	srli	a1,a1,0x10
c0025c30:	03498713          	addi	a4,s3,52
c0025c34:	03810793          	addi	a5,sp,56
c0025c38:	00075683          	lhu	a3,0(a4)
c0025c3c:	00278793          	addi	a5,a5,2
c0025c40:	00270713          	addi	a4,a4,2
c0025c44:	fed79f23          	sh	a3,-2(a5)
c0025c48:	fef618e3          	bne	a2,a5,c0025c38 <ediv+0x304>
c0025c4c:	00c12783          	lw	a5,12(sp)
c0025c50:	00812703          	lw	a4,8(sp)
c0025c54:	000046b7          	lui	a3,0x4
c0025c58:	fff68693          	addi	a3,a3,-1 # 3fff <_STACK_SIZE+0x2fff>
c0025c5c:	40e78ab3          	sub	s5,a5,a4
c0025c60:	03810513          	addi	a0,sp,56
c0025c64:	00098793          	mv	a5,s3
c0025c68:	04000713          	li	a4,64
c0025c6c:	00da86b3          	add	a3,s5,a3
c0025c70:	00000613          	li	a2,0
c0025c74:	aa0ff0ef          	jal	ra,c0024f14 <emdnorm>
c0025c78:	03815703          	lhu	a4,56(sp)
c0025c7c:	01c15783          	lhu	a5,28(sp)
c0025c80:	00040593          	mv	a1,s0
c0025c84:	03810513          	addi	a0,sp,56
c0025c88:	40e787b3          	sub	a5,a5,a4
c0025c8c:	00f037b3          	snez	a5,a5
c0025c90:	40f007b3          	neg	a5,a5
c0025c94:	02f11c23          	sh	a5,56(sp)
c0025c98:	c35fe0ef          	jal	ra,c00248cc <emovo.constprop.0>
c0025c9c:	dc5ff06f          	j	c0025a60 <ediv+0x12c>
c0025ca0:	01448713          	addi	a4,s1,20
c0025ca4:	0004d783          	lhu	a5,0(s1)
c0025ca8:	00248493          	addi	s1,s1,2
c0025cac:	00240413          	addi	s0,s0,2
c0025cb0:	fef41f23          	sh	a5,-2(s0)
c0025cb4:	fee498e3          	bne	s1,a4,c0025ca4 <ediv+0x370>
c0025cb8:	da9ff06f          	j	c0025a60 <ediv+0x12c>
c0025cbc:	01490713          	addi	a4,s2,20
c0025cc0:	00095783          	lhu	a5,0(s2)
c0025cc4:	00290913          	addi	s2,s2,2
c0025cc8:	00240413          	addi	s0,s0,2
c0025ccc:	fef41f23          	sh	a5,-2(s0)
c0025cd0:	fee918e3          	bne	s2,a4,c0025cc0 <ediv+0x38c>
c0025cd4:	d8dff06f          	j	c0025a60 <ediv+0x12c>
c0025cd8:	d84a0593          	addi	a1,s4,-636
c0025cdc:	00090513          	mv	a0,s2
c0025ce0:	8f8ff0ef          	jal	ra,c0024dd8 <ecmp>
c0025ce4:	ce051ee3          	bnez	a0,c00259e0 <ediv+0xac>
c0025ce8:	d51ff06f          	j	c0025a38 <ediv+0x104>
c0025cec:	da080ee3          	beqz	a6,c0025aa8 <ediv+0x174>
c0025cf0:	01440793          	addi	a5,s0,20
c0025cf4:	00240413          	addi	s0,s0,2
c0025cf8:	fe041f23          	sh	zero,-2(s0)
c0025cfc:	fef41ce3          	bne	s0,a5,c0025cf4 <ediv+0x3c0>
c0025d00:	d61ff06f          	j	c0025a60 <ediv+0x12c>
c0025d04:	00000813          	li	a6,0
c0025d08:	01290693          	addi	a3,s2,18
c0025d0c:	00090793          	mv	a5,s2
c0025d10:	0007d703          	lhu	a4,0(a5)
c0025d14:	00278793          	addi	a5,a5,2
c0025d18:	fc071ae3          	bnez	a4,c0025cec <ediv+0x3b8>
c0025d1c:	fed79ae3          	bne	a5,a3,c0025d10 <ediv+0x3dc>
c0025d20:	000087b7          	lui	a5,0x8
c0025d24:	fff78793          	addi	a5,a5,-1 # 7fff <_STACK_SIZE+0x6fff>
c0025d28:	04f50a63          	beq	a0,a5,c0025d7c <ediv+0x448>
c0025d2c:	00f65613          	srli	a2,a2,0xf
c0025d30:	00095783          	lhu	a5,0(s2)
c0025d34:	00290913          	addi	s2,s2,2
c0025d38:	18079063          	bnez	a5,c0025eb8 <ediv+0x584>
c0025d3c:	fed91ae3          	bne	s2,a3,c0025d30 <ediv+0x3fc>
c0025d40:	00f5d593          	srli	a1,a1,0xf
c0025d44:	00c58463          	beq	a1,a2,c0025d4c <ediv+0x418>
c0025d48:	00008737          	lui	a4,0x8
c0025d4c:	00e41923          	sh	a4,18(s0)
c0025d50:	00040793          	mv	a5,s0
c0025d54:	01240713          	addi	a4,s0,18
c0025d58:	00278793          	addi	a5,a5,2
c0025d5c:	fe079f23          	sh	zero,-2(a5)
c0025d60:	fee79ce3          	bne	a5,a4,c0025d58 <ediv+0x424>
c0025d64:	01245783          	lhu	a5,18(s0)
c0025d68:	00008737          	lui	a4,0x8
c0025d6c:	fff70713          	addi	a4,a4,-1 # 7fff <_STACK_SIZE+0x6fff>
c0025d70:	00e7e7b3          	or	a5,a5,a4
c0025d74:	00f41923          	sh	a5,18(s0)
c0025d78:	ce9ff06f          	j	c0025a60 <ediv+0x12c>
c0025d7c:	01248513          	addi	a0,s1,18
c0025d80:	0004d783          	lhu	a5,0(s1)
c0025d84:	00248493          	addi	s1,s1,2
c0025d88:	12079c63          	bnez	a5,c0025ec0 <ediv+0x58c>
c0025d8c:	fea49ae3          	bne	s1,a0,c0025d80 <ediv+0x44c>
c0025d90:	f9dff06f          	j	c0025d2c <ediv+0x3f8>
c0025d94:	03c10793          	addi	a5,sp,60
c0025d98:	05010c13          	addi	s8,sp,80
c0025d9c:	0cfc0e63          	beq	s8,a5,c0025e78 <ediv+0x544>
c0025da0:	0007d703          	lhu	a4,0(a5)
c0025da4:	00278793          	addi	a5,a5,2
c0025da8:	fe070ae3          	beqz	a4,c0025d9c <ediv+0x468>
c0025dac:	03810513          	addi	a0,sp,56
c0025db0:	bd9fe0ef          	jal	ra,c0024988 <enormlz>
c0025db4:	40a007b3          	neg	a5,a0
c0025db8:	01e15603          	lhu	a2,30(sp)
c0025dbc:	00f12623          	sw	a5,12(sp)
c0025dc0:	d15ff06f          	j	c0025ad4 <ediv+0x1a0>
c0025dc4:	dec6f0e3          	bgeu	a3,a2,c0025ba4 <ediv+0x270>
c0025dc8:	fffb8793          	addi	a5,s7,-1
c0025dcc:	01079893          	slli	a7,a5,0x10
c0025dd0:	0108d893          	srli	a7,a7,0x10
c0025dd4:	00000693          	li	a3,0
c0025dd8:	03410613          	addi	a2,sp,52
c0025ddc:	06c10713          	addi	a4,sp,108
c0025de0:	00075783          	lhu	a5,0(a4)
c0025de4:	00065583          	lhu	a1,0(a2)
c0025de8:	ffe70713          	addi	a4,a4,-2
c0025dec:	40d787b3          	sub	a5,a5,a3
c0025df0:	40b787b3          	sub	a5,a5,a1
c0025df4:	0107d693          	srli	a3,a5,0x10
c0025df8:	00f71123          	sh	a5,2(a4)
c0025dfc:	0016f693          	andi	a3,a3,1
c0025e00:	ffe60613          	addi	a2,a2,-2
c0025e04:	fdb71ee3          	bne	a4,s11,c0025de0 <ediv+0x4ac>
c0025e08:	03c10713          	addi	a4,sp,60
c0025e0c:	05810793          	addi	a5,sp,88
c0025e10:	0007d603          	lhu	a2,0(a5)
c0025e14:	00075683          	lhu	a3,0(a4)
c0025e18:	00278793          	addi	a5,a5,2
c0025e1c:	00270713          	addi	a4,a4,2
c0025e20:	00d61863          	bne	a2,a3,c0025e30 <ediv+0x4fc>
c0025e24:	ffa796e3          	bne	a5,s10,c0025e10 <ediv+0x4dc>
c0025e28:	00088b93          	mv	s7,a7
c0025e2c:	d79ff06f          	j	c0025ba4 <ediv+0x270>
c0025e30:	fec6fce3          	bgeu	a3,a2,c0025e28 <ediv+0x4f4>
c0025e34:	ffeb8513          	addi	a0,s7,-2
c0025e38:	01051b93          	slli	s7,a0,0x10
c0025e3c:	010bdb93          	srli	s7,s7,0x10
c0025e40:	00000693          	li	a3,0
c0025e44:	03410613          	addi	a2,sp,52
c0025e48:	06c10713          	addi	a4,sp,108
c0025e4c:	00075783          	lhu	a5,0(a4)
c0025e50:	00065583          	lhu	a1,0(a2)
c0025e54:	ffe70713          	addi	a4,a4,-2
c0025e58:	40d787b3          	sub	a5,a5,a3
c0025e5c:	40b787b3          	sub	a5,a5,a1
c0025e60:	0107d693          	srli	a3,a5,0x10
c0025e64:	00f71123          	sh	a5,2(a4)
c0025e68:	0016f693          	andi	a3,a3,1
c0025e6c:	ffe60613          	addi	a2,a2,-2
c0025e70:	fdb71ee3          	bne	a4,s11,c0025e4c <ediv+0x518>
c0025e74:	d31ff06f          	j	c0025ba4 <ediv+0x270>
c0025e78:	01440793          	addi	a5,s0,20
c0025e7c:	00240413          	addi	s0,s0,2
c0025e80:	fe041f23          	sh	zero,-2(s0)
c0025e84:	fef41ce3          	bne	s0,a5,c0025e7c <ediv+0x548>
c0025e88:	bd9ff06f          	j	c0025a60 <ediv+0x12c>
c0025e8c:	01c15703          	lhu	a4,28(sp)
c0025e90:	03815783          	lhu	a5,56(sp)
c0025e94:	00f70463          	beq	a4,a5,c0025e9c <ediv+0x568>
c0025e98:	00008637          	lui	a2,0x8
c0025e9c:	00c41923          	sh	a2,18(s0)
c0025ea0:	01240713          	addi	a4,s0,18
c0025ea4:	00040793          	mv	a5,s0
c0025ea8:	00278793          	addi	a5,a5,2
c0025eac:	fe079f23          	sh	zero,-2(a5)
c0025eb0:	fee79ce3          	bne	a5,a4,c0025ea8 <ediv+0x574>
c0025eb4:	eb1ff06f          	j	c0025d64 <ediv+0x430>
c0025eb8:	00000593          	li	a1,0
c0025ebc:	e89ff06f          	j	c0025d44 <ediv+0x410>
c0025ec0:	00000613          	li	a2,0
c0025ec4:	e6dff06f          	j	c0025d30 <ediv+0x3fc>
c0025ec8:	00100813          	li	a6,1
c0025ecc:	e41ff06f          	j	c0025d0c <ediv+0x3d8>

c0025ed0 <e113toe.isra.0>:
c0025ed0:	fd010113          	addi	sp,sp,-48
c0025ed4:	02812423          	sw	s0,40(sp)
c0025ed8:	02112623          	sw	ra,44(sp)
c0025edc:	00058413          	mv	s0,a1
c0025ee0:	00410793          	addi	a5,sp,4
c0025ee4:	01e10713          	addi	a4,sp,30
c0025ee8:	00278793          	addi	a5,a5,2
c0025eec:	fe079f23          	sh	zero,-2(a5)
c0025ef0:	fee79ce3          	bne	a5,a4,c0025ee8 <e113toe.isra.0+0x18>
c0025ef4:	00e55603          	lhu	a2,14(a0)
c0025ef8:	01061793          	slli	a5,a2,0x10
c0025efc:	4107d793          	srai	a5,a5,0x10
c0025f00:	0607ca63          	bltz	a5,c0025f74 <e113toe.isra.0+0xa4>
c0025f04:	000087b7          	lui	a5,0x8
c0025f08:	fff78793          	addi	a5,a5,-1 # 7fff <_STACK_SIZE+0x6fff>
c0025f0c:	00011223          	sh	zero,4(sp)
c0025f10:	00f67633          	and	a2,a2,a5
c0025f14:	06f60c63          	beq	a2,a5,c0025f8c <e113toe.isra.0+0xbc>
c0025f18:	00e50793          	addi	a5,a0,14
c0025f1c:	00c11323          	sh	a2,6(sp)
c0025f20:	00a10713          	addi	a4,sp,10
c0025f24:	ffe7d683          	lhu	a3,-2(a5)
c0025f28:	ffe78793          	addi	a5,a5,-2
c0025f2c:	00270713          	addi	a4,a4,2
c0025f30:	fed71f23          	sh	a3,-2(a4)
c0025f34:	fef518e3          	bne	a0,a5,c0025f24 <e113toe.isra.0+0x54>
c0025f38:	02061263          	bnez	a2,c0025f5c <e113toe.isra.0+0x8c>
c0025f3c:	00011423          	sh	zero,8(sp)
c0025f40:	00040593          	mv	a1,s0
c0025f44:	00410513          	addi	a0,sp,4
c0025f48:	985fe0ef          	jal	ra,c00248cc <emovo.constprop.0>
c0025f4c:	02c12083          	lw	ra,44(sp)
c0025f50:	02812403          	lw	s0,40(sp)
c0025f54:	03010113          	addi	sp,sp,48
c0025f58:	00008067          	ret
c0025f5c:	00100793          	li	a5,1
c0025f60:	fff00593          	li	a1,-1
c0025f64:	00410513          	addi	a0,sp,4
c0025f68:	00f11423          	sh	a5,8(sp)
c0025f6c:	b99fe0ef          	jal	ra,c0024b04 <eshift.part.0>
c0025f70:	fd1ff06f          	j	c0025f40 <e113toe.isra.0+0x70>
c0025f74:	fff00793          	li	a5,-1
c0025f78:	00f11223          	sh	a5,4(sp)
c0025f7c:	000087b7          	lui	a5,0x8
c0025f80:	fff78793          	addi	a5,a5,-1 # 7fff <_STACK_SIZE+0x6fff>
c0025f84:	00f67633          	and	a2,a2,a5
c0025f88:	f8f618e3          	bne	a2,a5,c0025f18 <e113toe.isra.0+0x48>
c0025f8c:	00050793          	mv	a5,a0
c0025f90:	00e50693          	addi	a3,a0,14
c0025f94:	0007d703          	lhu	a4,0(a5)
c0025f98:	00278793          	addi	a5,a5,2
c0025f9c:	06071c63          	bnez	a4,c0026014 <e113toe.isra.0+0x144>
c0025fa0:	fef69ae3          	bne	a3,a5,c0025f94 <e113toe.isra.0+0xc4>
c0025fa4:	01440713          	addi	a4,s0,20
c0025fa8:	00040793          	mv	a5,s0
c0025fac:	00278793          	addi	a5,a5,2
c0025fb0:	fe079f23          	sh	zero,-2(a5)
c0025fb4:	fee79ce3          	bne	a5,a4,c0025fac <e113toe.isra.0+0xdc>
c0025fb8:	01240713          	addi	a4,s0,18
c0025fbc:	00040793          	mv	a5,s0
c0025fc0:	00278793          	addi	a5,a5,2
c0025fc4:	fe079f23          	sh	zero,-2(a5)
c0025fc8:	fef71ce3          	bne	a4,a5,c0025fc0 <e113toe.isra.0+0xf0>
c0025fcc:	01245783          	lhu	a5,18(s0)
c0025fd0:	000086b7          	lui	a3,0x8
c0025fd4:	fff68693          	addi	a3,a3,-1 # 7fff <_STACK_SIZE+0x6fff>
c0025fd8:	00d7e7b3          	or	a5,a5,a3
c0025fdc:	01079793          	slli	a5,a5,0x10
c0025fe0:	0107d793          	srli	a5,a5,0x10
c0025fe4:	00f41923          	sh	a5,18(s0)
c0025fe8:	00e51683          	lh	a3,14(a0)
c0025fec:	f606d0e3          	bgez	a3,c0025f4c <e113toe.isra.0+0x7c>
c0025ff0:	00040693          	mv	a3,s0
c0025ff4:	0006d603          	lhu	a2,0(a3)
c0025ff8:	00268693          	addi	a3,a3,2
c0025ffc:	f40618e3          	bnez	a2,c0025f4c <e113toe.isra.0+0x7c>
c0026000:	fed71ae3          	bne	a4,a3,c0025ff4 <e113toe.isra.0+0x124>
c0026004:	ffff8737          	lui	a4,0xffff8
c0026008:	00e7c7b3          	xor	a5,a5,a4
c002600c:	00f41923          	sh	a5,18(s0)
c0026010:	f3dff06f          	j	c0025f4c <e113toe.isra.0+0x7c>
c0026014:	01040713          	addi	a4,s0,16
c0026018:	00040793          	mv	a5,s0
c002601c:	00278793          	addi	a5,a5,2
c0026020:	fe079f23          	sh	zero,-2(a5)
c0026024:	fee79ce3          	bne	a5,a4,c002601c <e113toe.isra.0+0x14c>
c0026028:	ffffc7b7          	lui	a5,0xffffc
c002602c:	00f41823          	sh	a5,16(s0)
c0026030:	ffff87b7          	lui	a5,0xffff8
c0026034:	fff7c793          	not	a5,a5
c0026038:	00f41923          	sh	a5,18(s0)
c002603c:	f11ff06f          	j	c0025f4c <e113toe.isra.0+0x7c>

c0026040 <_ldtoa_r>:
c0026040:	00c5a883          	lw	a7,12(a1)
c0026044:	e1010113          	addi	sp,sp,-496
c0026048:	0005ae83          	lw	t4,0(a1)
c002604c:	0045ae03          	lw	t3,4(a1)
c0026050:	0085a303          	lw	t1,8(a1)
c0026054:	03112e23          	sw	a7,60(sp)
c0026058:	04052583          	lw	a1,64(a0)
c002605c:	fff00893          	li	a7,-1
c0026060:	17112023          	sw	a7,352(sp)
c0026064:	09000893          	li	a7,144
c0026068:	1e812423          	sw	s0,488(sp)
c002606c:	1d412c23          	sw	s4,472(sp)
c0026070:	1e112623          	sw	ra,492(sp)
c0026074:	1e912223          	sw	s1,484(sp)
c0026078:	1f212023          	sw	s2,480(sp)
c002607c:	1d312e23          	sw	s3,476(sp)
c0026080:	1d512a23          	sw	s5,468(sp)
c0026084:	1d612823          	sw	s6,464(sp)
c0026088:	1d712623          	sw	s7,460(sp)
c002608c:	1d812423          	sw	s8,456(sp)
c0026090:	1d912223          	sw	s9,452(sp)
c0026094:	1da12023          	sw	s10,448(sp)
c0026098:	1bb12e23          	sw	s11,444(sp)
c002609c:	03d12823          	sw	t4,48(sp)
c00260a0:	03c12a23          	sw	t3,52(sp)
c00260a4:	02612c23          	sw	t1,56(sp)
c00260a8:	17112223          	sw	a7,356(sp)
c00260ac:	00c12023          	sw	a2,0(sp)
c00260b0:	00d12423          	sw	a3,8(sp)
c00260b4:	00e12623          	sw	a4,12(sp)
c00260b8:	01012a23          	sw	a6,20(sp)
c00260bc:	00050a13          	mv	s4,a0
c00260c0:	00078413          	mv	s0,a5
c00260c4:	02058063          	beqz	a1,c00260e4 <_ldtoa_r+0xa4>
c00260c8:	04452703          	lw	a4,68(a0)
c00260cc:	00100793          	li	a5,1
c00260d0:	00e797b3          	sll	a5,a5,a4
c00260d4:	00e5a223          	sw	a4,4(a1)
c00260d8:	00f5a423          	sw	a5,8(a1)
c00260dc:	0b4020ef          	jal	ra,c0028190 <_Bfree>
c00260e0:	040a2023          	sw	zero,64(s4)
c00260e4:	06010913          	addi	s2,sp,96
c00260e8:	00090593          	mv	a1,s2
c00260ec:	03010513          	addi	a0,sp,48
c00260f0:	de1ff0ef          	jal	ra,c0025ed0 <e113toe.isra.0>
c00260f4:	07215603          	lhu	a2,114(sp)
c00260f8:	00008737          	lui	a4,0x8
c00260fc:	fff70713          	addi	a4,a4,-1 # 7fff <_STACK_SIZE+0x6fff>
c0026100:	00e675b3          	and	a1,a2,a4
c0026104:	00e59e63          	bne	a1,a4,c0026120 <_ldtoa_r+0xe0>
c0026108:	00090713          	mv	a4,s2
c002610c:	07210793          	addi	a5,sp,114
c0026110:	00075683          	lhu	a3,0(a4)
c0026114:	00270713          	addi	a4,a4,2
c0026118:	3c0698e3          	bnez	a3,c0026ce8 <_ldtoa_r+0xca8>
c002611c:	fef71ae3          	bne	a4,a5,c0026110 <_ldtoa_r+0xd0>
c0026120:	00f65613          	srli	a2,a2,0xf
c0026124:	00012703          	lw	a4,0(sp)
c0026128:	00c42023          	sw	a2,0(s0)
c002612c:	00300793          	li	a5,3
c0026130:	08f70ee3          	beq	a4,a5,c00269cc <_ldtoa_r+0x98c>
c0026134:	01400793          	li	a5,20
c0026138:	00f12223          	sw	a5,4(sp)
c002613c:	3a071ae3          	bnez	a4,c0026cf0 <_ldtoa_r+0xcb0>
c0026140:	16412703          	lw	a4,356(sp)
c0026144:	000087b7          	lui	a5,0x8
c0026148:	fff78793          	addi	a5,a5,-1 # 7fff <_STACK_SIZE+0x6fff>
c002614c:	00e12823          	sw	a4,16(sp)
c0026150:	00f59e63          	bne	a1,a5,c002616c <_ldtoa_r+0x12c>
c0026154:	00090793          	mv	a5,s2
c0026158:	07210693          	addi	a3,sp,114
c002615c:	0007d703          	lhu	a4,0(a5)
c0026160:	00278793          	addi	a5,a5,2
c0026164:	0e0712e3          	bnez	a4,c0026a48 <_ldtoa_r+0xa08>
c0026168:	fed79ae3          	bne	a5,a3,c002615c <_ldtoa_r+0x11c>
c002616c:	09000793          	li	a5,144
c0026170:	16f12223          	sw	a5,356(sp)
c0026174:	07c10713          	addi	a4,sp,124
c0026178:	00090793          	mv	a5,s2
c002617c:	07410613          	addi	a2,sp,116
c0026180:	0007d683          	lhu	a3,0(a5)
c0026184:	00278793          	addi	a5,a5,2
c0026188:	00270713          	addi	a4,a4,2
c002618c:	fed71f23          	sh	a3,-2(a4)
c0026190:	fec798e3          	bne	a5,a2,c0026180 <_ldtoa_r+0x140>
c0026194:	08e15603          	lhu	a2,142(sp)
c0026198:	00012c23          	sw	zero,24(sp)
c002619c:	01061793          	slli	a5,a2,0x10
c00261a0:	4107d793          	srai	a5,a5,0x10
c00261a4:	5607c863          	bltz	a5,c0026714 <_ldtoa_r+0x6d4>
c00261a8:	c8002bb7          	lui	s7,0xc8002
c00261ac:	d84b8d93          	addi	s11,s7,-636 # c8001d84 <_end+0xfff7d504>
c00261b0:	014d8c13          	addi	s8,s11,20
c00261b4:	00000693          	li	a3,0
c00261b8:	09810793          	addi	a5,sp,152
c00261bc:	000c0713          	mv	a4,s8
c00261c0:	0ac10d13          	addi	s10,sp,172
c00261c4:	0080006f          	j	c00261cc <_ldtoa_r+0x18c>
c00261c8:	00075683          	lhu	a3,0(a4)
c00261cc:	00278793          	addi	a5,a5,2
c00261d0:	fed79f23          	sh	a3,-2(a5)
c00261d4:	00270713          	addi	a4,a4,2
c00261d8:	ffa798e3          	bne	a5,s10,c00261c8 <_ldtoa_r+0x188>
c00261dc:	14060463          	beqz	a2,c0026324 <_ldtoa_r+0x2e4>
c00261e0:	000087b7          	lui	a5,0x8
c00261e4:	fff78793          	addi	a5,a5,-1 # 7fff <_STACK_SIZE+0x6fff>
c00261e8:	4af60ee3          	beq	a2,a5,c0026ea4 <_ldtoa_r+0xe64>
c00261ec:	08c11783          	lh	a5,140(sp)
c00261f0:	5207dce3          	bgez	a5,c0026f28 <_ldtoa_r+0xee8>
c00261f4:	07c10593          	addi	a1,sp,124
c00261f8:	000c0513          	mv	a0,s8
c00261fc:	bddfe0ef          	jal	ra,c0024dd8 <ecmp>
c0026200:	12050e63          	beqz	a0,c002633c <_ldtoa_r+0x2fc>
c0026204:	060542e3          	bltz	a0,c0026a68 <_ldtoa_r+0xa28>
c0026208:	08e15783          	lhu	a5,142(sp)
c002620c:	5c0796e3          	bnez	a5,c0026fd8 <_ldtoa_r+0xf98>
c0026210:	08c11783          	lh	a5,140(sp)
c0026214:	00000493          	li	s1,0
c0026218:	16010993          	addi	s3,sp,352
c002621c:	0207c463          	bltz	a5,c0026244 <_ldtoa_r+0x204>
c0026220:	118d8413          	addi	s0,s11,280
c0026224:	07c10613          	addi	a2,sp,124
c0026228:	00098693          	mv	a3,s3
c002622c:	00060593          	mv	a1,a2
c0026230:	00040513          	mv	a0,s0
c0026234:	a4cff0ef          	jal	ra,c0025480 <emul>
c0026238:	08c11783          	lh	a5,140(sp)
c002623c:	fff48493          	addi	s1,s1,-1
c0026240:	fe07d2e3          	bgez	a5,c0026224 <_ldtoa_r+0x1e4>
c0026244:	0d010413          	addi	s0,sp,208
c0026248:	0e810b13          	addi	s6,sp,232
c002624c:	00040713          	mv	a4,s0
c0026250:	07c10793          	addi	a5,sp,124
c0026254:	09010613          	addi	a2,sp,144
c0026258:	0007d683          	lhu	a3,0(a5)
c002625c:	00278793          	addi	a5,a5,2
c0026260:	00270713          	addi	a4,a4,2
c0026264:	fed71f23          	sh	a3,-2(a4)
c0026268:	fec798e3          	bne	a5,a2,c0026258 <_ldtoa_r+0x218>
c002626c:	00000693          	li	a3,0
c0026270:	09810793          	addi	a5,sp,152
c0026274:	000c0713          	mv	a4,s8
c0026278:	0080006f          	j	c0026280 <_ldtoa_r+0x240>
c002627c:	00075683          	lhu	a3,0(a4)
c0026280:	00278793          	addi	a5,a5,2
c0026284:	fed79f23          	sh	a3,-2(a5)
c0026288:	00270713          	addi	a4,a4,2
c002628c:	ffa798e3          	bne	a5,s10,c002627c <_ldtoa_r+0x23c>
c0026290:	028d8c93          	addi	s9,s11,40
c0026294:	12cd8d13          	addi	s10,s11,300
c0026298:	fffffab7          	lui	s5,0xfffff
c002629c:	118d8d93          	addi	s11,s11,280
c00262a0:	00c0006f          	j	c00262ac <_ldtoa_r+0x26c>
c00262a4:	014d0d13          	addi	s10,s10,20
c00262a8:	014c8c93          	addi	s9,s9,20
c00262ac:	00040593          	mv	a1,s0
c00262b0:	000c0513          	mv	a0,s8
c00262b4:	b25fe0ef          	jal	ra,c0024dd8 <ecmp>
c00262b8:	04a05863          	blez	a0,c0026308 <_ldtoa_r+0x2c8>
c00262bc:	00040593          	mv	a1,s0
c00262c0:	000d0513          	mv	a0,s10
c00262c4:	b15fe0ef          	jal	ra,c0024dd8 <ecmp>
c00262c8:	02054863          	bltz	a0,c00262f8 <_ldtoa_r+0x2b8>
c00262cc:	00098693          	mv	a3,s3
c00262d0:	00040613          	mv	a2,s0
c00262d4:	00040593          	mv	a1,s0
c00262d8:	000c8513          	mv	a0,s9
c00262dc:	9a4ff0ef          	jal	ra,c0025480 <emul>
c00262e0:	09810613          	addi	a2,sp,152
c00262e4:	00098693          	mv	a3,s3
c00262e8:	00060593          	mv	a1,a2
c00262ec:	000c8513          	mv	a0,s9
c00262f0:	990ff0ef          	jal	ra,c0025480 <emul>
c00262f4:	015484b3          	add	s1,s1,s5
c00262f8:	01fad793          	srli	a5,s5,0x1f
c00262fc:	015787b3          	add	a5,a5,s5
c0026300:	4017da93          	srai	s5,a5,0x1
c0026304:	fbbc90e3          	bne	s9,s11,c00262a4 <_ldtoa_r+0x264>
c0026308:	09810613          	addi	a2,sp,152
c002630c:	00098693          	mv	a3,s3
c0026310:	000c0593          	mv	a1,s8
c0026314:	00060513          	mv	a0,a2
c0026318:	e1cff0ef          	jal	ra,c0025934 <ediv>
c002631c:	12410a93          	addi	s5,sp,292
c0026320:	0300006f          	j	c0026350 <_ldtoa_r+0x310>
c0026324:	07c10793          	addi	a5,sp,124
c0026328:	08e10693          	addi	a3,sp,142
c002632c:	0007d703          	lhu	a4,0(a5)
c0026330:	ec0712e3          	bnez	a4,c00261f4 <_ldtoa_r+0x1b4>
c0026334:	00278793          	addi	a5,a5,2
c0026338:	fef69ae3          	bne	a3,a5,c002632c <_ldtoa_r+0x2ec>
c002633c:	00000493          	li	s1,0
c0026340:	12410a93          	addi	s5,sp,292
c0026344:	16010993          	addi	s3,sp,352
c0026348:	0d010413          	addi	s0,sp,208
c002634c:	0e810b13          	addi	s6,sp,232
c0026350:	00040593          	mv	a1,s0
c0026354:	09810513          	addi	a0,sp,152
c0026358:	9cdfe0ef          	jal	ra,c0024d24 <emovi>
c002635c:	09810713          	addi	a4,sp,152
c0026360:	00040793          	mv	a5,s0
c0026364:	0007d683          	lhu	a3,0(a5)
c0026368:	00278793          	addi	a5,a5,2
c002636c:	00270713          	addi	a4,a4,2
c0026370:	fed71f23          	sh	a3,-2(a4)
c0026374:	ff6798e3          	bne	a5,s6,c0026364 <_ldtoa_r+0x324>
c0026378:	00040593          	mv	a1,s0
c002637c:	07c10513          	addi	a0,sp,124
c0026380:	0a011823          	sh	zero,176(sp)
c0026384:	9a1fe0ef          	jal	ra,c0024d24 <emovi>
c0026388:	07c10793          	addi	a5,sp,124
c002638c:	00045703          	lhu	a4,0(s0)
c0026390:	00240413          	addi	s0,s0,2
c0026394:	00278793          	addi	a5,a5,2
c0026398:	fee79f23          	sh	a4,-2(a5)
c002639c:	ff6418e3          	bne	s0,s6,c002638c <_ldtoa_r+0x34c>
c00263a0:	09810513          	addi	a0,sp,152
c00263a4:	00098613          	mv	a2,s3
c00263a8:	07c10593          	addi	a1,sp,124
c00263ac:	08011a23          	sh	zero,148(sp)
c00263b0:	f6dfe0ef          	jal	ra,c002531c <eiremain>
c00263b4:	1ac15503          	lhu	a0,428(sp)
c00263b8:	16051a63          	bnez	a0,c002652c <_ldtoa_r+0x4ec>
c00263bc:	09410c13          	addi	s8,sp,148
c00263c0:	07e10c93          	addi	s9,sp,126
c00263c4:	0b610413          	addi	s0,sp,182
c00263c8:	d84b8593          	addi	a1,s7,-636
c00263cc:	07c10513          	addi	a0,sp,124
c00263d0:	a09fe0ef          	jal	ra,c0024dd8 <ecmp>
c00263d4:	14050c63          	beqz	a0,c002652c <_ldtoa_r+0x4ec>
c00263d8:	00000713          	li	a4,0
c00263dc:	000c0693          	mv	a3,s8
c00263e0:	0006d783          	lhu	a5,0(a3)
c00263e4:	01079613          	slli	a2,a5,0x10
c00263e8:	41065613          	srai	a2,a2,0x10
c00263ec:	00065463          	bgez	a2,c00263f4 <_ldtoa_r+0x3b4>
c00263f0:	00176713          	ori	a4,a4,1
c00263f4:	00179793          	slli	a5,a5,0x1
c00263f8:	01079793          	slli	a5,a5,0x10
c00263fc:	00277613          	andi	a2,a4,2
c0026400:	0107d793          	srli	a5,a5,0x10
c0026404:	00060463          	beqz	a2,c002640c <_ldtoa_r+0x3cc>
c0026408:	0017e793          	ori	a5,a5,1
c002640c:	00171713          	slli	a4,a4,0x1
c0026410:	00f69023          	sh	a5,0(a3)
c0026414:	01071713          	slli	a4,a4,0x10
c0026418:	ffe68693          	addi	a3,a3,-2
c002641c:	01075713          	srli	a4,a4,0x10
c0026420:	fd9690e3          	bne	a3,s9,c00263e0 <_ldtoa_r+0x3a0>
c0026424:	0b410713          	addi	a4,sp,180
c0026428:	07c10793          	addi	a5,sp,124
c002642c:	0007d683          	lhu	a3,0(a5)
c0026430:	00278793          	addi	a5,a5,2
c0026434:	00270713          	addi	a4,a4,2
c0026438:	fed71f23          	sh	a3,-2(a4)
c002643c:	ff8798e3          	bne	a5,s8,c002642c <_ldtoa_r+0x3ec>
c0026440:	0c011623          	sh	zero,204(sp)
c0026444:	00000713          	li	a4,0
c0026448:	0cc10693          	addi	a3,sp,204
c002644c:	0006d783          	lhu	a5,0(a3)
c0026450:	01079613          	slli	a2,a5,0x10
c0026454:	41065613          	srai	a2,a2,0x10
c0026458:	00065463          	bgez	a2,c0026460 <_ldtoa_r+0x420>
c002645c:	00176713          	ori	a4,a4,1
c0026460:	00179793          	slli	a5,a5,0x1
c0026464:	01079793          	slli	a5,a5,0x10
c0026468:	00277613          	andi	a2,a4,2
c002646c:	0107d793          	srli	a5,a5,0x10
c0026470:	00060463          	beqz	a2,c0026478 <_ldtoa_r+0x438>
c0026474:	0017e793          	ori	a5,a5,1
c0026478:	00171713          	slli	a4,a4,0x1
c002647c:	00f69023          	sh	a5,0(a3)
c0026480:	01071713          	slli	a4,a4,0x10
c0026484:	ffe68693          	addi	a3,a3,-2
c0026488:	01075713          	srli	a4,a4,0x10
c002648c:	fc8690e3          	bne	a3,s0,c002644c <_ldtoa_r+0x40c>
c0026490:	00000713          	li	a4,0
c0026494:	0cc10693          	addi	a3,sp,204
c0026498:	0006d783          	lhu	a5,0(a3)
c002649c:	01079613          	slli	a2,a5,0x10
c00264a0:	41065613          	srai	a2,a2,0x10
c00264a4:	00065463          	bgez	a2,c00264ac <_ldtoa_r+0x46c>
c00264a8:	00176713          	ori	a4,a4,1
c00264ac:	00179793          	slli	a5,a5,0x1
c00264b0:	01079793          	slli	a5,a5,0x10
c00264b4:	00277613          	andi	a2,a4,2
c00264b8:	0107d793          	srli	a5,a5,0x10
c00264bc:	00060463          	beqz	a2,c00264c4 <_ldtoa_r+0x484>
c00264c0:	0017e793          	ori	a5,a5,1
c00264c4:	00171713          	slli	a4,a4,0x1
c00264c8:	00f69023          	sh	a5,0(a3)
c00264cc:	01071713          	slli	a4,a4,0x10
c00264d0:	ffe68693          	addi	a3,a3,-2
c00264d4:	01075713          	srli	a4,a4,0x10
c00264d8:	fc8690e3          	bne	a3,s0,c0026498 <_ldtoa_r+0x458>
c00264dc:	00000613          	li	a2,0
c00264e0:	000c0693          	mv	a3,s8
c00264e4:	0cc10713          	addi	a4,sp,204
c00264e8:	0006d583          	lhu	a1,0(a3)
c00264ec:	00075783          	lhu	a5,0(a4)
c00264f0:	ffe68693          	addi	a3,a3,-2
c00264f4:	ffe70713          	addi	a4,a4,-2
c00264f8:	00b787b3          	add	a5,a5,a1
c00264fc:	00c787b3          	add	a5,a5,a2
c0026500:	0107d613          	srli	a2,a5,0x10
c0026504:	00f69123          	sh	a5,2(a3)
c0026508:	00167613          	andi	a2,a2,1
c002650c:	fc871ee3          	bne	a4,s0,c00264e8 <_ldtoa_r+0x4a8>
c0026510:	09810513          	addi	a0,sp,152
c0026514:	00098613          	mv	a2,s3
c0026518:	07c10593          	addi	a1,sp,124
c002651c:	e01fe0ef          	jal	ra,c002531c <eiremain>
c0026520:	1ac15503          	lhu	a0,428(sp)
c0026524:	fff48493          	addi	s1,s1,-1
c0026528:	ea0500e3          	beqz	a0,c00263c8 <_ldtoa_r+0x388>
c002652c:	01812783          	lw	a5,24(sp)
c0026530:	00012683          	lw	a3,0(sp)
c0026534:	00300713          	li	a4,3
c0026538:	00f037b3          	snez	a5,a5
c002653c:	40f007b3          	neg	a5,a5
c0026540:	00d7f793          	andi	a5,a5,13
c0026544:	02078793          	addi	a5,a5,32
c0026548:	12f10223          	sb	a5,292(sp)
c002654c:	00412783          	lw	a5,4(sp)
c0026550:	00e69463          	bne	a3,a4,c0026558 <_ldtoa_r+0x518>
c0026554:	009787b3          	add	a5,a5,s1
c0026558:	02a00713          	li	a4,42
c002655c:	00f12c23          	sw	a5,24(sp)
c0026560:	00f75463          	bge	a4,a5,c0026568 <_ldtoa_r+0x528>
c0026564:	00e12c23          	sw	a4,24(sp)
c0026568:	00a00713          	li	a4,10
c002656c:	4ae50463          	beq	a0,a4,c0026a14 <_ldtoa_r+0x9d4>
c0026570:	03050513          	addi	a0,a0,48
c0026574:	02e00713          	li	a4,46
c0026578:	12a102a3          	sb	a0,293(sp)
c002657c:	12e10323          	sb	a4,294(sp)
c0026580:	1c07c4e3          	bltz	a5,c0026f48 <_ldtoa_r+0xf08>
c0026584:	12710b13          	addi	s6,sp,295
c0026588:	00000413          	li	s0,0
c002658c:	00912e23          	sw	s1,28(sp)
c0026590:	000b0493          	mv	s1,s6
c0026594:	00040b13          	mv	s6,s0
c0026598:	01812403          	lw	s0,24(sp)
c002659c:	0b410c93          	addi	s9,sp,180
c00265a0:	09410d13          	addi	s10,sp,148
c00265a4:	07e10d93          	addi	s11,sp,126
c00265a8:	0b610c13          	addi	s8,sp,182
c00265ac:	00000693          	li	a3,0
c00265b0:	000d0613          	mv	a2,s10
c00265b4:	00065783          	lhu	a5,0(a2) # 8000 <_STACK_SIZE+0x7000>
c00265b8:	01079593          	slli	a1,a5,0x10
c00265bc:	4105d593          	srai	a1,a1,0x10
c00265c0:	0005d463          	bgez	a1,c00265c8 <_ldtoa_r+0x588>
c00265c4:	0016e693          	ori	a3,a3,1
c00265c8:	00179793          	slli	a5,a5,0x1
c00265cc:	01079793          	slli	a5,a5,0x10
c00265d0:	0026f593          	andi	a1,a3,2
c00265d4:	0107d793          	srli	a5,a5,0x10
c00265d8:	00058463          	beqz	a1,c00265e0 <_ldtoa_r+0x5a0>
c00265dc:	0017e793          	ori	a5,a5,1
c00265e0:	00169693          	slli	a3,a3,0x1
c00265e4:	00f61023          	sh	a5,0(a2)
c00265e8:	01069693          	slli	a3,a3,0x10
c00265ec:	ffe60613          	addi	a2,a2,-2
c00265f0:	0106d693          	srli	a3,a3,0x10
c00265f4:	fdb610e3          	bne	a2,s11,c00265b4 <_ldtoa_r+0x574>
c00265f8:	000c8693          	mv	a3,s9
c00265fc:	07c10793          	addi	a5,sp,124
c0026600:	0007d603          	lhu	a2,0(a5)
c0026604:	00278793          	addi	a5,a5,2
c0026608:	00268693          	addi	a3,a3,2
c002660c:	fec69f23          	sh	a2,-2(a3)
c0026610:	ffa798e3          	bne	a5,s10,c0026600 <_ldtoa_r+0x5c0>
c0026614:	0c011623          	sh	zero,204(sp)
c0026618:	00000693          	li	a3,0
c002661c:	0cc10613          	addi	a2,sp,204
c0026620:	00065783          	lhu	a5,0(a2)
c0026624:	01079593          	slli	a1,a5,0x10
c0026628:	4105d593          	srai	a1,a1,0x10
c002662c:	0005d463          	bgez	a1,c0026634 <_ldtoa_r+0x5f4>
c0026630:	0016e693          	ori	a3,a3,1
c0026634:	00179793          	slli	a5,a5,0x1
c0026638:	01079793          	slli	a5,a5,0x10
c002663c:	0026f593          	andi	a1,a3,2
c0026640:	0107d793          	srli	a5,a5,0x10
c0026644:	00058463          	beqz	a1,c002664c <_ldtoa_r+0x60c>
c0026648:	0017e793          	ori	a5,a5,1
c002664c:	00169693          	slli	a3,a3,0x1
c0026650:	00f61023          	sh	a5,0(a2)
c0026654:	01069693          	slli	a3,a3,0x10
c0026658:	ffe60613          	addi	a2,a2,-2
c002665c:	0106d693          	srli	a3,a3,0x10
c0026660:	fd8610e3          	bne	a2,s8,c0026620 <_ldtoa_r+0x5e0>
c0026664:	00000693          	li	a3,0
c0026668:	0cc10613          	addi	a2,sp,204
c002666c:	00065783          	lhu	a5,0(a2)
c0026670:	01079593          	slli	a1,a5,0x10
c0026674:	4105d593          	srai	a1,a1,0x10
c0026678:	0005d463          	bgez	a1,c0026680 <_ldtoa_r+0x640>
c002667c:	0016e693          	ori	a3,a3,1
c0026680:	00179793          	slli	a5,a5,0x1
c0026684:	01079793          	slli	a5,a5,0x10
c0026688:	0026f593          	andi	a1,a3,2
c002668c:	0107d793          	srli	a5,a5,0x10
c0026690:	00058463          	beqz	a1,c0026698 <_ldtoa_r+0x658>
c0026694:	0017e793          	ori	a5,a5,1
c0026698:	00169693          	slli	a3,a3,0x1
c002669c:	00f61023          	sh	a5,0(a2)
c00266a0:	01069693          	slli	a3,a3,0x10
c00266a4:	ffe60613          	addi	a2,a2,-2
c00266a8:	0106d693          	srli	a3,a3,0x10
c00266ac:	fd8610e3          	bne	a2,s8,c002666c <_ldtoa_r+0x62c>
c00266b0:	00000593          	li	a1,0
c00266b4:	000d0613          	mv	a2,s10
c00266b8:	0cc10693          	addi	a3,sp,204
c00266bc:	00065503          	lhu	a0,0(a2)
c00266c0:	0006d783          	lhu	a5,0(a3)
c00266c4:	ffe60613          	addi	a2,a2,-2
c00266c8:	ffe68693          	addi	a3,a3,-2
c00266cc:	00a787b3          	add	a5,a5,a0
c00266d0:	00b787b3          	add	a5,a5,a1
c00266d4:	0107d593          	srli	a1,a5,0x10
c00266d8:	00f61123          	sh	a5,2(a2)
c00266dc:	0015f593          	andi	a1,a1,1
c00266e0:	fd869ee3          	bne	a3,s8,c00266bc <_ldtoa_r+0x67c>
c00266e4:	00098613          	mv	a2,s3
c00266e8:	07c10593          	addi	a1,sp,124
c00266ec:	09810513          	addi	a0,sp,152
c00266f0:	c2dfe0ef          	jal	ra,c002531c <eiremain>
c00266f4:	1ac15603          	lhu	a2,428(sp)
c00266f8:	00148793          	addi	a5,s1,1
c00266fc:	001b0b13          	addi	s6,s6,1
c0026700:	03060693          	addi	a3,a2,48
c0026704:	fed78fa3          	sb	a3,-1(a5)
c0026708:	03644463          	blt	s0,s6,c0026730 <_ldtoa_r+0x6f0>
c002670c:	00078493          	mv	s1,a5
c0026710:	e9dff06f          	j	c00265ac <_ldtoa_r+0x56c>
c0026714:	01161613          	slli	a2,a2,0x11
c0026718:	000107b7          	lui	a5,0x10
c002671c:	01165613          	srli	a2,a2,0x11
c0026720:	fff78793          	addi	a5,a5,-1 # ffff <_STACK_SIZE+0xefff>
c0026724:	08c11723          	sh	a2,142(sp)
c0026728:	00f12c23          	sw	a5,24(sp)
c002672c:	a7dff06f          	j	c00261a8 <_ldtoa_r+0x168>
c0026730:	00048b13          	mv	s6,s1
c0026734:	01c12483          	lw	s1,28(sp)
c0026738:	00400713          	li	a4,4
c002673c:	04c75a63          	bge	a4,a2,c0026790 <_ldtoa_r+0x750>
c0026740:	00500713          	li	a4,5
c0026744:	00e60ae3          	beq	a2,a4,c0026f58 <_ldtoa_r+0xf18>
c0026748:	ffe7c703          	lbu	a4,-2(a5)
c002674c:	01812683          	lw	a3,24(sp)
c0026750:	ffe78613          	addi	a2,a5,-2
c0026754:	07f77713          	andi	a4,a4,127
c0026758:	0206c663          	bltz	a3,c0026784 <_ldtoa_r+0x744>
c002675c:	02e00793          	li	a5,46
c0026760:	03800593          	li	a1,56
c0026764:	03000513          	li	a0,48
c0026768:	76f70663          	beq	a4,a5,c0026ed4 <_ldtoa_r+0xe94>
c002676c:	78e5d263          	bge	a1,a4,c0026ef0 <_ldtoa_r+0xeb0>
c0026770:	fff64703          	lbu	a4,-1(a2)
c0026774:	00a60023          	sb	a0,0(a2)
c0026778:	fff60613          	addi	a2,a2,-1
c002677c:	07f77713          	andi	a4,a4,127
c0026780:	fe9ff06f          	j	c0026768 <_ldtoa_r+0x728>
c0026784:	03100713          	li	a4,49
c0026788:	fee78f23          	sb	a4,-2(a5)
c002678c:	00148493          	addi	s1,s1,1
c0026790:	c80025b7          	lui	a1,0xc8002
c0026794:	00048613          	mv	a2,s1
c0026798:	73458593          	addi	a1,a1,1844 # c8002734 <_end+0xfff7deb4>
c002679c:	000b0513          	mv	a0,s6
c00267a0:	f9cf70ef          	jal	ra,c001df3c <sprintf>
c00267a4:	07215783          	lhu	a5,114(sp)
c00267a8:	01012703          	lw	a4,16(sp)
c00267ac:	16912823          	sw	s1,368(sp)
c00267b0:	fff7c793          	not	a5,a5
c00267b4:	16e12223          	sw	a4,356(sp)
c00267b8:	01179713          	slli	a4,a5,0x11
c00267bc:	18070863          	beqz	a4,c002694c <_ldtoa_r+0x90c>
c00267c0:	00c12683          	lw	a3,12(sp)
c00267c4:	12414703          	lbu	a4,292(sp)
c00267c8:	00148793          	addi	a5,s1,1
c00267cc:	00f6a023          	sw	a5,0(a3)
c00267d0:	000a8793          	mv	a5,s5
c00267d4:	02070a63          	beqz	a4,c0026808 <_ldtoa_r+0x7c8>
c00267d8:	02e00693          	li	a3,46
c00267dc:	20d70663          	beq	a4,a3,c00269e8 <_ldtoa_r+0x9a8>
c00267e0:	0017c703          	lbu	a4,1(a5)
c00267e4:	00178793          	addi	a5,a5,1
c00267e8:	fe071ae3          	bnez	a4,c00267dc <_ldtoa_r+0x79c>
c00267ec:	04500693          	li	a3,69
c00267f0:	00fae663          	bltu	s5,a5,c00267fc <_ldtoa_r+0x7bc>
c00267f4:	0140006f          	j	c0026808 <_ldtoa_r+0x7c8>
c00267f8:	01578863          	beq	a5,s5,c0026808 <_ldtoa_r+0x7c8>
c00267fc:	fff7c703          	lbu	a4,-1(a5)
c0026800:	fff78793          	addi	a5,a5,-1
c0026804:	fed71ae3          	bne	a4,a3,c00267f8 <_ldtoa_r+0x7b8>
c0026808:	00078023          	sb	zero,0(a5)
c002680c:	000a8793          	mv	a5,s5
c0026810:	02000693          	li	a3,32
c0026814:	02d00613          	li	a2,45
c0026818:	0007c703          	lbu	a4,0(a5)
c002681c:	00d70463          	beq	a4,a3,c0026824 <_ldtoa_r+0x7e4>
c0026820:	00c71663          	bne	a4,a2,c002682c <_ldtoa_r+0x7ec>
c0026824:	00178793          	addi	a5,a5,1
c0026828:	ff1ff06f          	j	c0026818 <_ldtoa_r+0x7d8>
c002682c:	000a8413          	mv	s0,s5
c0026830:	00c0006f          	j	c002683c <_ldtoa_r+0x7fc>
c0026834:	0007c703          	lbu	a4,0(a5)
c0026838:	00068413          	mv	s0,a3
c002683c:	00e40023          	sb	a4,0(s0)
c0026840:	00140693          	addi	a3,s0,1
c0026844:	00178793          	addi	a5,a5,1
c0026848:	fe0716e3          	bnez	a4,c0026834 <_ldtoa_r+0x7f4>
c002684c:	00012703          	lw	a4,0(sp)
c0026850:	00200793          	li	a5,2
c0026854:	fff44683          	lbu	a3,-1(s0)
c0026858:	12f70063          	beq	a4,a5,c0026978 <_ldtoa_r+0x938>
c002685c:	00412783          	lw	a5,4(sp)
c0026860:	00078713          	mv	a4,a5
c0026864:	0097d463          	bge	a5,s1,c002686c <_ldtoa_r+0x82c>
c0026868:	00048713          	mv	a4,s1
c002686c:	03000793          	li	a5,48
c0026870:	02f69663          	bne	a3,a5,c002689c <_ldtoa_r+0x85c>
c0026874:	415407b3          	sub	a5,s0,s5
c0026878:	02f75263          	bge	a4,a5,c002689c <_ldtoa_r+0x85c>
c002687c:	03000693          	li	a3,48
c0026880:	00c0006f          	j	c002688c <_ldtoa_r+0x84c>
c0026884:	415407b3          	sub	a5,s0,s5
c0026888:	00f75a63          	bge	a4,a5,c002689c <_ldtoa_r+0x85c>
c002688c:	ffe44783          	lbu	a5,-2(s0)
c0026890:	fe040fa3          	sb	zero,-1(s0)
c0026894:	fff40413          	addi	s0,s0,-1
c0026898:	fed786e3          	beq	a5,a3,c0026884 <_ldtoa_r+0x844>
c002689c:	00012703          	lw	a4,0(sp)
c00268a0:	00300793          	li	a5,3
c00268a4:	0ef70663          	beq	a4,a5,c0026990 <_ldtoa_r+0x950>
c00268a8:	00812783          	lw	a5,8(sp)
c00268ac:	040a2223          	sw	zero,68(s4)
c00268b0:	00978613          	addi	a2,a5,9
c00268b4:	01700793          	li	a5,23
c00268b8:	10c7f663          	bgeu	a5,a2,c00269c4 <_ldtoa_r+0x984>
c00268bc:	00100713          	li	a4,1
c00268c0:	00400793          	li	a5,4
c00268c4:	00179793          	slli	a5,a5,0x1
c00268c8:	01478693          	addi	a3,a5,20
c00268cc:	00070593          	mv	a1,a4
c00268d0:	00170713          	addi	a4,a4,1
c00268d4:	fed678e3          	bgeu	a2,a3,c00268c4 <_ldtoa_r+0x884>
c00268d8:	04ba2223          	sw	a1,68(s4)
c00268dc:	000a0513          	mv	a0,s4
c00268e0:	009010ef          	jal	ra,c00280e8 <_Balloc>
c00268e4:	00050493          	mv	s1,a0
c00268e8:	080502e3          	beqz	a0,c002716c <_ldtoa_r+0x112c>
c00268ec:	04aa2023          	sw	a0,64(s4)
c00268f0:	000a8593          	mv	a1,s5
c00268f4:	ec4f70ef          	jal	ra,c001dfb8 <strcpy>
c00268f8:	01412703          	lw	a4,20(sp)
c00268fc:	00070863          	beqz	a4,c002690c <_ldtoa_r+0x8cc>
c0026900:	415407b3          	sub	a5,s0,s5
c0026904:	00f487b3          	add	a5,s1,a5
c0026908:	00f72023          	sw	a5,0(a4)
c002690c:	1ec12083          	lw	ra,492(sp)
c0026910:	1e812403          	lw	s0,488(sp)
c0026914:	1e012903          	lw	s2,480(sp)
c0026918:	1dc12983          	lw	s3,476(sp)
c002691c:	1d812a03          	lw	s4,472(sp)
c0026920:	1d412a83          	lw	s5,468(sp)
c0026924:	1d012b03          	lw	s6,464(sp)
c0026928:	1cc12b83          	lw	s7,460(sp)
c002692c:	1c812c03          	lw	s8,456(sp)
c0026930:	1c412c83          	lw	s9,452(sp)
c0026934:	1c012d03          	lw	s10,448(sp)
c0026938:	1bc12d83          	lw	s11,444(sp)
c002693c:	00048513          	mv	a0,s1
c0026940:	1e412483          	lw	s1,484(sp)
c0026944:	1f010113          	addi	sp,sp,496
c0026948:	00008067          	ret
c002694c:	00090793          	mv	a5,s2
c0026950:	07210693          	addi	a3,sp,114
c0026954:	0007d703          	lhu	a4,0(a5)
c0026958:	00278793          	addi	a5,a5,2
c002695c:	5a071063          	bnez	a4,c0026efc <_ldtoa_r+0xebc>
c0026960:	fed79ae3          	bne	a5,a3,c0026954 <_ldtoa_r+0x914>
c0026964:	00c12703          	lw	a4,12(sp)
c0026968:	000027b7          	lui	a5,0x2
c002696c:	70f78793          	addi	a5,a5,1807 # 270f <_STACK_SIZE+0x170f>
c0026970:	00f72023          	sw	a5,0(a4)
c0026974:	e99ff06f          	j	c002680c <_ldtoa_r+0x7cc>
c0026978:	03000793          	li	a5,48
c002697c:	f2f696e3          	bne	a3,a5,c00268a8 <_ldtoa_r+0x868>
c0026980:	415407b3          	sub	a5,s0,s5
c0026984:	00100713          	li	a4,1
c0026988:	eef74ae3          	blt	a4,a5,c002687c <_ldtoa_r+0x83c>
c002698c:	f1dff06f          	j	c00268a8 <_ldtoa_r+0x868>
c0026990:	00412783          	lw	a5,4(sp)
c0026994:	009784b3          	add	s1,a5,s1
c0026998:	4e04c063          	bltz	s1,c0026e78 <_ldtoa_r+0xe38>
c002699c:	00c12783          	lw	a5,12(sp)
c00269a0:	00812703          	lw	a4,8(sp)
c00269a4:	0007a783          	lw	a5,0(a5)
c00269a8:	00f707b3          	add	a5,a4,a5
c00269ac:	00f12423          	sw	a5,8(sp)
c00269b0:	00812783          	lw	a5,8(sp)
c00269b4:	040a2223          	sw	zero,68(s4)
c00269b8:	00378613          	addi	a2,a5,3
c00269bc:	01700793          	li	a5,23
c00269c0:	eec7eee3          	bltu	a5,a2,c00268bc <_ldtoa_r+0x87c>
c00269c4:	00000593          	li	a1,0
c00269c8:	f15ff06f          	j	c00268dc <_ldtoa_r+0x89c>
c00269cc:	00812783          	lw	a5,8(sp)
c00269d0:	00078713          	mv	a4,a5
c00269d4:	00f12223          	sw	a5,4(sp)
c00269d8:	02a00793          	li	a5,42
c00269dc:	f6e7d263          	bge	a5,a4,c0026140 <_ldtoa_r+0x100>
c00269e0:	00f12223          	sw	a5,4(sp)
c00269e4:	f5cff06f          	j	c0026140 <_ldtoa_r+0x100>
c00269e8:	0007c703          	lbu	a4,0(a5)
c00269ec:	e00700e3          	beqz	a4,c00267ec <_ldtoa_r+0x7ac>
c00269f0:	0017c703          	lbu	a4,1(a5)
c00269f4:	00178793          	addi	a5,a5,1
c00269f8:	fee78fa3          	sb	a4,-1(a5)
c00269fc:	de0708e3          	beqz	a4,c00267ec <_ldtoa_r+0x7ac>
c0026a00:	0017c703          	lbu	a4,1(a5)
c0026a04:	00178793          	addi	a5,a5,1
c0026a08:	fee78fa3          	sb	a4,-1(a5)
c0026a0c:	fe0712e3          	bnez	a4,c00269f0 <_ldtoa_r+0x9b0>
c0026a10:	dddff06f          	j	c00267ec <_ldtoa_r+0x7ac>
c0026a14:	03100713          	li	a4,49
c0026a18:	12e102a3          	sb	a4,293(sp)
c0026a1c:	02e00713          	li	a4,46
c0026a20:	12e10323          	sb	a4,294(sp)
c0026a24:	00148493          	addi	s1,s1,1
c0026a28:	2af05a63          	blez	a5,c0026cdc <_ldtoa_r+0xc9c>
c0026a2c:	03000793          	li	a5,48
c0026a30:	12f103a3          	sb	a5,295(sp)
c0026a34:	01812783          	lw	a5,24(sp)
c0026a38:	12810b13          	addi	s6,sp,296
c0026a3c:	fff78793          	addi	a5,a5,-1
c0026a40:	00f12c23          	sw	a5,24(sp)
c0026a44:	b45ff06f          	j	c0026588 <_ldtoa_r+0x548>
c0026a48:	12410a93          	addi	s5,sp,292
c0026a4c:	c80025b7          	lui	a1,0xc8002
c0026a50:	79458593          	addi	a1,a1,1940 # c8002794 <_end+0xfff7df14>
c0026a54:	000a8513          	mv	a0,s5
c0026a58:	000024b7          	lui	s1,0x2
c0026a5c:	ce0f70ef          	jal	ra,c001df3c <sprintf>
c0026a60:	70f48493          	addi	s1,s1,1807 # 270f <_STACK_SIZE+0x170f>
c0026a64:	d41ff06f          	j	c00267a4 <_ldtoa_r+0x764>
c0026a68:	0b410c93          	addi	s9,sp,180
c0026a6c:	000c8713          	mv	a4,s9
c0026a70:	07c10793          	addi	a5,sp,124
c0026a74:	09010613          	addi	a2,sp,144
c0026a78:	0007d683          	lhu	a3,0(a5)
c0026a7c:	00278793          	addi	a5,a5,2
c0026a80:	00270713          	addi	a4,a4,2
c0026a84:	fed71f23          	sh	a3,-2(a4)
c0026a88:	fec798e3          	bne	a5,a2,c0026a78 <_ldtoa_r+0xa38>
c0026a8c:	000047b7          	lui	a5,0x4
c0026a90:	08e78793          	addi	a5,a5,142 # 408e <_STACK_SIZE+0x308e>
c0026a94:	0cf11323          	sh	a5,198(sp)
c0026a98:	000087b7          	lui	a5,0x8
c0026a9c:	fff78793          	addi	a5,a5,-1 # 7fff <_STACK_SIZE+0x6fff>
c0026aa0:	00f12e23          	sw	a5,28(sp)
c0026aa4:	ffffc7b7          	lui	a5,0xffffc
c0026aa8:	12410a93          	addi	s5,sp,292
c0026aac:	0d010413          	addi	s0,sp,208
c0026ab0:	01000713          	li	a4,16
c0026ab4:	0c8d8313          	addi	t1,s11,200
c0026ab8:	00278793          	addi	a5,a5,2 # ffffc002 <_end+0x37f77782>
c0026abc:	03412423          	sw	s4,40(sp)
c0026ac0:	03512223          	sw	s5,36(sp)
c0026ac4:	00000493          	li	s1,0
c0026ac8:	00040a93          	mv	s5,s0
c0026acc:	16010993          	addi	s3,sp,352
c0026ad0:	0aa10b13          	addi	s6,sp,170
c0026ad4:	02f12023          	sw	a5,32(sp)
c0026ad8:	00030a13          	mv	s4,t1
c0026adc:	00070413          	mv	s0,a4
c0026ae0:	00098693          	mv	a3,s3
c0026ae4:	09810613          	addi	a2,sp,152
c0026ae8:	000c8593          	mv	a1,s9
c0026aec:	000a0513          	mv	a0,s4
c0026af0:	e45fe0ef          	jal	ra,c0025934 <ediv>
c0026af4:	04c10713          	addi	a4,sp,76
c0026af8:	09810793          	addi	a5,sp,152
c0026afc:	0007d683          	lhu	a3,0(a5)
c0026b00:	00278793          	addi	a5,a5,2
c0026b04:	00270713          	addi	a4,a4,2
c0026b08:	fed71f23          	sh	a3,-2(a4)
c0026b0c:	ffa798e3          	bne	a5,s10,c0026afc <_ldtoa_r+0xabc>
c0026b10:	01c12783          	lw	a5,28(sp)
c0026b14:	05e15583          	lhu	a1,94(sp)
c0026b18:	00f5f633          	and	a2,a1,a5
c0026b1c:	02012783          	lw	a5,32(sp)
c0026b20:	00f60533          	add	a0,a2,a5
c0026b24:	36a05463          	blez	a0,c0026e8c <_ldtoa_r+0xe4c>
c0026b28:	09000613          	li	a2,144
c0026b2c:	40a60633          	sub	a2,a2,a0
c0026b30:	000a8713          	mv	a4,s5
c0026b34:	04c10793          	addi	a5,sp,76
c0026b38:	0007d683          	lhu	a3,0(a5)
c0026b3c:	00278793          	addi	a5,a5,2
c0026b40:	00270713          	addi	a4,a4,2
c0026b44:	fed71f23          	sh	a3,-2(a4)
c0026b48:	ff2798e3          	bne	a5,s2,c0026b38 <_ldtoa_r+0xaf8>
c0026b4c:	06c05663          	blez	a2,c0026bb8 <_ldtoa_r+0xb78>
c0026b50:	00f00793          	li	a5,15
c0026b54:	000a8713          	mv	a4,s5
c0026b58:	02c7de63          	bge	a5,a2,c0026b94 <_ldtoa_r+0xb54>
c0026b5c:	08000693          	li	a3,128
c0026b60:	40a686b3          	sub	a3,a3,a0
c0026b64:	0046d693          	srli	a3,a3,0x4
c0026b68:	00168713          	addi	a4,a3,1
c0026b6c:	00171713          	slli	a4,a4,0x1
c0026b70:	00ea8733          	add	a4,s5,a4
c0026b74:	000a8793          	mv	a5,s5
c0026b78:	00278793          	addi	a5,a5,2
c0026b7c:	fe079f23          	sh	zero,-2(a5)
c0026b80:	fef71ce3          	bne	a4,a5,c0026b78 <_ldtoa_r+0xb38>
c0026b84:	08000613          	li	a2,128
c0026b88:	40a60633          	sub	a2,a2,a0
c0026b8c:	00469693          	slli	a3,a3,0x4
c0026b90:	40d60633          	sub	a2,a2,a3
c0026b94:	00161793          	slli	a5,a2,0x1
c0026b98:	00fd87b3          	add	a5,s11,a5
c0026b9c:	00075683          	lhu	a3,0(a4)
c0026ba0:	2307d783          	lhu	a5,560(a5)
c0026ba4:	00f6f7b3          	and	a5,a3,a5
c0026ba8:	00f71023          	sh	a5,0(a4)
c0026bac:	01059593          	slli	a1,a1,0x10
c0026bb0:	4105d593          	srai	a1,a1,0x10
c0026bb4:	1405c463          	bltz	a1,c0026cfc <_ldtoa_r+0xcbc>
c0026bb8:	09810793          	addi	a5,sp,152
c0026bbc:	000a8713          	mv	a4,s5
c0026bc0:	0007d603          	lhu	a2,0(a5)
c0026bc4:	00075683          	lhu	a3,0(a4)
c0026bc8:	02d61863          	bne	a2,a3,c0026bf8 <_ldtoa_r+0xbb8>
c0026bcc:	00278793          	addi	a5,a5,2
c0026bd0:	00270713          	addi	a4,a4,2
c0026bd4:	fefb16e3          	bne	s6,a5,c0026bc0 <_ldtoa_r+0xb80>
c0026bd8:	000c8713          	mv	a4,s9
c0026bdc:	09810793          	addi	a5,sp,152
c0026be0:	0007d683          	lhu	a3,0(a5)
c0026be4:	00278793          	addi	a5,a5,2
c0026be8:	00270713          	addi	a4,a4,2
c0026bec:	fed71f23          	sh	a3,-2(a4)
c0026bf0:	ffa798e3          	bne	a5,s10,c0026be0 <_ldtoa_r+0xba0>
c0026bf4:	008484b3          	add	s1,s1,s0
c0026bf8:	014a0a13          	addi	s4,s4,20
c0026bfc:	12cd8793          	addi	a5,s11,300
c0026c00:	00145413          	srli	s0,s0,0x1
c0026c04:	ecfa1ee3          	bne	s4,a5,c0026ae0 <_ldtoa_r+0xaa0>
c0026c08:	0c615783          	lhu	a5,198(sp)
c0026c0c:	08e15703          	lhu	a4,142(sp)
c0026c10:	000a8413          	mv	s0,s5
c0026c14:	02812a03          	lw	s4,40(sp)
c0026c18:	00e787b3          	add	a5,a5,a4
c0026c1c:	ffffc737          	lui	a4,0xffffc
c0026c20:	f7270713          	addi	a4,a4,-142 # ffffbf72 <_end+0x37f776f2>
c0026c24:	02412a83          	lw	s5,36(sp)
c0026c28:	00e787b3          	add	a5,a5,a4
c0026c2c:	0cf11323          	sh	a5,198(sp)
c0026c30:	07c10713          	addi	a4,sp,124
c0026c34:	000c8793          	mv	a5,s9
c0026c38:	0c810613          	addi	a2,sp,200
c0026c3c:	0007d683          	lhu	a3,0(a5)
c0026c40:	00278793          	addi	a5,a5,2
c0026c44:	00270713          	addi	a4,a4,2
c0026c48:	fed71f23          	sh	a3,-2(a4)
c0026c4c:	fec798e3          	bne	a5,a2,c0026c3c <_ldtoa_r+0xbfc>
c0026c50:	00000713          	li	a4,0
c0026c54:	09810793          	addi	a5,sp,152
c0026c58:	0080006f          	j	c0026c60 <_ldtoa_r+0xc20>
c0026c5c:	000c5703          	lhu	a4,0(s8)
c0026c60:	00278793          	addi	a5,a5,2
c0026c64:	fee79f23          	sh	a4,-2(a5)
c0026c68:	002c0c13          	addi	s8,s8,2
c0026c6c:	ffa798e3          	bne	a5,s10,c0026c5c <_ldtoa_r+0xc1c>
c0026c70:	028d8d13          	addi	s10,s11,40
c0026c74:	00001c37          	lui	s8,0x1
c0026c78:	118d8d93          	addi	s11,s11,280
c0026c7c:	0100006f          	j	c0026c8c <_ldtoa_r+0xc4c>
c0026c80:	001c5c13          	srli	s8,s8,0x1
c0026c84:	25bd0463          	beq	s10,s11,c0026ecc <_ldtoa_r+0xe8c>
c0026c88:	014d0d13          	addi	s10,s10,20
c0026c8c:	000c8593          	mv	a1,s9
c0026c90:	000d8513          	mv	a0,s11
c0026c94:	944fe0ef          	jal	ra,c0024dd8 <ecmp>
c0026c98:	22a04a63          	bgtz	a0,c0026ecc <_ldtoa_r+0xe8c>
c0026c9c:	000c8593          	mv	a1,s9
c0026ca0:	000d0513          	mv	a0,s10
c0026ca4:	934fe0ef          	jal	ra,c0024dd8 <ecmp>
c0026ca8:	fca04ce3          	bgtz	a0,c0026c80 <_ldtoa_r+0xc40>
c0026cac:	00098693          	mv	a3,s3
c0026cb0:	000c8613          	mv	a2,s9
c0026cb4:	000c8593          	mv	a1,s9
c0026cb8:	000d0513          	mv	a0,s10
c0026cbc:	c79fe0ef          	jal	ra,c0025934 <ediv>
c0026cc0:	09810613          	addi	a2,sp,152
c0026cc4:	00098693          	mv	a3,s3
c0026cc8:	00060593          	mv	a1,a2
c0026ccc:	000d0513          	mv	a0,s10
c0026cd0:	fb0fe0ef          	jal	ra,c0025480 <emul>
c0026cd4:	018484b3          	add	s1,s1,s8
c0026cd8:	fa9ff06f          	j	c0026c80 <_ldtoa_r+0xc40>
c0026cdc:	12710b13          	addi	s6,sp,295
c0026ce0:	aa0798e3          	bnez	a5,c0026790 <_ldtoa_r+0x750>
c0026ce4:	8a5ff06f          	j	c0026588 <_ldtoa_r+0x548>
c0026ce8:	00000613          	li	a2,0
c0026cec:	c38ff06f          	j	c0026124 <_ldtoa_r+0xe4>
c0026cf0:	00812783          	lw	a5,8(sp)
c0026cf4:	fff78793          	addi	a5,a5,-1
c0026cf8:	cd9ff06f          	j	c00269d0 <_ldtoa_r+0x990>
c0026cfc:	04c10793          	addi	a5,sp,76
c0026d00:	000a8713          	mv	a4,s5
c0026d04:	0140006f          	j	c0026d18 <_ldtoa_r+0xcd8>
c0026d08:	00278793          	addi	a5,a5,2
c0026d0c:	05e10693          	addi	a3,sp,94
c0026d10:	00270713          	addi	a4,a4,2
c0026d14:	eaf682e3          	beq	a3,a5,c0026bb8 <_ldtoa_r+0xb78>
c0026d18:	0007d603          	lhu	a2,0(a5)
c0026d1c:	00075683          	lhu	a3,0(a4)
c0026d20:	fed604e3          	beq	a2,a3,c0026d08 <_ldtoa_r+0xcc8>
c0026d24:	0e215783          	lhu	a5,226(sp)
c0026d28:	01c12703          	lw	a4,28(sp)
c0026d2c:	00f777b3          	and	a5,a4,a5
c0026d30:	3ce78063          	beq	a5,a4,c00270f0 <_ldtoa_r+0x10b0>
c0026d34:	0ec10593          	addi	a1,sp,236
c0026d38:	000c0513          	mv	a0,s8
c0026d3c:	fe9fd0ef          	jal	ra,c0024d24 <emovi>
c0026d40:	10810593          	addi	a1,sp,264
c0026d44:	000a8513          	mv	a0,s5
c0026d48:	fddfd0ef          	jal	ra,c0024d24 <emovi>
c0026d4c:	0ec15703          	lhu	a4,236(sp)
c0026d50:	10a15603          	lhu	a2,266(sp)
c0026d54:	0ee15883          	lhu	a7,238(sp)
c0026d58:	fff74713          	not	a4,a4
c0026d5c:	01071713          	slli	a4,a4,0x10
c0026d60:	01075713          	srli	a4,a4,0x10
c0026d64:	0ee11623          	sh	a4,236(sp)
c0026d68:	40c885b3          	sub	a1,a7,a2
c0026d6c:	00060693          	mv	a3,a2
c0026d70:	06b05e63          	blez	a1,c0026dec <_ldtoa_r+0xdac>
c0026d74:	02412583          	lw	a1,36(sp)
c0026d78:	10810693          	addi	a3,sp,264
c0026d7c:	12010793          	addi	a5,sp,288
c0026d80:	0006d503          	lhu	a0,0(a3)
c0026d84:	00268693          	addi	a3,a3,2
c0026d88:	00258593          	addi	a1,a1,2
c0026d8c:	fea59f23          	sh	a0,-2(a1)
c0026d90:	fef698e3          	bne	a3,a5,c0026d80 <_ldtoa_r+0xd40>
c0026d94:	12011e23          	sh	zero,316(sp)
c0026d98:	10810693          	addi	a3,sp,264
c0026d9c:	0ec10593          	addi	a1,sp,236
c0026da0:	0080006f          	j	c0026da8 <_ldtoa_r+0xd68>
c0026da4:	0005d703          	lhu	a4,0(a1)
c0026da8:	00268693          	addi	a3,a3,2
c0026dac:	fee69f23          	sh	a4,-2(a3)
c0026db0:	00258593          	addi	a1,a1,2
c0026db4:	fef698e3          	bne	a3,a5,c0026da4 <_ldtoa_r+0xd64>
c0026db8:	02412783          	lw	a5,36(sp)
c0026dbc:	12011023          	sh	zero,288(sp)
c0026dc0:	0ec10713          	addi	a4,sp,236
c0026dc4:	13c10513          	addi	a0,sp,316
c0026dc8:	0007d683          	lhu	a3,0(a5)
c0026dcc:	00278793          	addi	a5,a5,2
c0026dd0:	00270713          	addi	a4,a4,2
c0026dd4:	fed71f23          	sh	a3,-2(a4)
c0026dd8:	fea798e3          	bne	a5,a0,c0026dc8 <_ldtoa_r+0xd88>
c0026ddc:	10a15683          	lhu	a3,266(sp)
c0026de0:	411605b3          	sub	a1,a2,a7
c0026de4:	10011223          	sh	zero,260(sp)
c0026de8:	00068613          	mv	a2,a3
c0026dec:	32058c63          	beqz	a1,c0027124 <_ldtoa_r+0x10e4>
c0026df0:	02d12623          	sw	a3,44(sp)
c0026df4:	f6f00793          	li	a5,-145
c0026df8:	06f5c863          	blt	a1,a5,c0026e68 <_ldtoa_r+0xe28>
c0026dfc:	0ec10513          	addi	a0,sp,236
c0026e00:	d05fd0ef          	jal	ra,c0024b04 <eshift.part.0>
c0026e04:	02c12683          	lw	a3,44(sp)
c0026e08:	00050593          	mv	a1,a0
c0026e0c:	12010793          	addi	a5,sp,288
c0026e10:	10410713          	addi	a4,sp,260
c0026e14:	0ec15503          	lhu	a0,236(sp)
c0026e18:	10815603          	lhu	a2,264(sp)
c0026e1c:	3ac50863          	beq	a0,a2,c00271cc <_ldtoa_r+0x118c>
c0026e20:	00000613          	li	a2,0
c0026e24:	10a10893          	addi	a7,sp,266
c0026e28:	00060513          	mv	a0,a2
c0026e2c:	0007d603          	lhu	a2,0(a5)
c0026e30:	00075803          	lhu	a6,0(a4)
c0026e34:	ffe78793          	addi	a5,a5,-2
c0026e38:	40a60633          	sub	a2,a2,a0
c0026e3c:	41060633          	sub	a2,a2,a6
c0026e40:	01065513          	srli	a0,a2,0x10
c0026e44:	00c79123          	sh	a2,2(a5)
c0026e48:	00157513          	andi	a0,a0,1
c0026e4c:	ffe70713          	addi	a4,a4,-2
c0026e50:	fd179ee3          	bne	a5,a7,c0026e2c <_ldtoa_r+0xdec>
c0026e54:	00100613          	li	a2,1
c0026e58:	00098793          	mv	a5,s3
c0026e5c:	04000713          	li	a4,64
c0026e60:	10810513          	addi	a0,sp,264
c0026e64:	8b0fe0ef          	jal	ra,c0024f14 <emdnorm>
c0026e68:	000a8593          	mv	a1,s5
c0026e6c:	10810513          	addi	a0,sp,264
c0026e70:	a5dfd0ef          	jal	ra,c00248cc <emovo.constprop.0>
c0026e74:	d45ff06f          	j	c0026bb8 <_ldtoa_r+0xb78>
c0026e78:	00c12783          	lw	a5,12(sp)
c0026e7c:	12010223          	sb	zero,292(sp)
c0026e80:	000a8413          	mv	s0,s5
c0026e84:	0007a023          	sw	zero,0(a5)
c0026e88:	b29ff06f          	j	c00269b0 <_ldtoa_r+0x970>
c0026e8c:	000a8793          	mv	a5,s5
c0026e90:	0e410713          	addi	a4,sp,228
c0026e94:	00278793          	addi	a5,a5,2
c0026e98:	fe079f23          	sh	zero,-2(a5)
c0026e9c:	fee79ce3          	bne	a5,a4,c0026e94 <_ldtoa_r+0xe54>
c0026ea0:	d0dff06f          	j	c0026bac <_ldtoa_r+0xb6c>
c0026ea4:	01812783          	lw	a5,24(sp)
c0026ea8:	12410a93          	addi	s5,sp,292
c0026eac:	10078263          	beqz	a5,c0026fb0 <_ldtoa_r+0xf70>
c0026eb0:	c80025b7          	lui	a1,0xc8002
c0026eb4:	71858593          	addi	a1,a1,1816 # c8002718 <_end+0xfff7de98>
c0026eb8:	000a8513          	mv	a0,s5
c0026ebc:	000024b7          	lui	s1,0x2
c0026ec0:	87cf70ef          	jal	ra,c001df3c <sprintf>
c0026ec4:	70f48493          	addi	s1,s1,1807 # 270f <_STACK_SIZE+0x170f>
c0026ec8:	8ddff06f          	j	c00267a4 <_ldtoa_r+0x764>
c0026ecc:	0e810b13          	addi	s6,sp,232
c0026ed0:	c80ff06f          	j	c0026350 <_ldtoa_r+0x310>
c0026ed4:	fff64783          	lbu	a5,-1(a2)
c0026ed8:	03800713          	li	a4,56
c0026edc:	0ef77863          	bgeu	a4,a5,c0026fcc <_ldtoa_r+0xf8c>
c0026ee0:	03100793          	li	a5,49
c0026ee4:	00148493          	addi	s1,s1,1
c0026ee8:	fef60fa3          	sb	a5,-1(a2)
c0026eec:	8a5ff06f          	j	c0026790 <_ldtoa_r+0x750>
c0026ef0:	00170713          	addi	a4,a4,1
c0026ef4:	00e60023          	sb	a4,0(a2)
c0026ef8:	899ff06f          	j	c0026790 <_ldtoa_r+0x750>
c0026efc:	07210713          	addi	a4,sp,114
c0026f00:	0080006f          	j	c0026f08 <_ldtoa_r+0xec8>
c0026f04:	8ae90ee3          	beq	s2,a4,c00267c0 <_ldtoa_r+0x780>
c0026f08:	00095783          	lhu	a5,0(s2)
c0026f0c:	00290913          	addi	s2,s2,2
c0026f10:	fe078ae3          	beqz	a5,c0026f04 <_ldtoa_r+0xec4>
c0026f14:	00c12703          	lw	a4,12(sp)
c0026f18:	000027b7          	lui	a5,0x2
c0026f1c:	70f78793          	addi	a5,a5,1807 # 270f <_STACK_SIZE+0x170f>
c0026f20:	00f72023          	sw	a5,0(a4)
c0026f24:	8e9ff06f          	j	c002680c <_ldtoa_r+0x7cc>
c0026f28:	12410a93          	addi	s5,sp,292
c0026f2c:	c80025b7          	lui	a1,0xc8002
c0026f30:	73058593          	addi	a1,a1,1840 # c8002730 <_end+0xfff7deb0>
c0026f34:	000a8513          	mv	a0,s5
c0026f38:	000024b7          	lui	s1,0x2
c0026f3c:	800f70ef          	jal	ra,c001df3c <sprintf>
c0026f40:	70f48493          	addi	s1,s1,1807 # 270f <_STACK_SIZE+0x170f>
c0026f44:	861ff06f          	j	c00267a4 <_ldtoa_r+0x764>
c0026f48:	1ac15603          	lhu	a2,428(sp)
c0026f4c:	12610b13          	addi	s6,sp,294
c0026f50:	12710793          	addi	a5,sp,295
c0026f54:	fe4ff06f          	j	c0026738 <_ldtoa_r+0x6f8>
c0026f58:	09810593          	addi	a1,sp,152
c0026f5c:	07c10513          	addi	a0,sp,124
c0026f60:	00f12e23          	sw	a5,28(sp)
c0026f64:	969fd0ef          	jal	ra,c00248cc <emovo.constprop.0>
c0026f68:	d84b8593          	addi	a1,s7,-636
c0026f6c:	09810513          	addi	a0,sp,152
c0026f70:	e69fd0ef          	jal	ra,c0024dd8 <ecmp>
c0026f74:	01c12783          	lw	a5,28(sp)
c0026f78:	fc051863          	bnez	a0,c0026748 <_ldtoa_r+0x708>
c0026f7c:	01812703          	lw	a4,24(sp)
c0026f80:	800748e3          	bltz	a4,c0026790 <_ldtoa_r+0x750>
c0026f84:	ffe7c703          	lbu	a4,-2(a5)
c0026f88:	fd270613          	addi	a2,a4,-46
c0026f8c:	00163613          	seqz	a2,a2
c0026f90:	fff64613          	not	a2,a2
c0026f94:	00cb0633          	add	a2,s6,a2
c0026f98:	00064603          	lbu	a2,0(a2)
c0026f9c:	00167613          	andi	a2,a2,1
c0026fa0:	fe060863          	beqz	a2,c0026790 <_ldtoa_r+0x750>
c0026fa4:	ffe78613          	addi	a2,a5,-2
c0026fa8:	07f77713          	andi	a4,a4,127
c0026fac:	fb0ff06f          	j	c002675c <_ldtoa_r+0x71c>
c0026fb0:	c80025b7          	lui	a1,0xc8002
c0026fb4:	72458593          	addi	a1,a1,1828 # c8002724 <_end+0xfff7dea4>
c0026fb8:	000a8513          	mv	a0,s5
c0026fbc:	000024b7          	lui	s1,0x2
c0026fc0:	f7df60ef          	jal	ra,c001df3c <sprintf>
c0026fc4:	70f48493          	addi	s1,s1,1807 # 270f <_STACK_SIZE+0x170f>
c0026fc8:	fdcff06f          	j	c00267a4 <_ldtoa_r+0x764>
c0026fcc:	00178793          	addi	a5,a5,1
c0026fd0:	fef60fa3          	sb	a5,-1(a2)
c0026fd4:	fbcff06f          	j	c0026790 <_ldtoa_r+0x750>
c0026fd8:	0d010413          	addi	s0,sp,208
c0026fdc:	00040593          	mv	a1,s0
c0026fe0:	07c10513          	addi	a0,sp,124
c0026fe4:	00004cb7          	lui	s9,0x4
c0026fe8:	d3dfd0ef          	jal	ra,c0024d24 <emovi>
c0026fec:	00000493          	li	s1,0
c0026ff0:	0e810b13          	addi	s6,sp,232
c0026ff4:	0cc10993          	addi	s3,sp,204
c0026ff8:	0d210a93          	addi	s5,sp,210
c0026ffc:	ffec8c93          	addi	s9,s9,-2 # 3ffe <_STACK_SIZE+0x2ffe>
c0027000:	0e815783          	lhu	a5,232(sp)
c0027004:	0077f793          	andi	a5,a5,7
c0027008:	0c079a63          	bnez	a5,c00270dc <_ldtoa_r+0x109c>
c002700c:	0b410713          	addi	a4,sp,180
c0027010:	00040793          	mv	a5,s0
c0027014:	0007d683          	lhu	a3,0(a5)
c0027018:	00278793          	addi	a5,a5,2
c002701c:	00270713          	addi	a4,a4,2
c0027020:	fed71f23          	sh	a3,-2(a4)
c0027024:	ff6798e3          	bne	a5,s6,c0027014 <_ldtoa_r+0xfd4>
c0027028:	0b410513          	addi	a0,sp,180
c002702c:	0c011623          	sh	zero,204(sp)
c0027030:	f2cfd0ef          	jal	ra,c002475c <eshdn1>
c0027034:	0b410513          	addi	a0,sp,180
c0027038:	f24fd0ef          	jal	ra,c002475c <eshdn1>
c002703c:	00000613          	li	a2,0
c0027040:	00098693          	mv	a3,s3
c0027044:	000b0713          	mv	a4,s6
c0027048:	0006d583          	lhu	a1,0(a3)
c002704c:	00075783          	lhu	a5,0(a4)
c0027050:	ffe68693          	addi	a3,a3,-2
c0027054:	ffe70713          	addi	a4,a4,-2
c0027058:	00b787b3          	add	a5,a5,a1
c002705c:	00c787b3          	add	a5,a5,a2
c0027060:	0107d613          	srli	a2,a5,0x10
c0027064:	00f69123          	sh	a5,2(a3)
c0027068:	00167613          	andi	a2,a2,1
c002706c:	fd571ee3          	bne	a4,s5,c0027048 <_ldtoa_r+0x1008>
c0027070:	0b615783          	lhu	a5,182(sp)
c0027074:	0b815703          	lhu	a4,184(sp)
c0027078:	00378793          	addi	a5,a5,3
c002707c:	0af11b23          	sh	a5,182(sp)
c0027080:	02070063          	beqz	a4,c00270a0 <_ldtoa_r+0x1060>
c0027084:	0b410513          	addi	a0,sp,180
c0027088:	ed4fd0ef          	jal	ra,c002475c <eshdn1>
c002708c:	0b615783          	lhu	a5,182(sp)
c0027090:	0b815703          	lhu	a4,184(sp)
c0027094:	00178793          	addi	a5,a5,1
c0027098:	0af11b23          	sh	a5,182(sp)
c002709c:	fe0714e3          	bnez	a4,c0027084 <_ldtoa_r+0x1044>
c00270a0:	0cc15783          	lhu	a5,204(sp)
c00270a4:	02079c63          	bnez	a5,c00270dc <_ldtoa_r+0x109c>
c00270a8:	0b615783          	lhu	a5,182(sp)
c00270ac:	02fce863          	bltu	s9,a5,c00270dc <_ldtoa_r+0x109c>
c00270b0:	00040713          	mv	a4,s0
c00270b4:	0b410793          	addi	a5,sp,180
c00270b8:	0007d683          	lhu	a3,0(a5)
c00270bc:	00278793          	addi	a5,a5,2
c00270c0:	00270713          	addi	a4,a4,2
c00270c4:	fed71f23          	sh	a3,-2(a4)
c00270c8:	ff3798e3          	bne	a5,s3,c00270b8 <_ldtoa_r+0x1078>
c00270cc:	0e011423          	sh	zero,232(sp)
c00270d0:	fff48493          	addi	s1,s1,-1
c00270d4:	fd500793          	li	a5,-43
c00270d8:	f2f494e3          	bne	s1,a5,c0027000 <_ldtoa_r+0xfc0>
c00270dc:	07c10593          	addi	a1,sp,124
c00270e0:	00040513          	mv	a0,s0
c00270e4:	fe8fd0ef          	jal	ra,c00248cc <emovo.constprop.0>
c00270e8:	16010993          	addi	s3,sp,352
c00270ec:	960ff06f          	j	c002624c <_ldtoa_r+0x20c>
c00270f0:	000a8793          	mv	a5,s5
c00270f4:	0007d703          	lhu	a4,0(a5)
c00270f8:	00278793          	addi	a5,a5,2
c00270fc:	aa071ee3          	bnez	a4,c0026bb8 <_ldtoa_r+0xb78>
c0027100:	0e210713          	addi	a4,sp,226
c0027104:	fee798e3          	bne	a5,a4,c00270f4 <_ldtoa_r+0x10b4>
c0027108:	000a8793          	mv	a5,s5
c002710c:	0007d703          	lhu	a4,0(a5)
c0027110:	00278793          	addi	a5,a5,2
c0027114:	c20710e3          	bnez	a4,c0026d34 <_ldtoa_r+0xcf4>
c0027118:	0e210713          	addi	a4,sp,226
c002711c:	fee798e3          	bne	a5,a4,c002710c <_ldtoa_r+0x10cc>
c0027120:	a99ff06f          	j	c0026bb8 <_ldtoa_r+0xb78>
c0027124:	10c10713          	addi	a4,sp,268
c0027128:	0f010793          	addi	a5,sp,240
c002712c:	0007d883          	lhu	a7,0(a5)
c0027130:	00075503          	lhu	a0,0(a4)
c0027134:	00278793          	addi	a5,a5,2
c0027138:	00270713          	addi	a4,a4,2
c002713c:	04a89863          	bne	a7,a0,c002718c <_ldtoa_r+0x114c>
c0027140:	10610513          	addi	a0,sp,262
c0027144:	fea794e3          	bne	a5,a0,c002712c <_ldtoa_r+0x10ec>
c0027148:	0ec15703          	lhu	a4,236(sp)
c002714c:	10815783          	lhu	a5,264(sp)
c0027150:	04f70663          	beq	a4,a5,c002719c <_ldtoa_r+0x115c>
c0027154:	000a8793          	mv	a5,s5
c0027158:	0e410713          	addi	a4,sp,228
c002715c:	00278793          	addi	a5,a5,2
c0027160:	fe079f23          	sh	zero,-2(a5)
c0027164:	fee79ce3          	bne	a5,a4,c002715c <_ldtoa_r+0x111c>
c0027168:	a51ff06f          	j	c0026bb8 <_ldtoa_r+0xb78>
c002716c:	c80026b7          	lui	a3,0xc8002
c0027170:	000015b7          	lui	a1,0x1
c0027174:	c8002537          	lui	a0,0xc8002
c0027178:	73868693          	addi	a3,a3,1848 # c8002738 <_end+0xfff7deb8>
c002717c:	00000613          	li	a2,0
c0027180:	b6e58593          	addi	a1,a1,-1170 # b6e <_STACK_SIZE-0x492>
c0027184:	74c50513          	addi	a0,a0,1868 # c800274c <_end+0xfff7decc>
c0027188:	2d4050ef          	jal	ra,c002c45c <__assert_func>
c002718c:	07156c63          	bltu	a0,a7,c0027204 <_ldtoa_r+0x11c4>
c0027190:	12010793          	addi	a5,sp,288
c0027194:	10410713          	addi	a4,sp,260
c0027198:	c7dff06f          	j	c0026e14 <_ldtoa_r+0xdd4>
c002719c:	00068713          	mv	a4,a3
c00271a0:	00069663          	bnez	a3,c00271ac <_ldtoa_r+0x116c>
c00271a4:	10e11783          	lh	a5,270(sp)
c00271a8:	0c07d663          	bgez	a5,c0027274 <_ldtoa_r+0x1234>
c00271ac:	10a10713          	addi	a4,sp,266
c00271b0:	12010793          	addi	a5,sp,288
c00271b4:	00075583          	lhu	a1,0(a4)
c00271b8:	10059663          	bnez	a1,c00272c4 <_ldtoa_r+0x1284>
c00271bc:	00270713          	addi	a4,a4,2
c00271c0:	fee79ae3          	bne	a5,a4,c00271b4 <_ldtoa_r+0x1174>
c00271c4:	10c11523          	sh	a2,266(sp)
c00271c8:	ca1ff06f          	j	c0026e68 <_ldtoa_r+0xe28>
c00271cc:	00000613          	li	a2,0
c00271d0:	0ee10893          	addi	a7,sp,238
c00271d4:	0007d803          	lhu	a6,0(a5)
c00271d8:	00075503          	lhu	a0,0(a4)
c00271dc:	ffe78793          	addi	a5,a5,-2
c00271e0:	ffe70713          	addi	a4,a4,-2
c00271e4:	01050533          	add	a0,a0,a6
c00271e8:	00c50633          	add	a2,a0,a2
c00271ec:	01065513          	srli	a0,a2,0x10
c00271f0:	00c79123          	sh	a2,2(a5)
c00271f4:	00157613          	andi	a2,a0,1
c00271f8:	fd171ee3          	bne	a4,a7,c00271d4 <_ldtoa_r+0x1194>
c00271fc:	00000613          	li	a2,0
c0027200:	c59ff06f          	j	c0026e58 <_ldtoa_r+0xe18>
c0027204:	02412603          	lw	a2,36(sp)
c0027208:	10810713          	addi	a4,sp,264
c002720c:	12010793          	addi	a5,sp,288
c0027210:	00075503          	lhu	a0,0(a4)
c0027214:	00270713          	addi	a4,a4,2
c0027218:	00260613          	addi	a2,a2,2
c002721c:	fea61f23          	sh	a0,-2(a2)
c0027220:	fef718e3          	bne	a4,a5,c0027210 <_ldtoa_r+0x11d0>
c0027224:	12011e23          	sh	zero,316(sp)
c0027228:	10810513          	addi	a0,sp,264
c002722c:	0ec10613          	addi	a2,sp,236
c0027230:	10410713          	addi	a4,sp,260
c0027234:	00065803          	lhu	a6,0(a2)
c0027238:	00260613          	addi	a2,a2,2
c002723c:	00250513          	addi	a0,a0,2
c0027240:	ff051f23          	sh	a6,-2(a0)
c0027244:	fee618e3          	bne	a2,a4,c0027234 <_ldtoa_r+0x11f4>
c0027248:	02412603          	lw	a2,36(sp)
c002724c:	12011023          	sh	zero,288(sp)
c0027250:	0ec10893          	addi	a7,sp,236
c0027254:	13c10513          	addi	a0,sp,316
c0027258:	00065803          	lhu	a6,0(a2)
c002725c:	00260613          	addi	a2,a2,2
c0027260:	00288893          	addi	a7,a7,2
c0027264:	ff089f23          	sh	a6,-2(a7)
c0027268:	fea618e3          	bne	a2,a0,c0027258 <_ldtoa_r+0x1218>
c002726c:	10011223          	sh	zero,260(sp)
c0027270:	ba5ff06f          	j	c0026e14 <_ldtoa_r+0xdd4>
c0027274:	12010693          	addi	a3,sp,288
c0027278:	10a10893          	addi	a7,sp,266
c002727c:	0006d783          	lhu	a5,0(a3)
c0027280:	01079613          	slli	a2,a5,0x10
c0027284:	41065613          	srai	a2,a2,0x10
c0027288:	00065463          	bgez	a2,c0027290 <_ldtoa_r+0x1250>
c002728c:	00176713          	ori	a4,a4,1
c0027290:	00179793          	slli	a5,a5,0x1
c0027294:	01079793          	slli	a5,a5,0x10
c0027298:	00277613          	andi	a2,a4,2
c002729c:	0107d793          	srli	a5,a5,0x10
c00272a0:	00060463          	beqz	a2,c00272a8 <_ldtoa_r+0x1268>
c00272a4:	0017e793          	ori	a5,a5,1
c00272a8:	00171713          	slli	a4,a4,0x1
c00272ac:	00f69023          	sh	a5,0(a3)
c00272b0:	01071713          	slli	a4,a4,0x10
c00272b4:	ffe68693          	addi	a3,a3,-2
c00272b8:	01075713          	srli	a4,a4,0x10
c00272bc:	fd1690e3          	bne	a3,a7,c002727c <_ldtoa_r+0x123c>
c00272c0:	ba9ff06f          	j	c0026e68 <_ldtoa_r+0xe28>
c00272c4:	00168613          	addi	a2,a3,1
c00272c8:	10c11523          	sh	a2,266(sp)
c00272cc:	b9dff06f          	j	c0026e68 <_ldtoa_r+0xe28>

c00272d0 <_ldcheck>:
c00272d0:	00852703          	lw	a4,8(a0)
c00272d4:	00c52783          	lw	a5,12(a0)
c00272d8:	00052603          	lw	a2,0(a0)
c00272dc:	00452683          	lw	a3,4(a0)
c00272e0:	fc010113          	addi	sp,sp,-64
c00272e4:	00010513          	mv	a0,sp
c00272e8:	01410593          	addi	a1,sp,20
c00272ec:	00e12423          	sw	a4,8(sp)
c00272f0:	00f12623          	sw	a5,12(sp)
c00272f4:	02112e23          	sw	ra,60(sp)
c00272f8:	00c12023          	sw	a2,0(sp)
c00272fc:	00d12223          	sw	a3,4(sp)
c0027300:	bd1fe0ef          	jal	ra,c0025ed0 <e113toe.isra.0>
c0027304:	02615783          	lhu	a5,38(sp)
c0027308:	00000513          	li	a0,0
c002730c:	fff7c793          	not	a5,a5
c0027310:	01179713          	slli	a4,a5,0x11
c0027314:	02071063          	bnez	a4,c0027334 <_ldcheck+0x64>
c0027318:	01410793          	addi	a5,sp,20
c002731c:	02610693          	addi	a3,sp,38
c0027320:	0007d703          	lhu	a4,0(a5)
c0027324:	00278793          	addi	a5,a5,2
c0027328:	00071c63          	bnez	a4,c0027340 <_ldcheck+0x70>
c002732c:	fed79ae3          	bne	a5,a3,c0027320 <_ldcheck+0x50>
c0027330:	00200513          	li	a0,2
c0027334:	03c12083          	lw	ra,60(sp)
c0027338:	04010113          	addi	sp,sp,64
c002733c:	00008067          	ret
c0027340:	00100513          	li	a0,1
c0027344:	ff1ff06f          	j	c0027334 <_ldcheck+0x64>

c0027348 <__localeconv_l>:
c0027348:	0f050513          	addi	a0,a0,240
c002734c:	00008067          	ret

c0027350 <_localeconv_r>:
c0027350:	c8003537          	lui	a0,0xc8003
c0027354:	08050513          	addi	a0,a0,128 # c8003080 <_end+0xfff7e800>
c0027358:	00008067          	ret

c002735c <localeconv>:
c002735c:	c8003537          	lui	a0,0xc8003
c0027360:	08050513          	addi	a0,a0,128 # c8003080 <_end+0xfff7e800>
c0027364:	00008067          	ret

c0027368 <_setlocale_r>:
c0027368:	ff010113          	addi	sp,sp,-16
c002736c:	00112623          	sw	ra,12(sp)
c0027370:	00812423          	sw	s0,8(sp)
c0027374:	00912223          	sw	s1,4(sp)
c0027378:	02060c63          	beqz	a2,c00273b0 <_setlocale_r+0x48>
c002737c:	c80025b7          	lui	a1,0xc8002
c0027380:	7a058593          	addi	a1,a1,1952 # c80027a0 <_end+0xfff7df20>
c0027384:	00060513          	mv	a0,a2
c0027388:	00060413          	mv	s0,a2
c002738c:	73c020ef          	jal	ra,c0029ac8 <strcmp>
c0027390:	c80024b7          	lui	s1,0xc8002
c0027394:	02051263          	bnez	a0,c00273b8 <_setlocale_r+0x50>
c0027398:	79c48513          	addi	a0,s1,1948 # c800279c <_end+0xfff7df1c>
c002739c:	00c12083          	lw	ra,12(sp)
c00273a0:	00812403          	lw	s0,8(sp)
c00273a4:	00412483          	lw	s1,4(sp)
c00273a8:	01010113          	addi	sp,sp,16
c00273ac:	00008067          	ret
c00273b0:	c80024b7          	lui	s1,0xc8002
c00273b4:	fe5ff06f          	j	c0027398 <_setlocale_r+0x30>
c00273b8:	79c48593          	addi	a1,s1,1948 # c800279c <_end+0xfff7df1c>
c00273bc:	00040513          	mv	a0,s0
c00273c0:	708020ef          	jal	ra,c0029ac8 <strcmp>
c00273c4:	fc050ae3          	beqz	a0,c0027398 <_setlocale_r+0x30>
c00273c8:	c80035b7          	lui	a1,0xc8003
c00273cc:	80058593          	addi	a1,a1,-2048 # c8002800 <_end+0xfff7df80>
c00273d0:	00040513          	mv	a0,s0
c00273d4:	6f4020ef          	jal	ra,c0029ac8 <strcmp>
c00273d8:	fc0500e3          	beqz	a0,c0027398 <_setlocale_r+0x30>
c00273dc:	00000513          	li	a0,0
c00273e0:	fbdff06f          	j	c002739c <_setlocale_r+0x34>

c00273e4 <__locale_mb_cur_max>:
c00273e4:	c80037b7          	lui	a5,0xc8003
c00273e8:	0b87c503          	lbu	a0,184(a5) # c80030b8 <_end+0xfff7e838>
c00273ec:	00008067          	ret

c00273f0 <setlocale>:
c00273f0:	ff010113          	addi	sp,sp,-16
c00273f4:	00112623          	sw	ra,12(sp)
c00273f8:	00812423          	sw	s0,8(sp)
c00273fc:	00912223          	sw	s1,4(sp)
c0027400:	02058c63          	beqz	a1,c0027438 <setlocale+0x48>
c0027404:	00058413          	mv	s0,a1
c0027408:	c80025b7          	lui	a1,0xc8002
c002740c:	7a058593          	addi	a1,a1,1952 # c80027a0 <_end+0xfff7df20>
c0027410:	00040513          	mv	a0,s0
c0027414:	6b4020ef          	jal	ra,c0029ac8 <strcmp>
c0027418:	c80024b7          	lui	s1,0xc8002
c002741c:	02051263          	bnez	a0,c0027440 <setlocale+0x50>
c0027420:	79c48513          	addi	a0,s1,1948 # c800279c <_end+0xfff7df1c>
c0027424:	00c12083          	lw	ra,12(sp)
c0027428:	00812403          	lw	s0,8(sp)
c002742c:	00412483          	lw	s1,4(sp)
c0027430:	01010113          	addi	sp,sp,16
c0027434:	00008067          	ret
c0027438:	c80024b7          	lui	s1,0xc8002
c002743c:	fe5ff06f          	j	c0027420 <setlocale+0x30>
c0027440:	79c48593          	addi	a1,s1,1948 # c800279c <_end+0xfff7df1c>
c0027444:	00040513          	mv	a0,s0
c0027448:	680020ef          	jal	ra,c0029ac8 <strcmp>
c002744c:	fc050ae3          	beqz	a0,c0027420 <setlocale+0x30>
c0027450:	c80035b7          	lui	a1,0xc8003
c0027454:	80058593          	addi	a1,a1,-2048 # c8002800 <_end+0xfff7df80>
c0027458:	00040513          	mv	a0,s0
c002745c:	66c020ef          	jal	ra,c0029ac8 <strcmp>
c0027460:	fc0500e3          	beqz	a0,c0027420 <setlocale+0x30>
c0027464:	00000513          	li	a0,0
c0027468:	fbdff06f          	j	c0027424 <setlocale+0x34>

c002746c <__smakebuf_r>:
c002746c:	00c5d783          	lhu	a5,12(a1)
c0027470:	f8010113          	addi	sp,sp,-128
c0027474:	06812c23          	sw	s0,120(sp)
c0027478:	06112e23          	sw	ra,124(sp)
c002747c:	06912a23          	sw	s1,116(sp)
c0027480:	07212823          	sw	s2,112(sp)
c0027484:	07312623          	sw	s3,108(sp)
c0027488:	07412423          	sw	s4,104(sp)
c002748c:	0027f713          	andi	a4,a5,2
c0027490:	00058413          	mv	s0,a1
c0027494:	02070c63          	beqz	a4,c00274cc <__smakebuf_r+0x60>
c0027498:	04358793          	addi	a5,a1,67
c002749c:	00f5a023          	sw	a5,0(a1)
c00274a0:	00f5a823          	sw	a5,16(a1)
c00274a4:	00100793          	li	a5,1
c00274a8:	00f5aa23          	sw	a5,20(a1)
c00274ac:	07c12083          	lw	ra,124(sp)
c00274b0:	07812403          	lw	s0,120(sp)
c00274b4:	07412483          	lw	s1,116(sp)
c00274b8:	07012903          	lw	s2,112(sp)
c00274bc:	06c12983          	lw	s3,108(sp)
c00274c0:	06812a03          	lw	s4,104(sp)
c00274c4:	08010113          	addi	sp,sp,128
c00274c8:	00008067          	ret
c00274cc:	00e59583          	lh	a1,14(a1)
c00274d0:	00050493          	mv	s1,a0
c00274d4:	0805cc63          	bltz	a1,c002756c <__smakebuf_r+0x100>
c00274d8:	00810613          	addi	a2,sp,8
c00274dc:	53c050ef          	jal	ra,c002ca18 <_fstat_r>
c00274e0:	08054463          	bltz	a0,c0027568 <__smakebuf_r+0xfc>
c00274e4:	00c12783          	lw	a5,12(sp)
c00274e8:	0000f937          	lui	s2,0xf
c00274ec:	40000a13          	li	s4,1024
c00274f0:	00f97933          	and	s2,s2,a5
c00274f4:	ffffe7b7          	lui	a5,0xffffe
c00274f8:	00f90933          	add	s2,s2,a5
c00274fc:	000017b7          	lui	a5,0x1
c0027500:	00193913          	seqz	s2,s2
c0027504:	80078993          	addi	s3,a5,-2048 # 800 <_STACK_SIZE-0x800>
c0027508:	000a0593          	mv	a1,s4
c002750c:	00048513          	mv	a0,s1
c0027510:	1bc000ef          	jal	ra,c00276cc <_malloc_r>
c0027514:	00c41783          	lh	a5,12(s0)
c0027518:	06050e63          	beqz	a0,c0027594 <__smakebuf_r+0x128>
c002751c:	c0024737          	lui	a4,0xc0024
c0027520:	98070713          	addi	a4,a4,-1664 # c0023980 <_end+0xf7f9f100>
c0027524:	02e4ae23          	sw	a4,60(s1)
c0027528:	0807e793          	ori	a5,a5,128
c002752c:	00f41623          	sh	a5,12(s0)
c0027530:	00a42023          	sw	a0,0(s0)
c0027534:	00a42823          	sw	a0,16(s0)
c0027538:	01442a23          	sw	s4,20(s0)
c002753c:	08091863          	bnez	s2,c00275cc <__smakebuf_r+0x160>
c0027540:	0137e7b3          	or	a5,a5,s3
c0027544:	07c12083          	lw	ra,124(sp)
c0027548:	00f41623          	sh	a5,12(s0)
c002754c:	07812403          	lw	s0,120(sp)
c0027550:	07412483          	lw	s1,116(sp)
c0027554:	07012903          	lw	s2,112(sp)
c0027558:	06c12983          	lw	s3,108(sp)
c002755c:	06812a03          	lw	s4,104(sp)
c0027560:	08010113          	addi	sp,sp,128
c0027564:	00008067          	ret
c0027568:	00c45783          	lhu	a5,12(s0)
c002756c:	0807f793          	andi	a5,a5,128
c0027570:	00000913          	li	s2,0
c0027574:	04078663          	beqz	a5,c00275c0 <__smakebuf_r+0x154>
c0027578:	04000a13          	li	s4,64
c002757c:	000a0593          	mv	a1,s4
c0027580:	00048513          	mv	a0,s1
c0027584:	148000ef          	jal	ra,c00276cc <_malloc_r>
c0027588:	00c41783          	lh	a5,12(s0)
c002758c:	00000993          	li	s3,0
c0027590:	f80516e3          	bnez	a0,c002751c <__smakebuf_r+0xb0>
c0027594:	2007f713          	andi	a4,a5,512
c0027598:	f0071ae3          	bnez	a4,c00274ac <__smakebuf_r+0x40>
c002759c:	ffc7f793          	andi	a5,a5,-4
c00275a0:	0027e793          	ori	a5,a5,2
c00275a4:	04340713          	addi	a4,s0,67
c00275a8:	00f41623          	sh	a5,12(s0)
c00275ac:	00100793          	li	a5,1
c00275b0:	00e42023          	sw	a4,0(s0)
c00275b4:	00e42823          	sw	a4,16(s0)
c00275b8:	00f42a23          	sw	a5,20(s0)
c00275bc:	ef1ff06f          	j	c00274ac <__smakebuf_r+0x40>
c00275c0:	40000a13          	li	s4,1024
c00275c4:	00000993          	li	s3,0
c00275c8:	f41ff06f          	j	c0027508 <__smakebuf_r+0x9c>
c00275cc:	00e41583          	lh	a1,14(s0)
c00275d0:	00048513          	mv	a0,s1
c00275d4:	4ac050ef          	jal	ra,c002ca80 <_isatty_r>
c00275d8:	00051663          	bnez	a0,c00275e4 <__smakebuf_r+0x178>
c00275dc:	00c41783          	lh	a5,12(s0)
c00275e0:	f61ff06f          	j	c0027540 <__smakebuf_r+0xd4>
c00275e4:	00c45783          	lhu	a5,12(s0)
c00275e8:	ffc7f793          	andi	a5,a5,-4
c00275ec:	0017e793          	ori	a5,a5,1
c00275f0:	01079793          	slli	a5,a5,0x10
c00275f4:	4107d793          	srai	a5,a5,0x10
c00275f8:	f49ff06f          	j	c0027540 <__smakebuf_r+0xd4>

c00275fc <__swhatbuf_r>:
c00275fc:	f9010113          	addi	sp,sp,-112
c0027600:	06812423          	sw	s0,104(sp)
c0027604:	00058413          	mv	s0,a1
c0027608:	00e59583          	lh	a1,14(a1)
c002760c:	06912223          	sw	s1,100(sp)
c0027610:	07212023          	sw	s2,96(sp)
c0027614:	06112623          	sw	ra,108(sp)
c0027618:	00060493          	mv	s1,a2
c002761c:	00068913          	mv	s2,a3
c0027620:	0405ca63          	bltz	a1,c0027674 <__swhatbuf_r+0x78>
c0027624:	00810613          	addi	a2,sp,8
c0027628:	3f0050ef          	jal	ra,c002ca18 <_fstat_r>
c002762c:	04054463          	bltz	a0,c0027674 <__swhatbuf_r+0x78>
c0027630:	00c12703          	lw	a4,12(sp)
c0027634:	0000f7b7          	lui	a5,0xf
c0027638:	06c12083          	lw	ra,108(sp)
c002763c:	00e7f7b3          	and	a5,a5,a4
c0027640:	ffffe737          	lui	a4,0xffffe
c0027644:	00e787b3          	add	a5,a5,a4
c0027648:	06812403          	lw	s0,104(sp)
c002764c:	0017b793          	seqz	a5,a5
c0027650:	00f92023          	sw	a5,0(s2) # f000 <_STACK_SIZE+0xe000>
c0027654:	40000793          	li	a5,1024
c0027658:	00f4a023          	sw	a5,0(s1)
c002765c:	00001537          	lui	a0,0x1
c0027660:	06412483          	lw	s1,100(sp)
c0027664:	06012903          	lw	s2,96(sp)
c0027668:	80050513          	addi	a0,a0,-2048 # 800 <_STACK_SIZE-0x800>
c002766c:	07010113          	addi	sp,sp,112
c0027670:	00008067          	ret
c0027674:	00c41783          	lh	a5,12(s0)
c0027678:	00092023          	sw	zero,0(s2)
c002767c:	0807f793          	andi	a5,a5,128
c0027680:	02078463          	beqz	a5,c00276a8 <__swhatbuf_r+0xac>
c0027684:	06c12083          	lw	ra,108(sp)
c0027688:	06812403          	lw	s0,104(sp)
c002768c:	04000793          	li	a5,64
c0027690:	00f4a023          	sw	a5,0(s1)
c0027694:	06012903          	lw	s2,96(sp)
c0027698:	06412483          	lw	s1,100(sp)
c002769c:	00000513          	li	a0,0
c00276a0:	07010113          	addi	sp,sp,112
c00276a4:	00008067          	ret
c00276a8:	06c12083          	lw	ra,108(sp)
c00276ac:	06812403          	lw	s0,104(sp)
c00276b0:	40000793          	li	a5,1024
c00276b4:	00f4a023          	sw	a5,0(s1)
c00276b8:	06012903          	lw	s2,96(sp)
c00276bc:	06412483          	lw	s1,100(sp)
c00276c0:	00000513          	li	a0,0
c00276c4:	07010113          	addi	sp,sp,112
c00276c8:	00008067          	ret

c00276cc <_malloc_r>:
c00276cc:	fd010113          	addi	sp,sp,-48
c00276d0:	01312e23          	sw	s3,28(sp)
c00276d4:	02112623          	sw	ra,44(sp)
c00276d8:	02812423          	sw	s0,40(sp)
c00276dc:	02912223          	sw	s1,36(sp)
c00276e0:	03212023          	sw	s2,32(sp)
c00276e4:	01412c23          	sw	s4,24(sp)
c00276e8:	01512a23          	sw	s5,20(sp)
c00276ec:	01612823          	sw	s6,16(sp)
c00276f0:	01712623          	sw	s7,12(sp)
c00276f4:	01812423          	sw	s8,8(sp)
c00276f8:	01912223          	sw	s9,4(sp)
c00276fc:	00b58793          	addi	a5,a1,11
c0027700:	01600713          	li	a4,22
c0027704:	00050993          	mv	s3,a0
c0027708:	06f76663          	bltu	a4,a5,c0027774 <_malloc_r+0xa8>
c002770c:	01000793          	li	a5,16
c0027710:	1eb7e663          	bltu	a5,a1,c00278fc <_malloc_r+0x230>
c0027714:	1cd000ef          	jal	ra,c00280e0 <__malloc_lock>
c0027718:	01000493          	li	s1,16
c002771c:	01800793          	li	a5,24
c0027720:	00200613          	li	a2,2
c0027724:	c8003937          	lui	s2,0xc8003
c0027728:	0fc90913          	addi	s2,s2,252 # c80030fc <_end+0xfff7e87c>
c002772c:	00f907b3          	add	a5,s2,a5
c0027730:	0047a403          	lw	s0,4(a5) # f004 <_STACK_SIZE+0xe004>
c0027734:	ff878713          	addi	a4,a5,-8
c0027738:	20e40a63          	beq	s0,a4,c002794c <_malloc_r+0x280>
c002773c:	00442783          	lw	a5,4(s0)
c0027740:	00c42683          	lw	a3,12(s0)
c0027744:	00842603          	lw	a2,8(s0)
c0027748:	ffc7f793          	andi	a5,a5,-4
c002774c:	00f407b3          	add	a5,s0,a5
c0027750:	0047a703          	lw	a4,4(a5)
c0027754:	00d62623          	sw	a3,12(a2)
c0027758:	00c6a423          	sw	a2,8(a3)
c002775c:	00176713          	ori	a4,a4,1
c0027760:	00098513          	mv	a0,s3
c0027764:	00e7a223          	sw	a4,4(a5)
c0027768:	17d000ef          	jal	ra,c00280e4 <__malloc_unlock>
c002776c:	00840513          	addi	a0,s0,8
c0027770:	1980006f          	j	c0027908 <_malloc_r+0x23c>
c0027774:	ff87f493          	andi	s1,a5,-8
c0027778:	1807c263          	bltz	a5,c00278fc <_malloc_r+0x230>
c002777c:	18b4e063          	bltu	s1,a1,c00278fc <_malloc_r+0x230>
c0027780:	161000ef          	jal	ra,c00280e0 <__malloc_lock>
c0027784:	1f700793          	li	a5,503
c0027788:	4697f663          	bgeu	a5,s1,c0027bf4 <_malloc_r+0x528>
c002778c:	0094d793          	srli	a5,s1,0x9
c0027790:	1a078663          	beqz	a5,c002793c <_malloc_r+0x270>
c0027794:	00400713          	li	a4,4
c0027798:	3cf76c63          	bltu	a4,a5,c0027b70 <_malloc_r+0x4a4>
c002779c:	0064d793          	srli	a5,s1,0x6
c00277a0:	03978613          	addi	a2,a5,57
c00277a4:	03878513          	addi	a0,a5,56
c00277a8:	00361693          	slli	a3,a2,0x3
c00277ac:	c8003937          	lui	s2,0xc8003
c00277b0:	0fc90913          	addi	s2,s2,252 # c80030fc <_end+0xfff7e87c>
c00277b4:	00d906b3          	add	a3,s2,a3
c00277b8:	0046a403          	lw	s0,4(a3)
c00277bc:	ff868693          	addi	a3,a3,-8
c00277c0:	02868663          	beq	a3,s0,c00277ec <_malloc_r+0x120>
c00277c4:	00f00593          	li	a1,15
c00277c8:	0100006f          	j	c00277d8 <_malloc_r+0x10c>
c00277cc:	32075c63          	bgez	a4,c0027b04 <_malloc_r+0x438>
c00277d0:	00c42403          	lw	s0,12(s0)
c00277d4:	00868c63          	beq	a3,s0,c00277ec <_malloc_r+0x120>
c00277d8:	00442783          	lw	a5,4(s0)
c00277dc:	ffc7f793          	andi	a5,a5,-4
c00277e0:	40978733          	sub	a4,a5,s1
c00277e4:	fee5d4e3          	bge	a1,a4,c00277cc <_malloc_r+0x100>
c00277e8:	00050613          	mv	a2,a0
c00277ec:	01092403          	lw	s0,16(s2)
c00277f0:	00890893          	addi	a7,s2,8
c00277f4:	17140863          	beq	s0,a7,c0027964 <_malloc_r+0x298>
c00277f8:	00442503          	lw	a0,4(s0)
c00277fc:	00f00693          	li	a3,15
c0027800:	ffc57513          	andi	a0,a0,-4
c0027804:	409507b3          	sub	a5,a0,s1
c0027808:	40f6cc63          	blt	a3,a5,c0027c20 <_malloc_r+0x554>
c002780c:	01192a23          	sw	a7,20(s2)
c0027810:	01192823          	sw	a7,16(s2)
c0027814:	3e07d663          	bgez	a5,c0027c00 <_malloc_r+0x534>
c0027818:	1ff00793          	li	a5,511
c002781c:	2ea7ea63          	bltu	a5,a0,c0027b10 <_malloc_r+0x444>
c0027820:	ff857793          	andi	a5,a0,-8
c0027824:	00878793          	addi	a5,a5,8
c0027828:	00492583          	lw	a1,4(s2)
c002782c:	00f907b3          	add	a5,s2,a5
c0027830:	0007a683          	lw	a3,0(a5)
c0027834:	00555513          	srli	a0,a0,0x5
c0027838:	00100713          	li	a4,1
c002783c:	00a71733          	sll	a4,a4,a0
c0027840:	00b76733          	or	a4,a4,a1
c0027844:	ff878593          	addi	a1,a5,-8
c0027848:	00b42623          	sw	a1,12(s0)
c002784c:	00d42423          	sw	a3,8(s0)
c0027850:	00e92223          	sw	a4,4(s2)
c0027854:	0087a023          	sw	s0,0(a5)
c0027858:	0086a623          	sw	s0,12(a3)
c002785c:	40265793          	srai	a5,a2,0x2
c0027860:	00100593          	li	a1,1
c0027864:	00f595b3          	sll	a1,a1,a5
c0027868:	10b76863          	bltu	a4,a1,c0027978 <_malloc_r+0x2ac>
c002786c:	00e5f7b3          	and	a5,a1,a4
c0027870:	02079463          	bnez	a5,c0027898 <_malloc_r+0x1cc>
c0027874:	00159593          	slli	a1,a1,0x1
c0027878:	ffc67613          	andi	a2,a2,-4
c002787c:	00e5f7b3          	and	a5,a1,a4
c0027880:	00460613          	addi	a2,a2,4
c0027884:	00079a63          	bnez	a5,c0027898 <_malloc_r+0x1cc>
c0027888:	00159593          	slli	a1,a1,0x1
c002788c:	00e5f7b3          	and	a5,a1,a4
c0027890:	00460613          	addi	a2,a2,4
c0027894:	fe078ae3          	beqz	a5,c0027888 <_malloc_r+0x1bc>
c0027898:	00f00813          	li	a6,15
c002789c:	00361313          	slli	t1,a2,0x3
c00278a0:	00690333          	add	t1,s2,t1
c00278a4:	00030513          	mv	a0,t1
c00278a8:	00c52783          	lw	a5,12(a0)
c00278ac:	00060e13          	mv	t3,a2
c00278b0:	2ef50263          	beq	a0,a5,c0027b94 <_malloc_r+0x4c8>
c00278b4:	0047a703          	lw	a4,4(a5)
c00278b8:	00078413          	mv	s0,a5
c00278bc:	00c7a783          	lw	a5,12(a5)
c00278c0:	ffc77713          	andi	a4,a4,-4
c00278c4:	409706b3          	sub	a3,a4,s1
c00278c8:	2ed84263          	blt	a6,a3,c0027bac <_malloc_r+0x4e0>
c00278cc:	fe06c2e3          	bltz	a3,c00278b0 <_malloc_r+0x1e4>
c00278d0:	00e40733          	add	a4,s0,a4
c00278d4:	00472683          	lw	a3,4(a4) # ffffe004 <_end+0x37f79784>
c00278d8:	00842603          	lw	a2,8(s0)
c00278dc:	00098513          	mv	a0,s3
c00278e0:	0016e693          	ori	a3,a3,1
c00278e4:	00d72223          	sw	a3,4(a4)
c00278e8:	00f62623          	sw	a5,12(a2)
c00278ec:	00c7a423          	sw	a2,8(a5)
c00278f0:	7f4000ef          	jal	ra,c00280e4 <__malloc_unlock>
c00278f4:	00840513          	addi	a0,s0,8
c00278f8:	0100006f          	j	c0027908 <_malloc_r+0x23c>
c00278fc:	00c00793          	li	a5,12
c0027900:	00f9a023          	sw	a5,0(s3)
c0027904:	00000513          	li	a0,0
c0027908:	02c12083          	lw	ra,44(sp)
c002790c:	02812403          	lw	s0,40(sp)
c0027910:	02412483          	lw	s1,36(sp)
c0027914:	02012903          	lw	s2,32(sp)
c0027918:	01c12983          	lw	s3,28(sp)
c002791c:	01812a03          	lw	s4,24(sp)
c0027920:	01412a83          	lw	s5,20(sp)
c0027924:	01012b03          	lw	s6,16(sp)
c0027928:	00c12b83          	lw	s7,12(sp)
c002792c:	00812c03          	lw	s8,8(sp)
c0027930:	00412c83          	lw	s9,4(sp)
c0027934:	03010113          	addi	sp,sp,48
c0027938:	00008067          	ret
c002793c:	20000693          	li	a3,512
c0027940:	04000613          	li	a2,64
c0027944:	03f00513          	li	a0,63
c0027948:	e65ff06f          	j	c00277ac <_malloc_r+0xe0>
c002794c:	00c7a403          	lw	s0,12(a5)
c0027950:	00260613          	addi	a2,a2,2
c0027954:	de8794e3          	bne	a5,s0,c002773c <_malloc_r+0x70>
c0027958:	01092403          	lw	s0,16(s2)
c002795c:	00890893          	addi	a7,s2,8
c0027960:	e9141ce3          	bne	s0,a7,c00277f8 <_malloc_r+0x12c>
c0027964:	00492703          	lw	a4,4(s2)
c0027968:	40265793          	srai	a5,a2,0x2
c002796c:	00100593          	li	a1,1
c0027970:	00f595b3          	sll	a1,a1,a5
c0027974:	eeb77ce3          	bgeu	a4,a1,c002786c <_malloc_r+0x1a0>
c0027978:	00892403          	lw	s0,8(s2)
c002797c:	00442a83          	lw	s5,4(s0)
c0027980:	ffcafb13          	andi	s6,s5,-4
c0027984:	009b6863          	bltu	s6,s1,c0027994 <_malloc_r+0x2c8>
c0027988:	409b07b3          	sub	a5,s6,s1
c002798c:	00f00713          	li	a4,15
c0027990:	14f74663          	blt	a4,a5,c0027adc <_malloc_r+0x410>
c0027994:	c80037b7          	lui	a5,0xc8003
c0027998:	c8003cb7          	lui	s9,0xc8003
c002799c:	9247aa83          	lw	s5,-1756(a5) # c8002924 <_end+0xfff7e0a4>
c00279a0:	990ca703          	lw	a4,-1648(s9) # c8002990 <_end+0xfff7e110>
c00279a4:	fff00793          	li	a5,-1
c00279a8:	01640a33          	add	s4,s0,s6
c00279ac:	01548ab3          	add	s5,s1,s5
c00279b0:	34f70a63          	beq	a4,a5,c0027d04 <_malloc_r+0x638>
c00279b4:	000017b7          	lui	a5,0x1
c00279b8:	00f78793          	addi	a5,a5,15 # 100f <_STACK_SIZE+0xf>
c00279bc:	00fa8ab3          	add	s5,s5,a5
c00279c0:	fffff7b7          	lui	a5,0xfffff
c00279c4:	00fafab3          	and	s5,s5,a5
c00279c8:	000a8593          	mv	a1,s5
c00279cc:	00098513          	mv	a0,s3
c00279d0:	691010ef          	jal	ra,c0029860 <_sbrk_r>
c00279d4:	fff00793          	li	a5,-1
c00279d8:	00050b93          	mv	s7,a0
c00279dc:	28f50c63          	beq	a0,a5,c0027c74 <_malloc_r+0x5a8>
c00279e0:	29456863          	bltu	a0,s4,c0027c70 <_malloc_r+0x5a4>
c00279e4:	c8044c37          	lui	s8,0xc8044
c00279e8:	82cc0c13          	addi	s8,s8,-2004 # c804382c <_end+0xfffbefac>
c00279ec:	000c2583          	lw	a1,0(s8)
c00279f0:	00ba85b3          	add	a1,s5,a1
c00279f4:	00bc2023          	sw	a1,0(s8)
c00279f8:	00058793          	mv	a5,a1
c00279fc:	3aaa0463          	beq	s4,a0,c0027da4 <_malloc_r+0x6d8>
c0027a00:	990ca683          	lw	a3,-1648(s9)
c0027a04:	fff00713          	li	a4,-1
c0027a08:	3ae68c63          	beq	a3,a4,c0027dc0 <_malloc_r+0x6f4>
c0027a0c:	414b8a33          	sub	s4,s7,s4
c0027a10:	00fa07b3          	add	a5,s4,a5
c0027a14:	00fc2023          	sw	a5,0(s8)
c0027a18:	007bfc93          	andi	s9,s7,7
c0027a1c:	300c8663          	beqz	s9,c0027d28 <_malloc_r+0x65c>
c0027a20:	000017b7          	lui	a5,0x1
c0027a24:	419b8bb3          	sub	s7,s7,s9
c0027a28:	00878593          	addi	a1,a5,8 # 1008 <_STACK_SIZE+0x8>
c0027a2c:	008b8b93          	addi	s7,s7,8
c0027a30:	419585b3          	sub	a1,a1,s9
c0027a34:	015b8ab3          	add	s5,s7,s5
c0027a38:	fff78793          	addi	a5,a5,-1
c0027a3c:	415585b3          	sub	a1,a1,s5
c0027a40:	00f5fa33          	and	s4,a1,a5
c0027a44:	000a0593          	mv	a1,s4
c0027a48:	00098513          	mv	a0,s3
c0027a4c:	615010ef          	jal	ra,c0029860 <_sbrk_r>
c0027a50:	fff00793          	li	a5,-1
c0027a54:	3cf50063          	beq	a0,a5,c0027e14 <_malloc_r+0x748>
c0027a58:	41750533          	sub	a0,a0,s7
c0027a5c:	01450ab3          	add	s5,a0,s4
c0027a60:	000c2583          	lw	a1,0(s8)
c0027a64:	01792423          	sw	s7,8(s2)
c0027a68:	001aea93          	ori	s5,s5,1
c0027a6c:	00ba05b3          	add	a1,s4,a1
c0027a70:	00bc2023          	sw	a1,0(s8)
c0027a74:	015ba223          	sw	s5,4(s7)
c0027a78:	35240863          	beq	s0,s2,c0027dc8 <_malloc_r+0x6fc>
c0027a7c:	00f00693          	li	a3,15
c0027a80:	3566f863          	bgeu	a3,s6,c0027dd0 <_malloc_r+0x704>
c0027a84:	00442703          	lw	a4,4(s0)
c0027a88:	ff4b0793          	addi	a5,s6,-12
c0027a8c:	ff87f793          	andi	a5,a5,-8
c0027a90:	00177713          	andi	a4,a4,1
c0027a94:	00f76733          	or	a4,a4,a5
c0027a98:	00e42223          	sw	a4,4(s0)
c0027a9c:	00500613          	li	a2,5
c0027aa0:	00f40733          	add	a4,s0,a5
c0027aa4:	00c72223          	sw	a2,4(a4)
c0027aa8:	00c72423          	sw	a2,8(a4)
c0027aac:	36f6ee63          	bltu	a3,a5,c0027e28 <_malloc_r+0x75c>
c0027ab0:	004baa83          	lw	s5,4(s7)
c0027ab4:	000b8413          	mv	s0,s7
c0027ab8:	c80037b7          	lui	a5,0xc8003
c0027abc:	9207a703          	lw	a4,-1760(a5) # c8002920 <_end+0xfff7e0a0>
c0027ac0:	00b77463          	bgeu	a4,a1,c0027ac8 <_malloc_r+0x3fc>
c0027ac4:	92b7a023          	sw	a1,-1760(a5)
c0027ac8:	c80037b7          	lui	a5,0xc8003
c0027acc:	91c7a703          	lw	a4,-1764(a5) # c800291c <_end+0xfff7e09c>
c0027ad0:	1ab77663          	bgeu	a4,a1,c0027c7c <_malloc_r+0x5b0>
c0027ad4:	90b7ae23          	sw	a1,-1764(a5)
c0027ad8:	1a40006f          	j	c0027c7c <_malloc_r+0x5b0>
c0027adc:	0014e713          	ori	a4,s1,1
c0027ae0:	00e42223          	sw	a4,4(s0)
c0027ae4:	009404b3          	add	s1,s0,s1
c0027ae8:	00992423          	sw	s1,8(s2)
c0027aec:	0017e793          	ori	a5,a5,1
c0027af0:	00098513          	mv	a0,s3
c0027af4:	00f4a223          	sw	a5,4(s1)
c0027af8:	5ec000ef          	jal	ra,c00280e4 <__malloc_unlock>
c0027afc:	00840513          	addi	a0,s0,8
c0027b00:	e09ff06f          	j	c0027908 <_malloc_r+0x23c>
c0027b04:	00c42683          	lw	a3,12(s0)
c0027b08:	00842603          	lw	a2,8(s0)
c0027b0c:	c41ff06f          	j	c002774c <_malloc_r+0x80>
c0027b10:	00955793          	srli	a5,a0,0x9
c0027b14:	00400713          	li	a4,4
c0027b18:	14f77263          	bgeu	a4,a5,c0027c5c <_malloc_r+0x590>
c0027b1c:	01400713          	li	a4,20
c0027b20:	22f76a63          	bltu	a4,a5,c0027d54 <_malloc_r+0x688>
c0027b24:	05c78693          	addi	a3,a5,92
c0027b28:	05b78593          	addi	a1,a5,91
c0027b2c:	00369693          	slli	a3,a3,0x3
c0027b30:	00d906b3          	add	a3,s2,a3
c0027b34:	0006a783          	lw	a5,0(a3)
c0027b38:	ff868693          	addi	a3,a3,-8
c0027b3c:	1cf68863          	beq	a3,a5,c0027d0c <_malloc_r+0x640>
c0027b40:	0047a703          	lw	a4,4(a5)
c0027b44:	ffc77713          	andi	a4,a4,-4
c0027b48:	00e57663          	bgeu	a0,a4,c0027b54 <_malloc_r+0x488>
c0027b4c:	0087a783          	lw	a5,8(a5)
c0027b50:	fef698e3          	bne	a3,a5,c0027b40 <_malloc_r+0x474>
c0027b54:	00c7a683          	lw	a3,12(a5)
c0027b58:	00492703          	lw	a4,4(s2)
c0027b5c:	00d42623          	sw	a3,12(s0)
c0027b60:	00f42423          	sw	a5,8(s0)
c0027b64:	0086a423          	sw	s0,8(a3)
c0027b68:	0087a623          	sw	s0,12(a5)
c0027b6c:	cf1ff06f          	j	c002785c <_malloc_r+0x190>
c0027b70:	01400713          	li	a4,20
c0027b74:	12f77663          	bgeu	a4,a5,c0027ca0 <_malloc_r+0x5d4>
c0027b78:	05400713          	li	a4,84
c0027b7c:	1ef76a63          	bltu	a4,a5,c0027d70 <_malloc_r+0x6a4>
c0027b80:	00c4d793          	srli	a5,s1,0xc
c0027b84:	06f78613          	addi	a2,a5,111
c0027b88:	06e78513          	addi	a0,a5,110
c0027b8c:	00361693          	slli	a3,a2,0x3
c0027b90:	c1dff06f          	j	c00277ac <_malloc_r+0xe0>
c0027b94:	001e0e13          	addi	t3,t3,1
c0027b98:	003e7793          	andi	a5,t3,3
c0027b9c:	00850513          	addi	a0,a0,8
c0027ba0:	10078e63          	beqz	a5,c0027cbc <_malloc_r+0x5f0>
c0027ba4:	00c52783          	lw	a5,12(a0)
c0027ba8:	d09ff06f          	j	c00278b0 <_malloc_r+0x1e4>
c0027bac:	00842603          	lw	a2,8(s0)
c0027bb0:	0014e593          	ori	a1,s1,1
c0027bb4:	00b42223          	sw	a1,4(s0)
c0027bb8:	00f62623          	sw	a5,12(a2)
c0027bbc:	00c7a423          	sw	a2,8(a5)
c0027bc0:	009404b3          	add	s1,s0,s1
c0027bc4:	00992a23          	sw	s1,20(s2)
c0027bc8:	00992823          	sw	s1,16(s2)
c0027bcc:	0016e793          	ori	a5,a3,1
c0027bd0:	0114a623          	sw	a7,12(s1)
c0027bd4:	0114a423          	sw	a7,8(s1)
c0027bd8:	00f4a223          	sw	a5,4(s1)
c0027bdc:	00e40733          	add	a4,s0,a4
c0027be0:	00098513          	mv	a0,s3
c0027be4:	00d72023          	sw	a3,0(a4)
c0027be8:	4fc000ef          	jal	ra,c00280e4 <__malloc_unlock>
c0027bec:	00840513          	addi	a0,s0,8
c0027bf0:	d19ff06f          	j	c0027908 <_malloc_r+0x23c>
c0027bf4:	0034d613          	srli	a2,s1,0x3
c0027bf8:	00848793          	addi	a5,s1,8
c0027bfc:	b29ff06f          	j	c0027724 <_malloc_r+0x58>
c0027c00:	00a40733          	add	a4,s0,a0
c0027c04:	00472783          	lw	a5,4(a4)
c0027c08:	00098513          	mv	a0,s3
c0027c0c:	0017e793          	ori	a5,a5,1
c0027c10:	00f72223          	sw	a5,4(a4)
c0027c14:	4d0000ef          	jal	ra,c00280e4 <__malloc_unlock>
c0027c18:	00840513          	addi	a0,s0,8
c0027c1c:	cedff06f          	j	c0027908 <_malloc_r+0x23c>
c0027c20:	0014e713          	ori	a4,s1,1
c0027c24:	00e42223          	sw	a4,4(s0)
c0027c28:	009404b3          	add	s1,s0,s1
c0027c2c:	00992a23          	sw	s1,20(s2)
c0027c30:	00992823          	sw	s1,16(s2)
c0027c34:	0017e713          	ori	a4,a5,1
c0027c38:	0114a623          	sw	a7,12(s1)
c0027c3c:	0114a423          	sw	a7,8(s1)
c0027c40:	00e4a223          	sw	a4,4(s1)
c0027c44:	00a40533          	add	a0,s0,a0
c0027c48:	00f52023          	sw	a5,0(a0)
c0027c4c:	00098513          	mv	a0,s3
c0027c50:	494000ef          	jal	ra,c00280e4 <__malloc_unlock>
c0027c54:	00840513          	addi	a0,s0,8
c0027c58:	cb1ff06f          	j	c0027908 <_malloc_r+0x23c>
c0027c5c:	00655793          	srli	a5,a0,0x6
c0027c60:	03978693          	addi	a3,a5,57
c0027c64:	03878593          	addi	a1,a5,56
c0027c68:	00369693          	slli	a3,a3,0x3
c0027c6c:	ec5ff06f          	j	c0027b30 <_malloc_r+0x464>
c0027c70:	11240e63          	beq	s0,s2,c0027d8c <_malloc_r+0x6c0>
c0027c74:	00892403          	lw	s0,8(s2)
c0027c78:	00442a83          	lw	s5,4(s0)
c0027c7c:	ffcafa93          	andi	s5,s5,-4
c0027c80:	409a87b3          	sub	a5,s5,s1
c0027c84:	009ae663          	bltu	s5,s1,c0027c90 <_malloc_r+0x5c4>
c0027c88:	00f00713          	li	a4,15
c0027c8c:	e4f748e3          	blt	a4,a5,c0027adc <_malloc_r+0x410>
c0027c90:	00098513          	mv	a0,s3
c0027c94:	450000ef          	jal	ra,c00280e4 <__malloc_unlock>
c0027c98:	00000513          	li	a0,0
c0027c9c:	c6dff06f          	j	c0027908 <_malloc_r+0x23c>
c0027ca0:	05c78613          	addi	a2,a5,92
c0027ca4:	05b78513          	addi	a0,a5,91
c0027ca8:	00361693          	slli	a3,a2,0x3
c0027cac:	b01ff06f          	j	c00277ac <_malloc_r+0xe0>
c0027cb0:	00832783          	lw	a5,8(t1)
c0027cb4:	fff60613          	addi	a2,a2,-1
c0027cb8:	1c679263          	bne	a5,t1,c0027e7c <_malloc_r+0x7b0>
c0027cbc:	00367793          	andi	a5,a2,3
c0027cc0:	ff830313          	addi	t1,t1,-8
c0027cc4:	fe0796e3          	bnez	a5,c0027cb0 <_malloc_r+0x5e4>
c0027cc8:	00492703          	lw	a4,4(s2)
c0027ccc:	fff5c793          	not	a5,a1
c0027cd0:	00e7f7b3          	and	a5,a5,a4
c0027cd4:	00f92223          	sw	a5,4(s2)
c0027cd8:	00159593          	slli	a1,a1,0x1
c0027cdc:	c8b7eee3          	bltu	a5,a1,c0027978 <_malloc_r+0x2ac>
c0027ce0:	c8058ce3          	beqz	a1,c0027978 <_malloc_r+0x2ac>
c0027ce4:	00f5f733          	and	a4,a1,a5
c0027ce8:	00071a63          	bnez	a4,c0027cfc <_malloc_r+0x630>
c0027cec:	00159593          	slli	a1,a1,0x1
c0027cf0:	00f5f733          	and	a4,a1,a5
c0027cf4:	004e0e13          	addi	t3,t3,4
c0027cf8:	fe070ae3          	beqz	a4,c0027cec <_malloc_r+0x620>
c0027cfc:	000e0613          	mv	a2,t3
c0027d00:	b9dff06f          	j	c002789c <_malloc_r+0x1d0>
c0027d04:	010a8a93          	addi	s5,s5,16 # fffff010 <_end+0x37f7a790>
c0027d08:	cc1ff06f          	j	c00279c8 <_malloc_r+0x2fc>
c0027d0c:	00492503          	lw	a0,4(s2)
c0027d10:	4025d593          	srai	a1,a1,0x2
c0027d14:	00100713          	li	a4,1
c0027d18:	00b71733          	sll	a4,a4,a1
c0027d1c:	00a76733          	or	a4,a4,a0
c0027d20:	00e92223          	sw	a4,4(s2)
c0027d24:	e39ff06f          	j	c0027b5c <_malloc_r+0x490>
c0027d28:	015b85b3          	add	a1,s7,s5
c0027d2c:	40b005b3          	neg	a1,a1
c0027d30:	01459593          	slli	a1,a1,0x14
c0027d34:	0145da13          	srli	s4,a1,0x14
c0027d38:	000a0593          	mv	a1,s4
c0027d3c:	00098513          	mv	a0,s3
c0027d40:	321010ef          	jal	ra,c0029860 <_sbrk_r>
c0027d44:	fff00793          	li	a5,-1
c0027d48:	d0f518e3          	bne	a0,a5,c0027a58 <_malloc_r+0x38c>
c0027d4c:	00000a13          	li	s4,0
c0027d50:	d11ff06f          	j	c0027a60 <_malloc_r+0x394>
c0027d54:	05400713          	li	a4,84
c0027d58:	08f76263          	bltu	a4,a5,c0027ddc <_malloc_r+0x710>
c0027d5c:	00c55793          	srli	a5,a0,0xc
c0027d60:	06f78693          	addi	a3,a5,111
c0027d64:	06e78593          	addi	a1,a5,110
c0027d68:	00369693          	slli	a3,a3,0x3
c0027d6c:	dc5ff06f          	j	c0027b30 <_malloc_r+0x464>
c0027d70:	15400713          	li	a4,340
c0027d74:	08f76263          	bltu	a4,a5,c0027df8 <_malloc_r+0x72c>
c0027d78:	00f4d793          	srli	a5,s1,0xf
c0027d7c:	07878613          	addi	a2,a5,120
c0027d80:	07778513          	addi	a0,a5,119
c0027d84:	00361693          	slli	a3,a2,0x3
c0027d88:	a25ff06f          	j	c00277ac <_malloc_r+0xe0>
c0027d8c:	c8044c37          	lui	s8,0xc8044
c0027d90:	82cc0c13          	addi	s8,s8,-2004 # c804382c <_end+0xfffbefac>
c0027d94:	000c2783          	lw	a5,0(s8)
c0027d98:	00fa87b3          	add	a5,s5,a5
c0027d9c:	00fc2023          	sw	a5,0(s8)
c0027da0:	c61ff06f          	j	c0027a00 <_malloc_r+0x334>
c0027da4:	014a1713          	slli	a4,s4,0x14
c0027da8:	c4071ce3          	bnez	a4,c0027a00 <_malloc_r+0x334>
c0027dac:	00892403          	lw	s0,8(s2)
c0027db0:	015b0ab3          	add	s5,s6,s5
c0027db4:	001aea93          	ori	s5,s5,1
c0027db8:	01542223          	sw	s5,4(s0)
c0027dbc:	cfdff06f          	j	c0027ab8 <_malloc_r+0x3ec>
c0027dc0:	997ca823          	sw	s7,-1648(s9)
c0027dc4:	c55ff06f          	j	c0027a18 <_malloc_r+0x34c>
c0027dc8:	000b8413          	mv	s0,s7
c0027dcc:	cedff06f          	j	c0027ab8 <_malloc_r+0x3ec>
c0027dd0:	00100793          	li	a5,1
c0027dd4:	00fba223          	sw	a5,4(s7)
c0027dd8:	eb9ff06f          	j	c0027c90 <_malloc_r+0x5c4>
c0027ddc:	15400713          	li	a4,340
c0027de0:	06f76263          	bltu	a4,a5,c0027e44 <_malloc_r+0x778>
c0027de4:	00f55793          	srli	a5,a0,0xf
c0027de8:	07878693          	addi	a3,a5,120
c0027dec:	07778593          	addi	a1,a5,119
c0027df0:	00369693          	slli	a3,a3,0x3
c0027df4:	d3dff06f          	j	c0027b30 <_malloc_r+0x464>
c0027df8:	55400713          	li	a4,1364
c0027dfc:	06f76263          	bltu	a4,a5,c0027e60 <_malloc_r+0x794>
c0027e00:	0124d793          	srli	a5,s1,0x12
c0027e04:	07d78613          	addi	a2,a5,125
c0027e08:	07c78513          	addi	a0,a5,124
c0027e0c:	00361693          	slli	a3,a2,0x3
c0027e10:	99dff06f          	j	c00277ac <_malloc_r+0xe0>
c0027e14:	ff8c8c93          	addi	s9,s9,-8
c0027e18:	019a8ab3          	add	s5,s5,s9
c0027e1c:	417a8ab3          	sub	s5,s5,s7
c0027e20:	00000a13          	li	s4,0
c0027e24:	c3dff06f          	j	c0027a60 <_malloc_r+0x394>
c0027e28:	00840593          	addi	a1,s0,8
c0027e2c:	00098513          	mv	a0,s3
c0027e30:	828fc0ef          	jal	ra,c0023e58 <_free_r>
c0027e34:	00892403          	lw	s0,8(s2)
c0027e38:	000c2583          	lw	a1,0(s8)
c0027e3c:	00442a83          	lw	s5,4(s0)
c0027e40:	c79ff06f          	j	c0027ab8 <_malloc_r+0x3ec>
c0027e44:	55400713          	li	a4,1364
c0027e48:	02f76463          	bltu	a4,a5,c0027e70 <_malloc_r+0x7a4>
c0027e4c:	01255793          	srli	a5,a0,0x12
c0027e50:	07d78693          	addi	a3,a5,125
c0027e54:	07c78593          	addi	a1,a5,124
c0027e58:	00369693          	slli	a3,a3,0x3
c0027e5c:	cd5ff06f          	j	c0027b30 <_malloc_r+0x464>
c0027e60:	3f800693          	li	a3,1016
c0027e64:	07f00613          	li	a2,127
c0027e68:	07e00513          	li	a0,126
c0027e6c:	941ff06f          	j	c00277ac <_malloc_r+0xe0>
c0027e70:	3f800693          	li	a3,1016
c0027e74:	07e00593          	li	a1,126
c0027e78:	cb9ff06f          	j	c0027b30 <_malloc_r+0x464>
c0027e7c:	00492783          	lw	a5,4(s2)
c0027e80:	e59ff06f          	j	c0027cd8 <_malloc_r+0x60c>

c0027e84 <_mbtowc_r>:
c0027e84:	c80037b7          	lui	a5,0xc8003
c0027e88:	0747a783          	lw	a5,116(a5) # c8003074 <_end+0xfff7e7f4>
c0027e8c:	00078067          	jr	a5

c0027e90 <__ascii_mbtowc>:
c0027e90:	02058063          	beqz	a1,c0027eb0 <__ascii_mbtowc+0x20>
c0027e94:	04060263          	beqz	a2,c0027ed8 <__ascii_mbtowc+0x48>
c0027e98:	04068863          	beqz	a3,c0027ee8 <__ascii_mbtowc+0x58>
c0027e9c:	00064783          	lbu	a5,0(a2)
c0027ea0:	00f5a023          	sw	a5,0(a1)
c0027ea4:	00064503          	lbu	a0,0(a2)
c0027ea8:	00a03533          	snez	a0,a0
c0027eac:	00008067          	ret
c0027eb0:	ff010113          	addi	sp,sp,-16
c0027eb4:	00c10593          	addi	a1,sp,12
c0027eb8:	02060463          	beqz	a2,c0027ee0 <__ascii_mbtowc+0x50>
c0027ebc:	02068a63          	beqz	a3,c0027ef0 <__ascii_mbtowc+0x60>
c0027ec0:	00064783          	lbu	a5,0(a2)
c0027ec4:	00f5a023          	sw	a5,0(a1)
c0027ec8:	00064503          	lbu	a0,0(a2)
c0027ecc:	00a03533          	snez	a0,a0
c0027ed0:	01010113          	addi	sp,sp,16
c0027ed4:	00008067          	ret
c0027ed8:	00000513          	li	a0,0
c0027edc:	00008067          	ret
c0027ee0:	00000513          	li	a0,0
c0027ee4:	fedff06f          	j	c0027ed0 <__ascii_mbtowc+0x40>
c0027ee8:	ffe00513          	li	a0,-2
c0027eec:	00008067          	ret
c0027ef0:	ffe00513          	li	a0,-2
c0027ef4:	fddff06f          	j	c0027ed0 <__ascii_mbtowc+0x40>

c0027ef8 <memchr>:
c0027ef8:	00357793          	andi	a5,a0,3
c0027efc:	0ff5f693          	andi	a3,a1,255
c0027f00:	02078a63          	beqz	a5,c0027f34 <memchr+0x3c>
c0027f04:	fff60793          	addi	a5,a2,-1
c0027f08:	02060e63          	beqz	a2,c0027f44 <memchr+0x4c>
c0027f0c:	fff00613          	li	a2,-1
c0027f10:	0180006f          	j	c0027f28 <memchr+0x30>
c0027f14:	00150513          	addi	a0,a0,1
c0027f18:	00357713          	andi	a4,a0,3
c0027f1c:	00070e63          	beqz	a4,c0027f38 <memchr+0x40>
c0027f20:	fff78793          	addi	a5,a5,-1
c0027f24:	02c78063          	beq	a5,a2,c0027f44 <memchr+0x4c>
c0027f28:	00054703          	lbu	a4,0(a0)
c0027f2c:	fed714e3          	bne	a4,a3,c0027f14 <memchr+0x1c>
c0027f30:	00008067          	ret
c0027f34:	00060793          	mv	a5,a2
c0027f38:	00300713          	li	a4,3
c0027f3c:	02f76663          	bltu	a4,a5,c0027f68 <memchr+0x70>
c0027f40:	00079663          	bnez	a5,c0027f4c <memchr+0x54>
c0027f44:	00000513          	li	a0,0
c0027f48:	00008067          	ret
c0027f4c:	00f507b3          	add	a5,a0,a5
c0027f50:	00c0006f          	j	c0027f5c <memchr+0x64>
c0027f54:	00150513          	addi	a0,a0,1
c0027f58:	fea786e3          	beq	a5,a0,c0027f44 <memchr+0x4c>
c0027f5c:	00054703          	lbu	a4,0(a0)
c0027f60:	fed71ae3          	bne	a4,a3,c0027f54 <memchr+0x5c>
c0027f64:	00008067          	ret
c0027f68:	0ff5f593          	andi	a1,a1,255
c0027f6c:	00859893          	slli	a7,a1,0x8
c0027f70:	00b8e5b3          	or	a1,a7,a1
c0027f74:	01059893          	slli	a7,a1,0x10
c0027f78:	00b8e8b3          	or	a7,a7,a1
c0027f7c:	feff0837          	lui	a6,0xfeff0
c0027f80:	808085b7          	lui	a1,0x80808
c0027f84:	eff80813          	addi	a6,a6,-257 # fefefeff <_end+0x36f6b67f>
c0027f88:	08058593          	addi	a1,a1,128 # 80808080 <_end+0xb8783800>
c0027f8c:	00300313          	li	t1,3
c0027f90:	00052703          	lw	a4,0(a0)
c0027f94:	00e8c733          	xor	a4,a7,a4
c0027f98:	01070633          	add	a2,a4,a6
c0027f9c:	fff74713          	not	a4,a4
c0027fa0:	00e67733          	and	a4,a2,a4
c0027fa4:	00b77733          	and	a4,a4,a1
c0027fa8:	fa0712e3          	bnez	a4,c0027f4c <memchr+0x54>
c0027fac:	ffc78793          	addi	a5,a5,-4
c0027fb0:	00450513          	addi	a0,a0,4
c0027fb4:	fcf36ee3          	bltu	t1,a5,c0027f90 <memchr+0x98>
c0027fb8:	f8079ae3          	bnez	a5,c0027f4c <memchr+0x54>
c0027fbc:	f89ff06f          	j	c0027f44 <memchr+0x4c>

c0027fc0 <memmove>:
c0027fc0:	02a5f663          	bgeu	a1,a0,c0027fec <memmove+0x2c>
c0027fc4:	00c587b3          	add	a5,a1,a2
c0027fc8:	02f57263          	bgeu	a0,a5,c0027fec <memmove+0x2c>
c0027fcc:	00c50733          	add	a4,a0,a2
c0027fd0:	0e060a63          	beqz	a2,c00280c4 <memmove+0x104>
c0027fd4:	fff7c683          	lbu	a3,-1(a5)
c0027fd8:	fff78793          	addi	a5,a5,-1
c0027fdc:	fff70713          	addi	a4,a4,-1
c0027fe0:	00d70023          	sb	a3,0(a4)
c0027fe4:	fef598e3          	bne	a1,a5,c0027fd4 <memmove+0x14>
c0027fe8:	00008067          	ret
c0027fec:	00f00793          	li	a5,15
c0027ff0:	02c7e863          	bltu	a5,a2,c0028020 <memmove+0x60>
c0027ff4:	00050793          	mv	a5,a0
c0027ff8:	fff60693          	addi	a3,a2,-1
c0027ffc:	0c060c63          	beqz	a2,c00280d4 <memmove+0x114>
c0028000:	00168693          	addi	a3,a3,1
c0028004:	00d786b3          	add	a3,a5,a3
c0028008:	0005c703          	lbu	a4,0(a1)
c002800c:	00178793          	addi	a5,a5,1
c0028010:	00158593          	addi	a1,a1,1
c0028014:	fee78fa3          	sb	a4,-1(a5)
c0028018:	fed798e3          	bne	a5,a3,c0028008 <memmove+0x48>
c002801c:	00008067          	ret
c0028020:	00a5e7b3          	or	a5,a1,a0
c0028024:	0037f793          	andi	a5,a5,3
c0028028:	0a079063          	bnez	a5,c00280c8 <memmove+0x108>
c002802c:	ff060893          	addi	a7,a2,-16
c0028030:	ff08f893          	andi	a7,a7,-16
c0028034:	01088893          	addi	a7,a7,16
c0028038:	01150833          	add	a6,a0,a7
c002803c:	00058713          	mv	a4,a1
c0028040:	00050793          	mv	a5,a0
c0028044:	00072683          	lw	a3,0(a4)
c0028048:	01070713          	addi	a4,a4,16
c002804c:	01078793          	addi	a5,a5,16
c0028050:	fed7a823          	sw	a3,-16(a5)
c0028054:	ff472683          	lw	a3,-12(a4)
c0028058:	fed7aa23          	sw	a3,-12(a5)
c002805c:	ff872683          	lw	a3,-8(a4)
c0028060:	fed7ac23          	sw	a3,-8(a5)
c0028064:	ffc72683          	lw	a3,-4(a4)
c0028068:	fed7ae23          	sw	a3,-4(a5)
c002806c:	fcf81ce3          	bne	a6,a5,c0028044 <memmove+0x84>
c0028070:	00c67713          	andi	a4,a2,12
c0028074:	011585b3          	add	a1,a1,a7
c0028078:	00f67813          	andi	a6,a2,15
c002807c:	04070e63          	beqz	a4,c00280d8 <memmove+0x118>
c0028080:	00058713          	mv	a4,a1
c0028084:	00078893          	mv	a7,a5
c0028088:	00300e13          	li	t3,3
c002808c:	00072303          	lw	t1,0(a4)
c0028090:	00470713          	addi	a4,a4,4
c0028094:	40e806b3          	sub	a3,a6,a4
c0028098:	0068a023          	sw	t1,0(a7)
c002809c:	00d586b3          	add	a3,a1,a3
c00280a0:	00488893          	addi	a7,a7,4
c00280a4:	fede64e3          	bltu	t3,a3,c002808c <memmove+0xcc>
c00280a8:	ffc80713          	addi	a4,a6,-4
c00280ac:	ffc77713          	andi	a4,a4,-4
c00280b0:	00470713          	addi	a4,a4,4
c00280b4:	00367613          	andi	a2,a2,3
c00280b8:	00e787b3          	add	a5,a5,a4
c00280bc:	00e585b3          	add	a1,a1,a4
c00280c0:	f39ff06f          	j	c0027ff8 <memmove+0x38>
c00280c4:	00008067          	ret
c00280c8:	fff60693          	addi	a3,a2,-1
c00280cc:	00050793          	mv	a5,a0
c00280d0:	f31ff06f          	j	c0028000 <memmove+0x40>
c00280d4:	00008067          	ret
c00280d8:	00080613          	mv	a2,a6
c00280dc:	f1dff06f          	j	c0027ff8 <memmove+0x38>

c00280e0 <__malloc_lock>:
c00280e0:	00008067          	ret

c00280e4 <__malloc_unlock>:
c00280e4:	00008067          	ret

c00280e8 <_Balloc>:
c00280e8:	04c52783          	lw	a5,76(a0)
c00280ec:	ff010113          	addi	sp,sp,-16
c00280f0:	00812423          	sw	s0,8(sp)
c00280f4:	00912223          	sw	s1,4(sp)
c00280f8:	00112623          	sw	ra,12(sp)
c00280fc:	01212023          	sw	s2,0(sp)
c0028100:	00050413          	mv	s0,a0
c0028104:	00058493          	mv	s1,a1
c0028108:	02078e63          	beqz	a5,c0028144 <_Balloc+0x5c>
c002810c:	00249513          	slli	a0,s1,0x2
c0028110:	00a787b3          	add	a5,a5,a0
c0028114:	0007a503          	lw	a0,0(a5)
c0028118:	04050663          	beqz	a0,c0028164 <_Balloc+0x7c>
c002811c:	00052703          	lw	a4,0(a0)
c0028120:	00e7a023          	sw	a4,0(a5)
c0028124:	00052823          	sw	zero,16(a0)
c0028128:	00052623          	sw	zero,12(a0)
c002812c:	00c12083          	lw	ra,12(sp)
c0028130:	00812403          	lw	s0,8(sp)
c0028134:	00412483          	lw	s1,4(sp)
c0028138:	00012903          	lw	s2,0(sp)
c002813c:	01010113          	addi	sp,sp,16
c0028140:	00008067          	ret
c0028144:	02100613          	li	a2,33
c0028148:	00400593          	li	a1,4
c002814c:	37c040ef          	jal	ra,c002c4c8 <_calloc_r>
c0028150:	04a42623          	sw	a0,76(s0)
c0028154:	00050793          	mv	a5,a0
c0028158:	fa051ae3          	bnez	a0,c002810c <_Balloc+0x24>
c002815c:	00000513          	li	a0,0
c0028160:	fcdff06f          	j	c002812c <_Balloc+0x44>
c0028164:	00100913          	li	s2,1
c0028168:	00991933          	sll	s2,s2,s1
c002816c:	00590613          	addi	a2,s2,5
c0028170:	00261613          	slli	a2,a2,0x2
c0028174:	00100593          	li	a1,1
c0028178:	00040513          	mv	a0,s0
c002817c:	34c040ef          	jal	ra,c002c4c8 <_calloc_r>
c0028180:	fc050ee3          	beqz	a0,c002815c <_Balloc+0x74>
c0028184:	00952223          	sw	s1,4(a0)
c0028188:	01252423          	sw	s2,8(a0)
c002818c:	f99ff06f          	j	c0028124 <_Balloc+0x3c>

c0028190 <_Bfree>:
c0028190:	02058063          	beqz	a1,c00281b0 <_Bfree+0x20>
c0028194:	0045a703          	lw	a4,4(a1)
c0028198:	04c52783          	lw	a5,76(a0)
c002819c:	00271713          	slli	a4,a4,0x2
c00281a0:	00e787b3          	add	a5,a5,a4
c00281a4:	0007a703          	lw	a4,0(a5)
c00281a8:	00e5a023          	sw	a4,0(a1)
c00281ac:	00b7a023          	sw	a1,0(a5)
c00281b0:	00008067          	ret

c00281b4 <__multadd>:
c00281b4:	fe010113          	addi	sp,sp,-32
c00281b8:	00912a23          	sw	s1,20(sp)
c00281bc:	0105a483          	lw	s1,16(a1)
c00281c0:	00010337          	lui	t1,0x10
c00281c4:	00812c23          	sw	s0,24(sp)
c00281c8:	01212823          	sw	s2,16(sp)
c00281cc:	01312623          	sw	s3,12(sp)
c00281d0:	00112e23          	sw	ra,28(sp)
c00281d4:	01412423          	sw	s4,8(sp)
c00281d8:	00058913          	mv	s2,a1
c00281dc:	00050993          	mv	s3,a0
c00281e0:	00068413          	mv	s0,a3
c00281e4:	01458813          	addi	a6,a1,20
c00281e8:	00000893          	li	a7,0
c00281ec:	fff30313          	addi	t1,t1,-1 # ffff <_STACK_SIZE+0xefff>
c00281f0:	00082783          	lw	a5,0(a6)
c00281f4:	00480813          	addi	a6,a6,4
c00281f8:	00188893          	addi	a7,a7,1
c00281fc:	0067f6b3          	and	a3,a5,t1
c0028200:	02c686b3          	mul	a3,a3,a2
c0028204:	0107d793          	srli	a5,a5,0x10
c0028208:	02c787b3          	mul	a5,a5,a2
c002820c:	008686b3          	add	a3,a3,s0
c0028210:	0106de13          	srli	t3,a3,0x10
c0028214:	0066f733          	and	a4,a3,t1
c0028218:	01c786b3          	add	a3,a5,t3
c002821c:	01069793          	slli	a5,a3,0x10
c0028220:	00e78733          	add	a4,a5,a4
c0028224:	fee82e23          	sw	a4,-4(a6)
c0028228:	0106d413          	srli	s0,a3,0x10
c002822c:	fc98c2e3          	blt	a7,s1,c00281f0 <__multadd+0x3c>
c0028230:	02040263          	beqz	s0,c0028254 <__multadd+0xa0>
c0028234:	00892783          	lw	a5,8(s2)
c0028238:	04f4d063          	bge	s1,a5,c0028278 <__multadd+0xc4>
c002823c:	00448793          	addi	a5,s1,4
c0028240:	00279793          	slli	a5,a5,0x2
c0028244:	00f907b3          	add	a5,s2,a5
c0028248:	0087a223          	sw	s0,4(a5)
c002824c:	00148493          	addi	s1,s1,1
c0028250:	00992823          	sw	s1,16(s2)
c0028254:	01c12083          	lw	ra,28(sp)
c0028258:	01812403          	lw	s0,24(sp)
c002825c:	01412483          	lw	s1,20(sp)
c0028260:	00c12983          	lw	s3,12(sp)
c0028264:	00812a03          	lw	s4,8(sp)
c0028268:	00090513          	mv	a0,s2
c002826c:	01012903          	lw	s2,16(sp)
c0028270:	02010113          	addi	sp,sp,32
c0028274:	00008067          	ret
c0028278:	00492583          	lw	a1,4(s2)
c002827c:	00098513          	mv	a0,s3
c0028280:	00158593          	addi	a1,a1,1
c0028284:	e65ff0ef          	jal	ra,c00280e8 <_Balloc>
c0028288:	00050a13          	mv	s4,a0
c002828c:	04050c63          	beqz	a0,c00282e4 <__multadd+0x130>
c0028290:	01092603          	lw	a2,16(s2)
c0028294:	00c90593          	addi	a1,s2,12
c0028298:	00c50513          	addi	a0,a0,12
c002829c:	00260613          	addi	a2,a2,2
c00282a0:	00261613          	slli	a2,a2,0x2
c00282a4:	8bdf50ef          	jal	ra,c001db60 <memcpy>
c00282a8:	00492703          	lw	a4,4(s2)
c00282ac:	04c9a783          	lw	a5,76(s3)
c00282b0:	00271713          	slli	a4,a4,0x2
c00282b4:	00e787b3          	add	a5,a5,a4
c00282b8:	0007a703          	lw	a4,0(a5)
c00282bc:	00e92023          	sw	a4,0(s2)
c00282c0:	0127a023          	sw	s2,0(a5)
c00282c4:	00448793          	addi	a5,s1,4
c00282c8:	000a0913          	mv	s2,s4
c00282cc:	00279793          	slli	a5,a5,0x2
c00282d0:	00f907b3          	add	a5,s2,a5
c00282d4:	0087a223          	sw	s0,4(a5)
c00282d8:	00148493          	addi	s1,s1,1
c00282dc:	00992823          	sw	s1,16(s2)
c00282e0:	f75ff06f          	j	c0028254 <__multadd+0xa0>
c00282e4:	c80026b7          	lui	a3,0xc8002
c00282e8:	c8002537          	lui	a0,0xc8002
c00282ec:	73868693          	addi	a3,a3,1848 # c8002738 <_end+0xfff7deb8>
c00282f0:	00000613          	li	a2,0
c00282f4:	0b500593          	li	a1,181
c00282f8:	7ac50513          	addi	a0,a0,1964 # c80027ac <_end+0xfff7df2c>
c00282fc:	160040ef          	jal	ra,c002c45c <__assert_func>

c0028300 <__s2b>:
c0028300:	fe010113          	addi	sp,sp,-32
c0028304:	00812c23          	sw	s0,24(sp)
c0028308:	00912a23          	sw	s1,20(sp)
c002830c:	01212823          	sw	s2,16(sp)
c0028310:	01312623          	sw	s3,12(sp)
c0028314:	01412423          	sw	s4,8(sp)
c0028318:	00068993          	mv	s3,a3
c002831c:	00900793          	li	a5,9
c0028320:	00868693          	addi	a3,a3,8
c0028324:	00112e23          	sw	ra,28(sp)
c0028328:	01512223          	sw	s5,4(sp)
c002832c:	02f6c6b3          	div	a3,a3,a5
c0028330:	00050913          	mv	s2,a0
c0028334:	00058413          	mv	s0,a1
c0028338:	00060a13          	mv	s4,a2
c002833c:	00070493          	mv	s1,a4
c0028340:	0d37d863          	bge	a5,s3,c0028410 <__s2b+0x110>
c0028344:	00100793          	li	a5,1
c0028348:	00000593          	li	a1,0
c002834c:	00179793          	slli	a5,a5,0x1
c0028350:	00158593          	addi	a1,a1,1
c0028354:	fed7cce3          	blt	a5,a3,c002834c <__s2b+0x4c>
c0028358:	00090513          	mv	a0,s2
c002835c:	d8dff0ef          	jal	ra,c00280e8 <_Balloc>
c0028360:	00050593          	mv	a1,a0
c0028364:	0a050a63          	beqz	a0,c0028418 <__s2b+0x118>
c0028368:	00100793          	li	a5,1
c002836c:	00f52823          	sw	a5,16(a0)
c0028370:	00952a23          	sw	s1,20(a0)
c0028374:	00900793          	li	a5,9
c0028378:	0947d663          	bge	a5,s4,c0028404 <__s2b+0x104>
c002837c:	00940a93          	addi	s5,s0,9
c0028380:	000a8493          	mv	s1,s5
c0028384:	01440433          	add	s0,s0,s4
c0028388:	0004c683          	lbu	a3,0(s1)
c002838c:	00a00613          	li	a2,10
c0028390:	00090513          	mv	a0,s2
c0028394:	fd068693          	addi	a3,a3,-48
c0028398:	e1dff0ef          	jal	ra,c00281b4 <__multadd>
c002839c:	00148493          	addi	s1,s1,1
c00283a0:	00050593          	mv	a1,a0
c00283a4:	fe8492e3          	bne	s1,s0,c0028388 <__s2b+0x88>
c00283a8:	ff8a0413          	addi	s0,s4,-8
c00283ac:	008a8433          	add	s0,s5,s0
c00283b0:	033a5663          	bge	s4,s3,c00283dc <__s2b+0xdc>
c00283b4:	414989b3          	sub	s3,s3,s4
c00283b8:	013409b3          	add	s3,s0,s3
c00283bc:	00044683          	lbu	a3,0(s0)
c00283c0:	00a00613          	li	a2,10
c00283c4:	00090513          	mv	a0,s2
c00283c8:	fd068693          	addi	a3,a3,-48
c00283cc:	de9ff0ef          	jal	ra,c00281b4 <__multadd>
c00283d0:	00140413          	addi	s0,s0,1
c00283d4:	00050593          	mv	a1,a0
c00283d8:	fe8992e3          	bne	s3,s0,c00283bc <__s2b+0xbc>
c00283dc:	01c12083          	lw	ra,28(sp)
c00283e0:	01812403          	lw	s0,24(sp)
c00283e4:	01412483          	lw	s1,20(sp)
c00283e8:	01012903          	lw	s2,16(sp)
c00283ec:	00c12983          	lw	s3,12(sp)
c00283f0:	00812a03          	lw	s4,8(sp)
c00283f4:	00412a83          	lw	s5,4(sp)
c00283f8:	00058513          	mv	a0,a1
c00283fc:	02010113          	addi	sp,sp,32
c0028400:	00008067          	ret
c0028404:	00a40413          	addi	s0,s0,10
c0028408:	00900a13          	li	s4,9
c002840c:	fa5ff06f          	j	c00283b0 <__s2b+0xb0>
c0028410:	00000593          	li	a1,0
c0028414:	f45ff06f          	j	c0028358 <__s2b+0x58>
c0028418:	c80026b7          	lui	a3,0xc8002
c002841c:	c8002537          	lui	a0,0xc8002
c0028420:	73868693          	addi	a3,a3,1848 # c8002738 <_end+0xfff7deb8>
c0028424:	00000613          	li	a2,0
c0028428:	0ce00593          	li	a1,206
c002842c:	7ac50513          	addi	a0,a0,1964 # c80027ac <_end+0xfff7df2c>
c0028430:	02c040ef          	jal	ra,c002c45c <__assert_func>

c0028434 <__hi0bits>:
c0028434:	ffff0737          	lui	a4,0xffff0
c0028438:	00e57733          	and	a4,a0,a4
c002843c:	00050793          	mv	a5,a0
c0028440:	00000513          	li	a0,0
c0028444:	00071663          	bnez	a4,c0028450 <__hi0bits+0x1c>
c0028448:	01079793          	slli	a5,a5,0x10
c002844c:	01000513          	li	a0,16
c0028450:	ff000737          	lui	a4,0xff000
c0028454:	00e7f733          	and	a4,a5,a4
c0028458:	00071663          	bnez	a4,c0028464 <__hi0bits+0x30>
c002845c:	00850513          	addi	a0,a0,8
c0028460:	00879793          	slli	a5,a5,0x8
c0028464:	f0000737          	lui	a4,0xf0000
c0028468:	00e7f733          	and	a4,a5,a4
c002846c:	00071663          	bnez	a4,c0028478 <__hi0bits+0x44>
c0028470:	00450513          	addi	a0,a0,4
c0028474:	00479793          	slli	a5,a5,0x4
c0028478:	c0000737          	lui	a4,0xc0000
c002847c:	00e7f733          	and	a4,a5,a4
c0028480:	00071663          	bnez	a4,c002848c <__hi0bits+0x58>
c0028484:	00250513          	addi	a0,a0,2
c0028488:	00279793          	slli	a5,a5,0x2
c002848c:	0007ca63          	bltz	a5,c00284a0 <__hi0bits+0x6c>
c0028490:	40000737          	lui	a4,0x40000
c0028494:	00e7f7b3          	and	a5,a5,a4
c0028498:	00150513          	addi	a0,a0,1
c002849c:	00078463          	beqz	a5,c00284a4 <__hi0bits+0x70>
c00284a0:	00008067          	ret
c00284a4:	02000513          	li	a0,32
c00284a8:	00008067          	ret

c00284ac <__lo0bits>:
c00284ac:	00052783          	lw	a5,0(a0)
c00284b0:	00050713          	mv	a4,a0
c00284b4:	0077f693          	andi	a3,a5,7
c00284b8:	02068463          	beqz	a3,c00284e0 <__lo0bits+0x34>
c00284bc:	0017f693          	andi	a3,a5,1
c00284c0:	00000513          	li	a0,0
c00284c4:	04069e63          	bnez	a3,c0028520 <__lo0bits+0x74>
c00284c8:	0027f693          	andi	a3,a5,2
c00284cc:	0a068863          	beqz	a3,c002857c <__lo0bits+0xd0>
c00284d0:	0017d793          	srli	a5,a5,0x1
c00284d4:	00f72023          	sw	a5,0(a4) # 40000000 <_DMEM_LENGTH+0x3f800000>
c00284d8:	00100513          	li	a0,1
c00284dc:	00008067          	ret
c00284e0:	01079693          	slli	a3,a5,0x10
c00284e4:	0106d693          	srli	a3,a3,0x10
c00284e8:	00000513          	li	a0,0
c00284ec:	06068e63          	beqz	a3,c0028568 <__lo0bits+0xbc>
c00284f0:	0ff7f693          	andi	a3,a5,255
c00284f4:	06068063          	beqz	a3,c0028554 <__lo0bits+0xa8>
c00284f8:	00f7f693          	andi	a3,a5,15
c00284fc:	04068263          	beqz	a3,c0028540 <__lo0bits+0x94>
c0028500:	0037f693          	andi	a3,a5,3
c0028504:	02068463          	beqz	a3,c002852c <__lo0bits+0x80>
c0028508:	0017f693          	andi	a3,a5,1
c002850c:	00069c63          	bnez	a3,c0028524 <__lo0bits+0x78>
c0028510:	0017d793          	srli	a5,a5,0x1
c0028514:	00150513          	addi	a0,a0,1
c0028518:	00079663          	bnez	a5,c0028524 <__lo0bits+0x78>
c002851c:	02000513          	li	a0,32
c0028520:	00008067          	ret
c0028524:	00f72023          	sw	a5,0(a4)
c0028528:	00008067          	ret
c002852c:	0027d793          	srli	a5,a5,0x2
c0028530:	0017f693          	andi	a3,a5,1
c0028534:	00250513          	addi	a0,a0,2
c0028538:	fe0696e3          	bnez	a3,c0028524 <__lo0bits+0x78>
c002853c:	fd5ff06f          	j	c0028510 <__lo0bits+0x64>
c0028540:	0047d793          	srli	a5,a5,0x4
c0028544:	0037f693          	andi	a3,a5,3
c0028548:	00450513          	addi	a0,a0,4
c002854c:	fa069ee3          	bnez	a3,c0028508 <__lo0bits+0x5c>
c0028550:	fddff06f          	j	c002852c <__lo0bits+0x80>
c0028554:	0087d793          	srli	a5,a5,0x8
c0028558:	00f7f693          	andi	a3,a5,15
c002855c:	00850513          	addi	a0,a0,8
c0028560:	fa0690e3          	bnez	a3,c0028500 <__lo0bits+0x54>
c0028564:	fddff06f          	j	c0028540 <__lo0bits+0x94>
c0028568:	0107d793          	srli	a5,a5,0x10
c002856c:	0ff7f693          	andi	a3,a5,255
c0028570:	01000513          	li	a0,16
c0028574:	f80692e3          	bnez	a3,c00284f8 <__lo0bits+0x4c>
c0028578:	fddff06f          	j	c0028554 <__lo0bits+0xa8>
c002857c:	0027d793          	srli	a5,a5,0x2
c0028580:	00f72023          	sw	a5,0(a4)
c0028584:	00200513          	li	a0,2
c0028588:	00008067          	ret

c002858c <__i2b>:
c002858c:	04c52783          	lw	a5,76(a0)
c0028590:	ff010113          	addi	sp,sp,-16
c0028594:	00812423          	sw	s0,8(sp)
c0028598:	00912223          	sw	s1,4(sp)
c002859c:	00112623          	sw	ra,12(sp)
c00285a0:	00050413          	mv	s0,a0
c00285a4:	00058493          	mv	s1,a1
c00285a8:	02078c63          	beqz	a5,c00285e0 <__i2b+0x54>
c00285ac:	0047a503          	lw	a0,4(a5)
c00285b0:	06050263          	beqz	a0,c0028614 <__i2b+0x88>
c00285b4:	00052703          	lw	a4,0(a0)
c00285b8:	00e7a223          	sw	a4,4(a5)
c00285bc:	00c12083          	lw	ra,12(sp)
c00285c0:	00812403          	lw	s0,8(sp)
c00285c4:	00100793          	li	a5,1
c00285c8:	00952a23          	sw	s1,20(a0)
c00285cc:	00052623          	sw	zero,12(a0)
c00285d0:	00f52823          	sw	a5,16(a0)
c00285d4:	00412483          	lw	s1,4(sp)
c00285d8:	01010113          	addi	sp,sp,16
c00285dc:	00008067          	ret
c00285e0:	02100613          	li	a2,33
c00285e4:	00400593          	li	a1,4
c00285e8:	6e1030ef          	jal	ra,c002c4c8 <_calloc_r>
c00285ec:	04a42623          	sw	a0,76(s0)
c00285f0:	00050793          	mv	a5,a0
c00285f4:	fa051ce3          	bnez	a0,c00285ac <__i2b+0x20>
c00285f8:	c80026b7          	lui	a3,0xc8002
c00285fc:	c8002537          	lui	a0,0xc8002
c0028600:	73868693          	addi	a3,a3,1848 # c8002738 <_end+0xfff7deb8>
c0028604:	00000613          	li	a2,0
c0028608:	14000593          	li	a1,320
c002860c:	7ac50513          	addi	a0,a0,1964 # c80027ac <_end+0xfff7df2c>
c0028610:	64d030ef          	jal	ra,c002c45c <__assert_func>
c0028614:	01c00613          	li	a2,28
c0028618:	00100593          	li	a1,1
c002861c:	00040513          	mv	a0,s0
c0028620:	6a9030ef          	jal	ra,c002c4c8 <_calloc_r>
c0028624:	fc050ae3          	beqz	a0,c00285f8 <__i2b+0x6c>
c0028628:	00100793          	li	a5,1
c002862c:	00f52223          	sw	a5,4(a0)
c0028630:	00200793          	li	a5,2
c0028634:	00f52423          	sw	a5,8(a0)
c0028638:	f85ff06f          	j	c00285bc <__i2b+0x30>

c002863c <__multiply>:
c002863c:	fe010113          	addi	sp,sp,-32
c0028640:	01212823          	sw	s2,16(sp)
c0028644:	01312623          	sw	s3,12(sp)
c0028648:	0105a903          	lw	s2,16(a1)
c002864c:	01062983          	lw	s3,16(a2)
c0028650:	00912a23          	sw	s1,20(sp)
c0028654:	01412423          	sw	s4,8(sp)
c0028658:	00112e23          	sw	ra,28(sp)
c002865c:	00812c23          	sw	s0,24(sp)
c0028660:	00058a13          	mv	s4,a1
c0028664:	00060493          	mv	s1,a2
c0028668:	01394c63          	blt	s2,s3,c0028680 <__multiply+0x44>
c002866c:	00098713          	mv	a4,s3
c0028670:	00058493          	mv	s1,a1
c0028674:	00090993          	mv	s3,s2
c0028678:	00060a13          	mv	s4,a2
c002867c:	00070913          	mv	s2,a4
c0028680:	0084a783          	lw	a5,8(s1)
c0028684:	0044a583          	lw	a1,4(s1)
c0028688:	01298433          	add	s0,s3,s2
c002868c:	0087a7b3          	slt	a5,a5,s0
c0028690:	00f585b3          	add	a1,a1,a5
c0028694:	a55ff0ef          	jal	ra,c00280e8 <_Balloc>
c0028698:	1a050e63          	beqz	a0,c0028854 <__multiply+0x218>
c002869c:	01450313          	addi	t1,a0,20
c00286a0:	00241893          	slli	a7,s0,0x2
c00286a4:	011308b3          	add	a7,t1,a7
c00286a8:	00030793          	mv	a5,t1
c00286ac:	01137863          	bgeu	t1,a7,c00286bc <__multiply+0x80>
c00286b0:	0007a023          	sw	zero,0(a5)
c00286b4:	00478793          	addi	a5,a5,4
c00286b8:	ff17ece3          	bltu	a5,a7,c00286b0 <__multiply+0x74>
c00286bc:	014a0813          	addi	a6,s4,20
c00286c0:	00291e13          	slli	t3,s2,0x2
c00286c4:	01448e93          	addi	t4,s1,20
c00286c8:	00299593          	slli	a1,s3,0x2
c00286cc:	01c80e33          	add	t3,a6,t3
c00286d0:	00be85b3          	add	a1,t4,a1
c00286d4:	13c87663          	bgeu	a6,t3,c0028800 <__multiply+0x1c4>
c00286d8:	01548793          	addi	a5,s1,21
c00286dc:	00400f13          	li	t5,4
c00286e0:	16f5f063          	bgeu	a1,a5,c0028840 <__multiply+0x204>
c00286e4:	00010637          	lui	a2,0x10
c00286e8:	fff60613          	addi	a2,a2,-1 # ffff <_STACK_SIZE+0xefff>
c00286ec:	0180006f          	j	c0028704 <__multiply+0xc8>
c00286f0:	010fdf93          	srli	t6,t6,0x10
c00286f4:	080f9863          	bnez	t6,c0028784 <__multiply+0x148>
c00286f8:	00480813          	addi	a6,a6,4
c00286fc:	00430313          	addi	t1,t1,4
c0028700:	11c87063          	bgeu	a6,t3,c0028800 <__multiply+0x1c4>
c0028704:	00082f83          	lw	t6,0(a6)
c0028708:	00cff4b3          	and	s1,t6,a2
c002870c:	fe0482e3          	beqz	s1,c00286f0 <__multiply+0xb4>
c0028710:	00030393          	mv	t2,t1
c0028714:	000e8293          	mv	t0,t4
c0028718:	00000913          	li	s2,0
c002871c:	0002a703          	lw	a4,0(t0) # c001dd3c <memset+0xb4>
c0028720:	0003af83          	lw	t6,0(t2)
c0028724:	00438393          	addi	t2,t2,4
c0028728:	00c776b3          	and	a3,a4,a2
c002872c:	029686b3          	mul	a3,a3,s1
c0028730:	01075793          	srli	a5,a4,0x10
c0028734:	00cff733          	and	a4,t6,a2
c0028738:	010fdf93          	srli	t6,t6,0x10
c002873c:	00428293          	addi	t0,t0,4
c0028740:	029787b3          	mul	a5,a5,s1
c0028744:	00e686b3          	add	a3,a3,a4
c0028748:	012686b3          	add	a3,a3,s2
c002874c:	0106d713          	srli	a4,a3,0x10
c0028750:	00c6f6b3          	and	a3,a3,a2
c0028754:	01f787b3          	add	a5,a5,t6
c0028758:	00e787b3          	add	a5,a5,a4
c002875c:	01079713          	slli	a4,a5,0x10
c0028760:	00d766b3          	or	a3,a4,a3
c0028764:	fed3ae23          	sw	a3,-4(t2)
c0028768:	0107d913          	srli	s2,a5,0x10
c002876c:	fab2e8e3          	bltu	t0,a1,c002871c <__multiply+0xe0>
c0028770:	01e307b3          	add	a5,t1,t5
c0028774:	0127a023          	sw	s2,0(a5)
c0028778:	00082f83          	lw	t6,0(a6)
c002877c:	010fdf93          	srli	t6,t6,0x10
c0028780:	f60f8ce3          	beqz	t6,c00286f8 <__multiply+0xbc>
c0028784:	00032703          	lw	a4,0(t1)
c0028788:	00030293          	mv	t0,t1
c002878c:	000e8693          	mv	a3,t4
c0028790:	00070493          	mv	s1,a4
c0028794:	00000393          	li	t2,0
c0028798:	0006a783          	lw	a5,0(a3)
c002879c:	0104d993          	srli	s3,s1,0x10
c00287a0:	00c77733          	and	a4,a4,a2
c00287a4:	00c7f7b3          	and	a5,a5,a2
c00287a8:	03f787b3          	mul	a5,a5,t6
c00287ac:	0042a483          	lw	s1,4(t0)
c00287b0:	00428293          	addi	t0,t0,4
c00287b4:	00468693          	addi	a3,a3,4
c00287b8:	00c4f933          	and	s2,s1,a2
c00287bc:	013787b3          	add	a5,a5,s3
c00287c0:	007787b3          	add	a5,a5,t2
c00287c4:	01079393          	slli	t2,a5,0x10
c00287c8:	00e3e733          	or	a4,t2,a4
c00287cc:	fee2ae23          	sw	a4,-4(t0)
c00287d0:	ffe6d703          	lhu	a4,-2(a3)
c00287d4:	0107d793          	srli	a5,a5,0x10
c00287d8:	03f70733          	mul	a4,a4,t6
c00287dc:	01270733          	add	a4,a4,s2
c00287e0:	00f70733          	add	a4,a4,a5
c00287e4:	01075393          	srli	t2,a4,0x10
c00287e8:	fab6e8e3          	bltu	a3,a1,c0028798 <__multiply+0x15c>
c00287ec:	01e307b3          	add	a5,t1,t5
c00287f0:	00e7a023          	sw	a4,0(a5)
c00287f4:	00480813          	addi	a6,a6,4
c00287f8:	00430313          	addi	t1,t1,4
c00287fc:	f1c864e3          	bltu	a6,t3,c0028704 <__multiply+0xc8>
c0028800:	00804863          	bgtz	s0,c0028810 <__multiply+0x1d4>
c0028804:	0180006f          	j	c002881c <__multiply+0x1e0>
c0028808:	fff40413          	addi	s0,s0,-1
c002880c:	00040863          	beqz	s0,c002881c <__multiply+0x1e0>
c0028810:	ffc8a783          	lw	a5,-4(a7)
c0028814:	ffc88893          	addi	a7,a7,-4
c0028818:	fe0788e3          	beqz	a5,c0028808 <__multiply+0x1cc>
c002881c:	01c12083          	lw	ra,28(sp)
c0028820:	00852823          	sw	s0,16(a0)
c0028824:	01812403          	lw	s0,24(sp)
c0028828:	01412483          	lw	s1,20(sp)
c002882c:	01012903          	lw	s2,16(sp)
c0028830:	00c12983          	lw	s3,12(sp)
c0028834:	00812a03          	lw	s4,8(sp)
c0028838:	02010113          	addi	sp,sp,32
c002883c:	00008067          	ret
c0028840:	40958f33          	sub	t5,a1,s1
c0028844:	febf0f13          	addi	t5,t5,-21
c0028848:	ffcf7f13          	andi	t5,t5,-4
c002884c:	004f0f13          	addi	t5,t5,4
c0028850:	e95ff06f          	j	c00286e4 <__multiply+0xa8>
c0028854:	c80026b7          	lui	a3,0xc8002
c0028858:	c8002537          	lui	a0,0xc8002
c002885c:	73868693          	addi	a3,a3,1848 # c8002738 <_end+0xfff7deb8>
c0028860:	00000613          	li	a2,0
c0028864:	15d00593          	li	a1,349
c0028868:	7ac50513          	addi	a0,a0,1964 # c80027ac <_end+0xfff7df2c>
c002886c:	3f1030ef          	jal	ra,c002c45c <__assert_func>

c0028870 <__pow5mult>:
c0028870:	fe010113          	addi	sp,sp,-32
c0028874:	00812c23          	sw	s0,24(sp)
c0028878:	01212823          	sw	s2,16(sp)
c002887c:	01312623          	sw	s3,12(sp)
c0028880:	00112e23          	sw	ra,28(sp)
c0028884:	00912a23          	sw	s1,20(sp)
c0028888:	00367793          	andi	a5,a2,3
c002888c:	00060413          	mv	s0,a2
c0028890:	00050993          	mv	s3,a0
c0028894:	00058913          	mv	s2,a1
c0028898:	0a079e63          	bnez	a5,c0028954 <__pow5mult+0xe4>
c002889c:	40245413          	srai	s0,s0,0x2
c00288a0:	06040663          	beqz	s0,c002890c <__pow5mult+0x9c>
c00288a4:	0489a483          	lw	s1,72(s3)
c00288a8:	0c048a63          	beqz	s1,c002897c <__pow5mult+0x10c>
c00288ac:	00147793          	andi	a5,s0,1
c00288b0:	02079063          	bnez	a5,c00288d0 <__pow5mult+0x60>
c00288b4:	40145413          	srai	s0,s0,0x1
c00288b8:	04040a63          	beqz	s0,c002890c <__pow5mult+0x9c>
c00288bc:	0004a503          	lw	a0,0(s1)
c00288c0:	06050663          	beqz	a0,c002892c <__pow5mult+0xbc>
c00288c4:	00050493          	mv	s1,a0
c00288c8:	00147793          	andi	a5,s0,1
c00288cc:	fe0784e3          	beqz	a5,c00288b4 <__pow5mult+0x44>
c00288d0:	00048613          	mv	a2,s1
c00288d4:	00090593          	mv	a1,s2
c00288d8:	00098513          	mv	a0,s3
c00288dc:	d61ff0ef          	jal	ra,c002863c <__multiply>
c00288e0:	06090663          	beqz	s2,c002894c <__pow5mult+0xdc>
c00288e4:	00492703          	lw	a4,4(s2)
c00288e8:	04c9a783          	lw	a5,76(s3)
c00288ec:	40145413          	srai	s0,s0,0x1
c00288f0:	00271713          	slli	a4,a4,0x2
c00288f4:	00e787b3          	add	a5,a5,a4
c00288f8:	0007a703          	lw	a4,0(a5)
c00288fc:	00e92023          	sw	a4,0(s2)
c0028900:	0127a023          	sw	s2,0(a5)
c0028904:	00050913          	mv	s2,a0
c0028908:	fa041ae3          	bnez	s0,c00288bc <__pow5mult+0x4c>
c002890c:	01c12083          	lw	ra,28(sp)
c0028910:	01812403          	lw	s0,24(sp)
c0028914:	01412483          	lw	s1,20(sp)
c0028918:	00c12983          	lw	s3,12(sp)
c002891c:	00090513          	mv	a0,s2
c0028920:	01012903          	lw	s2,16(sp)
c0028924:	02010113          	addi	sp,sp,32
c0028928:	00008067          	ret
c002892c:	00048613          	mv	a2,s1
c0028930:	00048593          	mv	a1,s1
c0028934:	00098513          	mv	a0,s3
c0028938:	d05ff0ef          	jal	ra,c002863c <__multiply>
c002893c:	00a4a023          	sw	a0,0(s1)
c0028940:	00052023          	sw	zero,0(a0)
c0028944:	00050493          	mv	s1,a0
c0028948:	f81ff06f          	j	c00288c8 <__pow5mult+0x58>
c002894c:	00050913          	mv	s2,a0
c0028950:	f65ff06f          	j	c00288b4 <__pow5mult+0x44>
c0028954:	fff78793          	addi	a5,a5,-1
c0028958:	c8002737          	lui	a4,0xc8002
c002895c:	fd870713          	addi	a4,a4,-40 # c8001fd8 <_end+0xfff7d758>
c0028960:	00279793          	slli	a5,a5,0x2
c0028964:	00f707b3          	add	a5,a4,a5
c0028968:	0007a603          	lw	a2,0(a5)
c002896c:	00000693          	li	a3,0
c0028970:	845ff0ef          	jal	ra,c00281b4 <__multadd>
c0028974:	00050913          	mv	s2,a0
c0028978:	f25ff06f          	j	c002889c <__pow5mult+0x2c>
c002897c:	00100593          	li	a1,1
c0028980:	00098513          	mv	a0,s3
c0028984:	f64ff0ef          	jal	ra,c00280e8 <_Balloc>
c0028988:	00050493          	mv	s1,a0
c002898c:	02050063          	beqz	a0,c00289ac <__pow5mult+0x13c>
c0028990:	27100793          	li	a5,625
c0028994:	00f52a23          	sw	a5,20(a0)
c0028998:	00100793          	li	a5,1
c002899c:	00f52823          	sw	a5,16(a0)
c00289a0:	04a9a423          	sw	a0,72(s3)
c00289a4:	00052023          	sw	zero,0(a0)
c00289a8:	f05ff06f          	j	c00288ac <__pow5mult+0x3c>
c00289ac:	c80026b7          	lui	a3,0xc8002
c00289b0:	c8002537          	lui	a0,0xc8002
c00289b4:	73868693          	addi	a3,a3,1848 # c8002738 <_end+0xfff7deb8>
c00289b8:	00000613          	li	a2,0
c00289bc:	14000593          	li	a1,320
c00289c0:	7ac50513          	addi	a0,a0,1964 # c80027ac <_end+0xfff7df2c>
c00289c4:	299030ef          	jal	ra,c002c45c <__assert_func>

c00289c8 <__lshift>:
c00289c8:	fe010113          	addi	sp,sp,-32
c00289cc:	01412423          	sw	s4,8(sp)
c00289d0:	0105aa03          	lw	s4,16(a1)
c00289d4:	0085a783          	lw	a5,8(a1)
c00289d8:	01312623          	sw	s3,12(sp)
c00289dc:	40565993          	srai	s3,a2,0x5
c00289e0:	01498a33          	add	s4,s3,s4
c00289e4:	00812c23          	sw	s0,24(sp)
c00289e8:	00912a23          	sw	s1,20(sp)
c00289ec:	01212823          	sw	s2,16(sp)
c00289f0:	01512223          	sw	s5,4(sp)
c00289f4:	00112e23          	sw	ra,28(sp)
c00289f8:	001a0913          	addi	s2,s4,1
c00289fc:	00058493          	mv	s1,a1
c0028a00:	00060413          	mv	s0,a2
c0028a04:	0045a583          	lw	a1,4(a1)
c0028a08:	00050a93          	mv	s5,a0
c0028a0c:	0127d863          	bge	a5,s2,c0028a1c <__lshift+0x54>
c0028a10:	00179793          	slli	a5,a5,0x1
c0028a14:	00158593          	addi	a1,a1,1
c0028a18:	ff27cce3          	blt	a5,s2,c0028a10 <__lshift+0x48>
c0028a1c:	000a8513          	mv	a0,s5
c0028a20:	ec8ff0ef          	jal	ra,c00280e8 <_Balloc>
c0028a24:	10050c63          	beqz	a0,c0028b3c <__lshift+0x174>
c0028a28:	01450813          	addi	a6,a0,20
c0028a2c:	03305463          	blez	s3,c0028a54 <__lshift+0x8c>
c0028a30:	00598993          	addi	s3,s3,5
c0028a34:	00299993          	slli	s3,s3,0x2
c0028a38:	01350733          	add	a4,a0,s3
c0028a3c:	00080793          	mv	a5,a6
c0028a40:	00478793          	addi	a5,a5,4
c0028a44:	fe07ae23          	sw	zero,-4(a5)
c0028a48:	fee79ce3          	bne	a5,a4,c0028a40 <__lshift+0x78>
c0028a4c:	fec98993          	addi	s3,s3,-20
c0028a50:	01380833          	add	a6,a6,s3
c0028a54:	0104a603          	lw	a2,16(s1)
c0028a58:	01448793          	addi	a5,s1,20
c0028a5c:	01f47313          	andi	t1,s0,31
c0028a60:	00261613          	slli	a2,a2,0x2
c0028a64:	00c78633          	add	a2,a5,a2
c0028a68:	0a030463          	beqz	t1,c0028b10 <__lshift+0x148>
c0028a6c:	02000593          	li	a1,32
c0028a70:	406585b3          	sub	a1,a1,t1
c0028a74:	00080893          	mv	a7,a6
c0028a78:	00000693          	li	a3,0
c0028a7c:	0007a703          	lw	a4,0(a5)
c0028a80:	00488893          	addi	a7,a7,4
c0028a84:	00478793          	addi	a5,a5,4
c0028a88:	00671733          	sll	a4,a4,t1
c0028a8c:	00d76733          	or	a4,a4,a3
c0028a90:	fee8ae23          	sw	a4,-4(a7)
c0028a94:	ffc7a703          	lw	a4,-4(a5)
c0028a98:	00b756b3          	srl	a3,a4,a1
c0028a9c:	fec7e0e3          	bltu	a5,a2,c0028a7c <__lshift+0xb4>
c0028aa0:	01548713          	addi	a4,s1,21
c0028aa4:	00400793          	li	a5,4
c0028aa8:	00e66a63          	bltu	a2,a4,c0028abc <__lshift+0xf4>
c0028aac:	409607b3          	sub	a5,a2,s1
c0028ab0:	feb78793          	addi	a5,a5,-21
c0028ab4:	ffc7f793          	andi	a5,a5,-4
c0028ab8:	00478793          	addi	a5,a5,4
c0028abc:	00f80833          	add	a6,a6,a5
c0028ac0:	00d82023          	sw	a3,0(a6)
c0028ac4:	00068463          	beqz	a3,c0028acc <__lshift+0x104>
c0028ac8:	00090a13          	mv	s4,s2
c0028acc:	0044a703          	lw	a4,4(s1)
c0028ad0:	04caa783          	lw	a5,76(s5)
c0028ad4:	01c12083          	lw	ra,28(sp)
c0028ad8:	00271713          	slli	a4,a4,0x2
c0028adc:	00e787b3          	add	a5,a5,a4
c0028ae0:	0007a703          	lw	a4,0(a5)
c0028ae4:	01452823          	sw	s4,16(a0)
c0028ae8:	01812403          	lw	s0,24(sp)
c0028aec:	00e4a023          	sw	a4,0(s1)
c0028af0:	0097a023          	sw	s1,0(a5)
c0028af4:	01012903          	lw	s2,16(sp)
c0028af8:	01412483          	lw	s1,20(sp)
c0028afc:	00c12983          	lw	s3,12(sp)
c0028b00:	00812a03          	lw	s4,8(sp)
c0028b04:	00412a83          	lw	s5,4(sp)
c0028b08:	02010113          	addi	sp,sp,32
c0028b0c:	00008067          	ret
c0028b10:	0007a703          	lw	a4,0(a5)
c0028b14:	00478793          	addi	a5,a5,4
c0028b18:	00480813          	addi	a6,a6,4
c0028b1c:	fee82e23          	sw	a4,-4(a6)
c0028b20:	fac7f6e3          	bgeu	a5,a2,c0028acc <__lshift+0x104>
c0028b24:	0007a703          	lw	a4,0(a5)
c0028b28:	00478793          	addi	a5,a5,4
c0028b2c:	00480813          	addi	a6,a6,4
c0028b30:	fee82e23          	sw	a4,-4(a6)
c0028b34:	fcc7eee3          	bltu	a5,a2,c0028b10 <__lshift+0x148>
c0028b38:	f95ff06f          	j	c0028acc <__lshift+0x104>
c0028b3c:	c80026b7          	lui	a3,0xc8002
c0028b40:	c8002537          	lui	a0,0xc8002
c0028b44:	73868693          	addi	a3,a3,1848 # c8002738 <_end+0xfff7deb8>
c0028b48:	00000613          	li	a2,0
c0028b4c:	1d900593          	li	a1,473
c0028b50:	7ac50513          	addi	a0,a0,1964 # c80027ac <_end+0xfff7df2c>
c0028b54:	109030ef          	jal	ra,c002c45c <__assert_func>

c0028b58 <__mcmp>:
c0028b58:	01052703          	lw	a4,16(a0)
c0028b5c:	0105a783          	lw	a5,16(a1)
c0028b60:	00050813          	mv	a6,a0
c0028b64:	40f70533          	sub	a0,a4,a5
c0028b68:	04f71263          	bne	a4,a5,c0028bac <__mcmp+0x54>
c0028b6c:	00279793          	slli	a5,a5,0x2
c0028b70:	01480813          	addi	a6,a6,20
c0028b74:	01458593          	addi	a1,a1,20
c0028b78:	00f80733          	add	a4,a6,a5
c0028b7c:	00f587b3          	add	a5,a1,a5
c0028b80:	0080006f          	j	c0028b88 <__mcmp+0x30>
c0028b84:	02e87463          	bgeu	a6,a4,c0028bac <__mcmp+0x54>
c0028b88:	ffc72683          	lw	a3,-4(a4)
c0028b8c:	ffc7a603          	lw	a2,-4(a5)
c0028b90:	ffc70713          	addi	a4,a4,-4
c0028b94:	ffc78793          	addi	a5,a5,-4
c0028b98:	fec686e3          	beq	a3,a2,c0028b84 <__mcmp+0x2c>
c0028b9c:	00c6b6b3          	sltu	a3,a3,a2
c0028ba0:	40d00533          	neg	a0,a3
c0028ba4:	00156513          	ori	a0,a0,1
c0028ba8:	00008067          	ret
c0028bac:	00008067          	ret

c0028bb0 <__mdiff>:
c0028bb0:	0105a783          	lw	a5,16(a1)
c0028bb4:	01062703          	lw	a4,16(a2)
c0028bb8:	ff010113          	addi	sp,sp,-16
c0028bbc:	00812423          	sw	s0,8(sp)
c0028bc0:	00912223          	sw	s1,4(sp)
c0028bc4:	01212023          	sw	s2,0(sp)
c0028bc8:	00112623          	sw	ra,12(sp)
c0028bcc:	00058493          	mv	s1,a1
c0028bd0:	00060413          	mv	s0,a2
c0028bd4:	40e78933          	sub	s2,a5,a4
c0028bd8:	1ae79463          	bne	a5,a4,c0028d80 <__mdiff+0x1d0>
c0028bdc:	00271693          	slli	a3,a4,0x2
c0028be0:	01458593          	addi	a1,a1,20
c0028be4:	01460713          	addi	a4,a2,20
c0028be8:	00d587b3          	add	a5,a1,a3
c0028bec:	00d70733          	add	a4,a4,a3
c0028bf0:	0080006f          	j	c0028bf8 <__mdiff+0x48>
c0028bf4:	18f5fc63          	bgeu	a1,a5,c0028d8c <__mdiff+0x1dc>
c0028bf8:	ffc7a603          	lw	a2,-4(a5)
c0028bfc:	ffc72683          	lw	a3,-4(a4)
c0028c00:	ffc78793          	addi	a5,a5,-4
c0028c04:	ffc70713          	addi	a4,a4,-4
c0028c08:	fed606e3          	beq	a2,a3,c0028bf4 <__mdiff+0x44>
c0028c0c:	16d66063          	bltu	a2,a3,c0028d6c <__mdiff+0x1bc>
c0028c10:	0044a583          	lw	a1,4(s1)
c0028c14:	cd4ff0ef          	jal	ra,c00280e8 <_Balloc>
c0028c18:	1a050263          	beqz	a0,c0028dbc <__mdiff+0x20c>
c0028c1c:	0104ae03          	lw	t3,16(s1)
c0028c20:	01042283          	lw	t0,16(s0)
c0028c24:	01448493          	addi	s1,s1,20
c0028c28:	002e1e93          	slli	t4,t3,0x2
c0028c2c:	01440813          	addi	a6,s0,20
c0028c30:	00229293          	slli	t0,t0,0x2
c0028c34:	01450f93          	addi	t6,a0,20
c0028c38:	000108b7          	lui	a7,0x10
c0028c3c:	01252623          	sw	s2,12(a0)
c0028c40:	01d48eb3          	add	t4,s1,t4
c0028c44:	005802b3          	add	t0,a6,t0
c0028c48:	000f8f13          	mv	t5,t6
c0028c4c:	00048313          	mv	t1,s1
c0028c50:	00000793          	li	a5,0
c0028c54:	fff88893          	addi	a7,a7,-1 # ffff <_STACK_SIZE+0xefff>
c0028c58:	00032703          	lw	a4,0(t1)
c0028c5c:	00082583          	lw	a1,0(a6)
c0028c60:	004f0f13          	addi	t5,t5,4
c0028c64:	011776b3          	and	a3,a4,a7
c0028c68:	00f686b3          	add	a3,a3,a5
c0028c6c:	0115f7b3          	and	a5,a1,a7
c0028c70:	40f686b3          	sub	a3,a3,a5
c0028c74:	0105d593          	srli	a1,a1,0x10
c0028c78:	01075793          	srli	a5,a4,0x10
c0028c7c:	40b787b3          	sub	a5,a5,a1
c0028c80:	4106d713          	srai	a4,a3,0x10
c0028c84:	00e787b3          	add	a5,a5,a4
c0028c88:	01079713          	slli	a4,a5,0x10
c0028c8c:	0116f6b3          	and	a3,a3,a7
c0028c90:	00d766b3          	or	a3,a4,a3
c0028c94:	00480813          	addi	a6,a6,4
c0028c98:	fedf2e23          	sw	a3,-4(t5)
c0028c9c:	00430313          	addi	t1,t1,4
c0028ca0:	4107d793          	srai	a5,a5,0x10
c0028ca4:	fa586ae3          	bltu	a6,t0,c0028c58 <__mdiff+0xa8>
c0028ca8:	408285b3          	sub	a1,t0,s0
c0028cac:	feb58593          	addi	a1,a1,-21
c0028cb0:	01540413          	addi	s0,s0,21
c0028cb4:	0025d593          	srli	a1,a1,0x2
c0028cb8:	00000713          	li	a4,0
c0028cbc:	0082e463          	bltu	t0,s0,c0028cc4 <__mdiff+0x114>
c0028cc0:	00259713          	slli	a4,a1,0x2
c0028cc4:	00ef8733          	add	a4,t6,a4
c0028cc8:	00400813          	li	a6,4
c0028ccc:	0082e663          	bltu	t0,s0,c0028cd8 <__mdiff+0x128>
c0028cd0:	00158593          	addi	a1,a1,1
c0028cd4:	00259813          	slli	a6,a1,0x2
c0028cd8:	010484b3          	add	s1,s1,a6
c0028cdc:	010f8fb3          	add	t6,t6,a6
c0028ce0:	05d4fe63          	bgeu	s1,t4,c0028d3c <__mdiff+0x18c>
c0028ce4:	000108b7          	lui	a7,0x10
c0028ce8:	000f8813          	mv	a6,t6
c0028cec:	00048593          	mv	a1,s1
c0028cf0:	fff88893          	addi	a7,a7,-1 # ffff <_STACK_SIZE+0xefff>
c0028cf4:	0005a703          	lw	a4,0(a1)
c0028cf8:	00480813          	addi	a6,a6,4
c0028cfc:	00458593          	addi	a1,a1,4
c0028d00:	01177633          	and	a2,a4,a7
c0028d04:	00f60633          	add	a2,a2,a5
c0028d08:	41065693          	srai	a3,a2,0x10
c0028d0c:	01075793          	srli	a5,a4,0x10
c0028d10:	00d787b3          	add	a5,a5,a3
c0028d14:	01079693          	slli	a3,a5,0x10
c0028d18:	01167633          	and	a2,a2,a7
c0028d1c:	00c6e6b3          	or	a3,a3,a2
c0028d20:	fed82e23          	sw	a3,-4(a6)
c0028d24:	4107d793          	srai	a5,a5,0x10
c0028d28:	fdd5e6e3          	bltu	a1,t4,c0028cf4 <__mdiff+0x144>
c0028d2c:	fffe8713          	addi	a4,t4,-1
c0028d30:	40970733          	sub	a4,a4,s1
c0028d34:	ffc77713          	andi	a4,a4,-4
c0028d38:	00ef8733          	add	a4,t6,a4
c0028d3c:	00069a63          	bnez	a3,c0028d50 <__mdiff+0x1a0>
c0028d40:	ffc72783          	lw	a5,-4(a4)
c0028d44:	fffe0e13          	addi	t3,t3,-1
c0028d48:	ffc70713          	addi	a4,a4,-4
c0028d4c:	fe078ae3          	beqz	a5,c0028d40 <__mdiff+0x190>
c0028d50:	00c12083          	lw	ra,12(sp)
c0028d54:	00812403          	lw	s0,8(sp)
c0028d58:	01c52823          	sw	t3,16(a0)
c0028d5c:	00412483          	lw	s1,4(sp)
c0028d60:	00012903          	lw	s2,0(sp)
c0028d64:	01010113          	addi	sp,sp,16
c0028d68:	00008067          	ret
c0028d6c:	00048793          	mv	a5,s1
c0028d70:	00100913          	li	s2,1
c0028d74:	00040493          	mv	s1,s0
c0028d78:	00078413          	mv	s0,a5
c0028d7c:	e95ff06f          	j	c0028c10 <__mdiff+0x60>
c0028d80:	fe0946e3          	bltz	s2,c0028d6c <__mdiff+0x1bc>
c0028d84:	00000913          	li	s2,0
c0028d88:	e89ff06f          	j	c0028c10 <__mdiff+0x60>
c0028d8c:	00000593          	li	a1,0
c0028d90:	b58ff0ef          	jal	ra,c00280e8 <_Balloc>
c0028d94:	04050263          	beqz	a0,c0028dd8 <__mdiff+0x228>
c0028d98:	00c12083          	lw	ra,12(sp)
c0028d9c:	00812403          	lw	s0,8(sp)
c0028da0:	00100793          	li	a5,1
c0028da4:	00f52823          	sw	a5,16(a0)
c0028da8:	00052a23          	sw	zero,20(a0)
c0028dac:	00412483          	lw	s1,4(sp)
c0028db0:	00012903          	lw	s2,0(sp)
c0028db4:	01010113          	addi	sp,sp,16
c0028db8:	00008067          	ret
c0028dbc:	c80026b7          	lui	a3,0xc8002
c0028dc0:	c8002537          	lui	a0,0xc8002
c0028dc4:	73868693          	addi	a3,a3,1848 # c8002738 <_end+0xfff7deb8>
c0028dc8:	00000613          	li	a2,0
c0028dcc:	24000593          	li	a1,576
c0028dd0:	7ac50513          	addi	a0,a0,1964 # c80027ac <_end+0xfff7df2c>
c0028dd4:	688030ef          	jal	ra,c002c45c <__assert_func>
c0028dd8:	c80026b7          	lui	a3,0xc8002
c0028ddc:	c8002537          	lui	a0,0xc8002
c0028de0:	73868693          	addi	a3,a3,1848 # c8002738 <_end+0xfff7deb8>
c0028de4:	00000613          	li	a2,0
c0028de8:	23200593          	li	a1,562
c0028dec:	7ac50513          	addi	a0,a0,1964 # c80027ac <_end+0xfff7df2c>
c0028df0:	66c030ef          	jal	ra,c002c45c <__assert_func>

c0028df4 <__ulp>:
c0028df4:	7ff007b7          	lui	a5,0x7ff00
c0028df8:	00b7f5b3          	and	a1,a5,a1
c0028dfc:	fcc007b7          	lui	a5,0xfcc00
c0028e00:	00f585b3          	add	a1,a1,a5
c0028e04:	00b05863          	blez	a1,c0028e14 <__ulp+0x20>
c0028e08:	00000793          	li	a5,0
c0028e0c:	00078513          	mv	a0,a5
c0028e10:	00008067          	ret
c0028e14:	40b005b3          	neg	a1,a1
c0028e18:	4145d593          	srai	a1,a1,0x14
c0028e1c:	01300793          	li	a5,19
c0028e20:	00b7c863          	blt	a5,a1,c0028e30 <__ulp+0x3c>
c0028e24:	000807b7          	lui	a5,0x80
c0028e28:	40b7d5b3          	sra	a1,a5,a1
c0028e2c:	fddff06f          	j	c0028e08 <__ulp+0x14>
c0028e30:	fec58713          	addi	a4,a1,-20
c0028e34:	01e00693          	li	a3,30
c0028e38:	00000593          	li	a1,0
c0028e3c:	00100793          	li	a5,1
c0028e40:	fce6c6e3          	blt	a3,a4,c0028e0c <__ulp+0x18>
c0028e44:	800007b7          	lui	a5,0x80000
c0028e48:	00e7d7b3          	srl	a5,a5,a4
c0028e4c:	00078513          	mv	a0,a5
c0028e50:	00008067          	ret

c0028e54 <__b2d>:
c0028e54:	fe010113          	addi	sp,sp,-32
c0028e58:	00912a23          	sw	s1,20(sp)
c0028e5c:	01052483          	lw	s1,16(a0)
c0028e60:	00812c23          	sw	s0,24(sp)
c0028e64:	01450413          	addi	s0,a0,20
c0028e68:	00249493          	slli	s1,s1,0x2
c0028e6c:	009404b3          	add	s1,s0,s1
c0028e70:	01212823          	sw	s2,16(sp)
c0028e74:	ffc4a903          	lw	s2,-4(s1)
c0028e78:	01312623          	sw	s3,12(sp)
c0028e7c:	01412423          	sw	s4,8(sp)
c0028e80:	00090513          	mv	a0,s2
c0028e84:	00058993          	mv	s3,a1
c0028e88:	00112e23          	sw	ra,28(sp)
c0028e8c:	da8ff0ef          	jal	ra,c0028434 <__hi0bits>
c0028e90:	02000713          	li	a4,32
c0028e94:	40a707b3          	sub	a5,a4,a0
c0028e98:	00f9a023          	sw	a5,0(s3)
c0028e9c:	00a00793          	li	a5,10
c0028ea0:	ffc48a13          	addi	s4,s1,-4
c0028ea4:	08a7d063          	bge	a5,a0,c0028f24 <__b2d+0xd0>
c0028ea8:	ff550513          	addi	a0,a0,-11
c0028eac:	05447063          	bgeu	s0,s4,c0028eec <__b2d+0x98>
c0028eb0:	ff84a783          	lw	a5,-8(s1)
c0028eb4:	04050063          	beqz	a0,c0028ef4 <__b2d+0xa0>
c0028eb8:	40a706b3          	sub	a3,a4,a0
c0028ebc:	00d7d733          	srl	a4,a5,a3
c0028ec0:	00a91933          	sll	s2,s2,a0
c0028ec4:	00e96933          	or	s2,s2,a4
c0028ec8:	ff848613          	addi	a2,s1,-8
c0028ecc:	3ff00737          	lui	a4,0x3ff00
c0028ed0:	00e96733          	or	a4,s2,a4
c0028ed4:	00a797b3          	sll	a5,a5,a0
c0028ed8:	02c47263          	bgeu	s0,a2,c0028efc <__b2d+0xa8>
c0028edc:	ff44a603          	lw	a2,-12(s1)
c0028ee0:	00d656b3          	srl	a3,a2,a3
c0028ee4:	00d7e7b3          	or	a5,a5,a3
c0028ee8:	0140006f          	j	c0028efc <__b2d+0xa8>
c0028eec:	00000793          	li	a5,0
c0028ef0:	06051463          	bnez	a0,c0028f58 <__b2d+0x104>
c0028ef4:	3ff00737          	lui	a4,0x3ff00
c0028ef8:	00e96733          	or	a4,s2,a4
c0028efc:	01c12083          	lw	ra,28(sp)
c0028f00:	01812403          	lw	s0,24(sp)
c0028f04:	01412483          	lw	s1,20(sp)
c0028f08:	01012903          	lw	s2,16(sp)
c0028f0c:	00c12983          	lw	s3,12(sp)
c0028f10:	00812a03          	lw	s4,8(sp)
c0028f14:	00078513          	mv	a0,a5
c0028f18:	00070593          	mv	a1,a4
c0028f1c:	02010113          	addi	sp,sp,32
c0028f20:	00008067          	ret
c0028f24:	00b00693          	li	a3,11
c0028f28:	40a686b3          	sub	a3,a3,a0
c0028f2c:	3ff007b7          	lui	a5,0x3ff00
c0028f30:	00d95733          	srl	a4,s2,a3
c0028f34:	00f76733          	or	a4,a4,a5
c0028f38:	00000793          	li	a5,0
c0028f3c:	01447663          	bgeu	s0,s4,c0028f48 <__b2d+0xf4>
c0028f40:	ff84a783          	lw	a5,-8(s1)
c0028f44:	00d7d7b3          	srl	a5,a5,a3
c0028f48:	01550513          	addi	a0,a0,21
c0028f4c:	00a91533          	sll	a0,s2,a0
c0028f50:	00f567b3          	or	a5,a0,a5
c0028f54:	fa9ff06f          	j	c0028efc <__b2d+0xa8>
c0028f58:	00a91533          	sll	a0,s2,a0
c0028f5c:	3ff00737          	lui	a4,0x3ff00
c0028f60:	00e56733          	or	a4,a0,a4
c0028f64:	00000793          	li	a5,0
c0028f68:	f95ff06f          	j	c0028efc <__b2d+0xa8>

c0028f6c <__d2b>:
c0028f6c:	fd010113          	addi	sp,sp,-48
c0028f70:	01512a23          	sw	s5,20(sp)
c0028f74:	00058a93          	mv	s5,a1
c0028f78:	00100593          	li	a1,1
c0028f7c:	03212023          	sw	s2,32(sp)
c0028f80:	01312e23          	sw	s3,28(sp)
c0028f84:	01412c23          	sw	s4,24(sp)
c0028f88:	02112623          	sw	ra,44(sp)
c0028f8c:	02812423          	sw	s0,40(sp)
c0028f90:	02912223          	sw	s1,36(sp)
c0028f94:	00060913          	mv	s2,a2
c0028f98:	00068a13          	mv	s4,a3
c0028f9c:	00070993          	mv	s3,a4
c0028fa0:	948ff0ef          	jal	ra,c00280e8 <_Balloc>
c0028fa4:	10050863          	beqz	a0,c00290b4 <__d2b+0x148>
c0028fa8:	001007b7          	lui	a5,0x100
c0028fac:	01495493          	srli	s1,s2,0x14
c0028fb0:	fff78613          	addi	a2,a5,-1 # fffff <_HEAP_SIZE+0xbffff>
c0028fb4:	7ff4f493          	andi	s1,s1,2047
c0028fb8:	00050413          	mv	s0,a0
c0028fbc:	01267633          	and	a2,a2,s2
c0028fc0:	00048463          	beqz	s1,c0028fc8 <__d2b+0x5c>
c0028fc4:	00f66633          	or	a2,a2,a5
c0028fc8:	00c12623          	sw	a2,12(sp)
c0028fcc:	080a8863          	beqz	s5,c002905c <__d2b+0xf0>
c0028fd0:	00810513          	addi	a0,sp,8
c0028fd4:	01512423          	sw	s5,8(sp)
c0028fd8:	cd4ff0ef          	jal	ra,c00284ac <__lo0bits>
c0028fdc:	00c12703          	lw	a4,12(sp)
c0028fe0:	00050793          	mv	a5,a0
c0028fe4:	0c050263          	beqz	a0,c00290a8 <__d2b+0x13c>
c0028fe8:	00812603          	lw	a2,8(sp)
c0028fec:	02000693          	li	a3,32
c0028ff0:	40a686b3          	sub	a3,a3,a0
c0028ff4:	00d716b3          	sll	a3,a4,a3
c0028ff8:	00c6e6b3          	or	a3,a3,a2
c0028ffc:	00a75733          	srl	a4,a4,a0
c0029000:	00d42a23          	sw	a3,20(s0)
c0029004:	00e12623          	sw	a4,12(sp)
c0029008:	00e03933          	snez	s2,a4
c002900c:	00190913          	addi	s2,s2,1
c0029010:	00e42c23          	sw	a4,24(s0)
c0029014:	01242823          	sw	s2,16(s0)
c0029018:	06048463          	beqz	s1,c0029080 <__d2b+0x114>
c002901c:	bcd48493          	addi	s1,s1,-1075
c0029020:	00f484b3          	add	s1,s1,a5
c0029024:	03500513          	li	a0,53
c0029028:	009a2023          	sw	s1,0(s4)
c002902c:	40f507b3          	sub	a5,a0,a5
c0029030:	00f9a023          	sw	a5,0(s3)
c0029034:	02c12083          	lw	ra,44(sp)
c0029038:	00040513          	mv	a0,s0
c002903c:	02812403          	lw	s0,40(sp)
c0029040:	02412483          	lw	s1,36(sp)
c0029044:	02012903          	lw	s2,32(sp)
c0029048:	01c12983          	lw	s3,28(sp)
c002904c:	01812a03          	lw	s4,24(sp)
c0029050:	01412a83          	lw	s5,20(sp)
c0029054:	03010113          	addi	sp,sp,48
c0029058:	00008067          	ret
c002905c:	00c10513          	addi	a0,sp,12
c0029060:	c4cff0ef          	jal	ra,c00284ac <__lo0bits>
c0029064:	00100793          	li	a5,1
c0029068:	00f42823          	sw	a5,16(s0)
c002906c:	00c12783          	lw	a5,12(sp)
c0029070:	00100913          	li	s2,1
c0029074:	00f42a23          	sw	a5,20(s0)
c0029078:	02050793          	addi	a5,a0,32
c002907c:	fa0490e3          	bnez	s1,c002901c <__d2b+0xb0>
c0029080:	00291713          	slli	a4,s2,0x2
c0029084:	00e40733          	add	a4,s0,a4
c0029088:	01072503          	lw	a0,16(a4) # 3ff00010 <_DMEM_LENGTH+0x3f700010>
c002908c:	bce78793          	addi	a5,a5,-1074
c0029090:	00fa2023          	sw	a5,0(s4)
c0029094:	ba0ff0ef          	jal	ra,c0028434 <__hi0bits>
c0029098:	00591913          	slli	s2,s2,0x5
c002909c:	40a90933          	sub	s2,s2,a0
c00290a0:	0129a023          	sw	s2,0(s3)
c00290a4:	f91ff06f          	j	c0029034 <__d2b+0xc8>
c00290a8:	00812683          	lw	a3,8(sp)
c00290ac:	00d42a23          	sw	a3,20(s0)
c00290b0:	f59ff06f          	j	c0029008 <__d2b+0x9c>
c00290b4:	c80026b7          	lui	a3,0xc8002
c00290b8:	c8002537          	lui	a0,0xc8002
c00290bc:	73868693          	addi	a3,a3,1848 # c8002738 <_end+0xfff7deb8>
c00290c0:	00000613          	li	a2,0
c00290c4:	30a00593          	li	a1,778
c00290c8:	7ac50513          	addi	a0,a0,1964 # c80027ac <_end+0xfff7df2c>
c00290cc:	390030ef          	jal	ra,c002c45c <__assert_func>

c00290d0 <__ratio>:
c00290d0:	fd010113          	addi	sp,sp,-48
c00290d4:	03212023          	sw	s2,32(sp)
c00290d8:	00058913          	mv	s2,a1
c00290dc:	00810593          	addi	a1,sp,8
c00290e0:	02112623          	sw	ra,44(sp)
c00290e4:	02812423          	sw	s0,40(sp)
c00290e8:	02912223          	sw	s1,36(sp)
c00290ec:	01312e23          	sw	s3,28(sp)
c00290f0:	00050993          	mv	s3,a0
c00290f4:	d61ff0ef          	jal	ra,c0028e54 <__b2d>
c00290f8:	00050493          	mv	s1,a0
c00290fc:	00058413          	mv	s0,a1
c0029100:	00090513          	mv	a0,s2
c0029104:	00c10593          	addi	a1,sp,12
c0029108:	d4dff0ef          	jal	ra,c0028e54 <__b2d>
c002910c:	01092703          	lw	a4,16(s2)
c0029110:	0109a783          	lw	a5,16(s3)
c0029114:	00c12683          	lw	a3,12(sp)
c0029118:	40e787b3          	sub	a5,a5,a4
c002911c:	00812703          	lw	a4,8(sp)
c0029120:	00579793          	slli	a5,a5,0x5
c0029124:	40d70733          	sub	a4,a4,a3
c0029128:	00e787b3          	add	a5,a5,a4
c002912c:	00050713          	mv	a4,a0
c0029130:	02f05e63          	blez	a5,c002916c <__ratio+0x9c>
c0029134:	01479793          	slli	a5,a5,0x14
c0029138:	00878433          	add	s0,a5,s0
c002913c:	00058693          	mv	a3,a1
c0029140:	00048513          	mv	a0,s1
c0029144:	00040593          	mv	a1,s0
c0029148:	00070613          	mv	a2,a4
c002914c:	565040ef          	jal	ra,c002deb0 <__divdf3>
c0029150:	02c12083          	lw	ra,44(sp)
c0029154:	02812403          	lw	s0,40(sp)
c0029158:	02412483          	lw	s1,36(sp)
c002915c:	02012903          	lw	s2,32(sp)
c0029160:	01c12983          	lw	s3,28(sp)
c0029164:	03010113          	addi	sp,sp,48
c0029168:	00008067          	ret
c002916c:	01479793          	slli	a5,a5,0x14
c0029170:	40f585b3          	sub	a1,a1,a5
c0029174:	fc9ff06f          	j	c002913c <__ratio+0x6c>

c0029178 <_mprec_log10>:
c0029178:	ff010113          	addi	sp,sp,-16
c002917c:	01212023          	sw	s2,0(sp)
c0029180:	00112623          	sw	ra,12(sp)
c0029184:	00812423          	sw	s0,8(sp)
c0029188:	00912223          	sw	s1,4(sp)
c002918c:	01700793          	li	a5,23
c0029190:	00050913          	mv	s2,a0
c0029194:	04a7da63          	bge	a5,a0,c00291e8 <_mprec_log10+0x70>
c0029198:	c8003737          	lui	a4,0xc8003
c002919c:	93072783          	lw	a5,-1744(a4) # c8002930 <_end+0xfff7e0b0>
c00291a0:	93472583          	lw	a1,-1740(a4)
c00291a4:	c8003737          	lui	a4,0xc8003
c00291a8:	93872403          	lw	s0,-1736(a4) # c8002938 <_end+0xfff7e0b8>
c00291ac:	93c72483          	lw	s1,-1732(a4)
c00291b0:	00078513          	mv	a0,a5
c00291b4:	00040613          	mv	a2,s0
c00291b8:	00048693          	mv	a3,s1
c00291bc:	3d4050ef          	jal	ra,c002e590 <__muldf3>
c00291c0:	fff90913          	addi	s2,s2,-1
c00291c4:	00050793          	mv	a5,a0
c00291c8:	fe0914e3          	bnez	s2,c00291b0 <_mprec_log10+0x38>
c00291cc:	00c12083          	lw	ra,12(sp)
c00291d0:	00812403          	lw	s0,8(sp)
c00291d4:	00412483          	lw	s1,4(sp)
c00291d8:	00012903          	lw	s2,0(sp)
c00291dc:	00078513          	mv	a0,a5
c00291e0:	01010113          	addi	sp,sp,16
c00291e4:	00008067          	ret
c00291e8:	c80027b7          	lui	a5,0xc8002
c00291ec:	00351913          	slli	s2,a0,0x3
c00291f0:	fd878793          	addi	a5,a5,-40 # c8001fd8 <_end+0xfff7d758>
c00291f4:	01278933          	add	s2,a5,s2
c00291f8:	01092783          	lw	a5,16(s2)
c00291fc:	00c12083          	lw	ra,12(sp)
c0029200:	00812403          	lw	s0,8(sp)
c0029204:	01492583          	lw	a1,20(s2)
c0029208:	00412483          	lw	s1,4(sp)
c002920c:	00012903          	lw	s2,0(sp)
c0029210:	00078513          	mv	a0,a5
c0029214:	01010113          	addi	sp,sp,16
c0029218:	00008067          	ret

c002921c <__copybits>:
c002921c:	01062683          	lw	a3,16(a2)
c0029220:	fff58593          	addi	a1,a1,-1
c0029224:	4055d593          	srai	a1,a1,0x5
c0029228:	00158593          	addi	a1,a1,1
c002922c:	01460793          	addi	a5,a2,20
c0029230:	00269693          	slli	a3,a3,0x2
c0029234:	00259593          	slli	a1,a1,0x2
c0029238:	00d786b3          	add	a3,a5,a3
c002923c:	00b505b3          	add	a1,a0,a1
c0029240:	02d7f863          	bgeu	a5,a3,c0029270 <__copybits+0x54>
c0029244:	00050713          	mv	a4,a0
c0029248:	0007a803          	lw	a6,0(a5)
c002924c:	00478793          	addi	a5,a5,4
c0029250:	00470713          	addi	a4,a4,4
c0029254:	ff072e23          	sw	a6,-4(a4)
c0029258:	fed7e8e3          	bltu	a5,a3,c0029248 <__copybits+0x2c>
c002925c:	40c687b3          	sub	a5,a3,a2
c0029260:	feb78793          	addi	a5,a5,-21
c0029264:	ffc7f793          	andi	a5,a5,-4
c0029268:	00478793          	addi	a5,a5,4
c002926c:	00f50533          	add	a0,a0,a5
c0029270:	00b57863          	bgeu	a0,a1,c0029280 <__copybits+0x64>
c0029274:	00450513          	addi	a0,a0,4
c0029278:	fe052e23          	sw	zero,-4(a0)
c002927c:	feb56ce3          	bltu	a0,a1,c0029274 <__copybits+0x58>
c0029280:	00008067          	ret

c0029284 <__any_on>:
c0029284:	01052703          	lw	a4,16(a0)
c0029288:	4055d613          	srai	a2,a1,0x5
c002928c:	01450693          	addi	a3,a0,20
c0029290:	02c75263          	bge	a4,a2,c00292b4 <__any_on+0x30>
c0029294:	00271793          	slli	a5,a4,0x2
c0029298:	00f687b3          	add	a5,a3,a5
c002929c:	04f6f263          	bgeu	a3,a5,c00292e0 <__any_on+0x5c>
c00292a0:	ffc7a703          	lw	a4,-4(a5)
c00292a4:	ffc78793          	addi	a5,a5,-4
c00292a8:	fe070ae3          	beqz	a4,c002929c <__any_on+0x18>
c00292ac:	00100513          	li	a0,1
c00292b0:	00008067          	ret
c00292b4:	00261793          	slli	a5,a2,0x2
c00292b8:	00f687b3          	add	a5,a3,a5
c00292bc:	fee650e3          	bge	a2,a4,c002929c <__any_on+0x18>
c00292c0:	01f5f593          	andi	a1,a1,31
c00292c4:	fc058ce3          	beqz	a1,c002929c <__any_on+0x18>
c00292c8:	0007a603          	lw	a2,0(a5)
c00292cc:	00100513          	li	a0,1
c00292d0:	00b65733          	srl	a4,a2,a1
c00292d4:	00b715b3          	sll	a1,a4,a1
c00292d8:	fcb602e3          	beq	a2,a1,c002929c <__any_on+0x18>
c00292dc:	00008067          	ret
c00292e0:	00000513          	li	a0,0
c00292e4:	00008067          	ret

c00292e8 <_realloc_r>:
c00292e8:	fd010113          	addi	sp,sp,-48
c00292ec:	03212023          	sw	s2,32(sp)
c00292f0:	02112623          	sw	ra,44(sp)
c00292f4:	02812423          	sw	s0,40(sp)
c00292f8:	02912223          	sw	s1,36(sp)
c00292fc:	01312e23          	sw	s3,28(sp)
c0029300:	01412c23          	sw	s4,24(sp)
c0029304:	01512a23          	sw	s5,20(sp)
c0029308:	01612823          	sw	s6,16(sp)
c002930c:	01712623          	sw	s7,12(sp)
c0029310:	01812423          	sw	s8,8(sp)
c0029314:	00060913          	mv	s2,a2
c0029318:	1c058663          	beqz	a1,c00294e4 <_realloc_r+0x1fc>
c002931c:	00058413          	mv	s0,a1
c0029320:	00050993          	mv	s3,a0
c0029324:	dbdfe0ef          	jal	ra,c00280e0 <__malloc_lock>
c0029328:	00b90493          	addi	s1,s2,11
c002932c:	01600793          	li	a5,22
c0029330:	0e97fe63          	bgeu	a5,s1,c002942c <_realloc_r+0x144>
c0029334:	ff84f493          	andi	s1,s1,-8
c0029338:	00048713          	mv	a4,s1
c002933c:	0e04ce63          	bltz	s1,c0029438 <_realloc_r+0x150>
c0029340:	0f24ec63          	bltu	s1,s2,c0029438 <_realloc_r+0x150>
c0029344:	ffc42783          	lw	a5,-4(s0)
c0029348:	ff840a93          	addi	s5,s0,-8
c002934c:	ffc7fa13          	andi	s4,a5,-4
c0029350:	014a8b33          	add	s6,s5,s4
c0029354:	12ea5e63          	bge	s4,a4,c0029490 <_realloc_r+0x1a8>
c0029358:	c80036b7          	lui	a3,0xc8003
c002935c:	0fc68b93          	addi	s7,a3,252 # c80030fc <_end+0xfff7e87c>
c0029360:	008ba603          	lw	a2,8(s7)
c0029364:	004b2683          	lw	a3,4(s6)
c0029368:	1f660063          	beq	a2,s6,c0029548 <_realloc_r+0x260>
c002936c:	ffe6f613          	andi	a2,a3,-2
c0029370:	00cb0633          	add	a2,s6,a2
c0029374:	00462603          	lw	a2,4(a2)
c0029378:	00167613          	andi	a2,a2,1
c002937c:	14061663          	bnez	a2,c00294c8 <_realloc_r+0x1e0>
c0029380:	ffc6f693          	andi	a3,a3,-4
c0029384:	00da0633          	add	a2,s4,a3
c0029388:	0ee65863          	bge	a2,a4,c0029478 <_realloc_r+0x190>
c002938c:	0017f793          	andi	a5,a5,1
c0029390:	02079463          	bnez	a5,c00293b8 <_realloc_r+0xd0>
c0029394:	ff842c03          	lw	s8,-8(s0)
c0029398:	418a8c33          	sub	s8,s5,s8
c002939c:	004c2783          	lw	a5,4(s8)
c00293a0:	ffc7f793          	andi	a5,a5,-4
c00293a4:	00d786b3          	add	a3,a5,a3
c00293a8:	01468bb3          	add	s7,a3,s4
c00293ac:	34ebda63          	bge	s7,a4,c0029700 <_realloc_r+0x418>
c00293b0:	00fa0bb3          	add	s7,s4,a5
c00293b4:	2cebd463          	bge	s7,a4,c002967c <_realloc_r+0x394>
c00293b8:	00090593          	mv	a1,s2
c00293bc:	00098513          	mv	a0,s3
c00293c0:	b0cfe0ef          	jal	ra,c00276cc <_malloc_r>
c00293c4:	00050913          	mv	s2,a0
c00293c8:	04050c63          	beqz	a0,c0029420 <_realloc_r+0x138>
c00293cc:	ffc42783          	lw	a5,-4(s0)
c00293d0:	ff850713          	addi	a4,a0,-8
c00293d4:	ffe7f793          	andi	a5,a5,-2
c00293d8:	00fa87b3          	add	a5,s5,a5
c00293dc:	28e78663          	beq	a5,a4,c0029668 <_realloc_r+0x380>
c00293e0:	ffca0613          	addi	a2,s4,-4
c00293e4:	02400793          	li	a5,36
c00293e8:	30c7e663          	bltu	a5,a2,c00296f4 <_realloc_r+0x40c>
c00293ec:	01300713          	li	a4,19
c00293f0:	00042683          	lw	a3,0(s0)
c00293f4:	20c76e63          	bltu	a4,a2,c0029610 <_realloc_r+0x328>
c00293f8:	00050793          	mv	a5,a0
c00293fc:	00040713          	mv	a4,s0
c0029400:	00d7a023          	sw	a3,0(a5)
c0029404:	00472683          	lw	a3,4(a4)
c0029408:	00d7a223          	sw	a3,4(a5)
c002940c:	00872703          	lw	a4,8(a4)
c0029410:	00e7a423          	sw	a4,8(a5)
c0029414:	00040593          	mv	a1,s0
c0029418:	00098513          	mv	a0,s3
c002941c:	a3dfa0ef          	jal	ra,c0023e58 <_free_r>
c0029420:	00098513          	mv	a0,s3
c0029424:	cc1fe0ef          	jal	ra,c00280e4 <__malloc_unlock>
c0029428:	01c0006f          	j	c0029444 <_realloc_r+0x15c>
c002942c:	01000493          	li	s1,16
c0029430:	01000713          	li	a4,16
c0029434:	f124f8e3          	bgeu	s1,s2,c0029344 <_realloc_r+0x5c>
c0029438:	00c00793          	li	a5,12
c002943c:	00f9a023          	sw	a5,0(s3)
c0029440:	00000913          	li	s2,0
c0029444:	02c12083          	lw	ra,44(sp)
c0029448:	02812403          	lw	s0,40(sp)
c002944c:	02412483          	lw	s1,36(sp)
c0029450:	01c12983          	lw	s3,28(sp)
c0029454:	01812a03          	lw	s4,24(sp)
c0029458:	01412a83          	lw	s5,20(sp)
c002945c:	01012b03          	lw	s6,16(sp)
c0029460:	00c12b83          	lw	s7,12(sp)
c0029464:	00812c03          	lw	s8,8(sp)
c0029468:	00090513          	mv	a0,s2
c002946c:	02012903          	lw	s2,32(sp)
c0029470:	03010113          	addi	sp,sp,48
c0029474:	00008067          	ret
c0029478:	00cb2783          	lw	a5,12(s6)
c002947c:	008b2703          	lw	a4,8(s6)
c0029480:	00060a13          	mv	s4,a2
c0029484:	00ca8b33          	add	s6,s5,a2
c0029488:	00f72623          	sw	a5,12(a4)
c002948c:	00e7a423          	sw	a4,8(a5)
c0029490:	004aa783          	lw	a5,4(s5)
c0029494:	409a0733          	sub	a4,s4,s1
c0029498:	00f00693          	li	a3,15
c002949c:	0017f793          	andi	a5,a5,1
c00294a0:	06e6ec63          	bltu	a3,a4,c0029518 <_realloc_r+0x230>
c00294a4:	00fa67b3          	or	a5,s4,a5
c00294a8:	00faa223          	sw	a5,4(s5)
c00294ac:	004b2783          	lw	a5,4(s6)
c00294b0:	0017e793          	ori	a5,a5,1
c00294b4:	00fb2223          	sw	a5,4(s6)
c00294b8:	00098513          	mv	a0,s3
c00294bc:	c29fe0ef          	jal	ra,c00280e4 <__malloc_unlock>
c00294c0:	00040913          	mv	s2,s0
c00294c4:	f81ff06f          	j	c0029444 <_realloc_r+0x15c>
c00294c8:	0017f793          	andi	a5,a5,1
c00294cc:	ee0796e3          	bnez	a5,c00293b8 <_realloc_r+0xd0>
c00294d0:	ff842c03          	lw	s8,-8(s0)
c00294d4:	418a8c33          	sub	s8,s5,s8
c00294d8:	004c2783          	lw	a5,4(s8)
c00294dc:	ffc7f793          	andi	a5,a5,-4
c00294e0:	ed1ff06f          	j	c00293b0 <_realloc_r+0xc8>
c00294e4:	02812403          	lw	s0,40(sp)
c00294e8:	02c12083          	lw	ra,44(sp)
c00294ec:	02412483          	lw	s1,36(sp)
c00294f0:	02012903          	lw	s2,32(sp)
c00294f4:	01c12983          	lw	s3,28(sp)
c00294f8:	01812a03          	lw	s4,24(sp)
c00294fc:	01412a83          	lw	s5,20(sp)
c0029500:	01012b03          	lw	s6,16(sp)
c0029504:	00c12b83          	lw	s7,12(sp)
c0029508:	00812c03          	lw	s8,8(sp)
c002950c:	00060593          	mv	a1,a2
c0029510:	03010113          	addi	sp,sp,48
c0029514:	9b8fe06f          	j	c00276cc <_malloc_r>
c0029518:	0097e7b3          	or	a5,a5,s1
c002951c:	00faa223          	sw	a5,4(s5)
c0029520:	009a85b3          	add	a1,s5,s1
c0029524:	00176713          	ori	a4,a4,1
c0029528:	00e5a223          	sw	a4,4(a1)
c002952c:	004b2783          	lw	a5,4(s6)
c0029530:	00858593          	addi	a1,a1,8
c0029534:	00098513          	mv	a0,s3
c0029538:	0017e793          	ori	a5,a5,1
c002953c:	00fb2223          	sw	a5,4(s6)
c0029540:	919fa0ef          	jal	ra,c0023e58 <_free_r>
c0029544:	f75ff06f          	j	c00294b8 <_realloc_r+0x1d0>
c0029548:	ffc6f693          	andi	a3,a3,-4
c002954c:	00da0633          	add	a2,s4,a3
c0029550:	01048593          	addi	a1,s1,16
c0029554:	0eb65063          	bge	a2,a1,c0029634 <_realloc_r+0x34c>
c0029558:	0017f793          	andi	a5,a5,1
c002955c:	e4079ee3          	bnez	a5,c00293b8 <_realloc_r+0xd0>
c0029560:	ff842c03          	lw	s8,-8(s0)
c0029564:	418a8c33          	sub	s8,s5,s8
c0029568:	004c2783          	lw	a5,4(s8)
c002956c:	ffc7f793          	andi	a5,a5,-4
c0029570:	00d786b3          	add	a3,a5,a3
c0029574:	01468b33          	add	s6,a3,s4
c0029578:	e2bb4ce3          	blt	s6,a1,c00293b0 <_realloc_r+0xc8>
c002957c:	00cc2783          	lw	a5,12(s8)
c0029580:	008c2703          	lw	a4,8(s8)
c0029584:	ffca0613          	addi	a2,s4,-4
c0029588:	02400693          	li	a3,36
c002958c:	00f72623          	sw	a5,12(a4)
c0029590:	00e7a423          	sw	a4,8(a5)
c0029594:	008c0913          	addi	s2,s8,8
c0029598:	26c6ec63          	bltu	a3,a2,c0029810 <_realloc_r+0x528>
c002959c:	01300593          	li	a1,19
c00295a0:	00042703          	lw	a4,0(s0)
c00295a4:	00090793          	mv	a5,s2
c00295a8:	02c5f263          	bgeu	a1,a2,c00295cc <_realloc_r+0x2e4>
c00295ac:	00ec2423          	sw	a4,8(s8)
c00295b0:	00442703          	lw	a4,4(s0)
c00295b4:	01b00793          	li	a5,27
c00295b8:	00ec2623          	sw	a4,12(s8)
c00295bc:	26c7e263          	bltu	a5,a2,c0029820 <_realloc_r+0x538>
c00295c0:	00842703          	lw	a4,8(s0)
c00295c4:	010c0793          	addi	a5,s8,16
c00295c8:	00840413          	addi	s0,s0,8
c00295cc:	00e7a023          	sw	a4,0(a5)
c00295d0:	00442703          	lw	a4,4(s0)
c00295d4:	00e7a223          	sw	a4,4(a5)
c00295d8:	00842703          	lw	a4,8(s0)
c00295dc:	00e7a423          	sw	a4,8(a5)
c00295e0:	009c0733          	add	a4,s8,s1
c00295e4:	409b07b3          	sub	a5,s6,s1
c00295e8:	00eba423          	sw	a4,8(s7)
c00295ec:	0017e793          	ori	a5,a5,1
c00295f0:	00f72223          	sw	a5,4(a4)
c00295f4:	004c2783          	lw	a5,4(s8)
c00295f8:	00098513          	mv	a0,s3
c00295fc:	0017f793          	andi	a5,a5,1
c0029600:	0097e4b3          	or	s1,a5,s1
c0029604:	009c2223          	sw	s1,4(s8)
c0029608:	addfe0ef          	jal	ra,c00280e4 <__malloc_unlock>
c002960c:	e39ff06f          	j	c0029444 <_realloc_r+0x15c>
c0029610:	00d52023          	sw	a3,0(a0)
c0029614:	00442683          	lw	a3,4(s0)
c0029618:	01b00713          	li	a4,27
c002961c:	00d52223          	sw	a3,4(a0)
c0029620:	16c76e63          	bltu	a4,a2,c002979c <_realloc_r+0x4b4>
c0029624:	00842683          	lw	a3,8(s0)
c0029628:	00840713          	addi	a4,s0,8
c002962c:	00850793          	addi	a5,a0,8
c0029630:	dd1ff06f          	j	c0029400 <_realloc_r+0x118>
c0029634:	009a8ab3          	add	s5,s5,s1
c0029638:	409607b3          	sub	a5,a2,s1
c002963c:	015ba423          	sw	s5,8(s7)
c0029640:	0017e793          	ori	a5,a5,1
c0029644:	00faa223          	sw	a5,4(s5)
c0029648:	ffc42783          	lw	a5,-4(s0)
c002964c:	00098513          	mv	a0,s3
c0029650:	00040913          	mv	s2,s0
c0029654:	0017f793          	andi	a5,a5,1
c0029658:	0097e4b3          	or	s1,a5,s1
c002965c:	fe942e23          	sw	s1,-4(s0)
c0029660:	a85fe0ef          	jal	ra,c00280e4 <__malloc_unlock>
c0029664:	de1ff06f          	j	c0029444 <_realloc_r+0x15c>
c0029668:	ffc52783          	lw	a5,-4(a0)
c002966c:	ffc7f793          	andi	a5,a5,-4
c0029670:	00fa0a33          	add	s4,s4,a5
c0029674:	014a8b33          	add	s6,s5,s4
c0029678:	e19ff06f          	j	c0029490 <_realloc_r+0x1a8>
c002967c:	00cc2783          	lw	a5,12(s8)
c0029680:	008c2703          	lw	a4,8(s8)
c0029684:	ffca0613          	addi	a2,s4,-4
c0029688:	02400693          	li	a3,36
c002968c:	00f72623          	sw	a5,12(a4)
c0029690:	00e7a423          	sw	a4,8(a5)
c0029694:	008c0913          	addi	s2,s8,8
c0029698:	017c0b33          	add	s6,s8,s7
c002969c:	0ec6e263          	bltu	a3,a2,c0029780 <_realloc_r+0x498>
c00296a0:	01300593          	li	a1,19
c00296a4:	00042703          	lw	a4,0(s0)
c00296a8:	00090793          	mv	a5,s2
c00296ac:	02c5f263          	bgeu	a1,a2,c00296d0 <_realloc_r+0x3e8>
c00296b0:	00ec2423          	sw	a4,8(s8)
c00296b4:	00442703          	lw	a4,4(s0)
c00296b8:	01b00793          	li	a5,27
c00296bc:	00ec2623          	sw	a4,12(s8)
c00296c0:	10c7e063          	bltu	a5,a2,c00297c0 <_realloc_r+0x4d8>
c00296c4:	00842703          	lw	a4,8(s0)
c00296c8:	010c0793          	addi	a5,s8,16
c00296cc:	00840413          	addi	s0,s0,8
c00296d0:	00e7a023          	sw	a4,0(a5)
c00296d4:	00442703          	lw	a4,4(s0)
c00296d8:	000b8a13          	mv	s4,s7
c00296dc:	000c0a93          	mv	s5,s8
c00296e0:	00e7a223          	sw	a4,4(a5)
c00296e4:	00842703          	lw	a4,8(s0)
c00296e8:	00090413          	mv	s0,s2
c00296ec:	00e7a423          	sw	a4,8(a5)
c00296f0:	da1ff06f          	j	c0029490 <_realloc_r+0x1a8>
c00296f4:	00040593          	mv	a1,s0
c00296f8:	8c9fe0ef          	jal	ra,c0027fc0 <memmove>
c00296fc:	d19ff06f          	j	c0029414 <_realloc_r+0x12c>
c0029700:	00cb2783          	lw	a5,12(s6)
c0029704:	008b2703          	lw	a4,8(s6)
c0029708:	ffca0613          	addi	a2,s4,-4
c002970c:	02400693          	li	a3,36
c0029710:	00f72623          	sw	a5,12(a4)
c0029714:	00e7a423          	sw	a4,8(a5)
c0029718:	008c2703          	lw	a4,8(s8)
c002971c:	00cc2783          	lw	a5,12(s8)
c0029720:	008c0913          	addi	s2,s8,8
c0029724:	017c0b33          	add	s6,s8,s7
c0029728:	00f72623          	sw	a5,12(a4)
c002972c:	00e7a423          	sw	a4,8(a5)
c0029730:	04c6e863          	bltu	a3,a2,c0029780 <_realloc_r+0x498>
c0029734:	01300693          	li	a3,19
c0029738:	00042703          	lw	a4,0(s0)
c002973c:	00090793          	mv	a5,s2
c0029740:	f8c6f8e3          	bgeu	a3,a2,c00296d0 <_realloc_r+0x3e8>
c0029744:	00ec2423          	sw	a4,8(s8)
c0029748:	00442703          	lw	a4,4(s0)
c002974c:	01b00793          	li	a5,27
c0029750:	00ec2623          	sw	a4,12(s8)
c0029754:	00842703          	lw	a4,8(s0)
c0029758:	f6c7f8e3          	bgeu	a5,a2,c00296c8 <_realloc_r+0x3e0>
c002975c:	00ec2823          	sw	a4,16(s8)
c0029760:	00c42703          	lw	a4,12(s0)
c0029764:	02400793          	li	a5,36
c0029768:	00ec2a23          	sw	a4,20(s8)
c002976c:	01042703          	lw	a4,16(s0)
c0029770:	06f60463          	beq	a2,a5,c00297d8 <_realloc_r+0x4f0>
c0029774:	018c0793          	addi	a5,s8,24
c0029778:	01040413          	addi	s0,s0,16
c002977c:	f55ff06f          	j	c00296d0 <_realloc_r+0x3e8>
c0029780:	00040593          	mv	a1,s0
c0029784:	00090513          	mv	a0,s2
c0029788:	839fe0ef          	jal	ra,c0027fc0 <memmove>
c002978c:	00090413          	mv	s0,s2
c0029790:	000b8a13          	mv	s4,s7
c0029794:	000c0a93          	mv	s5,s8
c0029798:	cf9ff06f          	j	c0029490 <_realloc_r+0x1a8>
c002979c:	00842703          	lw	a4,8(s0)
c00297a0:	00e52423          	sw	a4,8(a0)
c00297a4:	00c42703          	lw	a4,12(s0)
c00297a8:	00e52623          	sw	a4,12(a0)
c00297ac:	01042683          	lw	a3,16(s0)
c00297b0:	04f60263          	beq	a2,a5,c00297f4 <_realloc_r+0x50c>
c00297b4:	01040713          	addi	a4,s0,16
c00297b8:	01050793          	addi	a5,a0,16
c00297bc:	c45ff06f          	j	c0029400 <_realloc_r+0x118>
c00297c0:	00842783          	lw	a5,8(s0)
c00297c4:	00fc2823          	sw	a5,16(s8)
c00297c8:	00c42783          	lw	a5,12(s0)
c00297cc:	00fc2a23          	sw	a5,20(s8)
c00297d0:	01042703          	lw	a4,16(s0)
c00297d4:	fad610e3          	bne	a2,a3,c0029774 <_realloc_r+0x48c>
c00297d8:	00ec2c23          	sw	a4,24(s8)
c00297dc:	01442703          	lw	a4,20(s0)
c00297e0:	020c0793          	addi	a5,s8,32
c00297e4:	01840413          	addi	s0,s0,24
c00297e8:	00ec2e23          	sw	a4,28(s8)
c00297ec:	00042703          	lw	a4,0(s0)
c00297f0:	ee1ff06f          	j	c00296d0 <_realloc_r+0x3e8>
c00297f4:	00d52823          	sw	a3,16(a0)
c00297f8:	01442683          	lw	a3,20(s0)
c00297fc:	01840713          	addi	a4,s0,24
c0029800:	01850793          	addi	a5,a0,24
c0029804:	00d52a23          	sw	a3,20(a0)
c0029808:	01842683          	lw	a3,24(s0)
c002980c:	bf5ff06f          	j	c0029400 <_realloc_r+0x118>
c0029810:	00040593          	mv	a1,s0
c0029814:	00090513          	mv	a0,s2
c0029818:	fa8fe0ef          	jal	ra,c0027fc0 <memmove>
c002981c:	dc5ff06f          	j	c00295e0 <_realloc_r+0x2f8>
c0029820:	00842783          	lw	a5,8(s0)
c0029824:	00fc2823          	sw	a5,16(s8)
c0029828:	00c42783          	lw	a5,12(s0)
c002982c:	00fc2a23          	sw	a5,20(s8)
c0029830:	01042703          	lw	a4,16(s0)
c0029834:	00d60863          	beq	a2,a3,c0029844 <_realloc_r+0x55c>
c0029838:	018c0793          	addi	a5,s8,24
c002983c:	01040413          	addi	s0,s0,16
c0029840:	d8dff06f          	j	c00295cc <_realloc_r+0x2e4>
c0029844:	00ec2c23          	sw	a4,24(s8)
c0029848:	01442703          	lw	a4,20(s0)
c002984c:	020c0793          	addi	a5,s8,32
c0029850:	01840413          	addi	s0,s0,24
c0029854:	00ec2e23          	sw	a4,28(s8)
c0029858:	00042703          	lw	a4,0(s0)
c002985c:	d71ff06f          	j	c00295cc <_realloc_r+0x2e4>

c0029860 <_sbrk_r>:
c0029860:	ff010113          	addi	sp,sp,-16
c0029864:	00812423          	sw	s0,8(sp)
c0029868:	00912223          	sw	s1,4(sp)
c002986c:	00050413          	mv	s0,a0
c0029870:	c80034b7          	lui	s1,0xc8003
c0029874:	00058513          	mv	a0,a1
c0029878:	00112623          	sw	ra,12(sp)
c002987c:	9204a423          	sw	zero,-1752(s1) # c8002928 <_end+0xfff7e0a8>
c0029880:	b1de00ef          	jal	ra,c000a39c <_sbrk>
c0029884:	fff00793          	li	a5,-1
c0029888:	00f50c63          	beq	a0,a5,c00298a0 <_sbrk_r+0x40>
c002988c:	00c12083          	lw	ra,12(sp)
c0029890:	00812403          	lw	s0,8(sp)
c0029894:	00412483          	lw	s1,4(sp)
c0029898:	01010113          	addi	sp,sp,16
c002989c:	00008067          	ret
c00298a0:	9284a783          	lw	a5,-1752(s1)
c00298a4:	fe0784e3          	beqz	a5,c002988c <_sbrk_r+0x2c>
c00298a8:	00c12083          	lw	ra,12(sp)
c00298ac:	00f42023          	sw	a5,0(s0)
c00298b0:	00812403          	lw	s0,8(sp)
c00298b4:	00412483          	lw	s1,4(sp)
c00298b8:	01010113          	addi	sp,sp,16
c00298bc:	00008067          	ret

c00298c0 <frexp>:
c00298c0:	ff010113          	addi	sp,sp,-16
c00298c4:	00912223          	sw	s1,4(sp)
c00298c8:	800004b7          	lui	s1,0x80000
c00298cc:	00812423          	sw	s0,8(sp)
c00298d0:	00112623          	sw	ra,12(sp)
c00298d4:	fff4c493          	not	s1,s1
c00298d8:	00060413          	mv	s0,a2
c00298dc:	00062023          	sw	zero,0(a2)
c00298e0:	00b4f6b3          	and	a3,s1,a1
c00298e4:	7ff00637          	lui	a2,0x7ff00
c00298e8:	00058793          	mv	a5,a1
c00298ec:	00050713          	mv	a4,a0
c00298f0:	06c6d063          	bge	a3,a2,c0029950 <frexp+0x90>
c00298f4:	00a6e8b3          	or	a7,a3,a0
c00298f8:	04088c63          	beqz	a7,c0029950 <frexp+0x90>
c00298fc:	00c5f633          	and	a2,a1,a2
c0029900:	00058813          	mv	a6,a1
c0029904:	00000893          	li	a7,0
c0029908:	02061263          	bnez	a2,c002992c <frexp+0x6c>
c002990c:	c80037b7          	lui	a5,0xc8003
c0029910:	9447a683          	lw	a3,-1724(a5) # c8002944 <_end+0xfff7e0c4>
c0029914:	9407a603          	lw	a2,-1728(a5)
c0029918:	479040ef          	jal	ra,c002e590 <__muldf3>
c002991c:	00050713          	mv	a4,a0
c0029920:	00058813          	mv	a6,a1
c0029924:	00b4f6b3          	and	a3,s1,a1
c0029928:	fca00893          	li	a7,-54
c002992c:	4146d693          	srai	a3,a3,0x14
c0029930:	801007b7          	lui	a5,0x80100
c0029934:	fff78793          	addi	a5,a5,-1 # 800fffff <_end+0xb807b77f>
c0029938:	c0268693          	addi	a3,a3,-1022
c002993c:	00f87833          	and	a6,a6,a5
c0029940:	011686b3          	add	a3,a3,a7
c0029944:	3fe007b7          	lui	a5,0x3fe00
c0029948:	00f867b3          	or	a5,a6,a5
c002994c:	00d42023          	sw	a3,0(s0)
c0029950:	00c12083          	lw	ra,12(sp)
c0029954:	00812403          	lw	s0,8(sp)
c0029958:	00412483          	lw	s1,4(sp)
c002995c:	00070513          	mv	a0,a4
c0029960:	00078593          	mv	a1,a5
c0029964:	01010113          	addi	sp,sp,16
c0029968:	00008067          	ret

c002996c <__sread>:
c002996c:	ff010113          	addi	sp,sp,-16
c0029970:	00812423          	sw	s0,8(sp)
c0029974:	00058413          	mv	s0,a1
c0029978:	00e59583          	lh	a1,14(a1)
c002997c:	00112623          	sw	ra,12(sp)
c0029980:	1cc030ef          	jal	ra,c002cb4c <_read_r>
c0029984:	02054063          	bltz	a0,c00299a4 <__sread+0x38>
c0029988:	05042783          	lw	a5,80(s0)
c002998c:	00c12083          	lw	ra,12(sp)
c0029990:	00a787b3          	add	a5,a5,a0
c0029994:	04f42823          	sw	a5,80(s0)
c0029998:	00812403          	lw	s0,8(sp)
c002999c:	01010113          	addi	sp,sp,16
c00299a0:	00008067          	ret
c00299a4:	00c45783          	lhu	a5,12(s0)
c00299a8:	fffff737          	lui	a4,0xfffff
c00299ac:	fff70713          	addi	a4,a4,-1 # ffffefff <_end+0x37f7a77f>
c00299b0:	00e7f7b3          	and	a5,a5,a4
c00299b4:	00c12083          	lw	ra,12(sp)
c00299b8:	00f41623          	sh	a5,12(s0)
c00299bc:	00812403          	lw	s0,8(sp)
c00299c0:	01010113          	addi	sp,sp,16
c00299c4:	00008067          	ret

c00299c8 <__seofread>:
c00299c8:	00000513          	li	a0,0
c00299cc:	00008067          	ret

c00299d0 <__swrite>:
c00299d0:	00c59783          	lh	a5,12(a1)
c00299d4:	fe010113          	addi	sp,sp,-32
c00299d8:	00812c23          	sw	s0,24(sp)
c00299dc:	00912a23          	sw	s1,20(sp)
c00299e0:	01212823          	sw	s2,16(sp)
c00299e4:	01312623          	sw	s3,12(sp)
c00299e8:	00112e23          	sw	ra,28(sp)
c00299ec:	1007f713          	andi	a4,a5,256
c00299f0:	00058413          	mv	s0,a1
c00299f4:	00050493          	mv	s1,a0
c00299f8:	00e59583          	lh	a1,14(a1)
c00299fc:	00060913          	mv	s2,a2
c0029a00:	00068993          	mv	s3,a3
c0029a04:	02071e63          	bnez	a4,c0029a40 <__swrite+0x70>
c0029a08:	fffff737          	lui	a4,0xfffff
c0029a0c:	fff70713          	addi	a4,a4,-1 # ffffefff <_end+0x37f7a77f>
c0029a10:	00e7f7b3          	and	a5,a5,a4
c0029a14:	00f41623          	sh	a5,12(s0)
c0029a18:	01812403          	lw	s0,24(sp)
c0029a1c:	01c12083          	lw	ra,28(sp)
c0029a20:	00098693          	mv	a3,s3
c0029a24:	00090613          	mv	a2,s2
c0029a28:	00c12983          	lw	s3,12(sp)
c0029a2c:	01012903          	lw	s2,16(sp)
c0029a30:	00048513          	mv	a0,s1
c0029a34:	01412483          	lw	s1,20(sp)
c0029a38:	02010113          	addi	sp,sp,32
c0029a3c:	1b50206f          	j	c002c3f0 <_write_r>
c0029a40:	00200693          	li	a3,2
c0029a44:	00000613          	li	a2,0
c0029a48:	098030ef          	jal	ra,c002cae0 <_lseek_r>
c0029a4c:	00c41783          	lh	a5,12(s0)
c0029a50:	00e41583          	lh	a1,14(s0)
c0029a54:	fb5ff06f          	j	c0029a08 <__swrite+0x38>

c0029a58 <__sseek>:
c0029a58:	ff010113          	addi	sp,sp,-16
c0029a5c:	00812423          	sw	s0,8(sp)
c0029a60:	00058413          	mv	s0,a1
c0029a64:	00e59583          	lh	a1,14(a1)
c0029a68:	00112623          	sw	ra,12(sp)
c0029a6c:	074030ef          	jal	ra,c002cae0 <_lseek_r>
c0029a70:	fff00793          	li	a5,-1
c0029a74:	02f50463          	beq	a0,a5,c0029a9c <__sseek+0x44>
c0029a78:	00c45783          	lhu	a5,12(s0)
c0029a7c:	00001737          	lui	a4,0x1
c0029a80:	00c12083          	lw	ra,12(sp)
c0029a84:	00e7e7b3          	or	a5,a5,a4
c0029a88:	04a42823          	sw	a0,80(s0)
c0029a8c:	00f41623          	sh	a5,12(s0)
c0029a90:	00812403          	lw	s0,8(sp)
c0029a94:	01010113          	addi	sp,sp,16
c0029a98:	00008067          	ret
c0029a9c:	00c45783          	lhu	a5,12(s0)
c0029aa0:	fffff737          	lui	a4,0xfffff
c0029aa4:	fff70713          	addi	a4,a4,-1 # ffffefff <_end+0x37f7a77f>
c0029aa8:	00e7f7b3          	and	a5,a5,a4
c0029aac:	00c12083          	lw	ra,12(sp)
c0029ab0:	00f41623          	sh	a5,12(s0)
c0029ab4:	00812403          	lw	s0,8(sp)
c0029ab8:	01010113          	addi	sp,sp,16
c0029abc:	00008067          	ret

c0029ac0 <__sclose>:
c0029ac0:	00e59583          	lh	a1,14(a1)
c0029ac4:	2ed0206f          	j	c002c5b0 <_close_r>

c0029ac8 <strcmp>:
c0029ac8:	00b56733          	or	a4,a0,a1
c0029acc:	fff00393          	li	t2,-1
c0029ad0:	00377713          	andi	a4,a4,3
c0029ad4:	10071063          	bnez	a4,c0029bd4 <strcmp+0x10c>
c0029ad8:	7f7f87b7          	lui	a5,0x7f7f8
c0029adc:	f7f78793          	addi	a5,a5,-129 # 7f7f7f7f <_DMEM_LENGTH+0x7eff7f7f>
c0029ae0:	00052603          	lw	a2,0(a0)
c0029ae4:	0005a683          	lw	a3,0(a1)
c0029ae8:	00f672b3          	and	t0,a2,a5
c0029aec:	00f66333          	or	t1,a2,a5
c0029af0:	00f282b3          	add	t0,t0,a5
c0029af4:	0062e2b3          	or	t0,t0,t1
c0029af8:	10729263          	bne	t0,t2,c0029bfc <strcmp+0x134>
c0029afc:	08d61663          	bne	a2,a3,c0029b88 <strcmp+0xc0>
c0029b00:	00452603          	lw	a2,4(a0)
c0029b04:	0045a683          	lw	a3,4(a1)
c0029b08:	00f672b3          	and	t0,a2,a5
c0029b0c:	00f66333          	or	t1,a2,a5
c0029b10:	00f282b3          	add	t0,t0,a5
c0029b14:	0062e2b3          	or	t0,t0,t1
c0029b18:	0c729e63          	bne	t0,t2,c0029bf4 <strcmp+0x12c>
c0029b1c:	06d61663          	bne	a2,a3,c0029b88 <strcmp+0xc0>
c0029b20:	00852603          	lw	a2,8(a0)
c0029b24:	0085a683          	lw	a3,8(a1)
c0029b28:	00f672b3          	and	t0,a2,a5
c0029b2c:	00f66333          	or	t1,a2,a5
c0029b30:	00f282b3          	add	t0,t0,a5
c0029b34:	0062e2b3          	or	t0,t0,t1
c0029b38:	0c729863          	bne	t0,t2,c0029c08 <strcmp+0x140>
c0029b3c:	04d61663          	bne	a2,a3,c0029b88 <strcmp+0xc0>
c0029b40:	00c52603          	lw	a2,12(a0)
c0029b44:	00c5a683          	lw	a3,12(a1)
c0029b48:	00f672b3          	and	t0,a2,a5
c0029b4c:	00f66333          	or	t1,a2,a5
c0029b50:	00f282b3          	add	t0,t0,a5
c0029b54:	0062e2b3          	or	t0,t0,t1
c0029b58:	0c729263          	bne	t0,t2,c0029c1c <strcmp+0x154>
c0029b5c:	02d61663          	bne	a2,a3,c0029b88 <strcmp+0xc0>
c0029b60:	01052603          	lw	a2,16(a0)
c0029b64:	0105a683          	lw	a3,16(a1)
c0029b68:	00f672b3          	and	t0,a2,a5
c0029b6c:	00f66333          	or	t1,a2,a5
c0029b70:	00f282b3          	add	t0,t0,a5
c0029b74:	0062e2b3          	or	t0,t0,t1
c0029b78:	0a729c63          	bne	t0,t2,c0029c30 <strcmp+0x168>
c0029b7c:	01450513          	addi	a0,a0,20
c0029b80:	01458593          	addi	a1,a1,20
c0029b84:	f4d60ee3          	beq	a2,a3,c0029ae0 <strcmp+0x18>
c0029b88:	01061713          	slli	a4,a2,0x10
c0029b8c:	01069793          	slli	a5,a3,0x10
c0029b90:	00f71e63          	bne	a4,a5,c0029bac <strcmp+0xe4>
c0029b94:	01065713          	srli	a4,a2,0x10
c0029b98:	0106d793          	srli	a5,a3,0x10
c0029b9c:	40f70533          	sub	a0,a4,a5
c0029ba0:	0ff57593          	andi	a1,a0,255
c0029ba4:	02059063          	bnez	a1,c0029bc4 <strcmp+0xfc>
c0029ba8:	00008067          	ret
c0029bac:	01075713          	srli	a4,a4,0x10
c0029bb0:	0107d793          	srli	a5,a5,0x10
c0029bb4:	40f70533          	sub	a0,a4,a5
c0029bb8:	0ff57593          	andi	a1,a0,255
c0029bbc:	00059463          	bnez	a1,c0029bc4 <strcmp+0xfc>
c0029bc0:	00008067          	ret
c0029bc4:	0ff77713          	andi	a4,a4,255
c0029bc8:	0ff7f793          	andi	a5,a5,255
c0029bcc:	40f70533          	sub	a0,a4,a5
c0029bd0:	00008067          	ret
c0029bd4:	00054603          	lbu	a2,0(a0)
c0029bd8:	0005c683          	lbu	a3,0(a1)
c0029bdc:	00150513          	addi	a0,a0,1
c0029be0:	00158593          	addi	a1,a1,1
c0029be4:	00d61463          	bne	a2,a3,c0029bec <strcmp+0x124>
c0029be8:	fe0616e3          	bnez	a2,c0029bd4 <strcmp+0x10c>
c0029bec:	40d60533          	sub	a0,a2,a3
c0029bf0:	00008067          	ret
c0029bf4:	00450513          	addi	a0,a0,4
c0029bf8:	00458593          	addi	a1,a1,4
c0029bfc:	fcd61ce3          	bne	a2,a3,c0029bd4 <strcmp+0x10c>
c0029c00:	00000513          	li	a0,0
c0029c04:	00008067          	ret
c0029c08:	00850513          	addi	a0,a0,8
c0029c0c:	00858593          	addi	a1,a1,8
c0029c10:	fcd612e3          	bne	a2,a3,c0029bd4 <strcmp+0x10c>
c0029c14:	00000513          	li	a0,0
c0029c18:	00008067          	ret
c0029c1c:	00c50513          	addi	a0,a0,12
c0029c20:	00c58593          	addi	a1,a1,12
c0029c24:	fad618e3          	bne	a2,a3,c0029bd4 <strcmp+0x10c>
c0029c28:	00000513          	li	a0,0
c0029c2c:	00008067          	ret
c0029c30:	01050513          	addi	a0,a0,16
c0029c34:	01058593          	addi	a1,a1,16
c0029c38:	f8d61ee3          	bne	a2,a3,c0029bd4 <strcmp+0x10c>
c0029c3c:	00000513          	li	a0,0
c0029c40:	00008067          	ret

c0029c44 <strncpy>:
c0029c44:	00a5e7b3          	or	a5,a1,a0
c0029c48:	0037f793          	andi	a5,a5,3
c0029c4c:	00050713          	mv	a4,a0
c0029c50:	06079863          	bnez	a5,c0029cc0 <strncpy+0x7c>
c0029c54:	00300793          	li	a5,3
c0029c58:	06c7f463          	bgeu	a5,a2,c0029cc0 <strncpy+0x7c>
c0029c5c:	feff0337          	lui	t1,0xfeff0
c0029c60:	808088b7          	lui	a7,0x80808
c0029c64:	eff30313          	addi	t1,t1,-257 # fefefeff <_end+0x36f6b67f>
c0029c68:	08088893          	addi	a7,a7,128 # 80808080 <_end+0xb8783800>
c0029c6c:	00300e13          	li	t3,3
c0029c70:	0005a683          	lw	a3,0(a1)
c0029c74:	006687b3          	add	a5,a3,t1
c0029c78:	fff6c813          	not	a6,a3
c0029c7c:	0107f7b3          	and	a5,a5,a6
c0029c80:	0117f7b3          	and	a5,a5,a7
c0029c84:	02079e63          	bnez	a5,c0029cc0 <strncpy+0x7c>
c0029c88:	00d72023          	sw	a3,0(a4)
c0029c8c:	ffc60613          	addi	a2,a2,-4 # 7feffffc <_DMEM_LENGTH+0x7f6ffffc>
c0029c90:	00470713          	addi	a4,a4,4
c0029c94:	00458593          	addi	a1,a1,4
c0029c98:	fcce6ce3          	bltu	t3,a2,c0029c70 <strncpy+0x2c>
c0029c9c:	00158593          	addi	a1,a1,1
c0029ca0:	00170793          	addi	a5,a4,1
c0029ca4:	02060463          	beqz	a2,c0029ccc <strncpy+0x88>
c0029ca8:	fff5c683          	lbu	a3,-1(a1)
c0029cac:	fff60813          	addi	a6,a2,-1
c0029cb0:	fed78fa3          	sb	a3,-1(a5)
c0029cb4:	00068e63          	beqz	a3,c0029cd0 <strncpy+0x8c>
c0029cb8:	00078713          	mv	a4,a5
c0029cbc:	00080613          	mv	a2,a6
c0029cc0:	00158593          	addi	a1,a1,1
c0029cc4:	00170793          	addi	a5,a4,1
c0029cc8:	fe0610e3          	bnez	a2,c0029ca8 <strncpy+0x64>
c0029ccc:	00008067          	ret
c0029cd0:	00c70633          	add	a2,a4,a2
c0029cd4:	00080a63          	beqz	a6,c0029ce8 <strncpy+0xa4>
c0029cd8:	00178793          	addi	a5,a5,1
c0029cdc:	fe078fa3          	sb	zero,-1(a5)
c0029ce0:	fec79ce3          	bne	a5,a2,c0029cd8 <strncpy+0x94>
c0029ce4:	00008067          	ret
c0029ce8:	00008067          	ret

c0029cec <__ssprint_r>:
c0029cec:	00862783          	lw	a5,8(a2)
c0029cf0:	fd010113          	addi	sp,sp,-48
c0029cf4:	01512a23          	sw	s5,20(sp)
c0029cf8:	02112623          	sw	ra,44(sp)
c0029cfc:	02812423          	sw	s0,40(sp)
c0029d00:	02912223          	sw	s1,36(sp)
c0029d04:	03212023          	sw	s2,32(sp)
c0029d08:	01312e23          	sw	s3,28(sp)
c0029d0c:	01412c23          	sw	s4,24(sp)
c0029d10:	01612823          	sw	s6,16(sp)
c0029d14:	01712623          	sw	s7,12(sp)
c0029d18:	01812423          	sw	s8,8(sp)
c0029d1c:	00060a93          	mv	s5,a2
c0029d20:	14078863          	beqz	a5,c0029e70 <__ssprint_r+0x184>
c0029d24:	00050b13          	mv	s6,a0
c0029d28:	00062983          	lw	s3,0(a2)
c0029d2c:	0005a503          	lw	a0,0(a1)
c0029d30:	0085a483          	lw	s1,8(a1)
c0029d34:	00058413          	mv	s0,a1
c0029d38:	0d40006f          	j	c0029e0c <__ssprint_r+0x120>
c0029d3c:	00c45783          	lhu	a5,12(s0)
c0029d40:	4807f713          	andi	a4,a5,1152
c0029d44:	08070a63          	beqz	a4,c0029dd8 <__ssprint_r+0xec>
c0029d48:	01442683          	lw	a3,20(s0)
c0029d4c:	01042583          	lw	a1,16(s0)
c0029d50:	00190713          	addi	a4,s2,1
c0029d54:	00169493          	slli	s1,a3,0x1
c0029d58:	00d486b3          	add	a3,s1,a3
c0029d5c:	01f6d493          	srli	s1,a3,0x1f
c0029d60:	40b50a33          	sub	s4,a0,a1
c0029d64:	00d484b3          	add	s1,s1,a3
c0029d68:	4014d493          	srai	s1,s1,0x1
c0029d6c:	01470733          	add	a4,a4,s4
c0029d70:	00048613          	mv	a2,s1
c0029d74:	00e4f663          	bgeu	s1,a4,c0029d80 <__ssprint_r+0x94>
c0029d78:	00070493          	mv	s1,a4
c0029d7c:	00070613          	mv	a2,a4
c0029d80:	4007f793          	andi	a5,a5,1024
c0029d84:	0a078663          	beqz	a5,c0029e30 <__ssprint_r+0x144>
c0029d88:	00060593          	mv	a1,a2
c0029d8c:	000b0513          	mv	a0,s6
c0029d90:	93dfd0ef          	jal	ra,c00276cc <_malloc_r>
c0029d94:	00050c13          	mv	s8,a0
c0029d98:	0a050a63          	beqz	a0,c0029e4c <__ssprint_r+0x160>
c0029d9c:	01042583          	lw	a1,16(s0)
c0029da0:	000a0613          	mv	a2,s4
c0029da4:	dbdf30ef          	jal	ra,c001db60 <memcpy>
c0029da8:	00c45783          	lhu	a5,12(s0)
c0029dac:	b7f7f793          	andi	a5,a5,-1153
c0029db0:	0807e793          	ori	a5,a5,128
c0029db4:	00f41623          	sh	a5,12(s0)
c0029db8:	014c0533          	add	a0,s8,s4
c0029dbc:	41448a33          	sub	s4,s1,s4
c0029dc0:	00942a23          	sw	s1,20(s0)
c0029dc4:	01442423          	sw	s4,8(s0)
c0029dc8:	01842823          	sw	s8,16(s0)
c0029dcc:	00a42023          	sw	a0,0(s0)
c0029dd0:	00090493          	mv	s1,s2
c0029dd4:	00090a13          	mv	s4,s2
c0029dd8:	000a0613          	mv	a2,s4
c0029ddc:	000b8593          	mv	a1,s7
c0029de0:	9e0fe0ef          	jal	ra,c0027fc0 <memmove>
c0029de4:	00842703          	lw	a4,8(s0)
c0029de8:	00042503          	lw	a0,0(s0)
c0029dec:	008aa783          	lw	a5,8(s5)
c0029df0:	409704b3          	sub	s1,a4,s1
c0029df4:	01450533          	add	a0,a0,s4
c0029df8:	00942423          	sw	s1,8(s0)
c0029dfc:	00a42023          	sw	a0,0(s0)
c0029e00:	41278933          	sub	s2,a5,s2
c0029e04:	012aa423          	sw	s2,8(s5)
c0029e08:	06090463          	beqz	s2,c0029e70 <__ssprint_r+0x184>
c0029e0c:	0049a903          	lw	s2,4(s3)
c0029e10:	0009ab83          	lw	s7,0(s3)
c0029e14:	00048a13          	mv	s4,s1
c0029e18:	00898993          	addi	s3,s3,8
c0029e1c:	fe0908e3          	beqz	s2,c0029e0c <__ssprint_r+0x120>
c0029e20:	f0997ee3          	bgeu	s2,s1,c0029d3c <__ssprint_r+0x50>
c0029e24:	00090493          	mv	s1,s2
c0029e28:	00090a13          	mv	s4,s2
c0029e2c:	fadff06f          	j	c0029dd8 <__ssprint_r+0xec>
c0029e30:	000b0513          	mv	a0,s6
c0029e34:	cb4ff0ef          	jal	ra,c00292e8 <_realloc_r>
c0029e38:	00050c13          	mv	s8,a0
c0029e3c:	f6051ee3          	bnez	a0,c0029db8 <__ssprint_r+0xcc>
c0029e40:	01042583          	lw	a1,16(s0)
c0029e44:	000b0513          	mv	a0,s6
c0029e48:	810fa0ef          	jal	ra,c0023e58 <_free_r>
c0029e4c:	00c00793          	li	a5,12
c0029e50:	00fb2023          	sw	a5,0(s6)
c0029e54:	00c45783          	lhu	a5,12(s0)
c0029e58:	fff00513          	li	a0,-1
c0029e5c:	0407e793          	ori	a5,a5,64
c0029e60:	00f41623          	sh	a5,12(s0)
c0029e64:	000aa423          	sw	zero,8(s5)
c0029e68:	000aa223          	sw	zero,4(s5)
c0029e6c:	00c0006f          	j	c0029e78 <__ssprint_r+0x18c>
c0029e70:	000aa223          	sw	zero,4(s5)
c0029e74:	00000513          	li	a0,0
c0029e78:	02c12083          	lw	ra,44(sp)
c0029e7c:	02812403          	lw	s0,40(sp)
c0029e80:	02412483          	lw	s1,36(sp)
c0029e84:	02012903          	lw	s2,32(sp)
c0029e88:	01c12983          	lw	s3,28(sp)
c0029e8c:	01812a03          	lw	s4,24(sp)
c0029e90:	01412a83          	lw	s5,20(sp)
c0029e94:	01012b03          	lw	s6,16(sp)
c0029e98:	00c12b83          	lw	s7,12(sp)
c0029e9c:	00812c03          	lw	s8,8(sp)
c0029ea0:	03010113          	addi	sp,sp,48
c0029ea4:	00008067          	ret

c0029ea8 <_svfiprintf_r>:
c0029ea8:	00c5d783          	lhu	a5,12(a1)
c0029eac:	ed010113          	addi	sp,sp,-304
c0029eb0:	11412c23          	sw	s4,280(sp)
c0029eb4:	11612823          	sw	s6,272(sp)
c0029eb8:	0fb12e23          	sw	s11,252(sp)
c0029ebc:	12112623          	sw	ra,300(sp)
c0029ec0:	12812423          	sw	s0,296(sp)
c0029ec4:	12912223          	sw	s1,292(sp)
c0029ec8:	13212023          	sw	s2,288(sp)
c0029ecc:	11312e23          	sw	s3,284(sp)
c0029ed0:	11512a23          	sw	s5,276(sp)
c0029ed4:	11712623          	sw	s7,268(sp)
c0029ed8:	11812423          	sw	s8,264(sp)
c0029edc:	11912223          	sw	s9,260(sp)
c0029ee0:	11a12023          	sw	s10,256(sp)
c0029ee4:	0807f793          	andi	a5,a5,128
c0029ee8:	00d12623          	sw	a3,12(sp)
c0029eec:	00058a13          	mv	s4,a1
c0029ef0:	00050b13          	mv	s6,a0
c0029ef4:	00060d93          	mv	s11,a2
c0029ef8:	00078663          	beqz	a5,c0029f04 <_svfiprintf_r+0x5c>
c0029efc:	0105a783          	lw	a5,16(a1)
c0029f00:	5e0788e3          	beqz	a5,c002acf0 <_svfiprintf_r+0xe48>
c0029f04:	c80027b7          	lui	a5,0xc8002
c0029f08:	04c10a93          	addi	s5,sp,76
c0029f0c:	10078793          	addi	a5,a5,256 # c8002100 <_end+0xfff7d880>
c0029f10:	c8002c37          	lui	s8,0xc8002
c0029f14:	c80024b7          	lui	s1,0xc8002
c0029f18:	000d8993          	mv	s3,s11
c0029f1c:	05512023          	sw	s5,64(sp)
c0029f20:	04012423          	sw	zero,72(sp)
c0029f24:	04012223          	sw	zero,68(sp)
c0029f28:	00012a23          	sw	zero,20(sp)
c0029f2c:	00012c23          	sw	zero,24(sp)
c0029f30:	02012023          	sw	zero,32(sp)
c0029f34:	00012e23          	sw	zero,28(sp)
c0029f38:	00012423          	sw	zero,8(sp)
c0029f3c:	00f12823          	sw	a5,16(sp)
c0029f40:	26cc0c13          	addi	s8,s8,620 # c800226c <_end+0xfff7d9ec>
c0029f44:	27c48493          	addi	s1,s1,636 # c800227c <_end+0xfff7d9fc>
c0029f48:	000a8d93          	mv	s11,s5
c0029f4c:	0009c783          	lbu	a5,0(s3)
c0029f50:	20078c63          	beqz	a5,c002a168 <_svfiprintf_r+0x2c0>
c0029f54:	00098413          	mv	s0,s3
c0029f58:	02500693          	li	a3,37
c0029f5c:	2ad78863          	beq	a5,a3,c002a20c <_svfiprintf_r+0x364>
c0029f60:	00144783          	lbu	a5,1(s0)
c0029f64:	00140413          	addi	s0,s0,1
c0029f68:	fe079ae3          	bnez	a5,c0029f5c <_svfiprintf_r+0xb4>
c0029f6c:	41340bb3          	sub	s7,s0,s3
c0029f70:	1f340c63          	beq	s0,s3,c002a168 <_svfiprintf_r+0x2c0>
c0029f74:	04812683          	lw	a3,72(sp)
c0029f78:	04412783          	lw	a5,68(sp)
c0029f7c:	013da023          	sw	s3,0(s11)
c0029f80:	017686b3          	add	a3,a3,s7
c0029f84:	00178793          	addi	a5,a5,1
c0029f88:	017da223          	sw	s7,4(s11)
c0029f8c:	04d12423          	sw	a3,72(sp)
c0029f90:	04f12223          	sw	a5,68(sp)
c0029f94:	00700693          	li	a3,7
c0029f98:	008d8d93          	addi	s11,s11,8
c0029f9c:	28f6c063          	blt	a3,a5,c002a21c <_svfiprintf_r+0x374>
c0029fa0:	00812703          	lw	a4,8(sp)
c0029fa4:	00044783          	lbu	a5,0(s0)
c0029fa8:	01770733          	add	a4,a4,s7
c0029fac:	00e12423          	sw	a4,8(sp)
c0029fb0:	1a078c63          	beqz	a5,c002a168 <_svfiprintf_r+0x2c0>
c0029fb4:	fff00893          	li	a7,-1
c0029fb8:	00144683          	lbu	a3,1(s0)
c0029fbc:	00140993          	addi	s3,s0,1
c0029fc0:	02010da3          	sb	zero,59(sp)
c0029fc4:	00012223          	sw	zero,4(sp)
c0029fc8:	00000913          	li	s2,0
c0029fcc:	05a00b93          	li	s7,90
c0029fd0:	00900c93          	li	s9,9
c0029fd4:	02a00593          	li	a1,42
c0029fd8:	00088413          	mv	s0,a7
c0029fdc:	00198993          	addi	s3,s3,1
c0029fe0:	fe068793          	addi	a5,a3,-32
c0029fe4:	04fbe863          	bltu	s7,a5,c002a034 <_svfiprintf_r+0x18c>
c0029fe8:	01012703          	lw	a4,16(sp)
c0029fec:	00279793          	slli	a5,a5,0x2
c0029ff0:	00e787b3          	add	a5,a5,a4
c0029ff4:	0007a783          	lw	a5,0(a5)
c0029ff8:	00078067          	jr	a5
c0029ffc:	00012223          	sw	zero,4(sp)
c002a000:	fd068793          	addi	a5,a3,-48
c002a004:	00412603          	lw	a2,4(sp)
c002a008:	0009c683          	lbu	a3,0(s3)
c002a00c:	00198993          	addi	s3,s3,1
c002a010:	00261713          	slli	a4,a2,0x2
c002a014:	00c70733          	add	a4,a4,a2
c002a018:	00171713          	slli	a4,a4,0x1
c002a01c:	00e787b3          	add	a5,a5,a4
c002a020:	00f12223          	sw	a5,4(sp)
c002a024:	fd068793          	addi	a5,a3,-48
c002a028:	fcfcfee3          	bgeu	s9,a5,c002a004 <_svfiprintf_r+0x15c>
c002a02c:	fe068793          	addi	a5,a3,-32
c002a030:	fafbfce3          	bgeu	s7,a5,c0029fe8 <_svfiprintf_r+0x140>
c002a034:	12068a63          	beqz	a3,c002a168 <_svfiprintf_r+0x2c0>
c002a038:	08d10623          	sb	a3,140(sp)
c002a03c:	02010da3          	sb	zero,59(sp)
c002a040:	00100b93          	li	s7,1
c002a044:	00100c93          	li	s9,1
c002a048:	08c10413          	addi	s0,sp,140
c002a04c:	00000893          	li	a7,0
c002a050:	00297f13          	andi	t5,s2,2
c002a054:	000f0463          	beqz	t5,c002a05c <_svfiprintf_r+0x1b4>
c002a058:	002b8b93          	addi	s7,s7,2
c002a05c:	08497e93          	andi	t4,s2,132
c002a060:	04812783          	lw	a5,72(sp)
c002a064:	04412603          	lw	a2,68(sp)
c002a068:	000e9863          	bnez	t4,c002a078 <_svfiprintf_r+0x1d0>
c002a06c:	00412703          	lw	a4,4(sp)
c002a070:	41770d33          	sub	s10,a4,s7
c002a074:	7ba04a63          	bgtz	s10,c002a828 <_svfiprintf_r+0x980>
c002a078:	03b14503          	lbu	a0,59(sp)
c002a07c:	00160593          	addi	a1,a2,1
c002a080:	008d8693          	addi	a3,s11,8
c002a084:	04050063          	beqz	a0,c002a0c4 <_svfiprintf_r+0x21c>
c002a088:	03b10513          	addi	a0,sp,59
c002a08c:	00178793          	addi	a5,a5,1
c002a090:	00ada023          	sw	a0,0(s11)
c002a094:	00100513          	li	a0,1
c002a098:	00ada223          	sw	a0,4(s11)
c002a09c:	04f12423          	sw	a5,72(sp)
c002a0a0:	04b12223          	sw	a1,68(sp)
c002a0a4:	00700513          	li	a0,7
c002a0a8:	0ab544e3          	blt	a0,a1,c002a950 <_svfiprintf_r+0xaa8>
c002a0ac:	00260f93          	addi	t6,a2,2
c002a0b0:	010d8513          	addi	a0,s11,16
c002a0b4:	00058613          	mv	a2,a1
c002a0b8:	00068d93          	mv	s11,a3
c002a0bc:	000f8593          	mv	a1,t6
c002a0c0:	00050693          	mv	a3,a0
c002a0c4:	020f0c63          	beqz	t5,c002a0fc <_svfiprintf_r+0x254>
c002a0c8:	03c10613          	addi	a2,sp,60
c002a0cc:	00278793          	addi	a5,a5,2
c002a0d0:	00cda023          	sw	a2,0(s11)
c002a0d4:	00200613          	li	a2,2
c002a0d8:	00cda223          	sw	a2,4(s11)
c002a0dc:	04f12423          	sw	a5,72(sp)
c002a0e0:	04b12223          	sw	a1,68(sp)
c002a0e4:	00700713          	li	a4,7
c002a0e8:	0ab746e3          	blt	a4,a1,c002a994 <_svfiprintf_r+0xaec>
c002a0ec:	00058613          	mv	a2,a1
c002a0f0:	00068d93          	mv	s11,a3
c002a0f4:	00158593          	addi	a1,a1,1
c002a0f8:	00868693          	addi	a3,a3,8
c002a0fc:	08000513          	li	a0,128
c002a100:	54ae8c63          	beq	t4,a0,c002a658 <_svfiprintf_r+0x7b0>
c002a104:	41988d33          	sub	s10,a7,s9
c002a108:	63a04463          	bgtz	s10,c002a730 <_svfiprintf_r+0x888>
c002a10c:	00fc87b3          	add	a5,s9,a5
c002a110:	008da023          	sw	s0,0(s11)
c002a114:	019da223          	sw	s9,4(s11)
c002a118:	04f12423          	sw	a5,72(sp)
c002a11c:	04b12223          	sw	a1,68(sp)
c002a120:	00700713          	li	a4,7
c002a124:	6cb74263          	blt	a4,a1,c002a7e8 <_svfiprintf_r+0x940>
c002a128:	00497313          	andi	t1,s2,4
c002a12c:	00030863          	beqz	t1,c002a13c <_svfiprintf_r+0x294>
c002a130:	00412703          	lw	a4,4(sp)
c002a134:	41770cb3          	sub	s9,a4,s7
c002a138:	09904ce3          	bgtz	s9,c002a9d0 <_svfiprintf_r+0xb28>
c002a13c:	00412403          	lw	s0,4(sp)
c002a140:	01745463          	bge	s0,s7,c002a148 <_svfiprintf_r+0x2a0>
c002a144:	000b8413          	mv	s0,s7
c002a148:	00812703          	lw	a4,8(sp)
c002a14c:	00870733          	add	a4,a4,s0
c002a150:	00e12423          	sw	a4,8(sp)
c002a154:	6a079a63          	bnez	a5,c002a808 <_svfiprintf_r+0x960>
c002a158:	0009c783          	lbu	a5,0(s3)
c002a15c:	04012223          	sw	zero,68(sp)
c002a160:	000a8d93          	mv	s11,s5
c002a164:	de0798e3          	bnez	a5,c0029f54 <_svfiprintf_r+0xac>
c002a168:	04812783          	lw	a5,72(sp)
c002a16c:	580792e3          	bnez	a5,c002aef0 <_svfiprintf_r+0x1048>
c002a170:	00ca5783          	lhu	a5,12(s4)
c002a174:	0407f793          	andi	a5,a5,64
c002a178:	5a0798e3          	bnez	a5,c002af28 <_svfiprintf_r+0x1080>
c002a17c:	12c12083          	lw	ra,300(sp)
c002a180:	12812403          	lw	s0,296(sp)
c002a184:	00812503          	lw	a0,8(sp)
c002a188:	12412483          	lw	s1,292(sp)
c002a18c:	12012903          	lw	s2,288(sp)
c002a190:	11c12983          	lw	s3,284(sp)
c002a194:	11812a03          	lw	s4,280(sp)
c002a198:	11412a83          	lw	s5,276(sp)
c002a19c:	11012b03          	lw	s6,272(sp)
c002a1a0:	10c12b83          	lw	s7,268(sp)
c002a1a4:	10812c03          	lw	s8,264(sp)
c002a1a8:	10412c83          	lw	s9,260(sp)
c002a1ac:	10012d03          	lw	s10,256(sp)
c002a1b0:	0fc12d83          	lw	s11,252(sp)
c002a1b4:	13010113          	addi	sp,sp,304
c002a1b8:	00008067          	ret
c002a1bc:	000b0513          	mv	a0,s6
c002a1c0:	990fd0ef          	jal	ra,c0027350 <_localeconv_r>
c002a1c4:	00452783          	lw	a5,4(a0)
c002a1c8:	00078513          	mv	a0,a5
c002a1cc:	00f12e23          	sw	a5,28(sp)
c002a1d0:	e99f30ef          	jal	ra,c001e068 <strlen>
c002a1d4:	00050793          	mv	a5,a0
c002a1d8:	000b0513          	mv	a0,s6
c002a1dc:	00078d13          	mv	s10,a5
c002a1e0:	02f12023          	sw	a5,32(sp)
c002a1e4:	96cfd0ef          	jal	ra,c0027350 <_localeconv_r>
c002a1e8:	00852783          	lw	a5,8(a0)
c002a1ec:	02a00593          	li	a1,42
c002a1f0:	00f12c23          	sw	a5,24(sp)
c002a1f4:	1e0d1ce3          	bnez	s10,c002abec <_svfiprintf_r+0xd44>
c002a1f8:	0009c683          	lbu	a3,0(s3)
c002a1fc:	de1ff06f          	j	c0029fdc <_svfiprintf_r+0x134>
c002a200:	0009c683          	lbu	a3,0(s3)
c002a204:	02096913          	ori	s2,s2,32
c002a208:	dd5ff06f          	j	c0029fdc <_svfiprintf_r+0x134>
c002a20c:	41340bb3          	sub	s7,s0,s3
c002a210:	d73412e3          	bne	s0,s3,c0029f74 <_svfiprintf_r+0xcc>
c002a214:	00044783          	lbu	a5,0(s0)
c002a218:	d99ff06f          	j	c0029fb0 <_svfiprintf_r+0x108>
c002a21c:	04010613          	addi	a2,sp,64
c002a220:	000a0593          	mv	a1,s4
c002a224:	000b0513          	mv	a0,s6
c002a228:	ac5ff0ef          	jal	ra,c0029cec <__ssprint_r>
c002a22c:	f40512e3          	bnez	a0,c002a170 <_svfiprintf_r+0x2c8>
c002a230:	000a8d93          	mv	s11,s5
c002a234:	d6dff06f          	j	c0029fa0 <_svfiprintf_r+0xf8>
c002a238:	00c12783          	lw	a5,12(sp)
c002a23c:	00040893          	mv	a7,s0
c002a240:	02010da3          	sb	zero,59(sp)
c002a244:	0007a403          	lw	s0,0(a5)
c002a248:	00478d13          	addi	s10,a5,4
c002a24c:	380408e3          	beqz	s0,c002addc <_svfiprintf_r+0xf34>
c002a250:	fff00793          	li	a5,-1
c002a254:	28f882e3          	beq	a7,a5,c002acd8 <_svfiprintf_r+0xe30>
c002a258:	00088613          	mv	a2,a7
c002a25c:	00000593          	li	a1,0
c002a260:	00040513          	mv	a0,s0
c002a264:	01112623          	sw	a7,12(sp)
c002a268:	c91fd0ef          	jal	ra,c0027ef8 <memchr>
c002a26c:	00c12883          	lw	a7,12(sp)
c002a270:	48050ae3          	beqz	a0,c002af04 <_svfiprintf_r+0x105c>
c002a274:	40850cb3          	sub	s9,a0,s0
c002a278:	01a12623          	sw	s10,12(sp)
c002a27c:	00000893          	li	a7,0
c002a280:	0940006f          	j	c002a314 <_svfiprintf_r+0x46c>
c002a284:	00c12703          	lw	a4,12(sp)
c002a288:	02010da3          	sb	zero,59(sp)
c002a28c:	00100b93          	li	s7,1
c002a290:	00072783          	lw	a5,0(a4)
c002a294:	00470713          	addi	a4,a4,4
c002a298:	00e12623          	sw	a4,12(sp)
c002a29c:	08f10623          	sb	a5,140(sp)
c002a2a0:	00100c93          	li	s9,1
c002a2a4:	08c10413          	addi	s0,sp,140
c002a2a8:	da5ff06f          	j	c002a04c <_svfiprintf_r+0x1a4>
c002a2ac:	02097793          	andi	a5,s2,32
c002a2b0:	00040893          	mv	a7,s0
c002a2b4:	0e078e63          	beqz	a5,c002a3b0 <_svfiprintf_r+0x508>
c002a2b8:	00c12783          	lw	a5,12(sp)
c002a2bc:	00778793          	addi	a5,a5,7
c002a2c0:	ff87f793          	andi	a5,a5,-8
c002a2c4:	0047a683          	lw	a3,4(a5)
c002a2c8:	0007ac83          	lw	s9,0(a5)
c002a2cc:	00878793          	addi	a5,a5,8
c002a2d0:	00f12623          	sw	a5,12(sp)
c002a2d4:	00068b93          	mv	s7,a3
c002a2d8:	1006c463          	bltz	a3,c002a3e0 <_svfiprintf_r+0x538>
c002a2dc:	fff00693          	li	a3,-1
c002a2e0:	00090d13          	mv	s10,s2
c002a2e4:	00d88863          	beq	a7,a3,c002a2f4 <_svfiprintf_r+0x44c>
c002a2e8:	017ce6b3          	or	a3,s9,s7
c002a2ec:	f7f97d13          	andi	s10,s2,-129
c002a2f0:	78068263          	beqz	a3,c002aa74 <_svfiprintf_r+0xbcc>
c002a2f4:	020b90e3          	bnez	s7,c002ab14 <_svfiprintf_r+0xc6c>
c002a2f8:	00900693          	li	a3,9
c002a2fc:	0196ece3          	bltu	a3,s9,c002ab14 <_svfiprintf_r+0xc6c>
c002a300:	030c8793          	addi	a5,s9,48
c002a304:	0ef107a3          	sb	a5,239(sp)
c002a308:	000d0913          	mv	s2,s10
c002a30c:	00100c93          	li	s9,1
c002a310:	0ef10413          	addi	s0,sp,239
c002a314:	00088b93          	mv	s7,a7
c002a318:	0198d463          	bge	a7,s9,c002a320 <_svfiprintf_r+0x478>
c002a31c:	000c8b93          	mv	s7,s9
c002a320:	03b14783          	lbu	a5,59(sp)
c002a324:	00f037b3          	snez	a5,a5
c002a328:	00fb8bb3          	add	s7,s7,a5
c002a32c:	d25ff06f          	j	c002a050 <_svfiprintf_r+0x1a8>
c002a330:	00040893          	mv	a7,s0
c002a334:	01096913          	ori	s2,s2,16
c002a338:	02097793          	andi	a5,s2,32
c002a33c:	74078863          	beqz	a5,c002aa8c <_svfiprintf_r+0xbe4>
c002a340:	00c12783          	lw	a5,12(sp)
c002a344:	00778793          	addi	a5,a5,7
c002a348:	ff87f793          	andi	a5,a5,-8
c002a34c:	0007ac83          	lw	s9,0(a5)
c002a350:	0047ab83          	lw	s7,4(a5)
c002a354:	00878793          	addi	a5,a5,8
c002a358:	00f12623          	sw	a5,12(sp)
c002a35c:	bff97d13          	andi	s10,s2,-1025
c002a360:	00000693          	li	a3,0
c002a364:	02010da3          	sb	zero,59(sp)
c002a368:	fff00613          	li	a2,-1
c002a36c:	08c88e63          	beq	a7,a2,c002a408 <_svfiprintf_r+0x560>
c002a370:	017ce633          	or	a2,s9,s7
c002a374:	f7fd7913          	andi	s2,s10,-129
c002a378:	4a061463          	bnez	a2,c002a820 <_svfiprintf_r+0x978>
c002a37c:	28089263          	bnez	a7,c002a600 <_svfiprintf_r+0x758>
c002a380:	6e069e63          	bnez	a3,c002aa7c <_svfiprintf_r+0xbd4>
c002a384:	001d7c93          	andi	s9,s10,1
c002a388:	0f010413          	addi	s0,sp,240
c002a38c:	f80c84e3          	beqz	s9,c002a314 <_svfiprintf_r+0x46c>
c002a390:	03000793          	li	a5,48
c002a394:	0ef107a3          	sb	a5,239(sp)
c002a398:	0ef10413          	addi	s0,sp,239
c002a39c:	f79ff06f          	j	c002a314 <_svfiprintf_r+0x46c>
c002a3a0:	01096913          	ori	s2,s2,16
c002a3a4:	02097793          	andi	a5,s2,32
c002a3a8:	00040893          	mv	a7,s0
c002a3ac:	f00796e3          	bnez	a5,c002a2b8 <_svfiprintf_r+0x410>
c002a3b0:	00c12703          	lw	a4,12(sp)
c002a3b4:	01097793          	andi	a5,s2,16
c002a3b8:	00470693          	addi	a3,a4,4
c002a3bc:	040796e3          	bnez	a5,c002ac08 <_svfiprintf_r+0xd60>
c002a3c0:	04097793          	andi	a5,s2,64
c002a3c4:	26078ae3          	beqz	a5,c002ae38 <_svfiprintf_r+0xf90>
c002a3c8:	00c12783          	lw	a5,12(sp)
c002a3cc:	00d12623          	sw	a3,12(sp)
c002a3d0:	00079c83          	lh	s9,0(a5)
c002a3d4:	41fcdb93          	srai	s7,s9,0x1f
c002a3d8:	000b8693          	mv	a3,s7
c002a3dc:	f006d0e3          	bgez	a3,c002a2dc <_svfiprintf_r+0x434>
c002a3e0:	019036b3          	snez	a3,s9
c002a3e4:	41700eb3          	neg	t4,s7
c002a3e8:	40de8bb3          	sub	s7,t4,a3
c002a3ec:	02d00693          	li	a3,45
c002a3f0:	02d10da3          	sb	a3,59(sp)
c002a3f4:	fff00613          	li	a2,-1
c002a3f8:	41900cb3          	neg	s9,s9
c002a3fc:	00090d13          	mv	s10,s2
c002a400:	00100693          	li	a3,1
c002a404:	f6c896e3          	bne	a7,a2,c002a370 <_svfiprintf_r+0x4c8>
c002a408:	00100613          	li	a2,1
c002a40c:	eec684e3          	beq	a3,a2,c002a2f4 <_svfiprintf_r+0x44c>
c002a410:	00200613          	li	a2,2
c002a414:	20c68063          	beq	a3,a2,c002a614 <_svfiprintf_r+0x76c>
c002a418:	0f010413          	addi	s0,sp,240
c002a41c:	01db9793          	slli	a5,s7,0x1d
c002a420:	007cf693          	andi	a3,s9,7
c002a424:	003cdc93          	srli	s9,s9,0x3
c002a428:	03068693          	addi	a3,a3,48
c002a42c:	0197ecb3          	or	s9,a5,s9
c002a430:	003bdb93          	srli	s7,s7,0x3
c002a434:	fed40fa3          	sb	a3,-1(s0)
c002a438:	017ce7b3          	or	a5,s9,s7
c002a43c:	00040593          	mv	a1,s0
c002a440:	fff40413          	addi	s0,s0,-1
c002a444:	fc079ce3          	bnez	a5,c002a41c <_svfiprintf_r+0x574>
c002a448:	001d7793          	andi	a5,s10,1
c002a44c:	1e078e63          	beqz	a5,c002a648 <_svfiprintf_r+0x7a0>
c002a450:	03000793          	li	a5,48
c002a454:	1ef68a63          	beq	a3,a5,c002a648 <_svfiprintf_r+0x7a0>
c002a458:	ffe58593          	addi	a1,a1,-2
c002a45c:	fef40fa3          	sb	a5,-1(s0)
c002a460:	0f010793          	addi	a5,sp,240
c002a464:	40b78cb3          	sub	s9,a5,a1
c002a468:	000d0913          	mv	s2,s10
c002a46c:	00058413          	mv	s0,a1
c002a470:	ea5ff06f          	j	c002a314 <_svfiprintf_r+0x46c>
c002a474:	00040893          	mv	a7,s0
c002a478:	01096d13          	ori	s10,s2,16
c002a47c:	020d7793          	andi	a5,s10,32
c002a480:	62078c63          	beqz	a5,c002aab8 <_svfiprintf_r+0xc10>
c002a484:	00c12783          	lw	a5,12(sp)
c002a488:	00100693          	li	a3,1
c002a48c:	00778913          	addi	s2,a5,7
c002a490:	ff897913          	andi	s2,s2,-8
c002a494:	00890793          	addi	a5,s2,8
c002a498:	00092c83          	lw	s9,0(s2)
c002a49c:	00492b83          	lw	s7,4(s2)
c002a4a0:	00f12623          	sw	a5,12(sp)
c002a4a4:	ec1ff06f          	j	c002a364 <_svfiprintf_r+0x4bc>
c002a4a8:	00c12783          	lw	a5,12(sp)
c002a4ac:	ffff86b7          	lui	a3,0xffff8
c002a4b0:	8306c693          	xori	a3,a3,-2000
c002a4b4:	0007ac83          	lw	s9,0(a5)
c002a4b8:	00478793          	addi	a5,a5,4
c002a4bc:	00f12623          	sw	a5,12(sp)
c002a4c0:	c80027b7          	lui	a5,0xc8002
c002a4c4:	6e478793          	addi	a5,a5,1764 # c80026e4 <_end+0xfff7de64>
c002a4c8:	02d11e23          	sh	a3,60(sp)
c002a4cc:	00040893          	mv	a7,s0
c002a4d0:	00000b93          	li	s7,0
c002a4d4:	00296d13          	ori	s10,s2,2
c002a4d8:	00f12a23          	sw	a5,20(sp)
c002a4dc:	00200693          	li	a3,2
c002a4e0:	e85ff06f          	j	c002a364 <_svfiprintf_r+0x4bc>
c002a4e4:	0009c683          	lbu	a3,0(s3)
c002a4e8:	08096913          	ori	s2,s2,128
c002a4ec:	af1ff06f          	j	c0029fdc <_svfiprintf_r+0x134>
c002a4f0:	0009c683          	lbu	a3,0(s3)
c002a4f4:	00198713          	addi	a4,s3,1
c002a4f8:	22b68ee3          	beq	a3,a1,c002af34 <_svfiprintf_r+0x108c>
c002a4fc:	fd068793          	addi	a5,a3,-48 # ffff7fd0 <_end+0x37f73750>
c002a500:	00070993          	mv	s3,a4
c002a504:	00000413          	li	s0,0
c002a508:	acfcece3          	bltu	s9,a5,c0029fe0 <_svfiprintf_r+0x138>
c002a50c:	0009c683          	lbu	a3,0(s3)
c002a510:	00241713          	slli	a4,s0,0x2
c002a514:	008708b3          	add	a7,a4,s0
c002a518:	00189893          	slli	a7,a7,0x1
c002a51c:	00f88433          	add	s0,a7,a5
c002a520:	fd068793          	addi	a5,a3,-48
c002a524:	00198993          	addi	s3,s3,1
c002a528:	fefcf2e3          	bgeu	s9,a5,c002a50c <_svfiprintf_r+0x664>
c002a52c:	ab5ff06f          	j	c0029fe0 <_svfiprintf_r+0x138>
c002a530:	0009c683          	lbu	a3,0(s3)
c002a534:	00496913          	ori	s2,s2,4
c002a538:	aa5ff06f          	j	c0029fdc <_svfiprintf_r+0x134>
c002a53c:	02b00793          	li	a5,43
c002a540:	0009c683          	lbu	a3,0(s3)
c002a544:	02f10da3          	sb	a5,59(sp)
c002a548:	a95ff06f          	j	c0029fdc <_svfiprintf_r+0x134>
c002a54c:	00c12703          	lw	a4,12(sp)
c002a550:	0009c683          	lbu	a3,0(s3)
c002a554:	00072783          	lw	a5,0(a4)
c002a558:	00470713          	addi	a4,a4,4
c002a55c:	00e12623          	sw	a4,12(sp)
c002a560:	00f12223          	sw	a5,4(sp)
c002a564:	a607dce3          	bgez	a5,c0029fdc <_svfiprintf_r+0x134>
c002a568:	40f007b3          	neg	a5,a5
c002a56c:	00f12223          	sw	a5,4(sp)
c002a570:	00496913          	ori	s2,s2,4
c002a574:	a69ff06f          	j	c0029fdc <_svfiprintf_r+0x134>
c002a578:	0009c683          	lbu	a3,0(s3)
c002a57c:	00196913          	ori	s2,s2,1
c002a580:	a5dff06f          	j	c0029fdc <_svfiprintf_r+0x134>
c002a584:	03b14783          	lbu	a5,59(sp)
c002a588:	0009c683          	lbu	a3,0(s3)
c002a58c:	a40798e3          	bnez	a5,c0029fdc <_svfiprintf_r+0x134>
c002a590:	02000793          	li	a5,32
c002a594:	02f10da3          	sb	a5,59(sp)
c002a598:	a45ff06f          	j	c0029fdc <_svfiprintf_r+0x134>
c002a59c:	0009c683          	lbu	a3,0(s3)
c002a5a0:	06800793          	li	a5,104
c002a5a4:	00f682e3          	beq	a3,a5,c002ada8 <_svfiprintf_r+0xf00>
c002a5a8:	04096913          	ori	s2,s2,64
c002a5ac:	a31ff06f          	j	c0029fdc <_svfiprintf_r+0x134>
c002a5b0:	00c12703          	lw	a4,12(sp)
c002a5b4:	02097793          	andi	a5,s2,32
c002a5b8:	00072683          	lw	a3,0(a4)
c002a5bc:	00470713          	addi	a4,a4,4
c002a5c0:	00e12623          	sw	a4,12(sp)
c002a5c4:	60079063          	bnez	a5,c002abc4 <_svfiprintf_r+0xd1c>
c002a5c8:	01097793          	andi	a5,s2,16
c002a5cc:	000792e3          	bnez	a5,c002add0 <_svfiprintf_r+0xf28>
c002a5d0:	04097793          	andi	a5,s2,64
c002a5d4:	100798e3          	bnez	a5,c002aee4 <_svfiprintf_r+0x103c>
c002a5d8:	20097313          	andi	t1,s2,512
c002a5dc:	7e030a63          	beqz	t1,c002add0 <_svfiprintf_r+0xf28>
c002a5e0:	00812783          	lw	a5,8(sp)
c002a5e4:	00f68023          	sb	a5,0(a3)
c002a5e8:	965ff06f          	j	c0029f4c <_svfiprintf_r+0xa4>
c002a5ec:	0009c683          	lbu	a3,0(s3)
c002a5f0:	06c00793          	li	a5,108
c002a5f4:	7cf68263          	beq	a3,a5,c002adb8 <_svfiprintf_r+0xf10>
c002a5f8:	01096913          	ori	s2,s2,16
c002a5fc:	9e1ff06f          	j	c0029fdc <_svfiprintf_r+0x134>
c002a600:	00100613          	li	a2,1
c002a604:	10c688e3          	beq	a3,a2,c002af14 <_svfiprintf_r+0x106c>
c002a608:	00200613          	li	a2,2
c002a60c:	00090d13          	mv	s10,s2
c002a610:	e0c694e3          	bne	a3,a2,c002a418 <_svfiprintf_r+0x570>
c002a614:	01412683          	lw	a3,20(sp)
c002a618:	0f010413          	addi	s0,sp,240
c002a61c:	00fcf793          	andi	a5,s9,15
c002a620:	00f687b3          	add	a5,a3,a5
c002a624:	0007c703          	lbu	a4,0(a5)
c002a628:	004cdc93          	srli	s9,s9,0x4
c002a62c:	01cb9793          	slli	a5,s7,0x1c
c002a630:	0197ecb3          	or	s9,a5,s9
c002a634:	004bdb93          	srli	s7,s7,0x4
c002a638:	fee40fa3          	sb	a4,-1(s0)
c002a63c:	017ce7b3          	or	a5,s9,s7
c002a640:	fff40413          	addi	s0,s0,-1
c002a644:	fc079ce3          	bnez	a5,c002a61c <_svfiprintf_r+0x774>
c002a648:	0f010793          	addi	a5,sp,240
c002a64c:	40878cb3          	sub	s9,a5,s0
c002a650:	000d0913          	mv	s2,s10
c002a654:	cc1ff06f          	j	c002a314 <_svfiprintf_r+0x46c>
c002a658:	00412703          	lw	a4,4(sp)
c002a65c:	41770d33          	sub	s10,a4,s7
c002a660:	aba052e3          	blez	s10,c002a104 <_svfiprintf_r+0x25c>
c002a664:	01000513          	li	a0,16
c002a668:	0ba55ae3          	bge	a0,s10,c002af1c <_svfiprintf_r+0x1074>
c002a66c:	02812223          	sw	s0,36(sp)
c002a670:	01000693          	li	a3,16
c002a674:	000a0413          	mv	s0,s4
c002a678:	00700e93          	li	t4,7
c002a67c:	000d0a13          	mv	s4,s10
c002a680:	00098d13          	mv	s10,s3
c002a684:	00088993          	mv	s3,a7
c002a688:	00c0006f          	j	c002a694 <_svfiprintf_r+0x7ec>
c002a68c:	ff0a0a13          	addi	s4,s4,-16
c002a690:	0546da63          	bge	a3,s4,c002a6e4 <_svfiprintf_r+0x83c>
c002a694:	01078793          	addi	a5,a5,16
c002a698:	00160613          	addi	a2,a2,1
c002a69c:	009da023          	sw	s1,0(s11)
c002a6a0:	00dda223          	sw	a3,4(s11)
c002a6a4:	04f12423          	sw	a5,72(sp)
c002a6a8:	04c12223          	sw	a2,68(sp)
c002a6ac:	008d8d93          	addi	s11,s11,8
c002a6b0:	fccedee3          	bge	t4,a2,c002a68c <_svfiprintf_r+0x7e4>
c002a6b4:	04010613          	addi	a2,sp,64
c002a6b8:	00040593          	mv	a1,s0
c002a6bc:	000b0513          	mv	a0,s6
c002a6c0:	e2cff0ef          	jal	ra,c0029cec <__ssprint_r>
c002a6c4:	70051263          	bnez	a0,c002adc8 <_svfiprintf_r+0xf20>
c002a6c8:	01000693          	li	a3,16
c002a6cc:	ff0a0a13          	addi	s4,s4,-16
c002a6d0:	04812783          	lw	a5,72(sp)
c002a6d4:	04412603          	lw	a2,68(sp)
c002a6d8:	000a8d93          	mv	s11,s5
c002a6dc:	00700e93          	li	t4,7
c002a6e0:	fb46cae3          	blt	a3,s4,c002a694 <_svfiprintf_r+0x7ec>
c002a6e4:	00098893          	mv	a7,s3
c002a6e8:	000d0993          	mv	s3,s10
c002a6ec:	000a0d13          	mv	s10,s4
c002a6f0:	00040a13          	mv	s4,s0
c002a6f4:	02412403          	lw	s0,36(sp)
c002a6f8:	00160613          	addi	a2,a2,1
c002a6fc:	008d8513          	addi	a0,s11,8
c002a700:	01a787b3          	add	a5,a5,s10
c002a704:	009da023          	sw	s1,0(s11)
c002a708:	01ada223          	sw	s10,4(s11)
c002a70c:	04f12423          	sw	a5,72(sp)
c002a710:	04c12223          	sw	a2,68(sp)
c002a714:	00700713          	li	a4,7
c002a718:	64c74e63          	blt	a4,a2,c002ad74 <_svfiprintf_r+0xecc>
c002a71c:	41988d33          	sub	s10,a7,s9
c002a720:	00160593          	addi	a1,a2,1
c002a724:	00850693          	addi	a3,a0,8
c002a728:	00050d93          	mv	s11,a0
c002a72c:	9fa050e3          	blez	s10,c002a10c <_svfiprintf_r+0x264>
c002a730:	01000513          	li	a0,16
c002a734:	75a55263          	bge	a0,s10,c002ae78 <_svfiprintf_r+0xfd0>
c002a738:	01000693          	li	a3,16
c002a73c:	00700893          	li	a7,7
c002a740:	00c0006f          	j	c002a74c <_svfiprintf_r+0x8a4>
c002a744:	ff0d0d13          	addi	s10,s10,-16
c002a748:	05a6da63          	bge	a3,s10,c002a79c <_svfiprintf_r+0x8f4>
c002a74c:	01078793          	addi	a5,a5,16
c002a750:	00160613          	addi	a2,a2,1
c002a754:	009da023          	sw	s1,0(s11)
c002a758:	00dda223          	sw	a3,4(s11)
c002a75c:	04f12423          	sw	a5,72(sp)
c002a760:	04c12223          	sw	a2,68(sp)
c002a764:	008d8d93          	addi	s11,s11,8
c002a768:	fcc8dee3          	bge	a7,a2,c002a744 <_svfiprintf_r+0x89c>
c002a76c:	04010613          	addi	a2,sp,64
c002a770:	000a0593          	mv	a1,s4
c002a774:	000b0513          	mv	a0,s6
c002a778:	d74ff0ef          	jal	ra,c0029cec <__ssprint_r>
c002a77c:	9e051ae3          	bnez	a0,c002a170 <_svfiprintf_r+0x2c8>
c002a780:	01000693          	li	a3,16
c002a784:	ff0d0d13          	addi	s10,s10,-16
c002a788:	04812783          	lw	a5,72(sp)
c002a78c:	04412603          	lw	a2,68(sp)
c002a790:	000a8d93          	mv	s11,s5
c002a794:	00700893          	li	a7,7
c002a798:	fba6cae3          	blt	a3,s10,c002a74c <_svfiprintf_r+0x8a4>
c002a79c:	00160593          	addi	a1,a2,1
c002a7a0:	008d8613          	addi	a2,s11,8
c002a7a4:	01a787b3          	add	a5,a5,s10
c002a7a8:	009da023          	sw	s1,0(s11)
c002a7ac:	01ada223          	sw	s10,4(s11)
c002a7b0:	04f12423          	sw	a5,72(sp)
c002a7b4:	04b12223          	sw	a1,68(sp)
c002a7b8:	00700713          	li	a4,7
c002a7bc:	32b74663          	blt	a4,a1,c002aae8 <_svfiprintf_r+0xc40>
c002a7c0:	00060d93          	mv	s11,a2
c002a7c4:	00158593          	addi	a1,a1,1
c002a7c8:	00fc87b3          	add	a5,s9,a5
c002a7cc:	008da023          	sw	s0,0(s11)
c002a7d0:	019da223          	sw	s9,4(s11)
c002a7d4:	04f12423          	sw	a5,72(sp)
c002a7d8:	04b12223          	sw	a1,68(sp)
c002a7dc:	00700713          	li	a4,7
c002a7e0:	00860693          	addi	a3,a2,8
c002a7e4:	94b752e3          	bge	a4,a1,c002a128 <_svfiprintf_r+0x280>
c002a7e8:	04010613          	addi	a2,sp,64
c002a7ec:	000a0593          	mv	a1,s4
c002a7f0:	000b0513          	mv	a0,s6
c002a7f4:	cf8ff0ef          	jal	ra,c0029cec <__ssprint_r>
c002a7f8:	96051ce3          	bnez	a0,c002a170 <_svfiprintf_r+0x2c8>
c002a7fc:	04812783          	lw	a5,72(sp)
c002a800:	000a8693          	mv	a3,s5
c002a804:	925ff06f          	j	c002a128 <_svfiprintf_r+0x280>
c002a808:	04010613          	addi	a2,sp,64
c002a80c:	000a0593          	mv	a1,s4
c002a810:	000b0513          	mv	a0,s6
c002a814:	cd8ff0ef          	jal	ra,c0029cec <__ssprint_r>
c002a818:	940500e3          	beqz	a0,c002a158 <_svfiprintf_r+0x2b0>
c002a81c:	955ff06f          	j	c002a170 <_svfiprintf_r+0x2c8>
c002a820:	00090d13          	mv	s10,s2
c002a824:	be5ff06f          	j	c002a408 <_svfiprintf_r+0x560>
c002a828:	01000693          	li	a3,16
c002a82c:	0da6d263          	bge	a3,s10,c002a8f0 <_svfiprintf_r+0xa48>
c002a830:	00098593          	mv	a1,s3
c002a834:	000d8713          	mv	a4,s11
c002a838:	00040993          	mv	s3,s0
c002a83c:	000c8d93          	mv	s11,s9
c002a840:	000d0413          	mv	s0,s10
c002a844:	00700f93          	li	t6,7
c002a848:	000b8d13          	mv	s10,s7
c002a84c:	03e12223          	sw	t5,36(sp)
c002a850:	00090b93          	mv	s7,s2
c002a854:	03d12423          	sw	t4,40(sp)
c002a858:	000a0913          	mv	s2,s4
c002a85c:	00088c93          	mv	s9,a7
c002a860:	00058a13          	mv	s4,a1
c002a864:	00c0006f          	j	c002a870 <_svfiprintf_r+0x9c8>
c002a868:	ff040413          	addi	s0,s0,-16
c002a86c:	0486da63          	bge	a3,s0,c002a8c0 <_svfiprintf_r+0xa18>
c002a870:	01078793          	addi	a5,a5,16
c002a874:	00160613          	addi	a2,a2,1
c002a878:	01872023          	sw	s8,0(a4)
c002a87c:	00d72223          	sw	a3,4(a4)
c002a880:	04f12423          	sw	a5,72(sp)
c002a884:	04c12223          	sw	a2,68(sp)
c002a888:	00870713          	addi	a4,a4,8
c002a88c:	fccfdee3          	bge	t6,a2,c002a868 <_svfiprintf_r+0x9c0>
c002a890:	04010613          	addi	a2,sp,64
c002a894:	00090593          	mv	a1,s2
c002a898:	000b0513          	mv	a0,s6
c002a89c:	c50ff0ef          	jal	ra,c0029cec <__ssprint_r>
c002a8a0:	4a051863          	bnez	a0,c002ad50 <_svfiprintf_r+0xea8>
c002a8a4:	01000693          	li	a3,16
c002a8a8:	ff040413          	addi	s0,s0,-16
c002a8ac:	04812783          	lw	a5,72(sp)
c002a8b0:	04412603          	lw	a2,68(sp)
c002a8b4:	000a8713          	mv	a4,s5
c002a8b8:	00700f93          	li	t6,7
c002a8bc:	fa86cae3          	blt	a3,s0,c002a870 <_svfiprintf_r+0x9c8>
c002a8c0:	02412f03          	lw	t5,36(sp)
c002a8c4:	02812e83          	lw	t4,40(sp)
c002a8c8:	000c8893          	mv	a7,s9
c002a8cc:	000d8c93          	mv	s9,s11
c002a8d0:	00070d93          	mv	s11,a4
c002a8d4:	000a0713          	mv	a4,s4
c002a8d8:	00090a13          	mv	s4,s2
c002a8dc:	000b8913          	mv	s2,s7
c002a8e0:	000d0b93          	mv	s7,s10
c002a8e4:	00040d13          	mv	s10,s0
c002a8e8:	00098413          	mv	s0,s3
c002a8ec:	00070993          	mv	s3,a4
c002a8f0:	01a787b3          	add	a5,a5,s10
c002a8f4:	00160613          	addi	a2,a2,1
c002a8f8:	018da023          	sw	s8,0(s11)
c002a8fc:	01ada223          	sw	s10,4(s11)
c002a900:	04f12423          	sw	a5,72(sp)
c002a904:	04c12223          	sw	a2,68(sp)
c002a908:	00700693          	li	a3,7
c002a90c:	008d8d93          	addi	s11,s11,8
c002a910:	f6c6d463          	bge	a3,a2,c002a078 <_svfiprintf_r+0x1d0>
c002a914:	04010613          	addi	a2,sp,64
c002a918:	000a0593          	mv	a1,s4
c002a91c:	000b0513          	mv	a0,s6
c002a920:	03112623          	sw	a7,44(sp)
c002a924:	03d12423          	sw	t4,40(sp)
c002a928:	03e12223          	sw	t5,36(sp)
c002a92c:	bc0ff0ef          	jal	ra,c0029cec <__ssprint_r>
c002a930:	840510e3          	bnez	a0,c002a170 <_svfiprintf_r+0x2c8>
c002a934:	04812783          	lw	a5,72(sp)
c002a938:	04412603          	lw	a2,68(sp)
c002a93c:	02c12883          	lw	a7,44(sp)
c002a940:	02812e83          	lw	t4,40(sp)
c002a944:	02412f03          	lw	t5,36(sp)
c002a948:	000a8d93          	mv	s11,s5
c002a94c:	f2cff06f          	j	c002a078 <_svfiprintf_r+0x1d0>
c002a950:	04010613          	addi	a2,sp,64
c002a954:	000a0593          	mv	a1,s4
c002a958:	000b0513          	mv	a0,s6
c002a95c:	03112623          	sw	a7,44(sp)
c002a960:	03d12423          	sw	t4,40(sp)
c002a964:	03e12223          	sw	t5,36(sp)
c002a968:	b84ff0ef          	jal	ra,c0029cec <__ssprint_r>
c002a96c:	800512e3          	bnez	a0,c002a170 <_svfiprintf_r+0x2c8>
c002a970:	04412603          	lw	a2,68(sp)
c002a974:	04812783          	lw	a5,72(sp)
c002a978:	02c12883          	lw	a7,44(sp)
c002a97c:	02812e83          	lw	t4,40(sp)
c002a980:	02412f03          	lw	t5,36(sp)
c002a984:	05410693          	addi	a3,sp,84
c002a988:	00160593          	addi	a1,a2,1
c002a98c:	000a8d93          	mv	s11,s5
c002a990:	f34ff06f          	j	c002a0c4 <_svfiprintf_r+0x21c>
c002a994:	04010613          	addi	a2,sp,64
c002a998:	000a0593          	mv	a1,s4
c002a99c:	000b0513          	mv	a0,s6
c002a9a0:	03112423          	sw	a7,40(sp)
c002a9a4:	03d12223          	sw	t4,36(sp)
c002a9a8:	b44ff0ef          	jal	ra,c0029cec <__ssprint_r>
c002a9ac:	fc051263          	bnez	a0,c002a170 <_svfiprintf_r+0x2c8>
c002a9b0:	04412603          	lw	a2,68(sp)
c002a9b4:	04812783          	lw	a5,72(sp)
c002a9b8:	02812883          	lw	a7,40(sp)
c002a9bc:	02412e83          	lw	t4,36(sp)
c002a9c0:	05410693          	addi	a3,sp,84
c002a9c4:	00160593          	addi	a1,a2,1
c002a9c8:	000a8d93          	mv	s11,s5
c002a9cc:	f30ff06f          	j	c002a0fc <_svfiprintf_r+0x254>
c002a9d0:	01000613          	li	a2,16
c002a9d4:	04412703          	lw	a4,68(sp)
c002a9d8:	07965063          	bge	a2,s9,c002aa38 <_svfiprintf_r+0xb90>
c002a9dc:	01000d13          	li	s10,16
c002a9e0:	00700413          	li	s0,7
c002a9e4:	00c0006f          	j	c002a9f0 <_svfiprintf_r+0xb48>
c002a9e8:	ff0c8c93          	addi	s9,s9,-16
c002a9ec:	059d5663          	bge	s10,s9,c002aa38 <_svfiprintf_r+0xb90>
c002a9f0:	01078793          	addi	a5,a5,16
c002a9f4:	00170713          	addi	a4,a4,1
c002a9f8:	0186a023          	sw	s8,0(a3)
c002a9fc:	01a6a223          	sw	s10,4(a3)
c002aa00:	04f12423          	sw	a5,72(sp)
c002aa04:	04e12223          	sw	a4,68(sp)
c002aa08:	00868693          	addi	a3,a3,8
c002aa0c:	fce45ee3          	bge	s0,a4,c002a9e8 <_svfiprintf_r+0xb40>
c002aa10:	04010613          	addi	a2,sp,64
c002aa14:	000a0593          	mv	a1,s4
c002aa18:	000b0513          	mv	a0,s6
c002aa1c:	ad0ff0ef          	jal	ra,c0029cec <__ssprint_r>
c002aa20:	f4051863          	bnez	a0,c002a170 <_svfiprintf_r+0x2c8>
c002aa24:	ff0c8c93          	addi	s9,s9,-16
c002aa28:	04812783          	lw	a5,72(sp)
c002aa2c:	04412703          	lw	a4,68(sp)
c002aa30:	000a8693          	mv	a3,s5
c002aa34:	fb9d4ee3          	blt	s10,s9,c002a9f0 <_svfiprintf_r+0xb48>
c002aa38:	019787b3          	add	a5,a5,s9
c002aa3c:	00170713          	addi	a4,a4,1
c002aa40:	0186a023          	sw	s8,0(a3)
c002aa44:	0196a223          	sw	s9,4(a3)
c002aa48:	04f12423          	sw	a5,72(sp)
c002aa4c:	04e12223          	sw	a4,68(sp)
c002aa50:	00700693          	li	a3,7
c002aa54:	eee6d463          	bge	a3,a4,c002a13c <_svfiprintf_r+0x294>
c002aa58:	04010613          	addi	a2,sp,64
c002aa5c:	000a0593          	mv	a1,s4
c002aa60:	000b0513          	mv	a0,s6
c002aa64:	a88ff0ef          	jal	ra,c0029cec <__ssprint_r>
c002aa68:	f0051463          	bnez	a0,c002a170 <_svfiprintf_r+0x2c8>
c002aa6c:	04812783          	lw	a5,72(sp)
c002aa70:	eccff06f          	j	c002a13c <_svfiprintf_r+0x294>
c002aa74:	880896e3          	bnez	a7,c002a300 <_svfiprintf_r+0x458>
c002aa78:	000d0913          	mv	s2,s10
c002aa7c:	00000893          	li	a7,0
c002aa80:	00000c93          	li	s9,0
c002aa84:	0f010413          	addi	s0,sp,240
c002aa88:	88dff06f          	j	c002a314 <_svfiprintf_r+0x46c>
c002aa8c:	00c12703          	lw	a4,12(sp)
c002aa90:	01097793          	andi	a5,s2,16
c002aa94:	00470693          	addi	a3,a4,4
c002aa98:	18079263          	bnez	a5,c002ac1c <_svfiprintf_r+0xd74>
c002aa9c:	04097793          	andi	a5,s2,64
c002aaa0:	36078e63          	beqz	a5,c002ae1c <_svfiprintf_r+0xf74>
c002aaa4:	00c12783          	lw	a5,12(sp)
c002aaa8:	00000b93          	li	s7,0
c002aaac:	00d12623          	sw	a3,12(sp)
c002aab0:	0007dc83          	lhu	s9,0(a5)
c002aab4:	8a9ff06f          	j	c002a35c <_svfiprintf_r+0x4b4>
c002aab8:	00c12703          	lw	a4,12(sp)
c002aabc:	010d7793          	andi	a5,s10,16
c002aac0:	00470693          	addi	a3,a4,4
c002aac4:	10079a63          	bnez	a5,c002abd8 <_svfiprintf_r+0xd30>
c002aac8:	040d7793          	andi	a5,s10,64
c002aacc:	38078663          	beqz	a5,c002ae58 <_svfiprintf_r+0xfb0>
c002aad0:	00c12783          	lw	a5,12(sp)
c002aad4:	00000b93          	li	s7,0
c002aad8:	00d12623          	sw	a3,12(sp)
c002aadc:	0007dc83          	lhu	s9,0(a5)
c002aae0:	00100693          	li	a3,1
c002aae4:	881ff06f          	j	c002a364 <_svfiprintf_r+0x4bc>
c002aae8:	04010613          	addi	a2,sp,64
c002aaec:	000a0593          	mv	a1,s4
c002aaf0:	000b0513          	mv	a0,s6
c002aaf4:	9f8ff0ef          	jal	ra,c0029cec <__ssprint_r>
c002aaf8:	e6051c63          	bnez	a0,c002a170 <_svfiprintf_r+0x2c8>
c002aafc:	04412583          	lw	a1,68(sp)
c002ab00:	04812783          	lw	a5,72(sp)
c002ab04:	05410693          	addi	a3,sp,84
c002ab08:	00158593          	addi	a1,a1,1
c002ab0c:	000a8d93          	mv	s11,s5
c002ab10:	dfcff06f          	j	c002a10c <_svfiprintf_r+0x264>
c002ab14:	400d7793          	andi	a5,s10,1024
c002ab18:	03412423          	sw	s4,40(sp)
c002ab1c:	03312623          	sw	s3,44(sp)
c002ab20:	000b8a13          	mv	s4,s7
c002ab24:	000c8993          	mv	s3,s9
c002ab28:	00000913          	li	s2,0
c002ab2c:	01812c83          	lw	s9,24(sp)
c002ab30:	0f010413          	addi	s0,sp,240
c002ab34:	03112223          	sw	a7,36(sp)
c002ab38:	00078b93          	mv	s7,a5
c002ab3c:	0240006f          	j	c002ab60 <_svfiprintf_r+0xcb8>
c002ab40:	00a00613          	li	a2,10
c002ab44:	00000693          	li	a3,0
c002ab48:	00098513          	mv	a0,s3
c002ab4c:	000a0593          	mv	a1,s4
c002ab50:	329020ef          	jal	ra,c002d678 <__udivdi3>
c002ab54:	320a0663          	beqz	s4,c002ae80 <_svfiprintf_r+0xfd8>
c002ab58:	00050993          	mv	s3,a0
c002ab5c:	00058a13          	mv	s4,a1
c002ab60:	00a00613          	li	a2,10
c002ab64:	00000693          	li	a3,0
c002ab68:	00098513          	mv	a0,s3
c002ab6c:	000a0593          	mv	a1,s4
c002ab70:	73d020ef          	jal	ra,c002daac <__umoddi3>
c002ab74:	03050513          	addi	a0,a0,48
c002ab78:	fea40fa3          	sb	a0,-1(s0)
c002ab7c:	00190913          	addi	s2,s2,1
c002ab80:	fff40413          	addi	s0,s0,-1
c002ab84:	fa0b8ee3          	beqz	s7,c002ab40 <_svfiprintf_r+0xc98>
c002ab88:	000cc683          	lbu	a3,0(s9)
c002ab8c:	fb269ae3          	bne	a3,s2,c002ab40 <_svfiprintf_r+0xc98>
c002ab90:	0ff00793          	li	a5,255
c002ab94:	faf906e3          	beq	s2,a5,c002ab40 <_svfiprintf_r+0xc98>
c002ab98:	160a1c63          	bnez	s4,c002ad10 <_svfiprintf_r+0xe68>
c002ab9c:	00900793          	li	a5,9
c002aba0:	1737e863          	bltu	a5,s3,c002ad10 <_svfiprintf_r+0xe68>
c002aba4:	0f010793          	addi	a5,sp,240
c002aba8:	01912c23          	sw	s9,24(sp)
c002abac:	02412883          	lw	a7,36(sp)
c002abb0:	02812a03          	lw	s4,40(sp)
c002abb4:	02c12983          	lw	s3,44(sp)
c002abb8:	40878cb3          	sub	s9,a5,s0
c002abbc:	000d0913          	mv	s2,s10
c002abc0:	f54ff06f          	j	c002a314 <_svfiprintf_r+0x46c>
c002abc4:	00812703          	lw	a4,8(sp)
c002abc8:	41f75793          	srai	a5,a4,0x1f
c002abcc:	00e6a023          	sw	a4,0(a3)
c002abd0:	00f6a223          	sw	a5,4(a3)
c002abd4:	b78ff06f          	j	c0029f4c <_svfiprintf_r+0xa4>
c002abd8:	00d12623          	sw	a3,12(sp)
c002abdc:	00072c83          	lw	s9,0(a4)
c002abe0:	00000b93          	li	s7,0
c002abe4:	00100693          	li	a3,1
c002abe8:	f7cff06f          	j	c002a364 <_svfiprintf_r+0x4bc>
c002abec:	01812783          	lw	a5,24(sp)
c002abf0:	0009c683          	lbu	a3,0(s3)
c002abf4:	be078463          	beqz	a5,c0029fdc <_svfiprintf_r+0x134>
c002abf8:	0007c783          	lbu	a5,0(a5)
c002abfc:	be078063          	beqz	a5,c0029fdc <_svfiprintf_r+0x134>
c002ac00:	40096913          	ori	s2,s2,1024
c002ac04:	bd8ff06f          	j	c0029fdc <_svfiprintf_r+0x134>
c002ac08:	00072c83          	lw	s9,0(a4)
c002ac0c:	00d12623          	sw	a3,12(sp)
c002ac10:	41fcdb93          	srai	s7,s9,0x1f
c002ac14:	000b8693          	mv	a3,s7
c002ac18:	ec0ff06f          	j	c002a2d8 <_svfiprintf_r+0x430>
c002ac1c:	00072c83          	lw	s9,0(a4)
c002ac20:	00000b93          	li	s7,0
c002ac24:	00d12623          	sw	a3,12(sp)
c002ac28:	f34ff06f          	j	c002a35c <_svfiprintf_r+0x4b4>
c002ac2c:	c80027b7          	lui	a5,0xc8002
c002ac30:	6f878793          	addi	a5,a5,1784 # c80026f8 <_end+0xfff7de78>
c002ac34:	00f12a23          	sw	a5,20(sp)
c002ac38:	02097793          	andi	a5,s2,32
c002ac3c:	00040893          	mv	a7,s0
c002ac40:	06078c63          	beqz	a5,c002acb8 <_svfiprintf_r+0xe10>
c002ac44:	00c12783          	lw	a5,12(sp)
c002ac48:	00778793          	addi	a5,a5,7
c002ac4c:	ff87f793          	andi	a5,a5,-8
c002ac50:	0007ac83          	lw	s9,0(a5)
c002ac54:	0047ab83          	lw	s7,4(a5)
c002ac58:	00878793          	addi	a5,a5,8
c002ac5c:	00f12623          	sw	a5,12(sp)
c002ac60:	00197613          	andi	a2,s2,1
c002ac64:	00060e63          	beqz	a2,c002ac80 <_svfiprintf_r+0xdd8>
c002ac68:	017ce633          	or	a2,s9,s7
c002ac6c:	00060a63          	beqz	a2,c002ac80 <_svfiprintf_r+0xdd8>
c002ac70:	03000613          	li	a2,48
c002ac74:	02c10e23          	sb	a2,60(sp)
c002ac78:	02d10ea3          	sb	a3,61(sp)
c002ac7c:	00296913          	ori	s2,s2,2
c002ac80:	bff97d13          	andi	s10,s2,-1025
c002ac84:	00200693          	li	a3,2
c002ac88:	edcff06f          	j	c002a364 <_svfiprintf_r+0x4bc>
c002ac8c:	00040893          	mv	a7,s0
c002ac90:	00090d13          	mv	s10,s2
c002ac94:	fe8ff06f          	j	c002a47c <_svfiprintf_r+0x5d4>
c002ac98:	00040893          	mv	a7,s0
c002ac9c:	e9cff06f          	j	c002a338 <_svfiprintf_r+0x490>
c002aca0:	c80027b7          	lui	a5,0xc8002
c002aca4:	6e478793          	addi	a5,a5,1764 # c80026e4 <_end+0xfff7de64>
c002aca8:	00f12a23          	sw	a5,20(sp)
c002acac:	02097793          	andi	a5,s2,32
c002acb0:	00040893          	mv	a7,s0
c002acb4:	f80798e3          	bnez	a5,c002ac44 <_svfiprintf_r+0xd9c>
c002acb8:	00c12703          	lw	a4,12(sp)
c002acbc:	01097793          	andi	a5,s2,16
c002acc0:	00470613          	addi	a2,a4,4
c002acc4:	08078a63          	beqz	a5,c002ad58 <_svfiprintf_r+0xeb0>
c002acc8:	00072c83          	lw	s9,0(a4)
c002accc:	00000b93          	li	s7,0
c002acd0:	00c12623          	sw	a2,12(sp)
c002acd4:	f8dff06f          	j	c002ac60 <_svfiprintf_r+0xdb8>
c002acd8:	00040513          	mv	a0,s0
c002acdc:	b8cf30ef          	jal	ra,c001e068 <strlen>
c002ace0:	00050c93          	mv	s9,a0
c002ace4:	01a12623          	sw	s10,12(sp)
c002ace8:	00000893          	li	a7,0
c002acec:	e28ff06f          	j	c002a314 <_svfiprintf_r+0x46c>
c002acf0:	04000593          	li	a1,64
c002acf4:	9d9fc0ef          	jal	ra,c00276cc <_malloc_r>
c002acf8:	00aa2023          	sw	a0,0(s4)
c002acfc:	00aa2823          	sw	a0,16(s4)
c002ad00:	24050c63          	beqz	a0,c002af58 <_svfiprintf_r+0x10b0>
c002ad04:	04000793          	li	a5,64
c002ad08:	00fa2a23          	sw	a5,20(s4)
c002ad0c:	9f8ff06f          	j	c0029f04 <_svfiprintf_r+0x5c>
c002ad10:	02012783          	lw	a5,32(sp)
c002ad14:	01c12583          	lw	a1,28(sp)
c002ad18:	00000913          	li	s2,0
c002ad1c:	40f40433          	sub	s0,s0,a5
c002ad20:	00078613          	mv	a2,a5
c002ad24:	00040513          	mv	a0,s0
c002ad28:	f1dfe0ef          	jal	ra,c0029c44 <strncpy>
c002ad2c:	001cc583          	lbu	a1,1(s9)
c002ad30:	00a00613          	li	a2,10
c002ad34:	00000693          	li	a3,0
c002ad38:	00b03833          	snez	a6,a1
c002ad3c:	00098513          	mv	a0,s3
c002ad40:	000a0593          	mv	a1,s4
c002ad44:	010c8cb3          	add	s9,s9,a6
c002ad48:	131020ef          	jal	ra,c002d678 <__udivdi3>
c002ad4c:	e0dff06f          	j	c002ab58 <_svfiprintf_r+0xcb0>
c002ad50:	00090a13          	mv	s4,s2
c002ad54:	c1cff06f          	j	c002a170 <_svfiprintf_r+0x2c8>
c002ad58:	04097793          	andi	a5,s2,64
c002ad5c:	0a078263          	beqz	a5,c002ae00 <_svfiprintf_r+0xf58>
c002ad60:	00c12783          	lw	a5,12(sp)
c002ad64:	00000b93          	li	s7,0
c002ad68:	00c12623          	sw	a2,12(sp)
c002ad6c:	0007dc83          	lhu	s9,0(a5)
c002ad70:	ef1ff06f          	j	c002ac60 <_svfiprintf_r+0xdb8>
c002ad74:	04010613          	addi	a2,sp,64
c002ad78:	000a0593          	mv	a1,s4
c002ad7c:	000b0513          	mv	a0,s6
c002ad80:	03112223          	sw	a7,36(sp)
c002ad84:	f69fe0ef          	jal	ra,c0029cec <__ssprint_r>
c002ad88:	be051463          	bnez	a0,c002a170 <_svfiprintf_r+0x2c8>
c002ad8c:	04412603          	lw	a2,68(sp)
c002ad90:	04812783          	lw	a5,72(sp)
c002ad94:	02412883          	lw	a7,36(sp)
c002ad98:	05410693          	addi	a3,sp,84
c002ad9c:	00160593          	addi	a1,a2,1
c002ada0:	000a8d93          	mv	s11,s5
c002ada4:	b60ff06f          	j	c002a104 <_svfiprintf_r+0x25c>
c002ada8:	0019c683          	lbu	a3,1(s3)
c002adac:	20096913          	ori	s2,s2,512
c002adb0:	00198993          	addi	s3,s3,1
c002adb4:	a28ff06f          	j	c0029fdc <_svfiprintf_r+0x134>
c002adb8:	0019c683          	lbu	a3,1(s3)
c002adbc:	02096913          	ori	s2,s2,32
c002adc0:	00198993          	addi	s3,s3,1
c002adc4:	a18ff06f          	j	c0029fdc <_svfiprintf_r+0x134>
c002adc8:	00040a13          	mv	s4,s0
c002adcc:	ba4ff06f          	j	c002a170 <_svfiprintf_r+0x2c8>
c002add0:	00812783          	lw	a5,8(sp)
c002add4:	00f6a023          	sw	a5,0(a3)
c002add8:	974ff06f          	j	c0029f4c <_svfiprintf_r+0xa4>
c002addc:	00600793          	li	a5,6
c002ade0:	00088c93          	mv	s9,a7
c002ade4:	0117f463          	bgeu	a5,a7,c002adec <_svfiprintf_r+0xf44>
c002ade8:	00600c93          	li	s9,6
c002adec:	c8002e37          	lui	t3,0xc8002
c002adf0:	000c8b93          	mv	s7,s9
c002adf4:	01a12623          	sw	s10,12(sp)
c002adf8:	70ce0413          	addi	s0,t3,1804 # c800270c <_end+0xfff7de8c>
c002adfc:	a50ff06f          	j	c002a04c <_svfiprintf_r+0x1a4>
c002ae00:	20097793          	andi	a5,s2,512
c002ae04:	0c078663          	beqz	a5,c002aed0 <_svfiprintf_r+0x1028>
c002ae08:	00c12783          	lw	a5,12(sp)
c002ae0c:	00000b93          	li	s7,0
c002ae10:	00c12623          	sw	a2,12(sp)
c002ae14:	0007cc83          	lbu	s9,0(a5)
c002ae18:	e49ff06f          	j	c002ac60 <_svfiprintf_r+0xdb8>
c002ae1c:	20097793          	andi	a5,s2,512
c002ae20:	08078e63          	beqz	a5,c002aebc <_svfiprintf_r+0x1014>
c002ae24:	00c12783          	lw	a5,12(sp)
c002ae28:	00000b93          	li	s7,0
c002ae2c:	00d12623          	sw	a3,12(sp)
c002ae30:	0007cc83          	lbu	s9,0(a5)
c002ae34:	d28ff06f          	j	c002a35c <_svfiprintf_r+0x4b4>
c002ae38:	20097793          	andi	a5,s2,512
c002ae3c:	06078463          	beqz	a5,c002aea4 <_svfiprintf_r+0xffc>
c002ae40:	00c12783          	lw	a5,12(sp)
c002ae44:	00d12623          	sw	a3,12(sp)
c002ae48:	00078c83          	lb	s9,0(a5)
c002ae4c:	41fcdb93          	srai	s7,s9,0x1f
c002ae50:	000b8693          	mv	a3,s7
c002ae54:	c84ff06f          	j	c002a2d8 <_svfiprintf_r+0x430>
c002ae58:	200d7793          	andi	a5,s10,512
c002ae5c:	02078863          	beqz	a5,c002ae8c <_svfiprintf_r+0xfe4>
c002ae60:	00c12783          	lw	a5,12(sp)
c002ae64:	00000b93          	li	s7,0
c002ae68:	00d12623          	sw	a3,12(sp)
c002ae6c:	0007cc83          	lbu	s9,0(a5)
c002ae70:	00100693          	li	a3,1
c002ae74:	cf0ff06f          	j	c002a364 <_svfiprintf_r+0x4bc>
c002ae78:	00068613          	mv	a2,a3
c002ae7c:	929ff06f          	j	c002a7a4 <_svfiprintf_r+0x8fc>
c002ae80:	00900793          	li	a5,9
c002ae84:	cd37eae3          	bltu	a5,s3,c002ab58 <_svfiprintf_r+0xcb0>
c002ae88:	d1dff06f          	j	c002aba4 <_svfiprintf_r+0xcfc>
c002ae8c:	00c12783          	lw	a5,12(sp)
c002ae90:	00000b93          	li	s7,0
c002ae94:	00d12623          	sw	a3,12(sp)
c002ae98:	0007ac83          	lw	s9,0(a5)
c002ae9c:	00100693          	li	a3,1
c002aea0:	cc4ff06f          	j	c002a364 <_svfiprintf_r+0x4bc>
c002aea4:	00c12783          	lw	a5,12(sp)
c002aea8:	00d12623          	sw	a3,12(sp)
c002aeac:	0007ac83          	lw	s9,0(a5)
c002aeb0:	41fcdb93          	srai	s7,s9,0x1f
c002aeb4:	000b8693          	mv	a3,s7
c002aeb8:	c20ff06f          	j	c002a2d8 <_svfiprintf_r+0x430>
c002aebc:	00c12783          	lw	a5,12(sp)
c002aec0:	00000b93          	li	s7,0
c002aec4:	00d12623          	sw	a3,12(sp)
c002aec8:	0007ac83          	lw	s9,0(a5)
c002aecc:	c90ff06f          	j	c002a35c <_svfiprintf_r+0x4b4>
c002aed0:	00c12783          	lw	a5,12(sp)
c002aed4:	00000b93          	li	s7,0
c002aed8:	00c12623          	sw	a2,12(sp)
c002aedc:	0007ac83          	lw	s9,0(a5)
c002aee0:	d81ff06f          	j	c002ac60 <_svfiprintf_r+0xdb8>
c002aee4:	00812783          	lw	a5,8(sp)
c002aee8:	00f69023          	sh	a5,0(a3)
c002aeec:	860ff06f          	j	c0029f4c <_svfiprintf_r+0xa4>
c002aef0:	04010613          	addi	a2,sp,64
c002aef4:	000a0593          	mv	a1,s4
c002aef8:	000b0513          	mv	a0,s6
c002aefc:	df1fe0ef          	jal	ra,c0029cec <__ssprint_r>
c002af00:	a70ff06f          	j	c002a170 <_svfiprintf_r+0x2c8>
c002af04:	00088c93          	mv	s9,a7
c002af08:	01a12623          	sw	s10,12(sp)
c002af0c:	00000893          	li	a7,0
c002af10:	c04ff06f          	j	c002a314 <_svfiprintf_r+0x46c>
c002af14:	00090d13          	mv	s10,s2
c002af18:	be8ff06f          	j	c002a300 <_svfiprintf_r+0x458>
c002af1c:	00068513          	mv	a0,a3
c002af20:	00058613          	mv	a2,a1
c002af24:	fdcff06f          	j	c002a700 <_svfiprintf_r+0x858>
c002af28:	fff00793          	li	a5,-1
c002af2c:	00f12423          	sw	a5,8(sp)
c002af30:	a4cff06f          	j	c002a17c <_svfiprintf_r+0x2d4>
c002af34:	00c12783          	lw	a5,12(sp)
c002af38:	0007a403          	lw	s0,0(a5)
c002af3c:	00478793          	addi	a5,a5,4
c002af40:	00045463          	bgez	s0,c002af48 <_svfiprintf_r+0x10a0>
c002af44:	fff00413          	li	s0,-1
c002af48:	0019c683          	lbu	a3,1(s3)
c002af4c:	00f12623          	sw	a5,12(sp)
c002af50:	00070993          	mv	s3,a4
c002af54:	888ff06f          	j	c0029fdc <_svfiprintf_r+0x134>
c002af58:	00c00793          	li	a5,12
c002af5c:	00fb2023          	sw	a5,0(s6)
c002af60:	fff00793          	li	a5,-1
c002af64:	00f12423          	sw	a5,8(sp)
c002af68:	a14ff06f          	j	c002a17c <_svfiprintf_r+0x2d4>

c002af6c <__sprint_r.part.0>:
c002af6c:	0645a703          	lw	a4,100(a1)
c002af70:	fd010113          	addi	sp,sp,-48
c002af74:	000027b7          	lui	a5,0x2
c002af78:	01612823          	sw	s6,16(sp)
c002af7c:	02112623          	sw	ra,44(sp)
c002af80:	02812423          	sw	s0,40(sp)
c002af84:	02912223          	sw	s1,36(sp)
c002af88:	03212023          	sw	s2,32(sp)
c002af8c:	01312e23          	sw	s3,28(sp)
c002af90:	01412c23          	sw	s4,24(sp)
c002af94:	01512a23          	sw	s5,20(sp)
c002af98:	01712623          	sw	s7,12(sp)
c002af9c:	01812423          	sw	s8,8(sp)
c002afa0:	00e7f7b3          	and	a5,a5,a4
c002afa4:	00060b13          	mv	s6,a2
c002afa8:	0a078863          	beqz	a5,c002b058 <__sprint_r.part.0+0xec>
c002afac:	00862783          	lw	a5,8(a2)
c002afb0:	00062b83          	lw	s7,0(a2)
c002afb4:	00058913          	mv	s2,a1
c002afb8:	00050993          	mv	s3,a0
c002afbc:	fff00a93          	li	s5,-1
c002afc0:	08078863          	beqz	a5,c002b050 <__sprint_r.part.0+0xe4>
c002afc4:	004bac03          	lw	s8,4(s7)
c002afc8:	000ba403          	lw	s0,0(s7)
c002afcc:	002c5a13          	srli	s4,s8,0x2
c002afd0:	060a0663          	beqz	s4,c002b03c <__sprint_r.part.0+0xd0>
c002afd4:	00000493          	li	s1,0
c002afd8:	00c0006f          	j	c002afe4 <__sprint_r.part.0+0x78>
c002afdc:	00440413          	addi	s0,s0,4
c002afe0:	049a0c63          	beq	s4,s1,c002b038 <__sprint_r.part.0+0xcc>
c002afe4:	00042583          	lw	a1,0(s0)
c002afe8:	00090613          	mv	a2,s2
c002afec:	00098513          	mv	a0,s3
c002aff0:	17d010ef          	jal	ra,c002c96c <_fputwc_r>
c002aff4:	00148493          	addi	s1,s1,1
c002aff8:	ff5512e3          	bne	a0,s5,c002afdc <__sprint_r.part.0+0x70>
c002affc:	fff00513          	li	a0,-1
c002b000:	02c12083          	lw	ra,44(sp)
c002b004:	02812403          	lw	s0,40(sp)
c002b008:	000b2423          	sw	zero,8(s6)
c002b00c:	000b2223          	sw	zero,4(s6)
c002b010:	02412483          	lw	s1,36(sp)
c002b014:	02012903          	lw	s2,32(sp)
c002b018:	01c12983          	lw	s3,28(sp)
c002b01c:	01812a03          	lw	s4,24(sp)
c002b020:	01412a83          	lw	s5,20(sp)
c002b024:	01012b03          	lw	s6,16(sp)
c002b028:	00c12b83          	lw	s7,12(sp)
c002b02c:	00812c03          	lw	s8,8(sp)
c002b030:	03010113          	addi	sp,sp,48
c002b034:	00008067          	ret
c002b038:	008b2783          	lw	a5,8(s6)
c002b03c:	ffcc7c13          	andi	s8,s8,-4
c002b040:	418787b3          	sub	a5,a5,s8
c002b044:	00fb2423          	sw	a5,8(s6)
c002b048:	008b8b93          	addi	s7,s7,8
c002b04c:	f6079ce3          	bnez	a5,c002afc4 <__sprint_r.part.0+0x58>
c002b050:	00000513          	li	a0,0
c002b054:	fadff06f          	j	c002b000 <__sprint_r.part.0+0x94>
c002b058:	914f90ef          	jal	ra,c002416c <__sfvwrite_r>
c002b05c:	fa5ff06f          	j	c002b000 <__sprint_r.part.0+0x94>

c002b060 <__sprint_r>:
c002b060:	00862703          	lw	a4,8(a2)
c002b064:	00070463          	beqz	a4,c002b06c <__sprint_r+0xc>
c002b068:	f05ff06f          	j	c002af6c <__sprint_r.part.0>
c002b06c:	00062223          	sw	zero,4(a2)
c002b070:	00000513          	li	a0,0
c002b074:	00008067          	ret

c002b078 <_vfiprintf_r>:
c002b078:	ed010113          	addi	sp,sp,-304
c002b07c:	11312e23          	sw	s3,284(sp)
c002b080:	11412c23          	sw	s4,280(sp)
c002b084:	11712623          	sw	s7,268(sp)
c002b088:	12112623          	sw	ra,300(sp)
c002b08c:	12812423          	sw	s0,296(sp)
c002b090:	12912223          	sw	s1,292(sp)
c002b094:	13212023          	sw	s2,288(sp)
c002b098:	11512a23          	sw	s5,276(sp)
c002b09c:	11612823          	sw	s6,272(sp)
c002b0a0:	11812423          	sw	s8,264(sp)
c002b0a4:	11912223          	sw	s9,260(sp)
c002b0a8:	11a12023          	sw	s10,256(sp)
c002b0ac:	0fb12e23          	sw	s11,252(sp)
c002b0b0:	00d12823          	sw	a3,16(sp)
c002b0b4:	00050a13          	mv	s4,a0
c002b0b8:	00058993          	mv	s3,a1
c002b0bc:	00060b93          	mv	s7,a2
c002b0c0:	00050663          	beqz	a0,c002b0cc <_vfiprintf_r+0x54>
c002b0c4:	03852783          	lw	a5,56(a0)
c002b0c8:	62078663          	beqz	a5,c002b6f4 <_vfiprintf_r+0x67c>
c002b0cc:	00c99703          	lh	a4,12(s3)
c002b0d0:	000026b7          	lui	a3,0x2
c002b0d4:	01071793          	slli	a5,a4,0x10
c002b0d8:	0107d793          	srli	a5,a5,0x10
c002b0dc:	00d7f633          	and	a2,a5,a3
c002b0e0:	02061863          	bnez	a2,c002b110 <_vfiprintf_r+0x98>
c002b0e4:	0649a603          	lw	a2,100(s3)
c002b0e8:	00d767b3          	or	a5,a4,a3
c002b0ec:	01079793          	slli	a5,a5,0x10
c002b0f0:	ffffe737          	lui	a4,0xffffe
c002b0f4:	4107d793          	srai	a5,a5,0x10
c002b0f8:	fff70713          	addi	a4,a4,-1 # ffffdfff <_end+0x37f7977f>
c002b0fc:	00e67733          	and	a4,a2,a4
c002b100:	00f99623          	sh	a5,12(s3)
c002b104:	01079793          	slli	a5,a5,0x10
c002b108:	06e9a223          	sw	a4,100(s3)
c002b10c:	0107d793          	srli	a5,a5,0x10
c002b110:	0087f713          	andi	a4,a5,8
c002b114:	40070063          	beqz	a4,c002b514 <_vfiprintf_r+0x49c>
c002b118:	0109a703          	lw	a4,16(s3)
c002b11c:	3e070c63          	beqz	a4,c002b514 <_vfiprintf_r+0x49c>
c002b120:	01a7f793          	andi	a5,a5,26
c002b124:	00a00713          	li	a4,10
c002b128:	40e78663          	beq	a5,a4,c002b534 <_vfiprintf_r+0x4bc>
c002b12c:	c80027b7          	lui	a5,0xc8002
c002b130:	28c78793          	addi	a5,a5,652 # c800228c <_end+0xfff7da0c>
c002b134:	c8002b37          	lui	s6,0xc8002
c002b138:	04c10493          	addi	s1,sp,76
c002b13c:	00f12a23          	sw	a5,20(sp)
c002b140:	c8002937          	lui	s2,0xc8002
c002b144:	3f8b0793          	addi	a5,s6,1016 # c80023f8 <_end+0xfff7db78>
c002b148:	000b8c13          	mv	s8,s7
c002b14c:	04912023          	sw	s1,64(sp)
c002b150:	04012423          	sw	zero,72(sp)
c002b154:	04012223          	sw	zero,68(sp)
c002b158:	00012c23          	sw	zero,24(sp)
c002b15c:	00012e23          	sw	zero,28(sp)
c002b160:	02012223          	sw	zero,36(sp)
c002b164:	02012023          	sw	zero,32(sp)
c002b168:	00012623          	sw	zero,12(sp)
c002b16c:	00f12423          	sw	a5,8(sp)
c002b170:	40890913          	addi	s2,s2,1032 # c8002408 <_end+0xfff7db88>
c002b174:	00048b93          	mv	s7,s1
c002b178:	000c4783          	lbu	a5,0(s8)
c002b17c:	26078863          	beqz	a5,c002b3ec <_vfiprintf_r+0x374>
c002b180:	000c0413          	mv	s0,s8
c002b184:	02500713          	li	a4,37
c002b188:	46e78663          	beq	a5,a4,c002b5f4 <_vfiprintf_r+0x57c>
c002b18c:	00144783          	lbu	a5,1(s0)
c002b190:	00140413          	addi	s0,s0,1
c002b194:	fe079ae3          	bnez	a5,c002b188 <_vfiprintf_r+0x110>
c002b198:	41840cb3          	sub	s9,s0,s8
c002b19c:	25840863          	beq	s0,s8,c002b3ec <_vfiprintf_r+0x374>
c002b1a0:	04812703          	lw	a4,72(sp)
c002b1a4:	04412783          	lw	a5,68(sp)
c002b1a8:	018ba023          	sw	s8,0(s7)
c002b1ac:	00ec8733          	add	a4,s9,a4
c002b1b0:	00178793          	addi	a5,a5,1
c002b1b4:	019ba223          	sw	s9,4(s7)
c002b1b8:	04e12423          	sw	a4,72(sp)
c002b1bc:	04f12223          	sw	a5,68(sp)
c002b1c0:	00700693          	li	a3,7
c002b1c4:	008b8b93          	addi	s7,s7,8
c002b1c8:	02f6d063          	bge	a3,a5,c002b1e8 <_vfiprintf_r+0x170>
c002b1cc:	3e070ae3          	beqz	a4,c002bdc0 <_vfiprintf_r+0xd48>
c002b1d0:	04010613          	addi	a2,sp,64
c002b1d4:	00098593          	mv	a1,s3
c002b1d8:	000a0513          	mv	a0,s4
c002b1dc:	d91ff0ef          	jal	ra,c002af6c <__sprint_r.part.0>
c002b1e0:	20051a63          	bnez	a0,c002b3f4 <_vfiprintf_r+0x37c>
c002b1e4:	00048b93          	mv	s7,s1
c002b1e8:	00c12703          	lw	a4,12(sp)
c002b1ec:	00044783          	lbu	a5,0(s0)
c002b1f0:	01970733          	add	a4,a4,s9
c002b1f4:	00e12623          	sw	a4,12(sp)
c002b1f8:	1e078a63          	beqz	a5,c002b3ec <_vfiprintf_r+0x374>
c002b1fc:	00144703          	lbu	a4,1(s0)
c002b200:	00140c13          	addi	s8,s0,1
c002b204:	02010da3          	sb	zero,59(sp)
c002b208:	fff00a93          	li	s5,-1
c002b20c:	00012223          	sw	zero,4(sp)
c002b210:	00000b13          	li	s6,0
c002b214:	05a00c93          	li	s9,90
c002b218:	00900d13          	li	s10,9
c002b21c:	02a00613          	li	a2,42
c002b220:	001c0c13          	addi	s8,s8,1
c002b224:	fe070793          	addi	a5,a4,-32
c002b228:	04fce863          	bltu	s9,a5,c002b278 <_vfiprintf_r+0x200>
c002b22c:	01412683          	lw	a3,20(sp)
c002b230:	00279793          	slli	a5,a5,0x2
c002b234:	00d787b3          	add	a5,a5,a3
c002b238:	0007a783          	lw	a5,0(a5)
c002b23c:	00078067          	jr	a5
c002b240:	00012223          	sw	zero,4(sp)
c002b244:	fd070793          	addi	a5,a4,-48
c002b248:	00412583          	lw	a1,4(sp)
c002b24c:	000c4703          	lbu	a4,0(s8)
c002b250:	001c0c13          	addi	s8,s8,1
c002b254:	00259693          	slli	a3,a1,0x2
c002b258:	00b686b3          	add	a3,a3,a1
c002b25c:	00169693          	slli	a3,a3,0x1
c002b260:	00d787b3          	add	a5,a5,a3
c002b264:	00f12223          	sw	a5,4(sp)
c002b268:	fd070793          	addi	a5,a4,-48
c002b26c:	fcfd7ee3          	bgeu	s10,a5,c002b248 <_vfiprintf_r+0x1d0>
c002b270:	fe070793          	addi	a5,a4,-32
c002b274:	fafcfce3          	bgeu	s9,a5,c002b22c <_vfiprintf_r+0x1b4>
c002b278:	16070a63          	beqz	a4,c002b3ec <_vfiprintf_r+0x374>
c002b27c:	08e10623          	sb	a4,140(sp)
c002b280:	02010da3          	sb	zero,59(sp)
c002b284:	00100c93          	li	s9,1
c002b288:	00100d13          	li	s10,1
c002b28c:	08c10413          	addi	s0,sp,140
c002b290:	00000a93          	li	s5,0
c002b294:	002b7f93          	andi	t6,s6,2
c002b298:	000f8463          	beqz	t6,c002b2a0 <_vfiprintf_r+0x228>
c002b29c:	002c8c93          	addi	s9,s9,2
c002b2a0:	04412703          	lw	a4,68(sp)
c002b2a4:	084b7f13          	andi	t5,s6,132
c002b2a8:	04812783          	lw	a5,72(sp)
c002b2ac:	00170693          	addi	a3,a4,1
c002b2b0:	00068613          	mv	a2,a3
c002b2b4:	000f1863          	bnez	t5,c002b2c4 <_vfiprintf_r+0x24c>
c002b2b8:	00412583          	lw	a1,4(sp)
c002b2bc:	41958db3          	sub	s11,a1,s9
c002b2c0:	0db042e3          	bgtz	s11,c002bb84 <_vfiprintf_r+0xb0c>
c002b2c4:	03b14583          	lbu	a1,59(sp)
c002b2c8:	008b8693          	addi	a3,s7,8
c002b2cc:	02058c63          	beqz	a1,c002b304 <_vfiprintf_r+0x28c>
c002b2d0:	03b10713          	addi	a4,sp,59
c002b2d4:	00178793          	addi	a5,a5,1
c002b2d8:	00eba023          	sw	a4,0(s7)
c002b2dc:	00100713          	li	a4,1
c002b2e0:	00eba223          	sw	a4,4(s7)
c002b2e4:	04f12423          	sw	a5,72(sp)
c002b2e8:	04c12223          	sw	a2,68(sp)
c002b2ec:	00700713          	li	a4,7
c002b2f0:	00c748e3          	blt	a4,a2,c002bb00 <_vfiprintf_r+0xa88>
c002b2f4:	00060713          	mv	a4,a2
c002b2f8:	00068b93          	mv	s7,a3
c002b2fc:	00160613          	addi	a2,a2,1
c002b300:	00868693          	addi	a3,a3,8 # 2008 <_STACK_SIZE+0x1008>
c002b304:	040f8e63          	beqz	t6,c002b360 <_vfiprintf_r+0x2e8>
c002b308:	03c10713          	addi	a4,sp,60
c002b30c:	00278793          	addi	a5,a5,2
c002b310:	00eba023          	sw	a4,0(s7)
c002b314:	00200713          	li	a4,2
c002b318:	00eba223          	sw	a4,4(s7)
c002b31c:	04f12423          	sw	a5,72(sp)
c002b320:	04c12223          	sw	a2,68(sp)
c002b324:	00700713          	li	a4,7
c002b328:	04c750e3          	bge	a4,a2,c002bb68 <_vfiprintf_r+0xaf0>
c002b32c:	2e0784e3          	beqz	a5,c002be14 <_vfiprintf_r+0xd9c>
c002b330:	04010613          	addi	a2,sp,64
c002b334:	00098593          	mv	a1,s3
c002b338:	000a0513          	mv	a0,s4
c002b33c:	03e12423          	sw	t5,40(sp)
c002b340:	c2dff0ef          	jal	ra,c002af6c <__sprint_r.part.0>
c002b344:	0a051863          	bnez	a0,c002b3f4 <_vfiprintf_r+0x37c>
c002b348:	04412703          	lw	a4,68(sp)
c002b34c:	04812783          	lw	a5,72(sp)
c002b350:	02812f03          	lw	t5,40(sp)
c002b354:	05410693          	addi	a3,sp,84
c002b358:	00170613          	addi	a2,a4,1
c002b35c:	00048b93          	mv	s7,s1
c002b360:	08000593          	li	a1,128
c002b364:	5cbf0e63          	beq	t5,a1,c002b940 <_vfiprintf_r+0x8c8>
c002b368:	41aa8ab3          	sub	s5,s5,s10
c002b36c:	6b504a63          	bgtz	s5,c002ba20 <_vfiprintf_r+0x9a8>
c002b370:	00fd07b3          	add	a5,s10,a5
c002b374:	008ba023          	sw	s0,0(s7)
c002b378:	01aba223          	sw	s10,4(s7)
c002b37c:	04f12423          	sw	a5,72(sp)
c002b380:	04c12223          	sw	a2,68(sp)
c002b384:	00700713          	li	a4,7
c002b388:	02c75263          	bge	a4,a2,c002b3ac <_vfiprintf_r+0x334>
c002b38c:	0e078ee3          	beqz	a5,c002bc88 <_vfiprintf_r+0xc10>
c002b390:	04010613          	addi	a2,sp,64
c002b394:	00098593          	mv	a1,s3
c002b398:	000a0513          	mv	a0,s4
c002b39c:	bd1ff0ef          	jal	ra,c002af6c <__sprint_r.part.0>
c002b3a0:	04051a63          	bnez	a0,c002b3f4 <_vfiprintf_r+0x37c>
c002b3a4:	04812783          	lw	a5,72(sp)
c002b3a8:	00048693          	mv	a3,s1
c002b3ac:	004b7313          	andi	t1,s6,4
c002b3b0:	00030863          	beqz	t1,c002b3c0 <_vfiprintf_r+0x348>
c002b3b4:	00412703          	lw	a4,4(sp)
c002b3b8:	41970bb3          	sub	s7,a4,s9
c002b3bc:	0f7044e3          	bgtz	s7,c002bca4 <_vfiprintf_r+0xc2c>
c002b3c0:	00412403          	lw	s0,4(sp)
c002b3c4:	01945463          	bge	s0,s9,c002b3cc <_vfiprintf_r+0x354>
c002b3c8:	000c8413          	mv	s0,s9
c002b3cc:	00c12703          	lw	a4,12(sp)
c002b3d0:	00870733          	add	a4,a4,s0
c002b3d4:	00e12623          	sw	a4,12(sp)
c002b3d8:	70079063          	bnez	a5,c002bad8 <_vfiprintf_r+0xa60>
c002b3dc:	000c4783          	lbu	a5,0(s8)
c002b3e0:	04012223          	sw	zero,68(sp)
c002b3e4:	00048b93          	mv	s7,s1
c002b3e8:	d8079ce3          	bnez	a5,c002b180 <_vfiprintf_r+0x108>
c002b3ec:	04812783          	lw	a5,72(sp)
c002b3f0:	660798e3          	bnez	a5,c002c260 <_vfiprintf_r+0x11e8>
c002b3f4:	00c9d783          	lhu	a5,12(s3)
c002b3f8:	0407f793          	andi	a5,a5,64
c002b3fc:	6a0790e3          	bnez	a5,c002c29c <_vfiprintf_r+0x1224>
c002b400:	12c12083          	lw	ra,300(sp)
c002b404:	12812403          	lw	s0,296(sp)
c002b408:	00c12503          	lw	a0,12(sp)
c002b40c:	12412483          	lw	s1,292(sp)
c002b410:	12012903          	lw	s2,288(sp)
c002b414:	11c12983          	lw	s3,284(sp)
c002b418:	11812a03          	lw	s4,280(sp)
c002b41c:	11412a83          	lw	s5,276(sp)
c002b420:	11012b03          	lw	s6,272(sp)
c002b424:	10c12b83          	lw	s7,268(sp)
c002b428:	10812c03          	lw	s8,264(sp)
c002b42c:	10412c83          	lw	s9,260(sp)
c002b430:	10012d03          	lw	s10,256(sp)
c002b434:	0fc12d83          	lw	s11,252(sp)
c002b438:	13010113          	addi	sp,sp,304
c002b43c:	00008067          	ret
c002b440:	000a0513          	mv	a0,s4
c002b444:	f0dfb0ef          	jal	ra,c0027350 <_localeconv_r>
c002b448:	00452783          	lw	a5,4(a0)
c002b44c:	00078513          	mv	a0,a5
c002b450:	02f12023          	sw	a5,32(sp)
c002b454:	c15f20ef          	jal	ra,c001e068 <strlen>
c002b458:	00050793          	mv	a5,a0
c002b45c:	000a0513          	mv	a0,s4
c002b460:	00078413          	mv	s0,a5
c002b464:	02f12223          	sw	a5,36(sp)
c002b468:	ee9fb0ef          	jal	ra,c0027350 <_localeconv_r>
c002b46c:	00852783          	lw	a5,8(a0)
c002b470:	02a00613          	li	a2,42
c002b474:	00f12e23          	sw	a5,28(sp)
c002b478:	2e0412e3          	bnez	s0,c002bf5c <_vfiprintf_r+0xee4>
c002b47c:	000c4703          	lbu	a4,0(s8)
c002b480:	da1ff06f          	j	c002b220 <_vfiprintf_r+0x1a8>
c002b484:	000c4703          	lbu	a4,0(s8)
c002b488:	020b6b13          	ori	s6,s6,32
c002b48c:	d95ff06f          	j	c002b220 <_vfiprintf_r+0x1a8>
c002b490:	010b6b13          	ori	s6,s6,16
c002b494:	020b7793          	andi	a5,s6,32
c002b498:	18078c63          	beqz	a5,c002b630 <_vfiprintf_r+0x5b8>
c002b49c:	01012783          	lw	a5,16(sp)
c002b4a0:	00778793          	addi	a5,a5,7
c002b4a4:	ff87f793          	andi	a5,a5,-8
c002b4a8:	0047a703          	lw	a4,4(a5)
c002b4ac:	0007ad03          	lw	s10,0(a5)
c002b4b0:	00878793          	addi	a5,a5,8
c002b4b4:	00f12823          	sw	a5,16(sp)
c002b4b8:	00070c93          	mv	s9,a4
c002b4bc:	1a074263          	bltz	a4,c002b660 <_vfiprintf_r+0x5e8>
c002b4c0:	fff00713          	li	a4,-1
c002b4c4:	000b0d93          	mv	s11,s6
c002b4c8:	00ea8863          	beq	s5,a4,c002b4d8 <_vfiprintf_r+0x460>
c002b4cc:	019d6733          	or	a4,s10,s9
c002b4d0:	f7fb7d93          	andi	s11,s6,-129
c002b4d4:	0e070ce3          	beqz	a4,c002bdcc <_vfiprintf_r+0xd54>
c002b4d8:	160c94e3          	bnez	s9,c002be40 <_vfiprintf_r+0xdc8>
c002b4dc:	00900713          	li	a4,9
c002b4e0:	17a760e3          	bltu	a4,s10,c002be40 <_vfiprintf_r+0xdc8>
c002b4e4:	030d0793          	addi	a5,s10,48
c002b4e8:	0ef107a3          	sb	a5,239(sp)
c002b4ec:	000d8b13          	mv	s6,s11
c002b4f0:	00100d13          	li	s10,1
c002b4f4:	0ef10413          	addi	s0,sp,239
c002b4f8:	000a8c93          	mv	s9,s5
c002b4fc:	01aad463          	bge	s5,s10,c002b504 <_vfiprintf_r+0x48c>
c002b500:	000d0c93          	mv	s9,s10
c002b504:	03b14783          	lbu	a5,59(sp)
c002b508:	00f037b3          	snez	a5,a5
c002b50c:	00fc8cb3          	add	s9,s9,a5
c002b510:	d85ff06f          	j	c002b294 <_vfiprintf_r+0x21c>
c002b514:	00098593          	mv	a1,s3
c002b518:	000a0513          	mv	a0,s4
c002b51c:	fa9f70ef          	jal	ra,c00234c4 <__swsetup_r>
c002b520:	56051ee3          	bnez	a0,c002c29c <_vfiprintf_r+0x1224>
c002b524:	00c9d783          	lhu	a5,12(s3)
c002b528:	00a00713          	li	a4,10
c002b52c:	01a7f793          	andi	a5,a5,26
c002b530:	bee79ee3          	bne	a5,a4,c002b12c <_vfiprintf_r+0xb4>
c002b534:	00e99783          	lh	a5,14(s3)
c002b538:	be07cae3          	bltz	a5,c002b12c <_vfiprintf_r+0xb4>
c002b53c:	12812403          	lw	s0,296(sp)
c002b540:	01012683          	lw	a3,16(sp)
c002b544:	12c12083          	lw	ra,300(sp)
c002b548:	12412483          	lw	s1,292(sp)
c002b54c:	12012903          	lw	s2,288(sp)
c002b550:	11412a83          	lw	s5,276(sp)
c002b554:	11012b03          	lw	s6,272(sp)
c002b558:	10812c03          	lw	s8,264(sp)
c002b55c:	10412c83          	lw	s9,260(sp)
c002b560:	10012d03          	lw	s10,256(sp)
c002b564:	0fc12d83          	lw	s11,252(sp)
c002b568:	000b8613          	mv	a2,s7
c002b56c:	00098593          	mv	a1,s3
c002b570:	10c12b83          	lw	s7,268(sp)
c002b574:	11c12983          	lw	s3,284(sp)
c002b578:	000a0513          	mv	a0,s4
c002b57c:	11812a03          	lw	s4,280(sp)
c002b580:	13010113          	addi	sp,sp,304
c002b584:	5710006f          	j	c002c2f4 <__sbprintf>
c002b588:	010b6b13          	ori	s6,s6,16
c002b58c:	020b7793          	andi	a5,s6,32
c002b590:	06078a63          	beqz	a5,c002b604 <_vfiprintf_r+0x58c>
c002b594:	01012783          	lw	a5,16(sp)
c002b598:	00778793          	addi	a5,a5,7
c002b59c:	ff87f793          	andi	a5,a5,-8
c002b5a0:	0007ad03          	lw	s10,0(a5)
c002b5a4:	0047ac83          	lw	s9,4(a5)
c002b5a8:	00878793          	addi	a5,a5,8
c002b5ac:	00f12823          	sw	a5,16(sp)
c002b5b0:	bffb7d93          	andi	s11,s6,-1025
c002b5b4:	00000713          	li	a4,0
c002b5b8:	02010da3          	sb	zero,59(sp)
c002b5bc:	fff00693          	li	a3,-1
c002b5c0:	0cda8463          	beq	s5,a3,c002b688 <_vfiprintf_r+0x610>
c002b5c4:	019d66b3          	or	a3,s10,s9
c002b5c8:	f7fdfb13          	andi	s6,s11,-129
c002b5cc:	5a069863          	bnez	a3,c002bb7c <_vfiprintf_r+0xb04>
c002b5d0:	300a9c63          	bnez	s5,c002b8e8 <_vfiprintf_r+0x870>
c002b5d4:	000710e3          	bnez	a4,c002bdd4 <_vfiprintf_r+0xd5c>
c002b5d8:	001dfd13          	andi	s10,s11,1
c002b5dc:	0f010413          	addi	s0,sp,240
c002b5e0:	f00d0ce3          	beqz	s10,c002b4f8 <_vfiprintf_r+0x480>
c002b5e4:	03000793          	li	a5,48
c002b5e8:	0ef107a3          	sb	a5,239(sp)
c002b5ec:	0ef10413          	addi	s0,sp,239
c002b5f0:	f09ff06f          	j	c002b4f8 <_vfiprintf_r+0x480>
c002b5f4:	41840cb3          	sub	s9,s0,s8
c002b5f8:	bb8414e3          	bne	s0,s8,c002b1a0 <_vfiprintf_r+0x128>
c002b5fc:	00044783          	lbu	a5,0(s0)
c002b600:	bf9ff06f          	j	c002b1f8 <_vfiprintf_r+0x180>
c002b604:	01012683          	lw	a3,16(sp)
c002b608:	010b7793          	andi	a5,s6,16
c002b60c:	00468713          	addi	a4,a3,4
c002b610:	16079ee3          	bnez	a5,c002bf8c <_vfiprintf_r+0xf14>
c002b614:	040b7793          	andi	a5,s6,64
c002b618:	36078ee3          	beqz	a5,c002c194 <_vfiprintf_r+0x111c>
c002b61c:	01012783          	lw	a5,16(sp)
c002b620:	00000c93          	li	s9,0
c002b624:	00e12823          	sw	a4,16(sp)
c002b628:	0007dd03          	lhu	s10,0(a5)
c002b62c:	f85ff06f          	j	c002b5b0 <_vfiprintf_r+0x538>
c002b630:	01012683          	lw	a3,16(sp)
c002b634:	010b7793          	andi	a5,s6,16
c002b638:	00468713          	addi	a4,a3,4
c002b63c:	100796e3          	bnez	a5,c002bf48 <_vfiprintf_r+0xed0>
c002b640:	040b7793          	andi	a5,s6,64
c002b644:	300788e3          	beqz	a5,c002c154 <_vfiprintf_r+0x10dc>
c002b648:	01012783          	lw	a5,16(sp)
c002b64c:	00e12823          	sw	a4,16(sp)
c002b650:	00079d03          	lh	s10,0(a5)
c002b654:	41fd5c93          	srai	s9,s10,0x1f
c002b658:	000c8713          	mv	a4,s9
c002b65c:	e60752e3          	bgez	a4,c002b4c0 <_vfiprintf_r+0x448>
c002b660:	01a03733          	snez	a4,s10
c002b664:	41900eb3          	neg	t4,s9
c002b668:	40ee8cb3          	sub	s9,t4,a4
c002b66c:	02d00713          	li	a4,45
c002b670:	02e10da3          	sb	a4,59(sp)
c002b674:	fff00693          	li	a3,-1
c002b678:	41a00d33          	neg	s10,s10
c002b67c:	000b0d93          	mv	s11,s6
c002b680:	00100713          	li	a4,1
c002b684:	f4da90e3          	bne	s5,a3,c002b5c4 <_vfiprintf_r+0x54c>
c002b688:	00100693          	li	a3,1
c002b68c:	e4d706e3          	beq	a4,a3,c002b4d8 <_vfiprintf_r+0x460>
c002b690:	00200693          	li	a3,2
c002b694:	26d70463          	beq	a4,a3,c002b8fc <_vfiprintf_r+0x884>
c002b698:	0f010413          	addi	s0,sp,240
c002b69c:	01dc9793          	slli	a5,s9,0x1d
c002b6a0:	007d7713          	andi	a4,s10,7
c002b6a4:	003d5d13          	srli	s10,s10,0x3
c002b6a8:	03070713          	addi	a4,a4,48
c002b6ac:	01a7ed33          	or	s10,a5,s10
c002b6b0:	003cdc93          	srli	s9,s9,0x3
c002b6b4:	fee40fa3          	sb	a4,-1(s0)
c002b6b8:	019d67b3          	or	a5,s10,s9
c002b6bc:	00040613          	mv	a2,s0
c002b6c0:	fff40413          	addi	s0,s0,-1
c002b6c4:	fc079ce3          	bnez	a5,c002b69c <_vfiprintf_r+0x624>
c002b6c8:	001df793          	andi	a5,s11,1
c002b6cc:	26078263          	beqz	a5,c002b930 <_vfiprintf_r+0x8b8>
c002b6d0:	03000793          	li	a5,48
c002b6d4:	24f70e63          	beq	a4,a5,c002b930 <_vfiprintf_r+0x8b8>
c002b6d8:	ffe60613          	addi	a2,a2,-2
c002b6dc:	fef40fa3          	sb	a5,-1(s0)
c002b6e0:	0f010793          	addi	a5,sp,240
c002b6e4:	40c78d33          	sub	s10,a5,a2
c002b6e8:	000d8b13          	mv	s6,s11
c002b6ec:	00060413          	mv	s0,a2
c002b6f0:	e09ff06f          	j	c002b4f8 <_vfiprintf_r+0x480>
c002b6f4:	ddcf80ef          	jal	ra,c0023cd0 <__sinit>
c002b6f8:	9d5ff06f          	j	c002b0cc <_vfiprintf_r+0x54>
c002b6fc:	01012783          	lw	a5,16(sp)
c002b700:	02010da3          	sb	zero,59(sp)
c002b704:	0007a403          	lw	s0,0(a5)
c002b708:	00478d93          	addi	s11,a5,4
c002b70c:	200406e3          	beqz	s0,c002c118 <_vfiprintf_r+0x10a0>
c002b710:	fff00793          	li	a5,-1
c002b714:	12fa8ee3          	beq	s5,a5,c002c050 <_vfiprintf_r+0xfd8>
c002b718:	000a8613          	mv	a2,s5
c002b71c:	00000593          	li	a1,0
c002b720:	00040513          	mv	a0,s0
c002b724:	fd4fc0ef          	jal	ra,c0027ef8 <memchr>
c002b728:	340506e3          	beqz	a0,c002c274 <_vfiprintf_r+0x11fc>
c002b72c:	40850d33          	sub	s10,a0,s0
c002b730:	01b12823          	sw	s11,16(sp)
c002b734:	00000a93          	li	s5,0
c002b738:	dc1ff06f          	j	c002b4f8 <_vfiprintf_r+0x480>
c002b73c:	01012703          	lw	a4,16(sp)
c002b740:	02010da3          	sb	zero,59(sp)
c002b744:	00100c93          	li	s9,1
c002b748:	00072783          	lw	a5,0(a4)
c002b74c:	00470713          	addi	a4,a4,4
c002b750:	00e12823          	sw	a4,16(sp)
c002b754:	08f10623          	sb	a5,140(sp)
c002b758:	00100d13          	li	s10,1
c002b75c:	08c10413          	addi	s0,sp,140
c002b760:	b31ff06f          	j	c002b290 <_vfiprintf_r+0x218>
c002b764:	01012783          	lw	a5,16(sp)
c002b768:	ffff8737          	lui	a4,0xffff8
c002b76c:	83074713          	xori	a4,a4,-2000
c002b770:	0007ad03          	lw	s10,0(a5)
c002b774:	00478793          	addi	a5,a5,4
c002b778:	00f12823          	sw	a5,16(sp)
c002b77c:	c80027b7          	lui	a5,0xc8002
c002b780:	6e478793          	addi	a5,a5,1764 # c80026e4 <_end+0xfff7de64>
c002b784:	02e11e23          	sh	a4,60(sp)
c002b788:	00000c93          	li	s9,0
c002b78c:	002b6d93          	ori	s11,s6,2
c002b790:	00f12c23          	sw	a5,24(sp)
c002b794:	00200713          	li	a4,2
c002b798:	e21ff06f          	j	c002b5b8 <_vfiprintf_r+0x540>
c002b79c:	000c4703          	lbu	a4,0(s8)
c002b7a0:	06c00793          	li	a5,108
c002b7a4:	14f70ce3          	beq	a4,a5,c002c0fc <_vfiprintf_r+0x1084>
c002b7a8:	010b6b13          	ori	s6,s6,16
c002b7ac:	a75ff06f          	j	c002b220 <_vfiprintf_r+0x1a8>
c002b7b0:	000c4703          	lbu	a4,0(s8)
c002b7b4:	06800793          	li	a5,104
c002b7b8:	12f70ae3          	beq	a4,a5,c002c0ec <_vfiprintf_r+0x1074>
c002b7bc:	040b6b13          	ori	s6,s6,64
c002b7c0:	a61ff06f          	j	c002b220 <_vfiprintf_r+0x1a8>
c002b7c4:	010b6d93          	ori	s11,s6,16
c002b7c8:	020df793          	andi	a5,s11,32
c002b7cc:	60078c63          	beqz	a5,c002bde4 <_vfiprintf_r+0xd6c>
c002b7d0:	01012783          	lw	a5,16(sp)
c002b7d4:	00100713          	li	a4,1
c002b7d8:	00778793          	addi	a5,a5,7
c002b7dc:	ff87f793          	andi	a5,a5,-8
c002b7e0:	0007ad03          	lw	s10,0(a5)
c002b7e4:	0047ac83          	lw	s9,4(a5)
c002b7e8:	00878793          	addi	a5,a5,8
c002b7ec:	00f12823          	sw	a5,16(sp)
c002b7f0:	dc9ff06f          	j	c002b5b8 <_vfiprintf_r+0x540>
c002b7f4:	000c4703          	lbu	a4,0(s8)
c002b7f8:	080b6b13          	ori	s6,s6,128
c002b7fc:	a25ff06f          	j	c002b220 <_vfiprintf_r+0x1a8>
c002b800:	01012683          	lw	a3,16(sp)
c002b804:	000c4703          	lbu	a4,0(s8)
c002b808:	0006a783          	lw	a5,0(a3)
c002b80c:	00468693          	addi	a3,a3,4
c002b810:	00d12823          	sw	a3,16(sp)
c002b814:	00f12223          	sw	a5,4(sp)
c002b818:	a007d4e3          	bgez	a5,c002b220 <_vfiprintf_r+0x1a8>
c002b81c:	40f007b3          	neg	a5,a5
c002b820:	00f12223          	sw	a5,4(sp)
c002b824:	004b6b13          	ori	s6,s6,4
c002b828:	9f9ff06f          	j	c002b220 <_vfiprintf_r+0x1a8>
c002b82c:	000c4703          	lbu	a4,0(s8)
c002b830:	001b6b13          	ori	s6,s6,1
c002b834:	9edff06f          	j	c002b220 <_vfiprintf_r+0x1a8>
c002b838:	03b14783          	lbu	a5,59(sp)
c002b83c:	000c4703          	lbu	a4,0(s8)
c002b840:	9e0790e3          	bnez	a5,c002b220 <_vfiprintf_r+0x1a8>
c002b844:	02000793          	li	a5,32
c002b848:	02f10da3          	sb	a5,59(sp)
c002b84c:	9d5ff06f          	j	c002b220 <_vfiprintf_r+0x1a8>
c002b850:	000c4703          	lbu	a4,0(s8)
c002b854:	004b6b13          	ori	s6,s6,4
c002b858:	9c9ff06f          	j	c002b220 <_vfiprintf_r+0x1a8>
c002b85c:	02b00793          	li	a5,43
c002b860:	000c4703          	lbu	a4,0(s8)
c002b864:	02f10da3          	sb	a5,59(sp)
c002b868:	9b9ff06f          	j	c002b220 <_vfiprintf_r+0x1a8>
c002b86c:	000c4703          	lbu	a4,0(s8)
c002b870:	001c0693          	addi	a3,s8,1
c002b874:	24c700e3          	beq	a4,a2,c002c2b4 <_vfiprintf_r+0x123c>
c002b878:	fd070793          	addi	a5,a4,-48 # ffff7fd0 <_end+0x37f73750>
c002b87c:	00068c13          	mv	s8,a3
c002b880:	00000a93          	li	s5,0
c002b884:	9afd60e3          	bltu	s10,a5,c002b224 <_vfiprintf_r+0x1ac>
c002b888:	000c4703          	lbu	a4,0(s8)
c002b88c:	002a9693          	slli	a3,s5,0x2
c002b890:	01568ab3          	add	s5,a3,s5
c002b894:	001a9a93          	slli	s5,s5,0x1
c002b898:	00fa8ab3          	add	s5,s5,a5
c002b89c:	fd070793          	addi	a5,a4,-48
c002b8a0:	001c0c13          	addi	s8,s8,1
c002b8a4:	fefd72e3          	bgeu	s10,a5,c002b888 <_vfiprintf_r+0x810>
c002b8a8:	97dff06f          	j	c002b224 <_vfiprintf_r+0x1ac>
c002b8ac:	01012683          	lw	a3,16(sp)
c002b8b0:	020b7793          	andi	a5,s6,32
c002b8b4:	0006a703          	lw	a4,0(a3)
c002b8b8:	00468693          	addi	a3,a3,4
c002b8bc:	00d12823          	sw	a3,16(sp)
c002b8c0:	6a079c63          	bnez	a5,c002bf78 <_vfiprintf_r+0xf00>
c002b8c4:	010b7793          	andi	a5,s6,16
c002b8c8:	040792e3          	bnez	a5,c002c10c <_vfiprintf_r+0x1094>
c002b8cc:	040b7793          	andi	a5,s6,64
c002b8d0:	120796e3          	bnez	a5,c002c1fc <_vfiprintf_r+0x1184>
c002b8d4:	200b7313          	andi	t1,s6,512
c002b8d8:	02030ae3          	beqz	t1,c002c10c <_vfiprintf_r+0x1094>
c002b8dc:	00c12783          	lw	a5,12(sp)
c002b8e0:	00f70023          	sb	a5,0(a4)
c002b8e4:	895ff06f          	j	c002b178 <_vfiprintf_r+0x100>
c002b8e8:	00100693          	li	a3,1
c002b8ec:	1ad704e3          	beq	a4,a3,c002c294 <_vfiprintf_r+0x121c>
c002b8f0:	00200693          	li	a3,2
c002b8f4:	000b0d93          	mv	s11,s6
c002b8f8:	dad710e3          	bne	a4,a3,c002b698 <_vfiprintf_r+0x620>
c002b8fc:	01812683          	lw	a3,24(sp)
c002b900:	0f010413          	addi	s0,sp,240
c002b904:	00fd7793          	andi	a5,s10,15
c002b908:	00f687b3          	add	a5,a3,a5
c002b90c:	0007c703          	lbu	a4,0(a5)
c002b910:	004d5d13          	srli	s10,s10,0x4
c002b914:	01cc9793          	slli	a5,s9,0x1c
c002b918:	01a7ed33          	or	s10,a5,s10
c002b91c:	004cdc93          	srli	s9,s9,0x4
c002b920:	fee40fa3          	sb	a4,-1(s0)
c002b924:	019d67b3          	or	a5,s10,s9
c002b928:	fff40413          	addi	s0,s0,-1
c002b92c:	fc079ce3          	bnez	a5,c002b904 <_vfiprintf_r+0x88c>
c002b930:	0f010793          	addi	a5,sp,240
c002b934:	40878d33          	sub	s10,a5,s0
c002b938:	000d8b13          	mv	s6,s11
c002b93c:	bbdff06f          	j	c002b4f8 <_vfiprintf_r+0x480>
c002b940:	00412583          	lw	a1,4(sp)
c002b944:	41958db3          	sub	s11,a1,s9
c002b948:	a3b050e3          	blez	s11,c002b368 <_vfiprintf_r+0x2f0>
c002b94c:	01000593          	li	a1,16
c002b950:	15b5dce3          	bge	a1,s11,c002c2a8 <_vfiprintf_r+0x1230>
c002b954:	01000e93          	li	t4,16
c002b958:	00700f13          	li	t5,7
c002b95c:	0180006f          	j	c002b974 <_vfiprintf_r+0x8fc>
c002b960:	00270613          	addi	a2,a4,2
c002b964:	008b8b93          	addi	s7,s7,8
c002b968:	00068713          	mv	a4,a3
c002b96c:	ff0d8d93          	addi	s11,s11,-16
c002b970:	05bedc63          	bge	t4,s11,c002b9c8 <_vfiprintf_r+0x950>
c002b974:	01078793          	addi	a5,a5,16
c002b978:	00170693          	addi	a3,a4,1
c002b97c:	012ba023          	sw	s2,0(s7)
c002b980:	01dba223          	sw	t4,4(s7)
c002b984:	04f12423          	sw	a5,72(sp)
c002b988:	04d12223          	sw	a3,68(sp)
c002b98c:	fcdf5ae3          	bge	t5,a3,c002b960 <_vfiprintf_r+0x8e8>
c002b990:	16078063          	beqz	a5,c002baf0 <_vfiprintf_r+0xa78>
c002b994:	04010613          	addi	a2,sp,64
c002b998:	00098593          	mv	a1,s3
c002b99c:	000a0513          	mv	a0,s4
c002b9a0:	dccff0ef          	jal	ra,c002af6c <__sprint_r.part.0>
c002b9a4:	a40518e3          	bnez	a0,c002b3f4 <_vfiprintf_r+0x37c>
c002b9a8:	04412703          	lw	a4,68(sp)
c002b9ac:	01000e93          	li	t4,16
c002b9b0:	ff0d8d93          	addi	s11,s11,-16
c002b9b4:	04812783          	lw	a5,72(sp)
c002b9b8:	00048b93          	mv	s7,s1
c002b9bc:	00170613          	addi	a2,a4,1
c002b9c0:	00700f13          	li	t5,7
c002b9c4:	fbbec8e3          	blt	t4,s11,c002b974 <_vfiprintf_r+0x8fc>
c002b9c8:	00060593          	mv	a1,a2
c002b9cc:	008b8513          	addi	a0,s7,8
c002b9d0:	01b787b3          	add	a5,a5,s11
c002b9d4:	012ba023          	sw	s2,0(s7)
c002b9d8:	01bba223          	sw	s11,4(s7)
c002b9dc:	04f12423          	sw	a5,72(sp)
c002b9e0:	04b12223          	sw	a1,68(sp)
c002b9e4:	00700713          	li	a4,7
c002b9e8:	52b75c63          	bge	a4,a1,c002bf20 <_vfiprintf_r+0xea8>
c002b9ec:	7c078c63          	beqz	a5,c002c1c4 <_vfiprintf_r+0x114c>
c002b9f0:	04010613          	addi	a2,sp,64
c002b9f4:	00098593          	mv	a1,s3
c002b9f8:	000a0513          	mv	a0,s4
c002b9fc:	d70ff0ef          	jal	ra,c002af6c <__sprint_r.part.0>
c002ba00:	9e051ae3          	bnez	a0,c002b3f4 <_vfiprintf_r+0x37c>
c002ba04:	04412703          	lw	a4,68(sp)
c002ba08:	41aa8ab3          	sub	s5,s5,s10
c002ba0c:	04812783          	lw	a5,72(sp)
c002ba10:	05410693          	addi	a3,sp,84
c002ba14:	00170613          	addi	a2,a4,1
c002ba18:	00048b93          	mv	s7,s1
c002ba1c:	95505ae3          	blez	s5,c002b370 <_vfiprintf_r+0x2f8>
c002ba20:	01000593          	li	a1,16
c002ba24:	7955d663          	bge	a1,s5,c002c1b0 <_vfiprintf_r+0x1138>
c002ba28:	01000893          	li	a7,16
c002ba2c:	00700d93          	li	s11,7
c002ba30:	0180006f          	j	c002ba48 <_vfiprintf_r+0x9d0>
c002ba34:	00270613          	addi	a2,a4,2
c002ba38:	008b8b93          	addi	s7,s7,8
c002ba3c:	00068713          	mv	a4,a3
c002ba40:	ff0a8a93          	addi	s5,s5,-16
c002ba44:	0558da63          	bge	a7,s5,c002ba98 <_vfiprintf_r+0xa20>
c002ba48:	01078793          	addi	a5,a5,16
c002ba4c:	00170693          	addi	a3,a4,1
c002ba50:	012ba023          	sw	s2,0(s7)
c002ba54:	011ba223          	sw	a7,4(s7)
c002ba58:	04f12423          	sw	a5,72(sp)
c002ba5c:	04d12223          	sw	a3,68(sp)
c002ba60:	fcdddae3          	bge	s11,a3,c002ba34 <_vfiprintf_r+0x9bc>
c002ba64:	06078263          	beqz	a5,c002bac8 <_vfiprintf_r+0xa50>
c002ba68:	04010613          	addi	a2,sp,64
c002ba6c:	00098593          	mv	a1,s3
c002ba70:	000a0513          	mv	a0,s4
c002ba74:	cf8ff0ef          	jal	ra,c002af6c <__sprint_r.part.0>
c002ba78:	96051ee3          	bnez	a0,c002b3f4 <_vfiprintf_r+0x37c>
c002ba7c:	04412703          	lw	a4,68(sp)
c002ba80:	01000893          	li	a7,16
c002ba84:	ff0a8a93          	addi	s5,s5,-16
c002ba88:	04812783          	lw	a5,72(sp)
c002ba8c:	00048b93          	mv	s7,s1
c002ba90:	00170613          	addi	a2,a4,1
c002ba94:	fb58cae3          	blt	a7,s5,c002ba48 <_vfiprintf_r+0x9d0>
c002ba98:	008b8593          	addi	a1,s7,8
c002ba9c:	015787b3          	add	a5,a5,s5
c002baa0:	012ba023          	sw	s2,0(s7)
c002baa4:	015ba223          	sw	s5,4(s7)
c002baa8:	04f12423          	sw	a5,72(sp)
c002baac:	04c12223          	sw	a2,68(sp)
c002bab0:	00700713          	li	a4,7
c002bab4:	2cc74e63          	blt	a4,a2,c002bd90 <_vfiprintf_r+0xd18>
c002bab8:	00160613          	addi	a2,a2,1
c002babc:	00858693          	addi	a3,a1,8
c002bac0:	00058b93          	mv	s7,a1
c002bac4:	8adff06f          	j	c002b370 <_vfiprintf_r+0x2f8>
c002bac8:	00100613          	li	a2,1
c002bacc:	00000713          	li	a4,0
c002bad0:	00048b93          	mv	s7,s1
c002bad4:	f6dff06f          	j	c002ba40 <_vfiprintf_r+0x9c8>
c002bad8:	04010613          	addi	a2,sp,64
c002badc:	00098593          	mv	a1,s3
c002bae0:	000a0513          	mv	a0,s4
c002bae4:	c88ff0ef          	jal	ra,c002af6c <__sprint_r.part.0>
c002bae8:	8e050ae3          	beqz	a0,c002b3dc <_vfiprintf_r+0x364>
c002baec:	909ff06f          	j	c002b3f4 <_vfiprintf_r+0x37c>
c002baf0:	00100613          	li	a2,1
c002baf4:	00000713          	li	a4,0
c002baf8:	00048b93          	mv	s7,s1
c002bafc:	e71ff06f          	j	c002b96c <_vfiprintf_r+0x8f4>
c002bb00:	32078463          	beqz	a5,c002be28 <_vfiprintf_r+0xdb0>
c002bb04:	04010613          	addi	a2,sp,64
c002bb08:	00098593          	mv	a1,s3
c002bb0c:	000a0513          	mv	a0,s4
c002bb10:	03e12623          	sw	t5,44(sp)
c002bb14:	03f12423          	sw	t6,40(sp)
c002bb18:	c54ff0ef          	jal	ra,c002af6c <__sprint_r.part.0>
c002bb1c:	8c051ce3          	bnez	a0,c002b3f4 <_vfiprintf_r+0x37c>
c002bb20:	04412703          	lw	a4,68(sp)
c002bb24:	04812783          	lw	a5,72(sp)
c002bb28:	02c12f03          	lw	t5,44(sp)
c002bb2c:	02812f83          	lw	t6,40(sp)
c002bb30:	05410693          	addi	a3,sp,84
c002bb34:	00170613          	addi	a2,a4,1
c002bb38:	00048b93          	mv	s7,s1
c002bb3c:	fc8ff06f          	j	c002b304 <_vfiprintf_r+0x28c>
c002bb40:	3a079463          	bnez	a5,c002bee8 <_vfiprintf_r+0xe70>
c002bb44:	03b14703          	lbu	a4,59(sp)
c002bb48:	68071c63          	bnez	a4,c002c1e0 <_vfiprintf_r+0x1168>
c002bb4c:	2e0f8063          	beqz	t6,c002be2c <_vfiprintf_r+0xdb4>
c002bb50:	03c10793          	addi	a5,sp,60
c002bb54:	04f12623          	sw	a5,76(sp)
c002bb58:	00200793          	li	a5,2
c002bb5c:	04f12823          	sw	a5,80(sp)
c002bb60:	05410693          	addi	a3,sp,84
c002bb64:	00100613          	li	a2,1
c002bb68:	00068b93          	mv	s7,a3
c002bb6c:	00060713          	mv	a4,a2
c002bb70:	00170613          	addi	a2,a4,1
c002bb74:	008b8693          	addi	a3,s7,8
c002bb78:	fe8ff06f          	j	c002b360 <_vfiprintf_r+0x2e8>
c002bb7c:	000b0d93          	mv	s11,s6
c002bb80:	b09ff06f          	j	c002b688 <_vfiprintf_r+0x610>
c002bb84:	01000613          	li	a2,16
c002bb88:	6fb65e63          	bge	a2,s11,c002c284 <_vfiprintf_r+0x120c>
c002bb8c:	000b8613          	mv	a2,s7
c002bb90:	01000e93          	li	t4,16
c002bb94:	00040b93          	mv	s7,s0
c002bb98:	00700293          	li	t0,7
c002bb9c:	00098413          	mv	s0,s3
c002bba0:	03f12423          	sw	t6,40(sp)
c002bba4:	000d8993          	mv	s3,s11
c002bba8:	000c0d93          	mv	s11,s8
c002bbac:	000a8c13          	mv	s8,s5
c002bbb0:	000f0a93          	mv	s5,t5
c002bbb4:	01c0006f          	j	c002bbd0 <_vfiprintf_r+0xb58>
c002bbb8:	00270513          	addi	a0,a4,2
c002bbbc:	00860613          	addi	a2,a2,8
c002bbc0:	00068713          	mv	a4,a3
c002bbc4:	ff098993          	addi	s3,s3,-16
c002bbc8:	053ede63          	bge	t4,s3,c002bc24 <_vfiprintf_r+0xbac>
c002bbcc:	00170693          	addi	a3,a4,1
c002bbd0:	00812583          	lw	a1,8(sp)
c002bbd4:	01078793          	addi	a5,a5,16
c002bbd8:	01d62223          	sw	t4,4(a2)
c002bbdc:	00b62023          	sw	a1,0(a2)
c002bbe0:	04f12423          	sw	a5,72(sp)
c002bbe4:	04d12223          	sw	a3,68(sp)
c002bbe8:	fcd2d8e3          	bge	t0,a3,c002bbb8 <_vfiprintf_r+0xb40>
c002bbec:	08078663          	beqz	a5,c002bc78 <_vfiprintf_r+0xc00>
c002bbf0:	04010613          	addi	a2,sp,64
c002bbf4:	00040593          	mv	a1,s0
c002bbf8:	000a0513          	mv	a0,s4
c002bbfc:	b70ff0ef          	jal	ra,c002af6c <__sprint_r.part.0>
c002bc00:	4a051463          	bnez	a0,c002c0a8 <_vfiprintf_r+0x1030>
c002bc04:	04412703          	lw	a4,68(sp)
c002bc08:	01000e93          	li	t4,16
c002bc0c:	ff098993          	addi	s3,s3,-16
c002bc10:	04812783          	lw	a5,72(sp)
c002bc14:	00048613          	mv	a2,s1
c002bc18:	00170513          	addi	a0,a4,1
c002bc1c:	00700293          	li	t0,7
c002bc20:	fb3ec6e3          	blt	t4,s3,c002bbcc <_vfiprintf_r+0xb54>
c002bc24:	02812f83          	lw	t6,40(sp)
c002bc28:	000a8f13          	mv	t5,s5
c002bc2c:	00050593          	mv	a1,a0
c002bc30:	000c0a93          	mv	s5,s8
c002bc34:	000d8c13          	mv	s8,s11
c002bc38:	00098d93          	mv	s11,s3
c002bc3c:	00040993          	mv	s3,s0
c002bc40:	000b8413          	mv	s0,s7
c002bc44:	00060b93          	mv	s7,a2
c002bc48:	00812703          	lw	a4,8(sp)
c002bc4c:	01b787b3          	add	a5,a5,s11
c002bc50:	01bba223          	sw	s11,4(s7)
c002bc54:	00eba023          	sw	a4,0(s7)
c002bc58:	04f12423          	sw	a5,72(sp)
c002bc5c:	04b12223          	sw	a1,68(sp)
c002bc60:	00700713          	li	a4,7
c002bc64:	ecb74ee3          	blt	a4,a1,c002bb40 <_vfiprintf_r+0xac8>
c002bc68:	008b8b93          	addi	s7,s7,8
c002bc6c:	00158613          	addi	a2,a1,1
c002bc70:	00058713          	mv	a4,a1
c002bc74:	e50ff06f          	j	c002b2c4 <_vfiprintf_r+0x24c>
c002bc78:	00000713          	li	a4,0
c002bc7c:	00100513          	li	a0,1
c002bc80:	00048613          	mv	a2,s1
c002bc84:	f41ff06f          	j	c002bbc4 <_vfiprintf_r+0xb4c>
c002bc88:	04012223          	sw	zero,68(sp)
c002bc8c:	004b7313          	andi	t1,s6,4
c002bc90:	0e030263          	beqz	t1,c002bd74 <_vfiprintf_r+0xcfc>
c002bc94:	00412703          	lw	a4,4(sp)
c002bc98:	41970bb3          	sub	s7,a4,s9
c002bc9c:	0d705c63          	blez	s7,c002bd74 <_vfiprintf_r+0xcfc>
c002bca0:	00048693          	mv	a3,s1
c002bca4:	01000713          	li	a4,16
c002bca8:	04412603          	lw	a2,68(sp)
c002bcac:	5f775063          	bge	a4,s7,c002c28c <_vfiprintf_r+0x1214>
c002bcb0:	01000d13          	li	s10,16
c002bcb4:	00700d93          	li	s11,7
c002bcb8:	0180006f          	j	c002bcd0 <_vfiprintf_r+0xc58>
c002bcbc:	00260513          	addi	a0,a2,2
c002bcc0:	00868693          	addi	a3,a3,8
c002bcc4:	00070613          	mv	a2,a4
c002bcc8:	ff0b8b93          	addi	s7,s7,-16
c002bccc:	057d5a63          	bge	s10,s7,c002bd20 <_vfiprintf_r+0xca8>
c002bcd0:	00812583          	lw	a1,8(sp)
c002bcd4:	01078793          	addi	a5,a5,16
c002bcd8:	00160713          	addi	a4,a2,1
c002bcdc:	00b6a023          	sw	a1,0(a3)
c002bce0:	01a6a223          	sw	s10,4(a3)
c002bce4:	04f12423          	sw	a5,72(sp)
c002bce8:	04e12223          	sw	a4,68(sp)
c002bcec:	fcedd8e3          	bge	s11,a4,c002bcbc <_vfiprintf_r+0xc44>
c002bcf0:	06078a63          	beqz	a5,c002bd64 <_vfiprintf_r+0xcec>
c002bcf4:	04010613          	addi	a2,sp,64
c002bcf8:	00098593          	mv	a1,s3
c002bcfc:	000a0513          	mv	a0,s4
c002bd00:	a6cff0ef          	jal	ra,c002af6c <__sprint_r.part.0>
c002bd04:	ee051863          	bnez	a0,c002b3f4 <_vfiprintf_r+0x37c>
c002bd08:	04412603          	lw	a2,68(sp)
c002bd0c:	ff0b8b93          	addi	s7,s7,-16
c002bd10:	04812783          	lw	a5,72(sp)
c002bd14:	00048693          	mv	a3,s1
c002bd18:	00160513          	addi	a0,a2,1
c002bd1c:	fb7d4ae3          	blt	s10,s7,c002bcd0 <_vfiprintf_r+0xc58>
c002bd20:	00050593          	mv	a1,a0
c002bd24:	00812703          	lw	a4,8(sp)
c002bd28:	017787b3          	add	a5,a5,s7
c002bd2c:	0176a223          	sw	s7,4(a3)
c002bd30:	00e6a023          	sw	a4,0(a3)
c002bd34:	04f12423          	sw	a5,72(sp)
c002bd38:	04b12223          	sw	a1,68(sp)
c002bd3c:	00700713          	li	a4,7
c002bd40:	e8b75063          	bge	a4,a1,c002b3c0 <_vfiprintf_r+0x348>
c002bd44:	02078863          	beqz	a5,c002bd74 <_vfiprintf_r+0xcfc>
c002bd48:	04010613          	addi	a2,sp,64
c002bd4c:	00098593          	mv	a1,s3
c002bd50:	000a0513          	mv	a0,s4
c002bd54:	a18ff0ef          	jal	ra,c002af6c <__sprint_r.part.0>
c002bd58:	e8051e63          	bnez	a0,c002b3f4 <_vfiprintf_r+0x37c>
c002bd5c:	04812783          	lw	a5,72(sp)
c002bd60:	e60ff06f          	j	c002b3c0 <_vfiprintf_r+0x348>
c002bd64:	00100513          	li	a0,1
c002bd68:	00000613          	li	a2,0
c002bd6c:	00048693          	mv	a3,s1
c002bd70:	f59ff06f          	j	c002bcc8 <_vfiprintf_r+0xc50>
c002bd74:	00412403          	lw	s0,4(sp)
c002bd78:	01945463          	bge	s0,s9,c002bd80 <_vfiprintf_r+0xd08>
c002bd7c:	000c8413          	mv	s0,s9
c002bd80:	00c12783          	lw	a5,12(sp)
c002bd84:	008787b3          	add	a5,a5,s0
c002bd88:	00f12623          	sw	a5,12(sp)
c002bd8c:	e50ff06f          	j	c002b3dc <_vfiprintf_r+0x364>
c002bd90:	32078063          	beqz	a5,c002c0b0 <_vfiprintf_r+0x1038>
c002bd94:	04010613          	addi	a2,sp,64
c002bd98:	00098593          	mv	a1,s3
c002bd9c:	000a0513          	mv	a0,s4
c002bda0:	9ccff0ef          	jal	ra,c002af6c <__sprint_r.part.0>
c002bda4:	e4051863          	bnez	a0,c002b3f4 <_vfiprintf_r+0x37c>
c002bda8:	04412603          	lw	a2,68(sp)
c002bdac:	04812783          	lw	a5,72(sp)
c002bdb0:	05410693          	addi	a3,sp,84
c002bdb4:	00160613          	addi	a2,a2,1
c002bdb8:	00048b93          	mv	s7,s1
c002bdbc:	db4ff06f          	j	c002b370 <_vfiprintf_r+0x2f8>
c002bdc0:	04012223          	sw	zero,68(sp)
c002bdc4:	00048b93          	mv	s7,s1
c002bdc8:	c20ff06f          	j	c002b1e8 <_vfiprintf_r+0x170>
c002bdcc:	f00a9c63          	bnez	s5,c002b4e4 <_vfiprintf_r+0x46c>
c002bdd0:	000d8b13          	mv	s6,s11
c002bdd4:	00000a93          	li	s5,0
c002bdd8:	00000d13          	li	s10,0
c002bddc:	0f010413          	addi	s0,sp,240
c002bde0:	f18ff06f          	j	c002b4f8 <_vfiprintf_r+0x480>
c002bde4:	01012683          	lw	a3,16(sp)
c002bde8:	010df793          	andi	a5,s11,16
c002bdec:	00468713          	addi	a4,a3,4
c002bdf0:	14079263          	bnez	a5,c002bf34 <_vfiprintf_r+0xebc>
c002bdf4:	040df793          	andi	a5,s11,64
c002bdf8:	36078e63          	beqz	a5,c002c174 <_vfiprintf_r+0x10fc>
c002bdfc:	01012783          	lw	a5,16(sp)
c002be00:	00000c93          	li	s9,0
c002be04:	00e12823          	sw	a4,16(sp)
c002be08:	0007dd03          	lhu	s10,0(a5)
c002be0c:	00100713          	li	a4,1
c002be10:	fa8ff06f          	j	c002b5b8 <_vfiprintf_r+0x540>
c002be14:	05410693          	addi	a3,sp,84
c002be18:	00100613          	li	a2,1
c002be1c:	00000713          	li	a4,0
c002be20:	00048b93          	mv	s7,s1
c002be24:	d3cff06f          	j	c002b360 <_vfiprintf_r+0x2e8>
c002be28:	160f9a63          	bnez	t6,c002bf9c <_vfiprintf_r+0xf24>
c002be2c:	00000713          	li	a4,0
c002be30:	05410693          	addi	a3,sp,84
c002be34:	00100613          	li	a2,1
c002be38:	00048b93          	mv	s7,s1
c002be3c:	d24ff06f          	j	c002b360 <_vfiprintf_r+0x2e8>
c002be40:	400df793          	andi	a5,s11,1024
c002be44:	03412423          	sw	s4,40(sp)
c002be48:	03312623          	sw	s3,44(sp)
c002be4c:	000c8a13          	mv	s4,s9
c002be50:	000d0993          	mv	s3,s10
c002be54:	00000b13          	li	s6,0
c002be58:	01c12d03          	lw	s10,28(sp)
c002be5c:	0f010413          	addi	s0,sp,240
c002be60:	00078c93          	mv	s9,a5
c002be64:	0240006f          	j	c002be88 <_vfiprintf_r+0xe10>
c002be68:	00a00613          	li	a2,10
c002be6c:	00000693          	li	a3,0
c002be70:	00098513          	mv	a0,s3
c002be74:	000a0593          	mv	a1,s4
c002be78:	001010ef          	jal	ra,c002d678 <__udivdi3>
c002be7c:	320a0e63          	beqz	s4,c002c1b8 <_vfiprintf_r+0x1140>
c002be80:	00050993          	mv	s3,a0
c002be84:	00058a13          	mv	s4,a1
c002be88:	00a00613          	li	a2,10
c002be8c:	00000693          	li	a3,0
c002be90:	00098513          	mv	a0,s3
c002be94:	000a0593          	mv	a1,s4
c002be98:	415010ef          	jal	ra,c002daac <__umoddi3>
c002be9c:	03050513          	addi	a0,a0,48
c002bea0:	fea40fa3          	sb	a0,-1(s0)
c002bea4:	001b0b13          	addi	s6,s6,1
c002bea8:	fff40413          	addi	s0,s0,-1
c002beac:	fa0c8ee3          	beqz	s9,c002be68 <_vfiprintf_r+0xdf0>
c002beb0:	000d4683          	lbu	a3,0(s10)
c002beb4:	fb669ae3          	bne	a3,s6,c002be68 <_vfiprintf_r+0xdf0>
c002beb8:	0ff00793          	li	a5,255
c002bebc:	fafb06e3          	beq	s6,a5,c002be68 <_vfiprintf_r+0xdf0>
c002bec0:	1a0a1463          	bnez	s4,c002c068 <_vfiprintf_r+0xff0>
c002bec4:	00900793          	li	a5,9
c002bec8:	1b37e063          	bltu	a5,s3,c002c068 <_vfiprintf_r+0xff0>
c002becc:	0f010793          	addi	a5,sp,240
c002bed0:	01a12e23          	sw	s10,28(sp)
c002bed4:	02812a03          	lw	s4,40(sp)
c002bed8:	02c12983          	lw	s3,44(sp)
c002bedc:	40878d33          	sub	s10,a5,s0
c002bee0:	000d8b13          	mv	s6,s11
c002bee4:	e14ff06f          	j	c002b4f8 <_vfiprintf_r+0x480>
c002bee8:	04010613          	addi	a2,sp,64
c002beec:	00098593          	mv	a1,s3
c002bef0:	000a0513          	mv	a0,s4
c002bef4:	03e12623          	sw	t5,44(sp)
c002bef8:	03f12423          	sw	t6,40(sp)
c002befc:	870ff0ef          	jal	ra,c002af6c <__sprint_r.part.0>
c002bf00:	ce051a63          	bnez	a0,c002b3f4 <_vfiprintf_r+0x37c>
c002bf04:	04412703          	lw	a4,68(sp)
c002bf08:	04812783          	lw	a5,72(sp)
c002bf0c:	02c12f03          	lw	t5,44(sp)
c002bf10:	02812f83          	lw	t6,40(sp)
c002bf14:	00048b93          	mv	s7,s1
c002bf18:	00170613          	addi	a2,a4,1
c002bf1c:	ba8ff06f          	j	c002b2c4 <_vfiprintf_r+0x24c>
c002bf20:	00158613          	addi	a2,a1,1
c002bf24:	00850693          	addi	a3,a0,8
c002bf28:	00058713          	mv	a4,a1
c002bf2c:	00050b93          	mv	s7,a0
c002bf30:	c38ff06f          	j	c002b368 <_vfiprintf_r+0x2f0>
c002bf34:	00e12823          	sw	a4,16(sp)
c002bf38:	0006ad03          	lw	s10,0(a3)
c002bf3c:	00000c93          	li	s9,0
c002bf40:	00100713          	li	a4,1
c002bf44:	e74ff06f          	j	c002b5b8 <_vfiprintf_r+0x540>
c002bf48:	0006ad03          	lw	s10,0(a3)
c002bf4c:	00e12823          	sw	a4,16(sp)
c002bf50:	41fd5c93          	srai	s9,s10,0x1f
c002bf54:	000c8713          	mv	a4,s9
c002bf58:	d64ff06f          	j	c002b4bc <_vfiprintf_r+0x444>
c002bf5c:	01c12783          	lw	a5,28(sp)
c002bf60:	000c4703          	lbu	a4,0(s8)
c002bf64:	aa078e63          	beqz	a5,c002b220 <_vfiprintf_r+0x1a8>
c002bf68:	0007c783          	lbu	a5,0(a5)
c002bf6c:	aa078a63          	beqz	a5,c002b220 <_vfiprintf_r+0x1a8>
c002bf70:	400b6b13          	ori	s6,s6,1024
c002bf74:	aacff06f          	j	c002b220 <_vfiprintf_r+0x1a8>
c002bf78:	00c12683          	lw	a3,12(sp)
c002bf7c:	41f6d793          	srai	a5,a3,0x1f
c002bf80:	00d72023          	sw	a3,0(a4)
c002bf84:	00f72223          	sw	a5,4(a4)
c002bf88:	9f0ff06f          	j	c002b178 <_vfiprintf_r+0x100>
c002bf8c:	0006ad03          	lw	s10,0(a3)
c002bf90:	00000c93          	li	s9,0
c002bf94:	00e12823          	sw	a4,16(sp)
c002bf98:	e18ff06f          	j	c002b5b0 <_vfiprintf_r+0x538>
c002bf9c:	03c10793          	addi	a5,sp,60
c002bfa0:	04f12623          	sw	a5,76(sp)
c002bfa4:	00200793          	li	a5,2
c002bfa8:	04f12823          	sw	a5,80(sp)
c002bfac:	05410b93          	addi	s7,sp,84
c002bfb0:	00100713          	li	a4,1
c002bfb4:	bbdff06f          	j	c002bb70 <_vfiprintf_r+0xaf8>
c002bfb8:	000b0d93          	mv	s11,s6
c002bfbc:	80dff06f          	j	c002b7c8 <_vfiprintf_r+0x750>
c002bfc0:	c80027b7          	lui	a5,0xc8002
c002bfc4:	6f878793          	addi	a5,a5,1784 # c80026f8 <_end+0xfff7de78>
c002bfc8:	00f12c23          	sw	a5,24(sp)
c002bfcc:	020b7793          	andi	a5,s6,32
c002bfd0:	06078063          	beqz	a5,c002c030 <_vfiprintf_r+0xfb8>
c002bfd4:	01012783          	lw	a5,16(sp)
c002bfd8:	00778793          	addi	a5,a5,7
c002bfdc:	ff87f793          	andi	a5,a5,-8
c002bfe0:	0007ad03          	lw	s10,0(a5)
c002bfe4:	0047ac83          	lw	s9,4(a5)
c002bfe8:	00878793          	addi	a5,a5,8
c002bfec:	00f12823          	sw	a5,16(sp)
c002bff0:	001b7693          	andi	a3,s6,1
c002bff4:	00068e63          	beqz	a3,c002c010 <_vfiprintf_r+0xf98>
c002bff8:	019d66b3          	or	a3,s10,s9
c002bffc:	00068a63          	beqz	a3,c002c010 <_vfiprintf_r+0xf98>
c002c000:	03000693          	li	a3,48
c002c004:	02d10e23          	sb	a3,60(sp)
c002c008:	02e10ea3          	sb	a4,61(sp)
c002c00c:	002b6b13          	ori	s6,s6,2
c002c010:	bffb7d93          	andi	s11,s6,-1025
c002c014:	00200713          	li	a4,2
c002c018:	da0ff06f          	j	c002b5b8 <_vfiprintf_r+0x540>
c002c01c:	c80027b7          	lui	a5,0xc8002
c002c020:	6e478793          	addi	a5,a5,1764 # c80026e4 <_end+0xfff7de64>
c002c024:	00f12c23          	sw	a5,24(sp)
c002c028:	020b7793          	andi	a5,s6,32
c002c02c:	fa0794e3          	bnez	a5,c002bfd4 <_vfiprintf_r+0xf5c>
c002c030:	01012603          	lw	a2,16(sp)
c002c034:	010b7793          	andi	a5,s6,16
c002c038:	00460693          	addi	a3,a2,4
c002c03c:	08078a63          	beqz	a5,c002c0d0 <_vfiprintf_r+0x1058>
c002c040:	00062d03          	lw	s10,0(a2)
c002c044:	00000c93          	li	s9,0
c002c048:	00d12823          	sw	a3,16(sp)
c002c04c:	fa5ff06f          	j	c002bff0 <_vfiprintf_r+0xf78>
c002c050:	00040513          	mv	a0,s0
c002c054:	814f20ef          	jal	ra,c001e068 <strlen>
c002c058:	00050d13          	mv	s10,a0
c002c05c:	01b12823          	sw	s11,16(sp)
c002c060:	00000a93          	li	s5,0
c002c064:	c94ff06f          	j	c002b4f8 <_vfiprintf_r+0x480>
c002c068:	02412783          	lw	a5,36(sp)
c002c06c:	02012583          	lw	a1,32(sp)
c002c070:	00000b13          	li	s6,0
c002c074:	40f40433          	sub	s0,s0,a5
c002c078:	00078613          	mv	a2,a5
c002c07c:	00040513          	mv	a0,s0
c002c080:	bc5fd0ef          	jal	ra,c0029c44 <strncpy>
c002c084:	001d4583          	lbu	a1,1(s10)
c002c088:	00a00613          	li	a2,10
c002c08c:	00000693          	li	a3,0
c002c090:	00b03733          	snez	a4,a1
c002c094:	00098513          	mv	a0,s3
c002c098:	000a0593          	mv	a1,s4
c002c09c:	00ed0d33          	add	s10,s10,a4
c002c0a0:	5d8010ef          	jal	ra,c002d678 <__udivdi3>
c002c0a4:	dddff06f          	j	c002be80 <_vfiprintf_r+0xe08>
c002c0a8:	00040993          	mv	s3,s0
c002c0ac:	b48ff06f          	j	c002b3f4 <_vfiprintf_r+0x37c>
c002c0b0:	00100713          	li	a4,1
c002c0b4:	000d0793          	mv	a5,s10
c002c0b8:	04812623          	sw	s0,76(sp)
c002c0bc:	05a12823          	sw	s10,80(sp)
c002c0c0:	05a12423          	sw	s10,72(sp)
c002c0c4:	04e12223          	sw	a4,68(sp)
c002c0c8:	05410693          	addi	a3,sp,84
c002c0cc:	ae0ff06f          	j	c002b3ac <_vfiprintf_r+0x334>
c002c0d0:	040b7793          	andi	a5,s6,64
c002c0d4:	06078263          	beqz	a5,c002c138 <_vfiprintf_r+0x10c0>
c002c0d8:	01012783          	lw	a5,16(sp)
c002c0dc:	00000c93          	li	s9,0
c002c0e0:	00d12823          	sw	a3,16(sp)
c002c0e4:	0007dd03          	lhu	s10,0(a5)
c002c0e8:	f09ff06f          	j	c002bff0 <_vfiprintf_r+0xf78>
c002c0ec:	001c4703          	lbu	a4,1(s8)
c002c0f0:	200b6b13          	ori	s6,s6,512
c002c0f4:	001c0c13          	addi	s8,s8,1
c002c0f8:	928ff06f          	j	c002b220 <_vfiprintf_r+0x1a8>
c002c0fc:	001c4703          	lbu	a4,1(s8)
c002c100:	020b6b13          	ori	s6,s6,32
c002c104:	001c0c13          	addi	s8,s8,1
c002c108:	918ff06f          	j	c002b220 <_vfiprintf_r+0x1a8>
c002c10c:	00c12783          	lw	a5,12(sp)
c002c110:	00f72023          	sw	a5,0(a4)
c002c114:	864ff06f          	j	c002b178 <_vfiprintf_r+0x100>
c002c118:	00600793          	li	a5,6
c002c11c:	000a8d13          	mv	s10,s5
c002c120:	0b57ec63          	bltu	a5,s5,c002c1d8 <_vfiprintf_r+0x1160>
c002c124:	c8002e37          	lui	t3,0xc8002
c002c128:	000d0c93          	mv	s9,s10
c002c12c:	01b12823          	sw	s11,16(sp)
c002c130:	70ce0413          	addi	s0,t3,1804 # c800270c <_end+0xfff7de8c>
c002c134:	95cff06f          	j	c002b290 <_vfiprintf_r+0x218>
c002c138:	200b7793          	andi	a5,s6,512
c002c13c:	10078863          	beqz	a5,c002c24c <_vfiprintf_r+0x11d4>
c002c140:	01012783          	lw	a5,16(sp)
c002c144:	00000c93          	li	s9,0
c002c148:	00d12823          	sw	a3,16(sp)
c002c14c:	0007cd03          	lbu	s10,0(a5)
c002c150:	ea1ff06f          	j	c002bff0 <_vfiprintf_r+0xf78>
c002c154:	200b7793          	andi	a5,s6,512
c002c158:	0c078e63          	beqz	a5,c002c234 <_vfiprintf_r+0x11bc>
c002c15c:	01012783          	lw	a5,16(sp)
c002c160:	00e12823          	sw	a4,16(sp)
c002c164:	00078d03          	lb	s10,0(a5)
c002c168:	41fd5c93          	srai	s9,s10,0x1f
c002c16c:	000c8713          	mv	a4,s9
c002c170:	b4cff06f          	j	c002b4bc <_vfiprintf_r+0x444>
c002c174:	200df793          	andi	a5,s11,512
c002c178:	0a078263          	beqz	a5,c002c21c <_vfiprintf_r+0x11a4>
c002c17c:	01012783          	lw	a5,16(sp)
c002c180:	00000c93          	li	s9,0
c002c184:	00e12823          	sw	a4,16(sp)
c002c188:	0007cd03          	lbu	s10,0(a5)
c002c18c:	00100713          	li	a4,1
c002c190:	c28ff06f          	j	c002b5b8 <_vfiprintf_r+0x540>
c002c194:	200b7793          	andi	a5,s6,512
c002c198:	06078863          	beqz	a5,c002c208 <_vfiprintf_r+0x1190>
c002c19c:	01012783          	lw	a5,16(sp)
c002c1a0:	00000c93          	li	s9,0
c002c1a4:	00e12823          	sw	a4,16(sp)
c002c1a8:	0007cd03          	lbu	s10,0(a5)
c002c1ac:	c04ff06f          	j	c002b5b0 <_vfiprintf_r+0x538>
c002c1b0:	00068593          	mv	a1,a3
c002c1b4:	8e9ff06f          	j	c002ba9c <_vfiprintf_r+0xa24>
c002c1b8:	00900793          	li	a5,9
c002c1bc:	cd37e2e3          	bltu	a5,s3,c002be80 <_vfiprintf_r+0xe08>
c002c1c0:	d0dff06f          	j	c002becc <_vfiprintf_r+0xe54>
c002c1c4:	05410693          	addi	a3,sp,84
c002c1c8:	00100613          	li	a2,1
c002c1cc:	00000713          	li	a4,0
c002c1d0:	00048b93          	mv	s7,s1
c002c1d4:	994ff06f          	j	c002b368 <_vfiprintf_r+0x2f0>
c002c1d8:	00600d13          	li	s10,6
c002c1dc:	f49ff06f          	j	c002c124 <_vfiprintf_r+0x10ac>
c002c1e0:	03b10793          	addi	a5,sp,59
c002c1e4:	04f12623          	sw	a5,76(sp)
c002c1e8:	00100793          	li	a5,1
c002c1ec:	04f12823          	sw	a5,80(sp)
c002c1f0:	05410693          	addi	a3,sp,84
c002c1f4:	00100613          	li	a2,1
c002c1f8:	8fcff06f          	j	c002b2f4 <_vfiprintf_r+0x27c>
c002c1fc:	00c12783          	lw	a5,12(sp)
c002c200:	00f71023          	sh	a5,0(a4)
c002c204:	f75fe06f          	j	c002b178 <_vfiprintf_r+0x100>
c002c208:	01012783          	lw	a5,16(sp)
c002c20c:	00000c93          	li	s9,0
c002c210:	00e12823          	sw	a4,16(sp)
c002c214:	0007ad03          	lw	s10,0(a5)
c002c218:	b98ff06f          	j	c002b5b0 <_vfiprintf_r+0x538>
c002c21c:	01012783          	lw	a5,16(sp)
c002c220:	00000c93          	li	s9,0
c002c224:	00e12823          	sw	a4,16(sp)
c002c228:	0007ad03          	lw	s10,0(a5)
c002c22c:	00100713          	li	a4,1
c002c230:	b88ff06f          	j	c002b5b8 <_vfiprintf_r+0x540>
c002c234:	01012783          	lw	a5,16(sp)
c002c238:	00e12823          	sw	a4,16(sp)
c002c23c:	0007ad03          	lw	s10,0(a5)
c002c240:	41fd5c93          	srai	s9,s10,0x1f
c002c244:	000c8713          	mv	a4,s9
c002c248:	a74ff06f          	j	c002b4bc <_vfiprintf_r+0x444>
c002c24c:	01012783          	lw	a5,16(sp)
c002c250:	00000c93          	li	s9,0
c002c254:	00d12823          	sw	a3,16(sp)
c002c258:	0007ad03          	lw	s10,0(a5)
c002c25c:	d95ff06f          	j	c002bff0 <_vfiprintf_r+0xf78>
c002c260:	04010613          	addi	a2,sp,64
c002c264:	00098593          	mv	a1,s3
c002c268:	000a0513          	mv	a0,s4
c002c26c:	d01fe0ef          	jal	ra,c002af6c <__sprint_r.part.0>
c002c270:	984ff06f          	j	c002b3f4 <_vfiprintf_r+0x37c>
c002c274:	000a8d13          	mv	s10,s5
c002c278:	01b12823          	sw	s11,16(sp)
c002c27c:	00000a93          	li	s5,0
c002c280:	a78ff06f          	j	c002b4f8 <_vfiprintf_r+0x480>
c002c284:	00068593          	mv	a1,a3
c002c288:	9c1ff06f          	j	c002bc48 <_vfiprintf_r+0xbd0>
c002c28c:	00160593          	addi	a1,a2,1
c002c290:	a95ff06f          	j	c002bd24 <_vfiprintf_r+0xcac>
c002c294:	000b0d93          	mv	s11,s6
c002c298:	a4cff06f          	j	c002b4e4 <_vfiprintf_r+0x46c>
c002c29c:	fff00793          	li	a5,-1
c002c2a0:	00f12623          	sw	a5,12(sp)
c002c2a4:	95cff06f          	j	c002b400 <_vfiprintf_r+0x388>
c002c2a8:	00068513          	mv	a0,a3
c002c2ac:	00060593          	mv	a1,a2
c002c2b0:	f20ff06f          	j	c002b9d0 <_vfiprintf_r+0x958>
c002c2b4:	01012783          	lw	a5,16(sp)
c002c2b8:	0007aa83          	lw	s5,0(a5)
c002c2bc:	00478793          	addi	a5,a5,4
c002c2c0:	000ad463          	bgez	s5,c002c2c8 <_vfiprintf_r+0x1250>
c002c2c4:	fff00a93          	li	s5,-1
c002c2c8:	001c4703          	lbu	a4,1(s8)
c002c2cc:	00f12823          	sw	a5,16(sp)
c002c2d0:	00068c13          	mv	s8,a3
c002c2d4:	f4dfe06f          	j	c002b220 <_vfiprintf_r+0x1a8>

c002c2d8 <vfiprintf>:
c002c2d8:	c8003737          	lui	a4,0xc8003
c002c2dc:	00050793          	mv	a5,a0
c002c2e0:	98c72503          	lw	a0,-1652(a4) # c800298c <_end+0xfff7e10c>
c002c2e4:	00060693          	mv	a3,a2
c002c2e8:	00058613          	mv	a2,a1
c002c2ec:	00078593          	mv	a1,a5
c002c2f0:	d89fe06f          	j	c002b078 <_vfiprintf_r>

c002c2f4 <__sbprintf>:
c002c2f4:	00c5d783          	lhu	a5,12(a1)
c002c2f8:	0645ae03          	lw	t3,100(a1)
c002c2fc:	00e5d303          	lhu	t1,14(a1)
c002c300:	01c5a883          	lw	a7,28(a1)
c002c304:	0245a803          	lw	a6,36(a1)
c002c308:	b8010113          	addi	sp,sp,-1152
c002c30c:	ffd7f793          	andi	a5,a5,-3
c002c310:	40000713          	li	a4,1024
c002c314:	46812c23          	sw	s0,1144(sp)
c002c318:	00f11a23          	sh	a5,20(sp)
c002c31c:	00058413          	mv	s0,a1
c002c320:	07010793          	addi	a5,sp,112
c002c324:	00810593          	addi	a1,sp,8
c002c328:	46912a23          	sw	s1,1140(sp)
c002c32c:	47212823          	sw	s2,1136(sp)
c002c330:	46112e23          	sw	ra,1148(sp)
c002c334:	00050913          	mv	s2,a0
c002c338:	07c12623          	sw	t3,108(sp)
c002c33c:	00611b23          	sh	t1,22(sp)
c002c340:	03112223          	sw	a7,36(sp)
c002c344:	03012623          	sw	a6,44(sp)
c002c348:	00f12423          	sw	a5,8(sp)
c002c34c:	00f12c23          	sw	a5,24(sp)
c002c350:	00e12823          	sw	a4,16(sp)
c002c354:	00e12e23          	sw	a4,28(sp)
c002c358:	02012023          	sw	zero,32(sp)
c002c35c:	d1dfe0ef          	jal	ra,c002b078 <_vfiprintf_r>
c002c360:	00050493          	mv	s1,a0
c002c364:	02055c63          	bgez	a0,c002c39c <__sbprintf+0xa8>
c002c368:	01415783          	lhu	a5,20(sp)
c002c36c:	0407f793          	andi	a5,a5,64
c002c370:	00078863          	beqz	a5,c002c380 <__sbprintf+0x8c>
c002c374:	00c45783          	lhu	a5,12(s0)
c002c378:	0407e793          	ori	a5,a5,64
c002c37c:	00f41623          	sh	a5,12(s0)
c002c380:	47c12083          	lw	ra,1148(sp)
c002c384:	47812403          	lw	s0,1144(sp)
c002c388:	47012903          	lw	s2,1136(sp)
c002c38c:	00048513          	mv	a0,s1
c002c390:	47412483          	lw	s1,1140(sp)
c002c394:	48010113          	addi	sp,sp,1152
c002c398:	00008067          	ret
c002c39c:	00810593          	addi	a1,sp,8
c002c3a0:	00090513          	mv	a0,s2
c002c3a4:	cf0f70ef          	jal	ra,c0023894 <_fflush_r>
c002c3a8:	fc0500e3          	beqz	a0,c002c368 <__sbprintf+0x74>
c002c3ac:	fff00493          	li	s1,-1
c002c3b0:	fb9ff06f          	j	c002c368 <__sbprintf+0x74>

c002c3b4 <_wctomb_r>:
c002c3b4:	c80037b7          	lui	a5,0xc8003
c002c3b8:	0707a783          	lw	a5,112(a5) # c8003070 <_end+0xfff7e7f0>
c002c3bc:	00078067          	jr	a5

c002c3c0 <__ascii_wctomb>:
c002c3c0:	02058463          	beqz	a1,c002c3e8 <__ascii_wctomb+0x28>
c002c3c4:	0ff00793          	li	a5,255
c002c3c8:	00c7e863          	bltu	a5,a2,c002c3d8 <__ascii_wctomb+0x18>
c002c3cc:	00c58023          	sb	a2,0(a1)
c002c3d0:	00100513          	li	a0,1
c002c3d4:	00008067          	ret
c002c3d8:	08a00793          	li	a5,138
c002c3dc:	00f52023          	sw	a5,0(a0)
c002c3e0:	fff00513          	li	a0,-1
c002c3e4:	00008067          	ret
c002c3e8:	00000513          	li	a0,0
c002c3ec:	00008067          	ret

c002c3f0 <_write_r>:
c002c3f0:	ff010113          	addi	sp,sp,-16
c002c3f4:	00058713          	mv	a4,a1
c002c3f8:	00812423          	sw	s0,8(sp)
c002c3fc:	00912223          	sw	s1,4(sp)
c002c400:	00060593          	mv	a1,a2
c002c404:	00050413          	mv	s0,a0
c002c408:	c80034b7          	lui	s1,0xc8003
c002c40c:	00068613          	mv	a2,a3
c002c410:	00070513          	mv	a0,a4
c002c414:	00112623          	sw	ra,12(sp)
c002c418:	9204a423          	sw	zero,-1752(s1) # c8002928 <_end+0xfff7e0a8>
c002c41c:	fbddd0ef          	jal	ra,c000a3d8 <_write>
c002c420:	fff00793          	li	a5,-1
c002c424:	00f50c63          	beq	a0,a5,c002c43c <_write_r+0x4c>
c002c428:	00c12083          	lw	ra,12(sp)
c002c42c:	00812403          	lw	s0,8(sp)
c002c430:	00412483          	lw	s1,4(sp)
c002c434:	01010113          	addi	sp,sp,16
c002c438:	00008067          	ret
c002c43c:	9284a783          	lw	a5,-1752(s1)
c002c440:	fe0784e3          	beqz	a5,c002c428 <_write_r+0x38>
c002c444:	00c12083          	lw	ra,12(sp)
c002c448:	00f42023          	sw	a5,0(s0)
c002c44c:	00812403          	lw	s0,8(sp)
c002c450:	00412483          	lw	s1,4(sp)
c002c454:	01010113          	addi	sp,sp,16
c002c458:	00008067          	ret

c002c45c <__assert_func>:
c002c45c:	c80037b7          	lui	a5,0xc8003
c002c460:	98c7a703          	lw	a4,-1652(a5) # c800298c <_end+0xfff7e10c>
c002c464:	ff010113          	addi	sp,sp,-16
c002c468:	00068793          	mv	a5,a3
c002c46c:	00060813          	mv	a6,a2
c002c470:	00112623          	sw	ra,12(sp)
c002c474:	00c72883          	lw	a7,12(a4)
c002c478:	00050693          	mv	a3,a0
c002c47c:	00058713          	mv	a4,a1
c002c480:	00078613          	mv	a2,a5
c002c484:	02080063          	beqz	a6,c002c4a4 <__assert_func+0x48>
c002c488:	c80027b7          	lui	a5,0xc8002
c002c48c:	7f478793          	addi	a5,a5,2036 # c80027f4 <_end+0xfff7df74>
c002c490:	c80035b7          	lui	a1,0xc8003
c002c494:	80458593          	addi	a1,a1,-2044 # c8002804 <_end+0xfff7df84>
c002c498:	00088513          	mv	a0,a7
c002c49c:	354000ef          	jal	ra,c002c7f0 <fiprintf>
c002c4a0:	379000ef          	jal	ra,c002d018 <abort>
c002c4a4:	c8003837          	lui	a6,0xc8003
c002c4a8:	80080793          	addi	a5,a6,-2048 # c8002800 <_end+0xfff7df80>
c002c4ac:	80080813          	addi	a6,a6,-2048
c002c4b0:	fe1ff06f          	j	c002c490 <__assert_func+0x34>

c002c4b4 <__assert>:
c002c4b4:	ff010113          	addi	sp,sp,-16
c002c4b8:	00060693          	mv	a3,a2
c002c4bc:	00000613          	li	a2,0
c002c4c0:	00112623          	sw	ra,12(sp)
c002c4c4:	f99ff0ef          	jal	ra,c002c45c <__assert_func>

c002c4c8 <_calloc_r>:
c002c4c8:	02c5b7b3          	mulhu	a5,a1,a2
c002c4cc:	ff010113          	addi	sp,sp,-16
c002c4d0:	00112623          	sw	ra,12(sp)
c002c4d4:	00812423          	sw	s0,8(sp)
c002c4d8:	02c585b3          	mul	a1,a1,a2
c002c4dc:	0a079063          	bnez	a5,c002c57c <_calloc_r+0xb4>
c002c4e0:	9ecfb0ef          	jal	ra,c00276cc <_malloc_r>
c002c4e4:	00050413          	mv	s0,a0
c002c4e8:	04050863          	beqz	a0,c002c538 <_calloc_r+0x70>
c002c4ec:	ffc52603          	lw	a2,-4(a0)
c002c4f0:	02400713          	li	a4,36
c002c4f4:	ffc67613          	andi	a2,a2,-4
c002c4f8:	ffc60613          	addi	a2,a2,-4
c002c4fc:	04c76863          	bltu	a4,a2,c002c54c <_calloc_r+0x84>
c002c500:	01300693          	li	a3,19
c002c504:	00050793          	mv	a5,a0
c002c508:	02c6f263          	bgeu	a3,a2,c002c52c <_calloc_r+0x64>
c002c50c:	00052023          	sw	zero,0(a0)
c002c510:	00052223          	sw	zero,4(a0)
c002c514:	01b00793          	li	a5,27
c002c518:	04c7f863          	bgeu	a5,a2,c002c568 <_calloc_r+0xa0>
c002c51c:	00052423          	sw	zero,8(a0)
c002c520:	00052623          	sw	zero,12(a0)
c002c524:	01050793          	addi	a5,a0,16
c002c528:	06e60c63          	beq	a2,a4,c002c5a0 <_calloc_r+0xd8>
c002c52c:	0007a023          	sw	zero,0(a5)
c002c530:	0007a223          	sw	zero,4(a5)
c002c534:	0007a423          	sw	zero,8(a5)
c002c538:	00c12083          	lw	ra,12(sp)
c002c53c:	00040513          	mv	a0,s0
c002c540:	00812403          	lw	s0,8(sp)
c002c544:	01010113          	addi	sp,sp,16
c002c548:	00008067          	ret
c002c54c:	00000593          	li	a1,0
c002c550:	f38f10ef          	jal	ra,c001dc88 <memset>
c002c554:	00c12083          	lw	ra,12(sp)
c002c558:	00040513          	mv	a0,s0
c002c55c:	00812403          	lw	s0,8(sp)
c002c560:	01010113          	addi	sp,sp,16
c002c564:	00008067          	ret
c002c568:	00850793          	addi	a5,a0,8
c002c56c:	0007a023          	sw	zero,0(a5)
c002c570:	0007a223          	sw	zero,4(a5)
c002c574:	0007a423          	sw	zero,8(a5)
c002c578:	fc1ff06f          	j	c002c538 <_calloc_r+0x70>
c002c57c:	dd8f10ef          	jal	ra,c001db54 <__errno>
c002c580:	00000413          	li	s0,0
c002c584:	00c00793          	li	a5,12
c002c588:	00c12083          	lw	ra,12(sp)
c002c58c:	00f52023          	sw	a5,0(a0)
c002c590:	00040513          	mv	a0,s0
c002c594:	00812403          	lw	s0,8(sp)
c002c598:	01010113          	addi	sp,sp,16
c002c59c:	00008067          	ret
c002c5a0:	00052823          	sw	zero,16(a0)
c002c5a4:	01850793          	addi	a5,a0,24
c002c5a8:	00052a23          	sw	zero,20(a0)
c002c5ac:	f81ff06f          	j	c002c52c <_calloc_r+0x64>

c002c5b0 <_close_r>:
c002c5b0:	ff010113          	addi	sp,sp,-16
c002c5b4:	00812423          	sw	s0,8(sp)
c002c5b8:	00912223          	sw	s1,4(sp)
c002c5bc:	00050413          	mv	s0,a0
c002c5c0:	c80034b7          	lui	s1,0xc8003
c002c5c4:	00058513          	mv	a0,a1
c002c5c8:	00112623          	sw	ra,12(sp)
c002c5cc:	9204a423          	sw	zero,-1752(s1) # c8002928 <_end+0xfff7e0a8>
c002c5d0:	e49dd0ef          	jal	ra,c000a418 <_close>
c002c5d4:	fff00793          	li	a5,-1
c002c5d8:	00f50c63          	beq	a0,a5,c002c5f0 <_close_r+0x40>
c002c5dc:	00c12083          	lw	ra,12(sp)
c002c5e0:	00812403          	lw	s0,8(sp)
c002c5e4:	00412483          	lw	s1,4(sp)
c002c5e8:	01010113          	addi	sp,sp,16
c002c5ec:	00008067          	ret
c002c5f0:	9284a783          	lw	a5,-1752(s1)
c002c5f4:	fe0784e3          	beqz	a5,c002c5dc <_close_r+0x2c>
c002c5f8:	00c12083          	lw	ra,12(sp)
c002c5fc:	00f42023          	sw	a5,0(s0)
c002c600:	00812403          	lw	s0,8(sp)
c002c604:	00412483          	lw	s1,4(sp)
c002c608:	01010113          	addi	sp,sp,16
c002c60c:	00008067          	ret

c002c610 <_fclose_r.part.0>:
c002c610:	ff010113          	addi	sp,sp,-16
c002c614:	00812423          	sw	s0,8(sp)
c002c618:	00912223          	sw	s1,4(sp)
c002c61c:	01212023          	sw	s2,0(sp)
c002c620:	00058413          	mv	s0,a1
c002c624:	00112623          	sw	ra,12(sp)
c002c628:	00050493          	mv	s1,a0
c002c62c:	804f70ef          	jal	ra,c0023630 <__sflush_r>
c002c630:	02c42783          	lw	a5,44(s0)
c002c634:	00050913          	mv	s2,a0
c002c638:	00078a63          	beqz	a5,c002c64c <_fclose_r.part.0+0x3c>
c002c63c:	01c42583          	lw	a1,28(s0)
c002c640:	00048513          	mv	a0,s1
c002c644:	000780e7          	jalr	a5
c002c648:	06054463          	bltz	a0,c002c6b0 <_fclose_r.part.0+0xa0>
c002c64c:	00c45783          	lhu	a5,12(s0)
c002c650:	0807f793          	andi	a5,a5,128
c002c654:	06079663          	bnez	a5,c002c6c0 <_fclose_r.part.0+0xb0>
c002c658:	03042583          	lw	a1,48(s0)
c002c65c:	00058c63          	beqz	a1,c002c674 <_fclose_r.part.0+0x64>
c002c660:	04040793          	addi	a5,s0,64
c002c664:	00f58663          	beq	a1,a5,c002c670 <_fclose_r.part.0+0x60>
c002c668:	00048513          	mv	a0,s1
c002c66c:	fecf70ef          	jal	ra,c0023e58 <_free_r>
c002c670:	02042823          	sw	zero,48(s0)
c002c674:	04442583          	lw	a1,68(s0)
c002c678:	00058863          	beqz	a1,c002c688 <_fclose_r.part.0+0x78>
c002c67c:	00048513          	mv	a0,s1
c002c680:	fd8f70ef          	jal	ra,c0023e58 <_free_r>
c002c684:	04042223          	sw	zero,68(s0)
c002c688:	e58f70ef          	jal	ra,c0023ce0 <__sfp_lock_acquire>
c002c68c:	00041623          	sh	zero,12(s0)
c002c690:	e54f70ef          	jal	ra,c0023ce4 <__sfp_lock_release>
c002c694:	00c12083          	lw	ra,12(sp)
c002c698:	00812403          	lw	s0,8(sp)
c002c69c:	00412483          	lw	s1,4(sp)
c002c6a0:	00090513          	mv	a0,s2
c002c6a4:	00012903          	lw	s2,0(sp)
c002c6a8:	01010113          	addi	sp,sp,16
c002c6ac:	00008067          	ret
c002c6b0:	00c45783          	lhu	a5,12(s0)
c002c6b4:	fff00913          	li	s2,-1
c002c6b8:	0807f793          	andi	a5,a5,128
c002c6bc:	f8078ee3          	beqz	a5,c002c658 <_fclose_r.part.0+0x48>
c002c6c0:	01042583          	lw	a1,16(s0)
c002c6c4:	00048513          	mv	a0,s1
c002c6c8:	f90f70ef          	jal	ra,c0023e58 <_free_r>
c002c6cc:	f8dff06f          	j	c002c658 <_fclose_r.part.0+0x48>

c002c6d0 <_fclose_r>:
c002c6d0:	06058463          	beqz	a1,c002c738 <_fclose_r+0x68>
c002c6d4:	fe010113          	addi	sp,sp,-32
c002c6d8:	00812c23          	sw	s0,24(sp)
c002c6dc:	00112e23          	sw	ra,28(sp)
c002c6e0:	00050413          	mv	s0,a0
c002c6e4:	00050663          	beqz	a0,c002c6f0 <_fclose_r+0x20>
c002c6e8:	03852783          	lw	a5,56(a0)
c002c6ec:	02078a63          	beqz	a5,c002c720 <_fclose_r+0x50>
c002c6f0:	00c59783          	lh	a5,12(a1)
c002c6f4:	00079c63          	bnez	a5,c002c70c <_fclose_r+0x3c>
c002c6f8:	01c12083          	lw	ra,28(sp)
c002c6fc:	01812403          	lw	s0,24(sp)
c002c700:	00000513          	li	a0,0
c002c704:	02010113          	addi	sp,sp,32
c002c708:	00008067          	ret
c002c70c:	00040513          	mv	a0,s0
c002c710:	01812403          	lw	s0,24(sp)
c002c714:	01c12083          	lw	ra,28(sp)
c002c718:	02010113          	addi	sp,sp,32
c002c71c:	ef5ff06f          	j	c002c610 <_fclose_r.part.0>
c002c720:	00b12623          	sw	a1,12(sp)
c002c724:	dacf70ef          	jal	ra,c0023cd0 <__sinit>
c002c728:	00c12583          	lw	a1,12(sp)
c002c72c:	00c59783          	lh	a5,12(a1)
c002c730:	fc0784e3          	beqz	a5,c002c6f8 <_fclose_r+0x28>
c002c734:	fd9ff06f          	j	c002c70c <_fclose_r+0x3c>
c002c738:	00000513          	li	a0,0
c002c73c:	00008067          	ret

c002c740 <fclose>:
c002c740:	06050863          	beqz	a0,c002c7b0 <fclose+0x70>
c002c744:	fe010113          	addi	sp,sp,-32
c002c748:	c80037b7          	lui	a5,0xc8003
c002c74c:	00812c23          	sw	s0,24(sp)
c002c750:	00050413          	mv	s0,a0
c002c754:	98c7a503          	lw	a0,-1652(a5) # c800298c <_end+0xfff7e10c>
c002c758:	00112e23          	sw	ra,28(sp)
c002c75c:	00050663          	beqz	a0,c002c768 <fclose+0x28>
c002c760:	03852783          	lw	a5,56(a0)
c002c764:	02078a63          	beqz	a5,c002c798 <fclose+0x58>
c002c768:	00c41783          	lh	a5,12(s0)
c002c76c:	00079c63          	bnez	a5,c002c784 <fclose+0x44>
c002c770:	01c12083          	lw	ra,28(sp)
c002c774:	01812403          	lw	s0,24(sp)
c002c778:	00000513          	li	a0,0
c002c77c:	02010113          	addi	sp,sp,32
c002c780:	00008067          	ret
c002c784:	00040593          	mv	a1,s0
c002c788:	01812403          	lw	s0,24(sp)
c002c78c:	01c12083          	lw	ra,28(sp)
c002c790:	02010113          	addi	sp,sp,32
c002c794:	e7dff06f          	j	c002c610 <_fclose_r.part.0>
c002c798:	00a12623          	sw	a0,12(sp)
c002c79c:	d34f70ef          	jal	ra,c0023cd0 <__sinit>
c002c7a0:	00c41783          	lh	a5,12(s0)
c002c7a4:	00c12503          	lw	a0,12(sp)
c002c7a8:	fc0784e3          	beqz	a5,c002c770 <fclose+0x30>
c002c7ac:	fd9ff06f          	j	c002c784 <fclose+0x44>
c002c7b0:	00000513          	li	a0,0
c002c7b4:	00008067          	ret

c002c7b8 <_fiprintf_r>:
c002c7b8:	fc010113          	addi	sp,sp,-64
c002c7bc:	02c10313          	addi	t1,sp,44
c002c7c0:	02d12623          	sw	a3,44(sp)
c002c7c4:	00030693          	mv	a3,t1
c002c7c8:	00112e23          	sw	ra,28(sp)
c002c7cc:	02e12823          	sw	a4,48(sp)
c002c7d0:	02f12a23          	sw	a5,52(sp)
c002c7d4:	03012c23          	sw	a6,56(sp)
c002c7d8:	03112e23          	sw	a7,60(sp)
c002c7dc:	00612623          	sw	t1,12(sp)
c002c7e0:	899fe0ef          	jal	ra,c002b078 <_vfiprintf_r>
c002c7e4:	01c12083          	lw	ra,28(sp)
c002c7e8:	04010113          	addi	sp,sp,64
c002c7ec:	00008067          	ret

c002c7f0 <fiprintf>:
c002c7f0:	00050e13          	mv	t3,a0
c002c7f4:	c8003537          	lui	a0,0xc8003
c002c7f8:	fc010113          	addi	sp,sp,-64
c002c7fc:	98c52503          	lw	a0,-1652(a0) # c800298c <_end+0xfff7e10c>
c002c800:	02810313          	addi	t1,sp,40
c002c804:	02c12423          	sw	a2,40(sp)
c002c808:	02d12623          	sw	a3,44(sp)
c002c80c:	00058613          	mv	a2,a1
c002c810:	00030693          	mv	a3,t1
c002c814:	000e0593          	mv	a1,t3
c002c818:	00112e23          	sw	ra,28(sp)
c002c81c:	02e12823          	sw	a4,48(sp)
c002c820:	02f12a23          	sw	a5,52(sp)
c002c824:	03012c23          	sw	a6,56(sp)
c002c828:	03112e23          	sw	a7,60(sp)
c002c82c:	00612623          	sw	t1,12(sp)
c002c830:	849fe0ef          	jal	ra,c002b078 <_vfiprintf_r>
c002c834:	01c12083          	lw	ra,28(sp)
c002c838:	04010113          	addi	sp,sp,64
c002c83c:	00008067          	ret

c002c840 <__fputwc>:
c002c840:	fd010113          	addi	sp,sp,-48
c002c844:	02812423          	sw	s0,40(sp)
c002c848:	01312e23          	sw	s3,28(sp)
c002c84c:	01612823          	sw	s6,16(sp)
c002c850:	02112623          	sw	ra,44(sp)
c002c854:	02912223          	sw	s1,36(sp)
c002c858:	03212023          	sw	s2,32(sp)
c002c85c:	01412c23          	sw	s4,24(sp)
c002c860:	01512a23          	sw	s5,20(sp)
c002c864:	00050b13          	mv	s6,a0
c002c868:	00058993          	mv	s3,a1
c002c86c:	00060413          	mv	s0,a2
c002c870:	b75fa0ef          	jal	ra,c00273e4 <__locale_mb_cur_max>
c002c874:	00100793          	li	a5,1
c002c878:	02f51063          	bne	a0,a5,c002c898 <__fputwc+0x58>
c002c87c:	fff98793          	addi	a5,s3,-1
c002c880:	0fe00713          	li	a4,254
c002c884:	00f76a63          	bltu	a4,a5,c002c898 <__fputwc+0x58>
c002c888:	0ff9f713          	andi	a4,s3,255
c002c88c:	00e10623          	sb	a4,12(sp)
c002c890:	00100913          	li	s2,1
c002c894:	02c0006f          	j	c002c8c0 <__fputwc+0x80>
c002c898:	05c40693          	addi	a3,s0,92
c002c89c:	00098613          	mv	a2,s3
c002c8a0:	00c10593          	addi	a1,sp,12
c002c8a4:	000b0513          	mv	a0,s6
c002c8a8:	664000ef          	jal	ra,c002cf0c <_wcrtomb_r>
c002c8ac:	fff00793          	li	a5,-1
c002c8b0:	00050913          	mv	s2,a0
c002c8b4:	0af50463          	beq	a0,a5,c002c95c <__fputwc+0x11c>
c002c8b8:	08050e63          	beqz	a0,c002c954 <__fputwc+0x114>
c002c8bc:	00c14703          	lbu	a4,12(sp)
c002c8c0:	00000493          	li	s1,0
c002c8c4:	fff00a13          	li	s4,-1
c002c8c8:	00a00a93          	li	s5,10
c002c8cc:	0280006f          	j	c002c8f4 <__fputwc+0xb4>
c002c8d0:	00042783          	lw	a5,0(s0)
c002c8d4:	00178693          	addi	a3,a5,1
c002c8d8:	00d42023          	sw	a3,0(s0)
c002c8dc:	00e78023          	sb	a4,0(a5)
c002c8e0:	00148493          	addi	s1,s1,1
c002c8e4:	00c10793          	addi	a5,sp,12
c002c8e8:	009787b3          	add	a5,a5,s1
c002c8ec:	0724f463          	bgeu	s1,s2,c002c954 <__fputwc+0x114>
c002c8f0:	0007c703          	lbu	a4,0(a5)
c002c8f4:	00842783          	lw	a5,8(s0)
c002c8f8:	fff78793          	addi	a5,a5,-1
c002c8fc:	00f42423          	sw	a5,8(s0)
c002c900:	fc07d8e3          	bgez	a5,c002c8d0 <__fputwc+0x90>
c002c904:	01842683          	lw	a3,24(s0)
c002c908:	00070593          	mv	a1,a4
c002c90c:	00040613          	mv	a2,s0
c002c910:	000b0513          	mv	a0,s6
c002c914:	00d7c463          	blt	a5,a3,c002c91c <__fputwc+0xdc>
c002c918:	fb571ce3          	bne	a4,s5,c002c8d0 <__fputwc+0x90>
c002c91c:	450000ef          	jal	ra,c002cd6c <__swbuf_r>
c002c920:	fd4510e3          	bne	a0,s4,c002c8e0 <__fputwc+0xa0>
c002c924:	fff00913          	li	s2,-1
c002c928:	02c12083          	lw	ra,44(sp)
c002c92c:	02812403          	lw	s0,40(sp)
c002c930:	02412483          	lw	s1,36(sp)
c002c934:	01c12983          	lw	s3,28(sp)
c002c938:	01812a03          	lw	s4,24(sp)
c002c93c:	01412a83          	lw	s5,20(sp)
c002c940:	01012b03          	lw	s6,16(sp)
c002c944:	00090513          	mv	a0,s2
c002c948:	02012903          	lw	s2,32(sp)
c002c94c:	03010113          	addi	sp,sp,48
c002c950:	00008067          	ret
c002c954:	00098913          	mv	s2,s3
c002c958:	fd1ff06f          	j	c002c928 <__fputwc+0xe8>
c002c95c:	00c45783          	lhu	a5,12(s0)
c002c960:	0407e793          	ori	a5,a5,64
c002c964:	00f41623          	sh	a5,12(s0)
c002c968:	fc1ff06f          	j	c002c928 <__fputwc+0xe8>

c002c96c <_fputwc_r>:
c002c96c:	00c61783          	lh	a5,12(a2)
c002c970:	01279713          	slli	a4,a5,0x12
c002c974:	02074063          	bltz	a4,c002c994 <_fputwc_r+0x28>
c002c978:	06462703          	lw	a4,100(a2)
c002c97c:	000026b7          	lui	a3,0x2
c002c980:	00d7e7b3          	or	a5,a5,a3
c002c984:	000026b7          	lui	a3,0x2
c002c988:	00d76733          	or	a4,a4,a3
c002c98c:	00f61623          	sh	a5,12(a2)
c002c990:	06e62223          	sw	a4,100(a2)
c002c994:	eadff06f          	j	c002c840 <__fputwc>

c002c998 <fputwc>:
c002c998:	fe010113          	addi	sp,sp,-32
c002c99c:	c80037b7          	lui	a5,0xc8003
c002c9a0:	00812c23          	sw	s0,24(sp)
c002c9a4:	98c7a403          	lw	s0,-1652(a5) # c800298c <_end+0xfff7e10c>
c002c9a8:	00112e23          	sw	ra,28(sp)
c002c9ac:	00058613          	mv	a2,a1
c002c9b0:	00050593          	mv	a1,a0
c002c9b4:	00040663          	beqz	s0,c002c9c0 <fputwc+0x28>
c002c9b8:	03842783          	lw	a5,56(s0)
c002c9bc:	04078063          	beqz	a5,c002c9fc <fputwc+0x64>
c002c9c0:	00c61783          	lh	a5,12(a2)
c002c9c4:	01279713          	slli	a4,a5,0x12
c002c9c8:	02074063          	bltz	a4,c002c9e8 <fputwc+0x50>
c002c9cc:	06462703          	lw	a4,100(a2)
c002c9d0:	000026b7          	lui	a3,0x2
c002c9d4:	00d7e7b3          	or	a5,a5,a3
c002c9d8:	000026b7          	lui	a3,0x2
c002c9dc:	00d76733          	or	a4,a4,a3
c002c9e0:	00f61623          	sh	a5,12(a2)
c002c9e4:	06e62223          	sw	a4,100(a2)
c002c9e8:	00040513          	mv	a0,s0
c002c9ec:	01812403          	lw	s0,24(sp)
c002c9f0:	01c12083          	lw	ra,28(sp)
c002c9f4:	02010113          	addi	sp,sp,32
c002c9f8:	e49ff06f          	j	c002c840 <__fputwc>
c002c9fc:	00a12423          	sw	a0,8(sp)
c002ca00:	00040513          	mv	a0,s0
c002ca04:	00c12623          	sw	a2,12(sp)
c002ca08:	ac8f70ef          	jal	ra,c0023cd0 <__sinit>
c002ca0c:	00c12603          	lw	a2,12(sp)
c002ca10:	00812583          	lw	a1,8(sp)
c002ca14:	fadff06f          	j	c002c9c0 <fputwc+0x28>

c002ca18 <_fstat_r>:
c002ca18:	ff010113          	addi	sp,sp,-16
c002ca1c:	00058713          	mv	a4,a1
c002ca20:	00812423          	sw	s0,8(sp)
c002ca24:	00912223          	sw	s1,4(sp)
c002ca28:	00050413          	mv	s0,a0
c002ca2c:	c80034b7          	lui	s1,0xc8003
c002ca30:	00060593          	mv	a1,a2
c002ca34:	00070513          	mv	a0,a4
c002ca38:	00112623          	sw	ra,12(sp)
c002ca3c:	9204a423          	sw	zero,-1752(s1) # c8002928 <_end+0xfff7e0a8>
c002ca40:	a9ddd0ef          	jal	ra,c000a4dc <_fstat>
c002ca44:	fff00793          	li	a5,-1
c002ca48:	00f50c63          	beq	a0,a5,c002ca60 <_fstat_r+0x48>
c002ca4c:	00c12083          	lw	ra,12(sp)
c002ca50:	00812403          	lw	s0,8(sp)
c002ca54:	00412483          	lw	s1,4(sp)
c002ca58:	01010113          	addi	sp,sp,16
c002ca5c:	00008067          	ret
c002ca60:	9284a783          	lw	a5,-1752(s1)
c002ca64:	fe0784e3          	beqz	a5,c002ca4c <_fstat_r+0x34>
c002ca68:	00c12083          	lw	ra,12(sp)
c002ca6c:	00f42023          	sw	a5,0(s0)
c002ca70:	00812403          	lw	s0,8(sp)
c002ca74:	00412483          	lw	s1,4(sp)
c002ca78:	01010113          	addi	sp,sp,16
c002ca7c:	00008067          	ret

c002ca80 <_isatty_r>:
c002ca80:	ff010113          	addi	sp,sp,-16
c002ca84:	00812423          	sw	s0,8(sp)
c002ca88:	00912223          	sw	s1,4(sp)
c002ca8c:	00050413          	mv	s0,a0
c002ca90:	c80034b7          	lui	s1,0xc8003
c002ca94:	00058513          	mv	a0,a1
c002ca98:	00112623          	sw	ra,12(sp)
c002ca9c:	9204a423          	sw	zero,-1752(s1) # c8002928 <_end+0xfff7e0a8>
c002caa0:	a7ddd0ef          	jal	ra,c000a51c <_isatty>
c002caa4:	fff00793          	li	a5,-1
c002caa8:	00f50c63          	beq	a0,a5,c002cac0 <_isatty_r+0x40>
c002caac:	00c12083          	lw	ra,12(sp)
c002cab0:	00812403          	lw	s0,8(sp)
c002cab4:	00412483          	lw	s1,4(sp)
c002cab8:	01010113          	addi	sp,sp,16
c002cabc:	00008067          	ret
c002cac0:	9284a783          	lw	a5,-1752(s1)
c002cac4:	fe0784e3          	beqz	a5,c002caac <_isatty_r+0x2c>
c002cac8:	00c12083          	lw	ra,12(sp)
c002cacc:	00f42023          	sw	a5,0(s0)
c002cad0:	00812403          	lw	s0,8(sp)
c002cad4:	00412483          	lw	s1,4(sp)
c002cad8:	01010113          	addi	sp,sp,16
c002cadc:	00008067          	ret

c002cae0 <_lseek_r>:
c002cae0:	ff010113          	addi	sp,sp,-16
c002cae4:	00058713          	mv	a4,a1
c002cae8:	00812423          	sw	s0,8(sp)
c002caec:	00912223          	sw	s1,4(sp)
c002caf0:	00060593          	mv	a1,a2
c002caf4:	00050413          	mv	s0,a0
c002caf8:	c80034b7          	lui	s1,0xc8003
c002cafc:	00068613          	mv	a2,a3
c002cb00:	00070513          	mv	a0,a4
c002cb04:	00112623          	sw	ra,12(sp)
c002cb08:	9204a423          	sw	zero,-1752(s1) # c8002928 <_end+0xfff7e0a8>
c002cb0c:	949dd0ef          	jal	ra,c000a454 <_lseek>
c002cb10:	fff00793          	li	a5,-1
c002cb14:	00f50c63          	beq	a0,a5,c002cb2c <_lseek_r+0x4c>
c002cb18:	00c12083          	lw	ra,12(sp)
c002cb1c:	00812403          	lw	s0,8(sp)
c002cb20:	00412483          	lw	s1,4(sp)
c002cb24:	01010113          	addi	sp,sp,16
c002cb28:	00008067          	ret
c002cb2c:	9284a783          	lw	a5,-1752(s1)
c002cb30:	fe0784e3          	beqz	a5,c002cb18 <_lseek_r+0x38>
c002cb34:	00c12083          	lw	ra,12(sp)
c002cb38:	00f42023          	sw	a5,0(s0)
c002cb3c:	00812403          	lw	s0,8(sp)
c002cb40:	00412483          	lw	s1,4(sp)
c002cb44:	01010113          	addi	sp,sp,16
c002cb48:	00008067          	ret

c002cb4c <_read_r>:
c002cb4c:	ff010113          	addi	sp,sp,-16
c002cb50:	00058713          	mv	a4,a1
c002cb54:	00812423          	sw	s0,8(sp)
c002cb58:	00912223          	sw	s1,4(sp)
c002cb5c:	00060593          	mv	a1,a2
c002cb60:	00050413          	mv	s0,a0
c002cb64:	c80034b7          	lui	s1,0xc8003
c002cb68:	00068613          	mv	a2,a3
c002cb6c:	00070513          	mv	a0,a4
c002cb70:	00112623          	sw	ra,12(sp)
c002cb74:	9204a423          	sw	zero,-1752(s1) # c8002928 <_end+0xfff7e0a8>
c002cb78:	921dd0ef          	jal	ra,c000a498 <_read>
c002cb7c:	fff00793          	li	a5,-1
c002cb80:	00f50c63          	beq	a0,a5,c002cb98 <_read_r+0x4c>
c002cb84:	00c12083          	lw	ra,12(sp)
c002cb88:	00812403          	lw	s0,8(sp)
c002cb8c:	00412483          	lw	s1,4(sp)
c002cb90:	01010113          	addi	sp,sp,16
c002cb94:	00008067          	ret
c002cb98:	9284a783          	lw	a5,-1752(s1)
c002cb9c:	fe0784e3          	beqz	a5,c002cb84 <_read_r+0x38>
c002cba0:	00c12083          	lw	ra,12(sp)
c002cba4:	00f42023          	sw	a5,0(s0)
c002cba8:	00812403          	lw	s0,8(sp)
c002cbac:	00412483          	lw	s1,4(sp)
c002cbb0:	01010113          	addi	sp,sp,16
c002cbb4:	00008067          	ret

c002cbb8 <cleanup_glue>:
c002cbb8:	fe010113          	addi	sp,sp,-32
c002cbbc:	01212823          	sw	s2,16(sp)
c002cbc0:	0005a903          	lw	s2,0(a1)
c002cbc4:	00812c23          	sw	s0,24(sp)
c002cbc8:	00912a23          	sw	s1,20(sp)
c002cbcc:	00112e23          	sw	ra,28(sp)
c002cbd0:	01312623          	sw	s3,12(sp)
c002cbd4:	01412423          	sw	s4,8(sp)
c002cbd8:	00058413          	mv	s0,a1
c002cbdc:	00050493          	mv	s1,a0
c002cbe0:	04090263          	beqz	s2,c002cc24 <cleanup_glue+0x6c>
c002cbe4:	00092983          	lw	s3,0(s2)
c002cbe8:	02098863          	beqz	s3,c002cc18 <cleanup_glue+0x60>
c002cbec:	0009aa03          	lw	s4,0(s3)
c002cbf0:	000a0e63          	beqz	s4,c002cc0c <cleanup_glue+0x54>
c002cbf4:	000a2583          	lw	a1,0(s4)
c002cbf8:	00058463          	beqz	a1,c002cc00 <cleanup_glue+0x48>
c002cbfc:	fbdff0ef          	jal	ra,c002cbb8 <cleanup_glue>
c002cc00:	000a0593          	mv	a1,s4
c002cc04:	00048513          	mv	a0,s1
c002cc08:	a50f70ef          	jal	ra,c0023e58 <_free_r>
c002cc0c:	00098593          	mv	a1,s3
c002cc10:	00048513          	mv	a0,s1
c002cc14:	a44f70ef          	jal	ra,c0023e58 <_free_r>
c002cc18:	00090593          	mv	a1,s2
c002cc1c:	00048513          	mv	a0,s1
c002cc20:	a38f70ef          	jal	ra,c0023e58 <_free_r>
c002cc24:	00040593          	mv	a1,s0
c002cc28:	01812403          	lw	s0,24(sp)
c002cc2c:	01c12083          	lw	ra,28(sp)
c002cc30:	01012903          	lw	s2,16(sp)
c002cc34:	00c12983          	lw	s3,12(sp)
c002cc38:	00812a03          	lw	s4,8(sp)
c002cc3c:	00048513          	mv	a0,s1
c002cc40:	01412483          	lw	s1,20(sp)
c002cc44:	02010113          	addi	sp,sp,32
c002cc48:	a10f706f          	j	c0023e58 <_free_r>

c002cc4c <_reclaim_reent>:
c002cc4c:	c80037b7          	lui	a5,0xc8003
c002cc50:	98c7a783          	lw	a5,-1652(a5) # c800298c <_end+0xfff7e10c>
c002cc54:	10a78a63          	beq	a5,a0,c002cd68 <_reclaim_reent+0x11c>
c002cc58:	04c52583          	lw	a1,76(a0)
c002cc5c:	fe010113          	addi	sp,sp,-32
c002cc60:	00912a23          	sw	s1,20(sp)
c002cc64:	00112e23          	sw	ra,28(sp)
c002cc68:	00812c23          	sw	s0,24(sp)
c002cc6c:	01212823          	sw	s2,16(sp)
c002cc70:	01312623          	sw	s3,12(sp)
c002cc74:	00050493          	mv	s1,a0
c002cc78:	04058063          	beqz	a1,c002ccb8 <_reclaim_reent+0x6c>
c002cc7c:	00000913          	li	s2,0
c002cc80:	08000993          	li	s3,128
c002cc84:	012587b3          	add	a5,a1,s2
c002cc88:	0007a403          	lw	s0,0(a5)
c002cc8c:	00040e63          	beqz	s0,c002cca8 <_reclaim_reent+0x5c>
c002cc90:	00040593          	mv	a1,s0
c002cc94:	00042403          	lw	s0,0(s0)
c002cc98:	00048513          	mv	a0,s1
c002cc9c:	9bcf70ef          	jal	ra,c0023e58 <_free_r>
c002cca0:	fe0418e3          	bnez	s0,c002cc90 <_reclaim_reent+0x44>
c002cca4:	04c4a583          	lw	a1,76(s1)
c002cca8:	00490913          	addi	s2,s2,4
c002ccac:	fd391ce3          	bne	s2,s3,c002cc84 <_reclaim_reent+0x38>
c002ccb0:	00048513          	mv	a0,s1
c002ccb4:	9a4f70ef          	jal	ra,c0023e58 <_free_r>
c002ccb8:	0404a583          	lw	a1,64(s1)
c002ccbc:	00058663          	beqz	a1,c002ccc8 <_reclaim_reent+0x7c>
c002ccc0:	00048513          	mv	a0,s1
c002ccc4:	994f70ef          	jal	ra,c0023e58 <_free_r>
c002ccc8:	1484a403          	lw	s0,328(s1)
c002cccc:	02040063          	beqz	s0,c002ccec <_reclaim_reent+0xa0>
c002ccd0:	14c48913          	addi	s2,s1,332
c002ccd4:	01240c63          	beq	s0,s2,c002ccec <_reclaim_reent+0xa0>
c002ccd8:	00040593          	mv	a1,s0
c002ccdc:	00042403          	lw	s0,0(s0)
c002cce0:	00048513          	mv	a0,s1
c002cce4:	974f70ef          	jal	ra,c0023e58 <_free_r>
c002cce8:	fe8918e3          	bne	s2,s0,c002ccd8 <_reclaim_reent+0x8c>
c002ccec:	0544a583          	lw	a1,84(s1)
c002ccf0:	00058663          	beqz	a1,c002ccfc <_reclaim_reent+0xb0>
c002ccf4:	00048513          	mv	a0,s1
c002ccf8:	960f70ef          	jal	ra,c0023e58 <_free_r>
c002ccfc:	0384a783          	lw	a5,56(s1)
c002cd00:	04078663          	beqz	a5,c002cd4c <_reclaim_reent+0x100>
c002cd04:	03c4a783          	lw	a5,60(s1)
c002cd08:	00048513          	mv	a0,s1
c002cd0c:	000780e7          	jalr	a5
c002cd10:	2e04a403          	lw	s0,736(s1)
c002cd14:	02040c63          	beqz	s0,c002cd4c <_reclaim_reent+0x100>
c002cd18:	00042583          	lw	a1,0(s0)
c002cd1c:	00058663          	beqz	a1,c002cd28 <_reclaim_reent+0xdc>
c002cd20:	00048513          	mv	a0,s1
c002cd24:	e95ff0ef          	jal	ra,c002cbb8 <cleanup_glue>
c002cd28:	00040593          	mv	a1,s0
c002cd2c:	01812403          	lw	s0,24(sp)
c002cd30:	01c12083          	lw	ra,28(sp)
c002cd34:	01012903          	lw	s2,16(sp)
c002cd38:	00c12983          	lw	s3,12(sp)
c002cd3c:	00048513          	mv	a0,s1
c002cd40:	01412483          	lw	s1,20(sp)
c002cd44:	02010113          	addi	sp,sp,32
c002cd48:	910f706f          	j	c0023e58 <_free_r>
c002cd4c:	01c12083          	lw	ra,28(sp)
c002cd50:	01812403          	lw	s0,24(sp)
c002cd54:	01412483          	lw	s1,20(sp)
c002cd58:	01012903          	lw	s2,16(sp)
c002cd5c:	00c12983          	lw	s3,12(sp)
c002cd60:	02010113          	addi	sp,sp,32
c002cd64:	00008067          	ret
c002cd68:	00008067          	ret

c002cd6c <__swbuf_r>:
c002cd6c:	fe010113          	addi	sp,sp,-32
c002cd70:	00812c23          	sw	s0,24(sp)
c002cd74:	00912a23          	sw	s1,20(sp)
c002cd78:	01212823          	sw	s2,16(sp)
c002cd7c:	00112e23          	sw	ra,28(sp)
c002cd80:	01312623          	sw	s3,12(sp)
c002cd84:	00050913          	mv	s2,a0
c002cd88:	00058493          	mv	s1,a1
c002cd8c:	00060413          	mv	s0,a2
c002cd90:	00050663          	beqz	a0,c002cd9c <__swbuf_r+0x30>
c002cd94:	03852783          	lw	a5,56(a0)
c002cd98:	14078a63          	beqz	a5,c002ceec <__swbuf_r+0x180>
c002cd9c:	00c41703          	lh	a4,12(s0)
c002cda0:	01842683          	lw	a3,24(s0)
c002cda4:	00877793          	andi	a5,a4,8
c002cda8:	00d42423          	sw	a3,8(s0)
c002cdac:	01071693          	slli	a3,a4,0x10
c002cdb0:	0106d693          	srli	a3,a3,0x10
c002cdb4:	08078463          	beqz	a5,c002ce3c <__swbuf_r+0xd0>
c002cdb8:	01042783          	lw	a5,16(s0)
c002cdbc:	08078063          	beqz	a5,c002ce3c <__swbuf_r+0xd0>
c002cdc0:	00002637          	lui	a2,0x2
c002cdc4:	00c6f6b3          	and	a3,a3,a2
c002cdc8:	0ff4f993          	andi	s3,s1,255
c002cdcc:	0ff4f493          	andi	s1,s1,255
c002cdd0:	0a068063          	beqz	a3,c002ce70 <__swbuf_r+0x104>
c002cdd4:	00042703          	lw	a4,0(s0)
c002cdd8:	01442683          	lw	a3,20(s0)
c002cddc:	40f707b3          	sub	a5,a4,a5
c002cde0:	0ad7de63          	bge	a5,a3,c002ce9c <__swbuf_r+0x130>
c002cde4:	00842683          	lw	a3,8(s0)
c002cde8:	00170613          	addi	a2,a4,1
c002cdec:	00c42023          	sw	a2,0(s0)
c002cdf0:	fff68693          	addi	a3,a3,-1 # 1fff <_STACK_SIZE+0xfff>
c002cdf4:	00d42423          	sw	a3,8(s0)
c002cdf8:	01370023          	sb	s3,0(a4)
c002cdfc:	01442703          	lw	a4,20(s0)
c002ce00:	00178793          	addi	a5,a5,1
c002ce04:	0cf70863          	beq	a4,a5,c002ced4 <__swbuf_r+0x168>
c002ce08:	00c45783          	lhu	a5,12(s0)
c002ce0c:	0017f793          	andi	a5,a5,1
c002ce10:	00078663          	beqz	a5,c002ce1c <__swbuf_r+0xb0>
c002ce14:	00a00793          	li	a5,10
c002ce18:	0af48e63          	beq	s1,a5,c002ced4 <__swbuf_r+0x168>
c002ce1c:	01c12083          	lw	ra,28(sp)
c002ce20:	01812403          	lw	s0,24(sp)
c002ce24:	01012903          	lw	s2,16(sp)
c002ce28:	00c12983          	lw	s3,12(sp)
c002ce2c:	00048513          	mv	a0,s1
c002ce30:	01412483          	lw	s1,20(sp)
c002ce34:	02010113          	addi	sp,sp,32
c002ce38:	00008067          	ret
c002ce3c:	00040593          	mv	a1,s0
c002ce40:	00090513          	mv	a0,s2
c002ce44:	e80f60ef          	jal	ra,c00234c4 <__swsetup_r>
c002ce48:	08051e63          	bnez	a0,c002cee4 <__swbuf_r+0x178>
c002ce4c:	00c41703          	lh	a4,12(s0)
c002ce50:	00002637          	lui	a2,0x2
c002ce54:	0ff4f993          	andi	s3,s1,255
c002ce58:	01071693          	slli	a3,a4,0x10
c002ce5c:	0106d693          	srli	a3,a3,0x10
c002ce60:	00c6f6b3          	and	a3,a3,a2
c002ce64:	01042783          	lw	a5,16(s0)
c002ce68:	0ff4f493          	andi	s1,s1,255
c002ce6c:	f60694e3          	bnez	a3,c002cdd4 <__swbuf_r+0x68>
c002ce70:	06442683          	lw	a3,100(s0)
c002ce74:	00c76733          	or	a4,a4,a2
c002ce78:	ffffe637          	lui	a2,0xffffe
c002ce7c:	fff60613          	addi	a2,a2,-1 # ffffdfff <_end+0x37f7977f>
c002ce80:	00c6f6b3          	and	a3,a3,a2
c002ce84:	00e41623          	sh	a4,12(s0)
c002ce88:	00042703          	lw	a4,0(s0)
c002ce8c:	06d42223          	sw	a3,100(s0)
c002ce90:	01442683          	lw	a3,20(s0)
c002ce94:	40f707b3          	sub	a5,a4,a5
c002ce98:	f4d7c6e3          	blt	a5,a3,c002cde4 <__swbuf_r+0x78>
c002ce9c:	00040593          	mv	a1,s0
c002cea0:	00090513          	mv	a0,s2
c002cea4:	9f1f60ef          	jal	ra,c0023894 <_fflush_r>
c002cea8:	02051e63          	bnez	a0,c002cee4 <__swbuf_r+0x178>
c002ceac:	00042703          	lw	a4,0(s0)
c002ceb0:	00842683          	lw	a3,8(s0)
c002ceb4:	00100793          	li	a5,1
c002ceb8:	00170613          	addi	a2,a4,1
c002cebc:	fff68693          	addi	a3,a3,-1
c002cec0:	00c42023          	sw	a2,0(s0)
c002cec4:	00d42423          	sw	a3,8(s0)
c002cec8:	01370023          	sb	s3,0(a4)
c002cecc:	01442703          	lw	a4,20(s0)
c002ced0:	f2f71ce3          	bne	a4,a5,c002ce08 <__swbuf_r+0x9c>
c002ced4:	00040593          	mv	a1,s0
c002ced8:	00090513          	mv	a0,s2
c002cedc:	9b9f60ef          	jal	ra,c0023894 <_fflush_r>
c002cee0:	f2050ee3          	beqz	a0,c002ce1c <__swbuf_r+0xb0>
c002cee4:	fff00493          	li	s1,-1
c002cee8:	f35ff06f          	j	c002ce1c <__swbuf_r+0xb0>
c002ceec:	de5f60ef          	jal	ra,c0023cd0 <__sinit>
c002cef0:	eadff06f          	j	c002cd9c <__swbuf_r+0x30>

c002cef4 <__swbuf>:
c002cef4:	c8003737          	lui	a4,0xc8003
c002cef8:	00050793          	mv	a5,a0
c002cefc:	98c72503          	lw	a0,-1652(a4) # c800298c <_end+0xfff7e10c>
c002cf00:	00058613          	mv	a2,a1
c002cf04:	00078593          	mv	a1,a5
c002cf08:	e65ff06f          	j	c002cd6c <__swbuf_r>

c002cf0c <_wcrtomb_r>:
c002cf0c:	fe010113          	addi	sp,sp,-32
c002cf10:	00812c23          	sw	s0,24(sp)
c002cf14:	00912a23          	sw	s1,20(sp)
c002cf18:	c80037b7          	lui	a5,0xc8003
c002cf1c:	00112e23          	sw	ra,28(sp)
c002cf20:	0707a783          	lw	a5,112(a5) # c8003070 <_end+0xfff7e7f0>
c002cf24:	00050413          	mv	s0,a0
c002cf28:	00068493          	mv	s1,a3
c002cf2c:	02058263          	beqz	a1,c002cf50 <_wcrtomb_r+0x44>
c002cf30:	000780e7          	jalr	a5
c002cf34:	fff00793          	li	a5,-1
c002cf38:	02f50663          	beq	a0,a5,c002cf64 <_wcrtomb_r+0x58>
c002cf3c:	01c12083          	lw	ra,28(sp)
c002cf40:	01812403          	lw	s0,24(sp)
c002cf44:	01412483          	lw	s1,20(sp)
c002cf48:	02010113          	addi	sp,sp,32
c002cf4c:	00008067          	ret
c002cf50:	00000613          	li	a2,0
c002cf54:	00410593          	addi	a1,sp,4
c002cf58:	000780e7          	jalr	a5
c002cf5c:	fff00793          	li	a5,-1
c002cf60:	fcf51ee3          	bne	a0,a5,c002cf3c <_wcrtomb_r+0x30>
c002cf64:	0004a023          	sw	zero,0(s1)
c002cf68:	08a00793          	li	a5,138
c002cf6c:	01c12083          	lw	ra,28(sp)
c002cf70:	00f42023          	sw	a5,0(s0)
c002cf74:	01812403          	lw	s0,24(sp)
c002cf78:	01412483          	lw	s1,20(sp)
c002cf7c:	02010113          	addi	sp,sp,32
c002cf80:	00008067          	ret

c002cf84 <wcrtomb>:
c002cf84:	fe010113          	addi	sp,sp,-32
c002cf88:	c80037b7          	lui	a5,0xc8003
c002cf8c:	00812c23          	sw	s0,24(sp)
c002cf90:	00912a23          	sw	s1,20(sp)
c002cf94:	00112e23          	sw	ra,28(sp)
c002cf98:	98c7a483          	lw	s1,-1652(a5) # c800298c <_end+0xfff7e10c>
c002cf9c:	c80037b7          	lui	a5,0xc8003
c002cfa0:	0707a783          	lw	a5,112(a5) # c8003070 <_end+0xfff7e7f0>
c002cfa4:	00060413          	mv	s0,a2
c002cfa8:	02050a63          	beqz	a0,c002cfdc <wcrtomb+0x58>
c002cfac:	00058613          	mv	a2,a1
c002cfb0:	00040693          	mv	a3,s0
c002cfb4:	00050593          	mv	a1,a0
c002cfb8:	00048513          	mv	a0,s1
c002cfbc:	000780e7          	jalr	a5
c002cfc0:	fff00793          	li	a5,-1
c002cfc4:	02f50a63          	beq	a0,a5,c002cff8 <wcrtomb+0x74>
c002cfc8:	01c12083          	lw	ra,28(sp)
c002cfcc:	01812403          	lw	s0,24(sp)
c002cfd0:	01412483          	lw	s1,20(sp)
c002cfd4:	02010113          	addi	sp,sp,32
c002cfd8:	00008067          	ret
c002cfdc:	00060693          	mv	a3,a2
c002cfe0:	00410593          	addi	a1,sp,4
c002cfe4:	00000613          	li	a2,0
c002cfe8:	00048513          	mv	a0,s1
c002cfec:	000780e7          	jalr	a5
c002cff0:	fff00793          	li	a5,-1
c002cff4:	fcf51ae3          	bne	a0,a5,c002cfc8 <wcrtomb+0x44>
c002cff8:	00042023          	sw	zero,0(s0)
c002cffc:	01c12083          	lw	ra,28(sp)
c002d000:	01812403          	lw	s0,24(sp)
c002d004:	08a00793          	li	a5,138
c002d008:	00f4a023          	sw	a5,0(s1)
c002d00c:	01412483          	lw	s1,20(sp)
c002d010:	02010113          	addi	sp,sp,32
c002d014:	00008067          	ret

c002d018 <abort>:
c002d018:	ff010113          	addi	sp,sp,-16
c002d01c:	00600513          	li	a0,6
c002d020:	00112623          	sw	ra,12(sp)
c002d024:	2cc000ef          	jal	ra,c002d2f0 <raise>
c002d028:	00100513          	li	a0,1
c002d02c:	b54dd0ef          	jal	ra,c000a380 <_exit>

c002d030 <_init_signal_r>:
c002d030:	2dc52783          	lw	a5,732(a0)
c002d034:	00078663          	beqz	a5,c002d040 <_init_signal_r+0x10>
c002d038:	00000513          	li	a0,0
c002d03c:	00008067          	ret
c002d040:	ff010113          	addi	sp,sp,-16
c002d044:	08000593          	li	a1,128
c002d048:	00812423          	sw	s0,8(sp)
c002d04c:	00112623          	sw	ra,12(sp)
c002d050:	00050413          	mv	s0,a0
c002d054:	e78fa0ef          	jal	ra,c00276cc <_malloc_r>
c002d058:	2ca42e23          	sw	a0,732(s0)
c002d05c:	02050463          	beqz	a0,c002d084 <_init_signal_r+0x54>
c002d060:	08050793          	addi	a5,a0,128
c002d064:	00052023          	sw	zero,0(a0)
c002d068:	00450513          	addi	a0,a0,4
c002d06c:	fef51ce3          	bne	a0,a5,c002d064 <_init_signal_r+0x34>
c002d070:	00000513          	li	a0,0
c002d074:	00c12083          	lw	ra,12(sp)
c002d078:	00812403          	lw	s0,8(sp)
c002d07c:	01010113          	addi	sp,sp,16
c002d080:	00008067          	ret
c002d084:	fff00513          	li	a0,-1
c002d088:	fedff06f          	j	c002d074 <_init_signal_r+0x44>

c002d08c <_signal_r>:
c002d08c:	fe010113          	addi	sp,sp,-32
c002d090:	00912a23          	sw	s1,20(sp)
c002d094:	00112e23          	sw	ra,28(sp)
c002d098:	00812c23          	sw	s0,24(sp)
c002d09c:	01f00793          	li	a5,31
c002d0a0:	00050493          	mv	s1,a0
c002d0a4:	02b7ea63          	bltu	a5,a1,c002d0d8 <_signal_r+0x4c>
c002d0a8:	2dc52703          	lw	a4,732(a0)
c002d0ac:	00058413          	mv	s0,a1
c002d0b0:	04070463          	beqz	a4,c002d0f8 <_signal_r+0x6c>
c002d0b4:	00241413          	slli	s0,s0,0x2
c002d0b8:	00870433          	add	s0,a4,s0
c002d0bc:	00042503          	lw	a0,0(s0)
c002d0c0:	00c42023          	sw	a2,0(s0)
c002d0c4:	01c12083          	lw	ra,28(sp)
c002d0c8:	01812403          	lw	s0,24(sp)
c002d0cc:	01412483          	lw	s1,20(sp)
c002d0d0:	02010113          	addi	sp,sp,32
c002d0d4:	00008067          	ret
c002d0d8:	01c12083          	lw	ra,28(sp)
c002d0dc:	01812403          	lw	s0,24(sp)
c002d0e0:	01600793          	li	a5,22
c002d0e4:	00f52023          	sw	a5,0(a0)
c002d0e8:	01412483          	lw	s1,20(sp)
c002d0ec:	fff00513          	li	a0,-1
c002d0f0:	02010113          	addi	sp,sp,32
c002d0f4:	00008067          	ret
c002d0f8:	08000593          	li	a1,128
c002d0fc:	00c12623          	sw	a2,12(sp)
c002d100:	dccfa0ef          	jal	ra,c00276cc <_malloc_r>
c002d104:	2ca4ae23          	sw	a0,732(s1)
c002d108:	00050713          	mv	a4,a0
c002d10c:	02050063          	beqz	a0,c002d12c <_signal_r+0xa0>
c002d110:	00c12603          	lw	a2,12(sp)
c002d114:	00050793          	mv	a5,a0
c002d118:	08050693          	addi	a3,a0,128
c002d11c:	0007a023          	sw	zero,0(a5)
c002d120:	00478793          	addi	a5,a5,4
c002d124:	fed79ce3          	bne	a5,a3,c002d11c <_signal_r+0x90>
c002d128:	f8dff06f          	j	c002d0b4 <_signal_r+0x28>
c002d12c:	fff00513          	li	a0,-1
c002d130:	f95ff06f          	j	c002d0c4 <_signal_r+0x38>

c002d134 <_raise_r>:
c002d134:	ff010113          	addi	sp,sp,-16
c002d138:	00912223          	sw	s1,4(sp)
c002d13c:	00112623          	sw	ra,12(sp)
c002d140:	00812423          	sw	s0,8(sp)
c002d144:	01f00793          	li	a5,31
c002d148:	00050493          	mv	s1,a0
c002d14c:	0ab7ea63          	bltu	a5,a1,c002d200 <_raise_r+0xcc>
c002d150:	2dc52783          	lw	a5,732(a0)
c002d154:	00058413          	mv	s0,a1
c002d158:	04078463          	beqz	a5,c002d1a0 <_raise_r+0x6c>
c002d15c:	00259713          	slli	a4,a1,0x2
c002d160:	00e787b3          	add	a5,a5,a4
c002d164:	0007a703          	lw	a4,0(a5)
c002d168:	02070c63          	beqz	a4,c002d1a0 <_raise_r+0x6c>
c002d16c:	00100693          	li	a3,1
c002d170:	06d70c63          	beq	a4,a3,c002d1e8 <_raise_r+0xb4>
c002d174:	fff00693          	li	a3,-1
c002d178:	04d70863          	beq	a4,a3,c002d1c8 <_raise_r+0x94>
c002d17c:	00058513          	mv	a0,a1
c002d180:	0007a023          	sw	zero,0(a5)
c002d184:	000700e7          	jalr	a4
c002d188:	00000513          	li	a0,0
c002d18c:	00c12083          	lw	ra,12(sp)
c002d190:	00812403          	lw	s0,8(sp)
c002d194:	00412483          	lw	s1,4(sp)
c002d198:	01010113          	addi	sp,sp,16
c002d19c:	00008067          	ret
c002d1a0:	00048513          	mv	a0,s1
c002d1a4:	484000ef          	jal	ra,c002d628 <_getpid_r>
c002d1a8:	00040613          	mv	a2,s0
c002d1ac:	00812403          	lw	s0,8(sp)
c002d1b0:	00c12083          	lw	ra,12(sp)
c002d1b4:	00050593          	mv	a1,a0
c002d1b8:	00048513          	mv	a0,s1
c002d1bc:	00412483          	lw	s1,4(sp)
c002d1c0:	01010113          	addi	sp,sp,16
c002d1c4:	3fc0006f          	j	c002d5c0 <_kill_r>
c002d1c8:	00c12083          	lw	ra,12(sp)
c002d1cc:	00812403          	lw	s0,8(sp)
c002d1d0:	01600793          	li	a5,22
c002d1d4:	00f52023          	sw	a5,0(a0)
c002d1d8:	00412483          	lw	s1,4(sp)
c002d1dc:	00100513          	li	a0,1
c002d1e0:	01010113          	addi	sp,sp,16
c002d1e4:	00008067          	ret
c002d1e8:	00c12083          	lw	ra,12(sp)
c002d1ec:	00812403          	lw	s0,8(sp)
c002d1f0:	00412483          	lw	s1,4(sp)
c002d1f4:	00000513          	li	a0,0
c002d1f8:	01010113          	addi	sp,sp,16
c002d1fc:	00008067          	ret
c002d200:	01600793          	li	a5,22
c002d204:	00f52023          	sw	a5,0(a0)
c002d208:	fff00513          	li	a0,-1
c002d20c:	f81ff06f          	j	c002d18c <_raise_r+0x58>

c002d210 <__sigtramp_r>:
c002d210:	01f00793          	li	a5,31
c002d214:	0cb7ea63          	bltu	a5,a1,c002d2e8 <__sigtramp_r+0xd8>
c002d218:	2dc52703          	lw	a4,732(a0)
c002d21c:	ff010113          	addi	sp,sp,-16
c002d220:	00812423          	sw	s0,8(sp)
c002d224:	00912223          	sw	s1,4(sp)
c002d228:	00112623          	sw	ra,12(sp)
c002d22c:	00058413          	mv	s0,a1
c002d230:	00050493          	mv	s1,a0
c002d234:	06070063          	beqz	a4,c002d294 <__sigtramp_r+0x84>
c002d238:	00241513          	slli	a0,s0,0x2
c002d23c:	00a70733          	add	a4,a4,a0
c002d240:	00072783          	lw	a5,0(a4)
c002d244:	02078c63          	beqz	a5,c002d27c <__sigtramp_r+0x6c>
c002d248:	fff00693          	li	a3,-1
c002d24c:	08d78663          	beq	a5,a3,c002d2d8 <__sigtramp_r+0xc8>
c002d250:	00100693          	li	a3,1
c002d254:	06d78663          	beq	a5,a3,c002d2c0 <__sigtramp_r+0xb0>
c002d258:	00040513          	mv	a0,s0
c002d25c:	00072023          	sw	zero,0(a4)
c002d260:	000780e7          	jalr	a5
c002d264:	00000513          	li	a0,0
c002d268:	00c12083          	lw	ra,12(sp)
c002d26c:	00812403          	lw	s0,8(sp)
c002d270:	00412483          	lw	s1,4(sp)
c002d274:	01010113          	addi	sp,sp,16
c002d278:	00008067          	ret
c002d27c:	00c12083          	lw	ra,12(sp)
c002d280:	00812403          	lw	s0,8(sp)
c002d284:	00412483          	lw	s1,4(sp)
c002d288:	00100513          	li	a0,1
c002d28c:	01010113          	addi	sp,sp,16
c002d290:	00008067          	ret
c002d294:	08000593          	li	a1,128
c002d298:	c34fa0ef          	jal	ra,c00276cc <_malloc_r>
c002d29c:	2ca4ae23          	sw	a0,732(s1)
c002d2a0:	00050713          	mv	a4,a0
c002d2a4:	02050e63          	beqz	a0,c002d2e0 <__sigtramp_r+0xd0>
c002d2a8:	00050793          	mv	a5,a0
c002d2ac:	08050693          	addi	a3,a0,128
c002d2b0:	0007a023          	sw	zero,0(a5)
c002d2b4:	00478793          	addi	a5,a5,4
c002d2b8:	fed79ce3          	bne	a5,a3,c002d2b0 <__sigtramp_r+0xa0>
c002d2bc:	f7dff06f          	j	c002d238 <__sigtramp_r+0x28>
c002d2c0:	00c12083          	lw	ra,12(sp)
c002d2c4:	00812403          	lw	s0,8(sp)
c002d2c8:	00412483          	lw	s1,4(sp)
c002d2cc:	00300513          	li	a0,3
c002d2d0:	01010113          	addi	sp,sp,16
c002d2d4:	00008067          	ret
c002d2d8:	00200513          	li	a0,2
c002d2dc:	f8dff06f          	j	c002d268 <__sigtramp_r+0x58>
c002d2e0:	fff00513          	li	a0,-1
c002d2e4:	f85ff06f          	j	c002d268 <__sigtramp_r+0x58>
c002d2e8:	fff00513          	li	a0,-1
c002d2ec:	00008067          	ret

c002d2f0 <raise>:
c002d2f0:	ff010113          	addi	sp,sp,-16
c002d2f4:	00912223          	sw	s1,4(sp)
c002d2f8:	c8003737          	lui	a4,0xc8003
c002d2fc:	00112623          	sw	ra,12(sp)
c002d300:	00812423          	sw	s0,8(sp)
c002d304:	01f00793          	li	a5,31
c002d308:	98c72483          	lw	s1,-1652(a4) # c800298c <_end+0xfff7e10c>
c002d30c:	0aa7e863          	bltu	a5,a0,c002d3bc <raise+0xcc>
c002d310:	2dc4a783          	lw	a5,732(s1)
c002d314:	00050413          	mv	s0,a0
c002d318:	04078263          	beqz	a5,c002d35c <raise+0x6c>
c002d31c:	00251713          	slli	a4,a0,0x2
c002d320:	00e787b3          	add	a5,a5,a4
c002d324:	0007a703          	lw	a4,0(a5)
c002d328:	02070a63          	beqz	a4,c002d35c <raise+0x6c>
c002d32c:	00100693          	li	a3,1
c002d330:	06d70a63          	beq	a4,a3,c002d3a4 <raise+0xb4>
c002d334:	fff00693          	li	a3,-1
c002d338:	04d70663          	beq	a4,a3,c002d384 <raise+0x94>
c002d33c:	0007a023          	sw	zero,0(a5)
c002d340:	000700e7          	jalr	a4
c002d344:	00000513          	li	a0,0
c002d348:	00c12083          	lw	ra,12(sp)
c002d34c:	00812403          	lw	s0,8(sp)
c002d350:	00412483          	lw	s1,4(sp)
c002d354:	01010113          	addi	sp,sp,16
c002d358:	00008067          	ret
c002d35c:	00048513          	mv	a0,s1
c002d360:	2c8000ef          	jal	ra,c002d628 <_getpid_r>
c002d364:	00040613          	mv	a2,s0
c002d368:	00812403          	lw	s0,8(sp)
c002d36c:	00c12083          	lw	ra,12(sp)
c002d370:	00050593          	mv	a1,a0
c002d374:	00048513          	mv	a0,s1
c002d378:	00412483          	lw	s1,4(sp)
c002d37c:	01010113          	addi	sp,sp,16
c002d380:	2400006f          	j	c002d5c0 <_kill_r>
c002d384:	00c12083          	lw	ra,12(sp)
c002d388:	00812403          	lw	s0,8(sp)
c002d38c:	01600793          	li	a5,22
c002d390:	00f4a023          	sw	a5,0(s1)
c002d394:	00100513          	li	a0,1
c002d398:	00412483          	lw	s1,4(sp)
c002d39c:	01010113          	addi	sp,sp,16
c002d3a0:	00008067          	ret
c002d3a4:	00c12083          	lw	ra,12(sp)
c002d3a8:	00812403          	lw	s0,8(sp)
c002d3ac:	00412483          	lw	s1,4(sp)
c002d3b0:	00000513          	li	a0,0
c002d3b4:	01010113          	addi	sp,sp,16
c002d3b8:	00008067          	ret
c002d3bc:	01600793          	li	a5,22
c002d3c0:	00f4a023          	sw	a5,0(s1)
c002d3c4:	fff00513          	li	a0,-1
c002d3c8:	f81ff06f          	j	c002d348 <raise+0x58>

c002d3cc <signal>:
c002d3cc:	ff010113          	addi	sp,sp,-16
c002d3d0:	01212023          	sw	s2,0(sp)
c002d3d4:	c8003737          	lui	a4,0xc8003
c002d3d8:	00112623          	sw	ra,12(sp)
c002d3dc:	00812423          	sw	s0,8(sp)
c002d3e0:	00912223          	sw	s1,4(sp)
c002d3e4:	01f00793          	li	a5,31
c002d3e8:	98c72903          	lw	s2,-1652(a4) # c800298c <_end+0xfff7e10c>
c002d3ec:	02a7ee63          	bltu	a5,a0,c002d428 <signal+0x5c>
c002d3f0:	00050413          	mv	s0,a0
c002d3f4:	2dc92503          	lw	a0,732(s2)
c002d3f8:	00058493          	mv	s1,a1
c002d3fc:	04050863          	beqz	a0,c002d44c <signal+0x80>
c002d400:	00241413          	slli	s0,s0,0x2
c002d404:	00850433          	add	s0,a0,s0
c002d408:	00042503          	lw	a0,0(s0)
c002d40c:	00942023          	sw	s1,0(s0)
c002d410:	00c12083          	lw	ra,12(sp)
c002d414:	00812403          	lw	s0,8(sp)
c002d418:	00412483          	lw	s1,4(sp)
c002d41c:	00012903          	lw	s2,0(sp)
c002d420:	01010113          	addi	sp,sp,16
c002d424:	00008067          	ret
c002d428:	00c12083          	lw	ra,12(sp)
c002d42c:	00812403          	lw	s0,8(sp)
c002d430:	01600793          	li	a5,22
c002d434:	00f92023          	sw	a5,0(s2)
c002d438:	00412483          	lw	s1,4(sp)
c002d43c:	00012903          	lw	s2,0(sp)
c002d440:	fff00513          	li	a0,-1
c002d444:	01010113          	addi	sp,sp,16
c002d448:	00008067          	ret
c002d44c:	08000593          	li	a1,128
c002d450:	00090513          	mv	a0,s2
c002d454:	a78fa0ef          	jal	ra,c00276cc <_malloc_r>
c002d458:	2ca92e23          	sw	a0,732(s2)
c002d45c:	00050e63          	beqz	a0,c002d478 <signal+0xac>
c002d460:	00050793          	mv	a5,a0
c002d464:	08050713          	addi	a4,a0,128
c002d468:	0007a023          	sw	zero,0(a5)
c002d46c:	00478793          	addi	a5,a5,4
c002d470:	fef71ce3          	bne	a4,a5,c002d468 <signal+0x9c>
c002d474:	f8dff06f          	j	c002d400 <signal+0x34>
c002d478:	fff00513          	li	a0,-1
c002d47c:	f95ff06f          	j	c002d410 <signal+0x44>

c002d480 <_init_signal>:
c002d480:	ff010113          	addi	sp,sp,-16
c002d484:	c80037b7          	lui	a5,0xc8003
c002d488:	00812423          	sw	s0,8(sp)
c002d48c:	98c7a403          	lw	s0,-1652(a5) # c800298c <_end+0xfff7e10c>
c002d490:	00112623          	sw	ra,12(sp)
c002d494:	2dc42783          	lw	a5,732(s0)
c002d498:	00078c63          	beqz	a5,c002d4b0 <_init_signal+0x30>
c002d49c:	00000513          	li	a0,0
c002d4a0:	00c12083          	lw	ra,12(sp)
c002d4a4:	00812403          	lw	s0,8(sp)
c002d4a8:	01010113          	addi	sp,sp,16
c002d4ac:	00008067          	ret
c002d4b0:	08000593          	li	a1,128
c002d4b4:	00040513          	mv	a0,s0
c002d4b8:	a14fa0ef          	jal	ra,c00276cc <_malloc_r>
c002d4bc:	2ca42e23          	sw	a0,732(s0)
c002d4c0:	00050c63          	beqz	a0,c002d4d8 <_init_signal+0x58>
c002d4c4:	08050793          	addi	a5,a0,128
c002d4c8:	00052023          	sw	zero,0(a0)
c002d4cc:	00450513          	addi	a0,a0,4
c002d4d0:	fef51ce3          	bne	a0,a5,c002d4c8 <_init_signal+0x48>
c002d4d4:	fc9ff06f          	j	c002d49c <_init_signal+0x1c>
c002d4d8:	fff00513          	li	a0,-1
c002d4dc:	fc5ff06f          	j	c002d4a0 <_init_signal+0x20>

c002d4e0 <__sigtramp>:
c002d4e0:	ff010113          	addi	sp,sp,-16
c002d4e4:	00912223          	sw	s1,4(sp)
c002d4e8:	c8003737          	lui	a4,0xc8003
c002d4ec:	00112623          	sw	ra,12(sp)
c002d4f0:	00812423          	sw	s0,8(sp)
c002d4f4:	01f00793          	li	a5,31
c002d4f8:	98c72483          	lw	s1,-1652(a4) # c800298c <_end+0xfff7e10c>
c002d4fc:	0aa7ee63          	bltu	a5,a0,c002d5b8 <__sigtramp+0xd8>
c002d500:	2dc4a703          	lw	a4,732(s1)
c002d504:	00050413          	mv	s0,a0
c002d508:	06070063          	beqz	a4,c002d568 <__sigtramp+0x88>
c002d50c:	00241513          	slli	a0,s0,0x2
c002d510:	00a70733          	add	a4,a4,a0
c002d514:	00072783          	lw	a5,0(a4)
c002d518:	02078c63          	beqz	a5,c002d550 <__sigtramp+0x70>
c002d51c:	fff00693          	li	a3,-1
c002d520:	08d78863          	beq	a5,a3,c002d5b0 <__sigtramp+0xd0>
c002d524:	00100693          	li	a3,1
c002d528:	06d78863          	beq	a5,a3,c002d598 <__sigtramp+0xb8>
c002d52c:	00040513          	mv	a0,s0
c002d530:	00072023          	sw	zero,0(a4)
c002d534:	000780e7          	jalr	a5
c002d538:	00000513          	li	a0,0
c002d53c:	00c12083          	lw	ra,12(sp)
c002d540:	00812403          	lw	s0,8(sp)
c002d544:	00412483          	lw	s1,4(sp)
c002d548:	01010113          	addi	sp,sp,16
c002d54c:	00008067          	ret
c002d550:	00c12083          	lw	ra,12(sp)
c002d554:	00812403          	lw	s0,8(sp)
c002d558:	00412483          	lw	s1,4(sp)
c002d55c:	00100513          	li	a0,1
c002d560:	01010113          	addi	sp,sp,16
c002d564:	00008067          	ret
c002d568:	08000593          	li	a1,128
c002d56c:	00048513          	mv	a0,s1
c002d570:	95cfa0ef          	jal	ra,c00276cc <_malloc_r>
c002d574:	2ca4ae23          	sw	a0,732(s1)
c002d578:	00050713          	mv	a4,a0
c002d57c:	02050e63          	beqz	a0,c002d5b8 <__sigtramp+0xd8>
c002d580:	00050793          	mv	a5,a0
c002d584:	08050693          	addi	a3,a0,128
c002d588:	0007a023          	sw	zero,0(a5)
c002d58c:	00478793          	addi	a5,a5,4
c002d590:	fed79ce3          	bne	a5,a3,c002d588 <__sigtramp+0xa8>
c002d594:	f79ff06f          	j	c002d50c <__sigtramp+0x2c>
c002d598:	00c12083          	lw	ra,12(sp)
c002d59c:	00812403          	lw	s0,8(sp)
c002d5a0:	00412483          	lw	s1,4(sp)
c002d5a4:	00300513          	li	a0,3
c002d5a8:	01010113          	addi	sp,sp,16
c002d5ac:	00008067          	ret
c002d5b0:	00200513          	li	a0,2
c002d5b4:	f89ff06f          	j	c002d53c <__sigtramp+0x5c>
c002d5b8:	fff00513          	li	a0,-1
c002d5bc:	f81ff06f          	j	c002d53c <__sigtramp+0x5c>

c002d5c0 <_kill_r>:
c002d5c0:	ff010113          	addi	sp,sp,-16
c002d5c4:	00058713          	mv	a4,a1
c002d5c8:	00812423          	sw	s0,8(sp)
c002d5cc:	00912223          	sw	s1,4(sp)
c002d5d0:	00050413          	mv	s0,a0
c002d5d4:	c80034b7          	lui	s1,0xc8003
c002d5d8:	00060593          	mv	a1,a2
c002d5dc:	00070513          	mv	a0,a4
c002d5e0:	00112623          	sw	ra,12(sp)
c002d5e4:	9204a423          	sw	zero,-1752(s1) # c8002928 <_end+0xfff7e0a8>
c002d5e8:	f71dc0ef          	jal	ra,c000a558 <_kill>
c002d5ec:	fff00793          	li	a5,-1
c002d5f0:	00f50c63          	beq	a0,a5,c002d608 <_kill_r+0x48>
c002d5f4:	00c12083          	lw	ra,12(sp)
c002d5f8:	00812403          	lw	s0,8(sp)
c002d5fc:	00412483          	lw	s1,4(sp)
c002d600:	01010113          	addi	sp,sp,16
c002d604:	00008067          	ret
c002d608:	9284a783          	lw	a5,-1752(s1)
c002d60c:	fe0784e3          	beqz	a5,c002d5f4 <_kill_r+0x34>
c002d610:	00c12083          	lw	ra,12(sp)
c002d614:	00f42023          	sw	a5,0(s0)
c002d618:	00812403          	lw	s0,8(sp)
c002d61c:	00412483          	lw	s1,4(sp)
c002d620:	01010113          	addi	sp,sp,16
c002d624:	00008067          	ret

c002d628 <_getpid_r>:
c002d628:	f71dc06f          	j	c000a598 <_getpid>

c002d62c <__clzsi2>:
c002d62c:	000107b7          	lui	a5,0x10
c002d630:	02f57a63          	bgeu	a0,a5,c002d664 <__clzsi2+0x38>
c002d634:	0ff00793          	li	a5,255
c002d638:	00a7b7b3          	sltu	a5,a5,a0
c002d63c:	00379793          	slli	a5,a5,0x3
c002d640:	c8002737          	lui	a4,0xc8002
c002d644:	02000693          	li	a3,32
c002d648:	40f686b3          	sub	a3,a3,a5
c002d64c:	00f55533          	srl	a0,a0,a5
c002d650:	5d070793          	addi	a5,a4,1488 # c80025d0 <_end+0xfff7dd50>
c002d654:	00a78533          	add	a0,a5,a0
c002d658:	00054503          	lbu	a0,0(a0)
c002d65c:	40a68533          	sub	a0,a3,a0
c002d660:	00008067          	ret
c002d664:	01000737          	lui	a4,0x1000
c002d668:	01000793          	li	a5,16
c002d66c:	fce56ae3          	bltu	a0,a4,c002d640 <__clzsi2+0x14>
c002d670:	01800793          	li	a5,24
c002d674:	fcdff06f          	j	c002d640 <__clzsi2+0x14>

c002d678 <__udivdi3>:
c002d678:	00050893          	mv	a7,a0
c002d67c:	00058793          	mv	a5,a1
c002d680:	00060813          	mv	a6,a2
c002d684:	00068513          	mv	a0,a3
c002d688:	00088313          	mv	t1,a7
c002d68c:	28069463          	bnez	a3,c002d914 <__udivdi3+0x29c>
c002d690:	c80026b7          	lui	a3,0xc8002
c002d694:	5d068693          	addi	a3,a3,1488 # c80025d0 <_end+0xfff7dd50>
c002d698:	0ec5f663          	bgeu	a1,a2,c002d784 <__udivdi3+0x10c>
c002d69c:	00010737          	lui	a4,0x10
c002d6a0:	0ce67863          	bgeu	a2,a4,c002d770 <__udivdi3+0xf8>
c002d6a4:	0ff00713          	li	a4,255
c002d6a8:	00c73733          	sltu	a4,a4,a2
c002d6ac:	00371713          	slli	a4,a4,0x3
c002d6b0:	00e65533          	srl	a0,a2,a4
c002d6b4:	00a686b3          	add	a3,a3,a0
c002d6b8:	0006c683          	lbu	a3,0(a3)
c002d6bc:	02000513          	li	a0,32
c002d6c0:	00e68733          	add	a4,a3,a4
c002d6c4:	40e506b3          	sub	a3,a0,a4
c002d6c8:	00e50c63          	beq	a0,a4,c002d6e0 <__udivdi3+0x68>
c002d6cc:	00d795b3          	sll	a1,a5,a3
c002d6d0:	00e8d733          	srl	a4,a7,a4
c002d6d4:	00d61833          	sll	a6,a2,a3
c002d6d8:	00b765b3          	or	a1,a4,a1
c002d6dc:	00d89333          	sll	t1,a7,a3
c002d6e0:	01085893          	srli	a7,a6,0x10
c002d6e4:	0315d6b3          	divu	a3,a1,a7
c002d6e8:	01081613          	slli	a2,a6,0x10
c002d6ec:	01065613          	srli	a2,a2,0x10
c002d6f0:	01035793          	srli	a5,t1,0x10
c002d6f4:	0315f733          	remu	a4,a1,a7
c002d6f8:	00068513          	mv	a0,a3
c002d6fc:	02d605b3          	mul	a1,a2,a3
c002d700:	01071713          	slli	a4,a4,0x10
c002d704:	00f767b3          	or	a5,a4,a5
c002d708:	00b7fe63          	bgeu	a5,a1,c002d724 <__udivdi3+0xac>
c002d70c:	010787b3          	add	a5,a5,a6
c002d710:	fff68513          	addi	a0,a3,-1
c002d714:	0107e863          	bltu	a5,a6,c002d724 <__udivdi3+0xac>
c002d718:	00b7f663          	bgeu	a5,a1,c002d724 <__udivdi3+0xac>
c002d71c:	ffe68513          	addi	a0,a3,-2
c002d720:	010787b3          	add	a5,a5,a6
c002d724:	40b787b3          	sub	a5,a5,a1
c002d728:	0317f733          	remu	a4,a5,a7
c002d72c:	01031313          	slli	t1,t1,0x10
c002d730:	01035313          	srli	t1,t1,0x10
c002d734:	0317d7b3          	divu	a5,a5,a7
c002d738:	01071713          	slli	a4,a4,0x10
c002d73c:	00676333          	or	t1,a4,t1
c002d740:	02f606b3          	mul	a3,a2,a5
c002d744:	00078613          	mv	a2,a5
c002d748:	00d37c63          	bgeu	t1,a3,c002d760 <__udivdi3+0xe8>
c002d74c:	00680333          	add	t1,a6,t1
c002d750:	fff78613          	addi	a2,a5,-1 # ffff <_STACK_SIZE+0xefff>
c002d754:	01036663          	bltu	t1,a6,c002d760 <__udivdi3+0xe8>
c002d758:	00d37463          	bgeu	t1,a3,c002d760 <__udivdi3+0xe8>
c002d75c:	ffe78613          	addi	a2,a5,-2
c002d760:	01051513          	slli	a0,a0,0x10
c002d764:	00c56533          	or	a0,a0,a2
c002d768:	00000593          	li	a1,0
c002d76c:	0e40006f          	j	c002d850 <__udivdi3+0x1d8>
c002d770:	01000537          	lui	a0,0x1000
c002d774:	01000713          	li	a4,16
c002d778:	f2a66ce3          	bltu	a2,a0,c002d6b0 <__udivdi3+0x38>
c002d77c:	01800713          	li	a4,24
c002d780:	f31ff06f          	j	c002d6b0 <__udivdi3+0x38>
c002d784:	00061663          	bnez	a2,c002d790 <__udivdi3+0x118>
c002d788:	00100713          	li	a4,1
c002d78c:	02c75833          	divu	a6,a4,a2
c002d790:	00010737          	lui	a4,0x10
c002d794:	0ce87063          	bgeu	a6,a4,c002d854 <__udivdi3+0x1dc>
c002d798:	0ff00713          	li	a4,255
c002d79c:	01077463          	bgeu	a4,a6,c002d7a4 <__udivdi3+0x12c>
c002d7a0:	00800513          	li	a0,8
c002d7a4:	00a85733          	srl	a4,a6,a0
c002d7a8:	00e686b3          	add	a3,a3,a4
c002d7ac:	0006c703          	lbu	a4,0(a3)
c002d7b0:	02000613          	li	a2,32
c002d7b4:	00a70733          	add	a4,a4,a0
c002d7b8:	40e606b3          	sub	a3,a2,a4
c002d7bc:	0ae61663          	bne	a2,a4,c002d868 <__udivdi3+0x1f0>
c002d7c0:	410787b3          	sub	a5,a5,a6
c002d7c4:	00100593          	li	a1,1
c002d7c8:	01085893          	srli	a7,a6,0x10
c002d7cc:	01081613          	slli	a2,a6,0x10
c002d7d0:	01065613          	srli	a2,a2,0x10
c002d7d4:	01035713          	srli	a4,t1,0x10
c002d7d8:	0317f6b3          	remu	a3,a5,a7
c002d7dc:	0317d7b3          	divu	a5,a5,a7
c002d7e0:	01069693          	slli	a3,a3,0x10
c002d7e4:	00e6e733          	or	a4,a3,a4
c002d7e8:	02f60e33          	mul	t3,a2,a5
c002d7ec:	00078513          	mv	a0,a5
c002d7f0:	01c77e63          	bgeu	a4,t3,c002d80c <__udivdi3+0x194>
c002d7f4:	01070733          	add	a4,a4,a6
c002d7f8:	fff78513          	addi	a0,a5,-1
c002d7fc:	01076863          	bltu	a4,a6,c002d80c <__udivdi3+0x194>
c002d800:	01c77663          	bgeu	a4,t3,c002d80c <__udivdi3+0x194>
c002d804:	ffe78513          	addi	a0,a5,-2
c002d808:	01070733          	add	a4,a4,a6
c002d80c:	41c70733          	sub	a4,a4,t3
c002d810:	031777b3          	remu	a5,a4,a7
c002d814:	01031313          	slli	t1,t1,0x10
c002d818:	01035313          	srli	t1,t1,0x10
c002d81c:	03175733          	divu	a4,a4,a7
c002d820:	01079793          	slli	a5,a5,0x10
c002d824:	0067e333          	or	t1,a5,t1
c002d828:	02e606b3          	mul	a3,a2,a4
c002d82c:	00070613          	mv	a2,a4
c002d830:	00d37c63          	bgeu	t1,a3,c002d848 <__udivdi3+0x1d0>
c002d834:	00680333          	add	t1,a6,t1
c002d838:	fff70613          	addi	a2,a4,-1 # ffff <_STACK_SIZE+0xefff>
c002d83c:	01036663          	bltu	t1,a6,c002d848 <__udivdi3+0x1d0>
c002d840:	00d37463          	bgeu	t1,a3,c002d848 <__udivdi3+0x1d0>
c002d844:	ffe70613          	addi	a2,a4,-2
c002d848:	01051513          	slli	a0,a0,0x10
c002d84c:	00c56533          	or	a0,a0,a2
c002d850:	00008067          	ret
c002d854:	01000737          	lui	a4,0x1000
c002d858:	01000513          	li	a0,16
c002d85c:	f4e864e3          	bltu	a6,a4,c002d7a4 <__udivdi3+0x12c>
c002d860:	01800513          	li	a0,24
c002d864:	f41ff06f          	j	c002d7a4 <__udivdi3+0x12c>
c002d868:	00d81833          	sll	a6,a6,a3
c002d86c:	00e7d533          	srl	a0,a5,a4
c002d870:	00d89333          	sll	t1,a7,a3
c002d874:	00d797b3          	sll	a5,a5,a3
c002d878:	00e8d733          	srl	a4,a7,a4
c002d87c:	01085893          	srli	a7,a6,0x10
c002d880:	00f76633          	or	a2,a4,a5
c002d884:	03157733          	remu	a4,a0,a7
c002d888:	01081793          	slli	a5,a6,0x10
c002d88c:	0107d793          	srli	a5,a5,0x10
c002d890:	01065593          	srli	a1,a2,0x10
c002d894:	03155533          	divu	a0,a0,a7
c002d898:	01071713          	slli	a4,a4,0x10
c002d89c:	00b76733          	or	a4,a4,a1
c002d8a0:	02a786b3          	mul	a3,a5,a0
c002d8a4:	00050593          	mv	a1,a0
c002d8a8:	00d77e63          	bgeu	a4,a3,c002d8c4 <__udivdi3+0x24c>
c002d8ac:	01070733          	add	a4,a4,a6
c002d8b0:	fff50593          	addi	a1,a0,-1 # ffffff <_DMEM_LENGTH+0x7fffff>
c002d8b4:	01076863          	bltu	a4,a6,c002d8c4 <__udivdi3+0x24c>
c002d8b8:	00d77663          	bgeu	a4,a3,c002d8c4 <__udivdi3+0x24c>
c002d8bc:	ffe50593          	addi	a1,a0,-2
c002d8c0:	01070733          	add	a4,a4,a6
c002d8c4:	40d706b3          	sub	a3,a4,a3
c002d8c8:	0316f733          	remu	a4,a3,a7
c002d8cc:	01061613          	slli	a2,a2,0x10
c002d8d0:	01065613          	srli	a2,a2,0x10
c002d8d4:	0316d6b3          	divu	a3,a3,a7
c002d8d8:	01071713          	slli	a4,a4,0x10
c002d8dc:	02d78533          	mul	a0,a5,a3
c002d8e0:	00c767b3          	or	a5,a4,a2
c002d8e4:	00068713          	mv	a4,a3
c002d8e8:	00a7fe63          	bgeu	a5,a0,c002d904 <__udivdi3+0x28c>
c002d8ec:	010787b3          	add	a5,a5,a6
c002d8f0:	fff68713          	addi	a4,a3,-1
c002d8f4:	0107e863          	bltu	a5,a6,c002d904 <__udivdi3+0x28c>
c002d8f8:	00a7f663          	bgeu	a5,a0,c002d904 <__udivdi3+0x28c>
c002d8fc:	ffe68713          	addi	a4,a3,-2
c002d900:	010787b3          	add	a5,a5,a6
c002d904:	01059593          	slli	a1,a1,0x10
c002d908:	40a787b3          	sub	a5,a5,a0
c002d90c:	00e5e5b3          	or	a1,a1,a4
c002d910:	eb9ff06f          	j	c002d7c8 <__udivdi3+0x150>
c002d914:	18d5e663          	bltu	a1,a3,c002daa0 <__udivdi3+0x428>
c002d918:	00010737          	lui	a4,0x10
c002d91c:	04e6f463          	bgeu	a3,a4,c002d964 <__udivdi3+0x2ec>
c002d920:	0ff00713          	li	a4,255
c002d924:	00d735b3          	sltu	a1,a4,a3
c002d928:	00359593          	slli	a1,a1,0x3
c002d92c:	c8002737          	lui	a4,0xc8002
c002d930:	00b6d533          	srl	a0,a3,a1
c002d934:	5d070713          	addi	a4,a4,1488 # c80025d0 <_end+0xfff7dd50>
c002d938:	00a70733          	add	a4,a4,a0
c002d93c:	00074703          	lbu	a4,0(a4)
c002d940:	02000513          	li	a0,32
c002d944:	00b70733          	add	a4,a4,a1
c002d948:	40e505b3          	sub	a1,a0,a4
c002d94c:	02e51663          	bne	a0,a4,c002d978 <__udivdi3+0x300>
c002d950:	00100513          	li	a0,1
c002d954:	eef6eee3          	bltu	a3,a5,c002d850 <__udivdi3+0x1d8>
c002d958:	00c8b533          	sltu	a0,a7,a2
c002d95c:	00154513          	xori	a0,a0,1
c002d960:	ef1ff06f          	j	c002d850 <__udivdi3+0x1d8>
c002d964:	01000737          	lui	a4,0x1000
c002d968:	01000593          	li	a1,16
c002d96c:	fce6e0e3          	bltu	a3,a4,c002d92c <__udivdi3+0x2b4>
c002d970:	01800593          	li	a1,24
c002d974:	fb9ff06f          	j	c002d92c <__udivdi3+0x2b4>
c002d978:	00e65833          	srl	a6,a2,a4
c002d97c:	00b696b3          	sll	a3,a3,a1
c002d980:	00d86833          	or	a6,a6,a3
c002d984:	00e7de33          	srl	t3,a5,a4
c002d988:	01085e93          	srli	t4,a6,0x10
c002d98c:	03de76b3          	remu	a3,t3,t4
c002d990:	00b797b3          	sll	a5,a5,a1
c002d994:	00e8d733          	srl	a4,a7,a4
c002d998:	00b61333          	sll	t1,a2,a1
c002d99c:	00f76633          	or	a2,a4,a5
c002d9a0:	01081793          	slli	a5,a6,0x10
c002d9a4:	0107d793          	srli	a5,a5,0x10
c002d9a8:	01065713          	srli	a4,a2,0x10
c002d9ac:	03de5e33          	divu	t3,t3,t4
c002d9b0:	01069693          	slli	a3,a3,0x10
c002d9b4:	00e6e733          	or	a4,a3,a4
c002d9b8:	03c78f33          	mul	t5,a5,t3
c002d9bc:	000e0513          	mv	a0,t3
c002d9c0:	01e77e63          	bgeu	a4,t5,c002d9dc <__udivdi3+0x364>
c002d9c4:	01070733          	add	a4,a4,a6
c002d9c8:	fffe0513          	addi	a0,t3,-1
c002d9cc:	01076863          	bltu	a4,a6,c002d9dc <__udivdi3+0x364>
c002d9d0:	01e77663          	bgeu	a4,t5,c002d9dc <__udivdi3+0x364>
c002d9d4:	ffee0513          	addi	a0,t3,-2
c002d9d8:	01070733          	add	a4,a4,a6
c002d9dc:	41e70733          	sub	a4,a4,t5
c002d9e0:	03d776b3          	remu	a3,a4,t4
c002d9e4:	03d75733          	divu	a4,a4,t4
c002d9e8:	01069693          	slli	a3,a3,0x10
c002d9ec:	02e78e33          	mul	t3,a5,a4
c002d9f0:	01061793          	slli	a5,a2,0x10
c002d9f4:	0107d793          	srli	a5,a5,0x10
c002d9f8:	00f6e7b3          	or	a5,a3,a5
c002d9fc:	00070613          	mv	a2,a4
c002da00:	01c7fe63          	bgeu	a5,t3,c002da1c <__udivdi3+0x3a4>
c002da04:	010787b3          	add	a5,a5,a6
c002da08:	fff70613          	addi	a2,a4,-1 # ffffff <_DMEM_LENGTH+0x7fffff>
c002da0c:	0107e863          	bltu	a5,a6,c002da1c <__udivdi3+0x3a4>
c002da10:	01c7f663          	bgeu	a5,t3,c002da1c <__udivdi3+0x3a4>
c002da14:	ffe70613          	addi	a2,a4,-2
c002da18:	010787b3          	add	a5,a5,a6
c002da1c:	01051513          	slli	a0,a0,0x10
c002da20:	00010eb7          	lui	t4,0x10
c002da24:	00c56533          	or	a0,a0,a2
c002da28:	fffe8693          	addi	a3,t4,-1 # ffff <_STACK_SIZE+0xefff>
c002da2c:	00d57833          	and	a6,a0,a3
c002da30:	01055613          	srli	a2,a0,0x10
c002da34:	00d376b3          	and	a3,t1,a3
c002da38:	01035313          	srli	t1,t1,0x10
c002da3c:	41c787b3          	sub	a5,a5,t3
c002da40:	02d80e33          	mul	t3,a6,a3
c002da44:	02d606b3          	mul	a3,a2,a3
c002da48:	010e5713          	srli	a4,t3,0x10
c002da4c:	02680833          	mul	a6,a6,t1
c002da50:	00d80833          	add	a6,a6,a3
c002da54:	01070733          	add	a4,a4,a6
c002da58:	02660633          	mul	a2,a2,t1
c002da5c:	00d77463          	bgeu	a4,a3,c002da64 <__udivdi3+0x3ec>
c002da60:	01d60633          	add	a2,a2,t4
c002da64:	01075693          	srli	a3,a4,0x10
c002da68:	00c68633          	add	a2,a3,a2
c002da6c:	02c7e663          	bltu	a5,a2,c002da98 <__udivdi3+0x420>
c002da70:	cec79ce3          	bne	a5,a2,c002d768 <__udivdi3+0xf0>
c002da74:	000107b7          	lui	a5,0x10
c002da78:	fff78793          	addi	a5,a5,-1 # ffff <_STACK_SIZE+0xefff>
c002da7c:	00f77733          	and	a4,a4,a5
c002da80:	01071713          	slli	a4,a4,0x10
c002da84:	00fe7e33          	and	t3,t3,a5
c002da88:	00b898b3          	sll	a7,a7,a1
c002da8c:	01c70733          	add	a4,a4,t3
c002da90:	00000593          	li	a1,0
c002da94:	dae8fee3          	bgeu	a7,a4,c002d850 <__udivdi3+0x1d8>
c002da98:	fff50513          	addi	a0,a0,-1
c002da9c:	ccdff06f          	j	c002d768 <__udivdi3+0xf0>
c002daa0:	00000593          	li	a1,0
c002daa4:	00000513          	li	a0,0
c002daa8:	da9ff06f          	j	c002d850 <__udivdi3+0x1d8>

c002daac <__umoddi3>:
c002daac:	00050e93          	mv	t4,a0
c002dab0:	00058313          	mv	t1,a1
c002dab4:	00060813          	mv	a6,a2
c002dab8:	00068793          	mv	a5,a3
c002dabc:	22069a63          	bnez	a3,c002dcf0 <__umoddi3+0x244>
c002dac0:	c8002737          	lui	a4,0xc8002
c002dac4:	5d070713          	addi	a4,a4,1488 # c80025d0 <_end+0xfff7dd50>
c002dac8:	0cc5fc63          	bgeu	a1,a2,c002dba0 <__umoddi3+0xf4>
c002dacc:	000106b7          	lui	a3,0x10
c002dad0:	0ad67e63          	bgeu	a2,a3,c002db8c <__umoddi3+0xe0>
c002dad4:	0ff00693          	li	a3,255
c002dad8:	00c6f463          	bgeu	a3,a2,c002dae0 <__umoddi3+0x34>
c002dadc:	00800793          	li	a5,8
c002dae0:	00f656b3          	srl	a3,a2,a5
c002dae4:	00d70733          	add	a4,a4,a3
c002dae8:	00074703          	lbu	a4,0(a4)
c002daec:	00f707b3          	add	a5,a4,a5
c002daf0:	02000713          	li	a4,32
c002daf4:	40f708b3          	sub	a7,a4,a5
c002daf8:	00f70c63          	beq	a4,a5,c002db10 <__umoddi3+0x64>
c002dafc:	011315b3          	sll	a1,t1,a7
c002db00:	00fed7b3          	srl	a5,t4,a5
c002db04:	01161833          	sll	a6,a2,a7
c002db08:	00b7e5b3          	or	a1,a5,a1
c002db0c:	011e9533          	sll	a0,t4,a7
c002db10:	01085693          	srli	a3,a6,0x10
c002db14:	02d5f7b3          	remu	a5,a1,a3
c002db18:	01081613          	slli	a2,a6,0x10
c002db1c:	01065613          	srli	a2,a2,0x10
c002db20:	01055713          	srli	a4,a0,0x10
c002db24:	02d5d5b3          	divu	a1,a1,a3
c002db28:	01079793          	slli	a5,a5,0x10
c002db2c:	00e7e733          	or	a4,a5,a4
c002db30:	02b605b3          	mul	a1,a2,a1
c002db34:	00b77a63          	bgeu	a4,a1,c002db48 <__umoddi3+0x9c>
c002db38:	01070733          	add	a4,a4,a6
c002db3c:	01076663          	bltu	a4,a6,c002db48 <__umoddi3+0x9c>
c002db40:	00b77463          	bgeu	a4,a1,c002db48 <__umoddi3+0x9c>
c002db44:	01070733          	add	a4,a4,a6
c002db48:	40b70733          	sub	a4,a4,a1
c002db4c:	02d777b3          	remu	a5,a4,a3
c002db50:	01051513          	slli	a0,a0,0x10
c002db54:	01055513          	srli	a0,a0,0x10
c002db58:	02d75733          	divu	a4,a4,a3
c002db5c:	01079793          	slli	a5,a5,0x10
c002db60:	00a7e533          	or	a0,a5,a0
c002db64:	02e60733          	mul	a4,a2,a4
c002db68:	00e57a63          	bgeu	a0,a4,c002db7c <__umoddi3+0xd0>
c002db6c:	01050533          	add	a0,a0,a6
c002db70:	01056663          	bltu	a0,a6,c002db7c <__umoddi3+0xd0>
c002db74:	00e57463          	bgeu	a0,a4,c002db7c <__umoddi3+0xd0>
c002db78:	01050533          	add	a0,a0,a6
c002db7c:	40e50533          	sub	a0,a0,a4
c002db80:	01155533          	srl	a0,a0,a7
c002db84:	00000593          	li	a1,0
c002db88:	00008067          	ret
c002db8c:	010006b7          	lui	a3,0x1000
c002db90:	01000793          	li	a5,16
c002db94:	f4d666e3          	bltu	a2,a3,c002dae0 <__umoddi3+0x34>
c002db98:	01800793          	li	a5,24
c002db9c:	f45ff06f          	j	c002dae0 <__umoddi3+0x34>
c002dba0:	00061663          	bnez	a2,c002dbac <__umoddi3+0x100>
c002dba4:	00100693          	li	a3,1
c002dba8:	02c6d833          	divu	a6,a3,a2
c002dbac:	000106b7          	lui	a3,0x10
c002dbb0:	12d87663          	bgeu	a6,a3,c002dcdc <__umoddi3+0x230>
c002dbb4:	0ff00693          	li	a3,255
c002dbb8:	0106f463          	bgeu	a3,a6,c002dbc0 <__umoddi3+0x114>
c002dbbc:	00800793          	li	a5,8
c002dbc0:	00f856b3          	srl	a3,a6,a5
c002dbc4:	00d70733          	add	a4,a4,a3
c002dbc8:	00074603          	lbu	a2,0(a4)
c002dbcc:	410305b3          	sub	a1,t1,a6
c002dbd0:	00f60633          	add	a2,a2,a5
c002dbd4:	02000793          	li	a5,32
c002dbd8:	40c788b3          	sub	a7,a5,a2
c002dbdc:	08c78663          	beq	a5,a2,c002dc68 <__umoddi3+0x1bc>
c002dbe0:	01181833          	sll	a6,a6,a7
c002dbe4:	00c357b3          	srl	a5,t1,a2
c002dbe8:	011315b3          	sll	a1,t1,a7
c002dbec:	01085313          	srli	t1,a6,0x10
c002dbf0:	00ced633          	srl	a2,t4,a2
c002dbf4:	00b66633          	or	a2,a2,a1
c002dbf8:	01081593          	slli	a1,a6,0x10
c002dbfc:	0105d593          	srli	a1,a1,0x10
c002dc00:	011e9533          	sll	a0,t4,a7
c002dc04:	0267d6b3          	divu	a3,a5,t1
c002dc08:	0267f733          	remu	a4,a5,t1
c002dc0c:	01065793          	srli	a5,a2,0x10
c002dc10:	02d586b3          	mul	a3,a1,a3
c002dc14:	01071713          	slli	a4,a4,0x10
c002dc18:	00f76733          	or	a4,a4,a5
c002dc1c:	00d77a63          	bgeu	a4,a3,c002dc30 <__umoddi3+0x184>
c002dc20:	01070733          	add	a4,a4,a6
c002dc24:	01076663          	bltu	a4,a6,c002dc30 <__umoddi3+0x184>
c002dc28:	00d77463          	bgeu	a4,a3,c002dc30 <__umoddi3+0x184>
c002dc2c:	01070733          	add	a4,a4,a6
c002dc30:	40d706b3          	sub	a3,a4,a3
c002dc34:	0266f733          	remu	a4,a3,t1
c002dc38:	01061613          	slli	a2,a2,0x10
c002dc3c:	01065613          	srli	a2,a2,0x10
c002dc40:	0266d6b3          	divu	a3,a3,t1
c002dc44:	01071713          	slli	a4,a4,0x10
c002dc48:	02d586b3          	mul	a3,a1,a3
c002dc4c:	00c765b3          	or	a1,a4,a2
c002dc50:	00d5fa63          	bgeu	a1,a3,c002dc64 <__umoddi3+0x1b8>
c002dc54:	010585b3          	add	a1,a1,a6
c002dc58:	0105e663          	bltu	a1,a6,c002dc64 <__umoddi3+0x1b8>
c002dc5c:	00d5f463          	bgeu	a1,a3,c002dc64 <__umoddi3+0x1b8>
c002dc60:	010585b3          	add	a1,a1,a6
c002dc64:	40d585b3          	sub	a1,a1,a3
c002dc68:	01085693          	srli	a3,a6,0x10
c002dc6c:	02d5f733          	remu	a4,a1,a3
c002dc70:	01081793          	slli	a5,a6,0x10
c002dc74:	0107d793          	srli	a5,a5,0x10
c002dc78:	01055613          	srli	a2,a0,0x10
c002dc7c:	02d5d5b3          	divu	a1,a1,a3
c002dc80:	01071713          	slli	a4,a4,0x10
c002dc84:	00c76733          	or	a4,a4,a2
c002dc88:	02b785b3          	mul	a1,a5,a1
c002dc8c:	00b77a63          	bgeu	a4,a1,c002dca0 <__umoddi3+0x1f4>
c002dc90:	01070733          	add	a4,a4,a6
c002dc94:	01076663          	bltu	a4,a6,c002dca0 <__umoddi3+0x1f4>
c002dc98:	00b77463          	bgeu	a4,a1,c002dca0 <__umoddi3+0x1f4>
c002dc9c:	01070733          	add	a4,a4,a6
c002dca0:	40b705b3          	sub	a1,a4,a1
c002dca4:	02d5f733          	remu	a4,a1,a3
c002dca8:	01051513          	slli	a0,a0,0x10
c002dcac:	01055513          	srli	a0,a0,0x10
c002dcb0:	02d5d5b3          	divu	a1,a1,a3
c002dcb4:	02b785b3          	mul	a1,a5,a1
c002dcb8:	01071793          	slli	a5,a4,0x10
c002dcbc:	00a7e533          	or	a0,a5,a0
c002dcc0:	00b57a63          	bgeu	a0,a1,c002dcd4 <__umoddi3+0x228>
c002dcc4:	01050533          	add	a0,a0,a6
c002dcc8:	01056663          	bltu	a0,a6,c002dcd4 <__umoddi3+0x228>
c002dccc:	00b57463          	bgeu	a0,a1,c002dcd4 <__umoddi3+0x228>
c002dcd0:	01050533          	add	a0,a0,a6
c002dcd4:	40b50533          	sub	a0,a0,a1
c002dcd8:	ea9ff06f          	j	c002db80 <__umoddi3+0xd4>
c002dcdc:	010006b7          	lui	a3,0x1000
c002dce0:	01000793          	li	a5,16
c002dce4:	ecd86ee3          	bltu	a6,a3,c002dbc0 <__umoddi3+0x114>
c002dce8:	01800793          	li	a5,24
c002dcec:	ed5ff06f          	j	c002dbc0 <__umoddi3+0x114>
c002dcf0:	e8d5ece3          	bltu	a1,a3,c002db88 <__umoddi3+0xdc>
c002dcf4:	000107b7          	lui	a5,0x10
c002dcf8:	04f6f863          	bgeu	a3,a5,c002dd48 <__umoddi3+0x29c>
c002dcfc:	0ff00893          	li	a7,255
c002dd00:	00d8b7b3          	sltu	a5,a7,a3
c002dd04:	00379793          	slli	a5,a5,0x3
c002dd08:	c8002737          	lui	a4,0xc8002
c002dd0c:	00f6d833          	srl	a6,a3,a5
c002dd10:	5d070713          	addi	a4,a4,1488 # c80025d0 <_end+0xfff7dd50>
c002dd14:	01070733          	add	a4,a4,a6
c002dd18:	00074883          	lbu	a7,0(a4)
c002dd1c:	00f888b3          	add	a7,a7,a5
c002dd20:	02000793          	li	a5,32
c002dd24:	41178833          	sub	a6,a5,a7
c002dd28:	03179a63          	bne	a5,a7,c002dd5c <__umoddi3+0x2b0>
c002dd2c:	0066e463          	bltu	a3,t1,c002dd34 <__umoddi3+0x288>
c002dd30:	e4ceece3          	bltu	t4,a2,c002db88 <__umoddi3+0xdc>
c002dd34:	40ce8533          	sub	a0,t4,a2
c002dd38:	40d305b3          	sub	a1,t1,a3
c002dd3c:	00aebeb3          	sltu	t4,t4,a0
c002dd40:	41d585b3          	sub	a1,a1,t4
c002dd44:	e45ff06f          	j	c002db88 <__umoddi3+0xdc>
c002dd48:	01000737          	lui	a4,0x1000
c002dd4c:	01000793          	li	a5,16
c002dd50:	fae6ece3          	bltu	a3,a4,c002dd08 <__umoddi3+0x25c>
c002dd54:	01800793          	li	a5,24
c002dd58:	fb1ff06f          	j	c002dd08 <__umoddi3+0x25c>
c002dd5c:	011657b3          	srl	a5,a2,a7
c002dd60:	010696b3          	sll	a3,a3,a6
c002dd64:	00d7ee33          	or	t3,a5,a3
c002dd68:	01135f33          	srl	t5,t1,a7
c002dd6c:	011ed7b3          	srl	a5,t4,a7
c002dd70:	010e9533          	sll	a0,t4,a6
c002dd74:	010e5e93          	srli	t4,t3,0x10
c002dd78:	010315b3          	sll	a1,t1,a6
c002dd7c:	03df5333          	divu	t1,t5,t4
c002dd80:	00b7e7b3          	or	a5,a5,a1
c002dd84:	010e1593          	slli	a1,t3,0x10
c002dd88:	0105d593          	srli	a1,a1,0x10
c002dd8c:	0107d713          	srli	a4,a5,0x10
c002dd90:	01061633          	sll	a2,a2,a6
c002dd94:	03df76b3          	remu	a3,t5,t4
c002dd98:	02658f33          	mul	t5,a1,t1
c002dd9c:	01069693          	slli	a3,a3,0x10
c002dda0:	00e6e733          	or	a4,a3,a4
c002dda4:	00030693          	mv	a3,t1
c002dda8:	01e77e63          	bgeu	a4,t5,c002ddc4 <__umoddi3+0x318>
c002ddac:	01c70733          	add	a4,a4,t3
c002ddb0:	fff30693          	addi	a3,t1,-1
c002ddb4:	01c76863          	bltu	a4,t3,c002ddc4 <__umoddi3+0x318>
c002ddb8:	01e77663          	bgeu	a4,t5,c002ddc4 <__umoddi3+0x318>
c002ddbc:	ffe30693          	addi	a3,t1,-2
c002ddc0:	01c70733          	add	a4,a4,t3
c002ddc4:	41e70733          	sub	a4,a4,t5
c002ddc8:	03d77333          	remu	t1,a4,t4
c002ddcc:	01079793          	slli	a5,a5,0x10
c002ddd0:	0107d793          	srli	a5,a5,0x10
c002ddd4:	03d75733          	divu	a4,a4,t4
c002ddd8:	01031313          	slli	t1,t1,0x10
c002dddc:	00f36333          	or	t1,t1,a5
c002dde0:	02e585b3          	mul	a1,a1,a4
c002dde4:	00070793          	mv	a5,a4
c002dde8:	00b37e63          	bgeu	t1,a1,c002de04 <__umoddi3+0x358>
c002ddec:	01c30333          	add	t1,t1,t3
c002ddf0:	fff70793          	addi	a5,a4,-1 # ffffff <_DMEM_LENGTH+0x7fffff>
c002ddf4:	01c36863          	bltu	t1,t3,c002de04 <__umoddi3+0x358>
c002ddf8:	00b37663          	bgeu	t1,a1,c002de04 <__umoddi3+0x358>
c002ddfc:	ffe70793          	addi	a5,a4,-2
c002de00:	01c30333          	add	t1,t1,t3
c002de04:	01069693          	slli	a3,a3,0x10
c002de08:	00010f37          	lui	t5,0x10
c002de0c:	00f6e6b3          	or	a3,a3,a5
c002de10:	40b305b3          	sub	a1,t1,a1
c002de14:	ffff0313          	addi	t1,t5,-1 # ffff <_STACK_SIZE+0xefff>
c002de18:	0066feb3          	and	t4,a3,t1
c002de1c:	01065713          	srli	a4,a2,0x10
c002de20:	0106d693          	srli	a3,a3,0x10
c002de24:	00667333          	and	t1,a2,t1
c002de28:	026e87b3          	mul	a5,t4,t1
c002de2c:	02668333          	mul	t1,a3,t1
c002de30:	02ee8eb3          	mul	t4,t4,a4
c002de34:	02e686b3          	mul	a3,a3,a4
c002de38:	006e8eb3          	add	t4,t4,t1
c002de3c:	0107d713          	srli	a4,a5,0x10
c002de40:	01d70733          	add	a4,a4,t4
c002de44:	00677463          	bgeu	a4,t1,c002de4c <__umoddi3+0x3a0>
c002de48:	01e686b3          	add	a3,a3,t5
c002de4c:	01075313          	srli	t1,a4,0x10
c002de50:	00d306b3          	add	a3,t1,a3
c002de54:	00010337          	lui	t1,0x10
c002de58:	fff30313          	addi	t1,t1,-1 # ffff <_STACK_SIZE+0xefff>
c002de5c:	00677733          	and	a4,a4,t1
c002de60:	01071713          	slli	a4,a4,0x10
c002de64:	0067f7b3          	and	a5,a5,t1
c002de68:	00f707b3          	add	a5,a4,a5
c002de6c:	00d5e663          	bltu	a1,a3,c002de78 <__umoddi3+0x3cc>
c002de70:	00d59e63          	bne	a1,a3,c002de8c <__umoddi3+0x3e0>
c002de74:	00f57c63          	bgeu	a0,a5,c002de8c <__umoddi3+0x3e0>
c002de78:	40c78633          	sub	a2,a5,a2
c002de7c:	00c7b7b3          	sltu	a5,a5,a2
c002de80:	01c787b3          	add	a5,a5,t3
c002de84:	40f686b3          	sub	a3,a3,a5
c002de88:	00060793          	mv	a5,a2
c002de8c:	40f507b3          	sub	a5,a0,a5
c002de90:	00f53533          	sltu	a0,a0,a5
c002de94:	40d585b3          	sub	a1,a1,a3
c002de98:	40a585b3          	sub	a1,a1,a0
c002de9c:	011598b3          	sll	a7,a1,a7
c002dea0:	0107d533          	srl	a0,a5,a6
c002dea4:	00a8e533          	or	a0,a7,a0
c002dea8:	0105d5b3          	srl	a1,a1,a6
c002deac:	cddff06f          	j	c002db88 <__umoddi3+0xdc>

c002deb0 <__divdf3>:
c002deb0:	fd010113          	addi	sp,sp,-48
c002deb4:	03212023          	sw	s2,32(sp)
c002deb8:	0145d913          	srli	s2,a1,0x14
c002debc:	02912223          	sw	s1,36(sp)
c002dec0:	01312e23          	sw	s3,28(sp)
c002dec4:	01412c23          	sw	s4,24(sp)
c002dec8:	01612823          	sw	s6,16(sp)
c002decc:	01812423          	sw	s8,8(sp)
c002ded0:	00c59493          	slli	s1,a1,0xc
c002ded4:	02112623          	sw	ra,44(sp)
c002ded8:	02812423          	sw	s0,40(sp)
c002dedc:	01512a23          	sw	s5,20(sp)
c002dee0:	01712623          	sw	s7,12(sp)
c002dee4:	7ff97913          	andi	s2,s2,2047
c002dee8:	00050a13          	mv	s4,a0
c002deec:	00060b13          	mv	s6,a2
c002def0:	00068c13          	mv	s8,a3
c002def4:	00c4d493          	srli	s1,s1,0xc
c002def8:	01f5d993          	srli	s3,a1,0x1f
c002defc:	0a090063          	beqz	s2,c002df9c <__divdf3+0xec>
c002df00:	7ff00793          	li	a5,2047
c002df04:	0ef90e63          	beq	s2,a5,c002e000 <__divdf3+0x150>
c002df08:	01d55a93          	srli	s5,a0,0x1d
c002df0c:	00349493          	slli	s1,s1,0x3
c002df10:	009ae4b3          	or	s1,s5,s1
c002df14:	00800ab7          	lui	s5,0x800
c002df18:	0154eab3          	or	s5,s1,s5
c002df1c:	00351413          	slli	s0,a0,0x3
c002df20:	c0190913          	addi	s2,s2,-1023
c002df24:	00000b93          	li	s7,0
c002df28:	00cc1513          	slli	a0,s8,0xc
c002df2c:	00c55493          	srli	s1,a0,0xc
c002df30:	014c5513          	srli	a0,s8,0x14
c002df34:	7ff57593          	andi	a1,a0,2047
c002df38:	01fc5c13          	srli	s8,s8,0x1f
c002df3c:	10058063          	beqz	a1,c002e03c <__divdf3+0x18c>
c002df40:	7ff00793          	li	a5,2047
c002df44:	16f58263          	beq	a1,a5,c002e0a8 <__divdf3+0x1f8>
c002df48:	00349513          	slli	a0,s1,0x3
c002df4c:	01db5793          	srli	a5,s6,0x1d
c002df50:	00a7e533          	or	a0,a5,a0
c002df54:	008004b7          	lui	s1,0x800
c002df58:	009564b3          	or	s1,a0,s1
c002df5c:	003b1f93          	slli	t6,s6,0x3
c002df60:	c0158513          	addi	a0,a1,-1023
c002df64:	00000793          	li	a5,0
c002df68:	002b9713          	slli	a4,s7,0x2
c002df6c:	00f76733          	or	a4,a4,a5
c002df70:	fff70713          	addi	a4,a4,-1
c002df74:	00e00613          	li	a2,14
c002df78:	0189c6b3          	xor	a3,s3,s8
c002df7c:	40a905b3          	sub	a1,s2,a0
c002df80:	16e66063          	bltu	a2,a4,c002e0e0 <__divdf3+0x230>
c002df84:	c8002637          	lui	a2,0xc8002
c002df88:	00271713          	slli	a4,a4,0x2
c002df8c:	51c60613          	addi	a2,a2,1308 # c800251c <_end+0xfff7dc9c>
c002df90:	00c70733          	add	a4,a4,a2
c002df94:	00072703          	lw	a4,0(a4)
c002df98:	00070067          	jr	a4
c002df9c:	00a4eab3          	or	s5,s1,a0
c002dfa0:	060a8e63          	beqz	s5,c002e01c <__divdf3+0x16c>
c002dfa4:	04048063          	beqz	s1,c002dfe4 <__divdf3+0x134>
c002dfa8:	00048513          	mv	a0,s1
c002dfac:	e80ff0ef          	jal	ra,c002d62c <__clzsi2>
c002dfb0:	ff550793          	addi	a5,a0,-11
c002dfb4:	01c00713          	li	a4,28
c002dfb8:	02f74c63          	blt	a4,a5,c002dff0 <__divdf3+0x140>
c002dfbc:	01d00a93          	li	s5,29
c002dfc0:	ff850413          	addi	s0,a0,-8
c002dfc4:	40fa8ab3          	sub	s5,s5,a5
c002dfc8:	008494b3          	sll	s1,s1,s0
c002dfcc:	015a5ab3          	srl	s5,s4,s5
c002dfd0:	009aeab3          	or	s5,s5,s1
c002dfd4:	008a1433          	sll	s0,s4,s0
c002dfd8:	c0d00593          	li	a1,-1011
c002dfdc:	40a58933          	sub	s2,a1,a0
c002dfe0:	f45ff06f          	j	c002df24 <__divdf3+0x74>
c002dfe4:	e48ff0ef          	jal	ra,c002d62c <__clzsi2>
c002dfe8:	02050513          	addi	a0,a0,32
c002dfec:	fc5ff06f          	j	c002dfb0 <__divdf3+0x100>
c002dff0:	fd850493          	addi	s1,a0,-40
c002dff4:	009a1ab3          	sll	s5,s4,s1
c002dff8:	00000413          	li	s0,0
c002dffc:	fddff06f          	j	c002dfd8 <__divdf3+0x128>
c002e000:	00a4eab3          	or	s5,s1,a0
c002e004:	020a8463          	beqz	s5,c002e02c <__divdf3+0x17c>
c002e008:	00050413          	mv	s0,a0
c002e00c:	00048a93          	mv	s5,s1
c002e010:	7ff00913          	li	s2,2047
c002e014:	00300b93          	li	s7,3
c002e018:	f11ff06f          	j	c002df28 <__divdf3+0x78>
c002e01c:	00000413          	li	s0,0
c002e020:	00000913          	li	s2,0
c002e024:	00100b93          	li	s7,1
c002e028:	f01ff06f          	j	c002df28 <__divdf3+0x78>
c002e02c:	00000413          	li	s0,0
c002e030:	7ff00913          	li	s2,2047
c002e034:	00200b93          	li	s7,2
c002e038:	ef1ff06f          	j	c002df28 <__divdf3+0x78>
c002e03c:	0164efb3          	or	t6,s1,s6
c002e040:	080f8063          	beqz	t6,c002e0c0 <__divdf3+0x210>
c002e044:	04048263          	beqz	s1,c002e088 <__divdf3+0x1d8>
c002e048:	00048513          	mv	a0,s1
c002e04c:	de0ff0ef          	jal	ra,c002d62c <__clzsi2>
c002e050:	00050593          	mv	a1,a0
c002e054:	ff558793          	addi	a5,a1,-11
c002e058:	01c00713          	li	a4,28
c002e05c:	02f74e63          	blt	a4,a5,c002e098 <__divdf3+0x1e8>
c002e060:	01d00693          	li	a3,29
c002e064:	ff858f93          	addi	t6,a1,-8
c002e068:	40f686b3          	sub	a3,a3,a5
c002e06c:	01f49533          	sll	a0,s1,t6
c002e070:	00db56b3          	srl	a3,s6,a3
c002e074:	00a6e4b3          	or	s1,a3,a0
c002e078:	01fb1fb3          	sll	t6,s6,t6
c002e07c:	c0d00693          	li	a3,-1011
c002e080:	40b68533          	sub	a0,a3,a1
c002e084:	ee1ff06f          	j	c002df64 <__divdf3+0xb4>
c002e088:	000b0513          	mv	a0,s6
c002e08c:	da0ff0ef          	jal	ra,c002d62c <__clzsi2>
c002e090:	02050593          	addi	a1,a0,32
c002e094:	fc1ff06f          	j	c002e054 <__divdf3+0x1a4>
c002e098:	fd858513          	addi	a0,a1,-40
c002e09c:	00ab14b3          	sll	s1,s6,a0
c002e0a0:	00000f93          	li	t6,0
c002e0a4:	fd9ff06f          	j	c002e07c <__divdf3+0x1cc>
c002e0a8:	0164efb3          	or	t6,s1,s6
c002e0ac:	020f8263          	beqz	t6,c002e0d0 <__divdf3+0x220>
c002e0b0:	000b0f93          	mv	t6,s6
c002e0b4:	7ff00513          	li	a0,2047
c002e0b8:	00300793          	li	a5,3
c002e0bc:	eadff06f          	j	c002df68 <__divdf3+0xb8>
c002e0c0:	00000493          	li	s1,0
c002e0c4:	00000513          	li	a0,0
c002e0c8:	00100793          	li	a5,1
c002e0cc:	e9dff06f          	j	c002df68 <__divdf3+0xb8>
c002e0d0:	00000493          	li	s1,0
c002e0d4:	7ff00513          	li	a0,2047
c002e0d8:	00200793          	li	a5,2
c002e0dc:	e8dff06f          	j	c002df68 <__divdf3+0xb8>
c002e0e0:	0154e663          	bltu	s1,s5,c002e0ec <__divdf3+0x23c>
c002e0e4:	349a9e63          	bne	s5,s1,c002e440 <__divdf3+0x590>
c002e0e8:	35f46c63          	bltu	s0,t6,c002e440 <__divdf3+0x590>
c002e0ec:	01fa9613          	slli	a2,s5,0x1f
c002e0f0:	00145713          	srli	a4,s0,0x1
c002e0f4:	01f41793          	slli	a5,s0,0x1f
c002e0f8:	001ada93          	srli	s5,s5,0x1
c002e0fc:	00e66433          	or	s0,a2,a4
c002e100:	00849513          	slli	a0,s1,0x8
c002e104:	018fd893          	srli	a7,t6,0x18
c002e108:	00a8e8b3          	or	a7,a7,a0
c002e10c:	01055513          	srli	a0,a0,0x10
c002e110:	02aade33          	divu	t3,s5,a0
c002e114:	01089e93          	slli	t4,a7,0x10
c002e118:	010ede93          	srli	t4,t4,0x10
c002e11c:	01045713          	srli	a4,s0,0x10
c002e120:	008f9313          	slli	t1,t6,0x8
c002e124:	02aafab3          	remu	s5,s5,a0
c002e128:	000e0613          	mv	a2,t3
c002e12c:	03ce8833          	mul	a6,t4,t3
c002e130:	010a9a93          	slli	s5,s5,0x10
c002e134:	01576733          	or	a4,a4,s5
c002e138:	01077e63          	bgeu	a4,a6,c002e154 <__divdf3+0x2a4>
c002e13c:	01170733          	add	a4,a4,a7
c002e140:	fffe0613          	addi	a2,t3,-1
c002e144:	01176863          	bltu	a4,a7,c002e154 <__divdf3+0x2a4>
c002e148:	01077663          	bgeu	a4,a6,c002e154 <__divdf3+0x2a4>
c002e14c:	ffee0613          	addi	a2,t3,-2
c002e150:	01170733          	add	a4,a4,a7
c002e154:	41070733          	sub	a4,a4,a6
c002e158:	02a75e33          	divu	t3,a4,a0
c002e15c:	01041413          	slli	s0,s0,0x10
c002e160:	01045413          	srli	s0,s0,0x10
c002e164:	02a77733          	remu	a4,a4,a0
c002e168:	000e0293          	mv	t0,t3
c002e16c:	03ce8833          	mul	a6,t4,t3
c002e170:	01071713          	slli	a4,a4,0x10
c002e174:	00e46733          	or	a4,s0,a4
c002e178:	01077e63          	bgeu	a4,a6,c002e194 <__divdf3+0x2e4>
c002e17c:	01170733          	add	a4,a4,a7
c002e180:	fffe0293          	addi	t0,t3,-1
c002e184:	01176863          	bltu	a4,a7,c002e194 <__divdf3+0x2e4>
c002e188:	01077663          	bgeu	a4,a6,c002e194 <__divdf3+0x2e4>
c002e18c:	ffee0293          	addi	t0,t3,-2
c002e190:	01170733          	add	a4,a4,a7
c002e194:	41070433          	sub	s0,a4,a6
c002e198:	01061613          	slli	a2,a2,0x10
c002e19c:	00010837          	lui	a6,0x10
c002e1a0:	005662b3          	or	t0,a2,t0
c002e1a4:	fff80e13          	addi	t3,a6,-1 # ffff <_STACK_SIZE+0xefff>
c002e1a8:	0102d613          	srli	a2,t0,0x10
c002e1ac:	01c2f733          	and	a4,t0,t3
c002e1b0:	01035f13          	srli	t5,t1,0x10
c002e1b4:	01c37e33          	and	t3,t1,t3
c002e1b8:	02ee03b3          	mul	t2,t3,a4
c002e1bc:	03c604b3          	mul	s1,a2,t3
c002e1c0:	02ef0733          	mul	a4,t5,a4
c002e1c4:	03e60fb3          	mul	t6,a2,t5
c002e1c8:	00970633          	add	a2,a4,s1
c002e1cc:	0103d713          	srli	a4,t2,0x10
c002e1d0:	00c70733          	add	a4,a4,a2
c002e1d4:	00977463          	bgeu	a4,s1,c002e1dc <__divdf3+0x32c>
c002e1d8:	010f8fb3          	add	t6,t6,a6
c002e1dc:	01075613          	srli	a2,a4,0x10
c002e1e0:	01f60633          	add	a2,a2,t6
c002e1e4:	00010fb7          	lui	t6,0x10
c002e1e8:	ffff8f93          	addi	t6,t6,-1 # ffff <_STACK_SIZE+0xefff>
c002e1ec:	01f77833          	and	a6,a4,t6
c002e1f0:	01081813          	slli	a6,a6,0x10
c002e1f4:	01f3f3b3          	and	t2,t2,t6
c002e1f8:	00780833          	add	a6,a6,t2
c002e1fc:	00c46863          	bltu	s0,a2,c002e20c <__divdf3+0x35c>
c002e200:	00028493          	mv	s1,t0
c002e204:	04c41463          	bne	s0,a2,c002e24c <__divdf3+0x39c>
c002e208:	0507f263          	bgeu	a5,a6,c002e24c <__divdf3+0x39c>
c002e20c:	006787b3          	add	a5,a5,t1
c002e210:	0067b733          	sltu	a4,a5,t1
c002e214:	01170733          	add	a4,a4,a7
c002e218:	00e40433          	add	s0,s0,a4
c002e21c:	fff28493          	addi	s1,t0,-1
c002e220:	0088e663          	bltu	a7,s0,c002e22c <__divdf3+0x37c>
c002e224:	02889463          	bne	a7,s0,c002e24c <__divdf3+0x39c>
c002e228:	0267e263          	bltu	a5,t1,c002e24c <__divdf3+0x39c>
c002e22c:	00c46663          	bltu	s0,a2,c002e238 <__divdf3+0x388>
c002e230:	00861e63          	bne	a2,s0,c002e24c <__divdf3+0x39c>
c002e234:	0107fc63          	bgeu	a5,a6,c002e24c <__divdf3+0x39c>
c002e238:	006787b3          	add	a5,a5,t1
c002e23c:	0067b733          	sltu	a4,a5,t1
c002e240:	01170733          	add	a4,a4,a7
c002e244:	ffe28493          	addi	s1,t0,-2
c002e248:	00e40433          	add	s0,s0,a4
c002e24c:	41078833          	sub	a6,a5,a6
c002e250:	40c40433          	sub	s0,s0,a2
c002e254:	0107b7b3          	sltu	a5,a5,a6
c002e258:	40f40433          	sub	s0,s0,a5
c002e25c:	fff00f93          	li	t6,-1
c002e260:	12888463          	beq	a7,s0,c002e388 <__divdf3+0x4d8>
c002e264:	02a45fb3          	divu	t6,s0,a0
c002e268:	01085713          	srli	a4,a6,0x10
c002e26c:	02a47433          	remu	s0,s0,a0
c002e270:	000f8613          	mv	a2,t6
c002e274:	03fe87b3          	mul	a5,t4,t6
c002e278:	01041413          	slli	s0,s0,0x10
c002e27c:	00876433          	or	s0,a4,s0
c002e280:	00f47e63          	bgeu	s0,a5,c002e29c <__divdf3+0x3ec>
c002e284:	01140433          	add	s0,s0,a7
c002e288:	ffff8613          	addi	a2,t6,-1
c002e28c:	01146863          	bltu	s0,a7,c002e29c <__divdf3+0x3ec>
c002e290:	00f47663          	bgeu	s0,a5,c002e29c <__divdf3+0x3ec>
c002e294:	ffef8613          	addi	a2,t6,-2
c002e298:	01140433          	add	s0,s0,a7
c002e29c:	40f40433          	sub	s0,s0,a5
c002e2a0:	02a45733          	divu	a4,s0,a0
c002e2a4:	01081813          	slli	a6,a6,0x10
c002e2a8:	01085813          	srli	a6,a6,0x10
c002e2ac:	02a47433          	remu	s0,s0,a0
c002e2b0:	00070793          	mv	a5,a4
c002e2b4:	02ee8eb3          	mul	t4,t4,a4
c002e2b8:	01041413          	slli	s0,s0,0x10
c002e2bc:	00886433          	or	s0,a6,s0
c002e2c0:	01d47e63          	bgeu	s0,t4,c002e2dc <__divdf3+0x42c>
c002e2c4:	01140433          	add	s0,s0,a7
c002e2c8:	fff70793          	addi	a5,a4,-1
c002e2cc:	01146863          	bltu	s0,a7,c002e2dc <__divdf3+0x42c>
c002e2d0:	01d47663          	bgeu	s0,t4,c002e2dc <__divdf3+0x42c>
c002e2d4:	ffe70793          	addi	a5,a4,-2
c002e2d8:	01140433          	add	s0,s0,a7
c002e2dc:	01061613          	slli	a2,a2,0x10
c002e2e0:	00f66633          	or	a2,a2,a5
c002e2e4:	01061793          	slli	a5,a2,0x10
c002e2e8:	0107d793          	srli	a5,a5,0x10
c002e2ec:	01065713          	srli	a4,a2,0x10
c002e2f0:	02ef0833          	mul	a6,t5,a4
c002e2f4:	41d40433          	sub	s0,s0,t4
c002e2f8:	02ff0f33          	mul	t5,t5,a5
c002e2fc:	03c78eb3          	mul	t4,a5,t3
c002e300:	03c70e33          	mul	t3,a4,t3
c002e304:	010ed793          	srli	a5,t4,0x10
c002e308:	01cf0f33          	add	t5,t5,t3
c002e30c:	01e787b3          	add	a5,a5,t5
c002e310:	01c7f663          	bgeu	a5,t3,c002e31c <__divdf3+0x46c>
c002e314:	00010737          	lui	a4,0x10
c002e318:	00e80833          	add	a6,a6,a4
c002e31c:	0107d713          	srli	a4,a5,0x10
c002e320:	01070733          	add	a4,a4,a6
c002e324:	00010837          	lui	a6,0x10
c002e328:	fff80813          	addi	a6,a6,-1 # ffff <_STACK_SIZE+0xefff>
c002e32c:	0107f533          	and	a0,a5,a6
c002e330:	01051513          	slli	a0,a0,0x10
c002e334:	010efeb3          	and	t4,t4,a6
c002e338:	01d50533          	add	a0,a0,t4
c002e33c:	00e46863          	bltu	s0,a4,c002e34c <__divdf3+0x49c>
c002e340:	24e41463          	bne	s0,a4,c002e588 <__divdf3+0x6d8>
c002e344:	00060f93          	mv	t6,a2
c002e348:	04050063          	beqz	a0,c002e388 <__divdf3+0x4d8>
c002e34c:	00888433          	add	s0,a7,s0
c002e350:	fff60f93          	addi	t6,a2,-1
c002e354:	03146463          	bltu	s0,a7,c002e37c <__divdf3+0x4cc>
c002e358:	00e46663          	bltu	s0,a4,c002e364 <__divdf3+0x4b4>
c002e35c:	22e41463          	bne	s0,a4,c002e584 <__divdf3+0x6d4>
c002e360:	02a37063          	bgeu	t1,a0,c002e380 <__divdf3+0x4d0>
c002e364:	00131793          	slli	a5,t1,0x1
c002e368:	0067b333          	sltu	t1,a5,t1
c002e36c:	011308b3          	add	a7,t1,a7
c002e370:	ffe60f93          	addi	t6,a2,-2
c002e374:	01140433          	add	s0,s0,a7
c002e378:	00078313          	mv	t1,a5
c002e37c:	00e41463          	bne	s0,a4,c002e384 <__divdf3+0x4d4>
c002e380:	00650463          	beq	a0,t1,c002e388 <__divdf3+0x4d8>
c002e384:	001fef93          	ori	t6,t6,1
c002e388:	3ff58793          	addi	a5,a1,1023
c002e38c:	10f05a63          	blez	a5,c002e4a0 <__divdf3+0x5f0>
c002e390:	007ff713          	andi	a4,t6,7
c002e394:	02070063          	beqz	a4,c002e3b4 <__divdf3+0x504>
c002e398:	00fff713          	andi	a4,t6,15
c002e39c:	00400613          	li	a2,4
c002e3a0:	00c70a63          	beq	a4,a2,c002e3b4 <__divdf3+0x504>
c002e3a4:	004f8613          	addi	a2,t6,4
c002e3a8:	01f63fb3          	sltu	t6,a2,t6
c002e3ac:	01f484b3          	add	s1,s1,t6
c002e3b0:	00060f93          	mv	t6,a2
c002e3b4:	01000737          	lui	a4,0x1000
c002e3b8:	00e4f733          	and	a4,s1,a4
c002e3bc:	00070a63          	beqz	a4,c002e3d0 <__divdf3+0x520>
c002e3c0:	ff0007b7          	lui	a5,0xff000
c002e3c4:	fff78793          	addi	a5,a5,-1 # feffffff <_end+0x36f7b77f>
c002e3c8:	00f4f4b3          	and	s1,s1,a5
c002e3cc:	40058793          	addi	a5,a1,1024
c002e3d0:	7fe00713          	li	a4,2046
c002e3d4:	0af74063          	blt	a4,a5,c002e474 <__divdf3+0x5c4>
c002e3d8:	003fdf93          	srli	t6,t6,0x3
c002e3dc:	01d49713          	slli	a4,s1,0x1d
c002e3e0:	01f76733          	or	a4,a4,t6
c002e3e4:	0034d513          	srli	a0,s1,0x3
c002e3e8:	01479793          	slli	a5,a5,0x14
c002e3ec:	7ff00637          	lui	a2,0x7ff00
c002e3f0:	00c51513          	slli	a0,a0,0xc
c002e3f4:	02c12083          	lw	ra,44(sp)
c002e3f8:	02812403          	lw	s0,40(sp)
c002e3fc:	00c7f7b3          	and	a5,a5,a2
c002e400:	00c55513          	srli	a0,a0,0xc
c002e404:	00a7e533          	or	a0,a5,a0
c002e408:	01f69693          	slli	a3,a3,0x1f
c002e40c:	00d567b3          	or	a5,a0,a3
c002e410:	02412483          	lw	s1,36(sp)
c002e414:	02012903          	lw	s2,32(sp)
c002e418:	01c12983          	lw	s3,28(sp)
c002e41c:	01812a03          	lw	s4,24(sp)
c002e420:	01412a83          	lw	s5,20(sp)
c002e424:	01012b03          	lw	s6,16(sp)
c002e428:	00c12b83          	lw	s7,12(sp)
c002e42c:	00812c03          	lw	s8,8(sp)
c002e430:	00070513          	mv	a0,a4
c002e434:	00078593          	mv	a1,a5
c002e438:	03010113          	addi	sp,sp,48
c002e43c:	00008067          	ret
c002e440:	fff58593          	addi	a1,a1,-1
c002e444:	00000793          	li	a5,0
c002e448:	cb9ff06f          	j	c002e100 <__divdf3+0x250>
c002e44c:	00098693          	mv	a3,s3
c002e450:	000a8493          	mv	s1,s5
c002e454:	00040f93          	mv	t6,s0
c002e458:	000b8793          	mv	a5,s7
c002e45c:	00300713          	li	a4,3
c002e460:	0ee78a63          	beq	a5,a4,c002e554 <__divdf3+0x6a4>
c002e464:	00100713          	li	a4,1
c002e468:	10e78063          	beq	a5,a4,c002e568 <__divdf3+0x6b8>
c002e46c:	00200713          	li	a4,2
c002e470:	f0e79ce3          	bne	a5,a4,c002e388 <__divdf3+0x4d8>
c002e474:	00000513          	li	a0,0
c002e478:	00000713          	li	a4,0
c002e47c:	7ff00793          	li	a5,2047
c002e480:	f69ff06f          	j	c002e3e8 <__divdf3+0x538>
c002e484:	000c0693          	mv	a3,s8
c002e488:	fd5ff06f          	j	c002e45c <__divdf3+0x5ac>
c002e48c:	000804b7          	lui	s1,0x80
c002e490:	00000f93          	li	t6,0
c002e494:	00000693          	li	a3,0
c002e498:	00300793          	li	a5,3
c002e49c:	fc1ff06f          	j	c002e45c <__divdf3+0x5ac>
c002e4a0:	00100513          	li	a0,1
c002e4a4:	40f50533          	sub	a0,a0,a5
c002e4a8:	03800713          	li	a4,56
c002e4ac:	0aa74e63          	blt	a4,a0,c002e568 <__divdf3+0x6b8>
c002e4b0:	01f00713          	li	a4,31
c002e4b4:	06a74663          	blt	a4,a0,c002e520 <__divdf3+0x670>
c002e4b8:	41e58593          	addi	a1,a1,1054
c002e4bc:	00b497b3          	sll	a5,s1,a1
c002e4c0:	00afd733          	srl	a4,t6,a0
c002e4c4:	00bf95b3          	sll	a1,t6,a1
c002e4c8:	00e7e7b3          	or	a5,a5,a4
c002e4cc:	00b035b3          	snez	a1,a1
c002e4d0:	00b7e7b3          	or	a5,a5,a1
c002e4d4:	00a4d533          	srl	a0,s1,a0
c002e4d8:	0077f713          	andi	a4,a5,7
c002e4dc:	02070063          	beqz	a4,c002e4fc <__divdf3+0x64c>
c002e4e0:	00f7f713          	andi	a4,a5,15
c002e4e4:	00400613          	li	a2,4
c002e4e8:	00c70a63          	beq	a4,a2,c002e4fc <__divdf3+0x64c>
c002e4ec:	00478713          	addi	a4,a5,4
c002e4f0:	00f737b3          	sltu	a5,a4,a5
c002e4f4:	00f50533          	add	a0,a0,a5
c002e4f8:	00070793          	mv	a5,a4
c002e4fc:	00800737          	lui	a4,0x800
c002e500:	00e57733          	and	a4,a0,a4
c002e504:	06071863          	bnez	a4,c002e574 <__divdf3+0x6c4>
c002e508:	01d51713          	slli	a4,a0,0x1d
c002e50c:	0037d793          	srli	a5,a5,0x3
c002e510:	00f76733          	or	a4,a4,a5
c002e514:	00355513          	srli	a0,a0,0x3
c002e518:	00000793          	li	a5,0
c002e51c:	ecdff06f          	j	c002e3e8 <__divdf3+0x538>
c002e520:	fe100713          	li	a4,-31
c002e524:	40f707b3          	sub	a5,a4,a5
c002e528:	02000613          	li	a2,32
c002e52c:	00f4d7b3          	srl	a5,s1,a5
c002e530:	00000713          	li	a4,0
c002e534:	00c50663          	beq	a0,a2,c002e540 <__divdf3+0x690>
c002e538:	43e58713          	addi	a4,a1,1086
c002e53c:	00e49733          	sll	a4,s1,a4
c002e540:	01f76733          	or	a4,a4,t6
c002e544:	00e03733          	snez	a4,a4
c002e548:	00e7e7b3          	or	a5,a5,a4
c002e54c:	00000513          	li	a0,0
c002e550:	f89ff06f          	j	c002e4d8 <__divdf3+0x628>
c002e554:	00080537          	lui	a0,0x80
c002e558:	00000713          	li	a4,0
c002e55c:	7ff00793          	li	a5,2047
c002e560:	00000693          	li	a3,0
c002e564:	e85ff06f          	j	c002e3e8 <__divdf3+0x538>
c002e568:	00000513          	li	a0,0
c002e56c:	00000713          	li	a4,0
c002e570:	fa9ff06f          	j	c002e518 <__divdf3+0x668>
c002e574:	00000513          	li	a0,0
c002e578:	00000713          	li	a4,0
c002e57c:	00100793          	li	a5,1
c002e580:	e69ff06f          	j	c002e3e8 <__divdf3+0x538>
c002e584:	000f8613          	mv	a2,t6
c002e588:	00060f93          	mv	t6,a2
c002e58c:	df9ff06f          	j	c002e384 <__divdf3+0x4d4>

c002e590 <__muldf3>:
c002e590:	fd010113          	addi	sp,sp,-48
c002e594:	01312e23          	sw	s3,28(sp)
c002e598:	0145d993          	srli	s3,a1,0x14
c002e59c:	02812423          	sw	s0,40(sp)
c002e5a0:	02912223          	sw	s1,36(sp)
c002e5a4:	01412c23          	sw	s4,24(sp)
c002e5a8:	01512a23          	sw	s5,20(sp)
c002e5ac:	01712623          	sw	s7,12(sp)
c002e5b0:	00c59493          	slli	s1,a1,0xc
c002e5b4:	02112623          	sw	ra,44(sp)
c002e5b8:	03212023          	sw	s2,32(sp)
c002e5bc:	01612823          	sw	s6,16(sp)
c002e5c0:	7ff9f993          	andi	s3,s3,2047
c002e5c4:	00050413          	mv	s0,a0
c002e5c8:	00060b93          	mv	s7,a2
c002e5cc:	00068a93          	mv	s5,a3
c002e5d0:	00c4d493          	srli	s1,s1,0xc
c002e5d4:	01f5da13          	srli	s4,a1,0x1f
c002e5d8:	0a098263          	beqz	s3,c002e67c <__muldf3+0xec>
c002e5dc:	7ff00793          	li	a5,2047
c002e5e0:	10f98063          	beq	s3,a5,c002e6e0 <__muldf3+0x150>
c002e5e4:	01d55793          	srli	a5,a0,0x1d
c002e5e8:	00349493          	slli	s1,s1,0x3
c002e5ec:	0097e4b3          	or	s1,a5,s1
c002e5f0:	008007b7          	lui	a5,0x800
c002e5f4:	00f4e4b3          	or	s1,s1,a5
c002e5f8:	00351913          	slli	s2,a0,0x3
c002e5fc:	c0198993          	addi	s3,s3,-1023
c002e600:	00000b13          	li	s6,0
c002e604:	014ad513          	srli	a0,s5,0x14
c002e608:	00ca9413          	slli	s0,s5,0xc
c002e60c:	7ff57513          	andi	a0,a0,2047
c002e610:	00c45413          	srli	s0,s0,0xc
c002e614:	01fada93          	srli	s5,s5,0x1f
c002e618:	10050063          	beqz	a0,c002e718 <__muldf3+0x188>
c002e61c:	7ff00793          	li	a5,2047
c002e620:	16f50063          	beq	a0,a5,c002e780 <__muldf3+0x1f0>
c002e624:	01dbd793          	srli	a5,s7,0x1d
c002e628:	00341413          	slli	s0,s0,0x3
c002e62c:	0087e433          	or	s0,a5,s0
c002e630:	008007b7          	lui	a5,0x800
c002e634:	00f46433          	or	s0,s0,a5
c002e638:	c0150513          	addi	a0,a0,-1023 # 7fc01 <_HEAP_SIZE+0x3fc01>
c002e63c:	003b9793          	slli	a5,s7,0x3
c002e640:	00000713          	li	a4,0
c002e644:	002b1693          	slli	a3,s6,0x2
c002e648:	00e6e6b3          	or	a3,a3,a4
c002e64c:	00a98533          	add	a0,s3,a0
c002e650:	fff68693          	addi	a3,a3,-1 # ffffff <_DMEM_LENGTH+0x7fffff>
c002e654:	00e00813          	li	a6,14
c002e658:	015a4633          	xor	a2,s4,s5
c002e65c:	00150593          	addi	a1,a0,1
c002e660:	14d86c63          	bltu	a6,a3,c002e7b8 <__muldf3+0x228>
c002e664:	c8002537          	lui	a0,0xc8002
c002e668:	00269693          	slli	a3,a3,0x2
c002e66c:	55850513          	addi	a0,a0,1368 # c8002558 <_end+0xfff7dcd8>
c002e670:	00a686b3          	add	a3,a3,a0
c002e674:	0006a683          	lw	a3,0(a3)
c002e678:	00068067          	jr	a3
c002e67c:	00a4e933          	or	s2,s1,a0
c002e680:	06090c63          	beqz	s2,c002e6f8 <__muldf3+0x168>
c002e684:	04048063          	beqz	s1,c002e6c4 <__muldf3+0x134>
c002e688:	00048513          	mv	a0,s1
c002e68c:	fa1fe0ef          	jal	ra,c002d62c <__clzsi2>
c002e690:	ff550713          	addi	a4,a0,-11
c002e694:	01c00793          	li	a5,28
c002e698:	02e7cc63          	blt	a5,a4,c002e6d0 <__muldf3+0x140>
c002e69c:	01d00793          	li	a5,29
c002e6a0:	ff850913          	addi	s2,a0,-8
c002e6a4:	40e787b3          	sub	a5,a5,a4
c002e6a8:	012494b3          	sll	s1,s1,s2
c002e6ac:	00f457b3          	srl	a5,s0,a5
c002e6b0:	0097e4b3          	or	s1,a5,s1
c002e6b4:	01241933          	sll	s2,s0,s2
c002e6b8:	c0d00993          	li	s3,-1011
c002e6bc:	40a989b3          	sub	s3,s3,a0
c002e6c0:	f41ff06f          	j	c002e600 <__muldf3+0x70>
c002e6c4:	f69fe0ef          	jal	ra,c002d62c <__clzsi2>
c002e6c8:	02050513          	addi	a0,a0,32
c002e6cc:	fc5ff06f          	j	c002e690 <__muldf3+0x100>
c002e6d0:	fd850493          	addi	s1,a0,-40
c002e6d4:	009414b3          	sll	s1,s0,s1
c002e6d8:	00000913          	li	s2,0
c002e6dc:	fddff06f          	j	c002e6b8 <__muldf3+0x128>
c002e6e0:	00a4e933          	or	s2,s1,a0
c002e6e4:	02090263          	beqz	s2,c002e708 <__muldf3+0x178>
c002e6e8:	00050913          	mv	s2,a0
c002e6ec:	7ff00993          	li	s3,2047
c002e6f0:	00300b13          	li	s6,3
c002e6f4:	f11ff06f          	j	c002e604 <__muldf3+0x74>
c002e6f8:	00000493          	li	s1,0
c002e6fc:	00000993          	li	s3,0
c002e700:	00100b13          	li	s6,1
c002e704:	f01ff06f          	j	c002e604 <__muldf3+0x74>
c002e708:	00000493          	li	s1,0
c002e70c:	7ff00993          	li	s3,2047
c002e710:	00200b13          	li	s6,2
c002e714:	ef1ff06f          	j	c002e604 <__muldf3+0x74>
c002e718:	017467b3          	or	a5,s0,s7
c002e71c:	06078e63          	beqz	a5,c002e798 <__muldf3+0x208>
c002e720:	04040063          	beqz	s0,c002e760 <__muldf3+0x1d0>
c002e724:	00040513          	mv	a0,s0
c002e728:	f05fe0ef          	jal	ra,c002d62c <__clzsi2>
c002e72c:	ff550693          	addi	a3,a0,-11
c002e730:	01c00793          	li	a5,28
c002e734:	02d7ce63          	blt	a5,a3,c002e770 <__muldf3+0x1e0>
c002e738:	01d00713          	li	a4,29
c002e73c:	ff850793          	addi	a5,a0,-8
c002e740:	40d70733          	sub	a4,a4,a3
c002e744:	00f41433          	sll	s0,s0,a5
c002e748:	00ebd733          	srl	a4,s7,a4
c002e74c:	00876433          	or	s0,a4,s0
c002e750:	00fb97b3          	sll	a5,s7,a5
c002e754:	c0d00713          	li	a4,-1011
c002e758:	40a70533          	sub	a0,a4,a0
c002e75c:	ee5ff06f          	j	c002e640 <__muldf3+0xb0>
c002e760:	000b8513          	mv	a0,s7
c002e764:	ec9fe0ef          	jal	ra,c002d62c <__clzsi2>
c002e768:	02050513          	addi	a0,a0,32
c002e76c:	fc1ff06f          	j	c002e72c <__muldf3+0x19c>
c002e770:	fd850413          	addi	s0,a0,-40
c002e774:	008b9433          	sll	s0,s7,s0
c002e778:	00000793          	li	a5,0
c002e77c:	fd9ff06f          	j	c002e754 <__muldf3+0x1c4>
c002e780:	017467b3          	or	a5,s0,s7
c002e784:	02078263          	beqz	a5,c002e7a8 <__muldf3+0x218>
c002e788:	000b8793          	mv	a5,s7
c002e78c:	7ff00513          	li	a0,2047
c002e790:	00300713          	li	a4,3
c002e794:	eb1ff06f          	j	c002e644 <__muldf3+0xb4>
c002e798:	00000413          	li	s0,0
c002e79c:	00000513          	li	a0,0
c002e7a0:	00100713          	li	a4,1
c002e7a4:	ea1ff06f          	j	c002e644 <__muldf3+0xb4>
c002e7a8:	00000413          	li	s0,0
c002e7ac:	7ff00513          	li	a0,2047
c002e7b0:	00200713          	li	a4,2
c002e7b4:	e91ff06f          	j	c002e644 <__muldf3+0xb4>
c002e7b8:	00010f37          	lui	t5,0x10
c002e7bc:	ffff0e93          	addi	t4,t5,-1 # ffff <_STACK_SIZE+0xefff>
c002e7c0:	01095713          	srli	a4,s2,0x10
c002e7c4:	0107d893          	srli	a7,a5,0x10
c002e7c8:	01d97933          	and	s2,s2,t4
c002e7cc:	01d7f7b3          	and	a5,a5,t4
c002e7d0:	03288833          	mul	a6,a7,s2
c002e7d4:	02f906b3          	mul	a3,s2,a5
c002e7d8:	02f70fb3          	mul	t6,a4,a5
c002e7dc:	01f80333          	add	t1,a6,t6
c002e7e0:	0106d813          	srli	a6,a3,0x10
c002e7e4:	00680833          	add	a6,a6,t1
c002e7e8:	03170e33          	mul	t3,a4,a7
c002e7ec:	01f87463          	bgeu	a6,t6,c002e7f4 <__muldf3+0x264>
c002e7f0:	01ee0e33          	add	t3,t3,t5
c002e7f4:	01085393          	srli	t2,a6,0x10
c002e7f8:	01d87833          	and	a6,a6,t4
c002e7fc:	01d6f6b3          	and	a3,a3,t4
c002e800:	01045f13          	srli	t5,s0,0x10
c002e804:	01d472b3          	and	t0,s0,t4
c002e808:	01081813          	slli	a6,a6,0x10
c002e80c:	00d80833          	add	a6,a6,a3
c002e810:	02570eb3          	mul	t4,a4,t0
c002e814:	025906b3          	mul	a3,s2,t0
c002e818:	032f0933          	mul	s2,t5,s2
c002e81c:	01d90333          	add	t1,s2,t4
c002e820:	0106d913          	srli	s2,a3,0x10
c002e824:	00690933          	add	s2,s2,t1
c002e828:	03e70733          	mul	a4,a4,t5
c002e82c:	01d97663          	bgeu	s2,t4,c002e838 <__muldf3+0x2a8>
c002e830:	00010337          	lui	t1,0x10
c002e834:	00670733          	add	a4,a4,t1
c002e838:	01095e93          	srli	t4,s2,0x10
c002e83c:	000109b7          	lui	s3,0x10
c002e840:	00ee8eb3          	add	t4,t4,a4
c002e844:	fff98713          	addi	a4,s3,-1 # ffff <_STACK_SIZE+0xefff>
c002e848:	00e97933          	and	s2,s2,a4
c002e84c:	00e6f6b3          	and	a3,a3,a4
c002e850:	0104d413          	srli	s0,s1,0x10
c002e854:	01091913          	slli	s2,s2,0x10
c002e858:	00e4f4b3          	and	s1,s1,a4
c002e85c:	02978733          	mul	a4,a5,s1
c002e860:	00d90933          	add	s2,s2,a3
c002e864:	012383b3          	add	t2,t2,s2
c002e868:	02f40333          	mul	t1,s0,a5
c002e86c:	029886b3          	mul	a3,a7,s1
c002e870:	028887b3          	mul	a5,a7,s0
c002e874:	006688b3          	add	a7,a3,t1
c002e878:	01075693          	srli	a3,a4,0x10
c002e87c:	011686b3          	add	a3,a3,a7
c002e880:	0066f463          	bgeu	a3,t1,c002e888 <__muldf3+0x2f8>
c002e884:	013787b3          	add	a5,a5,s3
c002e888:	0106d893          	srli	a7,a3,0x10
c002e88c:	000109b7          	lui	s3,0x10
c002e890:	00f88fb3          	add	t6,a7,a5
c002e894:	fff98793          	addi	a5,s3,-1 # ffff <_STACK_SIZE+0xefff>
c002e898:	029288b3          	mul	a7,t0,s1
c002e89c:	00f6f6b3          	and	a3,a3,a5
c002e8a0:	00f77733          	and	a4,a4,a5
c002e8a4:	01069693          	slli	a3,a3,0x10
c002e8a8:	00e686b3          	add	a3,a3,a4
c002e8ac:	025407b3          	mul	a5,s0,t0
c002e8b0:	029f04b3          	mul	s1,t5,s1
c002e8b4:	028f0333          	mul	t1,t5,s0
c002e8b8:	00f484b3          	add	s1,s1,a5
c002e8bc:	0108d413          	srli	s0,a7,0x10
c002e8c0:	009404b3          	add	s1,s0,s1
c002e8c4:	00f4f463          	bgeu	s1,a5,c002e8cc <__muldf3+0x33c>
c002e8c8:	01330333          	add	t1,t1,s3
c002e8cc:	000107b7          	lui	a5,0x10
c002e8d0:	fff78793          	addi	a5,a5,-1 # ffff <_STACK_SIZE+0xefff>
c002e8d4:	00f4f733          	and	a4,s1,a5
c002e8d8:	00f8f8b3          	and	a7,a7,a5
c002e8dc:	01071713          	slli	a4,a4,0x10
c002e8e0:	007e0e33          	add	t3,t3,t2
c002e8e4:	01170733          	add	a4,a4,a7
c002e8e8:	012e3933          	sltu	s2,t3,s2
c002e8ec:	01d70733          	add	a4,a4,t4
c002e8f0:	01270433          	add	s0,a4,s2
c002e8f4:	00de0e33          	add	t3,t3,a3
c002e8f8:	00de36b3          	sltu	a3,t3,a3
c002e8fc:	01f408b3          	add	a7,s0,t6
c002e900:	00d88f33          	add	t5,a7,a3
c002e904:	01d73733          	sltu	a4,a4,t4
c002e908:	01243433          	sltu	s0,s0,s2
c002e90c:	00876433          	or	s0,a4,s0
c002e910:	0104d493          	srli	s1,s1,0x10
c002e914:	01f8b8b3          	sltu	a7,a7,t6
c002e918:	00df36b3          	sltu	a3,t5,a3
c002e91c:	00940433          	add	s0,s0,s1
c002e920:	00d8e6b3          	or	a3,a7,a3
c002e924:	00d40433          	add	s0,s0,a3
c002e928:	00640433          	add	s0,s0,t1
c002e92c:	017f5793          	srli	a5,t5,0x17
c002e930:	00941413          	slli	s0,s0,0x9
c002e934:	00f46433          	or	s0,s0,a5
c002e938:	009e1793          	slli	a5,t3,0x9
c002e93c:	0107e7b3          	or	a5,a5,a6
c002e940:	00f037b3          	snez	a5,a5
c002e944:	017e5e13          	srli	t3,t3,0x17
c002e948:	009f1713          	slli	a4,t5,0x9
c002e94c:	01c7e7b3          	or	a5,a5,t3
c002e950:	00e7e7b3          	or	a5,a5,a4
c002e954:	01000737          	lui	a4,0x1000
c002e958:	00e47733          	and	a4,s0,a4
c002e95c:	10070663          	beqz	a4,c002ea68 <__muldf3+0x4d8>
c002e960:	0017d713          	srli	a4,a5,0x1
c002e964:	0017f793          	andi	a5,a5,1
c002e968:	00f767b3          	or	a5,a4,a5
c002e96c:	01f41713          	slli	a4,s0,0x1f
c002e970:	00e7e7b3          	or	a5,a5,a4
c002e974:	00145413          	srli	s0,s0,0x1
c002e978:	3ff58693          	addi	a3,a1,1023
c002e97c:	0ed05a63          	blez	a3,c002ea70 <__muldf3+0x4e0>
c002e980:	0077f713          	andi	a4,a5,7
c002e984:	02070063          	beqz	a4,c002e9a4 <__muldf3+0x414>
c002e988:	00f7f713          	andi	a4,a5,15
c002e98c:	00400513          	li	a0,4
c002e990:	00a70a63          	beq	a4,a0,c002e9a4 <__muldf3+0x414>
c002e994:	00478713          	addi	a4,a5,4
c002e998:	00f737b3          	sltu	a5,a4,a5
c002e99c:	00f40433          	add	s0,s0,a5
c002e9a0:	00070793          	mv	a5,a4
c002e9a4:	01000737          	lui	a4,0x1000
c002e9a8:	00e47733          	and	a4,s0,a4
c002e9ac:	00070a63          	beqz	a4,c002e9c0 <__muldf3+0x430>
c002e9b0:	ff000737          	lui	a4,0xff000
c002e9b4:	fff70713          	addi	a4,a4,-1 # feffffff <_end+0x36f7b77f>
c002e9b8:	00e47433          	and	s0,s0,a4
c002e9bc:	40058693          	addi	a3,a1,1024
c002e9c0:	7fe00713          	li	a4,2046
c002e9c4:	16d74a63          	blt	a4,a3,c002eb38 <__muldf3+0x5a8>
c002e9c8:	0037d713          	srli	a4,a5,0x3
c002e9cc:	01d41793          	slli	a5,s0,0x1d
c002e9d0:	00e7e7b3          	or	a5,a5,a4
c002e9d4:	00345413          	srli	s0,s0,0x3
c002e9d8:	01469713          	slli	a4,a3,0x14
c002e9dc:	00c41413          	slli	s0,s0,0xc
c002e9e0:	7ff006b7          	lui	a3,0x7ff00
c002e9e4:	00d77733          	and	a4,a4,a3
c002e9e8:	00c45413          	srli	s0,s0,0xc
c002e9ec:	00876433          	or	s0,a4,s0
c002e9f0:	01f61613          	slli	a2,a2,0x1f
c002e9f4:	02c12083          	lw	ra,44(sp)
c002e9f8:	00c46733          	or	a4,s0,a2
c002e9fc:	02812403          	lw	s0,40(sp)
c002ea00:	02412483          	lw	s1,36(sp)
c002ea04:	02012903          	lw	s2,32(sp)
c002ea08:	01c12983          	lw	s3,28(sp)
c002ea0c:	01812a03          	lw	s4,24(sp)
c002ea10:	01412a83          	lw	s5,20(sp)
c002ea14:	01012b03          	lw	s6,16(sp)
c002ea18:	00c12b83          	lw	s7,12(sp)
c002ea1c:	00078513          	mv	a0,a5
c002ea20:	00070593          	mv	a1,a4
c002ea24:	03010113          	addi	sp,sp,48
c002ea28:	00008067          	ret
c002ea2c:	000a0613          	mv	a2,s4
c002ea30:	00048413          	mv	s0,s1
c002ea34:	00090793          	mv	a5,s2
c002ea38:	000b0713          	mv	a4,s6
c002ea3c:	00200693          	li	a3,2
c002ea40:	0ed70c63          	beq	a4,a3,c002eb38 <__muldf3+0x5a8>
c002ea44:	00300693          	li	a3,3
c002ea48:	0cd70e63          	beq	a4,a3,c002eb24 <__muldf3+0x594>
c002ea4c:	00100693          	li	a3,1
c002ea50:	f2d714e3          	bne	a4,a3,c002e978 <__muldf3+0x3e8>
c002ea54:	00000413          	li	s0,0
c002ea58:	00000793          	li	a5,0
c002ea5c:	08c0006f          	j	c002eae8 <__muldf3+0x558>
c002ea60:	000a8613          	mv	a2,s5
c002ea64:	fd9ff06f          	j	c002ea3c <__muldf3+0x4ac>
c002ea68:	00050593          	mv	a1,a0
c002ea6c:	f0dff06f          	j	c002e978 <__muldf3+0x3e8>
c002ea70:	00100513          	li	a0,1
c002ea74:	40d50533          	sub	a0,a0,a3
c002ea78:	03800713          	li	a4,56
c002ea7c:	fca74ce3          	blt	a4,a0,c002ea54 <__muldf3+0x4c4>
c002ea80:	01f00713          	li	a4,31
c002ea84:	06a74663          	blt	a4,a0,c002eaf0 <__muldf3+0x560>
c002ea88:	41e58593          	addi	a1,a1,1054
c002ea8c:	00b41733          	sll	a4,s0,a1
c002ea90:	00a7d6b3          	srl	a3,a5,a0
c002ea94:	00b797b3          	sll	a5,a5,a1
c002ea98:	00d76733          	or	a4,a4,a3
c002ea9c:	00f037b3          	snez	a5,a5
c002eaa0:	00f767b3          	or	a5,a4,a5
c002eaa4:	00a45433          	srl	s0,s0,a0
c002eaa8:	0077f713          	andi	a4,a5,7
c002eaac:	02070063          	beqz	a4,c002eacc <__muldf3+0x53c>
c002eab0:	00f7f713          	andi	a4,a5,15
c002eab4:	00400693          	li	a3,4
c002eab8:	00d70a63          	beq	a4,a3,c002eacc <__muldf3+0x53c>
c002eabc:	00478713          	addi	a4,a5,4
c002eac0:	00f737b3          	sltu	a5,a4,a5
c002eac4:	00f40433          	add	s0,s0,a5
c002eac8:	00070793          	mv	a5,a4
c002eacc:	00800737          	lui	a4,0x800
c002ead0:	00e47733          	and	a4,s0,a4
c002ead4:	06071a63          	bnez	a4,c002eb48 <__muldf3+0x5b8>
c002ead8:	01d41713          	slli	a4,s0,0x1d
c002eadc:	0037d793          	srli	a5,a5,0x3
c002eae0:	00f767b3          	or	a5,a4,a5
c002eae4:	00345413          	srli	s0,s0,0x3
c002eae8:	00000693          	li	a3,0
c002eaec:	eedff06f          	j	c002e9d8 <__muldf3+0x448>
c002eaf0:	fe100713          	li	a4,-31
c002eaf4:	40d70733          	sub	a4,a4,a3
c002eaf8:	02000813          	li	a6,32
c002eafc:	00e45733          	srl	a4,s0,a4
c002eb00:	00000693          	li	a3,0
c002eb04:	01050663          	beq	a0,a6,c002eb10 <__muldf3+0x580>
c002eb08:	43e58593          	addi	a1,a1,1086
c002eb0c:	00b416b3          	sll	a3,s0,a1
c002eb10:	00f6e7b3          	or	a5,a3,a5
c002eb14:	00f037b3          	snez	a5,a5
c002eb18:	00f767b3          	or	a5,a4,a5
c002eb1c:	00000413          	li	s0,0
c002eb20:	f89ff06f          	j	c002eaa8 <__muldf3+0x518>
c002eb24:	00080437          	lui	s0,0x80
c002eb28:	00000793          	li	a5,0
c002eb2c:	7ff00693          	li	a3,2047
c002eb30:	00000613          	li	a2,0
c002eb34:	ea5ff06f          	j	c002e9d8 <__muldf3+0x448>
c002eb38:	00000413          	li	s0,0
c002eb3c:	00000793          	li	a5,0
c002eb40:	7ff00693          	li	a3,2047
c002eb44:	e95ff06f          	j	c002e9d8 <__muldf3+0x448>
c002eb48:	00000413          	li	s0,0
c002eb4c:	00000793          	li	a5,0
c002eb50:	00100693          	li	a3,1
c002eb54:	e85ff06f          	j	c002e9d8 <__muldf3+0x448>

c002eb58 <__eqtf2>:
c002eb58:	00c52783          	lw	a5,12(a0)
c002eb5c:	0005af03          	lw	t5,0(a1)
c002eb60:	0045af83          	lw	t6,4(a1)
c002eb64:	0085a283          	lw	t0,8(a1)
c002eb68:	00c5a583          	lw	a1,12(a1)
c002eb6c:	00008737          	lui	a4,0x8
c002eb70:	0107d693          	srli	a3,a5,0x10
c002eb74:	fff70713          	addi	a4,a4,-1 # 7fff <_STACK_SIZE+0x6fff>
c002eb78:	01079813          	slli	a6,a5,0x10
c002eb7c:	01059e93          	slli	t4,a1,0x10
c002eb80:	01f7d613          	srli	a2,a5,0x1f
c002eb84:	00e6f6b3          	and	a3,a3,a4
c002eb88:	0105d793          	srli	a5,a1,0x10
c002eb8c:	00052883          	lw	a7,0(a0)
c002eb90:	00452303          	lw	t1,4(a0)
c002eb94:	00852e03          	lw	t3,8(a0)
c002eb98:	ff010113          	addi	sp,sp,-16
c002eb9c:	01085813          	srli	a6,a6,0x10
c002eba0:	010ede93          	srli	t4,t4,0x10
c002eba4:	00e7f7b3          	and	a5,a5,a4
c002eba8:	01f5d593          	srli	a1,a1,0x1f
c002ebac:	02e69063          	bne	a3,a4,c002ebcc <__eqtf2+0x74>
c002ebb0:	0068e733          	or	a4,a7,t1
c002ebb4:	01c76733          	or	a4,a4,t3
c002ebb8:	01076733          	or	a4,a4,a6
c002ebbc:	00100513          	li	a0,1
c002ebc0:	04071a63          	bnez	a4,c002ec14 <__eqtf2+0xbc>
c002ebc4:	04d79863          	bne	a5,a3,c002ec14 <__eqtf2+0xbc>
c002ebc8:	0080006f          	j	c002ebd0 <__eqtf2+0x78>
c002ebcc:	00e79c63          	bne	a5,a4,c002ebe4 <__eqtf2+0x8c>
c002ebd0:	01ff6733          	or	a4,t5,t6
c002ebd4:	00576733          	or	a4,a4,t0
c002ebd8:	01d76733          	or	a4,a4,t4
c002ebdc:	00100513          	li	a0,1
c002ebe0:	02071a63          	bnez	a4,c002ec14 <__eqtf2+0xbc>
c002ebe4:	00100513          	li	a0,1
c002ebe8:	02d79663          	bne	a5,a3,c002ec14 <__eqtf2+0xbc>
c002ebec:	03e89463          	bne	a7,t5,c002ec14 <__eqtf2+0xbc>
c002ebf0:	03f31263          	bne	t1,t6,c002ec14 <__eqtf2+0xbc>
c002ebf4:	025e1063          	bne	t3,t0,c002ec14 <__eqtf2+0xbc>
c002ebf8:	01d81e63          	bne	a6,t4,c002ec14 <__eqtf2+0xbc>
c002ebfc:	02b60063          	beq	a2,a1,c002ec1c <__eqtf2+0xc4>
c002ec00:	00079a63          	bnez	a5,c002ec14 <__eqtf2+0xbc>
c002ec04:	0068e533          	or	a0,a7,t1
c002ec08:	01c56533          	or	a0,a0,t3
c002ec0c:	01056533          	or	a0,a0,a6
c002ec10:	00a03533          	snez	a0,a0
c002ec14:	01010113          	addi	sp,sp,16
c002ec18:	00008067          	ret
c002ec1c:	00000513          	li	a0,0
c002ec20:	ff5ff06f          	j	c002ec14 <__eqtf2+0xbc>

c002ec24 <__getf2>:
c002ec24:	00052f83          	lw	t6,0(a0)
c002ec28:	00452803          	lw	a6,4(a0)
c002ec2c:	00852e03          	lw	t3,8(a0)
c002ec30:	00c52503          	lw	a0,12(a0)
c002ec34:	00c5a683          	lw	a3,12(a1)
c002ec38:	000087b7          	lui	a5,0x8
c002ec3c:	01055613          	srli	a2,a0,0x10
c002ec40:	fff78793          	addi	a5,a5,-1 # 7fff <_STACK_SIZE+0x6fff>
c002ec44:	01069313          	slli	t1,a3,0x10
c002ec48:	0106d713          	srli	a4,a3,0x10
c002ec4c:	0005a283          	lw	t0,0(a1)
c002ec50:	0045a883          	lw	a7,4(a1)
c002ec54:	0085ae83          	lw	t4,8(a1)
c002ec58:	00f67633          	and	a2,a2,a5
c002ec5c:	01051593          	slli	a1,a0,0x10
c002ec60:	ff010113          	addi	sp,sp,-16
c002ec64:	0105d593          	srli	a1,a1,0x10
c002ec68:	01f55513          	srli	a0,a0,0x1f
c002ec6c:	01035313          	srli	t1,t1,0x10
c002ec70:	00f77733          	and	a4,a4,a5
c002ec74:	01f6d693          	srli	a3,a3,0x1f
c002ec78:	00f61e63          	bne	a2,a5,c002ec94 <__getf2+0x70>
c002ec7c:	01f867b3          	or	a5,a6,t6
c002ec80:	01c7e7b3          	or	a5,a5,t3
c002ec84:	00b7e7b3          	or	a5,a5,a1
c002ec88:	0c078863          	beqz	a5,c002ed58 <__getf2+0x134>
c002ec8c:	ffe00513          	li	a0,-2
c002ec90:	0640006f          	j	c002ecf4 <__getf2+0xd0>
c002ec94:	00f71a63          	bne	a4,a5,c002eca8 <__getf2+0x84>
c002ec98:	0112e7b3          	or	a5,t0,a7
c002ec9c:	01d7e7b3          	or	a5,a5,t4
c002eca0:	0067e7b3          	or	a5,a5,t1
c002eca4:	fe0794e3          	bnez	a5,c002ec8c <__getf2+0x68>
c002eca8:	0a061a63          	bnez	a2,c002ed5c <__getf2+0x138>
c002ecac:	01f867b3          	or	a5,a6,t6
c002ecb0:	01c7e7b3          	or	a5,a5,t3
c002ecb4:	00b7e7b3          	or	a5,a5,a1
c002ecb8:	0017b793          	seqz	a5,a5
c002ecbc:	00071a63          	bnez	a4,c002ecd0 <__getf2+0xac>
c002ecc0:	0112ef33          	or	t5,t0,a7
c002ecc4:	01df6f33          	or	t5,t5,t4
c002ecc8:	006f6f33          	or	t5,t5,t1
c002eccc:	060f0a63          	beqz	t5,c002ed40 <__getf2+0x11c>
c002ecd0:	00079c63          	bnez	a5,c002ece8 <__getf2+0xc4>
c002ecd4:	00a69463          	bne	a3,a0,c002ecdc <__getf2+0xb8>
c002ecd8:	02c75263          	bge	a4,a2,c002ecfc <__getf2+0xd8>
c002ecdc:	04050e63          	beqz	a0,c002ed38 <__getf2+0x114>
c002ece0:	fff00513          	li	a0,-1
c002ece4:	0100006f          	j	c002ecf4 <__getf2+0xd0>
c002ece8:	fff00513          	li	a0,-1
c002ecec:	00068463          	beqz	a3,c002ecf4 <__getf2+0xd0>
c002ecf0:	00068513          	mv	a0,a3
c002ecf4:	01010113          	addi	sp,sp,16
c002ecf8:	00008067          	ret
c002ecfc:	00e65663          	bge	a2,a4,c002ed08 <__getf2+0xe4>
c002ed00:	fe051ae3          	bnez	a0,c002ecf4 <__getf2+0xd0>
c002ed04:	fddff06f          	j	c002ece0 <__getf2+0xbc>
c002ed08:	fcb36ae3          	bltu	t1,a1,c002ecdc <__getf2+0xb8>
c002ed0c:	02659e63          	bne	a1,t1,c002ed48 <__getf2+0x124>
c002ed10:	fdcee6e3          	bltu	t4,t3,c002ecdc <__getf2+0xb8>
c002ed14:	03de1e63          	bne	t3,t4,c002ed50 <__getf2+0x12c>
c002ed18:	fd08e2e3          	bltu	a7,a6,c002ecdc <__getf2+0xb8>
c002ed1c:	01181463          	bne	a6,a7,c002ed24 <__getf2+0x100>
c002ed20:	fbf2eee3          	bltu	t0,t6,c002ecdc <__getf2+0xb8>
c002ed24:	fd186ee3          	bltu	a6,a7,c002ed00 <__getf2+0xdc>
c002ed28:	01181463          	bne	a6,a7,c002ed30 <__getf2+0x10c>
c002ed2c:	fc5feae3          	bltu	t6,t0,c002ed00 <__getf2+0xdc>
c002ed30:	00000513          	li	a0,0
c002ed34:	fc1ff06f          	j	c002ecf4 <__getf2+0xd0>
c002ed38:	00100513          	li	a0,1
c002ed3c:	fb9ff06f          	j	c002ecf4 <__getf2+0xd0>
c002ed40:	fe0798e3          	bnez	a5,c002ed30 <__getf2+0x10c>
c002ed44:	f99ff06f          	j	c002ecdc <__getf2+0xb8>
c002ed48:	fa65ece3          	bltu	a1,t1,c002ed00 <__getf2+0xdc>
c002ed4c:	fe5ff06f          	j	c002ed30 <__getf2+0x10c>
c002ed50:	fbde68e3          	bltu	t3,t4,c002ed00 <__getf2+0xdc>
c002ed54:	fddff06f          	j	c002ed30 <__getf2+0x10c>
c002ed58:	f4c700e3          	beq	a4,a2,c002ec98 <__getf2+0x74>
c002ed5c:	f6071ce3          	bnez	a4,c002ecd4 <__getf2+0xb0>
c002ed60:	00000793          	li	a5,0
c002ed64:	f5dff06f          	j	c002ecc0 <__getf2+0x9c>

c002ed68 <__letf2>:
c002ed68:	00052f83          	lw	t6,0(a0)
c002ed6c:	00452803          	lw	a6,4(a0)
c002ed70:	00852e03          	lw	t3,8(a0)
c002ed74:	00c52503          	lw	a0,12(a0)
c002ed78:	00c5a683          	lw	a3,12(a1)
c002ed7c:	000087b7          	lui	a5,0x8
c002ed80:	01055613          	srli	a2,a0,0x10
c002ed84:	fff78793          	addi	a5,a5,-1 # 7fff <_STACK_SIZE+0x6fff>
c002ed88:	01069313          	slli	t1,a3,0x10
c002ed8c:	0106d713          	srli	a4,a3,0x10
c002ed90:	0005a283          	lw	t0,0(a1)
c002ed94:	0045a883          	lw	a7,4(a1)
c002ed98:	0085ae83          	lw	t4,8(a1)
c002ed9c:	00f67633          	and	a2,a2,a5
c002eda0:	01051593          	slli	a1,a0,0x10
c002eda4:	ff010113          	addi	sp,sp,-16
c002eda8:	0105d593          	srli	a1,a1,0x10
c002edac:	01f55513          	srli	a0,a0,0x1f
c002edb0:	01035313          	srli	t1,t1,0x10
c002edb4:	00f77733          	and	a4,a4,a5
c002edb8:	01f6d693          	srli	a3,a3,0x1f
c002edbc:	00f61e63          	bne	a2,a5,c002edd8 <__letf2+0x70>
c002edc0:	01f867b3          	or	a5,a6,t6
c002edc4:	01c7e7b3          	or	a5,a5,t3
c002edc8:	00b7e7b3          	or	a5,a5,a1
c002edcc:	0c078863          	beqz	a5,c002ee9c <__letf2+0x134>
c002edd0:	00200513          	li	a0,2
c002edd4:	0640006f          	j	c002ee38 <__letf2+0xd0>
c002edd8:	00f71a63          	bne	a4,a5,c002edec <__letf2+0x84>
c002eddc:	0112e7b3          	or	a5,t0,a7
c002ede0:	01d7e7b3          	or	a5,a5,t4
c002ede4:	0067e7b3          	or	a5,a5,t1
c002ede8:	fe0794e3          	bnez	a5,c002edd0 <__letf2+0x68>
c002edec:	0a061a63          	bnez	a2,c002eea0 <__letf2+0x138>
c002edf0:	01f867b3          	or	a5,a6,t6
c002edf4:	01c7e7b3          	or	a5,a5,t3
c002edf8:	00b7e7b3          	or	a5,a5,a1
c002edfc:	0017b793          	seqz	a5,a5
c002ee00:	00071a63          	bnez	a4,c002ee14 <__letf2+0xac>
c002ee04:	0112ef33          	or	t5,t0,a7
c002ee08:	01df6f33          	or	t5,t5,t4
c002ee0c:	006f6f33          	or	t5,t5,t1
c002ee10:	060f0a63          	beqz	t5,c002ee84 <__letf2+0x11c>
c002ee14:	00079c63          	bnez	a5,c002ee2c <__letf2+0xc4>
c002ee18:	00a69463          	bne	a3,a0,c002ee20 <__letf2+0xb8>
c002ee1c:	02c75263          	bge	a4,a2,c002ee40 <__letf2+0xd8>
c002ee20:	04050e63          	beqz	a0,c002ee7c <__letf2+0x114>
c002ee24:	fff00513          	li	a0,-1
c002ee28:	0100006f          	j	c002ee38 <__letf2+0xd0>
c002ee2c:	fff00513          	li	a0,-1
c002ee30:	00068463          	beqz	a3,c002ee38 <__letf2+0xd0>
c002ee34:	00068513          	mv	a0,a3
c002ee38:	01010113          	addi	sp,sp,16
c002ee3c:	00008067          	ret
c002ee40:	00e65663          	bge	a2,a4,c002ee4c <__letf2+0xe4>
c002ee44:	fe051ae3          	bnez	a0,c002ee38 <__letf2+0xd0>
c002ee48:	fddff06f          	j	c002ee24 <__letf2+0xbc>
c002ee4c:	fcb36ae3          	bltu	t1,a1,c002ee20 <__letf2+0xb8>
c002ee50:	02659e63          	bne	a1,t1,c002ee8c <__letf2+0x124>
c002ee54:	fdcee6e3          	bltu	t4,t3,c002ee20 <__letf2+0xb8>
c002ee58:	03de1e63          	bne	t3,t4,c002ee94 <__letf2+0x12c>
c002ee5c:	fd08e2e3          	bltu	a7,a6,c002ee20 <__letf2+0xb8>
c002ee60:	01181463          	bne	a6,a7,c002ee68 <__letf2+0x100>
c002ee64:	fbf2eee3          	bltu	t0,t6,c002ee20 <__letf2+0xb8>
c002ee68:	fd186ee3          	bltu	a6,a7,c002ee44 <__letf2+0xdc>
c002ee6c:	01181463          	bne	a6,a7,c002ee74 <__letf2+0x10c>
c002ee70:	fc5feae3          	bltu	t6,t0,c002ee44 <__letf2+0xdc>
c002ee74:	00000513          	li	a0,0
c002ee78:	fc1ff06f          	j	c002ee38 <__letf2+0xd0>
c002ee7c:	00100513          	li	a0,1
c002ee80:	fb9ff06f          	j	c002ee38 <__letf2+0xd0>
c002ee84:	fe0798e3          	bnez	a5,c002ee74 <__letf2+0x10c>
c002ee88:	f99ff06f          	j	c002ee20 <__letf2+0xb8>
c002ee8c:	fa65ece3          	bltu	a1,t1,c002ee44 <__letf2+0xdc>
c002ee90:	fe5ff06f          	j	c002ee74 <__letf2+0x10c>
c002ee94:	fbde68e3          	bltu	t3,t4,c002ee44 <__letf2+0xdc>
c002ee98:	fddff06f          	j	c002ee74 <__letf2+0x10c>
c002ee9c:	f4c700e3          	beq	a4,a2,c002eddc <__letf2+0x74>
c002eea0:	f6071ce3          	bnez	a4,c002ee18 <__letf2+0xb0>
c002eea4:	00000793          	li	a5,0
c002eea8:	f5dff06f          	j	c002ee04 <__letf2+0x9c>

c002eeac <__multf3>:
c002eeac:	f4010113          	addi	sp,sp,-192
c002eeb0:	0b212823          	sw	s2,176(sp)
c002eeb4:	00c5a903          	lw	s2,12(a1)
c002eeb8:	0005a783          	lw	a5,0(a1)
c002eebc:	0045a683          	lw	a3,4(a1)
c002eec0:	00a12623          	sw	a0,12(sp)
c002eec4:	0085a503          	lw	a0,8(a1)
c002eec8:	01091713          	slli	a4,s2,0x10
c002eecc:	0b312623          	sw	s3,172(sp)
c002eed0:	0b412423          	sw	s4,168(sp)
c002eed4:	00c62983          	lw	s3,12(a2) # 7ff0000c <_DMEM_LENGTH+0x7f70000c>
c002eed8:	00062a03          	lw	s4,0(a2)
c002eedc:	0b512223          	sw	s5,164(sp)
c002eee0:	0b612023          	sw	s6,160(sp)
c002eee4:	00862a83          	lw	s5,8(a2)
c002eee8:	00462b03          	lw	s6,4(a2)
c002eeec:	00008637          	lui	a2,0x8
c002eef0:	0a812c23          	sw	s0,184(sp)
c002eef4:	01075713          	srli	a4,a4,0x10
c002eef8:	01095413          	srli	s0,s2,0x10
c002eefc:	fff60613          	addi	a2,a2,-1 # 7fff <_STACK_SIZE+0x6fff>
c002ef00:	07212623          	sw	s2,108(sp)
c002ef04:	0a112e23          	sw	ra,188(sp)
c002ef08:	0a912a23          	sw	s1,180(sp)
c002ef0c:	09712e23          	sw	s7,156(sp)
c002ef10:	09812c23          	sw	s8,152(sp)
c002ef14:	09912a23          	sw	s9,148(sp)
c002ef18:	09a12823          	sw	s10,144(sp)
c002ef1c:	09b12623          	sw	s11,140(sp)
c002ef20:	06f12023          	sw	a5,96(sp)
c002ef24:	06d12223          	sw	a3,100(sp)
c002ef28:	06a12423          	sw	a0,104(sp)
c002ef2c:	02f12823          	sw	a5,48(sp)
c002ef30:	02d12a23          	sw	a3,52(sp)
c002ef34:	02a12c23          	sw	a0,56(sp)
c002ef38:	02e12e23          	sw	a4,60(sp)
c002ef3c:	00c47433          	and	s0,s0,a2
c002ef40:	01f95913          	srli	s2,s2,0x1f
c002ef44:	12040863          	beqz	s0,c002f074 <__multf3+0x1c8>
c002ef48:	24c40263          	beq	s0,a2,c002f18c <__multf3+0x2e0>
c002ef4c:	000107b7          	lui	a5,0x10
c002ef50:	00f767b3          	or	a5,a4,a5
c002ef54:	02f12e23          	sw	a5,60(sp)
c002ef58:	03010613          	addi	a2,sp,48
c002ef5c:	03c10793          	addi	a5,sp,60
c002ef60:	0007a703          	lw	a4,0(a5) # 10000 <_STACK_SIZE+0xf000>
c002ef64:	ffc7a683          	lw	a3,-4(a5)
c002ef68:	ffc78793          	addi	a5,a5,-4
c002ef6c:	00371713          	slli	a4,a4,0x3
c002ef70:	01d6d693          	srli	a3,a3,0x1d
c002ef74:	00d76733          	or	a4,a4,a3
c002ef78:	00e7a223          	sw	a4,4(a5)
c002ef7c:	fef612e3          	bne	a2,a5,c002ef60 <__multf3+0xb4>
c002ef80:	03012783          	lw	a5,48(sp)
c002ef84:	ffffc537          	lui	a0,0xffffc
c002ef88:	00150513          	addi	a0,a0,1 # ffffc001 <_end+0x37f77781>
c002ef8c:	00379793          	slli	a5,a5,0x3
c002ef90:	02f12823          	sw	a5,48(sp)
c002ef94:	00a40433          	add	s0,s0,a0
c002ef98:	00000b93          	li	s7,0
c002ef9c:	01099513          	slli	a0,s3,0x10
c002efa0:	00008737          	lui	a4,0x8
c002efa4:	0109d793          	srli	a5,s3,0x10
c002efa8:	01055513          	srli	a0,a0,0x10
c002efac:	fff70713          	addi	a4,a4,-1 # 7fff <_STACK_SIZE+0x6fff>
c002efb0:	07312623          	sw	s3,108(sp)
c002efb4:	07412023          	sw	s4,96(sp)
c002efb8:	07612223          	sw	s6,100(sp)
c002efbc:	07512423          	sw	s5,104(sp)
c002efc0:	05412023          	sw	s4,64(sp)
c002efc4:	05612223          	sw	s6,68(sp)
c002efc8:	05512423          	sw	s5,72(sp)
c002efcc:	04a12623          	sw	a0,76(sp)
c002efd0:	00e7f7b3          	and	a5,a5,a4
c002efd4:	01f9d993          	srli	s3,s3,0x1f
c002efd8:	1c078e63          	beqz	a5,c002f1b4 <__multf3+0x308>
c002efdc:	2ee78863          	beq	a5,a4,c002f2cc <__multf3+0x420>
c002efe0:	00010ab7          	lui	s5,0x10
c002efe4:	01556ab3          	or	s5,a0,s5
c002efe8:	05512623          	sw	s5,76(sp)
c002efec:	04010593          	addi	a1,sp,64
c002eff0:	04c10713          	addi	a4,sp,76
c002eff4:	00072683          	lw	a3,0(a4)
c002eff8:	ffc72603          	lw	a2,-4(a4)
c002effc:	ffc70713          	addi	a4,a4,-4
c002f000:	00369693          	slli	a3,a3,0x3
c002f004:	01d65613          	srli	a2,a2,0x1d
c002f008:	00c6e6b3          	or	a3,a3,a2
c002f00c:	00d72223          	sw	a3,4(a4)
c002f010:	fee592e3          	bne	a1,a4,c002eff4 <__multf3+0x148>
c002f014:	04012703          	lw	a4,64(sp)
c002f018:	ffffc537          	lui	a0,0xffffc
c002f01c:	00150513          	addi	a0,a0,1 # ffffc001 <_end+0x37f77781>
c002f020:	00371713          	slli	a4,a4,0x3
c002f024:	04e12023          	sw	a4,64(sp)
c002f028:	00a787b3          	add	a5,a5,a0
c002f02c:	00000713          	li	a4,0
c002f030:	008787b3          	add	a5,a5,s0
c002f034:	02f12023          	sw	a5,32(sp)
c002f038:	00178793          	addi	a5,a5,1
c002f03c:	00f12e23          	sw	a5,28(sp)
c002f040:	002b9793          	slli	a5,s7,0x2
c002f044:	013946b3          	xor	a3,s2,s3
c002f048:	00e7e7b3          	or	a5,a5,a4
c002f04c:	00d12823          	sw	a3,16(sp)
c002f050:	fff78793          	addi	a5,a5,-1
c002f054:	00e00693          	li	a3,14
c002f058:	28f6ee63          	bltu	a3,a5,c002f2f4 <__multf3+0x448>
c002f05c:	c80026b7          	lui	a3,0xc8002
c002f060:	00279793          	slli	a5,a5,0x2
c002f064:	59468693          	addi	a3,a3,1428 # c8002594 <_end+0xfff7dd14>
c002f068:	00d787b3          	add	a5,a5,a3
c002f06c:	0007a783          	lw	a5,0(a5)
c002f070:	00078067          	jr	a5
c002f074:	00d7e633          	or	a2,a5,a3
c002f078:	00a66633          	or	a2,a2,a0
c002f07c:	00e66633          	or	a2,a2,a4
c002f080:	12060463          	beqz	a2,c002f1a8 <__multf3+0x2fc>
c002f084:	08070063          	beqz	a4,c002f104 <__multf3+0x258>
c002f088:	00070513          	mv	a0,a4
c002f08c:	da0fe0ef          	jal	ra,c002d62c <__clzsi2>
c002f090:	00050493          	mv	s1,a0
c002f094:	ff448713          	addi	a4,s1,-12 # 7fff4 <_HEAP_SIZE+0x3fff4>
c002f098:	40575613          	srai	a2,a4,0x5
c002f09c:	01f77713          	andi	a4,a4,31
c002f0a0:	08070c63          	beqz	a4,c002f138 <__multf3+0x28c>
c002f0a4:	ffc00793          	li	a5,-4
c002f0a8:	02f607b3          	mul	a5,a2,a5
c002f0ac:	02000513          	li	a0,32
c002f0b0:	03010893          	addi	a7,sp,48
c002f0b4:	40e50533          	sub	a0,a0,a4
c002f0b8:	00261593          	slli	a1,a2,0x2
c002f0bc:	00c78793          	addi	a5,a5,12
c002f0c0:	00f887b3          	add	a5,a7,a5
c002f0c4:	0af89263          	bne	a7,a5,c002f168 <__multf3+0x2bc>
c002f0c8:	08010793          	addi	a5,sp,128
c002f0cc:	00b785b3          	add	a1,a5,a1
c002f0d0:	03012783          	lw	a5,48(sp)
c002f0d4:	fff60613          	addi	a2,a2,-1
c002f0d8:	00e79733          	sll	a4,a5,a4
c002f0dc:	fae5a823          	sw	a4,-80(a1)
c002f0e0:	00160613          	addi	a2,a2,1
c002f0e4:	ffffc437          	lui	s0,0xffffc
c002f0e8:	00261613          	slli	a2,a2,0x2
c002f0ec:	00000593          	li	a1,0
c002f0f0:	03010513          	addi	a0,sp,48
c002f0f4:	01140413          	addi	s0,s0,17 # ffffc011 <_end+0x37f77791>
c002f0f8:	b91ee0ef          	jal	ra,c001dc88 <memset>
c002f0fc:	40940433          	sub	s0,s0,s1
c002f100:	e99ff06f          	j	c002ef98 <__multf3+0xec>
c002f104:	00050863          	beqz	a0,c002f114 <__multf3+0x268>
c002f108:	d24fe0ef          	jal	ra,c002d62c <__clzsi2>
c002f10c:	02050493          	addi	s1,a0,32
c002f110:	f85ff06f          	j	c002f094 <__multf3+0x1e8>
c002f114:	00068a63          	beqz	a3,c002f128 <__multf3+0x27c>
c002f118:	00068513          	mv	a0,a3
c002f11c:	d10fe0ef          	jal	ra,c002d62c <__clzsi2>
c002f120:	04050493          	addi	s1,a0,64
c002f124:	f71ff06f          	j	c002f094 <__multf3+0x1e8>
c002f128:	00078513          	mv	a0,a5
c002f12c:	d00fe0ef          	jal	ra,c002d62c <__clzsi2>
c002f130:	06050493          	addi	s1,a0,96
c002f134:	f61ff06f          	j	c002f094 <__multf3+0x1e8>
c002f138:	ffc00693          	li	a3,-4
c002f13c:	02d606b3          	mul	a3,a2,a3
c002f140:	03c10793          	addi	a5,sp,60
c002f144:	00300713          	li	a4,3
c002f148:	00d785b3          	add	a1,a5,a3
c002f14c:	0005a583          	lw	a1,0(a1)
c002f150:	fff70713          	addi	a4,a4,-1
c002f154:	ffc78793          	addi	a5,a5,-4
c002f158:	00b7a223          	sw	a1,4(a5)
c002f15c:	fec756e3          	bge	a4,a2,c002f148 <__multf3+0x29c>
c002f160:	fff60613          	addi	a2,a2,-1
c002f164:	f7dff06f          	j	c002f0e0 <__multf3+0x234>
c002f168:	0007a683          	lw	a3,0(a5)
c002f16c:	ffc7a803          	lw	a6,-4(a5)
c002f170:	00b78333          	add	t1,a5,a1
c002f174:	00e696b3          	sll	a3,a3,a4
c002f178:	00a85833          	srl	a6,a6,a0
c002f17c:	0106e6b3          	or	a3,a3,a6
c002f180:	00d32023          	sw	a3,0(t1) # 10000 <_STACK_SIZE+0xf000>
c002f184:	ffc78793          	addi	a5,a5,-4
c002f188:	f3dff06f          	j	c002f0c4 <__multf3+0x218>
c002f18c:	00d7e7b3          	or	a5,a5,a3
c002f190:	00a7e7b3          	or	a5,a5,a0
c002f194:	00e7e7b3          	or	a5,a5,a4
c002f198:	00300b93          	li	s7,3
c002f19c:	e00790e3          	bnez	a5,c002ef9c <__multf3+0xf0>
c002f1a0:	00200b93          	li	s7,2
c002f1a4:	df9ff06f          	j	c002ef9c <__multf3+0xf0>
c002f1a8:	00000413          	li	s0,0
c002f1ac:	00100b93          	li	s7,1
c002f1b0:	dedff06f          	j	c002ef9c <__multf3+0xf0>
c002f1b4:	016a67b3          	or	a5,s4,s6
c002f1b8:	0157e7b3          	or	a5,a5,s5
c002f1bc:	00a7e7b3          	or	a5,a5,a0
c002f1c0:	12078463          	beqz	a5,c002f2e8 <__multf3+0x43c>
c002f1c4:	06050e63          	beqz	a0,c002f240 <__multf3+0x394>
c002f1c8:	c64fe0ef          	jal	ra,c002d62c <__clzsi2>
c002f1cc:	00050493          	mv	s1,a0
c002f1d0:	ff448713          	addi	a4,s1,-12
c002f1d4:	40575613          	srai	a2,a4,0x5
c002f1d8:	01f77713          	andi	a4,a4,31
c002f1dc:	08070e63          	beqz	a4,c002f278 <__multf3+0x3cc>
c002f1e0:	ffc00793          	li	a5,-4
c002f1e4:	02f607b3          	mul	a5,a2,a5
c002f1e8:	02000513          	li	a0,32
c002f1ec:	04010893          	addi	a7,sp,64
c002f1f0:	40e50533          	sub	a0,a0,a4
c002f1f4:	00261593          	slli	a1,a2,0x2
c002f1f8:	00c78793          	addi	a5,a5,12
c002f1fc:	00f887b3          	add	a5,a7,a5
c002f200:	0af89463          	bne	a7,a5,c002f2a8 <__multf3+0x3fc>
c002f204:	08010793          	addi	a5,sp,128
c002f208:	00b785b3          	add	a1,a5,a1
c002f20c:	04012783          	lw	a5,64(sp)
c002f210:	fff60613          	addi	a2,a2,-1
c002f214:	00e79733          	sll	a4,a5,a4
c002f218:	fce5a023          	sw	a4,-64(a1)
c002f21c:	00160613          	addi	a2,a2,1
c002f220:	00261613          	slli	a2,a2,0x2
c002f224:	00000593          	li	a1,0
c002f228:	04010513          	addi	a0,sp,64
c002f22c:	a5dee0ef          	jal	ra,c001dc88 <memset>
c002f230:	ffffc7b7          	lui	a5,0xffffc
c002f234:	01178793          	addi	a5,a5,17 # ffffc011 <_end+0x37f77791>
c002f238:	409787b3          	sub	a5,a5,s1
c002f23c:	df1ff06f          	j	c002f02c <__multf3+0x180>
c002f240:	000a8a63          	beqz	s5,c002f254 <__multf3+0x3a8>
c002f244:	000a8513          	mv	a0,s5
c002f248:	be4fe0ef          	jal	ra,c002d62c <__clzsi2>
c002f24c:	02050493          	addi	s1,a0,32
c002f250:	f81ff06f          	j	c002f1d0 <__multf3+0x324>
c002f254:	000b0a63          	beqz	s6,c002f268 <__multf3+0x3bc>
c002f258:	000b0513          	mv	a0,s6
c002f25c:	bd0fe0ef          	jal	ra,c002d62c <__clzsi2>
c002f260:	04050493          	addi	s1,a0,64
c002f264:	f6dff06f          	j	c002f1d0 <__multf3+0x324>
c002f268:	000a0513          	mv	a0,s4
c002f26c:	bc0fe0ef          	jal	ra,c002d62c <__clzsi2>
c002f270:	06050493          	addi	s1,a0,96
c002f274:	f5dff06f          	j	c002f1d0 <__multf3+0x324>
c002f278:	ffc00693          	li	a3,-4
c002f27c:	02d606b3          	mul	a3,a2,a3
c002f280:	04c10793          	addi	a5,sp,76
c002f284:	00300713          	li	a4,3
c002f288:	00d785b3          	add	a1,a5,a3
c002f28c:	0005a583          	lw	a1,0(a1)
c002f290:	fff70713          	addi	a4,a4,-1
c002f294:	ffc78793          	addi	a5,a5,-4
c002f298:	00b7a223          	sw	a1,4(a5)
c002f29c:	fec756e3          	bge	a4,a2,c002f288 <__multf3+0x3dc>
c002f2a0:	fff60613          	addi	a2,a2,-1
c002f2a4:	f79ff06f          	j	c002f21c <__multf3+0x370>
c002f2a8:	0007a683          	lw	a3,0(a5)
c002f2ac:	ffc7a803          	lw	a6,-4(a5)
c002f2b0:	00b78333          	add	t1,a5,a1
c002f2b4:	00e696b3          	sll	a3,a3,a4
c002f2b8:	00a85833          	srl	a6,a6,a0
c002f2bc:	0106e6b3          	or	a3,a3,a6
c002f2c0:	00d32023          	sw	a3,0(t1)
c002f2c4:	ffc78793          	addi	a5,a5,-4
c002f2c8:	f39ff06f          	j	c002f200 <__multf3+0x354>
c002f2cc:	016a6a33          	or	s4,s4,s6
c002f2d0:	015a6ab3          	or	s5,s4,s5
c002f2d4:	00aaeab3          	or	s5,s5,a0
c002f2d8:	00300713          	li	a4,3
c002f2dc:	d40a9ae3          	bnez	s5,c002f030 <__multf3+0x184>
c002f2e0:	00200713          	li	a4,2
c002f2e4:	d4dff06f          	j	c002f030 <__multf3+0x184>
c002f2e8:	00000793          	li	a5,0
c002f2ec:	00100713          	li	a4,1
c002f2f0:	d41ff06f          	j	c002f030 <__multf3+0x184>
c002f2f4:	03012703          	lw	a4,48(sp)
c002f2f8:	04012e03          	lw	t3,64(sp)
c002f2fc:	00010537          	lui	a0,0x10
c002f300:	fff50693          	addi	a3,a0,-1 # ffff <_STACK_SIZE+0xefff>
c002f304:	01075f93          	srli	t6,a4,0x10
c002f308:	010e5a93          	srli	s5,t3,0x10
c002f30c:	00d77733          	and	a4,a4,a3
c002f310:	00de7e33          	and	t3,t3,a3
c002f314:	02ea87b3          	mul	a5,s5,a4
c002f318:	02ee0633          	mul	a2,t3,a4
c002f31c:	03cf8833          	mul	a6,t6,t3
c002f320:	010785b3          	add	a1,a5,a6
c002f324:	01065793          	srli	a5,a2,0x10
c002f328:	00b787b3          	add	a5,a5,a1
c002f32c:	035f8bb3          	mul	s7,t6,s5
c002f330:	0107f463          	bgeu	a5,a6,c002f338 <__multf3+0x48c>
c002f334:	00ab8bb3          	add	s7,s7,a0
c002f338:	04412f03          	lw	t5,68(sp)
c002f33c:	0107d993          	srli	s3,a5,0x10
c002f340:	00d7f7b3          	and	a5,a5,a3
c002f344:	00d67633          	and	a2,a2,a3
c002f348:	01079793          	slli	a5,a5,0x10
c002f34c:	00c787b3          	add	a5,a5,a2
c002f350:	010f5493          	srli	s1,t5,0x10
c002f354:	00df7f33          	and	t5,t5,a3
c002f358:	02ef06b3          	mul	a3,t5,a4
c002f35c:	02f12223          	sw	a5,36(sp)
c002f360:	06f12023          	sw	a5,96(sp)
c002f364:	03ef8633          	mul	a2,t6,t5
c002f368:	02e487b3          	mul	a5,s1,a4
c002f36c:	00c78533          	add	a0,a5,a2
c002f370:	0106d793          	srli	a5,a3,0x10
c002f374:	00a787b3          	add	a5,a5,a0
c002f378:	029f8b33          	mul	s6,t6,s1
c002f37c:	00c7f663          	bgeu	a5,a2,c002f388 <__multf3+0x4dc>
c002f380:	00010637          	lui	a2,0x10
c002f384:	00cb0b33          	add	s6,s6,a2
c002f388:	00010637          	lui	a2,0x10
c002f38c:	fff60593          	addi	a1,a2,-1 # ffff <_STACK_SIZE+0xefff>
c002f390:	00b7f533          	and	a0,a5,a1
c002f394:	0107d293          	srli	t0,a5,0x10
c002f398:	03412783          	lw	a5,52(sp)
c002f39c:	00b6f6b3          	and	a3,a3,a1
c002f3a0:	01051513          	slli	a0,a0,0x10
c002f3a4:	0107d913          	srli	s2,a5,0x10
c002f3a8:	00b7f5b3          	and	a1,a5,a1
c002f3ac:	02ba87b3          	mul	a5,s5,a1
c002f3b0:	00d50533          	add	a0,a0,a3
c002f3b4:	00a989b3          	add	s3,s3,a0
c002f3b8:	03c586b3          	mul	a3,a1,t3
c002f3bc:	03c90333          	mul	t1,s2,t3
c002f3c0:	00678833          	add	a6,a5,t1
c002f3c4:	0106d793          	srli	a5,a3,0x10
c002f3c8:	010787b3          	add	a5,a5,a6
c002f3cc:	032a88b3          	mul	a7,s5,s2
c002f3d0:	0067f463          	bgeu	a5,t1,c002f3d8 <__multf3+0x52c>
c002f3d4:	00c888b3          	add	a7,a7,a2
c002f3d8:	0107da13          	srli	s4,a5,0x10
c002f3dc:	011a0a33          	add	s4,s4,a7
c002f3e0:	000108b7          	lui	a7,0x10
c002f3e4:	fff88613          	addi	a2,a7,-1 # ffff <_STACK_SIZE+0xefff>
c002f3e8:	00c7f833          	and	a6,a5,a2
c002f3ec:	00c6f6b3          	and	a3,a3,a2
c002f3f0:	01081813          	slli	a6,a6,0x10
c002f3f4:	03e58633          	mul	a2,a1,t5
c002f3f8:	00d80833          	add	a6,a6,a3
c002f3fc:	03e907b3          	mul	a5,s2,t5
c002f400:	01065e93          	srli	t4,a2,0x10
c002f404:	02b486b3          	mul	a3,s1,a1
c002f408:	00f686b3          	add	a3,a3,a5
c002f40c:	00de86b3          	add	a3,t4,a3
c002f410:	03248333          	mul	t1,s1,s2
c002f414:	00f6f463          	bgeu	a3,a5,c002f41c <__multf3+0x570>
c002f418:	01130333          	add	t1,t1,a7
c002f41c:	04812e83          	lw	t4,72(sp)
c002f420:	0106d793          	srli	a5,a3,0x10
c002f424:	006787b3          	add	a5,a5,t1
c002f428:	00010437          	lui	s0,0x10
c002f42c:	02f12423          	sw	a5,40(sp)
c002f430:	fff40793          	addi	a5,s0,-1 # ffff <_STACK_SIZE+0xefff>
c002f434:	010ed393          	srli	t2,t4,0x10
c002f438:	00fefeb3          	and	t4,t4,a5
c002f43c:	02e388b3          	mul	a7,t2,a4
c002f440:	00f67633          	and	a2,a2,a5
c002f444:	00f6f6b3          	and	a3,a3,a5
c002f448:	01069693          	slli	a3,a3,0x10
c002f44c:	00c686b3          	add	a3,a3,a2
c002f450:	02ee8333          	mul	t1,t4,a4
c002f454:	03df8c33          	mul	s8,t6,t4
c002f458:	018887b3          	add	a5,a7,s8
c002f45c:	01035893          	srli	a7,t1,0x10
c002f460:	00f888b3          	add	a7,a7,a5
c002f464:	027f8633          	mul	a2,t6,t2
c002f468:	0188f463          	bgeu	a7,s8,c002f470 <__multf3+0x5c4>
c002f46c:	00860633          	add	a2,a2,s0
c002f470:	0108d793          	srli	a5,a7,0x10
c002f474:	00010cb7          	lui	s9,0x10
c002f478:	00c787b3          	add	a5,a5,a2
c002f47c:	fffc8613          	addi	a2,s9,-1 # ffff <_STACK_SIZE+0xefff>
c002f480:	02f12623          	sw	a5,44(sp)
c002f484:	00c8f7b3          	and	a5,a7,a2
c002f488:	03812883          	lw	a7,56(sp)
c002f48c:	00c37333          	and	t1,t1,a2
c002f490:	01079793          	slli	a5,a5,0x10
c002f494:	0108d413          	srli	s0,a7,0x10
c002f498:	00c8f633          	and	a2,a7,a2
c002f49c:	03c608b3          	mul	a7,a2,t3
c002f4a0:	006787b3          	add	a5,a5,t1
c002f4a4:	03c40d33          	mul	s10,s0,t3
c002f4a8:	0108dd93          	srli	s11,a7,0x10
c002f4ac:	02ca8333          	mul	t1,s5,a2
c002f4b0:	01a30333          	add	t1,t1,s10
c002f4b4:	006d8db3          	add	s11,s11,t1
c002f4b8:	028a8c33          	mul	s8,s5,s0
c002f4bc:	01adf463          	bgeu	s11,s10,c002f4c4 <__multf3+0x618>
c002f4c0:	019c0c33          	add	s8,s8,s9
c002f4c4:	013b89b3          	add	s3,s7,s3
c002f4c8:	00a9b533          	sltu	a0,s3,a0
c002f4cc:	010dd313          	srli	t1,s11,0x10
c002f4d0:	00a282b3          	add	t0,t0,a0
c002f4d4:	01628b33          	add	s6,t0,s6
c002f4d8:	01830c33          	add	s8,t1,s8
c002f4dc:	01098333          	add	t1,s3,a6
c002f4e0:	01033833          	sltu	a6,t1,a6
c002f4e4:	00010cb7          	lui	s9,0x10
c002f4e8:	00612a23          	sw	t1,20(sp)
c002f4ec:	06612223          	sw	t1,100(sp)
c002f4f0:	014b0333          	add	t1,s6,s4
c002f4f4:	010302b3          	add	t0,t1,a6
c002f4f8:	fffc8d13          	addi	s10,s9,-1 # ffff <_STACK_SIZE+0xefff>
c002f4fc:	01433333          	sltu	t1,t1,s4
c002f500:	0102b833          	sltu	a6,t0,a6
c002f504:	01adfdb3          	and	s11,s11,s10
c002f508:	00d289b3          	add	s3,t0,a3
c002f50c:	01036833          	or	a6,t1,a6
c002f510:	010d9d93          	slli	s11,s11,0x10
c002f514:	00ab3533          	sltu	a0,s6,a0
c002f518:	01a8f8b3          	and	a7,a7,s10
c002f51c:	011d88b3          	add	a7,s11,a7
c002f520:	00d9b6b3          	sltu	a3,s3,a3
c002f524:	00a80533          	add	a0,a6,a0
c002f528:	00f989b3          	add	s3,s3,a5
c002f52c:	02812803          	lw	a6,40(sp)
c002f530:	01198333          	add	t1,s3,a7
c002f534:	011338b3          	sltu	a7,t1,a7
c002f538:	00612c23          	sw	t1,24(sp)
c002f53c:	06612423          	sw	t1,104(sp)
c002f540:	02812303          	lw	t1,40(sp)
c002f544:	01050533          	add	a0,a0,a6
c002f548:	02c12803          	lw	a6,44(sp)
c002f54c:	00d50db3          	add	s11,a0,a3
c002f550:	00ddb6b3          	sltu	a3,s11,a3
c002f554:	00653533          	sltu	a0,a0,t1
c002f558:	00f9b7b3          	sltu	a5,s3,a5
c002f55c:	010d8bb3          	add	s7,s11,a6
c002f560:	00d566b3          	or	a3,a0,a3
c002f564:	02c12503          	lw	a0,44(sp)
c002f568:	00fb8833          	add	a6,s7,a5
c002f56c:	04c12303          	lw	t1,76(sp)
c002f570:	018809b3          	add	s3,a6,s8
c002f574:	01198b33          	add	s6,s3,a7
c002f578:	00abbbb3          	sltu	s7,s7,a0
c002f57c:	00f837b3          	sltu	a5,a6,a5
c002f580:	00fbe7b3          	or	a5,s7,a5
c002f584:	011b38b3          	sltu	a7,s6,a7
c002f588:	0189bc33          	sltu	s8,s3,s8
c002f58c:	00f686b3          	add	a3,a3,a5
c002f590:	01035293          	srli	t0,t1,0x10
c002f594:	011c6a33          	or	s4,s8,a7
c002f598:	01a37333          	and	t1,t1,s10
c002f59c:	02e307b3          	mul	a5,t1,a4
c002f5a0:	01468a33          	add	s4,a3,s4
c002f5a4:	02e28733          	mul	a4,t0,a4
c002f5a8:	0107d893          	srli	a7,a5,0x10
c002f5ac:	026f86b3          	mul	a3,t6,t1
c002f5b0:	00d70733          	add	a4,a4,a3
c002f5b4:	00e888b3          	add	a7,a7,a4
c002f5b8:	025f8fb3          	mul	t6,t6,t0
c002f5bc:	00d8f463          	bgeu	a7,a3,c002f5c4 <__multf3+0x718>
c002f5c0:	019f8fb3          	add	t6,t6,s9
c002f5c4:	03c12983          	lw	s3,60(sp)
c002f5c8:	000106b7          	lui	a3,0x10
c002f5cc:	fff68513          	addi	a0,a3,-1 # ffff <_STACK_SIZE+0xefff>
c002f5d0:	0108d713          	srli	a4,a7,0x10
c002f5d4:	00a8f8b3          	and	a7,a7,a0
c002f5d8:	01f70733          	add	a4,a4,t6
c002f5dc:	00a7f7b3          	and	a5,a5,a0
c002f5e0:	0109df93          	srli	t6,s3,0x10
c002f5e4:	01089893          	slli	a7,a7,0x10
c002f5e8:	00a9f9b3          	and	s3,s3,a0
c002f5ec:	00070d93          	mv	s11,a4
c002f5f0:	00f888b3          	add	a7,a7,a5
c002f5f4:	03fa8733          	mul	a4,s5,t6
c002f5f8:	03c987b3          	mul	a5,s3,t3
c002f5fc:	033a8ab3          	mul	s5,s5,s3
c002f600:	0107d813          	srli	a6,a5,0x10
c002f604:	03cf8e33          	mul	t3,t6,t3
c002f608:	01ca8ab3          	add	s5,s5,t3
c002f60c:	01580ab3          	add	s5,a6,s5
c002f610:	01caf463          	bgeu	s5,t3,c002f618 <__multf3+0x76c>
c002f614:	00d70733          	add	a4,a4,a3
c002f618:	010ad693          	srli	a3,s5,0x10
c002f61c:	00e68733          	add	a4,a3,a4
c002f620:	00010bb7          	lui	s7,0x10
c002f624:	02e12423          	sw	a4,40(sp)
c002f628:	fffb8713          	addi	a4,s7,-1 # ffff <_STACK_SIZE+0xefff>
c002f62c:	00eaf833          	and	a6,s5,a4
c002f630:	00e7f7b3          	and	a5,a5,a4
c002f634:	01081813          	slli	a6,a6,0x10
c002f638:	02be8733          	mul	a4,t4,a1
c002f63c:	00f80833          	add	a6,a6,a5
c002f640:	03d906b3          	mul	a3,s2,t4
c002f644:	01075513          	srli	a0,a4,0x10
c002f648:	02b387b3          	mul	a5,t2,a1
c002f64c:	00d787b3          	add	a5,a5,a3
c002f650:	00f507b3          	add	a5,a0,a5
c002f654:	02790e33          	mul	t3,s2,t2
c002f658:	00d7f463          	bgeu	a5,a3,c002f660 <__multf3+0x7b4>
c002f65c:	017e0e33          	add	t3,t3,s7
c002f660:	0107d693          	srli	a3,a5,0x10
c002f664:	01c686b3          	add	a3,a3,t3
c002f668:	00010bb7          	lui	s7,0x10
c002f66c:	02d12623          	sw	a3,44(sp)
c002f670:	fffb8693          	addi	a3,s7,-1 # ffff <_STACK_SIZE+0xefff>
c002f674:	00d7f533          	and	a0,a5,a3
c002f678:	00d77733          	and	a4,a4,a3
c002f67c:	01051513          	slli	a0,a0,0x10
c002f680:	03e40e33          	mul	t3,s0,t5
c002f684:	00e50533          	add	a0,a0,a4
c002f688:	02c487b3          	mul	a5,s1,a2
c002f68c:	03e60733          	mul	a4,a2,t5
c002f690:	01c787b3          	add	a5,a5,t3
c002f694:	01075693          	srli	a3,a4,0x10
c002f698:	00f687b3          	add	a5,a3,a5
c002f69c:	02848ab3          	mul	s5,s1,s0
c002f6a0:	01c7f463          	bgeu	a5,t3,c002f6a8 <__multf3+0x7fc>
c002f6a4:	017a8ab3          	add	s5,s5,s7
c002f6a8:	000106b7          	lui	a3,0x10
c002f6ac:	fff68e13          	addi	t3,a3,-1 # ffff <_STACK_SIZE+0xefff>
c002f6b0:	01c7f6b3          	and	a3,a5,t3
c002f6b4:	0107db93          	srli	s7,a5,0x10
c002f6b8:	011b07b3          	add	a5,s6,a7
c002f6bc:	01c77733          	and	a4,a4,t3
c002f6c0:	0117b8b3          	sltu	a7,a5,a7
c002f6c4:	01ba0a33          	add	s4,s4,s11
c002f6c8:	01069693          	slli	a3,a3,0x10
c002f6cc:	00e686b3          	add	a3,a3,a4
c002f6d0:	011a0d33          	add	s10,s4,a7
c002f6d4:	02812703          	lw	a4,40(sp)
c002f6d8:	011d38b3          	sltu	a7,s10,a7
c002f6dc:	01ba3a33          	sltu	s4,s4,s11
c002f6e0:	010787b3          	add	a5,a5,a6
c002f6e4:	011a6a33          	or	s4,s4,a7
c002f6e8:	02812883          	lw	a7,40(sp)
c002f6ec:	0107b833          	sltu	a6,a5,a6
c002f6f0:	00ed0b33          	add	s6,s10,a4
c002f6f4:	02c12703          	lw	a4,44(sp)
c002f6f8:	010b0cb3          	add	s9,s6,a6
c002f6fc:	00a787b3          	add	a5,a5,a0
c002f700:	011b3b33          	sltu	s6,s6,a7
c002f704:	010cb833          	sltu	a6,s9,a6
c002f708:	00a7b533          	sltu	a0,a5,a0
c002f70c:	00ec8733          	add	a4,s9,a4
c002f710:	010b6b33          	or	s6,s6,a6
c002f714:	02c12803          	lw	a6,44(sp)
c002f718:	00a70c33          	add	s8,a4,a0
c002f71c:	015b8bb3          	add	s7,s7,s5
c002f720:	00d787b3          	add	a5,a5,a3
c002f724:	00d7b6b3          	sltu	a3,a5,a3
c002f728:	017c0ab3          	add	s5,s8,s7
c002f72c:	00da8e33          	add	t3,s5,a3
c002f730:	01073733          	sltu	a4,a4,a6
c002f734:	00ac3533          	sltu	a0,s8,a0
c002f738:	00a76733          	or	a4,a4,a0
c002f73c:	00de36b3          	sltu	a3,t3,a3
c002f740:	016a0a33          	add	s4,s4,s6
c002f744:	017abab3          	sltu	s5,s5,s7
c002f748:	00ea0a33          	add	s4,s4,a4
c002f74c:	00daeab3          	or	s5,s5,a3
c002f750:	02ce8833          	mul	a6,t4,a2
c002f754:	015a06b3          	add	a3,s4,s5
c002f758:	06f12623          	sw	a5,108(sp)
c002f75c:	03d40a33          	mul	s4,s0,t4
c002f760:	01085513          	srli	a0,a6,0x10
c002f764:	02c38733          	mul	a4,t2,a2
c002f768:	01470733          	add	a4,a4,s4
c002f76c:	00e50733          	add	a4,a0,a4
c002f770:	028388b3          	mul	a7,t2,s0
c002f774:	01477663          	bgeu	a4,s4,c002f780 <__multf3+0x8d4>
c002f778:	00010537          	lui	a0,0x10
c002f77c:	00a888b3          	add	a7,a7,a0
c002f780:	00010a37          	lui	s4,0x10
c002f784:	01075513          	srli	a0,a4,0x10
c002f788:	fffa0a93          	addi	s5,s4,-1 # ffff <_STACK_SIZE+0xefff>
c002f78c:	011508b3          	add	a7,a0,a7
c002f790:	01577533          	and	a0,a4,s5
c002f794:	01587833          	and	a6,a6,s5
c002f798:	01051513          	slli	a0,a0,0x10
c002f79c:	02690ab3          	mul	s5,s2,t1
c002f7a0:	01050533          	add	a0,a0,a6
c002f7a4:	02b30833          	mul	a6,t1,a1
c002f7a8:	02b285b3          	mul	a1,t0,a1
c002f7ac:	01085713          	srli	a4,a6,0x10
c002f7b0:	015585b3          	add	a1,a1,s5
c002f7b4:	00b70733          	add	a4,a4,a1
c002f7b8:	02590933          	mul	s2,s2,t0
c002f7bc:	01577463          	bgeu	a4,s5,c002f7c4 <__multf3+0x918>
c002f7c0:	01490933          	add	s2,s2,s4
c002f7c4:	00010ab7          	lui	s5,0x10
c002f7c8:	01075593          	srli	a1,a4,0x10
c002f7cc:	fffa8a13          	addi	s4,s5,-1 # ffff <_STACK_SIZE+0xefff>
c002f7d0:	01487833          	and	a6,a6,s4
c002f7d4:	01258933          	add	s2,a1,s2
c002f7d8:	014775b3          	and	a1,a4,s4
c002f7dc:	01059593          	slli	a1,a1,0x10
c002f7e0:	03e98733          	mul	a4,s3,t5
c002f7e4:	010585b3          	add	a1,a1,a6
c002f7e8:	03ef8f33          	mul	t5,t6,t5
c002f7ec:	01075813          	srli	a6,a4,0x10
c002f7f0:	03f48a33          	mul	s4,s1,t6
c002f7f4:	033484b3          	mul	s1,s1,s3
c002f7f8:	01e484b3          	add	s1,s1,t5
c002f7fc:	009804b3          	add	s1,a6,s1
c002f800:	01e4f463          	bgeu	s1,t5,c002f808 <__multf3+0x95c>
c002f804:	015a0a33          	add	s4,s4,s5
c002f808:	0104db13          	srli	s6,s1,0x10
c002f80c:	014b0b33          	add	s6,s6,s4
c002f810:	00010a37          	lui	s4,0x10
c002f814:	fffa0f13          	addi	t5,s4,-1 # ffff <_STACK_SIZE+0xefff>
c002f818:	01e4f833          	and	a6,s1,t5
c002f81c:	01e77733          	and	a4,a4,t5
c002f820:	026404b3          	mul	s1,s0,t1
c002f824:	01081813          	slli	a6,a6,0x10
c002f828:	00e80833          	add	a6,a6,a4
c002f82c:	02660f33          	mul	t5,a2,t1
c002f830:	02c28633          	mul	a2,t0,a2
c002f834:	010f5713          	srli	a4,t5,0x10
c002f838:	00960633          	add	a2,a2,s1
c002f83c:	00c70633          	add	a2,a4,a2
c002f840:	02540433          	mul	s0,s0,t0
c002f844:	00967463          	bgeu	a2,s1,c002f84c <__multf3+0x9a0>
c002f848:	01440433          	add	s0,s0,s4
c002f84c:	00010a37          	lui	s4,0x10
c002f850:	01065713          	srli	a4,a2,0x10
c002f854:	fffa0493          	addi	s1,s4,-1 # ffff <_STACK_SIZE+0xefff>
c002f858:	00870433          	add	s0,a4,s0
c002f85c:	00967733          	and	a4,a2,s1
c002f860:	009f7f33          	and	t5,t5,s1
c002f864:	01071713          	slli	a4,a4,0x10
c002f868:	03f384b3          	mul	s1,t2,t6
c002f86c:	01e70733          	add	a4,a4,t5
c002f870:	033383b3          	mul	t2,t2,s3
c002f874:	03d98f33          	mul	t5,s3,t4
c002f878:	03df8eb3          	mul	t4,t6,t4
c002f87c:	010f5613          	srli	a2,t5,0x10
c002f880:	01d383b3          	add	t2,t2,t4
c002f884:	00760633          	add	a2,a2,t2
c002f888:	01d67463          	bgeu	a2,t4,c002f890 <__multf3+0x9e4>
c002f88c:	014484b3          	add	s1,s1,s4
c002f890:	01065c13          	srli	s8,a2,0x10
c002f894:	00010cb7          	lui	s9,0x10
c002f898:	009c0c33          	add	s8,s8,s1
c002f89c:	00ae0e33          	add	t3,t3,a0
c002f8a0:	fffc8493          	addi	s1,s9,-1 # ffff <_STACK_SIZE+0xefff>
c002f8a4:	00ae3533          	sltu	a0,t3,a0
c002f8a8:	011686b3          	add	a3,a3,a7
c002f8ac:	00967633          	and	a2,a2,s1
c002f8b0:	00a68d33          	add	s10,a3,a0
c002f8b4:	009f7f33          	and	t5,t5,s1
c002f8b8:	00be0e33          	add	t3,t3,a1
c002f8bc:	01061613          	slli	a2,a2,0x10
c002f8c0:	01e60633          	add	a2,a2,t5
c002f8c4:	00be35b3          	sltu	a1,t3,a1
c002f8c8:	012d0f33          	add	t5,s10,s2
c002f8cc:	010e0e33          	add	t3,t3,a6
c002f8d0:	00bf03b3          	add	t2,t5,a1
c002f8d4:	01638eb3          	add	t4,t2,s6
c002f8d8:	07c12823          	sw	t3,112(sp)
c002f8dc:	010e3e33          	sltu	t3,t3,a6
c002f8e0:	01ce8db3          	add	s11,t4,t3
c002f8e4:	0116b6b3          	sltu	a3,a3,a7
c002f8e8:	00ad3533          	sltu	a0,s10,a0
c002f8ec:	012f3933          	sltu	s2,t5,s2
c002f8f0:	00b3b5b3          	sltu	a1,t2,a1
c002f8f4:	00a6e533          	or	a0,a3,a0
c002f8f8:	00b965b3          	or	a1,s2,a1
c002f8fc:	016ebeb3          	sltu	t4,t4,s6
c002f900:	01cdbe33          	sltu	t3,s11,t3
c002f904:	00b50533          	add	a0,a0,a1
c002f908:	01ceeeb3          	or	t4,t4,t3
c002f90c:	00ed8833          	add	a6,s11,a4
c002f910:	01d50533          	add	a0,a0,t4
c002f914:	00e83733          	sltu	a4,a6,a4
c002f918:	00850533          	add	a0,a0,s0
c002f91c:	00e506b3          	add	a3,a0,a4
c002f920:	00853433          	sltu	s0,a0,s0
c002f924:	02698533          	mul	a0,s3,t1
c002f928:	00c80833          	add	a6,a6,a2
c002f92c:	00e6b733          	sltu	a4,a3,a4
c002f930:	00c83633          	sltu	a2,a6,a2
c002f934:	018686b3          	add	a3,a3,s8
c002f938:	00c685b3          	add	a1,a3,a2
c002f93c:	0186bc33          	sltu	s8,a3,s8
c002f940:	00c5b633          	sltu	a2,a1,a2
c002f944:	07012a23          	sw	a6,116(sp)
c002f948:	00e46733          	or	a4,s0,a4
c002f94c:	026f8333          	mul	t1,t6,t1
c002f950:	01055693          	srli	a3,a0,0x10
c002f954:	00cc6633          	or	a2,s8,a2
c002f958:	033289b3          	mul	s3,t0,s3
c002f95c:	006989b3          	add	s3,s3,t1
c002f960:	03f28fb3          	mul	t6,t0,t6
c002f964:	013682b3          	add	t0,a3,s3
c002f968:	0062f463          	bgeu	t0,t1,c002f970 <__multf3+0xac4>
c002f96c:	019f8fb3          	add	t6,t6,s9
c002f970:	0092f6b3          	and	a3,t0,s1
c002f974:	01069693          	slli	a3,a3,0x10
c002f978:	009574b3          	and	s1,a0,s1
c002f97c:	0102d293          	srli	t0,t0,0x10
c002f980:	009684b3          	add	s1,a3,s1
c002f984:	00e282b3          	add	t0,t0,a4
c002f988:	01412683          	lw	a3,20(sp)
c002f98c:	02412703          	lw	a4,36(sp)
c002f990:	009585b3          	add	a1,a1,s1
c002f994:	0095b4b3          	sltu	s1,a1,s1
c002f998:	00d769b3          	or	s3,a4,a3
c002f99c:	01812703          	lw	a4,24(sp)
c002f9a0:	00c282b3          	add	t0,t0,a2
c002f9a4:	009282b3          	add	t0,t0,s1
c002f9a8:	013769b3          	or	s3,a4,s3
c002f9ac:	01f28fb3          	add	t6,t0,t6
c002f9b0:	00d79793          	slli	a5,a5,0xd
c002f9b4:	06b12c23          	sw	a1,120(sp)
c002f9b8:	07f12e23          	sw	t6,124(sp)
c002f9bc:	0137e7b3          	or	a5,a5,s3
c002f9c0:	06010713          	addi	a4,sp,96
c002f9c4:	07010593          	addi	a1,sp,112
c002f9c8:	00c72683          	lw	a3,12(a4)
c002f9cc:	01072603          	lw	a2,16(a4)
c002f9d0:	00470713          	addi	a4,a4,4
c002f9d4:	0136d693          	srli	a3,a3,0x13
c002f9d8:	00d61613          	slli	a2,a2,0xd
c002f9dc:	00c6e6b3          	or	a3,a3,a2
c002f9e0:	fed72e23          	sw	a3,-4(a4)
c002f9e4:	fee592e3          	bne	a1,a4,c002f9c8 <__multf3+0xb1c>
c002f9e8:	06812683          	lw	a3,104(sp)
c002f9ec:	06012703          	lw	a4,96(sp)
c002f9f0:	00f037b3          	snez	a5,a5
c002f9f4:	04d12c23          	sw	a3,88(sp)
c002f9f8:	06412683          	lw	a3,100(sp)
c002f9fc:	00e7e7b3          	or	a5,a5,a4
c002fa00:	06c12703          	lw	a4,108(sp)
c002fa04:	04d12a23          	sw	a3,84(sp)
c002fa08:	001006b7          	lui	a3,0x100
c002fa0c:	04e12e23          	sw	a4,92(sp)
c002fa10:	04f12823          	sw	a5,80(sp)
c002fa14:	00d77733          	and	a4,a4,a3
c002fa18:	20070e63          	beqz	a4,c002fc34 <__multf3+0xd88>
c002fa1c:	01f79793          	slli	a5,a5,0x1f
c002fa20:	05010713          	addi	a4,sp,80
c002fa24:	05c10593          	addi	a1,sp,92
c002fa28:	00072683          	lw	a3,0(a4)
c002fa2c:	00472603          	lw	a2,4(a4)
c002fa30:	00470713          	addi	a4,a4,4
c002fa34:	0016d693          	srli	a3,a3,0x1
c002fa38:	01f61613          	slli	a2,a2,0x1f
c002fa3c:	00c6e6b3          	or	a3,a3,a2
c002fa40:	fed72e23          	sw	a3,-4(a4)
c002fa44:	fee592e3          	bne	a1,a4,c002fa28 <__multf3+0xb7c>
c002fa48:	05c12703          	lw	a4,92(sp)
c002fa4c:	00f037b3          	snez	a5,a5
c002fa50:	00175713          	srli	a4,a4,0x1
c002fa54:	04e12e23          	sw	a4,92(sp)
c002fa58:	05012703          	lw	a4,80(sp)
c002fa5c:	00f767b3          	or	a5,a4,a5
c002fa60:	04f12823          	sw	a5,80(sp)
c002fa64:	01c12703          	lw	a4,28(sp)
c002fa68:	000047b7          	lui	a5,0x4
c002fa6c:	fff78793          	addi	a5,a5,-1 # 3fff <_STACK_SIZE+0x2fff>
c002fa70:	00f707b3          	add	a5,a4,a5
c002fa74:	1ef05263          	blez	a5,c002fc58 <__multf3+0xdac>
c002fa78:	05012703          	lw	a4,80(sp)
c002fa7c:	00777693          	andi	a3,a4,7
c002fa80:	04068463          	beqz	a3,c002fac8 <__multf3+0xc1c>
c002fa84:	00f77693          	andi	a3,a4,15
c002fa88:	00400613          	li	a2,4
c002fa8c:	02c68e63          	beq	a3,a2,c002fac8 <__multf3+0xc1c>
c002fa90:	05412683          	lw	a3,84(sp)
c002fa94:	00470713          	addi	a4,a4,4
c002fa98:	04e12823          	sw	a4,80(sp)
c002fa9c:	00473713          	sltiu	a4,a4,4
c002faa0:	00d706b3          	add	a3,a4,a3
c002faa4:	00e6b733          	sltu	a4,a3,a4
c002faa8:	04d12a23          	sw	a3,84(sp)
c002faac:	05812683          	lw	a3,88(sp)
c002fab0:	00d706b3          	add	a3,a4,a3
c002fab4:	04d12c23          	sw	a3,88(sp)
c002fab8:	00e6b6b3          	sltu	a3,a3,a4
c002fabc:	05c12703          	lw	a4,92(sp)
c002fac0:	00e686b3          	add	a3,a3,a4
c002fac4:	04d12e23          	sw	a3,92(sp)
c002fac8:	05c12703          	lw	a4,92(sp)
c002facc:	001006b7          	lui	a3,0x100
c002fad0:	00d776b3          	and	a3,a4,a3
c002fad4:	02068063          	beqz	a3,c002faf4 <__multf3+0xc48>
c002fad8:	fff007b7          	lui	a5,0xfff00
c002fadc:	fff78793          	addi	a5,a5,-1 # ffefffff <_end+0x37e7b77f>
c002fae0:	00f77733          	and	a4,a4,a5
c002fae4:	04e12e23          	sw	a4,92(sp)
c002fae8:	01c12703          	lw	a4,28(sp)
c002faec:	000047b7          	lui	a5,0x4
c002faf0:	00f707b3          	add	a5,a4,a5
c002faf4:	05010713          	addi	a4,sp,80
c002faf8:	05c10593          	addi	a1,sp,92
c002fafc:	00072683          	lw	a3,0(a4)
c002fb00:	00472603          	lw	a2,4(a4)
c002fb04:	00470713          	addi	a4,a4,4
c002fb08:	0036d693          	srli	a3,a3,0x3
c002fb0c:	01d61613          	slli	a2,a2,0x1d
c002fb10:	00c6e6b3          	or	a3,a3,a2
c002fb14:	fed72e23          	sw	a3,-4(a4)
c002fb18:	feb712e3          	bne	a4,a1,c002fafc <__multf3+0xc50>
c002fb1c:	00008737          	lui	a4,0x8
c002fb20:	ffe70693          	addi	a3,a4,-2 # 7ffe <_STACK_SIZE+0x6ffe>
c002fb24:	10f6ce63          	blt	a3,a5,c002fc40 <__multf3+0xd94>
c002fb28:	05c12703          	lw	a4,92(sp)
c002fb2c:	00375713          	srli	a4,a4,0x3
c002fb30:	04e12e23          	sw	a4,92(sp)
c002fb34:	05c12703          	lw	a4,92(sp)
c002fb38:	01179793          	slli	a5,a5,0x11
c002fb3c:	0117d793          	srli	a5,a5,0x11
c002fb40:	06e11623          	sh	a4,108(sp)
c002fb44:	01012703          	lw	a4,16(sp)
c002fb48:	0bc12083          	lw	ra,188(sp)
c002fb4c:	0b812403          	lw	s0,184(sp)
c002fb50:	00f71713          	slli	a4,a4,0xf
c002fb54:	00f767b3          	or	a5,a4,a5
c002fb58:	06f11723          	sh	a5,110(sp)
c002fb5c:	00c12703          	lw	a4,12(sp)
c002fb60:	05012783          	lw	a5,80(sp)
c002fb64:	0b412483          	lw	s1,180(sp)
c002fb68:	0b012903          	lw	s2,176(sp)
c002fb6c:	00f72023          	sw	a5,0(a4)
c002fb70:	05412783          	lw	a5,84(sp)
c002fb74:	0ac12983          	lw	s3,172(sp)
c002fb78:	0a812a03          	lw	s4,168(sp)
c002fb7c:	00f72223          	sw	a5,4(a4)
c002fb80:	05812783          	lw	a5,88(sp)
c002fb84:	0a412a83          	lw	s5,164(sp)
c002fb88:	0a012b03          	lw	s6,160(sp)
c002fb8c:	00f72423          	sw	a5,8(a4)
c002fb90:	06c12783          	lw	a5,108(sp)
c002fb94:	09c12b83          	lw	s7,156(sp)
c002fb98:	09812c03          	lw	s8,152(sp)
c002fb9c:	00f72623          	sw	a5,12(a4)
c002fba0:	09412c83          	lw	s9,148(sp)
c002fba4:	09012d03          	lw	s10,144(sp)
c002fba8:	08c12d83          	lw	s11,140(sp)
c002fbac:	00070513          	mv	a0,a4
c002fbb0:	0c010113          	addi	sp,sp,192
c002fbb4:	00008067          	ret
c002fbb8:	01212823          	sw	s2,16(sp)
c002fbbc:	03012783          	lw	a5,48(sp)
c002fbc0:	04f12823          	sw	a5,80(sp)
c002fbc4:	03412783          	lw	a5,52(sp)
c002fbc8:	04f12a23          	sw	a5,84(sp)
c002fbcc:	03812783          	lw	a5,56(sp)
c002fbd0:	04f12c23          	sw	a5,88(sp)
c002fbd4:	03c12783          	lw	a5,60(sp)
c002fbd8:	04f12e23          	sw	a5,92(sp)
c002fbdc:	00200793          	li	a5,2
c002fbe0:	28fb8063          	beq	s7,a5,c002fe60 <__multf3+0xfb4>
c002fbe4:	00300793          	li	a5,3
c002fbe8:	28fb8a63          	beq	s7,a5,c002fe7c <__multf3+0xfd0>
c002fbec:	00100793          	li	a5,1
c002fbf0:	e6fb9ae3          	bne	s7,a5,c002fa64 <__multf3+0xbb8>
c002fbf4:	04012e23          	sw	zero,92(sp)
c002fbf8:	04012c23          	sw	zero,88(sp)
c002fbfc:	04012a23          	sw	zero,84(sp)
c002fc00:	04012823          	sw	zero,80(sp)
c002fc04:	21c0006f          	j	c002fe20 <__multf3+0xf74>
c002fc08:	01312823          	sw	s3,16(sp)
c002fc0c:	04012783          	lw	a5,64(sp)
c002fc10:	00070b93          	mv	s7,a4
c002fc14:	04f12823          	sw	a5,80(sp)
c002fc18:	04412783          	lw	a5,68(sp)
c002fc1c:	04f12a23          	sw	a5,84(sp)
c002fc20:	04812783          	lw	a5,72(sp)
c002fc24:	04f12c23          	sw	a5,88(sp)
c002fc28:	04c12783          	lw	a5,76(sp)
c002fc2c:	04f12e23          	sw	a5,92(sp)
c002fc30:	fadff06f          	j	c002fbdc <__multf3+0xd30>
c002fc34:	02012783          	lw	a5,32(sp)
c002fc38:	00f12e23          	sw	a5,28(sp)
c002fc3c:	e29ff06f          	j	c002fa64 <__multf3+0xbb8>
c002fc40:	04012e23          	sw	zero,92(sp)
c002fc44:	04012c23          	sw	zero,88(sp)
c002fc48:	04012a23          	sw	zero,84(sp)
c002fc4c:	04012823          	sw	zero,80(sp)
c002fc50:	fff70793          	addi	a5,a4,-1
c002fc54:	ee1ff06f          	j	c002fb34 <__multf3+0xc88>
c002fc58:	00100713          	li	a4,1
c002fc5c:	40f707b3          	sub	a5,a4,a5
c002fc60:	07400713          	li	a4,116
c002fc64:	1cf74263          	blt	a4,a5,c002fe28 <__multf3+0xf7c>
c002fc68:	05010493          	addi	s1,sp,80
c002fc6c:	4057d513          	srai	a0,a5,0x5
c002fc70:	00048693          	mv	a3,s1
c002fc74:	00000413          	li	s0,0
c002fc78:	00000713          	li	a4,0
c002fc7c:	04a71263          	bne	a4,a0,c002fcc0 <__multf3+0xe14>
c002fc80:	01f7f793          	andi	a5,a5,31
c002fc84:	00251713          	slli	a4,a0,0x2
c002fc88:	04079663          	bnez	a5,c002fcd4 <__multf3+0xe28>
c002fc8c:	00300613          	li	a2,3
c002fc90:	00048793          	mv	a5,s1
c002fc94:	00000693          	li	a3,0
c002fc98:	40a60633          	sub	a2,a2,a0
c002fc9c:	00e785b3          	add	a1,a5,a4
c002fca0:	0005a583          	lw	a1,0(a1)
c002fca4:	00168693          	addi	a3,a3,1 # 100001 <_HEAP_SIZE+0xc0001>
c002fca8:	00478793          	addi	a5,a5,4 # 4004 <_STACK_SIZE+0x3004>
c002fcac:	feb7ae23          	sw	a1,-4(a5)
c002fcb0:	fed656e3          	bge	a2,a3,c002fc9c <__multf3+0xdf0>
c002fcb4:	00400793          	li	a5,4
c002fcb8:	40a78533          	sub	a0,a5,a0
c002fcbc:	0700006f          	j	c002fd2c <__multf3+0xe80>
c002fcc0:	0006a603          	lw	a2,0(a3)
c002fcc4:	00170713          	addi	a4,a4,1
c002fcc8:	00468693          	addi	a3,a3,4
c002fccc:	00c46433          	or	s0,s0,a2
c002fcd0:	fadff06f          	j	c002fc7c <__multf3+0xdd0>
c002fcd4:	ffc00893          	li	a7,-4
c002fcd8:	031508b3          	mul	a7,a0,a7
c002fcdc:	08010693          	addi	a3,sp,128
c002fce0:	00e686b3          	add	a3,a3,a4
c002fce4:	fd06a683          	lw	a3,-48(a3)
c002fce8:	02000593          	li	a1,32
c002fcec:	40f585b3          	sub	a1,a1,a5
c002fcf0:	00b696b3          	sll	a3,a3,a1
c002fcf4:	00d46433          	or	s0,s0,a3
c002fcf8:	00300693          	li	a3,3
c002fcfc:	00e48733          	add	a4,s1,a4
c002fd00:	00000813          	li	a6,0
c002fd04:	40a686b3          	sub	a3,a3,a0
c002fd08:	0cd84063          	blt	a6,a3,c002fdc8 <__multf3+0xf1c>
c002fd0c:	00400713          	li	a4,4
c002fd10:	40a70533          	sub	a0,a4,a0
c002fd14:	00269693          	slli	a3,a3,0x2
c002fd18:	08010713          	addi	a4,sp,128
c002fd1c:	00d706b3          	add	a3,a4,a3
c002fd20:	05c12703          	lw	a4,92(sp)
c002fd24:	00f757b3          	srl	a5,a4,a5
c002fd28:	fcf6a823          	sw	a5,-48(a3)
c002fd2c:	00400913          	li	s2,4
c002fd30:	40a90633          	sub	a2,s2,a0
c002fd34:	00251513          	slli	a0,a0,0x2
c002fd38:	00261613          	slli	a2,a2,0x2
c002fd3c:	00000593          	li	a1,0
c002fd40:	00a48533          	add	a0,s1,a0
c002fd44:	f45ed0ef          	jal	ra,c001dc88 <memset>
c002fd48:	05012703          	lw	a4,80(sp)
c002fd4c:	008037b3          	snez	a5,s0
c002fd50:	00e7e7b3          	or	a5,a5,a4
c002fd54:	04f12823          	sw	a5,80(sp)
c002fd58:	0077f713          	andi	a4,a5,7
c002fd5c:	04070263          	beqz	a4,c002fda0 <__multf3+0xef4>
c002fd60:	00f7f713          	andi	a4,a5,15
c002fd64:	03270e63          	beq	a4,s2,c002fda0 <__multf3+0xef4>
c002fd68:	05412703          	lw	a4,84(sp)
c002fd6c:	00478793          	addi	a5,a5,4
c002fd70:	04f12823          	sw	a5,80(sp)
c002fd74:	0047b793          	sltiu	a5,a5,4
c002fd78:	00e78733          	add	a4,a5,a4
c002fd7c:	00f737b3          	sltu	a5,a4,a5
c002fd80:	04e12a23          	sw	a4,84(sp)
c002fd84:	05812703          	lw	a4,88(sp)
c002fd88:	00e78733          	add	a4,a5,a4
c002fd8c:	04e12c23          	sw	a4,88(sp)
c002fd90:	00f73733          	sltu	a4,a4,a5
c002fd94:	05c12783          	lw	a5,92(sp)
c002fd98:	00f70733          	add	a4,a4,a5
c002fd9c:	04e12e23          	sw	a4,92(sp)
c002fda0:	05c12703          	lw	a4,92(sp)
c002fda4:	000807b7          	lui	a5,0x80
c002fda8:	00e7f7b3          	and	a5,a5,a4
c002fdac:	04078263          	beqz	a5,c002fdf0 <__multf3+0xf44>
c002fdb0:	04012e23          	sw	zero,92(sp)
c002fdb4:	04012c23          	sw	zero,88(sp)
c002fdb8:	04012a23          	sw	zero,84(sp)
c002fdbc:	04012823          	sw	zero,80(sp)
c002fdc0:	00100793          	li	a5,1
c002fdc4:	d71ff06f          	j	c002fb34 <__multf3+0xc88>
c002fdc8:	00072603          	lw	a2,0(a4)
c002fdcc:	00472303          	lw	t1,4(a4)
c002fdd0:	01170e33          	add	t3,a4,a7
c002fdd4:	00f65633          	srl	a2,a2,a5
c002fdd8:	00b31333          	sll	t1,t1,a1
c002fddc:	00666633          	or	a2,a2,t1
c002fde0:	00ce2023          	sw	a2,0(t3)
c002fde4:	00180813          	addi	a6,a6,1
c002fde8:	00470713          	addi	a4,a4,4
c002fdec:	f1dff06f          	j	c002fd08 <__multf3+0xe5c>
c002fdf0:	00c48693          	addi	a3,s1,12
c002fdf4:	0004a783          	lw	a5,0(s1)
c002fdf8:	0044a703          	lw	a4,4(s1)
c002fdfc:	00448493          	addi	s1,s1,4
c002fe00:	0037d793          	srli	a5,a5,0x3
c002fe04:	01d71713          	slli	a4,a4,0x1d
c002fe08:	00e7e7b3          	or	a5,a5,a4
c002fe0c:	fef4ae23          	sw	a5,-4(s1)
c002fe10:	fed492e3          	bne	s1,a3,c002fdf4 <__multf3+0xf48>
c002fe14:	05c12783          	lw	a5,92(sp)
c002fe18:	0037d793          	srli	a5,a5,0x3
c002fe1c:	04f12e23          	sw	a5,92(sp)
c002fe20:	00000793          	li	a5,0
c002fe24:	d11ff06f          	j	c002fb34 <__multf3+0xc88>
c002fe28:	05412783          	lw	a5,84(sp)
c002fe2c:	05012703          	lw	a4,80(sp)
c002fe30:	00f76733          	or	a4,a4,a5
c002fe34:	05812783          	lw	a5,88(sp)
c002fe38:	00f76733          	or	a4,a4,a5
c002fe3c:	05c12783          	lw	a5,92(sp)
c002fe40:	00f76733          	or	a4,a4,a5
c002fe44:	00000793          	li	a5,0
c002fe48:	ce0706e3          	beqz	a4,c002fb34 <__multf3+0xc88>
c002fe4c:	04012e23          	sw	zero,92(sp)
c002fe50:	04012c23          	sw	zero,88(sp)
c002fe54:	04012a23          	sw	zero,84(sp)
c002fe58:	04012823          	sw	zero,80(sp)
c002fe5c:	cd9ff06f          	j	c002fb34 <__multf3+0xc88>
c002fe60:	000087b7          	lui	a5,0x8
c002fe64:	04012e23          	sw	zero,92(sp)
c002fe68:	04012c23          	sw	zero,88(sp)
c002fe6c:	04012a23          	sw	zero,84(sp)
c002fe70:	04012823          	sw	zero,80(sp)
c002fe74:	fff78793          	addi	a5,a5,-1 # 7fff <_STACK_SIZE+0x6fff>
c002fe78:	cbdff06f          	j	c002fb34 <__multf3+0xc88>
c002fe7c:	000087b7          	lui	a5,0x8
c002fe80:	04f12e23          	sw	a5,92(sp)
c002fe84:	04012c23          	sw	zero,88(sp)
c002fe88:	04012a23          	sw	zero,84(sp)
c002fe8c:	04012823          	sw	zero,80(sp)
c002fe90:	fff78793          	addi	a5,a5,-1 # 7fff <_STACK_SIZE+0x6fff>
c002fe94:	00012823          	sw	zero,16(sp)
c002fe98:	c9dff06f          	j	c002fb34 <__multf3+0xc88>

c002fe9c <__subtf3>:
c002fe9c:	f9010113          	addi	sp,sp,-112
c002fea0:	0085a783          	lw	a5,8(a1)
c002fea4:	05512a23          	sw	s5,84(sp)
c002fea8:	00c5aa83          	lw	s5,12(a1)
c002feac:	0005a683          	lw	a3,0(a1)
c002feb0:	0045a703          	lw	a4,4(a1)
c002feb4:	05612823          	sw	s6,80(sp)
c002feb8:	05712623          	sw	s7,76(sp)
c002febc:	00050b13          	mv	s6,a0
c002fec0:	02f12c23          	sw	a5,56(sp)
c002fec4:	00f12c23          	sw	a5,24(sp)
c002fec8:	00062803          	lw	a6,0(a2)
c002fecc:	010a9793          	slli	a5,s5,0x10
c002fed0:	00462503          	lw	a0,4(a2)
c002fed4:	00862583          	lw	a1,8(a2)
c002fed8:	00c62b83          	lw	s7,12(a2)
c002fedc:	06912223          	sw	s1,100(sp)
c002fee0:	0107d793          	srli	a5,a5,0x10
c002fee4:	001a9493          	slli	s1,s5,0x1
c002fee8:	02d12823          	sw	a3,48(sp)
c002feec:	03512e23          	sw	s5,60(sp)
c002fef0:	00d12823          	sw	a3,16(sp)
c002fef4:	06112623          	sw	ra,108(sp)
c002fef8:	06812423          	sw	s0,104(sp)
c002fefc:	07212023          	sw	s2,96(sp)
c002ff00:	05312e23          	sw	s3,92(sp)
c002ff04:	05412c23          	sw	s4,88(sp)
c002ff08:	05812423          	sw	s8,72(sp)
c002ff0c:	05912223          	sw	s9,68(sp)
c002ff10:	02e12a23          	sw	a4,52(sp)
c002ff14:	00e12a23          	sw	a4,20(sp)
c002ff18:	00f12e23          	sw	a5,28(sp)
c002ff1c:	0114d493          	srli	s1,s1,0x11
c002ff20:	01fada93          	srli	s5,s5,0x1f
c002ff24:	01010893          	addi	a7,sp,16
c002ff28:	01c10693          	addi	a3,sp,28
c002ff2c:	0006a783          	lw	a5,0(a3)
c002ff30:	ffc6a703          	lw	a4,-4(a3)
c002ff34:	ffc68693          	addi	a3,a3,-4
c002ff38:	00379793          	slli	a5,a5,0x3
c002ff3c:	01d75713          	srli	a4,a4,0x1d
c002ff40:	00e7e7b3          	or	a5,a5,a4
c002ff44:	00f6a223          	sw	a5,4(a3)
c002ff48:	fed892e3          	bne	a7,a3,c002ff2c <__subtf3+0x90>
c002ff4c:	01012903          	lw	s2,16(sp)
c002ff50:	010b9793          	slli	a5,s7,0x10
c002ff54:	001b9c13          	slli	s8,s7,0x1
c002ff58:	00391913          	slli	s2,s2,0x3
c002ff5c:	0107d793          	srli	a5,a5,0x10
c002ff60:	02a12a23          	sw	a0,52(sp)
c002ff64:	02b12c23          	sw	a1,56(sp)
c002ff68:	03712e23          	sw	s7,60(sp)
c002ff6c:	02a12223          	sw	a0,36(sp)
c002ff70:	02b12423          	sw	a1,40(sp)
c002ff74:	01212823          	sw	s2,16(sp)
c002ff78:	03012823          	sw	a6,48(sp)
c002ff7c:	03012023          	sw	a6,32(sp)
c002ff80:	02f12623          	sw	a5,44(sp)
c002ff84:	011c5c13          	srli	s8,s8,0x11
c002ff88:	01fbdb93          	srli	s7,s7,0x1f
c002ff8c:	02010513          	addi	a0,sp,32
c002ff90:	02c10593          	addi	a1,sp,44
c002ff94:	0005a783          	lw	a5,0(a1)
c002ff98:	ffc5a703          	lw	a4,-4(a1)
c002ff9c:	ffc58593          	addi	a1,a1,-4
c002ffa0:	00379793          	slli	a5,a5,0x3
c002ffa4:	01d75713          	srli	a4,a4,0x1d
c002ffa8:	00e7e7b3          	or	a5,a5,a4
c002ffac:	00f5a223          	sw	a5,4(a1)
c002ffb0:	feb512e3          	bne	a0,a1,c002ff94 <__subtf3+0xf8>
c002ffb4:	02012403          	lw	s0,32(sp)
c002ffb8:	000087b7          	lui	a5,0x8
c002ffbc:	fff78793          	addi	a5,a5,-1 # 7fff <_STACK_SIZE+0x6fff>
c002ffc0:	00341413          	slli	s0,s0,0x3
c002ffc4:	02812023          	sw	s0,32(sp)
c002ffc8:	02fc1063          	bne	s8,a5,c002ffe8 <__subtf3+0x14c>
c002ffcc:	02812703          	lw	a4,40(sp)
c002ffd0:	02412783          	lw	a5,36(sp)
c002ffd4:	00e7e7b3          	or	a5,a5,a4
c002ffd8:	02c12703          	lw	a4,44(sp)
c002ffdc:	00e7e7b3          	or	a5,a5,a4
c002ffe0:	0087e7b3          	or	a5,a5,s0
c002ffe4:	00079463          	bnez	a5,c002ffec <__subtf3+0x150>
c002ffe8:	001bcb93          	xori	s7,s7,1
c002ffec:	41848833          	sub	a6,s1,s8
c002fff0:	115b96e3          	bne	s7,s5,c00308fc <__subtf3+0xa60>
c002fff4:	47005063          	blez	a6,c0030454 <__subtf3+0x5b8>
c002fff8:	01412b83          	lw	s7,20(sp)
c002fffc:	01812a03          	lw	s4,24(sp)
c0030000:	01c12983          	lw	s3,28(sp)
c0030004:	0a0c1c63          	bnez	s8,c00300bc <__subtf3+0x220>
c0030008:	02412603          	lw	a2,36(sp)
c003000c:	02812703          	lw	a4,40(sp)
c0030010:	02c12783          	lw	a5,44(sp)
c0030014:	00e666b3          	or	a3,a2,a4
c0030018:	00f6e6b3          	or	a3,a3,a5
c003001c:	0086e6b3          	or	a3,a3,s0
c0030020:	00069e63          	bnez	a3,c003003c <__subtf3+0x1a0>
c0030024:	03212823          	sw	s2,48(sp)
c0030028:	03712a23          	sw	s7,52(sp)
c003002c:	03412c23          	sw	s4,56(sp)
c0030030:	03312e23          	sw	s3,60(sp)
c0030034:	00080493          	mv	s1,a6
c0030038:	0a00006f          	j	c00300d8 <__subtf3+0x23c>
c003003c:	fff80693          	addi	a3,a6,-1
c0030040:	04069a63          	bnez	a3,c0030094 <__subtf3+0x1f8>
c0030044:	00890433          	add	s0,s2,s0
c0030048:	01243933          	sltu	s2,s0,s2
c003004c:	01760633          	add	a2,a2,s7
c0030050:	02812823          	sw	s0,48(sp)
c0030054:	01260433          	add	s0,a2,s2
c0030058:	01243933          	sltu	s2,s0,s2
c003005c:	01763633          	sltu	a2,a2,s7
c0030060:	01266633          	or	a2,a2,s2
c0030064:	01470733          	add	a4,a4,s4
c0030068:	00c706b3          	add	a3,a4,a2
c003006c:	00c6b633          	sltu	a2,a3,a2
c0030070:	01473733          	sltu	a4,a4,s4
c0030074:	00c76733          	or	a4,a4,a2
c0030078:	013787b3          	add	a5,a5,s3
c003007c:	00f70733          	add	a4,a4,a5
c0030080:	02812a23          	sw	s0,52(sp)
c0030084:	02d12c23          	sw	a3,56(sp)
c0030088:	02e12e23          	sw	a4,60(sp)
c003008c:	00100493          	li	s1,1
c0030090:	30c0006f          	j	c003039c <__subtf3+0x500>
c0030094:	000087b7          	lui	a5,0x8
c0030098:	fff78793          	addi	a5,a5,-1 # 7fff <_STACK_SIZE+0x6fff>
c003009c:	f8f804e3          	beq	a6,a5,c0030024 <__subtf3+0x188>
c00300a0:	07400793          	li	a5,116
c00300a4:	1ad7dc63          	bge	a5,a3,c003025c <__subtf3+0x3c0>
c00300a8:	02012623          	sw	zero,44(sp)
c00300ac:	02012423          	sw	zero,40(sp)
c00300b0:	02012223          	sw	zero,36(sp)
c00300b4:	00100793          	li	a5,1
c00300b8:	2880006f          	j	c0030340 <__subtf3+0x4a4>
c00300bc:	000087b7          	lui	a5,0x8
c00300c0:	fff78793          	addi	a5,a5,-1 # 7fff <_STACK_SIZE+0x6fff>
c00300c4:	16f49e63          	bne	s1,a5,c0030240 <__subtf3+0x3a4>
c00300c8:	03212823          	sw	s2,48(sp)
c00300cc:	03712a23          	sw	s7,52(sp)
c00300d0:	03412c23          	sw	s4,56(sp)
c00300d4:	03312e23          	sw	s3,60(sp)
c00300d8:	03012783          	lw	a5,48(sp)
c00300dc:	0077f713          	andi	a4,a5,7
c00300e0:	04070463          	beqz	a4,c0030128 <__subtf3+0x28c>
c00300e4:	00f7f713          	andi	a4,a5,15
c00300e8:	00400693          	li	a3,4
c00300ec:	02d70e63          	beq	a4,a3,c0030128 <__subtf3+0x28c>
c00300f0:	03412703          	lw	a4,52(sp)
c00300f4:	00478793          	addi	a5,a5,4
c00300f8:	02f12823          	sw	a5,48(sp)
c00300fc:	0047b793          	sltiu	a5,a5,4
c0030100:	00e78733          	add	a4,a5,a4
c0030104:	00f737b3          	sltu	a5,a4,a5
c0030108:	02e12a23          	sw	a4,52(sp)
c003010c:	03812703          	lw	a4,56(sp)
c0030110:	00e78733          	add	a4,a5,a4
c0030114:	02e12c23          	sw	a4,56(sp)
c0030118:	00f73733          	sltu	a4,a4,a5
c003011c:	03c12783          	lw	a5,60(sp)
c0030120:	00f70733          	add	a4,a4,a5
c0030124:	02e12e23          	sw	a4,60(sp)
c0030128:	03c12783          	lw	a5,60(sp)
c003012c:	00080737          	lui	a4,0x80
c0030130:	00e7f733          	and	a4,a5,a4
c0030134:	02070463          	beqz	a4,c003015c <__subtf3+0x2c0>
c0030138:	00008737          	lui	a4,0x8
c003013c:	00148493          	addi	s1,s1,1
c0030140:	fff70713          	addi	a4,a4,-1 # 7fff <_STACK_SIZE+0x6fff>
c0030144:	00e49463          	bne	s1,a4,c003014c <__subtf3+0x2b0>
c0030148:	2680106f          	j	c00313b0 <__subtf3+0x1514>
c003014c:	fff80737          	lui	a4,0xfff80
c0030150:	fff70713          	addi	a4,a4,-1 # fff7ffff <_end+0x37efb77f>
c0030154:	00e7f7b3          	and	a5,a5,a4
c0030158:	02f12e23          	sw	a5,60(sp)
c003015c:	03010793          	addi	a5,sp,48
c0030160:	03c10613          	addi	a2,sp,60
c0030164:	0007a703          	lw	a4,0(a5)
c0030168:	0047a683          	lw	a3,4(a5)
c003016c:	00478793          	addi	a5,a5,4
c0030170:	00375713          	srli	a4,a4,0x3
c0030174:	01d69693          	slli	a3,a3,0x1d
c0030178:	00d76733          	or	a4,a4,a3
c003017c:	fee7ae23          	sw	a4,-4(a5)
c0030180:	fef612e3          	bne	a2,a5,c0030164 <__subtf3+0x2c8>
c0030184:	03c12783          	lw	a5,60(sp)
c0030188:	000086b7          	lui	a3,0x8
c003018c:	0037d713          	srli	a4,a5,0x3
c0030190:	02e12e23          	sw	a4,60(sp)
c0030194:	fff68793          	addi	a5,a3,-1 # 7fff <_STACK_SIZE+0x6fff>
c0030198:	02f49a63          	bne	s1,a5,c00301cc <__subtf3+0x330>
c003019c:	03412603          	lw	a2,52(sp)
c00301a0:	03012783          	lw	a5,48(sp)
c00301a4:	00c7e7b3          	or	a5,a5,a2
c00301a8:	03812603          	lw	a2,56(sp)
c00301ac:	00c7e7b3          	or	a5,a5,a2
c00301b0:	00e7e7b3          	or	a5,a5,a4
c00301b4:	00078c63          	beqz	a5,c00301cc <__subtf3+0x330>
c00301b8:	02d12e23          	sw	a3,60(sp)
c00301bc:	02012c23          	sw	zero,56(sp)
c00301c0:	02012a23          	sw	zero,52(sp)
c00301c4:	02012823          	sw	zero,48(sp)
c00301c8:	00000a93          	li	s5,0
c00301cc:	03c12783          	lw	a5,60(sp)
c00301d0:	01149493          	slli	s1,s1,0x11
c00301d4:	0114d493          	srli	s1,s1,0x11
c00301d8:	00f11623          	sh	a5,12(sp)
c00301dc:	03012783          	lw	a5,48(sp)
c00301e0:	00fa9a93          	slli	s5,s5,0xf
c00301e4:	009aeab3          	or	s5,s5,s1
c00301e8:	00fb2023          	sw	a5,0(s6)
c00301ec:	03412783          	lw	a5,52(sp)
c00301f0:	01511723          	sh	s5,14(sp)
c00301f4:	06c12083          	lw	ra,108(sp)
c00301f8:	00fb2223          	sw	a5,4(s6)
c00301fc:	03812783          	lw	a5,56(sp)
c0030200:	06812403          	lw	s0,104(sp)
c0030204:	06412483          	lw	s1,100(sp)
c0030208:	00fb2423          	sw	a5,8(s6)
c003020c:	00c12783          	lw	a5,12(sp)
c0030210:	06012903          	lw	s2,96(sp)
c0030214:	05c12983          	lw	s3,92(sp)
c0030218:	00fb2623          	sw	a5,12(s6)
c003021c:	05812a03          	lw	s4,88(sp)
c0030220:	05412a83          	lw	s5,84(sp)
c0030224:	04c12b83          	lw	s7,76(sp)
c0030228:	04812c03          	lw	s8,72(sp)
c003022c:	04412c83          	lw	s9,68(sp)
c0030230:	000b0513          	mv	a0,s6
c0030234:	05012b03          	lw	s6,80(sp)
c0030238:	07010113          	addi	sp,sp,112
c003023c:	00008067          	ret
c0030240:	02c12783          	lw	a5,44(sp)
c0030244:	00080737          	lui	a4,0x80
c0030248:	00e7e7b3          	or	a5,a5,a4
c003024c:	02f12623          	sw	a5,44(sp)
c0030250:	07400793          	li	a5,116
c0030254:	e507cae3          	blt	a5,a6,c00300a8 <__subtf3+0x20c>
c0030258:	00080693          	mv	a3,a6
c003025c:	4056d793          	srai	a5,a3,0x5
c0030260:	00058613          	mv	a2,a1
c0030264:	00000413          	li	s0,0
c0030268:	00000713          	li	a4,0
c003026c:	04f71063          	bne	a4,a5,c00302ac <__subtf3+0x410>
c0030270:	01f6f693          	andi	a3,a3,31
c0030274:	00279613          	slli	a2,a5,0x2
c0030278:	04069463          	bnez	a3,c00302c0 <__subtf3+0x424>
c003027c:	00300693          	li	a3,3
c0030280:	00000713          	li	a4,0
c0030284:	40f686b3          	sub	a3,a3,a5
c0030288:	00c58833          	add	a6,a1,a2
c003028c:	00082803          	lw	a6,0(a6)
c0030290:	00170713          	addi	a4,a4,1 # 80001 <_HEAP_SIZE+0x40001>
c0030294:	00458593          	addi	a1,a1,4
c0030298:	ff05ae23          	sw	a6,-4(a1)
c003029c:	fee6d6e3          	bge	a3,a4,c0030288 <__subtf3+0x3ec>
c00302a0:	00400713          	li	a4,4
c00302a4:	40f707b3          	sub	a5,a4,a5
c00302a8:	0700006f          	j	c0030318 <__subtf3+0x47c>
c00302ac:	00062803          	lw	a6,0(a2)
c00302b0:	00170713          	addi	a4,a4,1
c00302b4:	00460613          	addi	a2,a2,4
c00302b8:	01046433          	or	s0,s0,a6
c00302bc:	fb1ff06f          	j	c003026c <__subtf3+0x3d0>
c00302c0:	ffc00313          	li	t1,-4
c00302c4:	02678333          	mul	t1,a5,t1
c00302c8:	04010713          	addi	a4,sp,64
c00302cc:	00c70733          	add	a4,a4,a2
c00302d0:	fe072703          	lw	a4,-32(a4)
c00302d4:	02000813          	li	a6,32
c00302d8:	40d80833          	sub	a6,a6,a3
c00302dc:	01071733          	sll	a4,a4,a6
c00302e0:	00e46433          	or	s0,s0,a4
c00302e4:	00300713          	li	a4,3
c00302e8:	00c50633          	add	a2,a0,a2
c00302ec:	00000893          	li	a7,0
c00302f0:	40f70733          	sub	a4,a4,a5
c00302f4:	12e8cc63          	blt	a7,a4,c003042c <__subtf3+0x590>
c00302f8:	00400613          	li	a2,4
c00302fc:	40f607b3          	sub	a5,a2,a5
c0030300:	00271713          	slli	a4,a4,0x2
c0030304:	04010613          	addi	a2,sp,64
c0030308:	00e60733          	add	a4,a2,a4
c003030c:	02c12603          	lw	a2,44(sp)
c0030310:	00d656b3          	srl	a3,a2,a3
c0030314:	fed72023          	sw	a3,-32(a4)
c0030318:	00400613          	li	a2,4
c003031c:	40f60633          	sub	a2,a2,a5
c0030320:	00279793          	slli	a5,a5,0x2
c0030324:	00f50533          	add	a0,a0,a5
c0030328:	00261613          	slli	a2,a2,0x2
c003032c:	00000593          	li	a1,0
c0030330:	959ed0ef          	jal	ra,c001dc88 <memset>
c0030334:	02012703          	lw	a4,32(sp)
c0030338:	008037b3          	snez	a5,s0
c003033c:	00f767b3          	or	a5,a4,a5
c0030340:	02f12023          	sw	a5,32(sp)
c0030344:	02012603          	lw	a2,32(sp)
c0030348:	02812683          	lw	a3,40(sp)
c003034c:	00c90633          	add	a2,s2,a2
c0030350:	01263933          	sltu	s2,a2,s2
c0030354:	02c12823          	sw	a2,48(sp)
c0030358:	02412603          	lw	a2,36(sp)
c003035c:	00cb8633          	add	a2,s7,a2
c0030360:	012607b3          	add	a5,a2,s2
c0030364:	0127b933          	sltu	s2,a5,s2
c0030368:	01763633          	sltu	a2,a2,s7
c003036c:	01266633          	or	a2,a2,s2
c0030370:	02f12a23          	sw	a5,52(sp)
c0030374:	00da07b3          	add	a5,s4,a3
c0030378:	00c78733          	add	a4,a5,a2
c003037c:	02e12c23          	sw	a4,56(sp)
c0030380:	0147b7b3          	sltu	a5,a5,s4
c0030384:	00c73733          	sltu	a4,a4,a2
c0030388:	00e7e7b3          	or	a5,a5,a4
c003038c:	02c12703          	lw	a4,44(sp)
c0030390:	00e989b3          	add	s3,s3,a4
c0030394:	013787b3          	add	a5,a5,s3
c0030398:	02f12e23          	sw	a5,60(sp)
c003039c:	03c12783          	lw	a5,60(sp)
c00303a0:	00080737          	lui	a4,0x80
c00303a4:	00e7f733          	and	a4,a5,a4
c00303a8:	d20708e3          	beqz	a4,c00300d8 <__subtf3+0x23c>
c00303ac:	fff80737          	lui	a4,0xfff80
c00303b0:	fff70713          	addi	a4,a4,-1 # fff7ffff <_end+0x37efb77f>
c00303b4:	00e7f7b3          	and	a5,a5,a4
c00303b8:	02f12e23          	sw	a5,60(sp)
c00303bc:	03012783          	lw	a5,48(sp)
c00303c0:	00148493          	addi	s1,s1,1
c00303c4:	03c10593          	addi	a1,sp,60
c00303c8:	01f79713          	slli	a4,a5,0x1f
c00303cc:	03010793          	addi	a5,sp,48
c00303d0:	0007a683          	lw	a3,0(a5)
c00303d4:	0047a603          	lw	a2,4(a5)
c00303d8:	00478793          	addi	a5,a5,4
c00303dc:	0016d693          	srli	a3,a3,0x1
c00303e0:	01f61613          	slli	a2,a2,0x1f
c00303e4:	00c6e6b3          	or	a3,a3,a2
c00303e8:	fed7ae23          	sw	a3,-4(a5)
c00303ec:	fef592e3          	bne	a1,a5,c00303d0 <__subtf3+0x534>
c00303f0:	03c12783          	lw	a5,60(sp)
c00303f4:	0017d793          	srli	a5,a5,0x1
c00303f8:	02f12e23          	sw	a5,60(sp)
c00303fc:	00e037b3          	snez	a5,a4
c0030400:	03012703          	lw	a4,48(sp)
c0030404:	00f767b3          	or	a5,a4,a5
c0030408:	02f12823          	sw	a5,48(sp)
c003040c:	000087b7          	lui	a5,0x8
c0030410:	fff78793          	addi	a5,a5,-1 # 7fff <_STACK_SIZE+0x6fff>
c0030414:	ccf492e3          	bne	s1,a5,c00300d8 <__subtf3+0x23c>
c0030418:	02012e23          	sw	zero,60(sp)
c003041c:	02012c23          	sw	zero,56(sp)
c0030420:	02012a23          	sw	zero,52(sp)
c0030424:	02012823          	sw	zero,48(sp)
c0030428:	cb1ff06f          	j	c00300d8 <__subtf3+0x23c>
c003042c:	00062583          	lw	a1,0(a2)
c0030430:	00462e03          	lw	t3,4(a2)
c0030434:	00660eb3          	add	t4,a2,t1
c0030438:	00d5d5b3          	srl	a1,a1,a3
c003043c:	010e1e33          	sll	t3,t3,a6
c0030440:	01c5e5b3          	or	a1,a1,t3
c0030444:	00bea023          	sw	a1,0(t4)
c0030448:	00188893          	addi	a7,a7,1
c003044c:	00460613          	addi	a2,a2,4
c0030450:	ea5ff06f          	j	c00302f4 <__subtf3+0x458>
c0030454:	02412983          	lw	s3,36(sp)
c0030458:	02812a03          	lw	s4,40(sp)
c003045c:	02c12b83          	lw	s7,44(sp)
c0030460:	28080663          	beqz	a6,c00306ec <__subtf3+0x850>
c0030464:	409c05b3          	sub	a1,s8,s1
c0030468:	0a049a63          	bnez	s1,c003051c <__subtf3+0x680>
c003046c:	01412703          	lw	a4,20(sp)
c0030470:	01812783          	lw	a5,24(sp)
c0030474:	01c12503          	lw	a0,28(sp)
c0030478:	00f76633          	or	a2,a4,a5
c003047c:	00a66633          	or	a2,a2,a0
c0030480:	01266633          	or	a2,a2,s2
c0030484:	00061e63          	bnez	a2,c00304a0 <__subtf3+0x604>
c0030488:	02812823          	sw	s0,48(sp)
c003048c:	03312a23          	sw	s3,52(sp)
c0030490:	03412c23          	sw	s4,56(sp)
c0030494:	03712e23          	sw	s7,60(sp)
c0030498:	00058493          	mv	s1,a1
c003049c:	c3dff06f          	j	c00300d8 <__subtf3+0x23c>
c00304a0:	fff58613          	addi	a2,a1,-1
c00304a4:	04061863          	bnez	a2,c00304f4 <__subtf3+0x658>
c00304a8:	00890933          	add	s2,s2,s0
c00304ac:	01370733          	add	a4,a4,s3
c00304b0:	00893433          	sltu	s0,s2,s0
c00304b4:	03212823          	sw	s2,48(sp)
c00304b8:	00870933          	add	s2,a4,s0
c00304bc:	00893433          	sltu	s0,s2,s0
c00304c0:	01373733          	sltu	a4,a4,s3
c00304c4:	008769b3          	or	s3,a4,s0
c00304c8:	014787b3          	add	a5,a5,s4
c00304cc:	01378733          	add	a4,a5,s3
c00304d0:	013739b3          	sltu	s3,a4,s3
c00304d4:	0147b7b3          	sltu	a5,a5,s4
c00304d8:	0137e7b3          	or	a5,a5,s3
c00304dc:	01750bb3          	add	s7,a0,s7
c00304e0:	01778bb3          	add	s7,a5,s7
c00304e4:	03212a23          	sw	s2,52(sp)
c00304e8:	02e12c23          	sw	a4,56(sp)
c00304ec:	03712e23          	sw	s7,60(sp)
c00304f0:	b9dff06f          	j	c003008c <__subtf3+0x1f0>
c00304f4:	000087b7          	lui	a5,0x8
c00304f8:	fff78793          	addi	a5,a5,-1 # 7fff <_STACK_SIZE+0x6fff>
c00304fc:	f8f586e3          	beq	a1,a5,c0030488 <__subtf3+0x5ec>
c0030500:	07400793          	li	a5,116
c0030504:	04c7dc63          	bge	a5,a2,c003055c <__subtf3+0x6c0>
c0030508:	00012e23          	sw	zero,28(sp)
c003050c:	00012c23          	sw	zero,24(sp)
c0030510:	00012a23          	sw	zero,20(sp)
c0030514:	00100793          	li	a5,1
c0030518:	1480006f          	j	c0030660 <__subtf3+0x7c4>
c003051c:	000087b7          	lui	a5,0x8
c0030520:	fff78793          	addi	a5,a5,-1 # 7fff <_STACK_SIZE+0x6fff>
c0030524:	00fc1e63          	bne	s8,a5,c0030540 <__subtf3+0x6a4>
c0030528:	02812823          	sw	s0,48(sp)
c003052c:	03312a23          	sw	s3,52(sp)
c0030530:	03412c23          	sw	s4,56(sp)
c0030534:	03712e23          	sw	s7,60(sp)
c0030538:	000c0493          	mv	s1,s8
c003053c:	b9dff06f          	j	c00300d8 <__subtf3+0x23c>
c0030540:	01c12783          	lw	a5,28(sp)
c0030544:	00080737          	lui	a4,0x80
c0030548:	00e7e7b3          	or	a5,a5,a4
c003054c:	00f12e23          	sw	a5,28(sp)
c0030550:	07400793          	li	a5,116
c0030554:	fab7cae3          	blt	a5,a1,c0030508 <__subtf3+0x66c>
c0030558:	00058613          	mv	a2,a1
c003055c:	02000793          	li	a5,32
c0030560:	02f647b3          	div	a5,a2,a5
c0030564:	00068593          	mv	a1,a3
c0030568:	00000493          	li	s1,0
c003056c:	00000713          	li	a4,0
c0030570:	04f74663          	blt	a4,a5,c00305bc <__subtf3+0x720>
c0030574:	00078593          	mv	a1,a5
c0030578:	0007d463          	bgez	a5,c0030580 <__subtf3+0x6e4>
c003057c:	00000593          	li	a1,0
c0030580:	01f67513          	andi	a0,a2,31
c0030584:	00279713          	slli	a4,a5,0x2
c0030588:	04051463          	bnez	a0,c00305d0 <__subtf3+0x734>
c003058c:	00300593          	li	a1,3
c0030590:	00000613          	li	a2,0
c0030594:	40f585b3          	sub	a1,a1,a5
c0030598:	00e68533          	add	a0,a3,a4
c003059c:	00052503          	lw	a0,0(a0) # 10000 <_STACK_SIZE+0xf000>
c00305a0:	00160613          	addi	a2,a2,1
c00305a4:	00468693          	addi	a3,a3,4
c00305a8:	fea6ae23          	sw	a0,-4(a3)
c00305ac:	fec5d6e3          	bge	a1,a2,c0030598 <__subtf3+0x6fc>
c00305b0:	00400513          	li	a0,4
c00305b4:	40f507b3          	sub	a5,a0,a5
c00305b8:	0780006f          	j	c0030630 <__subtf3+0x794>
c00305bc:	0005a503          	lw	a0,0(a1)
c00305c0:	00170713          	addi	a4,a4,1 # 80001 <_HEAP_SIZE+0x40001>
c00305c4:	00458593          	addi	a1,a1,4
c00305c8:	00a4e4b3          	or	s1,s1,a0
c00305cc:	fa5ff06f          	j	c0030570 <__subtf3+0x6d4>
c00305d0:	02000513          	li	a0,32
c00305d4:	02a66633          	rem	a2,a2,a0
c00305d8:	ffc00313          	li	t1,-4
c00305dc:	04010693          	addi	a3,sp,64
c00305e0:	00259593          	slli	a1,a1,0x2
c00305e4:	00b685b3          	add	a1,a3,a1
c00305e8:	fd05a683          	lw	a3,-48(a1)
c00305ec:	00000813          	li	a6,0
c00305f0:	02678333          	mul	t1,a5,t1
c00305f4:	40c50533          	sub	a0,a0,a2
c00305f8:	00a696b3          	sll	a3,a3,a0
c00305fc:	00d4e4b3          	or	s1,s1,a3
c0030600:	00e886b3          	add	a3,a7,a4
c0030604:	00300713          	li	a4,3
c0030608:	40f70733          	sub	a4,a4,a5
c003060c:	0ae84c63          	blt	a6,a4,c00306c4 <__subtf3+0x828>
c0030610:	04010693          	addi	a3,sp,64
c0030614:	00271713          	slli	a4,a4,0x2
c0030618:	00e68733          	add	a4,a3,a4
c003061c:	01c12683          	lw	a3,28(sp)
c0030620:	00400513          	li	a0,4
c0030624:	40f507b3          	sub	a5,a0,a5
c0030628:	00c6d633          	srl	a2,a3,a2
c003062c:	fcc72823          	sw	a2,-48(a4)
c0030630:	00400713          	li	a4,4
c0030634:	00000613          	li	a2,0
c0030638:	00f74663          	blt	a4,a5,c0030644 <__subtf3+0x7a8>
c003063c:	40f70733          	sub	a4,a4,a5
c0030640:	00271613          	slli	a2,a4,0x2
c0030644:	00279793          	slli	a5,a5,0x2
c0030648:	00f88533          	add	a0,a7,a5
c003064c:	00000593          	li	a1,0
c0030650:	e38ed0ef          	jal	ra,c001dc88 <memset>
c0030654:	01012703          	lw	a4,16(sp)
c0030658:	009037b3          	snez	a5,s1
c003065c:	00f767b3          	or	a5,a4,a5
c0030660:	00f12823          	sw	a5,16(sp)
c0030664:	01012783          	lw	a5,16(sp)
c0030668:	01412703          	lw	a4,20(sp)
c003066c:	000c0493          	mv	s1,s8
c0030670:	00f407b3          	add	a5,s0,a5
c0030674:	00e98733          	add	a4,s3,a4
c0030678:	0087b433          	sltu	s0,a5,s0
c003067c:	02f12823          	sw	a5,48(sp)
c0030680:	008707b3          	add	a5,a4,s0
c0030684:	0087b433          	sltu	s0,a5,s0
c0030688:	02f12a23          	sw	a5,52(sp)
c003068c:	01812783          	lw	a5,24(sp)
c0030690:	013739b3          	sltu	s3,a4,s3
c0030694:	0089e9b3          	or	s3,s3,s0
c0030698:	00fa07b3          	add	a5,s4,a5
c003069c:	01378733          	add	a4,a5,s3
c00306a0:	0147b7b3          	sltu	a5,a5,s4
c00306a4:	01c12a03          	lw	s4,28(sp)
c00306a8:	013739b3          	sltu	s3,a4,s3
c00306ac:	0137e7b3          	or	a5,a5,s3
c00306b0:	014b8bb3          	add	s7,s7,s4
c00306b4:	01778bb3          	add	s7,a5,s7
c00306b8:	02e12c23          	sw	a4,56(sp)
c00306bc:	03712e23          	sw	s7,60(sp)
c00306c0:	cddff06f          	j	c003039c <__subtf3+0x500>
c00306c4:	0006a583          	lw	a1,0(a3)
c00306c8:	0046ae03          	lw	t3,4(a3)
c00306cc:	00668eb3          	add	t4,a3,t1
c00306d0:	00c5d5b3          	srl	a1,a1,a2
c00306d4:	00ae1e33          	sll	t3,t3,a0
c00306d8:	01c5e5b3          	or	a1,a1,t3
c00306dc:	00bea023          	sw	a1,0(t4)
c00306e0:	00180813          	addi	a6,a6,1
c00306e4:	00468693          	addi	a3,a3,4
c00306e8:	f25ff06f          	j	c003060c <__subtf3+0x770>
c00306ec:	00008837          	lui	a6,0x8
c00306f0:	00148693          	addi	a3,s1,1
c00306f4:	ffe80893          	addi	a7,a6,-2 # 7ffe <_STACK_SIZE+0x6ffe>
c00306f8:	0116f8b3          	and	a7,a3,a7
c00306fc:	01412703          	lw	a4,20(sp)
c0030700:	01812503          	lw	a0,24(sp)
c0030704:	01c12583          	lw	a1,28(sp)
c0030708:	03010793          	addi	a5,sp,48
c003070c:	03c10613          	addi	a2,sp,60
c0030710:	14089863          	bnez	a7,c0030860 <__subtf3+0x9c4>
c0030714:	00a766b3          	or	a3,a4,a0
c0030718:	00b6e6b3          	or	a3,a3,a1
c003071c:	0126e6b3          	or	a3,a3,s2
c0030720:	0a049863          	bnez	s1,c00307d0 <__subtf3+0x934>
c0030724:	00069c63          	bnez	a3,c003073c <__subtf3+0x8a0>
c0030728:	02812823          	sw	s0,48(sp)
c003072c:	03312a23          	sw	s3,52(sp)
c0030730:	03412c23          	sw	s4,56(sp)
c0030734:	03712e23          	sw	s7,60(sp)
c0030738:	9a1ff06f          	j	c00300d8 <__subtf3+0x23c>
c003073c:	0149e7b3          	or	a5,s3,s4
c0030740:	0177e7b3          	or	a5,a5,s7
c0030744:	0087e7b3          	or	a5,a5,s0
c0030748:	00079c63          	bnez	a5,c0030760 <__subtf3+0x8c4>
c003074c:	03212823          	sw	s2,48(sp)
c0030750:	02e12a23          	sw	a4,52(sp)
c0030754:	02a12c23          	sw	a0,56(sp)
c0030758:	02b12e23          	sw	a1,60(sp)
c003075c:	97dff06f          	j	c00300d8 <__subtf3+0x23c>
c0030760:	00890433          	add	s0,s2,s0
c0030764:	01243933          	sltu	s2,s0,s2
c0030768:	013709b3          	add	s3,a4,s3
c003076c:	02812823          	sw	s0,48(sp)
c0030770:	01298433          	add	s0,s3,s2
c0030774:	01243933          	sltu	s2,s0,s2
c0030778:	00e9b9b3          	sltu	s3,s3,a4
c003077c:	0129e9b3          	or	s3,s3,s2
c0030780:	01450a33          	add	s4,a0,s4
c0030784:	013a07b3          	add	a5,s4,s3
c0030788:	0137b9b3          	sltu	s3,a5,s3
c003078c:	00aa3a33          	sltu	s4,s4,a0
c0030790:	013a6a33          	or	s4,s4,s3
c0030794:	01758bb3          	add	s7,a1,s7
c0030798:	02f12c23          	sw	a5,56(sp)
c003079c:	017a0a33          	add	s4,s4,s7
c00307a0:	000807b7          	lui	a5,0x80
c00307a4:	02812a23          	sw	s0,52(sp)
c00307a8:	00fa77b3          	and	a5,s4,a5
c00307ac:	00079663          	bnez	a5,c00307b8 <__subtf3+0x91c>
c00307b0:	03412e23          	sw	s4,60(sp)
c00307b4:	925ff06f          	j	c00300d8 <__subtf3+0x23c>
c00307b8:	fff807b7          	lui	a5,0xfff80
c00307bc:	fff78793          	addi	a5,a5,-1 # fff7ffff <_end+0x37efb77f>
c00307c0:	00fa7a33          	and	s4,s4,a5
c00307c4:	03412e23          	sw	s4,60(sp)
c00307c8:	00100493          	li	s1,1
c00307cc:	90dff06f          	j	c00300d8 <__subtf3+0x23c>
c00307d0:	00069e63          	bnez	a3,c00307ec <__subtf3+0x950>
c00307d4:	02812823          	sw	s0,48(sp)
c00307d8:	03312a23          	sw	s3,52(sp)
c00307dc:	03412c23          	sw	s4,56(sp)
c00307e0:	03712e23          	sw	s7,60(sp)
c00307e4:	fff80493          	addi	s1,a6,-1
c00307e8:	8f1ff06f          	j	c00300d8 <__subtf3+0x23c>
c00307ec:	0149ea33          	or	s4,s3,s4
c00307f0:	017a6bb3          	or	s7,s4,s7
c00307f4:	008be433          	or	s0,s7,s0
c00307f8:	00041c63          	bnez	s0,c0030810 <__subtf3+0x974>
c00307fc:	03212823          	sw	s2,48(sp)
c0030800:	02e12a23          	sw	a4,52(sp)
c0030804:	02a12c23          	sw	a0,56(sp)
c0030808:	02b12e23          	sw	a1,60(sp)
c003080c:	fd9ff06f          	j	c00307e4 <__subtf3+0x948>
c0030810:	03012e23          	sw	a6,60(sp)
c0030814:	02012c23          	sw	zero,56(sp)
c0030818:	02012a23          	sw	zero,52(sp)
c003081c:	02012823          	sw	zero,48(sp)
c0030820:	00060713          	mv	a4,a2
c0030824:	00072683          	lw	a3,0(a4)
c0030828:	ffc72603          	lw	a2,-4(a4)
c003082c:	ffc70713          	addi	a4,a4,-4
c0030830:	00369693          	slli	a3,a3,0x3
c0030834:	01d65613          	srli	a2,a2,0x1d
c0030838:	00c6e6b3          	or	a3,a3,a2
c003083c:	00d72223          	sw	a3,4(a4)
c0030840:	fee792e3          	bne	a5,a4,c0030824 <__subtf3+0x988>
c0030844:	03012783          	lw	a5,48(sp)
c0030848:	000084b7          	lui	s1,0x8
c003084c:	00000a93          	li	s5,0
c0030850:	00379793          	slli	a5,a5,0x3
c0030854:	02f12823          	sw	a5,48(sp)
c0030858:	fff48493          	addi	s1,s1,-1 # 7fff <_STACK_SIZE+0x6fff>
c003085c:	87dff06f          	j	c00300d8 <__subtf3+0x23c>
c0030860:	00890433          	add	s0,s2,s0
c0030864:	013709b3          	add	s3,a4,s3
c0030868:	01243933          	sltu	s2,s0,s2
c003086c:	02812823          	sw	s0,48(sp)
c0030870:	01298433          	add	s0,s3,s2
c0030874:	01243933          	sltu	s2,s0,s2
c0030878:	00e9b9b3          	sltu	s3,s3,a4
c003087c:	0129e933          	or	s2,s3,s2
c0030880:	01450733          	add	a4,a0,s4
c0030884:	01270833          	add	a6,a4,s2
c0030888:	00a73a33          	sltu	s4,a4,a0
c003088c:	01283733          	sltu	a4,a6,s2
c0030890:	00ea6733          	or	a4,s4,a4
c0030894:	01758bb3          	add	s7,a1,s7
c0030898:	01770bb3          	add	s7,a4,s7
c003089c:	02812a23          	sw	s0,52(sp)
c00308a0:	03012c23          	sw	a6,56(sp)
c00308a4:	03712e23          	sw	s7,60(sp)
c00308a8:	0007a703          	lw	a4,0(a5)
c00308ac:	0047a583          	lw	a1,4(a5)
c00308b0:	00478793          	addi	a5,a5,4
c00308b4:	00175713          	srli	a4,a4,0x1
c00308b8:	01f59593          	slli	a1,a1,0x1f
c00308bc:	00b76733          	or	a4,a4,a1
c00308c0:	fee7ae23          	sw	a4,-4(a5)
c00308c4:	fef612e3          	bne	a2,a5,c00308a8 <__subtf3+0xa0c>
c00308c8:	000087b7          	lui	a5,0x8
c00308cc:	fff78793          	addi	a5,a5,-1 # 7fff <_STACK_SIZE+0x6fff>
c00308d0:	00f68c63          	beq	a3,a5,c00308e8 <__subtf3+0xa4c>
c00308d4:	03c12783          	lw	a5,60(sp)
c00308d8:	0017d793          	srli	a5,a5,0x1
c00308dc:	02f12e23          	sw	a5,60(sp)
c00308e0:	00068493          	mv	s1,a3
c00308e4:	ff4ff06f          	j	c00300d8 <__subtf3+0x23c>
c00308e8:	02012e23          	sw	zero,60(sp)
c00308ec:	02012c23          	sw	zero,56(sp)
c00308f0:	02012a23          	sw	zero,52(sp)
c00308f4:	02012823          	sw	zero,48(sp)
c00308f8:	fe9ff06f          	j	c00308e0 <__subtf3+0xa44>
c00308fc:	2b005463          	blez	a6,c0030ba4 <__subtf3+0xd08>
c0030900:	01412983          	lw	s3,20(sp)
c0030904:	01812a03          	lw	s4,24(sp)
c0030908:	01c12b83          	lw	s7,28(sp)
c003090c:	0c0c1463          	bnez	s8,c00309d4 <__subtf3+0xb38>
c0030910:	02412883          	lw	a7,36(sp)
c0030914:	02812683          	lw	a3,40(sp)
c0030918:	02c12783          	lw	a5,44(sp)
c003091c:	00d8e733          	or	a4,a7,a3
c0030920:	00f76733          	or	a4,a4,a5
c0030924:	00876733          	or	a4,a4,s0
c0030928:	00071c63          	bnez	a4,c0030940 <__subtf3+0xaa4>
c003092c:	03212823          	sw	s2,48(sp)
c0030930:	03312a23          	sw	s3,52(sp)
c0030934:	03412c23          	sw	s4,56(sp)
c0030938:	03712e23          	sw	s7,60(sp)
c003093c:	ef8ff06f          	j	c0030034 <__subtf3+0x198>
c0030940:	fff80713          	addi	a4,a6,-1
c0030944:	06071463          	bnez	a4,c00309ac <__subtf3+0xb10>
c0030948:	40890433          	sub	s0,s2,s0
c003094c:	411985b3          	sub	a1,s3,a7
c0030950:	00893633          	sltu	a2,s2,s0
c0030954:	00b9b533          	sltu	a0,s3,a1
c0030958:	40c585b3          	sub	a1,a1,a2
c003095c:	00000613          	li	a2,0
c0030960:	00897663          	bgeu	s2,s0,c003096c <__subtf3+0xad0>
c0030964:	41388633          	sub	a2,a7,s3
c0030968:	00163613          	seqz	a2,a2
c003096c:	00a66633          	or	a2,a2,a0
c0030970:	40da0533          	sub	a0,s4,a3
c0030974:	00aa3833          	sltu	a6,s4,a0
c0030978:	40c50533          	sub	a0,a0,a2
c003097c:	00060663          	beqz	a2,c0030988 <__subtf3+0xaec>
c0030980:	41468733          	sub	a4,a3,s4
c0030984:	00173713          	seqz	a4,a4
c0030988:	40fb87b3          	sub	a5,s7,a5
c003098c:	01076733          	or	a4,a4,a6
c0030990:	40e787b3          	sub	a5,a5,a4
c0030994:	02f12e23          	sw	a5,60(sp)
c0030998:	02a12c23          	sw	a0,56(sp)
c003099c:	02b12a23          	sw	a1,52(sp)
c00309a0:	02812823          	sw	s0,48(sp)
c00309a4:	00100493          	li	s1,1
c00309a8:	1b40006f          	j	c0030b5c <__subtf3+0xcc0>
c00309ac:	000087b7          	lui	a5,0x8
c00309b0:	fff78793          	addi	a5,a5,-1 # 7fff <_STACK_SIZE+0x6fff>
c00309b4:	f6f80ce3          	beq	a6,a5,c003092c <__subtf3+0xa90>
c00309b8:	07400793          	li	a5,116
c00309bc:	04e7d463          	bge	a5,a4,c0030a04 <__subtf3+0xb68>
c00309c0:	02012623          	sw	zero,44(sp)
c00309c4:	02012423          	sw	zero,40(sp)
c00309c8:	02012223          	sw	zero,36(sp)
c00309cc:	00100793          	li	a5,1
c00309d0:	1180006f          	j	c0030ae8 <__subtf3+0xc4c>
c00309d4:	000087b7          	lui	a5,0x8
c00309d8:	fff78793          	addi	a5,a5,-1 # 7fff <_STACK_SIZE+0x6fff>
c00309dc:	00f49663          	bne	s1,a5,c00309e8 <__subtf3+0xb4c>
c00309e0:	03212823          	sw	s2,48(sp)
c00309e4:	d49ff06f          	j	c003072c <__subtf3+0x890>
c00309e8:	02c12783          	lw	a5,44(sp)
c00309ec:	00080737          	lui	a4,0x80
c00309f0:	00e7e7b3          	or	a5,a5,a4
c00309f4:	02f12623          	sw	a5,44(sp)
c00309f8:	07400793          	li	a5,116
c00309fc:	fd07c2e3          	blt	a5,a6,c00309c0 <__subtf3+0xb24>
c0030a00:	00080713          	mv	a4,a6
c0030a04:	40575793          	srai	a5,a4,0x5
c0030a08:	00058613          	mv	a2,a1
c0030a0c:	00000413          	li	s0,0
c0030a10:	00000693          	li	a3,0
c0030a14:	04f69063          	bne	a3,a5,c0030a54 <__subtf3+0xbb8>
c0030a18:	01f77613          	andi	a2,a4,31
c0030a1c:	00279713          	slli	a4,a5,0x2
c0030a20:	04061463          	bnez	a2,c0030a68 <__subtf3+0xbcc>
c0030a24:	00300613          	li	a2,3
c0030a28:	00000693          	li	a3,0
c0030a2c:	40f60633          	sub	a2,a2,a5
c0030a30:	00e58833          	add	a6,a1,a4
c0030a34:	00082803          	lw	a6,0(a6)
c0030a38:	00168693          	addi	a3,a3,1
c0030a3c:	00458593          	addi	a1,a1,4
c0030a40:	ff05ae23          	sw	a6,-4(a1)
c0030a44:	fed656e3          	bge	a2,a3,c0030a30 <__subtf3+0xb94>
c0030a48:	00400713          	li	a4,4
c0030a4c:	40f707b3          	sub	a5,a4,a5
c0030a50:	0700006f          	j	c0030ac0 <__subtf3+0xc24>
c0030a54:	00062803          	lw	a6,0(a2)
c0030a58:	00168693          	addi	a3,a3,1
c0030a5c:	00460613          	addi	a2,a2,4
c0030a60:	01046433          	or	s0,s0,a6
c0030a64:	fb1ff06f          	j	c0030a14 <__subtf3+0xb78>
c0030a68:	ffc00313          	li	t1,-4
c0030a6c:	02678333          	mul	t1,a5,t1
c0030a70:	04010693          	addi	a3,sp,64
c0030a74:	00e686b3          	add	a3,a3,a4
c0030a78:	fe06a683          	lw	a3,-32(a3)
c0030a7c:	02000813          	li	a6,32
c0030a80:	40c80833          	sub	a6,a6,a2
c0030a84:	010696b3          	sll	a3,a3,a6
c0030a88:	00d46433          	or	s0,s0,a3
c0030a8c:	00300693          	li	a3,3
c0030a90:	00e50733          	add	a4,a0,a4
c0030a94:	00000893          	li	a7,0
c0030a98:	40f686b3          	sub	a3,a3,a5
c0030a9c:	0ed8c063          	blt	a7,a3,c0030b7c <__subtf3+0xce0>
c0030aa0:	00400713          	li	a4,4
c0030aa4:	40f707b3          	sub	a5,a4,a5
c0030aa8:	00269693          	slli	a3,a3,0x2
c0030aac:	04010713          	addi	a4,sp,64
c0030ab0:	00d706b3          	add	a3,a4,a3
c0030ab4:	02c12703          	lw	a4,44(sp)
c0030ab8:	00c75733          	srl	a4,a4,a2
c0030abc:	fee6a023          	sw	a4,-32(a3)
c0030ac0:	00400613          	li	a2,4
c0030ac4:	40f60633          	sub	a2,a2,a5
c0030ac8:	00279793          	slli	a5,a5,0x2
c0030acc:	00f50533          	add	a0,a0,a5
c0030ad0:	00261613          	slli	a2,a2,0x2
c0030ad4:	00000593          	li	a1,0
c0030ad8:	9b0ed0ef          	jal	ra,c001dc88 <memset>
c0030adc:	02012703          	lw	a4,32(sp)
c0030ae0:	008037b3          	snez	a5,s0
c0030ae4:	00f767b3          	or	a5,a4,a5
c0030ae8:	02f12023          	sw	a5,32(sp)
c0030aec:	02012703          	lw	a4,32(sp)
c0030af0:	02412583          	lw	a1,36(sp)
c0030af4:	00000693          	li	a3,0
c0030af8:	40e90733          	sub	a4,s2,a4
c0030afc:	40b987b3          	sub	a5,s3,a1
c0030b00:	00e93633          	sltu	a2,s2,a4
c0030b04:	00f9b533          	sltu	a0,s3,a5
c0030b08:	40c78633          	sub	a2,a5,a2
c0030b0c:	00e97663          	bgeu	s2,a4,c0030b18 <__subtf3+0xc7c>
c0030b10:	413586b3          	sub	a3,a1,s3
c0030b14:	0016b693          	seqz	a3,a3
c0030b18:	02812803          	lw	a6,40(sp)
c0030b1c:	00a6e6b3          	or	a3,a3,a0
c0030b20:	00000513          	li	a0,0
c0030b24:	410a05b3          	sub	a1,s4,a6
c0030b28:	00ba38b3          	sltu	a7,s4,a1
c0030b2c:	40d585b3          	sub	a1,a1,a3
c0030b30:	00068663          	beqz	a3,c0030b3c <__subtf3+0xca0>
c0030b34:	41480833          	sub	a6,a6,s4
c0030b38:	00183513          	seqz	a0,a6
c0030b3c:	02c12783          	lw	a5,44(sp)
c0030b40:	01156533          	or	a0,a0,a7
c0030b44:	02b12c23          	sw	a1,56(sp)
c0030b48:	40fb87b3          	sub	a5,s7,a5
c0030b4c:	40a787b3          	sub	a5,a5,a0
c0030b50:	02f12e23          	sw	a5,60(sp)
c0030b54:	02c12a23          	sw	a2,52(sp)
c0030b58:	02e12823          	sw	a4,48(sp)
c0030b5c:	03c12783          	lw	a5,60(sp)
c0030b60:	00080737          	lui	a4,0x80
c0030b64:	00e7f6b3          	and	a3,a5,a4
c0030b68:	d6068863          	beqz	a3,c00300d8 <__subtf3+0x23c>
c0030b6c:	fff70713          	addi	a4,a4,-1 # 7ffff <_HEAP_SIZE+0x3ffff>
c0030b70:	00e7f7b3          	and	a5,a5,a4
c0030b74:	02f12e23          	sw	a5,60(sp)
c0030b78:	5bc0006f          	j	c0031134 <__subtf3+0x1298>
c0030b7c:	00072583          	lw	a1,0(a4)
c0030b80:	00472e03          	lw	t3,4(a4)
c0030b84:	00670eb3          	add	t4,a4,t1
c0030b88:	00c5d5b3          	srl	a1,a1,a2
c0030b8c:	010e1e33          	sll	t3,t3,a6
c0030b90:	01c5e5b3          	or	a1,a1,t3
c0030b94:	00bea023          	sw	a1,0(t4)
c0030b98:	00188893          	addi	a7,a7,1
c0030b9c:	00470713          	addi	a4,a4,4
c0030ba0:	efdff06f          	j	c0030a9c <__subtf3+0xc00>
c0030ba4:	02412983          	lw	s3,36(sp)
c0030ba8:	02812a03          	lw	s4,40(sp)
c0030bac:	02c12c83          	lw	s9,44(sp)
c0030bb0:	2c080463          	beqz	a6,c0030e78 <__subtf3+0xfdc>
c0030bb4:	409c05b3          	sub	a1,s8,s1
c0030bb8:	0c049263          	bnez	s1,c0030c7c <__subtf3+0xde0>
c0030bbc:	01412503          	lw	a0,20(sp)
c0030bc0:	01812703          	lw	a4,24(sp)
c0030bc4:	01c12603          	lw	a2,28(sp)
c0030bc8:	00e567b3          	or	a5,a0,a4
c0030bcc:	00c7e7b3          	or	a5,a5,a2
c0030bd0:	0127e7b3          	or	a5,a5,s2
c0030bd4:	02079063          	bnez	a5,c0030bf4 <__subtf3+0xd58>
c0030bd8:	02812823          	sw	s0,48(sp)
c0030bdc:	03312a23          	sw	s3,52(sp)
c0030be0:	03412c23          	sw	s4,56(sp)
c0030be4:	03912e23          	sw	s9,60(sp)
c0030be8:	00058493          	mv	s1,a1
c0030bec:	000b8a93          	mv	s5,s7
c0030bf0:	ce8ff06f          	j	c00300d8 <__subtf3+0x23c>
c0030bf4:	fff58793          	addi	a5,a1,-1
c0030bf8:	06079463          	bnez	a5,c0030c60 <__subtf3+0xdc4>
c0030bfc:	41240933          	sub	s2,s0,s2
c0030c00:	40a985b3          	sub	a1,s3,a0
c0030c04:	012436b3          	sltu	a3,s0,s2
c0030c08:	00b9b833          	sltu	a6,s3,a1
c0030c0c:	40d585b3          	sub	a1,a1,a3
c0030c10:	00000693          	li	a3,0
c0030c14:	01247663          	bgeu	s0,s2,c0030c20 <__subtf3+0xd84>
c0030c18:	413506b3          	sub	a3,a0,s3
c0030c1c:	0016b693          	seqz	a3,a3
c0030c20:	0106e6b3          	or	a3,a3,a6
c0030c24:	40ea0533          	sub	a0,s4,a4
c0030c28:	00aa3833          	sltu	a6,s4,a0
c0030c2c:	40d50533          	sub	a0,a0,a3
c0030c30:	00068663          	beqz	a3,c0030c3c <__subtf3+0xda0>
c0030c34:	414707b3          	sub	a5,a4,s4
c0030c38:	0017b793          	seqz	a5,a5
c0030c3c:	40cc8cb3          	sub	s9,s9,a2
c0030c40:	0107e7b3          	or	a5,a5,a6
c0030c44:	40fc8cb3          	sub	s9,s9,a5
c0030c48:	03912e23          	sw	s9,60(sp)
c0030c4c:	02a12c23          	sw	a0,56(sp)
c0030c50:	02b12a23          	sw	a1,52(sp)
c0030c54:	03212823          	sw	s2,48(sp)
c0030c58:	000b8a93          	mv	s5,s7
c0030c5c:	d49ff06f          	j	c00309a4 <__subtf3+0xb08>
c0030c60:	00008737          	lui	a4,0x8
c0030c64:	fff70713          	addi	a4,a4,-1 # 7fff <_STACK_SIZE+0x6fff>
c0030c68:	f6e588e3          	beq	a1,a4,c0030bd8 <__subtf3+0xd3c>
c0030c6c:	07400713          	li	a4,116
c0030c70:	1ef74a63          	blt	a4,a5,c0030e64 <__subtf3+0xfc8>
c0030c74:	00078593          	mv	a1,a5
c0030c78:	0400006f          	j	c0030cb8 <__subtf3+0xe1c>
c0030c7c:	000087b7          	lui	a5,0x8
c0030c80:	fff78793          	addi	a5,a5,-1 # 7fff <_STACK_SIZE+0x6fff>
c0030c84:	00fc1e63          	bne	s8,a5,c0030ca0 <__subtf3+0xe04>
c0030c88:	02812823          	sw	s0,48(sp)
c0030c8c:	03312a23          	sw	s3,52(sp)
c0030c90:	03412c23          	sw	s4,56(sp)
c0030c94:	03912e23          	sw	s9,60(sp)
c0030c98:	000c0493          	mv	s1,s8
c0030c9c:	f51ff06f          	j	c0030bec <__subtf3+0xd50>
c0030ca0:	01c12783          	lw	a5,28(sp)
c0030ca4:	00080737          	lui	a4,0x80
c0030ca8:	00e7e7b3          	or	a5,a5,a4
c0030cac:	00f12e23          	sw	a5,28(sp)
c0030cb0:	07400793          	li	a5,116
c0030cb4:	1ab7c863          	blt	a5,a1,c0030e64 <__subtf3+0xfc8>
c0030cb8:	02000713          	li	a4,32
c0030cbc:	02e5c733          	div	a4,a1,a4
c0030cc0:	00068613          	mv	a2,a3
c0030cc4:	00000493          	li	s1,0
c0030cc8:	00000793          	li	a5,0
c0030ccc:	04e7c663          	blt	a5,a4,c0030d18 <__subtf3+0xe7c>
c0030cd0:	00070613          	mv	a2,a4
c0030cd4:	00075463          	bgez	a4,c0030cdc <__subtf3+0xe40>
c0030cd8:	00000613          	li	a2,0
c0030cdc:	01f5f513          	andi	a0,a1,31
c0030ce0:	00271793          	slli	a5,a4,0x2
c0030ce4:	04051463          	bnez	a0,c0030d2c <__subtf3+0xe90>
c0030ce8:	00300593          	li	a1,3
c0030cec:	00000613          	li	a2,0
c0030cf0:	40e585b3          	sub	a1,a1,a4
c0030cf4:	00f68533          	add	a0,a3,a5
c0030cf8:	00052503          	lw	a0,0(a0)
c0030cfc:	00160613          	addi	a2,a2,1
c0030d00:	00468693          	addi	a3,a3,4
c0030d04:	fea6ae23          	sw	a0,-4(a3)
c0030d08:	fec5d6e3          	bge	a1,a2,c0030cf4 <__subtf3+0xe58>
c0030d0c:	00400513          	li	a0,4
c0030d10:	40e50733          	sub	a4,a0,a4
c0030d14:	0780006f          	j	c0030d8c <__subtf3+0xef0>
c0030d18:	00062503          	lw	a0,0(a2)
c0030d1c:	00178793          	addi	a5,a5,1
c0030d20:	00460613          	addi	a2,a2,4
c0030d24:	00a4e4b3          	or	s1,s1,a0
c0030d28:	fa5ff06f          	j	c0030ccc <__subtf3+0xe30>
c0030d2c:	02000513          	li	a0,32
c0030d30:	02a5e5b3          	rem	a1,a1,a0
c0030d34:	ffc00313          	li	t1,-4
c0030d38:	04010693          	addi	a3,sp,64
c0030d3c:	00261613          	slli	a2,a2,0x2
c0030d40:	00c68633          	add	a2,a3,a2
c0030d44:	fd062683          	lw	a3,-48(a2)
c0030d48:	00000813          	li	a6,0
c0030d4c:	02670333          	mul	t1,a4,t1
c0030d50:	40b50533          	sub	a0,a0,a1
c0030d54:	00a696b3          	sll	a3,a3,a0
c0030d58:	00d4e4b3          	or	s1,s1,a3
c0030d5c:	00f886b3          	add	a3,a7,a5
c0030d60:	00300793          	li	a5,3
c0030d64:	40e787b3          	sub	a5,a5,a4
c0030d68:	0cf84a63          	blt	a6,a5,c0030e3c <__subtf3+0xfa0>
c0030d6c:	04010693          	addi	a3,sp,64
c0030d70:	00279793          	slli	a5,a5,0x2
c0030d74:	00f687b3          	add	a5,a3,a5
c0030d78:	01c12683          	lw	a3,28(sp)
c0030d7c:	00400513          	li	a0,4
c0030d80:	40e50733          	sub	a4,a0,a4
c0030d84:	00b6d5b3          	srl	a1,a3,a1
c0030d88:	fcb7a823          	sw	a1,-48(a5)
c0030d8c:	00400793          	li	a5,4
c0030d90:	00000613          	li	a2,0
c0030d94:	00e7c663          	blt	a5,a4,c0030da0 <__subtf3+0xf04>
c0030d98:	40e787b3          	sub	a5,a5,a4
c0030d9c:	00279613          	slli	a2,a5,0x2
c0030da0:	00271713          	slli	a4,a4,0x2
c0030da4:	00e88533          	add	a0,a7,a4
c0030da8:	00000593          	li	a1,0
c0030dac:	eddec0ef          	jal	ra,c001dc88 <memset>
c0030db0:	01012703          	lw	a4,16(sp)
c0030db4:	009037b3          	snez	a5,s1
c0030db8:	00f767b3          	or	a5,a4,a5
c0030dbc:	00f12823          	sw	a5,16(sp)
c0030dc0:	01012703          	lw	a4,16(sp)
c0030dc4:	01412603          	lw	a2,20(sp)
c0030dc8:	40e40733          	sub	a4,s0,a4
c0030dcc:	40c987b3          	sub	a5,s3,a2
c0030dd0:	00e436b3          	sltu	a3,s0,a4
c0030dd4:	00f9b5b3          	sltu	a1,s3,a5
c0030dd8:	40d787b3          	sub	a5,a5,a3
c0030ddc:	00000693          	li	a3,0
c0030de0:	00e47663          	bgeu	s0,a4,c0030dec <__subtf3+0xf50>
c0030de4:	413606b3          	sub	a3,a2,s3
c0030de8:	0016b693          	seqz	a3,a3
c0030dec:	01812803          	lw	a6,24(sp)
c0030df0:	00b6e6b3          	or	a3,a3,a1
c0030df4:	00000513          	li	a0,0
c0030df8:	410a0633          	sub	a2,s4,a6
c0030dfc:	00ca38b3          	sltu	a7,s4,a2
c0030e00:	40d605b3          	sub	a1,a2,a3
c0030e04:	00068663          	beqz	a3,c0030e10 <__subtf3+0xf74>
c0030e08:	41480833          	sub	a6,a6,s4
c0030e0c:	00183513          	seqz	a0,a6
c0030e10:	01c12603          	lw	a2,28(sp)
c0030e14:	01156533          	or	a0,a0,a7
c0030e18:	02b12c23          	sw	a1,56(sp)
c0030e1c:	40cc8cb3          	sub	s9,s9,a2
c0030e20:	40ac8cb3          	sub	s9,s9,a0
c0030e24:	03912e23          	sw	s9,60(sp)
c0030e28:	02f12a23          	sw	a5,52(sp)
c0030e2c:	02e12823          	sw	a4,48(sp)
c0030e30:	000c0493          	mv	s1,s8
c0030e34:	000b8a93          	mv	s5,s7
c0030e38:	d25ff06f          	j	c0030b5c <__subtf3+0xcc0>
c0030e3c:	0006a603          	lw	a2,0(a3)
c0030e40:	0046ae03          	lw	t3,4(a3)
c0030e44:	00668eb3          	add	t4,a3,t1
c0030e48:	00b65633          	srl	a2,a2,a1
c0030e4c:	00ae1e33          	sll	t3,t3,a0
c0030e50:	01c66633          	or	a2,a2,t3
c0030e54:	00cea023          	sw	a2,0(t4)
c0030e58:	00180813          	addi	a6,a6,1
c0030e5c:	00468693          	addi	a3,a3,4
c0030e60:	f09ff06f          	j	c0030d68 <__subtf3+0xecc>
c0030e64:	00012e23          	sw	zero,28(sp)
c0030e68:	00012c23          	sw	zero,24(sp)
c0030e6c:	00012a23          	sw	zero,20(sp)
c0030e70:	00100793          	li	a5,1
c0030e74:	f49ff06f          	j	c0030dbc <__subtf3+0xf20>
c0030e78:	00008537          	lui	a0,0x8
c0030e7c:	ffe50713          	addi	a4,a0,-2 # 7ffe <_STACK_SIZE+0x6ffe>
c0030e80:	00148793          	addi	a5,s1,1
c0030e84:	00e7f7b3          	and	a5,a5,a4
c0030e88:	01812683          	lw	a3,24(sp)
c0030e8c:	01412703          	lw	a4,20(sp)
c0030e90:	01c12603          	lw	a2,28(sp)
c0030e94:	1e079263          	bnez	a5,c0031078 <__subtf3+0x11dc>
c0030e98:	0149e7b3          	or	a5,s3,s4
c0030e9c:	00d765b3          	or	a1,a4,a3
c0030ea0:	0197e7b3          	or	a5,a5,s9
c0030ea4:	00c5e5b3          	or	a1,a1,a2
c0030ea8:	0087e7b3          	or	a5,a5,s0
c0030eac:	0125e5b3          	or	a1,a1,s2
c0030eb0:	10049c63          	bnez	s1,c0030fc8 <__subtf3+0x112c>
c0030eb4:	02059463          	bnez	a1,c0030edc <__subtf3+0x1040>
c0030eb8:	02812823          	sw	s0,48(sp)
c0030ebc:	03312a23          	sw	s3,52(sp)
c0030ec0:	03412c23          	sw	s4,56(sp)
c0030ec4:	03912e23          	sw	s9,60(sp)
c0030ec8:	000b8a93          	mv	s5,s7
c0030ecc:	a0079663          	bnez	a5,c00300d8 <__subtf3+0x23c>
c0030ed0:	00000493          	li	s1,0
c0030ed4:	00000a93          	li	s5,0
c0030ed8:	a00ff06f          	j	c00300d8 <__subtf3+0x23c>
c0030edc:	00079c63          	bnez	a5,c0030ef4 <__subtf3+0x1058>
c0030ee0:	03212823          	sw	s2,48(sp)
c0030ee4:	02e12a23          	sw	a4,52(sp)
c0030ee8:	02d12c23          	sw	a3,56(sp)
c0030eec:	02c12e23          	sw	a2,60(sp)
c0030ef0:	9e8ff06f          	j	c00300d8 <__subtf3+0x23c>
c0030ef4:	408905b3          	sub	a1,s2,s0
c0030ef8:	41370333          	sub	t1,a4,s3
c0030efc:	00b93833          	sltu	a6,s2,a1
c0030f00:	006737b3          	sltu	a5,a4,t1
c0030f04:	41030833          	sub	a6,t1,a6
c0030f08:	00000513          	li	a0,0
c0030f0c:	00b97463          	bgeu	s2,a1,c0030f14 <__subtf3+0x1078>
c0030f10:	00133513          	seqz	a0,t1
c0030f14:	414688b3          	sub	a7,a3,s4
c0030f18:	00f56533          	or	a0,a0,a5
c0030f1c:	0116bf33          	sltu	t5,a3,a7
c0030f20:	40a88eb3          	sub	t4,a7,a0
c0030f24:	00000e13          	li	t3,0
c0030f28:	00050463          	beqz	a0,c0030f30 <__subtf3+0x1094>
c0030f2c:	0018be13          	seqz	t3,a7
c0030f30:	419607b3          	sub	a5,a2,s9
c0030f34:	01ee6e33          	or	t3,t3,t5
c0030f38:	41c787b3          	sub	a5,a5,t3
c0030f3c:	00080537          	lui	a0,0x80
c0030f40:	02f12e23          	sw	a5,60(sp)
c0030f44:	03d12c23          	sw	t4,56(sp)
c0030f48:	03012a23          	sw	a6,52(sp)
c0030f4c:	02b12823          	sw	a1,48(sp)
c0030f50:	00a7f533          	and	a0,a5,a0
c0030f54:	06050063          	beqz	a0,c0030fb4 <__subtf3+0x1118>
c0030f58:	41240933          	sub	s2,s0,s2
c0030f5c:	40e98733          	sub	a4,s3,a4
c0030f60:	012437b3          	sltu	a5,s0,s2
c0030f64:	00e9b9b3          	sltu	s3,s3,a4
c0030f68:	40f70733          	sub	a4,a4,a5
c0030f6c:	00000793          	li	a5,0
c0030f70:	01247463          	bgeu	s0,s2,c0030f78 <__subtf3+0x10dc>
c0030f74:	00133793          	seqz	a5,t1
c0030f78:	40da06b3          	sub	a3,s4,a3
c0030f7c:	0137e9b3          	or	s3,a5,s3
c0030f80:	00da3a33          	sltu	s4,s4,a3
c0030f84:	00000593          	li	a1,0
c0030f88:	413686b3          	sub	a3,a3,s3
c0030f8c:	00098463          	beqz	s3,c0030f94 <__subtf3+0x10f8>
c0030f90:	0018b593          	seqz	a1,a7
c0030f94:	40cc8633          	sub	a2,s9,a2
c0030f98:	0145e5b3          	or	a1,a1,s4
c0030f9c:	40b605b3          	sub	a1,a2,a1
c0030fa0:	02b12e23          	sw	a1,60(sp)
c0030fa4:	02d12c23          	sw	a3,56(sp)
c0030fa8:	02e12a23          	sw	a4,52(sp)
c0030fac:	03212823          	sw	s2,48(sp)
c0030fb0:	c3dff06f          	j	c0030bec <__subtf3+0xd50>
c0030fb4:	0105e5b3          	or	a1,a1,a6
c0030fb8:	01d5e5b3          	or	a1,a1,t4
c0030fbc:	00f5e5b3          	or	a1,a1,a5
c0030fc0:	f00588e3          	beqz	a1,c0030ed0 <__subtf3+0x1034>
c0030fc4:	914ff06f          	j	c00300d8 <__subtf3+0x23c>
c0030fc8:	03010813          	addi	a6,sp,48
c0030fcc:	04059e63          	bnez	a1,c0031028 <__subtf3+0x118c>
c0030fd0:	02079e63          	bnez	a5,c003100c <__subtf3+0x1170>
c0030fd4:	02a12e23          	sw	a0,60(sp)
c0030fd8:	02012c23          	sw	zero,56(sp)
c0030fdc:	02012a23          	sw	zero,52(sp)
c0030fe0:	02012823          	sw	zero,48(sp)
c0030fe4:	03c10793          	addi	a5,sp,60
c0030fe8:	0007a703          	lw	a4,0(a5)
c0030fec:	ffc7a683          	lw	a3,-4(a5)
c0030ff0:	ffc78793          	addi	a5,a5,-4
c0030ff4:	00371713          	slli	a4,a4,0x3
c0030ff8:	01d6d693          	srli	a3,a3,0x1d
c0030ffc:	00d76733          	or	a4,a4,a3
c0031000:	00e7a223          	sw	a4,4(a5)
c0031004:	fef812e3          	bne	a6,a5,c0030fe8 <__subtf3+0x114c>
c0031008:	83dff06f          	j	c0030844 <__subtf3+0x9a8>
c003100c:	02812823          	sw	s0,48(sp)
c0031010:	03312a23          	sw	s3,52(sp)
c0031014:	03412c23          	sw	s4,56(sp)
c0031018:	03912e23          	sw	s9,60(sp)
c003101c:	000b8a93          	mv	s5,s7
c0031020:	fff50493          	addi	s1,a0,-1 # 7ffff <_HEAP_SIZE+0x3ffff>
c0031024:	8b4ff06f          	j	c00300d8 <__subtf3+0x23c>
c0031028:	00079c63          	bnez	a5,c0031040 <__subtf3+0x11a4>
c003102c:	03212823          	sw	s2,48(sp)
c0031030:	02e12a23          	sw	a4,52(sp)
c0031034:	02d12c23          	sw	a3,56(sp)
c0031038:	02c12e23          	sw	a2,60(sp)
c003103c:	fe5ff06f          	j	c0031020 <__subtf3+0x1184>
c0031040:	02a12e23          	sw	a0,60(sp)
c0031044:	02012c23          	sw	zero,56(sp)
c0031048:	02012a23          	sw	zero,52(sp)
c003104c:	02012823          	sw	zero,48(sp)
c0031050:	03c10793          	addi	a5,sp,60
c0031054:	0007a703          	lw	a4,0(a5)
c0031058:	ffc7a683          	lw	a3,-4(a5)
c003105c:	ffc78793          	addi	a5,a5,-4
c0031060:	00371713          	slli	a4,a4,0x3
c0031064:	01d6d693          	srli	a3,a3,0x1d
c0031068:	00d76733          	or	a4,a4,a3
c003106c:	00e7a223          	sw	a4,4(a5)
c0031070:	fef812e3          	bne	a6,a5,c0031054 <__subtf3+0x11b8>
c0031074:	fd0ff06f          	j	c0030844 <__subtf3+0x9a8>
c0031078:	408905b3          	sub	a1,s2,s0
c003107c:	41370e33          	sub	t3,a4,s3
c0031080:	00b938b3          	sltu	a7,s2,a1
c0031084:	01c737b3          	sltu	a5,a4,t3
c0031088:	411e08b3          	sub	a7,t3,a7
c003108c:	00000513          	li	a0,0
c0031090:	00b97463          	bgeu	s2,a1,c0031098 <__subtf3+0x11fc>
c0031094:	001e3513          	seqz	a0,t3
c0031098:	41468333          	sub	t1,a3,s4
c003109c:	00f56533          	or	a0,a0,a5
c00310a0:	0066bfb3          	sltu	t6,a3,t1
c00310a4:	40a30f33          	sub	t5,t1,a0
c00310a8:	00000e93          	li	t4,0
c00310ac:	00050463          	beqz	a0,c00310b4 <__subtf3+0x1218>
c00310b0:	00133e93          	seqz	t4,t1
c00310b4:	419607b3          	sub	a5,a2,s9
c00310b8:	01feeeb3          	or	t4,t4,t6
c00310bc:	41d787b3          	sub	a5,a5,t4
c00310c0:	00080537          	lui	a0,0x80
c00310c4:	02f12e23          	sw	a5,60(sp)
c00310c8:	03e12c23          	sw	t5,56(sp)
c00310cc:	03112a23          	sw	a7,52(sp)
c00310d0:	02b12823          	sw	a1,48(sp)
c00310d4:	00a7f533          	and	a0,a5,a0
c00310d8:	12050e63          	beqz	a0,c0031214 <__subtf3+0x1378>
c00310dc:	41240933          	sub	s2,s0,s2
c00310e0:	40e98733          	sub	a4,s3,a4
c00310e4:	012437b3          	sltu	a5,s0,s2
c00310e8:	00e9b9b3          	sltu	s3,s3,a4
c00310ec:	40f70733          	sub	a4,a4,a5
c00310f0:	00000793          	li	a5,0
c00310f4:	01247463          	bgeu	s0,s2,c00310fc <__subtf3+0x1260>
c00310f8:	001e3793          	seqz	a5,t3
c00310fc:	0137e9b3          	or	s3,a5,s3
c0031100:	40da06b3          	sub	a3,s4,a3
c0031104:	00da37b3          	sltu	a5,s4,a3
c0031108:	413686b3          	sub	a3,a3,s3
c003110c:	00098463          	beqz	s3,c0031114 <__subtf3+0x1278>
c0031110:	00133813          	seqz	a6,t1
c0031114:	40cc8633          	sub	a2,s9,a2
c0031118:	00f867b3          	or	a5,a6,a5
c003111c:	40f607b3          	sub	a5,a2,a5
c0031120:	02f12e23          	sw	a5,60(sp)
c0031124:	02d12c23          	sw	a3,56(sp)
c0031128:	02e12a23          	sw	a4,52(sp)
c003112c:	03212823          	sw	s2,48(sp)
c0031130:	000b8a93          	mv	s5,s7
c0031134:	03c12503          	lw	a0,60(sp)
c0031138:	0e050863          	beqz	a0,c0031228 <__subtf3+0x138c>
c003113c:	cf0fc0ef          	jal	ra,c002d62c <__clzsi2>
c0031140:	ff450413          	addi	s0,a0,-12 # 7fff4 <_HEAP_SIZE+0x3fff4>
c0031144:	02000793          	li	a5,32
c0031148:	01f47713          	andi	a4,s0,31
c003114c:	02f44633          	div	a2,s0,a5
c0031150:	10070863          	beqz	a4,c0031260 <__subtf3+0x13c4>
c0031154:	03010893          	addi	a7,sp,48
c0031158:	00261593          	slli	a1,a2,0x2
c003115c:	02f46533          	rem	a0,s0,a5
c0031160:	40a78733          	sub	a4,a5,a0
c0031164:	ffc00793          	li	a5,-4
c0031168:	02f607b3          	mul	a5,a2,a5
c003116c:	00c78793          	addi	a5,a5,12
c0031170:	00f887b3          	add	a5,a7,a5
c0031174:	10f89e63          	bne	a7,a5,c0031290 <__subtf3+0x13f4>
c0031178:	04010793          	addi	a5,sp,64
c003117c:	00b785b3          	add	a1,a5,a1
c0031180:	03012783          	lw	a5,48(sp)
c0031184:	fff60613          	addi	a2,a2,-1
c0031188:	00a797b3          	sll	a5,a5,a0
c003118c:	fef5a823          	sw	a5,-16(a1)
c0031190:	00160613          	addi	a2,a2,1
c0031194:	00261613          	slli	a2,a2,0x2
c0031198:	00000593          	li	a1,0
c003119c:	03010513          	addi	a0,sp,48
c00311a0:	ae9ec0ef          	jal	ra,c001dc88 <memset>
c00311a4:	1e944863          	blt	s0,s1,c0031394 <__subtf3+0x14f8>
c00311a8:	40940433          	sub	s0,s0,s1
c00311ac:	00140413          	addi	s0,s0,1
c00311b0:	02000793          	li	a5,32
c00311b4:	02f447b3          	div	a5,s0,a5
c00311b8:	03010613          	addi	a2,sp,48
c00311bc:	00060693          	mv	a3,a2
c00311c0:	00000913          	li	s2,0
c00311c4:	00000713          	li	a4,0
c00311c8:	0ef74663          	blt	a4,a5,c00312b4 <__subtf3+0x1418>
c00311cc:	00078713          	mv	a4,a5
c00311d0:	0007d463          	bgez	a5,c00311d8 <__subtf3+0x133c>
c00311d4:	00000713          	li	a4,0
c00311d8:	01f47593          	andi	a1,s0,31
c00311dc:	00279693          	slli	a3,a5,0x2
c00311e0:	0e059463          	bnez	a1,c00312c8 <__subtf3+0x142c>
c00311e4:	00300593          	li	a1,3
c00311e8:	00000713          	li	a4,0
c00311ec:	40f585b3          	sub	a1,a1,a5
c00311f0:	00d60533          	add	a0,a2,a3
c00311f4:	00052503          	lw	a0,0(a0)
c00311f8:	00170713          	addi	a4,a4,1 # 80001 <_HEAP_SIZE+0x40001>
c00311fc:	00460613          	addi	a2,a2,4
c0031200:	fea62e23          	sw	a0,-4(a2)
c0031204:	fee5d6e3          	bge	a1,a4,c00311f0 <__subtf3+0x1354>
c0031208:	00400513          	li	a0,4
c003120c:	40f507b3          	sub	a5,a0,a5
c0031210:	11c0006f          	j	c003132c <__subtf3+0x1490>
c0031214:	0115e5b3          	or	a1,a1,a7
c0031218:	01e5e5b3          	or	a1,a1,t5
c003121c:	00f5e5b3          	or	a1,a1,a5
c0031220:	ca0588e3          	beqz	a1,c0030ed0 <__subtf3+0x1034>
c0031224:	f11ff06f          	j	c0031134 <__subtf3+0x1298>
c0031228:	03812503          	lw	a0,56(sp)
c003122c:	00050863          	beqz	a0,c003123c <__subtf3+0x13a0>
c0031230:	bfcfc0ef          	jal	ra,c002d62c <__clzsi2>
c0031234:	02050513          	addi	a0,a0,32
c0031238:	f09ff06f          	j	c0031140 <__subtf3+0x12a4>
c003123c:	03412503          	lw	a0,52(sp)
c0031240:	00050863          	beqz	a0,c0031250 <__subtf3+0x13b4>
c0031244:	be8fc0ef          	jal	ra,c002d62c <__clzsi2>
c0031248:	04050513          	addi	a0,a0,64
c003124c:	ef5ff06f          	j	c0031140 <__subtf3+0x12a4>
c0031250:	03012503          	lw	a0,48(sp)
c0031254:	bd8fc0ef          	jal	ra,c002d62c <__clzsi2>
c0031258:	06050513          	addi	a0,a0,96
c003125c:	ee5ff06f          	j	c0031140 <__subtf3+0x12a4>
c0031260:	ffc00693          	li	a3,-4
c0031264:	02d606b3          	mul	a3,a2,a3
c0031268:	03c10793          	addi	a5,sp,60
c003126c:	00300713          	li	a4,3
c0031270:	00d785b3          	add	a1,a5,a3
c0031274:	0005a583          	lw	a1,0(a1)
c0031278:	fff70713          	addi	a4,a4,-1
c003127c:	ffc78793          	addi	a5,a5,-4
c0031280:	00b7a223          	sw	a1,4(a5)
c0031284:	fec756e3          	bge	a4,a2,c0031270 <__subtf3+0x13d4>
c0031288:	fff60613          	addi	a2,a2,-1
c003128c:	f05ff06f          	j	c0031190 <__subtf3+0x12f4>
c0031290:	0007a683          	lw	a3,0(a5)
c0031294:	ffc7a803          	lw	a6,-4(a5)
c0031298:	00b78333          	add	t1,a5,a1
c003129c:	00a696b3          	sll	a3,a3,a0
c00312a0:	00e85833          	srl	a6,a6,a4
c00312a4:	0106e6b3          	or	a3,a3,a6
c00312a8:	00d32023          	sw	a3,0(t1)
c00312ac:	ffc78793          	addi	a5,a5,-4
c00312b0:	ec5ff06f          	j	c0031174 <__subtf3+0x12d8>
c00312b4:	0006a583          	lw	a1,0(a3)
c00312b8:	00170713          	addi	a4,a4,1
c00312bc:	00468693          	addi	a3,a3,4
c00312c0:	00b96933          	or	s2,s2,a1
c00312c4:	f05ff06f          	j	c00311c8 <__subtf3+0x132c>
c00312c8:	02000613          	li	a2,32
c00312cc:	02c46433          	rem	s0,s0,a2
c00312d0:	ffc00813          	li	a6,-4
c00312d4:	00271713          	slli	a4,a4,0x2
c00312d8:	04010593          	addi	a1,sp,64
c00312dc:	00e58733          	add	a4,a1,a4
c00312e0:	ff072703          	lw	a4,-16(a4)
c00312e4:	00000513          	li	a0,0
c00312e8:	03078833          	mul	a6,a5,a6
c00312ec:	40860633          	sub	a2,a2,s0
c00312f0:	00c71733          	sll	a4,a4,a2
c00312f4:	00e96933          	or	s2,s2,a4
c00312f8:	03010713          	addi	a4,sp,48
c00312fc:	00d706b3          	add	a3,a4,a3
c0031300:	00300713          	li	a4,3
c0031304:	40f70733          	sub	a4,a4,a5
c0031308:	06e54263          	blt	a0,a4,c003136c <__subtf3+0x14d0>
c003130c:	03c12483          	lw	s1,60(sp)
c0031310:	00271713          	slli	a4,a4,0x2
c0031314:	04010693          	addi	a3,sp,64
c0031318:	00400513          	li	a0,4
c003131c:	00e68733          	add	a4,a3,a4
c0031320:	0084d433          	srl	s0,s1,s0
c0031324:	40f507b3          	sub	a5,a0,a5
c0031328:	fe872823          	sw	s0,-16(a4)
c003132c:	00400713          	li	a4,4
c0031330:	00000613          	li	a2,0
c0031334:	00f74663          	blt	a4,a5,c0031340 <__subtf3+0x14a4>
c0031338:	40f70733          	sub	a4,a4,a5
c003133c:	00271613          	slli	a2,a4,0x2
c0031340:	00279513          	slli	a0,a5,0x2
c0031344:	03010793          	addi	a5,sp,48
c0031348:	00a78533          	add	a0,a5,a0
c003134c:	00000593          	li	a1,0
c0031350:	939ec0ef          	jal	ra,c001dc88 <memset>
c0031354:	03012703          	lw	a4,48(sp)
c0031358:	012037b3          	snez	a5,s2
c003135c:	00000493          	li	s1,0
c0031360:	00f767b3          	or	a5,a4,a5
c0031364:	02f12823          	sw	a5,48(sp)
c0031368:	d71fe06f          	j	c00300d8 <__subtf3+0x23c>
c003136c:	0006a583          	lw	a1,0(a3)
c0031370:	0046a883          	lw	a7,4(a3)
c0031374:	01068333          	add	t1,a3,a6
c0031378:	0085d5b3          	srl	a1,a1,s0
c003137c:	00c898b3          	sll	a7,a7,a2
c0031380:	0115e5b3          	or	a1,a1,a7
c0031384:	00b32023          	sw	a1,0(t1)
c0031388:	00150513          	addi	a0,a0,1
c003138c:	00468693          	addi	a3,a3,4
c0031390:	f79ff06f          	j	c0031308 <__subtf3+0x146c>
c0031394:	03c12783          	lw	a5,60(sp)
c0031398:	fff80737          	lui	a4,0xfff80
c003139c:	fff70713          	addi	a4,a4,-1 # fff7ffff <_end+0x37efb77f>
c00313a0:	00e7f7b3          	and	a5,a5,a4
c00313a4:	408484b3          	sub	s1,s1,s0
c00313a8:	02f12e23          	sw	a5,60(sp)
c00313ac:	d2dfe06f          	j	c00300d8 <__subtf3+0x23c>
c00313b0:	02012e23          	sw	zero,60(sp)
c00313b4:	02012c23          	sw	zero,56(sp)
c00313b8:	02012a23          	sw	zero,52(sp)
c00313bc:	02012823          	sw	zero,48(sp)
c00313c0:	d9dfe06f          	j	c003015c <__subtf3+0x2c0>

c00313c4 <__fixtfsi>:
c00313c4:	00852783          	lw	a5,8(a0)
c00313c8:	00452703          	lw	a4,4(a0)
c00313cc:	00c52683          	lw	a3,12(a0)
c00313d0:	00052603          	lw	a2,0(a0)
c00313d4:	fe010113          	addi	sp,sp,-32
c00313d8:	00e12223          	sw	a4,4(sp)
c00313dc:	00f12423          	sw	a5,8(sp)
c00313e0:	00f12c23          	sw	a5,24(sp)
c00313e4:	00004737          	lui	a4,0x4
c00313e8:	00169793          	slli	a5,a3,0x1
c00313ec:	0117d593          	srli	a1,a5,0x11
c00313f0:	00c12023          	sw	a2,0(sp)
c00313f4:	00d12623          	sw	a3,12(sp)
c00313f8:	00c12823          	sw	a2,16(sp)
c00313fc:	ffe70793          	addi	a5,a4,-2 # 3ffe <_STACK_SIZE+0x2ffe>
c0031400:	00000513          	li	a0,0
c0031404:	00b7de63          	bge	a5,a1,c0031420 <__fixtfsi+0x5c>
c0031408:	01d70793          	addi	a5,a4,29
c003140c:	01f6d813          	srli	a6,a3,0x1f
c0031410:	00b7dc63          	bge	a5,a1,c0031428 <__fixtfsi+0x64>
c0031414:	80000537          	lui	a0,0x80000
c0031418:	fff54513          	not	a0,a0
c003141c:	00a80533          	add	a0,a6,a0
c0031420:	02010113          	addi	sp,sp,32
c0031424:	00008067          	ret
c0031428:	01069693          	slli	a3,a3,0x10
c003142c:	000107b7          	lui	a5,0x10
c0031430:	0106d693          	srli	a3,a3,0x10
c0031434:	00f6e6b3          	or	a3,a3,a5
c0031438:	06f70793          	addi	a5,a4,111
c003143c:	40b787b3          	sub	a5,a5,a1
c0031440:	4057d713          	srai	a4,a5,0x5
c0031444:	00d12e23          	sw	a3,28(sp)
c0031448:	01f7f793          	andi	a5,a5,31
c003144c:	04078863          	beqz	a5,c003149c <__fixtfsi+0xd8>
c0031450:	02000513          	li	a0,32
c0031454:	ffe70893          	addi	a7,a4,-2
c0031458:	40f50533          	sub	a0,a0,a5
c003145c:	00271713          	slli	a4,a4,0x2
c0031460:	02010e13          	addi	t3,sp,32
c0031464:	00a69533          	sll	a0,a3,a0
c0031468:	00000313          	li	t1,0
c003146c:	00000593          	li	a1,0
c0031470:	0018b893          	seqz	a7,a7
c0031474:	00ee0733          	add	a4,t3,a4
c0031478:	0515c463          	blt	a1,a7,c00314c0 <__fixtfsi+0xfc>
c003147c:	00030463          	beqz	t1,c0031484 <__fixtfsi+0xc0>
c0031480:	00c12823          	sw	a2,16(sp)
c0031484:	00259593          	slli	a1,a1,0x2
c0031488:	02010713          	addi	a4,sp,32
c003148c:	00b705b3          	add	a1,a4,a1
c0031490:	00f6d6b3          	srl	a3,a3,a5
c0031494:	fed5a823          	sw	a3,-16(a1)
c0031498:	0180006f          	j	c00314b0 <__fixtfsi+0xec>
c003149c:	02010793          	addi	a5,sp,32
c00314a0:	00271713          	slli	a4,a4,0x2
c00314a4:	00e78733          	add	a4,a5,a4
c00314a8:	ff072783          	lw	a5,-16(a4)
c00314ac:	00f12823          	sw	a5,16(sp)
c00314b0:	01012503          	lw	a0,16(sp)
c00314b4:	f60806e3          	beqz	a6,c0031420 <__fixtfsi+0x5c>
c00314b8:	40a00533          	neg	a0,a0
c00314bc:	f65ff06f          	j	c0031420 <__fixtfsi+0x5c>
c00314c0:	ff072603          	lw	a2,-16(a4)
c00314c4:	00100313          	li	t1,1
c00314c8:	00100593          	li	a1,1
c00314cc:	00f65633          	srl	a2,a2,a5
c00314d0:	00a66633          	or	a2,a2,a0
c00314d4:	fa5ff06f          	j	c0031478 <__fixtfsi+0xb4>

c00314d8 <__floatsitf>:
c00314d8:	fc010113          	addi	sp,sp,-64
c00314dc:	02912a23          	sw	s1,52(sp)
c00314e0:	02112e23          	sw	ra,60(sp)
c00314e4:	02812c23          	sw	s0,56(sp)
c00314e8:	03212823          	sw	s2,48(sp)
c00314ec:	03312623          	sw	s3,44(sp)
c00314f0:	00050493          	mv	s1,a0
c00314f4:	12058063          	beqz	a1,c0031614 <__floatsitf+0x13c>
c00314f8:	41f5d793          	srai	a5,a1,0x1f
c00314fc:	00b7c433          	xor	s0,a5,a1
c0031500:	40f40433          	sub	s0,s0,a5
c0031504:	00040513          	mv	a0,s0
c0031508:	01f5d913          	srli	s2,a1,0x1f
c003150c:	920fc0ef          	jal	ra,c002d62c <__clzsi2>
c0031510:	05150593          	addi	a1,a0,81 # 80000051 <_end+0xb7f7b7d1>
c0031514:	000049b7          	lui	s3,0x4
c0031518:	01e98993          	addi	s3,s3,30 # 401e <_STACK_SIZE+0x301e>
c003151c:	4055d793          	srai	a5,a1,0x5
c0031520:	00812823          	sw	s0,16(sp)
c0031524:	00012a23          	sw	zero,20(sp)
c0031528:	00012c23          	sw	zero,24(sp)
c003152c:	00012e23          	sw	zero,28(sp)
c0031530:	01f5f593          	andi	a1,a1,31
c0031534:	40a989b3          	sub	s3,s3,a0
c0031538:	02058c63          	beqz	a1,c0031570 <__floatsitf+0x98>
c003153c:	00200713          	li	a4,2
c0031540:	0ce79663          	bne	a5,a4,c003160c <__floatsitf+0x134>
c0031544:	02000713          	li	a4,32
c0031548:	40b70733          	sub	a4,a4,a1
c003154c:	00e45733          	srl	a4,s0,a4
c0031550:	00e12e23          	sw	a4,28(sp)
c0031554:	fff78613          	addi	a2,a5,-1 # ffff <_STACK_SIZE+0xefff>
c0031558:	02010713          	addi	a4,sp,32
c003155c:	00279793          	slli	a5,a5,0x2
c0031560:	00f707b3          	add	a5,a4,a5
c0031564:	00b41433          	sll	s0,s0,a1
c0031568:	fe87a823          	sw	s0,-16(a5)
c003156c:	0340006f          	j	c00315a0 <__floatsitf+0xc8>
c0031570:	00300713          	li	a4,3
c0031574:	40f70733          	sub	a4,a4,a5
c0031578:	00271713          	slli	a4,a4,0x2
c003157c:	02010693          	addi	a3,sp,32
c0031580:	00e68733          	add	a4,a3,a4
c0031584:	ff072703          	lw	a4,-16(a4)
c0031588:	00200613          	li	a2,2
c003158c:	00e12e23          	sw	a4,28(sp)
c0031590:	00200713          	li	a4,2
c0031594:	00e79663          	bne	a5,a4,c00315a0 <__floatsitf+0xc8>
c0031598:	00812c23          	sw	s0,24(sp)
c003159c:	00100613          	li	a2,1
c00315a0:	00160613          	addi	a2,a2,1
c00315a4:	00000593          	li	a1,0
c00315a8:	00261613          	slli	a2,a2,0x2
c00315ac:	01010513          	addi	a0,sp,16
c00315b0:	ed8ec0ef          	jal	ra,c001dc88 <memset>
c00315b4:	00090593          	mv	a1,s2
c00315b8:	01c12783          	lw	a5,28(sp)
c00315bc:	00f59413          	slli	s0,a1,0xf
c00315c0:	01346433          	or	s0,s0,s3
c00315c4:	00f11623          	sh	a5,12(sp)
c00315c8:	01012783          	lw	a5,16(sp)
c00315cc:	00811723          	sh	s0,14(sp)
c00315d0:	03c12083          	lw	ra,60(sp)
c00315d4:	00f4a023          	sw	a5,0(s1)
c00315d8:	01412783          	lw	a5,20(sp)
c00315dc:	03812403          	lw	s0,56(sp)
c00315e0:	03012903          	lw	s2,48(sp)
c00315e4:	00f4a223          	sw	a5,4(s1)
c00315e8:	01812783          	lw	a5,24(sp)
c00315ec:	02c12983          	lw	s3,44(sp)
c00315f0:	00048513          	mv	a0,s1
c00315f4:	00f4a423          	sw	a5,8(s1)
c00315f8:	00c12783          	lw	a5,12(sp)
c00315fc:	00f4a623          	sw	a5,12(s1)
c0031600:	03412483          	lw	s1,52(sp)
c0031604:	04010113          	addi	sp,sp,64
c0031608:	00008067          	ret
c003160c:	00300793          	li	a5,3
c0031610:	f45ff06f          	j	c0031554 <__floatsitf+0x7c>
c0031614:	00012e23          	sw	zero,28(sp)
c0031618:	00012c23          	sw	zero,24(sp)
c003161c:	00012a23          	sw	zero,20(sp)
c0031620:	00012823          	sw	zero,16(sp)
c0031624:	00000993          	li	s3,0
c0031628:	f91ff06f          	j	c00315b8 <__floatsitf+0xe0>

c003162c <__extenddftf2>:
c003162c:	01465793          	srli	a5,a2,0x14
c0031630:	00c61713          	slli	a4,a2,0xc
c0031634:	7ff7f793          	andi	a5,a5,2047
c0031638:	fc010113          	addi	sp,sp,-64
c003163c:	00c75713          	srli	a4,a4,0xc
c0031640:	00178693          	addi	a3,a5,1
c0031644:	02812c23          	sw	s0,56(sp)
c0031648:	02912a23          	sw	s1,52(sp)
c003164c:	03212823          	sw	s2,48(sp)
c0031650:	02112e23          	sw	ra,60(sp)
c0031654:	03312623          	sw	s3,44(sp)
c0031658:	00b12823          	sw	a1,16(sp)
c003165c:	00e12a23          	sw	a4,20(sp)
c0031660:	00012e23          	sw	zero,28(sp)
c0031664:	00012c23          	sw	zero,24(sp)
c0031668:	7fe6f693          	andi	a3,a3,2046
c003166c:	00050913          	mv	s2,a0
c0031670:	00058413          	mv	s0,a1
c0031674:	01f65493          	srli	s1,a2,0x1f
c0031678:	08068463          	beqz	a3,c0031700 <__extenddftf2+0xd4>
c003167c:	000046b7          	lui	a3,0x4
c0031680:	c0068693          	addi	a3,a3,-1024 # 3c00 <_STACK_SIZE+0x2c00>
c0031684:	00d787b3          	add	a5,a5,a3
c0031688:	0045d513          	srli	a0,a1,0x4
c003168c:	00475693          	srli	a3,a4,0x4
c0031690:	01c71713          	slli	a4,a4,0x1c
c0031694:	00a76733          	or	a4,a4,a0
c0031698:	01c59413          	slli	s0,a1,0x1c
c003169c:	00d12e23          	sw	a3,28(sp)
c00316a0:	00e12c23          	sw	a4,24(sp)
c00316a4:	00812a23          	sw	s0,20(sp)
c00316a8:	00012823          	sw	zero,16(sp)
c00316ac:	00f49493          	slli	s1,s1,0xf
c00316b0:	00f4e7b3          	or	a5,s1,a5
c00316b4:	00f11723          	sh	a5,14(sp)
c00316b8:	01012783          	lw	a5,16(sp)
c00316bc:	01c12703          	lw	a4,28(sp)
c00316c0:	03c12083          	lw	ra,60(sp)
c00316c4:	00f92023          	sw	a5,0(s2)
c00316c8:	01412783          	lw	a5,20(sp)
c00316cc:	00e11623          	sh	a4,12(sp)
c00316d0:	03812403          	lw	s0,56(sp)
c00316d4:	00f92223          	sw	a5,4(s2)
c00316d8:	01812783          	lw	a5,24(sp)
c00316dc:	03412483          	lw	s1,52(sp)
c00316e0:	02c12983          	lw	s3,44(sp)
c00316e4:	00f92423          	sw	a5,8(s2)
c00316e8:	00c12783          	lw	a5,12(sp)
c00316ec:	00090513          	mv	a0,s2
c00316f0:	00f92623          	sw	a5,12(s2)
c00316f4:	03012903          	lw	s2,48(sp)
c00316f8:	04010113          	addi	sp,sp,64
c00316fc:	00008067          	ret
c0031700:	00b76533          	or	a0,a4,a1
c0031704:	0e079263          	bnez	a5,c00317e8 <__extenddftf2+0x1bc>
c0031708:	fa0502e3          	beqz	a0,c00316ac <__extenddftf2+0x80>
c003170c:	04070e63          	beqz	a4,c0031768 <__extenddftf2+0x13c>
c0031710:	00070513          	mv	a0,a4
c0031714:	f19fb0ef          	jal	ra,c002d62c <__clzsi2>
c0031718:	00050993          	mv	s3,a0
c003171c:	03198593          	addi	a1,s3,49
c0031720:	4055d613          	srai	a2,a1,0x5
c0031724:	01f5f593          	andi	a1,a1,31
c0031728:	04058663          	beqz	a1,c0031774 <__extenddftf2+0x148>
c003172c:	ffc00713          	li	a4,-4
c0031730:	02e60733          	mul	a4,a2,a4
c0031734:	02000513          	li	a0,32
c0031738:	01010893          	addi	a7,sp,16
c003173c:	40b50533          	sub	a0,a0,a1
c0031740:	00261693          	slli	a3,a2,0x2
c0031744:	00c70713          	addi	a4,a4,12
c0031748:	00e88733          	add	a4,a7,a4
c003174c:	06e89c63          	bne	a7,a4,c00317c4 <__extenddftf2+0x198>
c0031750:	02010793          	addi	a5,sp,32
c0031754:	00d786b3          	add	a3,a5,a3
c0031758:	00b415b3          	sll	a1,s0,a1
c003175c:	fff60613          	addi	a2,a2,-1
c0031760:	feb6a823          	sw	a1,-16(a3)
c0031764:	03c0006f          	j	c00317a0 <__extenddftf2+0x174>
c0031768:	ec5fb0ef          	jal	ra,c002d62c <__clzsi2>
c003176c:	02050993          	addi	s3,a0,32
c0031770:	fadff06f          	j	c003171c <__extenddftf2+0xf0>
c0031774:	ffc00693          	li	a3,-4
c0031778:	02d606b3          	mul	a3,a2,a3
c003177c:	01c10793          	addi	a5,sp,28
c0031780:	00300713          	li	a4,3
c0031784:	00d785b3          	add	a1,a5,a3
c0031788:	0005a583          	lw	a1,0(a1)
c003178c:	fff70713          	addi	a4,a4,-1
c0031790:	ffc78793          	addi	a5,a5,-4
c0031794:	00b7a223          	sw	a1,4(a5)
c0031798:	fec756e3          	bge	a4,a2,c0031784 <__extenddftf2+0x158>
c003179c:	fff60613          	addi	a2,a2,-1
c00317a0:	00160613          	addi	a2,a2,1
c00317a4:	00261613          	slli	a2,a2,0x2
c00317a8:	00000593          	li	a1,0
c00317ac:	01010513          	addi	a0,sp,16
c00317b0:	cd8ec0ef          	jal	ra,c001dc88 <memset>
c00317b4:	000047b7          	lui	a5,0x4
c00317b8:	c0c78793          	addi	a5,a5,-1012 # 3c0c <_STACK_SIZE+0x2c0c>
c00317bc:	413787b3          	sub	a5,a5,s3
c00317c0:	eedff06f          	j	c00316ac <__extenddftf2+0x80>
c00317c4:	00072783          	lw	a5,0(a4)
c00317c8:	ffc72803          	lw	a6,-4(a4)
c00317cc:	00d70333          	add	t1,a4,a3
c00317d0:	00b797b3          	sll	a5,a5,a1
c00317d4:	00a85833          	srl	a6,a6,a0
c00317d8:	0107e7b3          	or	a5,a5,a6
c00317dc:	00f32023          	sw	a5,0(t1)
c00317e0:	ffc70713          	addi	a4,a4,-4
c00317e4:	f69ff06f          	j	c003174c <__extenddftf2+0x120>
c00317e8:	000087b7          	lui	a5,0x8
c00317ec:	02050863          	beqz	a0,c003181c <__extenddftf2+0x1f0>
c00317f0:	01c71793          	slli	a5,a4,0x1c
c00317f4:	0045d693          	srli	a3,a1,0x4
c00317f8:	00d7e7b3          	or	a5,a5,a3
c00317fc:	00f12c23          	sw	a5,24(sp)
c0031800:	00475713          	srli	a4,a4,0x4
c0031804:	000087b7          	lui	a5,0x8
c0031808:	01c59413          	slli	s0,a1,0x1c
c003180c:	00f76733          	or	a4,a4,a5
c0031810:	00812a23          	sw	s0,20(sp)
c0031814:	00012823          	sw	zero,16(sp)
c0031818:	00e12e23          	sw	a4,28(sp)
c003181c:	fff78793          	addi	a5,a5,-1 # 7fff <_STACK_SIZE+0x6fff>
c0031820:	e8dff06f          	j	c00316ac <__extenddftf2+0x80>

c0031824 <__trunctfdf2>:
c0031824:	fd010113          	addi	sp,sp,-48
c0031828:	00852783          	lw	a5,8(a0)
c003182c:	02812423          	sw	s0,40(sp)
c0031830:	00c52403          	lw	s0,12(a0)
c0031834:	00452703          	lw	a4,4(a0)
c0031838:	00052683          	lw	a3,0(a0)
c003183c:	00f12423          	sw	a5,8(sp)
c0031840:	00f12c23          	sw	a5,24(sp)
c0031844:	01041793          	slli	a5,s0,0x10
c0031848:	00e12223          	sw	a4,4(sp)
c003184c:	00e12a23          	sw	a4,20(sp)
c0031850:	0107d793          	srli	a5,a5,0x10
c0031854:	00141713          	slli	a4,s0,0x1
c0031858:	00812623          	sw	s0,12(sp)
c003185c:	02112623          	sw	ra,44(sp)
c0031860:	02912223          	sw	s1,36(sp)
c0031864:	00d12023          	sw	a3,0(sp)
c0031868:	00d12823          	sw	a3,16(sp)
c003186c:	00f12e23          	sw	a5,28(sp)
c0031870:	01175713          	srli	a4,a4,0x11
c0031874:	01f45413          	srli	s0,s0,0x1f
c0031878:	01010513          	addi	a0,sp,16
c003187c:	01c10613          	addi	a2,sp,28
c0031880:	00062783          	lw	a5,0(a2)
c0031884:	ffc62683          	lw	a3,-4(a2)
c0031888:	ffc60613          	addi	a2,a2,-4
c003188c:	00379793          	slli	a5,a5,0x3
c0031890:	01d6d693          	srli	a3,a3,0x1d
c0031894:	00d7e7b3          	or	a5,a5,a3
c0031898:	00f62223          	sw	a5,4(a2)
c003189c:	fec512e3          	bne	a0,a2,c0031880 <__trunctfdf2+0x5c>
c00318a0:	01012683          	lw	a3,16(sp)
c00318a4:	00170793          	addi	a5,a4,1
c00318a8:	00369593          	slli	a1,a3,0x3
c00318ac:	000086b7          	lui	a3,0x8
c00318b0:	ffe68693          	addi	a3,a3,-2 # 7ffe <_STACK_SIZE+0x6ffe>
c00318b4:	00b12823          	sw	a1,16(sp)
c00318b8:	00d7f7b3          	and	a5,a5,a3
c00318bc:	1c078063          	beqz	a5,c0031a7c <__trunctfdf2+0x258>
c00318c0:	ffffc7b7          	lui	a5,0xffffc
c00318c4:	40078793          	addi	a5,a5,1024 # ffffc400 <_end+0x37f77b80>
c00318c8:	00f70733          	add	a4,a4,a5
c00318cc:	7fe00793          	li	a5,2046
c00318d0:	20e7c263          	blt	a5,a4,c0031ad4 <__trunctfdf2+0x2b0>
c00318d4:	06e05863          	blez	a4,c0031944 <__trunctfdf2+0x120>
c00318d8:	01812503          	lw	a0,24(sp)
c00318dc:	01c12603          	lw	a2,28(sp)
c00318e0:	01412783          	lw	a5,20(sp)
c00318e4:	01c55693          	srli	a3,a0,0x1c
c00318e8:	00461613          	slli	a2,a2,0x4
c00318ec:	00d66633          	or	a2,a2,a3
c00318f0:	00479693          	slli	a3,a5,0x4
c00318f4:	00b6e6b3          	or	a3,a3,a1
c00318f8:	01c7d793          	srli	a5,a5,0x1c
c00318fc:	00451513          	slli	a0,a0,0x4
c0031900:	00d036b3          	snez	a3,a3
c0031904:	00a7e7b3          	or	a5,a5,a0
c0031908:	00f6e6b3          	or	a3,a3,a5
c003190c:	00c12a23          	sw	a2,20(sp)
c0031910:	00d12823          	sw	a3,16(sp)
c0031914:	01012683          	lw	a3,16(sp)
c0031918:	01412783          	lw	a5,20(sp)
c003191c:	0076f613          	andi	a2,a3,7
c0031920:	1c060063          	beqz	a2,c0031ae0 <__trunctfdf2+0x2bc>
c0031924:	00f6f613          	andi	a2,a3,15
c0031928:	00400593          	li	a1,4
c003192c:	1ab60a63          	beq	a2,a1,c0031ae0 <__trunctfdf2+0x2bc>
c0031930:	00468613          	addi	a2,a3,4
c0031934:	00d636b3          	sltu	a3,a2,a3
c0031938:	00d787b3          	add	a5,a5,a3
c003193c:	00060693          	mv	a3,a2
c0031940:	1a00006f          	j	c0031ae0 <__trunctfdf2+0x2bc>
c0031944:	fcc00793          	li	a5,-52
c0031948:	00f75c63          	bge	a4,a5,c0031960 <__trunctfdf2+0x13c>
c003194c:	00012a23          	sw	zero,20(sp)
c0031950:	00100793          	li	a5,1
c0031954:	00f12823          	sw	a5,16(sp)
c0031958:	00000713          	li	a4,0
c003195c:	fb9ff06f          	j	c0031914 <__trunctfdf2+0xf0>
c0031960:	01c12783          	lw	a5,28(sp)
c0031964:	000808b7          	lui	a7,0x80
c0031968:	00050593          	mv	a1,a0
c003196c:	00f8e8b3          	or	a7,a7,a5
c0031970:	03d00793          	li	a5,61
c0031974:	40e78733          	sub	a4,a5,a4
c0031978:	01112e23          	sw	a7,28(sp)
c003197c:	40575793          	srai	a5,a4,0x5
c0031980:	00000693          	li	a3,0
c0031984:	00000493          	li	s1,0
c0031988:	0005a803          	lw	a6,0(a1)
c003198c:	00168693          	addi	a3,a3,1
c0031990:	00458593          	addi	a1,a1,4
c0031994:	0104e4b3          	or	s1,s1,a6
c0031998:	fed798e3          	bne	a5,a3,c0031988 <__trunctfdf2+0x164>
c003199c:	01f77713          	andi	a4,a4,31
c00319a0:	00279693          	slli	a3,a5,0x2
c00319a4:	02071863          	bnez	a4,c00319d4 <__trunctfdf2+0x1b0>
c00319a8:	00300593          	li	a1,3
c00319ac:	40f585b3          	sub	a1,a1,a5
c00319b0:	00d60833          	add	a6,a2,a3
c00319b4:	00082803          	lw	a6,0(a6)
c00319b8:	00170713          	addi	a4,a4,1
c00319bc:	00460613          	addi	a2,a2,4
c00319c0:	ff062e23          	sw	a6,-4(a2)
c00319c4:	fee5d6e3          	bge	a1,a4,c00319b0 <__trunctfdf2+0x18c>
c00319c8:	00400713          	li	a4,4
c00319cc:	40f707b3          	sub	a5,a4,a5
c00319d0:	0580006f          	j	c0031a28 <__trunctfdf2+0x204>
c00319d4:	ffc00e13          	li	t3,-4
c00319d8:	03c78e33          	mul	t3,a5,t3
c00319dc:	02010613          	addi	a2,sp,32
c00319e0:	00d60633          	add	a2,a2,a3
c00319e4:	ff062603          	lw	a2,-16(a2)
c00319e8:	02000813          	li	a6,32
c00319ec:	40e80833          	sub	a6,a6,a4
c00319f0:	01061633          	sll	a2,a2,a6
c00319f4:	00c4e4b3          	or	s1,s1,a2
c00319f8:	00300613          	li	a2,3
c00319fc:	00d506b3          	add	a3,a0,a3
c0031a00:	00000313          	li	t1,0
c0031a04:	40f60633          	sub	a2,a2,a5
c0031a08:	04c34663          	blt	t1,a2,c0031a54 <__trunctfdf2+0x230>
c0031a0c:	00400693          	li	a3,4
c0031a10:	40f687b3          	sub	a5,a3,a5
c0031a14:	00261613          	slli	a2,a2,0x2
c0031a18:	02010693          	addi	a3,sp,32
c0031a1c:	00c68633          	add	a2,a3,a2
c0031a20:	00e8d733          	srl	a4,a7,a4
c0031a24:	fee62823          	sw	a4,-16(a2)
c0031a28:	00400613          	li	a2,4
c0031a2c:	40f60633          	sub	a2,a2,a5
c0031a30:	00279793          	slli	a5,a5,0x2
c0031a34:	00f50533          	add	a0,a0,a5
c0031a38:	00261613          	slli	a2,a2,0x2
c0031a3c:	00000593          	li	a1,0
c0031a40:	a48ec0ef          	jal	ra,c001dc88 <memset>
c0031a44:	01012703          	lw	a4,16(sp)
c0031a48:	009037b3          	snez	a5,s1
c0031a4c:	00f767b3          	or	a5,a4,a5
c0031a50:	f05ff06f          	j	c0031954 <__trunctfdf2+0x130>
c0031a54:	0006a583          	lw	a1,0(a3)
c0031a58:	0046ae83          	lw	t4,4(a3)
c0031a5c:	01c68f33          	add	t5,a3,t3
c0031a60:	00e5d5b3          	srl	a1,a1,a4
c0031a64:	010e9eb3          	sll	t4,t4,a6
c0031a68:	01d5e5b3          	or	a1,a1,t4
c0031a6c:	00bf2023          	sw	a1,0(t5)
c0031a70:	00130313          	addi	t1,t1,1
c0031a74:	00468693          	addi	a3,a3,4
c0031a78:	f91ff06f          	j	c0031a08 <__trunctfdf2+0x1e4>
c0031a7c:	01412603          	lw	a2,20(sp)
c0031a80:	01812783          	lw	a5,24(sp)
c0031a84:	01c12503          	lw	a0,28(sp)
c0031a88:	00f666b3          	or	a3,a2,a5
c0031a8c:	00a6e6b3          	or	a3,a3,a0
c0031a90:	00b6e6b3          	or	a3,a3,a1
c0031a94:	00071863          	bnez	a4,c0031aa4 <__trunctfdf2+0x280>
c0031a98:	00d036b3          	snez	a3,a3
c0031a9c:	00000793          	li	a5,0
c0031aa0:	e7dff06f          	j	c003191c <__trunctfdf2+0xf8>
c0031aa4:	0c068663          	beqz	a3,c0031b70 <__trunctfdf2+0x34c>
c0031aa8:	01c65693          	srli	a3,a2,0x1c
c0031aac:	00451513          	slli	a0,a0,0x4
c0031ab0:	00479613          	slli	a2,a5,0x4
c0031ab4:	01c7d793          	srli	a5,a5,0x1c
c0031ab8:	00400737          	lui	a4,0x400
c0031abc:	00c6e6b3          	or	a3,a3,a2
c0031ac0:	00a7e7b3          	or	a5,a5,a0
c0031ac4:	00e7e7b3          	or	a5,a5,a4
c0031ac8:	ff86f693          	andi	a3,a3,-8
c0031acc:	7ff00713          	li	a4,2047
c0031ad0:	e4dff06f          	j	c003191c <__trunctfdf2+0xf8>
c0031ad4:	00000793          	li	a5,0
c0031ad8:	00000693          	li	a3,0
c0031adc:	7ff00713          	li	a4,2047
c0031ae0:	00800637          	lui	a2,0x800
c0031ae4:	00c7f633          	and	a2,a5,a2
c0031ae8:	00060e63          	beqz	a2,c0031b04 <__trunctfdf2+0x2e0>
c0031aec:	00170713          	addi	a4,a4,1 # 400001 <_HEAP_SIZE+0x3c0001>
c0031af0:	7ff00613          	li	a2,2047
c0031af4:	08c70263          	beq	a4,a2,c0031b78 <__trunctfdf2+0x354>
c0031af8:	ff800637          	lui	a2,0xff800
c0031afc:	fff60613          	addi	a2,a2,-1 # ff7fffff <_end+0x3777b77f>
c0031b00:	00c7f7b3          	and	a5,a5,a2
c0031b04:	01d79613          	slli	a2,a5,0x1d
c0031b08:	0036d693          	srli	a3,a3,0x3
c0031b0c:	00d666b3          	or	a3,a2,a3
c0031b10:	7ff00613          	li	a2,2047
c0031b14:	0037d793          	srli	a5,a5,0x3
c0031b18:	00c71e63          	bne	a4,a2,c0031b34 <__trunctfdf2+0x310>
c0031b1c:	00f6e6b3          	or	a3,a3,a5
c0031b20:	00000793          	li	a5,0
c0031b24:	00068863          	beqz	a3,c0031b34 <__trunctfdf2+0x310>
c0031b28:	000807b7          	lui	a5,0x80
c0031b2c:	00000693          	li	a3,0
c0031b30:	00000413          	li	s0,0
c0031b34:	01471713          	slli	a4,a4,0x14
c0031b38:	7ff00637          	lui	a2,0x7ff00
c0031b3c:	00c79793          	slli	a5,a5,0xc
c0031b40:	00c77733          	and	a4,a4,a2
c0031b44:	00c7d793          	srli	a5,a5,0xc
c0031b48:	01f41413          	slli	s0,s0,0x1f
c0031b4c:	00f767b3          	or	a5,a4,a5
c0031b50:	02c12083          	lw	ra,44(sp)
c0031b54:	0087e733          	or	a4,a5,s0
c0031b58:	02812403          	lw	s0,40(sp)
c0031b5c:	02412483          	lw	s1,36(sp)
c0031b60:	00068513          	mv	a0,a3
c0031b64:	00070593          	mv	a1,a4
c0031b68:	03010113          	addi	sp,sp,48
c0031b6c:	00008067          	ret
c0031b70:	00000793          	li	a5,0
c0031b74:	f69ff06f          	j	c0031adc <__trunctfdf2+0x2b8>
c0031b78:	00000793          	li	a5,0
c0031b7c:	00000693          	li	a3,0
c0031b80:	f85ff06f          	j	c0031b04 <__trunctfdf2+0x2e0>
