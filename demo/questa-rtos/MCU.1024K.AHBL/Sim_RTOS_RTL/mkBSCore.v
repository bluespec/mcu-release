//
// Generated by Bluespec Compiler, version 2021.12.1-27-g9a7d5e05 (build 9a7d5e05)
//
//
// Ports:
// Name                         I/O  size props
// master1_HADDR                  O    32 reg
// master1_HBURST                 O     3 const
// master1_HMASTLOCK              O     1 const
// master1_HPROT                  O     4 const
// master1_HSIZE                  O     3 reg
// master1_HTRANS                 O     2 reg
// master1_HWDATA                 O    32 reg
// master1_HWRITE                 O     1 reg
// RDY_set_watch_tohost           O     1 reg
// mv_tohost_value                O    32 reg
// RDY_mv_tohost_value            O     1 reg
// RDY_set_verbosity              O     1 const
// CLK                            I     1 clock
// RST_N                          I     1 reset
// master1_HRDATA                 I    32 reg
// master1_HREADY                 I     1
// master1_HRESP                  I     1
// ext_interrupt                  I     1 reg
// sw_interrupt                   I     1 reg
// timer_interrupt                I     1 reg
// set_watch_tohost_watch_tohost  I     1
// set_watch_tohost_tohost_addr   I    32 reg
// set_verbosity_verbosity        I     2 reg
// EN_set_watch_tohost            I     1
// EN_set_verbosity               I     1
//
// No combinational paths from inputs to outputs
//
//

`ifdef BSV_ASSIGNMENT_DELAY
`else
  `define BSV_ASSIGNMENT_DELAY
`endif

`ifdef BSV_POSITIVE_RESET
  `define BSV_RESET_VALUE 1'b1
  `define BSV_RESET_EDGE posedge
`else
  `define BSV_RESET_VALUE 1'b0
  `define BSV_RESET_EDGE negedge
`endif

module mkBSCore(CLK,
		RST_N,

		master1_HADDR,

		master1_HBURST,

		master1_HMASTLOCK,

		master1_HPROT,

		master1_HSIZE,

		master1_HTRANS,

		master1_HWDATA,

		master1_HWRITE,

		master1_HRDATA,

		master1_HREADY,

		master1_HRESP,

		ext_interrupt,

		sw_interrupt,

		timer_interrupt,

		set_watch_tohost_watch_tohost,
		set_watch_tohost_tohost_addr,
		EN_set_watch_tohost,
		RDY_set_watch_tohost,

		mv_tohost_value,
		RDY_mv_tohost_value,

		set_verbosity_verbosity,
		EN_set_verbosity,
		RDY_set_verbosity);
  input  CLK;
  input  RST_N;

  // value method master1_haddr
  output [31 : 0] master1_HADDR;

  // value method master1_hburst
  output [2 : 0] master1_HBURST;

  // value method master1_hmastlock
  output master1_HMASTLOCK;

  // value method master1_hprot
  output [3 : 0] master1_HPROT;

  // value method master1_hsize
  output [2 : 0] master1_HSIZE;

  // value method master1_htrans
  output [1 : 0] master1_HTRANS;

  // value method master1_hwdata
  output [31 : 0] master1_HWDATA;

  // value method master1_hwrite
  output master1_HWRITE;

  // action method master1_hrdata
  input  [31 : 0] master1_HRDATA;

  // action method master1_hready
  input  master1_HREADY;

  // action method master1_hresp
  input  master1_HRESP;

  // action method m_external_interrupt_req
  input  ext_interrupt;

  // action method software_interrupt_req
  input  sw_interrupt;

  // action method timer_interrupt_req
  input  timer_interrupt;

  // action method set_watch_tohost
  input  set_watch_tohost_watch_tohost;
  input  [31 : 0] set_watch_tohost_tohost_addr;
  input  EN_set_watch_tohost;
  output RDY_set_watch_tohost;

  // value method mv_tohost_value
  output [31 : 0] mv_tohost_value;
  output RDY_mv_tohost_value;

  // action method set_verbosity
  input  [1 : 0] set_verbosity_verbosity;
  input  EN_set_verbosity;
  output RDY_set_verbosity;

  // signals for module outputs
  wire [31 : 0] master1_HADDR, master1_HWDATA, mv_tohost_value;
  wire [3 : 0] master1_HPROT;
  wire [2 : 0] master1_HBURST, master1_HSIZE;
  wire [1 : 0] master1_HTRANS;
  wire RDY_mv_tohost_value,
       RDY_set_verbosity,
       RDY_set_watch_tohost,
       master1_HMASTLOCK,
       master1_HWRITE;

  // register coreInReset_isInReset
  reg coreInReset_isInReset;
  wire coreInReset_isInReset$D_IN, coreInReset_isInReset$EN;

  // register rg_last_cpuh
  reg rg_last_cpuh;
  wire rg_last_cpuh$D_IN, rg_last_cpuh$EN;

  // register rg_ldr_reset
  reg [1 : 0] rg_ldr_reset;
  wire [1 : 0] rg_ldr_reset$D_IN;
  wire rg_ldr_reset$EN;

  // register rg_once
  reg rg_once;
  wire rg_once$D_IN, rg_once$EN;

  // register rg_reset_done
  reg rg_reset_done;
  wire rg_reset_done$D_IN, rg_reset_done$EN;

  // ports of submodule core
  wire [31 : 0] core$m0_HADDR,
		core$m0_HRDATA,
		core$m0_HWDATA,
		core$mv_tohost_value,
		core$set_watch_tohost_tohost_addr;
  wire [3 : 0] core$m0_HPROT;
  wire [2 : 0] core$m0_HBURST, core$m0_HSIZE;
  wire [1 : 0] core$m0_HTRANS, core$set_verbosity_verbosity;
  wire core$EN_cpu_reset_server_request_put,
       core$EN_cpu_reset_server_response_get,
       core$EN_set_verbosity,
       core$EN_set_watch_tohost,
       core$RDY_cpu_reset_server_request_put,
       core$RDY_cpu_reset_server_response_get,
       core$RDY_mv_tohost_value,
       core$RDY_set_watch_tohost,
       core$cpu_reset_server_request_put,
       core$ext_interrupt,
       core$m0_HMASTLOCK,
       core$m0_HREADY,
       core$m0_HRESP,
       core$m0_HWRITE,
       core$set_watch_tohost_watch_tohost,
       core$sw_interrupt,
       core$timer_interrupt;

  // ports of submodule ndmIfc
  wire ndmIfc$ASSERT_IN, ndmIfc$OUT_RST;

  // rule scheduling signals
  wire CAN_FIRE_RL_coreInReset_isResetAssertedUpdate,
       CAN_FIRE_RL_rl_once,
       CAN_FIRE_RL_rl_reset_response,
       CAN_FIRE_m_external_interrupt_req,
       CAN_FIRE_master1_hrdata,
       CAN_FIRE_master1_hready,
       CAN_FIRE_master1_hresp,
       CAN_FIRE_set_verbosity,
       CAN_FIRE_set_watch_tohost,
       CAN_FIRE_software_interrupt_req,
       CAN_FIRE_timer_interrupt_req,
       WILL_FIRE_RL_coreInReset_isResetAssertedUpdate,
       WILL_FIRE_RL_rl_once,
       WILL_FIRE_RL_rl_reset_response,
       WILL_FIRE_m_external_interrupt_req,
       WILL_FIRE_master1_hrdata,
       WILL_FIRE_master1_hready,
       WILL_FIRE_master1_hresp,
       WILL_FIRE_set_verbosity,
       WILL_FIRE_set_watch_tohost,
       WILL_FIRE_software_interrupt_req,
       WILL_FIRE_timer_interrupt_req;

  // declarations used by system tasks
  // synopsys translate_off
  reg [31 : 0] v__h679;
  reg [31 : 0] v__h673;
  // synopsys translate_on

  // value method master1_haddr
  assign master1_HADDR = core$m0_HADDR ;

  // value method master1_hburst
  assign master1_HBURST = core$m0_HBURST ;

  // value method master1_hmastlock
  assign master1_HMASTLOCK = core$m0_HMASTLOCK ;

  // value method master1_hprot
  assign master1_HPROT = core$m0_HPROT ;

  // value method master1_hsize
  assign master1_HSIZE = core$m0_HSIZE ;

  // value method master1_htrans
  assign master1_HTRANS = core$m0_HTRANS ;

  // value method master1_hwdata
  assign master1_HWDATA = core$m0_HWDATA ;

  // value method master1_hwrite
  assign master1_HWRITE = core$m0_HWRITE ;

  // action method master1_hrdata
  assign CAN_FIRE_master1_hrdata = 1'd1 ;
  assign WILL_FIRE_master1_hrdata = 1'd1 ;

  // action method master1_hready
  assign CAN_FIRE_master1_hready = 1'd1 ;
  assign WILL_FIRE_master1_hready = 1'd1 ;

  // action method master1_hresp
  assign CAN_FIRE_master1_hresp = 1'd1 ;
  assign WILL_FIRE_master1_hresp = 1'd1 ;

  // action method m_external_interrupt_req
  assign CAN_FIRE_m_external_interrupt_req = 1'd1 ;
  assign WILL_FIRE_m_external_interrupt_req = 1'd1 ;

  // action method software_interrupt_req
  assign CAN_FIRE_software_interrupt_req = 1'd1 ;
  assign WILL_FIRE_software_interrupt_req = 1'd1 ;

  // action method timer_interrupt_req
  assign CAN_FIRE_timer_interrupt_req = 1'd1 ;
  assign WILL_FIRE_timer_interrupt_req = 1'd1 ;

  // action method set_watch_tohost
  assign RDY_set_watch_tohost = core$RDY_set_watch_tohost ;
  assign CAN_FIRE_set_watch_tohost = core$RDY_set_watch_tohost ;
  assign WILL_FIRE_set_watch_tohost = EN_set_watch_tohost ;

  // value method mv_tohost_value
  assign mv_tohost_value = core$mv_tohost_value ;
  assign RDY_mv_tohost_value = core$RDY_mv_tohost_value ;

  // action method set_verbosity
  assign RDY_set_verbosity = 1'd1 ;
  assign CAN_FIRE_set_verbosity = 1'd1 ;
  assign WILL_FIRE_set_verbosity = EN_set_verbosity ;

  // submodule core
  mkCore core(.CLK(CLK),
	      .RST_N(ndmIfc$OUT_RST),
	      .cpu_reset_server_request_put(core$cpu_reset_server_request_put),
	      .ext_interrupt(core$ext_interrupt),
	      .m0_HRDATA(core$m0_HRDATA),
	      .m0_HREADY(core$m0_HREADY),
	      .m0_HRESP(core$m0_HRESP),
	      .set_verbosity_verbosity(core$set_verbosity_verbosity),
	      .set_watch_tohost_tohost_addr(core$set_watch_tohost_tohost_addr),
	      .set_watch_tohost_watch_tohost(core$set_watch_tohost_watch_tohost),
	      .sw_interrupt(core$sw_interrupt),
	      .timer_interrupt(core$timer_interrupt),
	      .EN_cpu_reset_server_request_put(core$EN_cpu_reset_server_request_put),
	      .EN_cpu_reset_server_response_get(core$EN_cpu_reset_server_response_get),
	      .EN_set_verbosity(core$EN_set_verbosity),
	      .EN_set_watch_tohost(core$EN_set_watch_tohost),
	      .RDY_cpu_reset_server_request_put(core$RDY_cpu_reset_server_request_put),
	      .cpu_reset_server_response_get(),
	      .RDY_cpu_reset_server_response_get(core$RDY_cpu_reset_server_response_get),
	      .m0_HADDR(core$m0_HADDR),
	      .m0_HBURST(core$m0_HBURST),
	      .m0_HMASTLOCK(core$m0_HMASTLOCK),
	      .m0_HPROT(core$m0_HPROT),
	      .m0_HSIZE(core$m0_HSIZE),
	      .m0_HTRANS(core$m0_HTRANS),
	      .m0_HWDATA(core$m0_HWDATA),
	      .m0_HWRITE(core$m0_HWRITE),
	      .RDY_set_verbosity(),
	      .RDY_set_watch_tohost(core$RDY_set_watch_tohost),
	      .mv_tohost_value(core$mv_tohost_value),
	      .RDY_mv_tohost_value(core$RDY_mv_tohost_value));

  // submodule ndmIfc
  MakeResetA #(.RSTDELAY(32'd2), .init(1'd0)) ndmIfc(.CLK(CLK),
						     .RST(RST_N),
						     .DST_CLK(CLK),
						     .ASSERT_IN(ndmIfc$ASSERT_IN),
						     .ASSERT_OUT(),
						     .OUT_RST(ndmIfc$OUT_RST));

  // rule RL_rl_once
  assign CAN_FIRE_RL_rl_once =
	     core$RDY_cpu_reset_server_request_put && !rg_once &&
	     !coreInReset_isInReset ;
  assign WILL_FIRE_RL_rl_once = CAN_FIRE_RL_rl_once ;

  // rule RL_rl_reset_response
  assign CAN_FIRE_RL_rl_reset_response =
	     core$RDY_cpu_reset_server_response_get ;
  assign WILL_FIRE_RL_rl_reset_response =
	     core$RDY_cpu_reset_server_response_get ;

  // rule RL_coreInReset_isResetAssertedUpdate
  assign CAN_FIRE_RL_coreInReset_isResetAssertedUpdate =
	     coreInReset_isInReset ;
  assign WILL_FIRE_RL_coreInReset_isResetAssertedUpdate =
	     coreInReset_isInReset ;

  // register coreInReset_isInReset
  assign coreInReset_isInReset$D_IN = 1'd0 ;
  assign coreInReset_isInReset$EN = coreInReset_isInReset ;

  // register rg_last_cpuh
  assign rg_last_cpuh$D_IN = 1'b0 ;
  assign rg_last_cpuh$EN = 1'b0 ;

  // register rg_ldr_reset
  assign rg_ldr_reset$D_IN = 2'd0 ;
  assign rg_ldr_reset$EN = CAN_FIRE_RL_rl_once ;

  // register rg_once
  assign rg_once$D_IN = 1'd1 ;
  assign rg_once$EN = CAN_FIRE_RL_rl_once ;

  // register rg_reset_done
  assign rg_reset_done$D_IN = 1'd1 ;
  assign rg_reset_done$EN = core$RDY_cpu_reset_server_response_get ;

  // submodule core
  assign core$cpu_reset_server_request_put =
	     !rg_ldr_reset[1] || rg_ldr_reset[0] ;
  assign core$ext_interrupt = ext_interrupt ;
  assign core$m0_HRDATA = master1_HRDATA ;
  assign core$m0_HREADY = master1_HREADY ;
  assign core$m0_HRESP = master1_HRESP ;
  assign core$set_verbosity_verbosity = set_verbosity_verbosity ;
  assign core$set_watch_tohost_tohost_addr = set_watch_tohost_tohost_addr ;
  assign core$set_watch_tohost_watch_tohost = set_watch_tohost_watch_tohost ;
  assign core$sw_interrupt = sw_interrupt ;
  assign core$timer_interrupt = timer_interrupt ;
  assign core$EN_cpu_reset_server_request_put = CAN_FIRE_RL_rl_once ;
  assign core$EN_cpu_reset_server_response_get =
	     core$RDY_cpu_reset_server_response_get ;
  assign core$EN_set_verbosity = EN_set_verbosity ;
  assign core$EN_set_watch_tohost = EN_set_watch_tohost ;

  // submodule ndmIfc
  assign ndmIfc$ASSERT_IN = 1'b0 ;

  // handling of inlined registers

  always@(posedge CLK)
  begin
    if (RST_N == `BSV_RESET_VALUE)
      begin
        rg_last_cpuh <= `BSV_ASSIGNMENT_DELAY 1'd0;
	rg_ldr_reset <= `BSV_ASSIGNMENT_DELAY 2'd0;
	rg_once <= `BSV_ASSIGNMENT_DELAY 1'd0;
	rg_reset_done <= `BSV_ASSIGNMENT_DELAY 1'd0;
      end
    else
      begin
        if (rg_last_cpuh$EN)
	  rg_last_cpuh <= `BSV_ASSIGNMENT_DELAY rg_last_cpuh$D_IN;
	if (rg_ldr_reset$EN)
	  rg_ldr_reset <= `BSV_ASSIGNMENT_DELAY rg_ldr_reset$D_IN;
	if (rg_once$EN) rg_once <= `BSV_ASSIGNMENT_DELAY rg_once$D_IN;
	if (rg_reset_done$EN)
	  rg_reset_done <= `BSV_ASSIGNMENT_DELAY rg_reset_done$D_IN;
      end
  end

  always@(posedge CLK or `BSV_RESET_EDGE ndmIfc$OUT_RST)
  if (ndmIfc$OUT_RST == `BSV_RESET_VALUE)
    begin
      coreInReset_isInReset <= `BSV_ASSIGNMENT_DELAY 1'd1;
    end
  else
    begin
      if (coreInReset_isInReset$EN)
	coreInReset_isInReset <= `BSV_ASSIGNMENT_DELAY
	    coreInReset_isInReset$D_IN;
    end

  // synopsys translate_off
  `ifdef BSV_NO_INITIAL_BLOCKS
  `else // not BSV_NO_INITIAL_BLOCKS
  initial
  begin
    coreInReset_isInReset = 1'h0;
    rg_last_cpuh = 1'h0;
    rg_ldr_reset = 2'h2;
    rg_once = 1'h0;
    rg_reset_done = 1'h0;
  end
  `endif // BSV_NO_INITIAL_BLOCKS
  // synopsys translate_on

  // handling of system tasks

  // synopsys translate_off
  always@(negedge CLK)
  begin
    #0;
    if (RST_N != `BSV_RESET_VALUE)
      if (ndmIfc$OUT_RST != `BSV_RESET_VALUE)
	if (WILL_FIRE_RL_rl_once)
	  begin
	    v__h679 = $stime;
	    #0;
	  end
    v__h673 = v__h679 / 32'd10;
    if (RST_N != `BSV_RESET_VALUE)
      if (ndmIfc$OUT_RST != `BSV_RESET_VALUE)
	if (WILL_FIRE_RL_rl_once)
	  $write("%06d:[D]:%m.rl_once: PoR to Core: (running ", v__h673);
    if (RST_N != `BSV_RESET_VALUE)
      if (ndmIfc$OUT_RST != `BSV_RESET_VALUE)
	if (WILL_FIRE_RL_rl_once && rg_ldr_reset[1] && !rg_ldr_reset[0])
	  $write("False");
    if (RST_N != `BSV_RESET_VALUE)
      if (ndmIfc$OUT_RST != `BSV_RESET_VALUE)
	if (WILL_FIRE_RL_rl_once && (!rg_ldr_reset[1] || rg_ldr_reset[0]))
	  $write("True");
    if (RST_N != `BSV_RESET_VALUE)
      if (ndmIfc$OUT_RST != `BSV_RESET_VALUE)
	if (WILL_FIRE_RL_rl_once) $write(")", "\n");
  end
  // synopsys translate_on
endmodule  // mkBSCore

