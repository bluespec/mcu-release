//
// Generated by Bluespec Compiler, version 2021.12.1-27-g9a7d5e05 (build 9a7d5e05)
//
//
// Ports:
// Name                         I/O  size props
// RDY_server_reset_request_put   O     1 reg
// RDY_server_reset_response_get  O     1
// read_csr                       O    33
// mav_csr_write                  O    65
// read_mstatus                   O    32
// csr_trap_actions               O    32
// RDY_csr_trap_actions           O     1 const
// csr_ret_actions                O    32
// RDY_csr_ret_actions            O     1 const
// read_csr_minstret              O    64 reg
// read_csr_mcycle                O    64 reg
// read_misa                      O    28 const
// read_csr_mtime                 O    64 reg
// access_permitted               O     1
// csr_mip_read                   O    32
// interrupt_pending              O     5
// wfi_resume                     O     1
// RDY_debug                      O     1 const
// CLK                            I     1 clock
// RST_N                          I     1 reset
// read_csr_csr_addr              I    12
// mav_csr_write_csr_addr         I    12
// mav_csr_write_word             I    32
// csr_trap_actions_pc            I    32
// csr_trap_actions_interrupt     I     1
// csr_trap_actions_exc_code      I     4
// csr_trap_actions_xtval         I    32
// access_permitted_csr_addr      I    12
// access_permitted_read_not_write  I     1
// m_external_interrupt_req_set_not_clear  I     1 reg
// timer_interrupt_req_set_not_clear  I     1 reg
// software_interrupt_req_set_not_clear  I     1 reg
// EN_server_reset_request_put    I     1
// EN_server_reset_response_get   I     1
// EN_csr_minstret_incr           I     1
// EN_debug                       I     1 unused
// EN_mav_csr_write               I     1
// EN_csr_trap_actions            I     1
// EN_csr_ret_actions             I     1
//
// Combinational paths from inputs to outputs:
//   read_csr_csr_addr -> read_csr
//   (access_permitted_csr_addr,
//    access_permitted_read_not_write) -> access_permitted
//   (mav_csr_write_csr_addr,
//    mav_csr_write_word,
//    EN_mav_csr_write) -> mav_csr_write
//   (csr_trap_actions_interrupt, csr_trap_actions_exc_code) -> csr_trap_actions
//
//

`ifdef BSV_ASSIGNMENT_DELAY
`else
  `define BSV_ASSIGNMENT_DELAY
`endif

`ifdef BSV_POSITIVE_RESET
  `define BSV_RESET_VALUE 1'b1
  `define BSV_RESET_EDGE posedge
`else
  `define BSV_RESET_VALUE 1'b0
  `define BSV_RESET_EDGE negedge
`endif

module mkCSR_RegFile(CLK,
		     RST_N,

		     EN_server_reset_request_put,
		     RDY_server_reset_request_put,

		     EN_server_reset_response_get,
		     RDY_server_reset_response_get,

		     read_csr_csr_addr,
		     read_csr,

		     mav_csr_write_csr_addr,
		     mav_csr_write_word,
		     EN_mav_csr_write,
		     mav_csr_write,

		     read_mstatus,

		     csr_trap_actions_pc,
		     csr_trap_actions_interrupt,
		     csr_trap_actions_exc_code,
		     csr_trap_actions_xtval,
		     EN_csr_trap_actions,
		     csr_trap_actions,
		     RDY_csr_trap_actions,

		     EN_csr_ret_actions,
		     csr_ret_actions,
		     RDY_csr_ret_actions,

		     read_csr_minstret,

		     EN_csr_minstret_incr,

		     read_csr_mcycle,

		     read_misa,

		     read_csr_mtime,

		     access_permitted_csr_addr,
		     access_permitted_read_not_write,
		     access_permitted,

		     csr_mip_read,

		     m_external_interrupt_req_set_not_clear,

		     timer_interrupt_req_set_not_clear,

		     software_interrupt_req_set_not_clear,

		     interrupt_pending,

		     wfi_resume,

		     EN_debug,
		     RDY_debug);
  input  CLK;
  input  RST_N;

  // action method server_reset_request_put
  input  EN_server_reset_request_put;
  output RDY_server_reset_request_put;

  // action method server_reset_response_get
  input  EN_server_reset_response_get;
  output RDY_server_reset_response_get;

  // value method read_csr
  input  [11 : 0] read_csr_csr_addr;
  output [32 : 0] read_csr;

  // actionvalue method mav_csr_write
  input  [11 : 0] mav_csr_write_csr_addr;
  input  [31 : 0] mav_csr_write_word;
  input  EN_mav_csr_write;
  output [64 : 0] mav_csr_write;

  // value method read_mstatus
  output [31 : 0] read_mstatus;

  // actionvalue method csr_trap_actions
  input  [31 : 0] csr_trap_actions_pc;
  input  csr_trap_actions_interrupt;
  input  [3 : 0] csr_trap_actions_exc_code;
  input  [31 : 0] csr_trap_actions_xtval;
  input  EN_csr_trap_actions;
  output [31 : 0] csr_trap_actions;
  output RDY_csr_trap_actions;

  // actionvalue method csr_ret_actions
  input  EN_csr_ret_actions;
  output [31 : 0] csr_ret_actions;
  output RDY_csr_ret_actions;

  // value method read_csr_minstret
  output [63 : 0] read_csr_minstret;

  // action method csr_minstret_incr
  input  EN_csr_minstret_incr;

  // value method read_csr_mcycle
  output [63 : 0] read_csr_mcycle;

  // value method read_misa
  output [27 : 0] read_misa;

  // value method read_csr_mtime
  output [63 : 0] read_csr_mtime;

  // value method access_permitted
  input  [11 : 0] access_permitted_csr_addr;
  input  access_permitted_read_not_write;
  output access_permitted;

  // value method csr_mip_read
  output [31 : 0] csr_mip_read;

  // action method m_external_interrupt_req
  input  m_external_interrupt_req_set_not_clear;

  // action method timer_interrupt_req
  input  timer_interrupt_req_set_not_clear;

  // action method software_interrupt_req
  input  software_interrupt_req_set_not_clear;

  // value method interrupt_pending
  output [4 : 0] interrupt_pending;

  // value method wfi_resume
  output wfi_resume;

  // action method debug
  input  EN_debug;
  output RDY_debug;

  // signals for module outputs
  wire [64 : 0] mav_csr_write;
  wire [63 : 0] read_csr_mcycle, read_csr_minstret, read_csr_mtime;
  wire [32 : 0] read_csr;
  wire [31 : 0] csr_mip_read, csr_ret_actions, csr_trap_actions, read_mstatus;
  wire [27 : 0] read_misa;
  wire [4 : 0] interrupt_pending;
  wire RDY_csr_ret_actions,
       RDY_csr_trap_actions,
       RDY_debug,
       RDY_server_reset_request_put,
       RDY_server_reset_response_get,
       access_permitted,
       wfi_resume;

  // register csr_mstatus_rg_mie
  reg csr_mstatus_rg_mie;
  reg csr_mstatus_rg_mie$D_IN;
  wire csr_mstatus_rg_mie$EN;

  // register csr_mstatus_rg_mpie
  reg csr_mstatus_rg_mpie;
  reg csr_mstatus_rg_mpie$D_IN;
  wire csr_mstatus_rg_mpie$EN;

  // register rg_mcause
  reg [4 : 0] rg_mcause;
  reg [4 : 0] rg_mcause$D_IN;
  wire rg_mcause$EN;

  // register rg_mcycle
  reg [63 : 0] rg_mcycle;
  wire [63 : 0] rg_mcycle$D_IN;
  wire rg_mcycle$EN;

  // register rg_mepc
  reg [31 : 0] rg_mepc;
  wire [31 : 0] rg_mepc$D_IN;
  wire rg_mepc$EN;

  // register rg_minstret
  reg [63 : 0] rg_minstret;
  wire [63 : 0] rg_minstret$D_IN;
  wire rg_minstret$EN;

  // register rg_mscratch
  reg [31 : 0] rg_mscratch;
  wire [31 : 0] rg_mscratch$D_IN;
  wire rg_mscratch$EN;

  // register rg_mtval
  reg [31 : 0] rg_mtval;
  wire [31 : 0] rg_mtval$D_IN;
  wire rg_mtval$EN;

  // register rg_mtvec
  reg [30 : 0] rg_mtvec;
  wire [30 : 0] rg_mtvec$D_IN;
  wire rg_mtvec$EN;

  // register rg_state
  reg rg_state;
  wire rg_state$D_IN, rg_state$EN;

  // ports of submodule addr_map
  wire [31 : 0] addr_map$m_is_dtcm_addr_addr,
		addr_map$m_is_itcm_addr_addr,
		addr_map$m_mtvec_reset_value;

  // ports of submodule csr_mie
  wire [31 : 0] csr_mie$mav_write, csr_mie$mv_read;
  wire [2 : 0] csr_mie$mav_write_mie;
  wire csr_mie$EN_mav_write, csr_mie$EN_reset;

  // ports of submodule csr_mip
  wire [31 : 0] csr_mip$mv_read;
  wire csr_mip$EN_reset,
       csr_mip$m_external_interrupt_req_req,
       csr_mip$m_software_interrupt_req_req,
       csr_mip$m_timer_interrupt_req_req;

  // ports of submodule f_reset_rsps
  wire f_reset_rsps$CLR,
       f_reset_rsps$DEQ,
       f_reset_rsps$EMPTY_N,
       f_reset_rsps$ENQ,
       f_reset_rsps$FULL_N;

  // rule scheduling signals
  wire CAN_FIRE_RL_rl_mcycle_incr,
       CAN_FIRE_RL_rl_reset_start,
       CAN_FIRE_RL_rl_upd_minstret_csrrx,
       CAN_FIRE_RL_rl_upd_minstret_incr,
       CAN_FIRE_csr_minstret_incr,
       CAN_FIRE_csr_ret_actions,
       CAN_FIRE_csr_trap_actions,
       CAN_FIRE_debug,
       CAN_FIRE_m_external_interrupt_req,
       CAN_FIRE_mav_csr_write,
       CAN_FIRE_server_reset_request_put,
       CAN_FIRE_server_reset_response_get,
       CAN_FIRE_software_interrupt_req,
       CAN_FIRE_timer_interrupt_req,
       WILL_FIRE_RL_rl_mcycle_incr,
       WILL_FIRE_RL_rl_reset_start,
       WILL_FIRE_RL_rl_upd_minstret_csrrx,
       WILL_FIRE_RL_rl_upd_minstret_incr,
       WILL_FIRE_csr_minstret_incr,
       WILL_FIRE_csr_ret_actions,
       WILL_FIRE_csr_trap_actions,
       WILL_FIRE_debug,
       WILL_FIRE_m_external_interrupt_req,
       WILL_FIRE_mav_csr_write,
       WILL_FIRE_server_reset_request_put,
       WILL_FIRE_server_reset_response_get,
       WILL_FIRE_software_interrupt_req,
       WILL_FIRE_timer_interrupt_req;

  // inputs to muxes for submodule ports
  wire [63 : 0] MUX_rg_minstret$write_1__VAL_1,
		MUX_rg_minstret$write_1__VAL_2,
		MUX_rw_minstret$wset_1__VAL_1;
  wire [30 : 0] MUX_rg_mtvec$write_1__VAL_1, MUX_rg_mtvec$write_1__VAL_2;
  wire [4 : 0] MUX_rg_mcause$write_1__VAL_2, MUX_rg_mcause$write_1__VAL_3;
  wire MUX_csr_mstatus_rg_mie$write_1__SEL_2,
       MUX_rg_mcause$write_1__SEL_2,
       MUX_rg_mepc$write_1__SEL_1,
       MUX_rg_mtval$write_1__SEL_1,
       MUX_rg_mtvec$write_1__SEL_1,
       MUX_rg_state$write_1__SEL_2,
       MUX_rw_minstret$wset_1__SEL_1;

  // remaining internal signals
  reg [31 : 0] IF_read_csr_csr_addr_EQ_0xF14_8_THEN_0_ELSE_IF_ETC___d80,
	       x__h2009;
  wire [63 : 0] x__h2903, x__h2999;
  wire [31 : 0] exc_pc___1__h3450,
		exc_pc__h3330,
		new_csr_value__h2462,
		v__h2095,
		v__h2350,
		v__h2512,
		vector_offset__h3426,
		x_mv_read__h361;
  wire [7 : 0] new_mstatus__h1903, x__h2213;
  wire [4 : 0] IF_NOT_csr_mip_mv_read__2_BIT_11_88_89_OR_NOT__ETC___d211;

  // action method server_reset_request_put
  assign RDY_server_reset_request_put = f_reset_rsps$FULL_N ;
  assign CAN_FIRE_server_reset_request_put = f_reset_rsps$FULL_N ;
  assign WILL_FIRE_server_reset_request_put = EN_server_reset_request_put ;

  // action method server_reset_response_get
  assign RDY_server_reset_response_get = rg_state && f_reset_rsps$EMPTY_N ;
  assign CAN_FIRE_server_reset_response_get =
	     rg_state && f_reset_rsps$EMPTY_N ;
  assign WILL_FIRE_server_reset_response_get = EN_server_reset_response_get ;

  // value method read_csr
  assign read_csr =
	     { read_csr_csr_addr == 12'hF14 || read_csr_csr_addr == 12'h301 ||
	       read_csr_csr_addr == 12'h300 ||
	       read_csr_csr_addr == 12'h304 ||
	       read_csr_csr_addr == 12'h305 ||
	       read_csr_csr_addr == 12'h340 ||
	       read_csr_csr_addr == 12'h341 ||
	       read_csr_csr_addr == 12'h342 ||
	       read_csr_csr_addr == 12'h343 ||
	       read_csr_csr_addr == 12'h344 ||
	       read_csr_csr_addr == 12'hB00 ||
	       read_csr_csr_addr == 12'hB02 ||
	       read_csr_csr_addr == 12'hB80 ||
	       read_csr_csr_addr == 12'hB82,
	       IF_read_csr_csr_addr_EQ_0xF14_8_THEN_0_ELSE_IF_ETC___d80 } ;

  // actionvalue method mav_csr_write
  assign mav_csr_write = { x__h2009, 33'h0AAAAAAAA } ;
  assign CAN_FIRE_mav_csr_write = 1'd1 ;
  assign WILL_FIRE_mav_csr_write = EN_mav_csr_write ;

  // value method read_mstatus
  assign read_mstatus = { 24'd0, new_mstatus__h1903 } ;

  // actionvalue method csr_trap_actions
  assign csr_trap_actions =
	     (csr_trap_actions_interrupt && rg_mtvec[0]) ?
	       exc_pc___1__h3450 :
	       exc_pc__h3330 ;
  assign RDY_csr_trap_actions = 1'd1 ;
  assign CAN_FIRE_csr_trap_actions = 1'd1 ;
  assign WILL_FIRE_csr_trap_actions = EN_csr_trap_actions ;

  // actionvalue method csr_ret_actions
  assign csr_ret_actions = { rg_mepc[31:1], 1'd0 } ;
  assign RDY_csr_ret_actions = 1'd1 ;
  assign CAN_FIRE_csr_ret_actions = 1'd1 ;
  assign WILL_FIRE_csr_ret_actions = EN_csr_ret_actions ;

  // value method read_csr_minstret
  assign read_csr_minstret = rg_minstret ;

  // action method csr_minstret_incr
  assign CAN_FIRE_csr_minstret_incr = 1'd1 ;
  assign WILL_FIRE_csr_minstret_incr = EN_csr_minstret_incr ;

  // value method read_csr_mcycle
  assign read_csr_mcycle = rg_mcycle ;

  // value method read_misa
  assign read_misa = 28'd67113220 ;

  // value method read_csr_mtime
  assign read_csr_mtime = rg_mcycle ;

  // value method access_permitted
  assign access_permitted =
	     (access_permitted_csr_addr == 12'h300 ||
	      access_permitted_csr_addr == 12'h304 ||
	      access_permitted_csr_addr == 12'h305 ||
	      access_permitted_csr_addr == 12'hF14 ||
	      access_permitted_csr_addr == 12'h341 ||
	      access_permitted_csr_addr == 12'h340 ||
	      access_permitted_csr_addr == 12'h342 ||
	      access_permitted_csr_addr == 12'h343 ||
	      access_permitted_csr_addr == 12'h344 ||
	      access_permitted_csr_addr == 12'hB00 ||
	      access_permitted_csr_addr == 12'hB02 ||
	      access_permitted_csr_addr == 12'hB80 ||
	      access_permitted_csr_addr == 12'hB82) &&
	     (access_permitted_read_not_write ||
	      access_permitted_csr_addr[11:10] != 2'b11) ;

  // value method csr_mip_read
  assign csr_mip_read = csr_mip$mv_read ;

  // action method m_external_interrupt_req
  assign CAN_FIRE_m_external_interrupt_req = 1'd1 ;
  assign WILL_FIRE_m_external_interrupt_req = 1'd1 ;

  // action method timer_interrupt_req
  assign CAN_FIRE_timer_interrupt_req = 1'd1 ;
  assign WILL_FIRE_timer_interrupt_req = 1'd1 ;

  // action method software_interrupt_req
  assign CAN_FIRE_software_interrupt_req = 1'd1 ;
  assign WILL_FIRE_software_interrupt_req = 1'd1 ;

  // value method interrupt_pending
  assign interrupt_pending =
	     ((!csr_mip$mv_read[11] || !csr_mie$mv_read[11] ||
	       !csr_mstatus_rg_mie) &&
	      (!csr_mip$mv_read[3] || !csr_mie$mv_read[3] ||
	       !csr_mstatus_rg_mie)) ?
	       { csr_mip$mv_read[7] && csr_mie$mv_read[7] &&
		 csr_mstatus_rg_mie,
		 4'd7 } :
	       IF_NOT_csr_mip_mv_read__2_BIT_11_88_89_OR_NOT__ETC___d211 ;

  // value method wfi_resume
  assign wfi_resume = (csr_mip$mv_read & csr_mie$mv_read) != 32'd0 ;

  // action method debug
  assign RDY_debug = 1'd1 ;
  assign CAN_FIRE_debug = 1'd1 ;
  assign WILL_FIRE_debug = EN_debug ;

  // submodule addr_map
  mkCore_Map addr_map(.CLK(CLK),
		      .RST_N(RST_N),
		      .m_is_dtcm_addr_addr(addr_map$m_is_dtcm_addr_addr),
		      .m_is_itcm_addr_addr(addr_map$m_is_itcm_addr_addr),
		      .m_itcm_addr_base(),
		      .m_itcm_addr_size(),
		      .m_itcm_addr_lim(),
		      .m_is_itcm_addr(),
		      .m_dtcm_addr_base(),
		      .m_dtcm_addr_size(),
		      .m_dtcm_addr_lim(),
		      .m_is_dtcm_addr(),
		      .m_pc_reset_value(),
		      .m_mtvec_reset_value(addr_map$m_mtvec_reset_value));

  // submodule csr_mie
  mkCSR_MIE csr_mie(.CLK(CLK),
		    .RST_N(RST_N),
		    .mav_write_mie(csr_mie$mav_write_mie),
		    .EN_reset(csr_mie$EN_reset),
		    .EN_mav_write(csr_mie$EN_mav_write),
		    .mv_read(csr_mie$mv_read),
		    .mav_write(csr_mie$mav_write));

  // submodule csr_mip
  mkCSR_MIP csr_mip(.CLK(CLK),
		    .RST_N(RST_N),
		    .m_external_interrupt_req_req(csr_mip$m_external_interrupt_req_req),
		    .m_software_interrupt_req_req(csr_mip$m_software_interrupt_req_req),
		    .m_timer_interrupt_req_req(csr_mip$m_timer_interrupt_req_req),
		    .EN_reset(csr_mip$EN_reset),
		    .mv_read(csr_mip$mv_read));

  // submodule f_reset_rsps
  FIFO20 #(.guarded(1'd1)) f_reset_rsps(.RST(RST_N),
					.CLK(CLK),
					.ENQ(f_reset_rsps$ENQ),
					.DEQ(f_reset_rsps$DEQ),
					.CLR(f_reset_rsps$CLR),
					.FULL_N(f_reset_rsps$FULL_N),
					.EMPTY_N(f_reset_rsps$EMPTY_N));

  // rule RL_rl_reset_start
  assign CAN_FIRE_RL_rl_reset_start = !rg_state ;
  assign WILL_FIRE_RL_rl_reset_start = MUX_rg_state$write_1__SEL_2 ;

  // rule RL_rl_mcycle_incr
  assign CAN_FIRE_RL_rl_mcycle_incr = 1'd1 ;
  assign WILL_FIRE_RL_rl_mcycle_incr = 1'd1 ;

  // rule RL_rl_upd_minstret_csrrx
  assign CAN_FIRE_RL_rl_upd_minstret_csrrx =
	     MUX_rw_minstret$wset_1__SEL_1 || WILL_FIRE_RL_rl_reset_start ;
  assign WILL_FIRE_RL_rl_upd_minstret_csrrx =
	     CAN_FIRE_RL_rl_upd_minstret_csrrx ;

  // rule RL_rl_upd_minstret_incr
  assign CAN_FIRE_RL_rl_upd_minstret_incr =
	     !CAN_FIRE_RL_rl_upd_minstret_csrrx && EN_csr_minstret_incr ;
  assign WILL_FIRE_RL_rl_upd_minstret_incr =
	     CAN_FIRE_RL_rl_upd_minstret_incr ;

  // inputs to muxes for submodule ports
  assign MUX_csr_mstatus_rg_mie$write_1__SEL_2 =
	     EN_mav_csr_write && mav_csr_write_csr_addr == 12'h300 ;
  assign MUX_rg_mcause$write_1__SEL_2 =
	     EN_mav_csr_write && mav_csr_write_csr_addr == 12'h342 ;
  assign MUX_rg_mepc$write_1__SEL_1 =
	     EN_mav_csr_write && mav_csr_write_csr_addr == 12'h341 ;
  assign MUX_rg_mtval$write_1__SEL_1 =
	     EN_mav_csr_write && mav_csr_write_csr_addr == 12'h343 ;
  assign MUX_rg_mtvec$write_1__SEL_1 =
	     EN_mav_csr_write && mav_csr_write_csr_addr == 12'h305 ;
  assign MUX_rg_state$write_1__SEL_2 =
	     CAN_FIRE_RL_rl_reset_start && !EN_mav_csr_write ;
  assign MUX_rw_minstret$wset_1__SEL_1 =
	     EN_mav_csr_write &&
	     (mav_csr_write_csr_addr == 12'hB02 ||
	      mav_csr_write_csr_addr == 12'hB82) ;
  assign MUX_rg_mcause$write_1__VAL_2 =
	     { mav_csr_write_word[31], mav_csr_write_word[3:0] } ;
  assign MUX_rg_mcause$write_1__VAL_3 =
	     { csr_trap_actions_interrupt, csr_trap_actions_exc_code } ;
  assign MUX_rg_minstret$write_1__VAL_1 =
	     MUX_rw_minstret$wset_1__SEL_1 ?
	       MUX_rw_minstret$wset_1__VAL_1 :
	       64'd0 ;
  assign MUX_rg_minstret$write_1__VAL_2 = rg_minstret + 64'd1 ;
  assign MUX_rg_mtvec$write_1__VAL_1 =
	     { mav_csr_write_word[31:2], mav_csr_write_word[0] } ;
  assign MUX_rg_mtvec$write_1__VAL_2 =
	     { addr_map$m_mtvec_reset_value[31:2],
	       addr_map$m_mtvec_reset_value[0] } ;
  assign MUX_rw_minstret$wset_1__VAL_1 =
	     (mav_csr_write_csr_addr == 12'hB02) ? x__h2903 : x__h2999 ;

  // register csr_mstatus_rg_mie
  always@(WILL_FIRE_RL_rl_reset_start or
	  MUX_csr_mstatus_rg_mie$write_1__SEL_2 or
	  mav_csr_write_word or
	  EN_csr_ret_actions or csr_mstatus_rg_mpie or EN_csr_trap_actions)
  case (1'b1)
    WILL_FIRE_RL_rl_reset_start: csr_mstatus_rg_mie$D_IN = 1'b0;
    MUX_csr_mstatus_rg_mie$write_1__SEL_2:
	csr_mstatus_rg_mie$D_IN = mav_csr_write_word[3];
    EN_csr_ret_actions: csr_mstatus_rg_mie$D_IN = csr_mstatus_rg_mpie;
    EN_csr_trap_actions: csr_mstatus_rg_mie$D_IN = 1'b0;
    default: csr_mstatus_rg_mie$D_IN = 1'b0 /* unspecified value */ ;
  endcase
  assign csr_mstatus_rg_mie$EN =
	     EN_mav_csr_write && mav_csr_write_csr_addr == 12'h300 ||
	     EN_csr_ret_actions ||
	     WILL_FIRE_RL_rl_reset_start ||
	     EN_csr_trap_actions ;

  // register csr_mstatus_rg_mpie
  always@(WILL_FIRE_RL_rl_reset_start or
	  MUX_csr_mstatus_rg_mie$write_1__SEL_2 or
	  mav_csr_write_word or
	  EN_csr_ret_actions or EN_csr_trap_actions or csr_mstatus_rg_mie)
  case (1'b1)
    WILL_FIRE_RL_rl_reset_start: csr_mstatus_rg_mpie$D_IN = 1'b0;
    MUX_csr_mstatus_rg_mie$write_1__SEL_2:
	csr_mstatus_rg_mpie$D_IN = mav_csr_write_word[7];
    EN_csr_ret_actions: csr_mstatus_rg_mpie$D_IN = 1'b0;
    EN_csr_trap_actions: csr_mstatus_rg_mpie$D_IN = csr_mstatus_rg_mie;
    default: csr_mstatus_rg_mpie$D_IN = 1'b0 /* unspecified value */ ;
  endcase
  assign csr_mstatus_rg_mpie$EN =
	     EN_mav_csr_write && mav_csr_write_csr_addr == 12'h300 ||
	     EN_csr_trap_actions ||
	     WILL_FIRE_RL_rl_reset_start ||
	     EN_csr_ret_actions ;

  // register rg_mcause
  always@(WILL_FIRE_RL_rl_reset_start or
	  MUX_rg_mcause$write_1__SEL_2 or
	  MUX_rg_mcause$write_1__VAL_2 or
	  EN_csr_trap_actions or MUX_rg_mcause$write_1__VAL_3)
  case (1'b1)
    WILL_FIRE_RL_rl_reset_start: rg_mcause$D_IN = 5'd0;
    MUX_rg_mcause$write_1__SEL_2:
	rg_mcause$D_IN = MUX_rg_mcause$write_1__VAL_2;
    EN_csr_trap_actions: rg_mcause$D_IN = MUX_rg_mcause$write_1__VAL_3;
    default: rg_mcause$D_IN = 5'b01010 /* unspecified value */ ;
  endcase
  assign rg_mcause$EN =
	     EN_mav_csr_write && mav_csr_write_csr_addr == 12'h342 ||
	     EN_csr_trap_actions ||
	     WILL_FIRE_RL_rl_reset_start ;

  // register rg_mcycle
  assign rg_mcycle$D_IN = rg_mcycle + 64'd1 ;
  assign rg_mcycle$EN = 1'd1 ;

  // register rg_mepc
  assign rg_mepc$D_IN =
	     MUX_rg_mepc$write_1__SEL_1 ?
	       new_csr_value__h2462 :
	       csr_trap_actions_pc ;
  assign rg_mepc$EN =
	     EN_mav_csr_write && mav_csr_write_csr_addr == 12'h341 ||
	     EN_csr_trap_actions ;

  // register rg_minstret
  assign rg_minstret$D_IN =
	     WILL_FIRE_RL_rl_upd_minstret_csrrx ?
	       MUX_rg_minstret$write_1__VAL_1 :
	       MUX_rg_minstret$write_1__VAL_2 ;
  assign rg_minstret$EN =
	     WILL_FIRE_RL_rl_upd_minstret_csrrx ||
	     WILL_FIRE_RL_rl_upd_minstret_incr ;

  // register rg_mscratch
  assign rg_mscratch$D_IN = mav_csr_write_word ;
  assign rg_mscratch$EN =
	     EN_mav_csr_write && mav_csr_write_csr_addr == 12'h340 ;

  // register rg_mtval
  assign rg_mtval$D_IN =
	     MUX_rg_mtval$write_1__SEL_1 ?
	       mav_csr_write_word :
	       csr_trap_actions_xtval ;
  assign rg_mtval$EN =
	     EN_mav_csr_write && mav_csr_write_csr_addr == 12'h343 ||
	     EN_csr_trap_actions ;

  // register rg_mtvec
  assign rg_mtvec$D_IN =
	     MUX_rg_mtvec$write_1__SEL_1 ?
	       MUX_rg_mtvec$write_1__VAL_1 :
	       MUX_rg_mtvec$write_1__VAL_2 ;
  assign rg_mtvec$EN =
	     EN_mav_csr_write && mav_csr_write_csr_addr == 12'h305 ||
	     WILL_FIRE_RL_rl_reset_start ;

  // register rg_state
  assign rg_state$D_IN = !EN_server_reset_request_put ;
  assign rg_state$EN =
	     EN_server_reset_request_put || WILL_FIRE_RL_rl_reset_start ;

  // submodule addr_map
  assign addr_map$m_is_dtcm_addr_addr = 32'h0 ;
  assign addr_map$m_is_itcm_addr_addr = 32'h0 ;

  // submodule csr_mie
  assign csr_mie$mav_write_mie =
	     { mav_csr_write_word[11],
	       mav_csr_write_word[7],
	       mav_csr_write_word[3] } ;
  assign csr_mie$EN_reset = MUX_rg_state$write_1__SEL_2 ;
  assign csr_mie$EN_mav_write =
	     EN_mav_csr_write && mav_csr_write_csr_addr == 12'h304 ;

  // submodule csr_mip
  assign csr_mip$m_external_interrupt_req_req =
	     m_external_interrupt_req_set_not_clear ;
  assign csr_mip$m_software_interrupt_req_req =
	     software_interrupt_req_set_not_clear ;
  assign csr_mip$m_timer_interrupt_req_req =
	     timer_interrupt_req_set_not_clear ;
  assign csr_mip$EN_reset = MUX_rg_state$write_1__SEL_2 ;

  // submodule f_reset_rsps
  assign f_reset_rsps$ENQ = EN_server_reset_request_put ;
  assign f_reset_rsps$DEQ = EN_server_reset_response_get ;
  assign f_reset_rsps$CLR = 1'b0 ;

  // remaining internal signals
  assign IF_NOT_csr_mip_mv_read__2_BIT_11_88_89_OR_NOT__ETC___d211 =
	     (!csr_mip$mv_read[11] || !csr_mie$mv_read[11] ||
	      !csr_mstatus_rg_mie) ?
	       { csr_mip$mv_read[3] && csr_mie$mv_read[3] &&
		 csr_mstatus_rg_mie,
		 4'd3 } :
	       { csr_mip$mv_read[11], 4'd11 } ;
  assign exc_pc___1__h3450 = exc_pc__h3330 + vector_offset__h3426 ;
  assign exc_pc__h3330 = { rg_mtvec[30:1], 2'd0 } ;
  assign new_csr_value__h2462 = { mav_csr_write_word[31:2], 2'd0 } ;
  assign new_mstatus__h1903 =
	     { csr_mstatus_rg_mpie, 3'b0, csr_mstatus_rg_mie, 3'b0 } ;
  assign v__h2095 = { 24'd0, x__h2213 } ;
  assign v__h2350 =
	     { mav_csr_write_word[31:2], 1'b0, mav_csr_write_word[0] } ;
  assign v__h2512 =
	     { mav_csr_write_word[31], 27'd0, mav_csr_write_word[3:0] } ;
  assign vector_offset__h3426 = { 26'd0, csr_trap_actions_exc_code, 2'd0 } ;
  assign x__h2213 =
	     { mav_csr_write_word[7], 3'b0, mav_csr_write_word[3], 3'b0 } ;
  assign x__h2903 = { rg_minstret[63:32], mav_csr_write_word } ;
  assign x__h2999 = { mav_csr_write_word, rg_minstret[31:0] } ;
  assign x_mv_read__h361 = { 24'd0, new_mstatus__h1903 } ;
  always@(mav_csr_write_csr_addr or
	  v__h2095 or
	  csr_mie$mav_write or
	  v__h2350 or mav_csr_write_word or new_csr_value__h2462 or v__h2512)
  begin
    case (mav_csr_write_csr_addr)
      12'h300: x__h2009 = v__h2095;
      12'h304: x__h2009 = csr_mie$mav_write;
      12'h305: x__h2009 = v__h2350;
      12'h340, 12'h343, 12'hB00, 12'hB02, 12'hB80, 12'hB82:
	  x__h2009 = mav_csr_write_word;
      12'h341: x__h2009 = new_csr_value__h2462;
      12'h342: x__h2009 = v__h2512;
      default: x__h2009 = 32'd0;
    endcase
  end
  always@(read_csr_csr_addr or
	  rg_minstret or
	  x_mv_read__h361 or
	  csr_mie$mv_read or
	  rg_mtvec or
	  rg_mscratch or
	  rg_mepc or rg_mcause or rg_mtval or csr_mip$mv_read or rg_mcycle)
  begin
    case (read_csr_csr_addr)
      12'h300:
	  IF_read_csr_csr_addr_EQ_0xF14_8_THEN_0_ELSE_IF_ETC___d80 =
	      x_mv_read__h361;
      12'h301:
	  IF_read_csr_csr_addr_EQ_0xF14_8_THEN_0_ELSE_IF_ETC___d80 =
	      32'd1073746180;
      12'h304:
	  IF_read_csr_csr_addr_EQ_0xF14_8_THEN_0_ELSE_IF_ETC___d80 =
	      csr_mie$mv_read;
      12'h305:
	  IF_read_csr_csr_addr_EQ_0xF14_8_THEN_0_ELSE_IF_ETC___d80 =
	      { rg_mtvec[30:1], 1'b0, rg_mtvec[0] };
      12'h340:
	  IF_read_csr_csr_addr_EQ_0xF14_8_THEN_0_ELSE_IF_ETC___d80 =
	      rg_mscratch;
      12'h341:
	  IF_read_csr_csr_addr_EQ_0xF14_8_THEN_0_ELSE_IF_ETC___d80 = rg_mepc;
      12'h342:
	  IF_read_csr_csr_addr_EQ_0xF14_8_THEN_0_ELSE_IF_ETC___d80 =
	      { rg_mcause[4], 27'd0, rg_mcause[3:0] };
      12'h343:
	  IF_read_csr_csr_addr_EQ_0xF14_8_THEN_0_ELSE_IF_ETC___d80 = rg_mtval;
      12'h344:
	  IF_read_csr_csr_addr_EQ_0xF14_8_THEN_0_ELSE_IF_ETC___d80 =
	      csr_mip$mv_read;
      12'hB00:
	  IF_read_csr_csr_addr_EQ_0xF14_8_THEN_0_ELSE_IF_ETC___d80 =
	      rg_mcycle[31:0];
      12'hB02:
	  IF_read_csr_csr_addr_EQ_0xF14_8_THEN_0_ELSE_IF_ETC___d80 =
	      rg_minstret[31:0];
      12'hB80:
	  IF_read_csr_csr_addr_EQ_0xF14_8_THEN_0_ELSE_IF_ETC___d80 =
	      rg_mcycle[63:32];
      12'hF14:
	  IF_read_csr_csr_addr_EQ_0xF14_8_THEN_0_ELSE_IF_ETC___d80 = 32'd0;
      default: IF_read_csr_csr_addr_EQ_0xF14_8_THEN_0_ELSE_IF_ETC___d80 =
		   rg_minstret[63:32];
    endcase
  end

  // handling of inlined registers

  always@(posedge CLK)
  begin
    if (RST_N == `BSV_RESET_VALUE)
      begin
        csr_mstatus_rg_mie <= `BSV_ASSIGNMENT_DELAY 1'd0;
	csr_mstatus_rg_mpie <= `BSV_ASSIGNMENT_DELAY 1'd0;
	rg_mcycle <= `BSV_ASSIGNMENT_DELAY 64'd0;
	rg_minstret <= `BSV_ASSIGNMENT_DELAY 64'd0;
	rg_state <= `BSV_ASSIGNMENT_DELAY 1'd0;
      end
    else
      begin
        if (csr_mstatus_rg_mie$EN)
	  csr_mstatus_rg_mie <= `BSV_ASSIGNMENT_DELAY csr_mstatus_rg_mie$D_IN;
	if (csr_mstatus_rg_mpie$EN)
	  csr_mstatus_rg_mpie <= `BSV_ASSIGNMENT_DELAY
	      csr_mstatus_rg_mpie$D_IN;
	if (rg_mcycle$EN) rg_mcycle <= `BSV_ASSIGNMENT_DELAY rg_mcycle$D_IN;
	if (rg_minstret$EN)
	  rg_minstret <= `BSV_ASSIGNMENT_DELAY rg_minstret$D_IN;
	if (rg_state$EN) rg_state <= `BSV_ASSIGNMENT_DELAY rg_state$D_IN;
      end
    if (rg_mcause$EN) rg_mcause <= `BSV_ASSIGNMENT_DELAY rg_mcause$D_IN;
    if (rg_mepc$EN) rg_mepc <= `BSV_ASSIGNMENT_DELAY rg_mepc$D_IN;
    if (rg_mscratch$EN) rg_mscratch <= `BSV_ASSIGNMENT_DELAY rg_mscratch$D_IN;
    if (rg_mtval$EN) rg_mtval <= `BSV_ASSIGNMENT_DELAY rg_mtval$D_IN;
    if (rg_mtvec$EN) rg_mtvec <= `BSV_ASSIGNMENT_DELAY rg_mtvec$D_IN;
  end

  // synopsys translate_off
  `ifdef BSV_NO_INITIAL_BLOCKS
  `else // not BSV_NO_INITIAL_BLOCKS
  initial
  begin
    csr_mstatus_rg_mie = 1'h0;
    csr_mstatus_rg_mpie = 1'h0;
    rg_mcause = 5'h0A;
    rg_mcycle = 64'hAAAAAAAAAAAAAAAA;
    rg_mepc = 32'hAAAAAAAA;
    rg_minstret = 64'hAAAAAAAAAAAAAAAA;
    rg_mscratch = 32'hAAAAAAAA;
    rg_mtval = 32'hAAAAAAAA;
    rg_mtvec = 31'h2AAAAAAA;
    rg_state = 1'h0;
  end
  `endif // BSV_NO_INITIAL_BLOCKS
  // synopsys translate_on

  // handling of system tasks

  // synopsys translate_off
  always@(negedge CLK)
  begin
    #0;
    if (RST_N != `BSV_RESET_VALUE)
      if (EN_debug) $display("mstatus = 0x%0h", x_mv_read__h361);
    if (RST_N != `BSV_RESET_VALUE)
      if (EN_debug) $display("mip     = 0x%0h", csr_mip$mv_read);
    if (RST_N != `BSV_RESET_VALUE)
      if (EN_debug) $display("mie     = 0x%0h", csr_mie$mv_read);
  end
  // synopsys translate_on
endmodule  // mkCSR_RegFile

