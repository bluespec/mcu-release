//
// Generated by Bluespec Compiler, version 2021.12.1-27-g9a7d5e05 (build 9a7d5e05)
//
//
// Ports:
// Name                         I/O  size props
// RDY_reset                      O     1 const
// ahbl_target_HRDATA             O    32 reg
// ahbl_target_HREADYOUT          O     1
// ahbl_target_HRESP              O     1 const
// axi4_initiator_awvalid         O     1 reg
// axi4_initiator_awid            O     4 reg
// axi4_initiator_awaddr          O    32 reg
// axi4_initiator_awlen           O     8 reg
// axi4_initiator_awsize          O     3 reg
// axi4_initiator_awburst         O     2 reg
// axi4_initiator_awlock          O     1 reg
// axi4_initiator_awcache         O     4 reg
// axi4_initiator_awprot          O     3 reg
// axi4_initiator_awqos           O     4 reg
// axi4_initiator_awregion        O     4 reg
// axi4_initiator_wvalid          O     1 reg
// axi4_initiator_wdata           O    32 reg
// axi4_initiator_wstrb           O     4 reg
// axi4_initiator_wlast           O     1 reg
// axi4_initiator_bready          O     1 reg
// axi4_initiator_arvalid         O     1 reg
// axi4_initiator_arid            O     4 reg
// axi4_initiator_araddr          O    32 reg
// axi4_initiator_arlen           O     8 reg
// axi4_initiator_arsize          O     3 reg
// axi4_initiator_arburst         O     2 reg
// axi4_initiator_arlock          O     1 reg
// axi4_initiator_arcache         O     4 reg
// axi4_initiator_arprot          O     3 reg
// axi4_initiator_arqos           O     4 reg
// axi4_initiator_arregion        O     4 reg
// axi4_initiator_rready          O     1 reg
// CLK                            I     1 clock
// RST_N                          I     1 reset
// ahbl_target_HSEL               I     1
// ahbl_target_HREADY             I     1
// ahbl_target_HADDR              I    32 reg
// ahbl_target_HBURST             I     3 unused
// ahbl_target_HMASTLOCK          I     1 unused
// ahbl_target_HPROT              I     4 unused
// ahbl_target_HSIZE              I     3 reg
// ahbl_target_HTRANS             I     2
// ahbl_target_HWDATA             I    32 reg
// ahbl_target_HWRITE             I     1
// axi4_initiator_awready         I     1
// axi4_initiator_wready          I     1
// axi4_initiator_bvalid          I     1
// axi4_initiator_bid             I     4 reg
// axi4_initiator_bresp           I     2 reg
// axi4_initiator_arready         I     1
// axi4_initiator_rvalid          I     1
// axi4_initiator_rid             I     4 reg
// axi4_initiator_rdata           I    32 reg
// axi4_initiator_rresp           I     2 reg
// axi4_initiator_rlast           I     1 reg
// EN_reset                       I     1
//
// No combinational paths from inputs to outputs
//
//

`ifdef BSV_ASSIGNMENT_DELAY
`else
  `define BSV_ASSIGNMENT_DELAY
`endif

`ifdef BSV_POSITIVE_RESET
  `define BSV_RESET_VALUE 1'b1
  `define BSV_RESET_EDGE posedge
`else
  `define BSV_RESET_VALUE 1'b0
  `define BSV_RESET_EDGE negedge
`endif

module mkAHBL_Target_AXI4_Initiator(CLK,
				    RST_N,

				    EN_reset,
				    RDY_reset,

				    ahbl_target_HSEL,

				    ahbl_target_HREADY,

				    ahbl_target_HADDR,

				    ahbl_target_HBURST,

				    ahbl_target_HMASTLOCK,

				    ahbl_target_HPROT,

				    ahbl_target_HSIZE,

				    ahbl_target_HTRANS,

				    ahbl_target_HWDATA,

				    ahbl_target_HWRITE,

				    ahbl_target_HRDATA,

				    ahbl_target_HREADYOUT,

				    ahbl_target_HRESP,

				    axi4_initiator_awvalid,

				    axi4_initiator_awid,

				    axi4_initiator_awaddr,

				    axi4_initiator_awlen,

				    axi4_initiator_awsize,

				    axi4_initiator_awburst,

				    axi4_initiator_awlock,

				    axi4_initiator_awcache,

				    axi4_initiator_awprot,

				    axi4_initiator_awqos,

				    axi4_initiator_awregion,

				    axi4_initiator_awready,

				    axi4_initiator_wvalid,

				    axi4_initiator_wdata,

				    axi4_initiator_wstrb,

				    axi4_initiator_wlast,

				    axi4_initiator_wready,

				    axi4_initiator_bvalid,
				    axi4_initiator_bid,
				    axi4_initiator_bresp,

				    axi4_initiator_bready,

				    axi4_initiator_arvalid,

				    axi4_initiator_arid,

				    axi4_initiator_araddr,

				    axi4_initiator_arlen,

				    axi4_initiator_arsize,

				    axi4_initiator_arburst,

				    axi4_initiator_arlock,

				    axi4_initiator_arcache,

				    axi4_initiator_arprot,

				    axi4_initiator_arqos,

				    axi4_initiator_arregion,

				    axi4_initiator_arready,

				    axi4_initiator_rvalid,
				    axi4_initiator_rid,
				    axi4_initiator_rdata,
				    axi4_initiator_rresp,
				    axi4_initiator_rlast,

				    axi4_initiator_rready);
  input  CLK;
  input  RST_N;

  // action method reset
  input  EN_reset;
  output RDY_reset;

  // action method ahbl_target_hsel
  input  ahbl_target_HSEL;

  // action method ahbl_target_hready
  input  ahbl_target_HREADY;

  // action method ahbl_target_haddr
  input  [31 : 0] ahbl_target_HADDR;

  // action method ahbl_target_hburst
  input  [2 : 0] ahbl_target_HBURST;

  // action method ahbl_target_hmastlock
  input  ahbl_target_HMASTLOCK;

  // action method ahbl_target_hprot
  input  [3 : 0] ahbl_target_HPROT;

  // action method ahbl_target_hsize
  input  [2 : 0] ahbl_target_HSIZE;

  // action method ahbl_target_htrans
  input  [1 : 0] ahbl_target_HTRANS;

  // action method ahbl_target_hwdata
  input  [31 : 0] ahbl_target_HWDATA;

  // action method ahbl_target_hwrite
  input  ahbl_target_HWRITE;

  // value method ahbl_target_hrdata
  output [31 : 0] ahbl_target_HRDATA;

  // value method ahbl_target_hreadyout
  output ahbl_target_HREADYOUT;

  // value method ahbl_target_hresp
  output ahbl_target_HRESP;

  // value method axi4_initiator_m_awvalid
  output axi4_initiator_awvalid;

  // value method axi4_initiator_m_awid
  output [3 : 0] axi4_initiator_awid;

  // value method axi4_initiator_m_awaddr
  output [31 : 0] axi4_initiator_awaddr;

  // value method axi4_initiator_m_awlen
  output [7 : 0] axi4_initiator_awlen;

  // value method axi4_initiator_m_awsize
  output [2 : 0] axi4_initiator_awsize;

  // value method axi4_initiator_m_awburst
  output [1 : 0] axi4_initiator_awburst;

  // value method axi4_initiator_m_awlock
  output axi4_initiator_awlock;

  // value method axi4_initiator_m_awcache
  output [3 : 0] axi4_initiator_awcache;

  // value method axi4_initiator_m_awprot
  output [2 : 0] axi4_initiator_awprot;

  // value method axi4_initiator_m_awqos
  output [3 : 0] axi4_initiator_awqos;

  // value method axi4_initiator_m_awregion
  output [3 : 0] axi4_initiator_awregion;

  // value method axi4_initiator_m_awuser

  // action method axi4_initiator_m_awready
  input  axi4_initiator_awready;

  // value method axi4_initiator_m_wvalid
  output axi4_initiator_wvalid;

  // value method axi4_initiator_m_wdata
  output [31 : 0] axi4_initiator_wdata;

  // value method axi4_initiator_m_wstrb
  output [3 : 0] axi4_initiator_wstrb;

  // value method axi4_initiator_m_wlast
  output axi4_initiator_wlast;

  // value method axi4_initiator_m_wuser

  // action method axi4_initiator_m_wready
  input  axi4_initiator_wready;

  // action method axi4_initiator_m_bvalid
  input  axi4_initiator_bvalid;
  input  [3 : 0] axi4_initiator_bid;
  input  [1 : 0] axi4_initiator_bresp;

  // value method axi4_initiator_m_bready
  output axi4_initiator_bready;

  // value method axi4_initiator_m_arvalid
  output axi4_initiator_arvalid;

  // value method axi4_initiator_m_arid
  output [3 : 0] axi4_initiator_arid;

  // value method axi4_initiator_m_araddr
  output [31 : 0] axi4_initiator_araddr;

  // value method axi4_initiator_m_arlen
  output [7 : 0] axi4_initiator_arlen;

  // value method axi4_initiator_m_arsize
  output [2 : 0] axi4_initiator_arsize;

  // value method axi4_initiator_m_arburst
  output [1 : 0] axi4_initiator_arburst;

  // value method axi4_initiator_m_arlock
  output axi4_initiator_arlock;

  // value method axi4_initiator_m_arcache
  output [3 : 0] axi4_initiator_arcache;

  // value method axi4_initiator_m_arprot
  output [2 : 0] axi4_initiator_arprot;

  // value method axi4_initiator_m_arqos
  output [3 : 0] axi4_initiator_arqos;

  // value method axi4_initiator_m_arregion
  output [3 : 0] axi4_initiator_arregion;

  // value method axi4_initiator_m_aruser

  // action method axi4_initiator_m_arready
  input  axi4_initiator_arready;

  // action method axi4_initiator_m_rvalid
  input  axi4_initiator_rvalid;
  input  [3 : 0] axi4_initiator_rid;
  input  [31 : 0] axi4_initiator_rdata;
  input  [1 : 0] axi4_initiator_rresp;
  input  axi4_initiator_rlast;

  // value method axi4_initiator_m_rready
  output axi4_initiator_rready;

  // signals for module outputs
  wire [31 : 0] ahbl_target_HRDATA,
		axi4_initiator_araddr,
		axi4_initiator_awaddr,
		axi4_initiator_wdata;
  wire [7 : 0] axi4_initiator_arlen, axi4_initiator_awlen;
  wire [3 : 0] axi4_initiator_arcache,
	       axi4_initiator_arid,
	       axi4_initiator_arqos,
	       axi4_initiator_arregion,
	       axi4_initiator_awcache,
	       axi4_initiator_awid,
	       axi4_initiator_awqos,
	       axi4_initiator_awregion,
	       axi4_initiator_wstrb;
  wire [2 : 0] axi4_initiator_arprot,
	       axi4_initiator_arsize,
	       axi4_initiator_awprot,
	       axi4_initiator_awsize;
  wire [1 : 0] axi4_initiator_arburst, axi4_initiator_awburst;
  wire RDY_reset,
       ahbl_target_HREADYOUT,
       ahbl_target_HRESP,
       axi4_initiator_arlock,
       axi4_initiator_arvalid,
       axi4_initiator_awlock,
       axi4_initiator_awvalid,
       axi4_initiator_bready,
       axi4_initiator_rready,
       axi4_initiator_wlast,
       axi4_initiator_wvalid;

  // register rg_rdata
  reg [31 : 0] rg_rdata;
  wire [31 : 0] rg_rdata$D_IN;
  wire rg_rdata$EN;

  // register rg_state
  reg [1 : 0] rg_state;
  wire [1 : 0] rg_state$D_IN;
  wire rg_state$EN;

  // register rg_wr_rsps_pending
  reg [1 : 0] rg_wr_rsps_pending;
  wire [1 : 0] rg_wr_rsps_pending$D_IN;
  wire rg_wr_rsps_pending$EN;

  // register rg_write_error
  reg rg_write_error;
  wire rg_write_error$D_IN, rg_write_error$EN;

  // ports of submodule f_rd_rsp_control
  wire [11 : 0] f_rd_rsp_control$D_IN;
  wire f_rd_rsp_control$CLR,
       f_rd_rsp_control$DEQ,
       f_rd_rsp_control$EMPTY_N,
       f_rd_rsp_control$ENQ,
       f_rd_rsp_control$FULL_N;

  // ports of submodule f_wr_data_control
  wire [13 : 0] f_wr_data_control$D_IN, f_wr_data_control$D_OUT;
  wire f_wr_data_control$CLR,
       f_wr_data_control$DEQ,
       f_wr_data_control$EMPTY_N,
       f_wr_data_control$ENQ,
       f_wr_data_control$FULL_N;

  // ports of submodule master_xactor_f_rd_addr
  wire [64 : 0] master_xactor_f_rd_addr$D_IN, master_xactor_f_rd_addr$D_OUT;
  wire master_xactor_f_rd_addr$CLR,
       master_xactor_f_rd_addr$DEQ,
       master_xactor_f_rd_addr$EMPTY_N,
       master_xactor_f_rd_addr$ENQ,
       master_xactor_f_rd_addr$FULL_N;

  // ports of submodule master_xactor_f_rd_data
  wire [38 : 0] master_xactor_f_rd_data$D_IN, master_xactor_f_rd_data$D_OUT;
  wire master_xactor_f_rd_data$CLR,
       master_xactor_f_rd_data$DEQ,
       master_xactor_f_rd_data$EMPTY_N,
       master_xactor_f_rd_data$ENQ,
       master_xactor_f_rd_data$FULL_N;

  // ports of submodule master_xactor_f_wr_addr
  wire [64 : 0] master_xactor_f_wr_addr$D_IN, master_xactor_f_wr_addr$D_OUT;
  wire master_xactor_f_wr_addr$CLR,
       master_xactor_f_wr_addr$DEQ,
       master_xactor_f_wr_addr$EMPTY_N,
       master_xactor_f_wr_addr$ENQ,
       master_xactor_f_wr_addr$FULL_N;

  // ports of submodule master_xactor_f_wr_data
  wire [36 : 0] master_xactor_f_wr_data$D_IN, master_xactor_f_wr_data$D_OUT;
  wire master_xactor_f_wr_data$CLR,
       master_xactor_f_wr_data$DEQ,
       master_xactor_f_wr_data$EMPTY_N,
       master_xactor_f_wr_data$ENQ,
       master_xactor_f_wr_data$FULL_N;

  // ports of submodule master_xactor_f_wr_resp
  wire [5 : 0] master_xactor_f_wr_resp$D_IN, master_xactor_f_wr_resp$D_OUT;
  wire master_xactor_f_wr_resp$CLR,
       master_xactor_f_wr_resp$DEQ,
       master_xactor_f_wr_resp$EMPTY_N,
       master_xactor_f_wr_resp$ENQ,
       master_xactor_f_wr_resp$FULL_N;

  // rule scheduling signals
  wire CAN_FIRE_RL_rl_ahbl_new_req,
       CAN_FIRE_RL_rl_rdata,
       CAN_FIRE_RL_rl_write_data,
       CAN_FIRE_RL_rl_write_rsp,
       CAN_FIRE_ahbl_target_haddr,
       CAN_FIRE_ahbl_target_hburst,
       CAN_FIRE_ahbl_target_hmastlock,
       CAN_FIRE_ahbl_target_hprot,
       CAN_FIRE_ahbl_target_hready,
       CAN_FIRE_ahbl_target_hsel,
       CAN_FIRE_ahbl_target_hsize,
       CAN_FIRE_ahbl_target_htrans,
       CAN_FIRE_ahbl_target_hwdata,
       CAN_FIRE_ahbl_target_hwrite,
       CAN_FIRE_axi4_initiator_m_arready,
       CAN_FIRE_axi4_initiator_m_awready,
       CAN_FIRE_axi4_initiator_m_bvalid,
       CAN_FIRE_axi4_initiator_m_rvalid,
       CAN_FIRE_axi4_initiator_m_wready,
       CAN_FIRE_reset,
       WILL_FIRE_RL_rl_ahbl_new_req,
       WILL_FIRE_RL_rl_rdata,
       WILL_FIRE_RL_rl_write_data,
       WILL_FIRE_RL_rl_write_rsp,
       WILL_FIRE_ahbl_target_haddr,
       WILL_FIRE_ahbl_target_hburst,
       WILL_FIRE_ahbl_target_hmastlock,
       WILL_FIRE_ahbl_target_hprot,
       WILL_FIRE_ahbl_target_hready,
       WILL_FIRE_ahbl_target_hsel,
       WILL_FIRE_ahbl_target_hsize,
       WILL_FIRE_ahbl_target_htrans,
       WILL_FIRE_ahbl_target_hwdata,
       WILL_FIRE_ahbl_target_hwrite,
       WILL_FIRE_axi4_initiator_m_arready,
       WILL_FIRE_axi4_initiator_m_awready,
       WILL_FIRE_axi4_initiator_m_bvalid,
       WILL_FIRE_axi4_initiator_m_rvalid,
       WILL_FIRE_axi4_initiator_m_wready,
       WILL_FIRE_reset;

  // inputs to muxes for submodule ports
  wire [1 : 0] MUX_rg_state$write_1__VAL_4,
	       MUX_rg_wr_rsps_pending$write_1__VAL_1,
	       MUX_rg_wr_rsps_pending$write_1__VAL_2;
  wire MUX_rg_wr_rsps_pending$write_1__SEL_1;

  // declarations used by system tasks
  // synopsys translate_off
  reg [31 : 0] v__h2232;
  reg [31 : 0] v__h2226;
  // synopsys translate_on

  // remaining internal signals
  reg [3 : 0] strb__h1818;
  wire IF_w_hwrite_wget_THEN_master_xactor_f_wr_addr__ETC___d16,
       w_hsel_wget_AND_w_hready_in_wget_1_AND_NOT_w_h_ETC___d24,
       w_hsel_wget_AND_w_hready_in_wget_1_AND_NOT_w_h_ETC___d34;

  // action method reset
  assign RDY_reset = 1'd1 ;
  assign CAN_FIRE_reset = 1'd1 ;
  assign WILL_FIRE_reset = EN_reset ;

  // action method ahbl_target_hsel
  assign CAN_FIRE_ahbl_target_hsel = 1'd1 ;
  assign WILL_FIRE_ahbl_target_hsel = 1'd1 ;

  // action method ahbl_target_hready
  assign CAN_FIRE_ahbl_target_hready = 1'd1 ;
  assign WILL_FIRE_ahbl_target_hready = 1'd1 ;

  // action method ahbl_target_haddr
  assign CAN_FIRE_ahbl_target_haddr = 1'd1 ;
  assign WILL_FIRE_ahbl_target_haddr = 1'd1 ;

  // action method ahbl_target_hburst
  assign CAN_FIRE_ahbl_target_hburst = 1'd1 ;
  assign WILL_FIRE_ahbl_target_hburst = 1'd1 ;

  // action method ahbl_target_hmastlock
  assign CAN_FIRE_ahbl_target_hmastlock = 1'd1 ;
  assign WILL_FIRE_ahbl_target_hmastlock = 1'd1 ;

  // action method ahbl_target_hprot
  assign CAN_FIRE_ahbl_target_hprot = 1'd1 ;
  assign WILL_FIRE_ahbl_target_hprot = 1'd1 ;

  // action method ahbl_target_hsize
  assign CAN_FIRE_ahbl_target_hsize = 1'd1 ;
  assign WILL_FIRE_ahbl_target_hsize = 1'd1 ;

  // action method ahbl_target_htrans
  assign CAN_FIRE_ahbl_target_htrans = 1'd1 ;
  assign WILL_FIRE_ahbl_target_htrans = 1'd1 ;

  // action method ahbl_target_hwdata
  assign CAN_FIRE_ahbl_target_hwdata = 1'd1 ;
  assign WILL_FIRE_ahbl_target_hwdata = 1'd1 ;

  // action method ahbl_target_hwrite
  assign CAN_FIRE_ahbl_target_hwrite = 1'd1 ;
  assign WILL_FIRE_ahbl_target_hwrite = 1'd1 ;

  // value method ahbl_target_hrdata
  assign ahbl_target_HRDATA = rg_rdata ;

  // value method ahbl_target_hreadyout
  assign ahbl_target_HREADYOUT = rg_state == 2'd0 ;

  // value method ahbl_target_hresp
  assign ahbl_target_HRESP = 1'd0 ;

  // value method axi4_initiator_m_awvalid
  assign axi4_initiator_awvalid = master_xactor_f_wr_addr$EMPTY_N ;

  // value method axi4_initiator_m_awid
  assign axi4_initiator_awid = master_xactor_f_wr_addr$D_OUT[64:61] ;

  // value method axi4_initiator_m_awaddr
  assign axi4_initiator_awaddr = master_xactor_f_wr_addr$D_OUT[60:29] ;

  // value method axi4_initiator_m_awlen
  assign axi4_initiator_awlen = master_xactor_f_wr_addr$D_OUT[28:21] ;

  // value method axi4_initiator_m_awsize
  assign axi4_initiator_awsize = master_xactor_f_wr_addr$D_OUT[20:18] ;

  // value method axi4_initiator_m_awburst
  assign axi4_initiator_awburst = master_xactor_f_wr_addr$D_OUT[17:16] ;

  // value method axi4_initiator_m_awlock
  assign axi4_initiator_awlock = master_xactor_f_wr_addr$D_OUT[15] ;

  // value method axi4_initiator_m_awcache
  assign axi4_initiator_awcache = master_xactor_f_wr_addr$D_OUT[14:11] ;

  // value method axi4_initiator_m_awprot
  assign axi4_initiator_awprot = master_xactor_f_wr_addr$D_OUT[10:8] ;

  // value method axi4_initiator_m_awqos
  assign axi4_initiator_awqos = master_xactor_f_wr_addr$D_OUT[7:4] ;

  // value method axi4_initiator_m_awregion
  assign axi4_initiator_awregion = master_xactor_f_wr_addr$D_OUT[3:0] ;

  // action method axi4_initiator_m_awready
  assign CAN_FIRE_axi4_initiator_m_awready = 1'd1 ;
  assign WILL_FIRE_axi4_initiator_m_awready = 1'd1 ;

  // value method axi4_initiator_m_wvalid
  assign axi4_initiator_wvalid = master_xactor_f_wr_data$EMPTY_N ;

  // value method axi4_initiator_m_wdata
  assign axi4_initiator_wdata = master_xactor_f_wr_data$D_OUT[36:5] ;

  // value method axi4_initiator_m_wstrb
  assign axi4_initiator_wstrb = master_xactor_f_wr_data$D_OUT[4:1] ;

  // value method axi4_initiator_m_wlast
  assign axi4_initiator_wlast = master_xactor_f_wr_data$D_OUT[0] ;

  // action method axi4_initiator_m_wready
  assign CAN_FIRE_axi4_initiator_m_wready = 1'd1 ;
  assign WILL_FIRE_axi4_initiator_m_wready = 1'd1 ;

  // action method axi4_initiator_m_bvalid
  assign CAN_FIRE_axi4_initiator_m_bvalid = 1'd1 ;
  assign WILL_FIRE_axi4_initiator_m_bvalid = 1'd1 ;

  // value method axi4_initiator_m_bready
  assign axi4_initiator_bready = master_xactor_f_wr_resp$FULL_N ;

  // value method axi4_initiator_m_arvalid
  assign axi4_initiator_arvalid = master_xactor_f_rd_addr$EMPTY_N ;

  // value method axi4_initiator_m_arid
  assign axi4_initiator_arid = master_xactor_f_rd_addr$D_OUT[64:61] ;

  // value method axi4_initiator_m_araddr
  assign axi4_initiator_araddr = master_xactor_f_rd_addr$D_OUT[60:29] ;

  // value method axi4_initiator_m_arlen
  assign axi4_initiator_arlen = master_xactor_f_rd_addr$D_OUT[28:21] ;

  // value method axi4_initiator_m_arsize
  assign axi4_initiator_arsize = master_xactor_f_rd_addr$D_OUT[20:18] ;

  // value method axi4_initiator_m_arburst
  assign axi4_initiator_arburst = master_xactor_f_rd_addr$D_OUT[17:16] ;

  // value method axi4_initiator_m_arlock
  assign axi4_initiator_arlock = master_xactor_f_rd_addr$D_OUT[15] ;

  // value method axi4_initiator_m_arcache
  assign axi4_initiator_arcache = master_xactor_f_rd_addr$D_OUT[14:11] ;

  // value method axi4_initiator_m_arprot
  assign axi4_initiator_arprot = master_xactor_f_rd_addr$D_OUT[10:8] ;

  // value method axi4_initiator_m_arqos
  assign axi4_initiator_arqos = master_xactor_f_rd_addr$D_OUT[7:4] ;

  // value method axi4_initiator_m_arregion
  assign axi4_initiator_arregion = master_xactor_f_rd_addr$D_OUT[3:0] ;

  // action method axi4_initiator_m_arready
  assign CAN_FIRE_axi4_initiator_m_arready = 1'd1 ;
  assign WILL_FIRE_axi4_initiator_m_arready = 1'd1 ;

  // action method axi4_initiator_m_rvalid
  assign CAN_FIRE_axi4_initiator_m_rvalid = 1'd1 ;
  assign WILL_FIRE_axi4_initiator_m_rvalid = 1'd1 ;

  // value method axi4_initiator_m_rready
  assign axi4_initiator_rready = master_xactor_f_rd_data$FULL_N ;

  // submodule f_rd_rsp_control
  FIFO1 #(.width(32'd12), .guarded(1'd1)) f_rd_rsp_control(.RST(RST_N),
							   .CLK(CLK),
							   .D_IN(f_rd_rsp_control$D_IN),
							   .ENQ(f_rd_rsp_control$ENQ),
							   .DEQ(f_rd_rsp_control$DEQ),
							   .CLR(f_rd_rsp_control$CLR),
							   .D_OUT(),
							   .FULL_N(f_rd_rsp_control$FULL_N),
							   .EMPTY_N(f_rd_rsp_control$EMPTY_N));

  // submodule f_wr_data_control
  FIFO1 #(.width(32'd14), .guarded(1'd1)) f_wr_data_control(.RST(RST_N),
							    .CLK(CLK),
							    .D_IN(f_wr_data_control$D_IN),
							    .ENQ(f_wr_data_control$ENQ),
							    .DEQ(f_wr_data_control$DEQ),
							    .CLR(f_wr_data_control$CLR),
							    .D_OUT(f_wr_data_control$D_OUT),
							    .FULL_N(f_wr_data_control$FULL_N),
							    .EMPTY_N(f_wr_data_control$EMPTY_N));

  // submodule master_xactor_f_rd_addr
  FIFO2 #(.width(32'd65), .guarded(1'd1)) master_xactor_f_rd_addr(.RST(RST_N),
								  .CLK(CLK),
								  .D_IN(master_xactor_f_rd_addr$D_IN),
								  .ENQ(master_xactor_f_rd_addr$ENQ),
								  .DEQ(master_xactor_f_rd_addr$DEQ),
								  .CLR(master_xactor_f_rd_addr$CLR),
								  .D_OUT(master_xactor_f_rd_addr$D_OUT),
								  .FULL_N(master_xactor_f_rd_addr$FULL_N),
								  .EMPTY_N(master_xactor_f_rd_addr$EMPTY_N));

  // submodule master_xactor_f_rd_data
  FIFO2 #(.width(32'd39), .guarded(1'd1)) master_xactor_f_rd_data(.RST(RST_N),
								  .CLK(CLK),
								  .D_IN(master_xactor_f_rd_data$D_IN),
								  .ENQ(master_xactor_f_rd_data$ENQ),
								  .DEQ(master_xactor_f_rd_data$DEQ),
								  .CLR(master_xactor_f_rd_data$CLR),
								  .D_OUT(master_xactor_f_rd_data$D_OUT),
								  .FULL_N(master_xactor_f_rd_data$FULL_N),
								  .EMPTY_N(master_xactor_f_rd_data$EMPTY_N));

  // submodule master_xactor_f_wr_addr
  FIFO2 #(.width(32'd65), .guarded(1'd1)) master_xactor_f_wr_addr(.RST(RST_N),
								  .CLK(CLK),
								  .D_IN(master_xactor_f_wr_addr$D_IN),
								  .ENQ(master_xactor_f_wr_addr$ENQ),
								  .DEQ(master_xactor_f_wr_addr$DEQ),
								  .CLR(master_xactor_f_wr_addr$CLR),
								  .D_OUT(master_xactor_f_wr_addr$D_OUT),
								  .FULL_N(master_xactor_f_wr_addr$FULL_N),
								  .EMPTY_N(master_xactor_f_wr_addr$EMPTY_N));

  // submodule master_xactor_f_wr_data
  FIFO2 #(.width(32'd37), .guarded(1'd1)) master_xactor_f_wr_data(.RST(RST_N),
								  .CLK(CLK),
								  .D_IN(master_xactor_f_wr_data$D_IN),
								  .ENQ(master_xactor_f_wr_data$ENQ),
								  .DEQ(master_xactor_f_wr_data$DEQ),
								  .CLR(master_xactor_f_wr_data$CLR),
								  .D_OUT(master_xactor_f_wr_data$D_OUT),
								  .FULL_N(master_xactor_f_wr_data$FULL_N),
								  .EMPTY_N(master_xactor_f_wr_data$EMPTY_N));

  // submodule master_xactor_f_wr_resp
  FIFO2 #(.width(32'd6), .guarded(1'd1)) master_xactor_f_wr_resp(.RST(RST_N),
								 .CLK(CLK),
								 .D_IN(master_xactor_f_wr_resp$D_IN),
								 .ENQ(master_xactor_f_wr_resp$ENQ),
								 .DEQ(master_xactor_f_wr_resp$DEQ),
								 .CLR(master_xactor_f_wr_resp$CLR),
								 .D_OUT(master_xactor_f_wr_resp$D_OUT),
								 .FULL_N(master_xactor_f_wr_resp$FULL_N),
								 .EMPTY_N(master_xactor_f_wr_resp$EMPTY_N));

  // rule RL_rl_ahbl_new_req
  assign CAN_FIRE_RL_rl_ahbl_new_req =
	     (!ahbl_target_HSEL || !ahbl_target_HREADY ||
	      ahbl_target_HTRANS == 2'd0 ||
	      IF_w_hwrite_wget_THEN_master_xactor_f_wr_addr__ETC___d16) &&
	     rg_state == 2'd0 ;
  assign WILL_FIRE_RL_rl_ahbl_new_req = CAN_FIRE_RL_rl_ahbl_new_req ;

  // rule RL_rl_write_data
  assign CAN_FIRE_RL_rl_write_data =
	     f_wr_data_control$EMPTY_N && master_xactor_f_wr_data$FULL_N &&
	     rg_state == 2'd1 ;
  assign WILL_FIRE_RL_rl_write_data = CAN_FIRE_RL_rl_write_data ;

  // rule RL_rl_rdata
  assign CAN_FIRE_RL_rl_rdata =
	     master_xactor_f_rd_data$EMPTY_N && f_rd_rsp_control$EMPTY_N &&
	     rg_state == 2'd2 ;
  assign WILL_FIRE_RL_rl_rdata = CAN_FIRE_RL_rl_rdata ;

  // rule RL_rl_write_rsp
  assign CAN_FIRE_RL_rl_write_rsp = master_xactor_f_wr_resp$EMPTY_N ;
  assign WILL_FIRE_RL_rl_write_rsp =
	     master_xactor_f_wr_resp$EMPTY_N &&
	     !WILL_FIRE_RL_rl_ahbl_new_req ;

  // inputs to muxes for submodule ports
  assign MUX_rg_wr_rsps_pending$write_1__SEL_1 =
	     WILL_FIRE_RL_rl_ahbl_new_req &&
	     w_hsel_wget_AND_w_hready_in_wget_1_AND_NOT_w_h_ETC___d24 ;
  assign MUX_rg_state$write_1__VAL_4 =
	     (ahbl_target_HSEL && ahbl_target_HREADY &&
	      ahbl_target_HTRANS != 2'd0) ?
	       (ahbl_target_HWRITE ? 2'd1 : 2'd2) :
	       rg_state ;
  assign MUX_rg_wr_rsps_pending$write_1__VAL_1 = rg_wr_rsps_pending + 2'd1 ;
  assign MUX_rg_wr_rsps_pending$write_1__VAL_2 = rg_wr_rsps_pending - 2'd1 ;

  // register rg_rdata
  assign rg_rdata$D_IN = master_xactor_f_rd_data$D_OUT[34:3] ;
  assign rg_rdata$EN = CAN_FIRE_RL_rl_rdata ;

  // register rg_state
  assign rg_state$D_IN =
	     (EN_reset || WILL_FIRE_RL_rl_rdata ||
	      WILL_FIRE_RL_rl_write_data) ?
	       2'd0 :
	       MUX_rg_state$write_1__VAL_4 ;
  assign rg_state$EN =
	     WILL_FIRE_RL_rl_ahbl_new_req || WILL_FIRE_RL_rl_rdata ||
	     WILL_FIRE_RL_rl_write_data ||
	     EN_reset ;

  // register rg_wr_rsps_pending
  assign rg_wr_rsps_pending$D_IN =
	     MUX_rg_wr_rsps_pending$write_1__SEL_1 ?
	       MUX_rg_wr_rsps_pending$write_1__VAL_1 :
	       MUX_rg_wr_rsps_pending$write_1__VAL_2 ;
  assign rg_wr_rsps_pending$EN =
	     WILL_FIRE_RL_rl_ahbl_new_req &&
	     w_hsel_wget_AND_w_hready_in_wget_1_AND_NOT_w_h_ETC___d24 ||
	     WILL_FIRE_RL_rl_write_rsp && rg_wr_rsps_pending != 2'd0 ;

  // register rg_write_error
  assign rg_write_error$D_IN = 1'd1 ;
  assign rg_write_error$EN =
	     WILL_FIRE_RL_rl_write_rsp &&
	     (rg_wr_rsps_pending == 2'd0 ||
	      master_xactor_f_wr_resp$D_OUT[1:0] != 2'b0) ;

  // submodule f_rd_rsp_control
  assign f_rd_rsp_control$D_IN =
	     { ahbl_target_HSIZE, ahbl_target_HADDR[2], 8'd1 } ;
  assign f_rd_rsp_control$ENQ =
	     WILL_FIRE_RL_rl_ahbl_new_req &&
	     w_hsel_wget_AND_w_hready_in_wget_1_AND_NOT_w_h_ETC___d34 ;
  assign f_rd_rsp_control$DEQ = CAN_FIRE_RL_rl_rdata ;
  assign f_rd_rsp_control$CLR = 1'b0 ;

  // submodule f_wr_data_control
  assign f_wr_data_control$D_IN =
	     { ahbl_target_HSIZE, ahbl_target_HADDR[2:0], 8'd1 } ;
  assign f_wr_data_control$ENQ = MUX_rg_wr_rsps_pending$write_1__SEL_1 ;
  assign f_wr_data_control$DEQ = CAN_FIRE_RL_rl_write_data ;
  assign f_wr_data_control$CLR = 1'b0 ;

  // submodule master_xactor_f_rd_addr
  assign master_xactor_f_rd_addr$D_IN =
	     { 4'd0, ahbl_target_HADDR, 8'd0, ahbl_target_HSIZE, 18'd65536 } ;
  assign master_xactor_f_rd_addr$ENQ =
	     WILL_FIRE_RL_rl_ahbl_new_req &&
	     w_hsel_wget_AND_w_hready_in_wget_1_AND_NOT_w_h_ETC___d34 ;
  assign master_xactor_f_rd_addr$DEQ =
	     master_xactor_f_rd_addr$EMPTY_N && axi4_initiator_arready ;
  assign master_xactor_f_rd_addr$CLR = EN_reset ;

  // submodule master_xactor_f_rd_data
  assign master_xactor_f_rd_data$D_IN =
	     { axi4_initiator_rid,
	       axi4_initiator_rdata,
	       axi4_initiator_rresp,
	       axi4_initiator_rlast } ;
  assign master_xactor_f_rd_data$ENQ =
	     axi4_initiator_rvalid && master_xactor_f_rd_data$FULL_N ;
  assign master_xactor_f_rd_data$DEQ = CAN_FIRE_RL_rl_rdata ;
  assign master_xactor_f_rd_data$CLR = EN_reset ;

  // submodule master_xactor_f_wr_addr
  assign master_xactor_f_wr_addr$D_IN =
	     { 4'd0, ahbl_target_HADDR, 8'd0, ahbl_target_HSIZE, 18'd65536 } ;
  assign master_xactor_f_wr_addr$ENQ = MUX_rg_wr_rsps_pending$write_1__SEL_1 ;
  assign master_xactor_f_wr_addr$DEQ =
	     master_xactor_f_wr_addr$EMPTY_N && axi4_initiator_awready ;
  assign master_xactor_f_wr_addr$CLR = EN_reset ;

  // submodule master_xactor_f_wr_data
  assign master_xactor_f_wr_data$D_IN =
	     { ahbl_target_HWDATA, strb__h1818, 1'd1 } ;
  assign master_xactor_f_wr_data$ENQ = CAN_FIRE_RL_rl_write_data ;
  assign master_xactor_f_wr_data$DEQ =
	     master_xactor_f_wr_data$EMPTY_N && axi4_initiator_wready ;
  assign master_xactor_f_wr_data$CLR = EN_reset ;

  // submodule master_xactor_f_wr_resp
  assign master_xactor_f_wr_resp$D_IN =
	     { axi4_initiator_bid, axi4_initiator_bresp } ;
  assign master_xactor_f_wr_resp$ENQ =
	     axi4_initiator_bvalid && master_xactor_f_wr_resp$FULL_N ;
  assign master_xactor_f_wr_resp$DEQ = WILL_FIRE_RL_rl_write_rsp ;
  assign master_xactor_f_wr_resp$CLR = EN_reset ;

  // remaining internal signals
  assign IF_w_hwrite_wget_THEN_master_xactor_f_wr_addr__ETC___d16 =
	     ahbl_target_HWRITE ?
	       master_xactor_f_wr_addr$FULL_N && f_wr_data_control$FULL_N :
	       master_xactor_f_rd_addr$FULL_N && f_rd_rsp_control$FULL_N ;
  assign w_hsel_wget_AND_w_hready_in_wget_1_AND_NOT_w_h_ETC___d24 =
	     ahbl_target_HSEL && ahbl_target_HREADY &&
	     ahbl_target_HTRANS != 2'd0 &&
	     ahbl_target_HWRITE ;
  assign w_hsel_wget_AND_w_hready_in_wget_1_AND_NOT_w_h_ETC___d34 =
	     ahbl_target_HSEL && ahbl_target_HREADY &&
	     ahbl_target_HTRANS != 2'd0 &&
	     !ahbl_target_HWRITE ;
  always@(f_wr_data_control$D_OUT)
  begin
    case (f_wr_data_control$D_OUT[13:11])
      3'b0: strb__h1818 = 4'h1;
      3'b001: strb__h1818 = 4'h3;
      3'b010: strb__h1818 = 4'hF;
      default: strb__h1818 = 4'h0;
    endcase
  end

  // handling of inlined registers

  always@(posedge CLK)
  begin
    if (RST_N == `BSV_RESET_VALUE)
      begin
        rg_state <= `BSV_ASSIGNMENT_DELAY 2'd0;
	rg_wr_rsps_pending <= `BSV_ASSIGNMENT_DELAY 2'd0;
	rg_write_error <= `BSV_ASSIGNMENT_DELAY 1'd0;
      end
    else
      begin
        if (rg_state$EN) rg_state <= `BSV_ASSIGNMENT_DELAY rg_state$D_IN;
	if (rg_wr_rsps_pending$EN)
	  rg_wr_rsps_pending <= `BSV_ASSIGNMENT_DELAY rg_wr_rsps_pending$D_IN;
	if (rg_write_error$EN)
	  rg_write_error <= `BSV_ASSIGNMENT_DELAY rg_write_error$D_IN;
      end
    if (rg_rdata$EN) rg_rdata <= `BSV_ASSIGNMENT_DELAY rg_rdata$D_IN;
  end

  // synopsys translate_off
  `ifdef BSV_NO_INITIAL_BLOCKS
  `else // not BSV_NO_INITIAL_BLOCKS
  initial
  begin
    rg_rdata = 32'hAAAAAAAA;
    rg_state = 2'h2;
    rg_wr_rsps_pending = 2'h2;
    rg_write_error = 1'h0;
  end
  `endif // BSV_NO_INITIAL_BLOCKS
  // synopsys translate_on

  // handling of system tasks

  // synopsys translate_off
  always@(negedge CLK)
  begin
    #0;
    if (RST_N != `BSV_RESET_VALUE)
      if (WILL_FIRE_RL_rl_write_rsp && rg_wr_rsps_pending == 2'd0)
	begin
	  v__h2232 = $stime;
	  #0;
	end
    v__h2226 = v__h2232 / 32'd10;
    if (RST_N != `BSV_RESET_VALUE)
      if (WILL_FIRE_RL_rl_write_rsp && rg_wr_rsps_pending == 2'd0)
	$display("%0d: %m.rl_write_rsp: ERROR not expecting any write-response:",
		 v__h2226);
    if (RST_N != `BSV_RESET_VALUE)
      if (WILL_FIRE_RL_rl_write_rsp && rg_wr_rsps_pending == 2'd0)
	$write("    ");
    if (RST_N != `BSV_RESET_VALUE)
      if (WILL_FIRE_RL_rl_write_rsp && rg_wr_rsps_pending == 2'd0)
	$write("AXI4_Wr_Resp { ", "bid: ");
    if (RST_N != `BSV_RESET_VALUE)
      if (WILL_FIRE_RL_rl_write_rsp && rg_wr_rsps_pending == 2'd0)
	$write("'h%h", master_xactor_f_wr_resp$D_OUT[5:2]);
    if (RST_N != `BSV_RESET_VALUE)
      if (WILL_FIRE_RL_rl_write_rsp && rg_wr_rsps_pending == 2'd0)
	$write(", ", "bresp: ");
    if (RST_N != `BSV_RESET_VALUE)
      if (WILL_FIRE_RL_rl_write_rsp && rg_wr_rsps_pending == 2'd0)
	$write("'h%h", master_xactor_f_wr_resp$D_OUT[1:0]);
    if (RST_N != `BSV_RESET_VALUE)
      if (WILL_FIRE_RL_rl_write_rsp && rg_wr_rsps_pending == 2'd0)
	$write(", ", "buser: ");
    if (RST_N != `BSV_RESET_VALUE)
      if (WILL_FIRE_RL_rl_write_rsp && rg_wr_rsps_pending == 2'd0)
	$write("'h%h", 1'd0, " }");
    if (RST_N != `BSV_RESET_VALUE)
      if (WILL_FIRE_RL_rl_write_rsp && rg_wr_rsps_pending == 2'd0)
	$write("\n");
  end
  // synopsys translate_on
endmodule  // mkAHBL_Target_AXI4_Initiator

