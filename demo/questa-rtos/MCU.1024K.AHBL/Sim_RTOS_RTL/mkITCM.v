//
// Generated by Bluespec Compiler, version 2021.12.1-27-g9a7d5e05 (build 9a7d5e05)
//
//
// Ports:
// Name                         I/O  size props
// RDY_server_reset_request_put   O     1 reg
// RDY_server_reset_response_get  O     1
// RDY_imem_req                   O     1
// imem_instr                     O    37
// RDY_imem_instr                 O     1
// verbosity                      I     2
// CLK                            I     1 clock
// RST_N                          I     1 reset
// imem_req_addr                  I    32
// EN_server_reset_request_put    I     1
// EN_server_reset_response_get   I     1
// EN_imem_req                    I     1
// EN_imem_instr                  I     1
//
// No combinational paths from inputs to outputs
//
//

`ifdef BSV_ASSIGNMENT_DELAY
`else
  `define BSV_ASSIGNMENT_DELAY
`endif

`ifdef BSV_POSITIVE_RESET
  `define BSV_RESET_VALUE 1'b1
  `define BSV_RESET_EDGE posedge
`else
  `define BSV_RESET_VALUE 1'b0
  `define BSV_RESET_EDGE negedge
`endif

module mkITCM(verbosity,
	      CLK,
	      RST_N,

	      EN_server_reset_request_put,
	      RDY_server_reset_request_put,

	      EN_server_reset_response_get,
	      RDY_server_reset_response_get,

	      imem_req_addr,
	      EN_imem_req,
	      RDY_imem_req,

	      EN_imem_instr,
	      imem_instr,
	      RDY_imem_instr);
  input  [1 : 0] verbosity;
  input  CLK;
  input  RST_N;

  // action method server_reset_request_put
  input  EN_server_reset_request_put;
  output RDY_server_reset_request_put;

  // action method server_reset_response_get
  input  EN_server_reset_response_get;
  output RDY_server_reset_response_get;

  // action method imem_req
  input  [31 : 0] imem_req_addr;
  input  EN_imem_req;
  output RDY_imem_req;

  // actionvalue method imem_instr
  input  EN_imem_instr;
  output [36 : 0] imem_instr;
  output RDY_imem_instr;

  // signals for module outputs
  wire [36 : 0] imem_instr;
  wire RDY_imem_instr,
       RDY_imem_req,
       RDY_server_reset_request_put,
       RDY_server_reset_response_get;

  // register rg_rsp_exc
  reg [4 : 0] rg_rsp_exc;
  wire [4 : 0] rg_rsp_exc$D_IN;
  wire rg_rsp_exc$EN;

  // register rg_state
  reg rg_state;
  wire rg_state$D_IN, rg_state$EN;

  // ports of submodule addr_map
  wire [31 : 0] addr_map$m_is_dtcm_addr_addr, addr_map$m_is_itcm_addr_addr;
  wire addr_map$m_is_itcm_addr;

  // ports of submodule f_reset_rsps
  wire f_reset_rsps$CLR,
       f_reset_rsps$DEQ,
       f_reset_rsps$EMPTY_N,
       f_reset_rsps$ENQ,
       f_reset_rsps$FULL_N;

  // ports of submodule mem
  wire [31 : 0] mem$DI, mem$DO;
  wire [17 : 0] mem$ADDR;
  wire mem$EN, mem$WE;

  // ports of submodule rg_rsp_valid
  wire rg_rsp_valid$CLR,
       rg_rsp_valid$DEQ,
       rg_rsp_valid$EMPTY_N,
       rg_rsp_valid$ENQ,
       rg_rsp_valid$FULL_N;

  // rule scheduling signals
  wire CAN_FIRE_RL_rl_reset,
       CAN_FIRE_imem_instr,
       CAN_FIRE_imem_req,
       CAN_FIRE_server_reset_request_put,
       CAN_FIRE_server_reset_response_get,
       WILL_FIRE_RL_rl_reset,
       WILL_FIRE_imem_instr,
       WILL_FIRE_imem_req,
       WILL_FIRE_server_reset_request_put,
       WILL_FIRE_server_reset_response_get;

  // inputs to muxes for submodule ports
  wire [4 : 0] MUX_rg_rsp_exc$write_1__VAL_2;

  // declarations used by system tasks
  // synopsys translate_off
  reg [31 : 0] v__h1256;
  reg [31 : 0] v__h918;
  reg [31 : 0] v__h832;
  reg [31 : 0] v__h1102;
  reg [31 : 0] v__h826;
  reg [31 : 0] v__h912;
  reg [31 : 0] v__h1096;
  reg [31 : 0] v__h1250;
  // synopsys translate_on

  // remaining internal signals
  wire NOT_verbosity_ULE_1_4___d25;

  // action method server_reset_request_put
  assign RDY_server_reset_request_put = f_reset_rsps$FULL_N ;
  assign CAN_FIRE_server_reset_request_put = f_reset_rsps$FULL_N ;
  assign WILL_FIRE_server_reset_request_put = EN_server_reset_request_put ;

  // action method server_reset_response_get
  assign RDY_server_reset_response_get = rg_state && f_reset_rsps$EMPTY_N ;
  assign CAN_FIRE_server_reset_response_get =
	     rg_state && f_reset_rsps$EMPTY_N ;
  assign WILL_FIRE_server_reset_response_get = EN_server_reset_response_get ;

  // action method imem_req
  assign RDY_imem_req = rg_state && rg_rsp_valid$FULL_N ;
  assign CAN_FIRE_imem_req = rg_state && rg_rsp_valid$FULL_N ;
  assign WILL_FIRE_imem_req = EN_imem_req ;

  // actionvalue method imem_instr
  assign imem_instr = { mem$DO, rg_rsp_exc } ;
  assign RDY_imem_instr = rg_state && rg_rsp_valid$EMPTY_N ;
  assign CAN_FIRE_imem_instr = rg_state && rg_rsp_valid$EMPTY_N ;
  assign WILL_FIRE_imem_instr = EN_imem_instr ;

  // submodule addr_map
  mkCore_Map addr_map(.CLK(CLK),
		      .RST_N(RST_N),
		      .m_is_dtcm_addr_addr(addr_map$m_is_dtcm_addr_addr),
		      .m_is_itcm_addr_addr(addr_map$m_is_itcm_addr_addr),
		      .m_itcm_addr_base(),
		      .m_itcm_addr_size(),
		      .m_itcm_addr_lim(),
		      .m_is_itcm_addr(addr_map$m_is_itcm_addr),
		      .m_dtcm_addr_base(),
		      .m_dtcm_addr_size(),
		      .m_dtcm_addr_lim(),
		      .m_is_dtcm_addr(),
		      .m_pc_reset_value(),
		      .m_mtvec_reset_value());

  // submodule f_reset_rsps
  FIFO10 #(.guarded(1'd1)) f_reset_rsps(.RST(RST_N),
					.CLK(CLK),
					.ENQ(f_reset_rsps$ENQ),
					.DEQ(f_reset_rsps$DEQ),
					.CLR(f_reset_rsps$CLR),
					.FULL_N(f_reset_rsps$FULL_N),
					.EMPTY_N(f_reset_rsps$EMPTY_N));

  // submodule mem
  BRAM1Load #(.FILENAME("/tmp/itcm.mem"),
	      .PIPELINED(1'd0),
	      .ADDR_WIDTH(32'd18),
	      .DATA_WIDTH(32'd32),
	      .MEMSIZE(19'd262144),
	      .BINARY(1'd0)) mem(.CLK(CLK),
				 .ADDR(mem$ADDR),
				 .DI(mem$DI),
				 .WE(mem$WE),
				 .EN(mem$EN),
				 .DO(mem$DO));

  // submodule rg_rsp_valid
  FIFO20 #(.guarded(1'd1)) rg_rsp_valid(.RST(RST_N),
					.CLK(CLK),
					.ENQ(rg_rsp_valid$ENQ),
					.DEQ(rg_rsp_valid$DEQ),
					.CLR(rg_rsp_valid$CLR),
					.FULL_N(rg_rsp_valid$FULL_N),
					.EMPTY_N(rg_rsp_valid$EMPTY_N));

  // rule RL_rl_reset
  assign CAN_FIRE_RL_rl_reset = !rg_state ;
  assign WILL_FIRE_RL_rl_reset = CAN_FIRE_RL_rl_reset ;

  // inputs to muxes for submodule ports
  assign MUX_rg_rsp_exc$write_1__VAL_2 =
	     { imem_req_addr[1:0] != 2'b0 || !addr_map$m_is_itcm_addr,
	       (imem_req_addr[1:0] == 2'b0) ? 4'd1 : 4'd0 } ;

  // register rg_rsp_exc
  assign rg_rsp_exc$D_IN =
	     WILL_FIRE_RL_rl_reset ? 5'd10 : MUX_rg_rsp_exc$write_1__VAL_2 ;
  assign rg_rsp_exc$EN = WILL_FIRE_RL_rl_reset || EN_imem_req ;

  // register rg_state
  assign rg_state$D_IN = !EN_server_reset_request_put ;
  assign rg_state$EN = EN_server_reset_request_put || WILL_FIRE_RL_rl_reset ;

  // submodule addr_map
  assign addr_map$m_is_dtcm_addr_addr = 32'h0 ;
  assign addr_map$m_is_itcm_addr_addr = imem_req_addr ;

  // submodule f_reset_rsps
  assign f_reset_rsps$ENQ = EN_server_reset_request_put ;
  assign f_reset_rsps$DEQ = EN_server_reset_response_get ;
  assign f_reset_rsps$CLR = 1'b0 ;

  // submodule mem
  assign mem$ADDR = imem_req_addr[19:2] ;
  assign mem$DI = 32'hAAAAAAAA /* unspecified value */  ;
  assign mem$WE = 1'd0 ;
  assign mem$EN = EN_imem_req ;

  // submodule rg_rsp_valid
  assign rg_rsp_valid$ENQ = EN_imem_req ;
  assign rg_rsp_valid$DEQ = EN_imem_instr ;
  assign rg_rsp_valid$CLR = CAN_FIRE_RL_rl_reset ;

  // remaining internal signals
  assign NOT_verbosity_ULE_1_4___d25 = verbosity > 2'd1 ;

  // handling of inlined registers

  always@(posedge CLK)
  begin
    if (RST_N == `BSV_RESET_VALUE)
      begin
        rg_rsp_exc <= `BSV_ASSIGNMENT_DELAY 5'd10;
	rg_state <= `BSV_ASSIGNMENT_DELAY 1'd0;
      end
    else
      begin
        if (rg_rsp_exc$EN)
	  rg_rsp_exc <= `BSV_ASSIGNMENT_DELAY rg_rsp_exc$D_IN;
	if (rg_state$EN) rg_state <= `BSV_ASSIGNMENT_DELAY rg_state$D_IN;
      end
  end

  // synopsys translate_off
  `ifdef BSV_NO_INITIAL_BLOCKS
  `else // not BSV_NO_INITIAL_BLOCKS
  initial
  begin
    rg_rsp_exc = 5'h0A;
    rg_state = 1'h0;
  end
  `endif // BSV_NO_INITIAL_BLOCKS
  // synopsys translate_on

  // handling of system tasks

  // synopsys translate_off
  always@(negedge CLK)
  begin
    #0;
    if (RST_N != `BSV_RESET_VALUE)
      if (EN_imem_instr && verbosity != 2'd0)
	begin
	  v__h1256 = $stime;
	  #0;
	end
    v__h1250 = v__h1256 / 32'd10;
    if (RST_N != `BSV_RESET_VALUE)
      if (EN_imem_instr && verbosity != 2'd0)
	$display("%06d:[D]:%m.imem.instr", v__h1250);
    if (RST_N != `BSV_RESET_VALUE)
      if (EN_imem_instr && verbosity != 2'd0 && NOT_verbosity_ULE_1_4___d25)
	$write("           (instr 0x%08h) (exc ", mem$DO);
    if (RST_N != `BSV_RESET_VALUE)
      if (EN_imem_instr && verbosity != 2'd0 && NOT_verbosity_ULE_1_4___d25 &&
	  rg_rsp_exc[4])
	$write("tagged Valid ", "'h%h", rg_rsp_exc[3:0]);
    if (RST_N != `BSV_RESET_VALUE)
      if (EN_imem_instr && verbosity != 2'd0 && NOT_verbosity_ULE_1_4___d25 &&
	  !rg_rsp_exc[4])
	$write("tagged Invalid ", "");
    if (RST_N != `BSV_RESET_VALUE)
      if (EN_imem_instr && verbosity != 2'd0 && NOT_verbosity_ULE_1_4___d25)
	$write(")", "\n");
    if (RST_N != `BSV_RESET_VALUE)
      if (EN_imem_req && imem_req_addr[1:0] == 2'b0 &&
	  !addr_map$m_is_itcm_addr)
	begin
	  v__h918 = $stime;
	  #0;
	end
    v__h912 = v__h918 / 32'd10;
    if (RST_N != `BSV_RESET_VALUE)
      if (EN_imem_req && imem_req_addr[1:0] == 2'b0 &&
	  !addr_map$m_is_itcm_addr)
	$display("%06d:[E]:%m.req: INSTR_ACCESS_FAULT", v__h912);
    if (RST_N != `BSV_RESET_VALUE)
      if (EN_imem_req && imem_req_addr[1:0] != 2'b0)
	begin
	  v__h832 = $stime;
	  #0;
	end
    v__h826 = v__h832 / 32'd10;
    if (RST_N != `BSV_RESET_VALUE)
      if (EN_imem_req && imem_req_addr[1:0] != 2'b0)
	$display("%06d:[E]:%m.req: INSTR_ADDR_MISALIGNED", v__h826);
    if (RST_N != `BSV_RESET_VALUE)
      if (EN_imem_req && verbosity != 2'd0)
	begin
	  v__h1102 = $stime;
	  #0;
	end
    v__h1096 = v__h1102 / 32'd10;
    if (RST_N != `BSV_RESET_VALUE)
      if (EN_imem_req && verbosity != 2'd0)
	$display("%06d:[D]:%m.imem.req", v__h1096);
    if (RST_N != `BSV_RESET_VALUE)
      if (EN_imem_req && verbosity != 2'd0 && NOT_verbosity_ULE_1_4___d25)
	$display("           (addr 0x%08h)", imem_req_addr);
  end
  // synopsys translate_on
endmodule  // mkITCM

